457
#method_before
private void dequeueMcastEvent(McastEvent mcastEvent) {
    final McastRouteUpdate mcastUpdate = mcastEvent.subject();
    final McastRouteUpdate mcastPrevUpdate = mcastEvent.prevSubject();
    IpAddress mcastIp = mcastPrevUpdate.route().group();
    Set<ConnectPoint> prevSinks = mcastPrevUpdate.sinks().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
    Set<ConnectPoint> prevSources = mcastPrevUpdate.sources();
    Set<ConnectPoint> sources;
    switch(mcastEvent.type()) {
        case SOURCES_ADDED:
            sources = mcastUpdate.sources();
            Set<ConnectPoint> sourcesToBeAdded = Sets.difference(sources, prevSources);
            processSourcesAddedInternal(sourcesToBeAdded, mcastIp, mcastUpdate.sinks());
            break;
        case SOURCES_REMOVED:
            sources = mcastUpdate.sources();
            Set<ConnectPoint> sourcesToBeRemoved = Sets.difference(prevSources, sources);
            processSourcesRemovedInternal(sourcesToBeRemoved, sources, mcastIp, mcastUpdate.sinks());
            break;
        case ROUTE_REMOVED:
            processRouteRemovedInternal(prevSources, mcastIp);
            break;
        case SINKS_ADDED:
            processSinksAddedInternal(prevSources, mcastIp, mcastUpdate.sinks(), prevSinks);
            break;
        case SINKS_REMOVED:
            processSinksRemovedInternal(prevSources, mcastIp, mcastUpdate.sinks(), mcastPrevUpdate.sinks());
            break;
        default:
            break;
    }
}
#method_after
private void dequeueMcastEvent(McastEvent mcastEvent) {
    final McastRouteUpdate mcastUpdate = mcastEvent.subject();
    final McastRouteUpdate mcastPrevUpdate = mcastEvent.prevSubject();
    IpAddress mcastIp = mcastPrevUpdate.route().group();
    Set<ConnectPoint> prevSinks = mcastPrevUpdate.sinks().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
    Set<ConnectPoint> prevSources = mcastPrevUpdate.sources().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
    Set<ConnectPoint> sources;
    switch(mcastEvent.type()) {
        case SOURCES_ADDED:
            sources = mcastUpdate.sources().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
            Set<ConnectPoint> sourcesToBeAdded = Sets.difference(sources, prevSources);
            processSourcesAddedInternal(sourcesToBeAdded, mcastIp, mcastUpdate.sinks());
            break;
        case SOURCES_REMOVED:
            sources = mcastUpdate.sources().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
            Set<ConnectPoint> sourcesToBeRemoved = Sets.difference(prevSources, sources);
            processSourcesRemovedInternal(sourcesToBeRemoved, sources, mcastIp, mcastUpdate.sinks());
            break;
        case ROUTE_REMOVED:
            processRouteRemovedInternal(prevSources, mcastIp);
            break;
        case SINKS_ADDED:
            processSinksAddedInternal(prevSources, mcastIp, mcastUpdate.sinks(), prevSinks);
            break;
        case SINKS_REMOVED:
            processSinksRemovedInternal(prevSources, mcastIp, mcastUpdate.sinks(), mcastPrevUpdate.sinks());
            break;
        default:
            break;
    }
}
#end_block

#method_before
public void init() {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        srManager.multicastRouteService.getRoutes().forEach(mcastRoute -> {
            log.debug("Init group {}", mcastRoute.group());
            if (!mcastUtils.isLeader(mcastRoute.group())) {
                log.debug("Skip {} due to lack of leadership", mcastRoute.group());
                return;
            }
            McastRouteData mcastRouteData = srManager.multicastRouteService.routeData(mcastRoute);
            // For each source process the mcast tree
            srManager.multicastRouteService.sources(mcastRoute).forEach(source -> {
                Map<ConnectPoint, List<ConnectPoint>> mcastPaths = Maps.newHashMap();
                Set<DeviceId> visited = Sets.newHashSet();
                List<ConnectPoint> currentPath = Lists.newArrayList(source);
                buildMcastPaths(source.deviceId(), visited, mcastPaths, currentPath, mcastRoute.group(), source);
                // Get all the sinks and process them
                Set<ConnectPoint> sinks = processSinksToBeAdded(source, mcastRoute.group(), mcastRouteData.sinks());
                // Filter out all the working sinks, we do not want to move them
                sinks = sinks.stream().filter(sink -> !mcastPaths.containsKey(sink)).collect(Collectors.toSet());
                if (sinks.isEmpty()) {
                    log.debug("Skip {} for source {} nothing to do", mcastRoute.group(), source);
                    return;
                }
                Map<ConnectPoint, List<Path>> mcasTree = computeSinkMcastTree(source.deviceId(), sinks);
                mcasTree.forEach((sink, paths) -> processSinkAddedInternal(source, sink, mcastRoute.group(), paths));
            });
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
public void init() {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        srManager.multicastRouteService.getRoutes().forEach(mcastRoute -> {
            log.debug("Init group {}", mcastRoute.group());
            if (!mcastUtils.isLeader(mcastRoute.group())) {
                log.debug("Skip {} due to lack of leadership", mcastRoute.group());
                return;
            }
            McastRouteData mcastRouteData = srManager.multicastRouteService.routeData(mcastRoute);
            // For each source process the mcast tree
            srManager.multicastRouteService.sources(mcastRoute).forEach(source -> {
                Map<ConnectPoint, List<ConnectPoint>> mcastPaths = Maps.newHashMap();
                Set<DeviceId> visited = Sets.newHashSet();
                List<ConnectPoint> currentPath = Lists.newArrayList(source);
                buildMcastPaths(source.deviceId(), visited, mcastPaths, currentPath, mcastRoute.group(), source);
                // Get all the sinks and process them
                Set<ConnectPoint> sinks = processSinksToBeAdded(source, mcastRoute.group(), mcastRouteData.sinks());
                // Filter out all the working sinks, we do not want to move them
                // TODO we need a better way to distinguish flows coming from different sources
                sinks = sinks.stream().filter(sink -> !mcastPaths.containsKey(sink) || !isSinkForSource(mcastRoute.group(), sink, source)).collect(Collectors.toSet());
                if (sinks.isEmpty()) {
                    log.debug("Skip {} for source {} nothing to do", mcastRoute.group(), source);
                    return;
                }
                Map<ConnectPoint, List<Path>> mcasTree = computeSinkMcastTree(source.deviceId(), sinks);
                mcasTree.forEach((sink, paths) -> processSinkAddedInternal(source, sink, mcastRoute.group(), paths));
            });
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void processSourcesRemovedInternal(Set<ConnectPoint> sourcesToBeRemoved, Set<ConnectPoint> remainingSources, IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> sinks) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        log.debug("Processing sources removed {} for group {}", sourcesToBeRemoved, mcastIp);
        if (!mcastUtils.isLeader(mcastIp)) {
            log.debug("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        Set<Link> remainingLinks = Sets.newHashSet();
        Map<ConnectPoint, Set<Link>> candidateLinks = Maps.newHashMap();
        Map<ConnectPoint, Set<ConnectPoint>> candidateSinks = Maps.newHashMap();
        Set<ConnectPoint> totalSources = Sets.newHashSet(sourcesToBeRemoved);
        totalSources.addAll(remainingSources);
        // Calculate all the links used by the sources
        totalSources.forEach(source -> {
            Set<ConnectPoint> currentSinks = sinks.values().stream().flatMap(Collection::stream).filter(sink -> isSinkForSource(mcastIp, sink, source)).collect(Collectors.toSet());
            candidateSinks.put(source, currentSinks);
            currentSinks.forEach(currentSink -> {
                Optional<Path> currentPath = getPath(source.deviceId(), currentSink.deviceId(), mcastIp, null, source);
                if (currentPath.isPresent()) {
                    if (!sourcesToBeRemoved.contains(source)) {
                        remainingLinks.addAll(currentPath.get().links());
                    } else {
                        candidateLinks.put(source, Sets.newHashSet(currentPath.get().links()));
                    }
                }
            });
        });
        // Clean transit links
        candidateLinks.forEach((source, currentCandidateLinks) -> {
            Set<Link> linksToBeRemoved = Sets.difference(currentCandidateLinks, remainingLinks).immutableCopy();
            if (!linksToBeRemoved.isEmpty()) {
                currentCandidateLinks.forEach(link -> {
                    DeviceId srcLink = link.src().deviceId();
                    // Remove ports only on links to be removed
                    if (linksToBeRemoved.contains(link)) {
                        removePortFromDevice(link.src().deviceId(), link.src().port(), mcastIp, mcastUtils.assignedVlan(srcLink.equals(source.deviceId()) ? source : null));
                    }
                    // Remove role on the candidate links
                    mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, srcLink, source));
                });
            }
        });
        // Clean ingress and egress
        sourcesToBeRemoved.forEach(source -> {
            Set<ConnectPoint> currentSinks = candidateSinks.get(source);
            currentSinks.forEach(currentSink -> {
                VlanId assignedVlan = mcastUtils.assignedVlan(source.deviceId().equals(currentSink.deviceId()) ? source : null);
                // Sinks co-located with the source
                if (source.deviceId().equals(currentSink.deviceId())) {
                    if (source.port().equals(currentSink.port())) {
                        log.warn("Skip {} since sink {} is on the same port of source {}. Abort", mcastIp, currentSink, source);
                        return;
                    }
                    // We need to check against the other sources and if it is
                    // necessary remove the port from the device - no overlap
                    Set<VlanId> otherVlans = remainingSources.stream().filter(remainingSource -> remainingSource.deviceId().equals(source.deviceId()) && candidateSinks.get(remainingSource).contains(currentSink)).map(remainingSource -> mcastUtils.assignedVlan(remainingSource.deviceId().equals(currentSink.deviceId()) ? remainingSource : null)).collect(Collectors.toSet());
                    if (!otherVlans.contains(assignedVlan)) {
                        removePortFromDevice(currentSink.deviceId(), currentSink.port(), mcastIp, assignedVlan);
                    }
                    mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, currentSink.deviceId(), source));
                    return;
                }
                Set<VlanId> otherVlans = remainingSources.stream().filter(remainingSource -> candidateSinks.get(remainingSource).contains(currentSink)).map(remainingSource -> mcastUtils.assignedVlan(remainingSource.deviceId().equals(currentSink.deviceId()) ? remainingSource : null)).collect(Collectors.toSet());
                // Sinks on other leaves
                if (!otherVlans.contains(assignedVlan)) {
                    removePortFromDevice(currentSink.deviceId(), currentSink.port(), mcastIp, assignedVlan);
                }
                mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, currentSink.deviceId(), source));
            });
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processSourcesRemovedInternal(Set<ConnectPoint> sourcesToBeRemoved, Set<ConnectPoint> remainingSources, IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> sinks) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        log.debug("Processing sources removed {} for group {}", sourcesToBeRemoved, mcastIp);
        if (!mcastUtils.isLeader(mcastIp)) {
            log.debug("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        if (remainingSources.isEmpty()) {
            processRouteRemovedInternal(sourcesToBeRemoved, mcastIp);
            return;
        }
        // Skip offline devices
        Set<ConnectPoint> candidateSources = sourcesToBeRemoved.stream().filter(source -> srManager.deviceService.isAvailable(source.deviceId())).collect(Collectors.toSet());
        if (candidateSources.isEmpty()) {
            log.debug("Skip {} due to empty sources to be removed", mcastIp);
            return;
        }
        Set<Link> remainingLinks = Sets.newHashSet();
        Map<ConnectPoint, Set<Link>> candidateLinks = Maps.newHashMap();
        Map<ConnectPoint, Set<ConnectPoint>> candidateSinks = Maps.newHashMap();
        Set<ConnectPoint> totalSources = Sets.newHashSet(candidateSources);
        totalSources.addAll(remainingSources);
        // Calculate all the links used by the sources
        totalSources.forEach(source -> {
            Set<ConnectPoint> currentSinks = sinks.values().stream().flatMap(Collection::stream).filter(sink -> isSinkForSource(mcastIp, sink, source)).collect(Collectors.toSet());
            candidateSinks.put(source, currentSinks);
            currentSinks.forEach(currentSink -> {
                Optional<Path> currentPath = getPath(source.deviceId(), currentSink.deviceId(), mcastIp, null, source);
                if (currentPath.isPresent()) {
                    if (!candidateSources.contains(source)) {
                        remainingLinks.addAll(currentPath.get().links());
                    } else {
                        candidateLinks.put(source, Sets.newHashSet(currentPath.get().links()));
                    }
                }
            });
        });
        // Clean transit links
        candidateLinks.forEach((source, currentCandidateLinks) -> {
            Set<Link> linksToBeRemoved = Sets.difference(currentCandidateLinks, remainingLinks).immutableCopy();
            if (!linksToBeRemoved.isEmpty()) {
                currentCandidateLinks.forEach(link -> {
                    DeviceId srcLink = link.src().deviceId();
                    // Remove ports only on links to be removed
                    if (linksToBeRemoved.contains(link)) {
                        removePortFromDevice(link.src().deviceId(), link.src().port(), mcastIp, mcastUtils.assignedVlan(srcLink.equals(source.deviceId()) ? source : null));
                    }
                    // Remove role on the candidate links
                    mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, srcLink, source));
                });
            }
        });
        // Clean ingress and egress
        candidateSources.forEach(source -> {
            Set<ConnectPoint> currentSinks = candidateSinks.get(source);
            currentSinks.forEach(currentSink -> {
                VlanId assignedVlan = mcastUtils.assignedVlan(source.deviceId().equals(currentSink.deviceId()) ? source : null);
                // Sinks co-located with the source
                if (source.deviceId().equals(currentSink.deviceId())) {
                    if (source.port().equals(currentSink.port())) {
                        log.warn("Skip {} since sink {} is on the same port of source {}. Abort", mcastIp, currentSink, source);
                        return;
                    }
                    // We need to check against the other sources and if it is
                    // necessary remove the port from the device - no overlap
                    Set<VlanId> otherVlans = remainingSources.stream().filter(remainingSource -> remainingSource.deviceId().equals(source.deviceId()) && candidateSinks.get(remainingSource).contains(currentSink)).map(remainingSource -> mcastUtils.assignedVlan(remainingSource.deviceId().equals(currentSink.deviceId()) ? remainingSource : null)).collect(Collectors.toSet());
                    if (!otherVlans.contains(assignedVlan)) {
                        removePortFromDevice(currentSink.deviceId(), currentSink.port(), mcastIp, assignedVlan);
                    }
                    mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, currentSink.deviceId(), source));
                    return;
                }
                Set<VlanId> otherVlans = remainingSources.stream().filter(remainingSource -> candidateSinks.get(remainingSource).contains(currentSink)).map(remainingSource -> mcastUtils.assignedVlan(remainingSource.deviceId().equals(currentSink.deviceId()) ? remainingSource : null)).collect(Collectors.toSet());
                // Sinks on other leaves
                if (!otherVlans.contains(assignedVlan)) {
                    removePortFromDevice(currentSink.deviceId(), currentSink.port(), mcastIp, assignedVlan);
                }
                mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, currentSink.deviceId(), source));
            });
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void processSinksRemovedInternal(Set<ConnectPoint> sources, IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> newSinks, Map<HostId, Set<ConnectPoint>> prevSinks) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        if (!mcastUtils.isLeader(mcastIp)) {
            log.debug("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        log.debug("Processing sinks removed for group {} and for sources {}", mcastIp, sources);
        Map<ConnectPoint, Map<ConnectPoint, Optional<Path>>> treesToBeRemoved = Maps.newHashMap();
        Map<ConnectPoint, Set<ConnectPoint>> treesToBeAdded = Maps.newHashMap();
        sources.forEach(source -> {
            // Save the path associated to the sinks to be removed
            Set<ConnectPoint> sinksToBeRemoved = processSinksToBeRemoved(mcastIp, prevSinks, newSinks, source);
            Map<ConnectPoint, Optional<Path>> treeToBeRemoved = Maps.newHashMap();
            sinksToBeRemoved.forEach(sink -> treeToBeRemoved.put(sink, getPath(source.deviceId(), sink.deviceId(), mcastIp, null, source)));
            treesToBeRemoved.put(source, treeToBeRemoved);
            // Recover the dual-homed sinks
            Set<ConnectPoint> sinksToBeRecovered = processSinksToBeRecovered(mcastIp, newSinks, prevSinks, source);
            treesToBeAdded.put(source, sinksToBeRecovered);
        });
        // Add new sinks according to the recovery procedure
        treesToBeAdded.forEach((source, sinks) -> sinks.forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, null)));
        // Remove the sinks taking into account the multiple sources and the original paths
        treesToBeRemoved.forEach((source, tree) -> tree.forEach((sink, path) -> processSinkRemovedInternal(source, sink, mcastIp, path)));
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processSinksRemovedInternal(Set<ConnectPoint> sources, IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> newSinks, Map<HostId, Set<ConnectPoint>> prevSinks) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        if (!mcastUtils.isLeader(mcastIp)) {
            log.debug("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        log.debug("Processing sinks removed for group {} and for sources {}", mcastIp, sources);
        Map<ConnectPoint, Map<ConnectPoint, Optional<Path>>> treesToBeRemoved = Maps.newHashMap();
        Map<ConnectPoint, Set<ConnectPoint>> treesToBeAdded = Maps.newHashMap();
        sources.forEach(source -> {
            // Save the path associated to the sinks to be removed
            Set<ConnectPoint> sinksToBeRemoved = processSinksToBeRemoved(mcastIp, prevSinks, newSinks, source);
            Map<ConnectPoint, Optional<Path>> treeToBeRemoved = Maps.newHashMap();
            sinksToBeRemoved.forEach(sink -> treeToBeRemoved.put(sink, getPath(source.deviceId(), sink.deviceId(), mcastIp, null, source)));
            treesToBeRemoved.put(source, treeToBeRemoved);
            // Recover the dual-homed sinks
            Set<ConnectPoint> sinksToBeRecovered = processSinksToBeRecovered(mcastIp, newSinks, prevSinks, source);
            treesToBeAdded.put(source, sinksToBeRecovered);
        });
        // Remove the sinks taking into account the multiple sources and the original paths
        treesToBeRemoved.forEach((source, tree) -> tree.forEach((sink, path) -> processSinkRemovedInternal(source, sink, mcastIp, path)));
        // Add new sinks according to the recovery procedure
        treesToBeAdded.forEach((source, sinks) -> sinks.forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, null)));
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void recoverFailure(IpAddress mcastIp, Object failedElement) {
    // TODO Optimize when the group editing is in place
    if (!mcastUtils.isLeader(mcastIp)) {
        log.debug("Skip {} due to lack of leadership", mcastIp);
        return;
    }
    // Do not proceed if the sources of this group are missing
    Set<ConnectPoint> sources = mcastUtils.getSources(mcastIp);
    if (sources.isEmpty()) {
        log.warn("Missing sources for group {}", mcastIp);
        return;
    }
    // Find out the ingress devices of the affected group
    // If sinks are in other leafs, we have ingress, transit, egress, and source
    // If sinks are in the same leaf, we have just ingress and source
    Set<DeviceId> ingressDevices = getDevice(mcastIp, INGRESS);
    if (ingressDevices.isEmpty()) {
        log.warn("Missing ingress devices for group {}", ingressDevices, mcastIp);
        return;
    }
    // For each tree, delete ingress-transit part
    sources.forEach(source -> {
        Set<DeviceId> transitDevices = getDevice(mcastIp, TRANSIT, source);
        transitDevices.forEach(transitDevice -> {
            removeGroupFromDevice(transitDevice, mcastIp, mcastUtils.assignedVlan(null));
            mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, transitDevice, source));
        });
    });
    removeIngressTransitPorts(mcastIp, ingressDevices, sources);
    // TODO Evaluate the possibility of building optimize trees between sources
    // let's compute the mcast tree
    Map<DeviceId, Set<ConnectPoint>> notRecovered = Maps.newHashMap();
    sources.forEach(source -> {
        Set<DeviceId> notRecoveredInternal = Sets.newHashSet();
        DeviceId ingressDevice = ingressDevices.stream().filter(deviceId -> deviceId.equals(source.deviceId())).findFirst().orElse(null);
        // Just skip if ingress does not exist
        if (ingressDevice == null) {
            log.warn("Skip failure recovery - " + "Missing ingress for source {} and group {}", source, mcastIp);
            return;
        }
        Set<DeviceId> egressDevices = getDevice(mcastIp, EGRESS, source);
        Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, egressDevices);
        // We have to verify, if there are egresses without paths
        mcastTree.forEach((egressDevice, paths) -> {
            Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths, source);
            // No paths, we have to try with alternative location
            if (!mcastPath.isPresent()) {
                notRecovered.compute(egressDevice, (deviceId, listSources) -> {
                    listSources = listSources == null ? Sets.newHashSet() : listSources;
                    listSources.add(source);
                    return listSources;
                });
                notRecoveredInternal.add(egressDevice);
            }
        });
        // Fast path, we can recover all the locations
        if (notRecoveredInternal.isEmpty()) {
            mcastTree.forEach((egressDevice, paths) -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths, source);
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                }
            });
        } else {
            // Let's try to recover using alternative locations
            recoverSinks(egressDevices, notRecovered.keySet(), mcastIp, ingressDevice, source);
        }
    });
    // Finally remove the egresses not recovered
    notRecovered.forEach((egressDevice, listSources) -> {
        Set<ConnectPoint> currentSources = getSources(mcastIp, egressDevice, EGRESS);
        if (Objects.equal(currentSources, listSources)) {
            log.warn("Fail to recover egress device {} from {} failure {}", egressDevice, failedElement instanceof Link ? "Link" : "Device", failedElement);
            removeGroupFromDevice(egressDevice, mcastIp, mcastUtils.assignedVlan(null));
        }
        listSources.forEach(source -> mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, egressDevice, source)));
    });
}
#method_after
private void recoverFailure(IpAddress mcastIp, Object failedElement) {
    // TODO Optimize when the group editing is in place
    if (!mcastUtils.isLeader(mcastIp)) {
        log.debug("Skip {} due to lack of leadership", mcastIp);
        return;
    }
    // Do not proceed if the sources of this group are missing
    Set<ConnectPoint> sources = getSources(mcastIp);
    if (sources.isEmpty()) {
        log.warn("Missing sources for group {}", mcastIp);
        return;
    }
    // Find out the ingress devices of the affected group
    // If sinks are in other leafs, we have ingress, transit, egress, and source
    // If sinks are in the same leaf, we have just ingress and source
    Set<DeviceId> ingressDevices = getDevice(mcastIp, INGRESS);
    if (ingressDevices.isEmpty()) {
        log.warn("Missing ingress devices for group {}", ingressDevices, mcastIp);
        return;
    }
    // For each tree, delete ingress-transit part
    sources.forEach(source -> {
        Set<DeviceId> transitDevices = getDevice(mcastIp, TRANSIT, source);
        transitDevices.forEach(transitDevice -> {
            removeGroupFromDevice(transitDevice, mcastIp, mcastUtils.assignedVlan(null));
            mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, transitDevice, source));
        });
    });
    removeIngressTransitPorts(mcastIp, ingressDevices, sources);
    // TODO Evaluate the possibility of building optimize trees between sources
    Map<DeviceId, Set<ConnectPoint>> notRecovered = Maps.newHashMap();
    sources.forEach(source -> {
        Set<DeviceId> notRecoveredInternal = Sets.newHashSet();
        DeviceId ingressDevice = ingressDevices.stream().filter(deviceId -> deviceId.equals(source.deviceId())).findFirst().orElse(null);
        // Clean also the ingress
        if (failedElement instanceof DeviceId && ingressDevice.equals(failedElement)) {
            removeGroupFromDevice((DeviceId) failedElement, mcastIp, mcastUtils.assignedVlan(source));
            mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, (DeviceId) failedElement, source));
        }
        if (ingressDevice == null) {
            log.warn("Skip failure recovery - " + "Missing ingress for source {} and group {}", source, mcastIp);
            return;
        }
        Set<DeviceId> egressDevices = getDevice(mcastIp, EGRESS, source);
        Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, egressDevices);
        // We have to verify, if there are egresses without paths
        mcastTree.forEach((egressDevice, paths) -> {
            Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths, source);
            // No paths, we have to try with alternative location
            if (!mcastPath.isPresent()) {
                notRecovered.compute(egressDevice, (deviceId, listSources) -> {
                    listSources = listSources == null ? Sets.newHashSet() : listSources;
                    listSources.add(source);
                    return listSources;
                });
                notRecoveredInternal.add(egressDevice);
            }
        });
        // Fast path, we can recover all the locations
        if (notRecoveredInternal.isEmpty()) {
            mcastTree.forEach((egressDevice, paths) -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths, source);
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                }
            });
        } else {
            // Let's try to recover using alternative locations
            recoverSinks(egressDevices, notRecoveredInternal, mcastIp, ingressDevice, source);
        }
    });
    // Finally remove the egresses not recovered
    notRecovered.forEach((egressDevice, listSources) -> {
        Set<ConnectPoint> currentSources = getSources(mcastIp, egressDevice, EGRESS);
        if (Objects.equal(currentSources, listSources)) {
            log.warn("Fail to recover egress device {} from {} failure {}", egressDevice, failedElement instanceof Link ? "Link" : "Device", failedElement);
            removeGroupFromDevice(egressDevice, mcastIp, mcastUtils.assignedVlan(null));
        }
        listSources.forEach(source -> mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, egressDevice, source)));
    });
}
#end_block

#method_before
private void recoverSinks(Set<DeviceId> egressDevices, Set<DeviceId> notRecovered, IpAddress mcastIp, DeviceId ingressDevice, ConnectPoint source) {
    log.debug("Processing recover sinks for group {} and for source {}", mcastIp, source);
    Set<DeviceId> recovered = Sets.difference(egressDevices, notRecovered);
    Set<ConnectPoint> totalAffectedSinks = Sets.newHashSet();
    Set<ConnectPoint> totalSinks = Sets.newHashSet();
    // Let's compute all the affected sinks and all the sinks
    notRecovered.forEach(deviceId -> {
        totalAffectedSinks.addAll(mcastUtils.getAffectedSinks(deviceId, mcastIp).values().stream().flatMap(Collection::stream).filter(connectPoint -> connectPoint.deviceId().equals(deviceId)).collect(Collectors.toSet()));
        totalSinks.addAll(mcastUtils.getAffectedSinks(deviceId, mcastIp).values().stream().flatMap(Collection::stream).collect(Collectors.toSet()));
    });
    Set<ConnectPoint> sinksToBeAdded = Sets.difference(totalSinks, totalAffectedSinks);
    Set<DeviceId> newEgressDevice = sinksToBeAdded.stream().map(ConnectPoint::deviceId).collect(Collectors.toSet());
    newEgressDevice.addAll(recovered);
    Set<DeviceId> copyNewEgressDevice = ImmutableSet.copyOf(newEgressDevice);
    newEgressDevice = newEgressDevice.stream().filter(deviceId -> !deviceId.equals(ingressDevice)).collect(Collectors.toSet());
    Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, newEgressDevice);
    // if the source was originally in the new locations, add new sinks
    if (copyNewEgressDevice.contains(ingressDevice)) {
        sinksToBeAdded.stream().filter(connectPoint -> connectPoint.deviceId().equals(ingressDevice)).forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, ImmutableList.of()));
    }
    // Construct a new path for each egress device
    mcastTree.forEach((egressDevice, paths) -> {
        Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths, source);
        if (mcastPath.isPresent()) {
            // Using recovery procedure
            if (recovered.contains(egressDevice)) {
                installPath(mcastIp, source, mcastPath.get());
            } else {
                // otherwise we need to threat as new sink
                sinksToBeAdded.stream().filter(connectPoint -> connectPoint.deviceId().equals(egressDevice)).forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, paths));
            }
        }
    });
}
#method_after
private void recoverSinks(Set<DeviceId> egressDevices, Set<DeviceId> notRecovered, IpAddress mcastIp, DeviceId ingressDevice, ConnectPoint source) {
    log.debug("Processing recover sinks for group {} and for source {}", mcastIp, source);
    Set<DeviceId> recovered = Sets.difference(egressDevices, notRecovered);
    Set<ConnectPoint> totalAffectedSinks = Sets.newHashSet();
    Set<ConnectPoint> totalSinks = Sets.newHashSet();
    // Let's compute all the affected sinks and all the sinks
    notRecovered.forEach(deviceId -> {
        totalAffectedSinks.addAll(mcastUtils.getAffectedSinks(deviceId, mcastIp).values().stream().flatMap(Collection::stream).filter(connectPoint -> connectPoint.deviceId().equals(deviceId)).collect(Collectors.toSet()));
        totalSinks.addAll(mcastUtils.getAffectedSinks(deviceId, mcastIp).values().stream().flatMap(Collection::stream).collect(Collectors.toSet()));
    });
    Set<ConnectPoint> sinksToBeAdded = Sets.difference(totalSinks, totalAffectedSinks);
    Set<DeviceId> newEgressDevices = sinksToBeAdded.stream().map(ConnectPoint::deviceId).collect(Collectors.toSet());
    newEgressDevices.addAll(recovered);
    Set<DeviceId> copyNewEgressDevices = ImmutableSet.copyOf(newEgressDevices);
    newEgressDevices = newEgressDevices.stream().filter(deviceId -> !deviceId.equals(ingressDevice)).collect(Collectors.toSet());
    Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, newEgressDevices);
    // if the source was originally in the new locations, add new sinks
    if (copyNewEgressDevices.contains(ingressDevice)) {
        sinksToBeAdded.stream().filter(connectPoint -> connectPoint.deviceId().equals(ingressDevice)).forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, ImmutableList.of()));
    }
    // Construct a new path for each egress device
    mcastTree.forEach((egressDevice, paths) -> {
        Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths, source);
        if (mcastPath.isPresent()) {
            // Using recovery procedure
            if (recovered.contains(egressDevice)) {
                installPath(mcastIp, source, mcastPath.get());
            } else {
                // otherwise we need to threat as new sink
                sinksToBeAdded.stream().filter(connectPoint -> connectPoint.deviceId().equals(egressDevice)).forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, paths));
            }
        }
    });
}
#end_block

#method_before
private Set<ConnectPoint> processSinksToBeAdded(ConnectPoint source, IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> sinks) {
    final Set<ConnectPoint> sinksToBeProcessed = Sets.newHashSet();
    sinks.forEach(((hostId, connectPoints) -> {
        // If it has more than 2 locations
        if (connectPoints.size() > 2 || connectPoints.size() == 0) {
            log.debug("Skip {} since sink {} has {} locations", mcastIp, hostId, connectPoints.size());
            return;
        }
        // If it has one location, just use it
        if (connectPoints.size() == 1) {
            sinksToBeProcessed.add(connectPoints.stream().findFirst().orElse(null));
            return;
        }
        // We prefer to reuse existing flows
        ConnectPoint sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> {
            if (!isSinkForGroup(mcastIp, connectPoint, source)) {
                return false;
            }
            if (!isSinkReachable(mcastIp, connectPoint, source)) {
                return false;
            }
            ConnectPoint other = connectPoints.stream().filter(remaining -> !remaining.equals(connectPoint)).findFirst().orElse(null);
            // We are already serving the sink
            return !isSinkForSource(mcastIp, other, source);
        }).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Otherwise we prefer to reuse existing egresses
        Set<DeviceId> egresses = getDevice(mcastIp, EGRESS, source);
        sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> {
            if (!egresses.contains(connectPoint.deviceId())) {
                return false;
            }
            if (!isSinkReachable(mcastIp, connectPoint, source)) {
                return false;
            }
            ConnectPoint other = connectPoints.stream().filter(remaining -> !remaining.equals(connectPoint)).findFirst().orElse(null);
            return !isSinkForSource(mcastIp, other, source);
        }).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Otherwise we prefer a location co-located with the source (if it exists)
        sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> connectPoint.deviceId().equals(source.deviceId())).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Finally, we randomly pick a new location if it is reachable
        sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> {
            if (!isSinkReachable(mcastIp, connectPoint, source)) {
                return false;
            }
            ConnectPoint other = connectPoints.stream().filter(remaining -> !remaining.equals(connectPoint)).findFirst().orElse(null);
            return !isSinkForSource(mcastIp, other, source);
        }).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
        }
    }));
    // We have done, return the set
    return sinksToBeProcessed;
}
#method_after
private Set<ConnectPoint> processSinksToBeAdded(ConnectPoint source, IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> sinks) {
    final Set<ConnectPoint> sinksToBeProcessed = Sets.newHashSet();
    sinks.forEach(((hostId, connectPoints) -> {
        // If it has more than 2 locations
        if (connectPoints.size() > 2 || connectPoints.size() == 0) {
            log.debug("Skip {} since sink {} has {} locations", mcastIp, hostId, connectPoints.size());
            return;
        }
        // If it has one location, just use it
        if (connectPoints.size() == 1) {
            sinksToBeProcessed.add(connectPoints.stream().findFirst().orElse(null));
            return;
        }
        // We prefer to reuse existing flows
        ConnectPoint sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> {
            if (!isSinkForGroup(mcastIp, connectPoint, source)) {
                return false;
            }
            if (!isSinkReachable(mcastIp, connectPoint, source)) {
                return false;
            }
            ConnectPoint other = connectPoints.stream().filter(remaining -> !remaining.equals(connectPoint)).findFirst().orElse(null);
            // We are already serving the sink
            return !isSinkForSource(mcastIp, other, source);
        }).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Otherwise we prefer to reuse existing egresses
        Set<DeviceId> egresses = getDevice(mcastIp, EGRESS, source);
        sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> {
            if (!egresses.contains(connectPoint.deviceId())) {
                return false;
            }
            if (!isSinkReachable(mcastIp, connectPoint, source)) {
                return false;
            }
            ConnectPoint other = connectPoints.stream().filter(remaining -> !remaining.equals(connectPoint)).findFirst().orElse(null);
            return !isSinkForSource(mcastIp, other, source);
        }).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Otherwise we prefer a location co-located with the source (if it exists)
        sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> connectPoint.deviceId().equals(source.deviceId())).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Finally, we randomly pick a new location if it is reachable
        sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> {
            if (!isSinkReachable(mcastIp, connectPoint, source)) {
                return false;
            }
            ConnectPoint other = connectPoints.stream().filter(remaining -> !remaining.equals(connectPoint)).findFirst().orElse(null);
            return !isSinkForSource(mcastIp, other, source);
        }).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
        }
    }));
    return sinksToBeProcessed;
}
#end_block

#method_before
private void removeIngressTransitPorts(IpAddress mcastIp, Set<DeviceId> ingressDevices, Set<ConnectPoint> sources) {
    Map<ConnectPoint, Set<PortNumber>> ingressTransitPorts = Maps.newHashMap();
    sources.forEach(source -> {
        DeviceId ingressDevice = ingressDevices.stream().filter(deviceId -> deviceId.equals(source.deviceId())).findFirst().orElse(null);
        if (ingressDevice == null) {
            log.warn("Skip removeIngressTransitPorts - " + "Missing ingress for source {} and group {}", source, mcastIp);
            return;
        }
        ingressTransitPorts.put(source, ingressTransitPort(mcastIp, ingressDevice, source));
    });
    // Remove all the ingress transits
    ingressTransitPorts.forEach((source, ports) -> ports.forEach(ingressTransitPort -> {
        DeviceId ingressDevice = ingressDevices.stream().filter(deviceId -> deviceId.equals(source.deviceId())).findFirst().orElse(null);
        boolean isLast = removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, mcastUtils.assignedVlan(source));
        if (isLast) {
            mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, ingressDevice, source));
        }
    }));
}
#method_after
private void removeIngressTransitPorts(IpAddress mcastIp, Set<DeviceId> ingressDevices, Set<ConnectPoint> sources) {
    Map<ConnectPoint, Set<PortNumber>> ingressTransitPorts = Maps.newHashMap();
    sources.forEach(source -> {
        DeviceId ingressDevice = ingressDevices.stream().filter(deviceId -> deviceId.equals(source.deviceId())).findFirst().orElse(null);
        if (ingressDevice == null) {
            log.warn("Skip removeIngressTransitPorts - " + "Missing ingress for source {} and group {}", source, mcastIp);
            return;
        }
        ingressTransitPorts.put(source, ingressTransitPort(mcastIp, ingressDevice, source));
    });
    ingressTransitPorts.forEach((source, ports) -> ports.forEach(ingressTransitPort -> {
        DeviceId ingressDevice = ingressDevices.stream().filter(deviceId -> deviceId.equals(source.deviceId())).findFirst().orElse(null);
        boolean isLast = removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, mcastUtils.assignedVlan(source));
        if (isLast) {
            mcastRoleStore.remove(new McastRoleStoreKey(mcastIp, ingressDevice, source));
        }
    }));
}
#end_block

#method_before
private Map<ConnectPoint, List<Path>> computeSinkMcastTree(DeviceId source, Set<ConnectPoint> sinks) {
    // Get the egress devices, remove source from the egress if present
    Set<DeviceId> egresses = sinks.stream().map(ConnectPoint::deviceId).filter(deviceId -> !deviceId.equals(source)).collect(Collectors.toSet());
    Map<DeviceId, List<Path>> mcastTree = computeMcastTree(source, egresses);
    // Build final tree and return it as it is
    final Map<ConnectPoint, List<Path>> finalTree = Maps.newHashMap();
    // We need to put back the source if it was originally present
    sinks.forEach(sink -> {
        List<Path> sinkPaths = mcastTree.get(sink.deviceId());
        finalTree.put(sink, sinkPaths != null ? sinkPaths : ImmutableList.of());
    });
    return finalTree;
}
#method_after
private Map<ConnectPoint, List<Path>> computeSinkMcastTree(DeviceId source, Set<ConnectPoint> sinks) {
    // Get the egress devices, remove source from the egress if present
    Set<DeviceId> egresses = sinks.stream().map(ConnectPoint::deviceId).filter(deviceId -> !deviceId.equals(source)).collect(Collectors.toSet());
    Map<DeviceId, List<Path>> mcastTree = computeMcastTree(source, egresses);
    final Map<ConnectPoint, List<Path>> finalTree = Maps.newHashMap();
    // We need to put back the source if it was originally present
    sinks.forEach(sink -> {
        List<Path> sinkPaths = mcastTree.get(sink.deviceId());
        finalTree.put(sink, sinkPaths != null ? sinkPaths : ImmutableList.of());
    });
    return finalTree;
}
#end_block

#method_before
private Set<ConnectPoint> getSources(IpAddress mcastIp, DeviceId deviceId, McastRole role) {
    return mcastRoleStore.entrySet().stream().filter(entry -> entry.getKey().mcastIp().equals(mcastIp) && entry.getKey().deviceId().equals(deviceId) && entry.getValue().value() == role).map(Entry::getKey).map(McastRoleStoreKey::source).collect(Collectors.toSet());
}
#method_after
private Set<ConnectPoint> getSources(IpAddress mcastIp) {
    return mcastRoleStore.entrySet().stream().filter(entry -> entry.getKey().mcastIp().equals(mcastIp)).map(Entry::getKey).map(McastRoleStoreKey::source).collect(Collectors.toSet());
}
#end_block

#method_before
private boolean isSinkForGroup(IpAddress mcastIp, ConnectPoint connectPoint, ConnectPoint source) {
    VlanId assignedVlan = mcastUtils.assignedVlan(connectPoint.deviceId().equals(source.deviceId()) ? source : null);
    // Let's check if we are already serving that location
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, connectPoint.deviceId(), assignedVlan);
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        return false;
    }
    NextObjective mcastNext = mcastNextObjStore.get(mcastStoreKey).value();
    return mcastUtils.getPorts(mcastNext.next()).contains(connectPoint.port());
}
#method_after
private boolean isSinkForGroup(IpAddress mcastIp, ConnectPoint connectPoint, ConnectPoint source) {
    VlanId assignedVlan = mcastUtils.assignedVlan(connectPoint.deviceId().equals(source.deviceId()) ? source : null);
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, connectPoint.deviceId(), assignedVlan);
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        return false;
    }
    NextObjective mcastNext = mcastNextObjStore.get(mcastStoreKey).value();
    return mcastUtils.getPorts(mcastNext.next()).contains(connectPoint.port());
}
#end_block

#method_before
private boolean isSinkForSource(IpAddress mcastIp, ConnectPoint connectPoint, ConnectPoint source) {
    boolean isSink = isSinkForGroup(mcastIp, connectPoint, source);
    // Let's check if we have a role stored
    DeviceId device;
    if (connectPoint.deviceId().equals(source.deviceId())) {
        device = getDevice(mcastIp, INGRESS, source).stream().filter(deviceId -> deviceId.equals(connectPoint.deviceId())).findFirst().orElse(null);
    } else {
        device = getDevice(mcastIp, EGRESS, source).stream().filter(deviceId -> deviceId.equals(connectPoint.deviceId())).findFirst().orElse(null);
    }
    return isSink && device != null;
}
#method_after
private boolean isSinkForSource(IpAddress mcastIp, ConnectPoint connectPoint, ConnectPoint source) {
    boolean isSink = isSinkForGroup(mcastIp, connectPoint, source);
    DeviceId device;
    if (connectPoint.deviceId().equals(source.deviceId())) {
        device = getDevice(mcastIp, INGRESS, source).stream().filter(deviceId -> deviceId.equals(connectPoint.deviceId())).findFirst().orElse(null);
    } else {
        device = getDevice(mcastIp, EGRESS, source).stream().filter(deviceId -> deviceId.equals(connectPoint.deviceId())).findFirst().orElse(null);
    }
    return isSink && device != null;
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective forwardObjective) {
    ForwardingObjective newFwd = forwardObjective;
    Device device = deviceSetvice.getDevice(deviceId);
    if (forwardObjective.treatment() != null && forwardObjective.treatment().clearedDeferred()) {
        log.debug("Using 'clear actions' instruction which is not supported by {} {} {} Switch", device.id(), device.manufacturer(), device.hwVersion());
        newFwd = forwardingObjectiveWithoutCleardDef(forwardObjective).orElse(forwardObjective);
    }
    super.forward(newFwd);
}
#method_after
@Override
public void forward(ForwardingObjective forwardObjective) {
    ForwardingObjective newFwd = forwardObjective;
    Device device = deviceSetvice.getDevice(deviceId);
    if (forwardObjective.treatment() != null && forwardObjective.treatment().clearedDeferred()) {
        log.warn("Using 'clear actions' instruction which is not supported by {} {} {} Switch" + " removing the clear deferred from the forwarding objective", device.id(), device.manufacturer(), device.hwVersion());
        newFwd = forwardingObjectiveWithoutCleardDef(forwardObjective).orElse(forwardObjective);
    }
    super.forward(newFwd);
}
#end_block

#method_before
@Before
public void setup() throws NetconfException {
    MockCoreService coreService = new MockCoreService(101, "org.onosproject.drivers.netconf", "org.onosproject.linkdiscovery", "org.onosproject.drivers.ciena.c5170");
    // Load the mock responses for mock device "netconf:1.2.3.4:830"
    DeviceId mId = DeviceId.deviceId("netconf:1.2.3.4:830");
    mockRequestDriver.load(DeviceDiscoveryTest.class, "/templates/responses/device_1_2_3_4/%s.j2", mId, "systemInfo", "softwareVersion", "logicalPorts", "link-info", "port-stats", "chassis-mac");
    MockDriverHandler mockDriverHandler = new MockDriverHandler(Ciena5170DriversLoader.class, "/ciena-5170-drivers.xml", mId, coreService, deviceService);
    NetconfController controller = mockDriverHandler.get(NetconfController.class);
    mockDriverHandlers.put(mId, mockDriverHandler);
    mockRequestDriver.setDeviceMap(controller.getDevicesMap());
    // Load the mock responses for mock device "netconf:5.6.7.8:830"
    mId = DeviceId.deviceId("netconf:5.6.7.8:830");
    mockRequestDriver.load(DeviceDiscoveryTest.class, "/templates/responses/device_5_6_7_8/%s.j2", mId, "systemInfo", "softwareVersion", "logicalPorts", "link-info", "chassis-mac");
    mockDriverHandler = new MockDriverHandler(Ciena5170DriversLoader.class, "/ciena-5170-drivers.xml", mId, coreService, deviceService);
    controller = mockDriverHandler.get(NetconfController.class);
    mockDriverHandlers.put(mId, mockDriverHandler);
    mockRequestDriver.setDeviceMap(controller.getDevicesMap());
}
#method_after
@Before
public void setup() {
    MockCoreService coreService = new MockCoreService(101, "org.onosproject.drivers.netconf", "org.onosproject.linkdiscovery", "org.onosproject.drivers.ciena.c5170");
    // Load the mock responses for mock device "netconf:1.2.3.4:830"
    DeviceId mId = DeviceId.deviceId("netconf:1.2.3.4:830");
    mockRequestDriver.load(DeviceDiscoveryTest.class, "/templates/responses/device_1_2_3_4/%s.j2", mId, "systemInfo", "softwareVersion", "logicalPorts", "link-info", "port-stats", "chassis-mac");
    MockDriverHandler mockDriverHandler = new MockDriverHandler(Ciena5170DriversLoader.class, "/ciena-5170-drivers.xml", mId, coreService, deviceService);
    NetconfController controller = mockDriverHandler.get(NetconfController.class);
    mockDriverHandlers.put(mId, mockDriverHandler);
    mockRequestDriver.setDeviceMap(controller.getDevicesMap());
    // Load the mock responses for mock device "netconf:5.6.7.8:830"
    mId = DeviceId.deviceId("netconf:5.6.7.8:830");
    mockRequestDriver.load(DeviceDiscoveryTest.class, "/templates/responses/device_5_6_7_8/%s.j2", mId, "systemInfo", "softwareVersion", "logicalPorts", "link-info", "chassis-mac");
    mockDriverHandler = new MockDriverHandler(Ciena5170DriversLoader.class, "/ciena-5170-drivers.xml", mId, coreService, deviceService);
    controller = mockDriverHandler.get(NetconfController.class);
    mockDriverHandlers.put(mId, mockDriverHandler);
    mockRequestDriver.setDeviceMap(controller.getDevicesMap());
}
#end_block

#method_before
private boolean testDeviceConnection(RestSBDevice dev) {
    try {
        Callable<Boolean> connectionSuccess;
        if (dev.testUrl().isPresent()) {
            connectionSuccess = () -> controller.get(dev.deviceId(), dev.testUrl().get(), MediaType.APPLICATION_JSON_TYPE) != null;
        } else {
            connectionSuccess = () -> controller.get(dev.deviceId(), "", MediaType.APPLICATION_JSON_TYPE) != null;
        }
        Future<Boolean> future = executor.submit(connectionSuccess);
        try {
            return future.get(REST_TIMEOUT_SEC, TimeUnit.SECONDS);
        } catch (TimeoutException ex) {
            log.warn("Connection to device {} timed out: {}", dev.deviceId(), ex.getMessage());
            return false;
        } catch (InterruptedException ex) {
            log.warn("Connection to device {} interrupted: {}", dev.deviceId(), ex.getMessage());
            Thread.currentThread().interrupt();
            return false;
        } catch (ExecutionException ex) {
            log.warn("Connection to device {} had an execution exception: {}", dev.deviceId(), ex.getMessage());
            return false;
        }
    } catch (ProcessingException e) {
        log.warn("Cannot connect to device {}", dev, e);
    }
    return false;
}
#method_after
private boolean testDeviceConnection(RestSBDevice dev) {
    try {
        Callable<Boolean> connectionSuccess;
        if (dev.testUrl().isPresent()) {
            connectionSuccess = () -> controller.get(dev.deviceId(), dev.testUrl().get(), MediaType.APPLICATION_JSON_TYPE) != null;
        } else {
            connectionSuccess = () -> controller.get(dev.deviceId(), "", MediaType.APPLICATION_JSON_TYPE) != null;
        }
        Future<Boolean> future = executor.submit(connectionSuccess);
        try {
            return future.get(REST_TIMEOUT_SEC, TimeUnit.SECONDS);
        } catch (TimeoutException ex) {
            log.warn("Connection to device {} timed out: {}", dev.deviceId(), ex.getMessage());
            return false;
        } catch (InterruptedException ex) {
            log.warn("Connection to device {} interrupted: {}", dev.deviceId(), ex.getMessage());
            Thread.currentThread().interrupt();
            return false;
        } catch (ExecutionException ex) {
            log.warn("Connection to device {} had an execution exception.", dev.deviceId(), ex);
            return false;
        }
    } catch (ProcessingException e) {
        log.warn("Cannot connect to device {}", dev, e);
    }
    return false;
}
#end_block

#method_before
@Override
protected void execute() {
    print("intents-diagnosis");
    ServiceRefs svcRefs = buildServiceRefs();
    if (svcRefs == null) {
        return;
    }
    try {
        for (Intent intent : svcRefs.intentsService().getIntents()) {
            if (key != null && !intent.key().toString().equals(key)) {
                continue;
            }
            print("");
            printIntentHdr(intent, svcRefs);
            if (intent instanceof PointToPointIntent) {
                diagnosisP2Pintent((PointToPointIntent) intent, svcRefs);
            } else {
            // TODO : it needs to implement other types of intent
            }
        }
        if (dumpIntentByLink) {
            dumpIntentsByLink(svcRefs);
        }
    } catch (Exception e) {
        print("error: " + e);
    }
}
#method_after
@Override
protected void execute() {
    print("intents-diagnosis");
    ServiceRefs svcRefs = buildServiceRefs();
    if (svcRefs == null) {
        return;
    }
    try {
        for (Intent intent : svcRefs.intentsService().getIntents()) {
            if (key != null && !intent.key().toString().equals(key)) {
                continue;
            }
            print("");
            printIntentHdr(intent, svcRefs);
            if (intent instanceof PointToPointIntent) {
                diagnosisP2Pintent((PointToPointIntent) intent, svcRefs);
            } else {
                // TODO : it needs to implement other types of intent
                print(" It doesn't support %s intent.", intent.getClass().getSimpleName());
            }
        }
        if (dumpIntentByLink) {
            dumpIntentsByLink(svcRefs);
        }
    } catch (Exception e) {
        print("error: " + e);
    }
}
#end_block

#method_before
private void diagnosisP2Pintent(PointToPointIntent intent, ServiceRefs svcRefs) throws Exception {
    List<Intent> installableIntents = svcRefs.intentsService().getInstallableIntents(intent.key());
    if (installableIntents.size() == 0) {
        error("NO INSTALLABLE INTENTS");
        return;
    }
    for (Intent installable : installableIntents) {
        if (installable instanceof FlowRuleIntent) {
            checkP2PFlowRuleIntent(intent, (FlowRuleIntent) installable, svcRefs);
        } else {
        // TODO : it needs to implement other types of installables
        }
    }
}
#method_after
private void diagnosisP2Pintent(PointToPointIntent intent, ServiceRefs svcRefs) throws Exception {
    List<Intent> installableIntents = svcRefs.intentsService().getInstallableIntents(intent.key());
    if (installableIntents.size() == 0) {
        error("NO INSTALLABLE INTENTS");
        return;
    }
    Set<String> notSupport = new HashSet<>();
    for (Intent installable : installableIntents) {
        if (installable instanceof FlowRuleIntent) {
            checkP2PFlowRuleIntent(intent, (FlowRuleIntent) installable, svcRefs);
        } else {
            // TODO : it needs to implement other types of installables
            notSupport.add(installable.getClass().getSimpleName());
        }
    }
    if (notSupport.size() > 0) {
        print(" It doesn't support %s.", notSupport);
    }
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    log.debug("Adding description for Waveserver Ai device");
    NetconfSession session = getNetconfSession();
    Device device = getDevice(handler().data().deviceId());
    try {
        XPath xp = XPathFactory.newInstance().newXPath();
        Node node = TemplateManager.doRequest(session, "discoverDeviceDetails");
        String chassisId = xp.evaluate("waveserver-chassis/mac-addresses/chassis/base/text()", node);
        chassisId = chassisId.replace(":", "");
        SparseAnnotations annotationDevice = DefaultAnnotations.builder().set("hostname", xp.evaluate("waveserver-system/host-name/current-host-name/text()", node)).set("macAddress", chassisId).build();
        // Long chassis = Long.parseLong(chassisId, 16);
        return new DefaultDeviceDescription(device.id().uri(), Device.Type.OTN, "Ciena", "WaverserverAi", xp.evaluate("waveserver-software/status/active-version/text()", node), xp.evaluate("waveserver-chassis/identification/serial-number/text()", node), new ChassisId(), (SparseAnnotations) annotationDevice);
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port information for device {}, {}", device.chassisId(), e);
    }
    return new DefaultDeviceDescription(device.id().uri(), Device.Type.OTN, "Ciena", "WaverserverAi", "unknown", "unknown", device.chassisId());
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    log.debug("Adding description for Waveserver Ai device");
    NetconfSession session = getNetconfSession();
    Device device = getDevice(handler().data().deviceId());
    try {
        XPath xp = XPathFactory.newInstance().newXPath();
        Node node = TEMPLATE_MANAGER.doRequest(session, "discoverDeviceDetails");
        String chassisId = xp.evaluate("waveserver-chassis/mac-addresses/chassis/base/text()", node);
        chassisId = chassisId.replace(":", "");
        SparseAnnotations annotationDevice = DefaultAnnotations.builder().set("name", xp.evaluate("waveserver-system/host-name/current-host-name/text()", node)).build();
        return new DefaultDeviceDescription(device.id().uri(), Device.Type.OTN, "Ciena", "WaverserverAi", xp.evaluate("waveserver-software/status/active-version/text()", node), xp.evaluate("waveserver-chassis/identification/serial-number/text()", node), new ChassisId(Long.valueOf(chassisId, 16)), (SparseAnnotations) annotationDevice);
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve device information for device {}, {}", device.chassisId(), e);
    }
    return new DefaultDeviceDescription(device.id().uri(), Device.Type.OTN, "Ciena", "WaverserverAi", "unknown", "unknown", device.chassisId());
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    log.info("Adding ports for Waveserver Ai device");
    List<PortDescription> ports = new ArrayList<>();
    Device device = getDevice(handler().data().deviceId());
    NetconfSession session = getNetconfSession();
    try {
        XPath xp = XPathFactory.newInstance().newXPath();
        Node nodeListItem;
        Node node = TemplateManager.doRequest(session, "discoverPortDetails");
        NodeList nodeList = (NodeList) xp.evaluate("waveserver-ports/ports", node, XPathConstants.NODESET);
        int count = nodeList.getLength();
        for (int i = 0; i < count; ++i) {
            nodeListItem = nodeList.item(i);
            DefaultAnnotations annotationPort = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, xp.evaluate("port-id/text()", nodeListItem)).set(AnnotationKeys.PROTOCOL, xp.evaluate("id/type/text()", nodeListItem)).build();
            String port = xp.evaluate("port-id/text()", nodeListItem);
            ports.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(TemplateManager.portIdConvert(port), port)).isEnabled(TemplateManager.portStateConvert(xp.evaluate("state/operational-state/text()", nodeListItem))).portSpeed(TemplateManager.portSpeedToLong(xp.evaluate("id/speed/text()", nodeListItem))).type(Port.Type.PACKET).annotations(annotationPort).build());
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port information for device {}, {}", device.chassisId(), e);
    }
    return ImmutableList.copyOf(ports);
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    log.info("Adding ports for Waveserver Ai device");
    List<PortDescription> ports = new ArrayList<>();
    Device device = getDevice(handler().data().deviceId());
    NetconfSession session = getNetconfSession();
    try {
        XPath xp = XPathFactory.newInstance().newXPath();
        Node nodeListItem;
        Node node = TEMPLATE_MANAGER.doRequest(session, "discoverPortDetails");
        NodeList nodeList = (NodeList) xp.evaluate("waveserver-ports/ports", node, XPathConstants.NODESET);
        int count = nodeList.getLength();
        for (int i = 0; i < count; ++i) {
            nodeListItem = nodeList.item(i);
            DefaultAnnotations annotationPort = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, xp.evaluate("port-id/text()", nodeListItem)).set(AnnotationKeys.PROTOCOL, xp.evaluate("id/type/text()", nodeListItem)).build();
            String port = xp.evaluate("port-id/text()", nodeListItem);
            ports.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(portIdConvert(port), port)).isEnabled(portStateConvert(xp.evaluate("state/operational-state/text()", nodeListItem))).portSpeed(portSpeedToLong(xp.evaluate("id/speed/text()", nodeListItem))).type(Port.Type.PACKET).annotations(annotationPort).build());
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port information for device {}, {}", device.chassisId(), e);
    }
    return ImmutableList.copyOf(ports);
}
#end_block

#method_before
private CompletableFuture<Boolean> setAdminState(PortNumber number, Boolean state) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String port = TemplateManager.portIdConvert(Long.valueOf(String.valueOf(number)));
    String adminState = TemplateManager.portStateConvert(state);
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", port);
        templateContext.put("admin-state", adminState);
        Node req = (Node) TemplateManager.doRequest(session, "setAdminState", templateContext, "/", XPathConstants.NODE);
        XPath xp = XPathFactory.newInstance().newXPath();
        // If OK element exists then it worked.
        Node ok = (Node) xp.evaluate("/rpc-reply/ok", req, XPathConstants.NODE);
        return CompletableFuture.completedFuture(ok != null);
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to set port admin state for port {} to {}", port, handler().data().deviceId(), adminState, e);
    }
    return CompletableFuture.completedFuture(false);
}
#method_after
private CompletableFuture<Boolean> setAdminState(PortNumber number, Boolean state) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String port = portIdConvert(Long.valueOf(String.valueOf(number)));
    String adminState = portStateConvert(state);
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", port);
        templateContext.put("admin-state", adminState);
        Node req = (Node) TEMPLATE_MANAGER.doRequest(session, "setAdminState", templateContext, "/", XPathConstants.NODE);
        XPath xp = XPathFactory.newInstance().newXPath();
        // If OK element exists then it worked.
        Node ok = (Node) xp.evaluate("/rpc-reply/ok", req, XPathConstants.NODE);
        return CompletableFuture.completedFuture(ok != null);
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to set port admin state for port {} to {}", port, handler().data().deviceId(), adminState, e);
    }
    return CompletableFuture.completedFuture(false);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isEnabled(PortNumber number) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toString());
        Node port = TemplateManager.doRequest(session, "isEnabled", templateContext);
        XPath xp = XPathFactory.newInstance().newXPath();
        log.error("SOMEONE IS LOOKING: {}", TemplateManager.portStateConvert(xp.evaluate("state/operational-state/text()", port)));
        return CompletableFuture.completedFuture(TemplateManager.portStateConvert(xp.evaluate("state/operational-state/text()", port)));
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to query port state for port {} from device {}", number, handler().data().deviceId(), e);
    }
    return CompletableFuture.completedFuture(false);
}
#method_after
@Override
public CompletableFuture<Boolean> isEnabled(PortNumber number) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        log.debug("Querying port state for port {} from device {}", number, handler().data().deviceId());
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toString());
        Node port = TEMPLATE_MANAGER.doRequest(session, "isEnabled", templateContext);
        XPath xp = XPathFactory.newInstance().newXPath();
        return CompletableFuture.completedFuture(portStateConvert(xp.evaluate("state/operational-state/text()", port)));
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to query port state for port {} from device {}", number, handler().data().deviceId(), e);
    }
    return CompletableFuture.completedFuture(false);
}
#end_block

#method_before
@Override
public Set<LinkDescription> getLinks() {
    log.info("LINKS CHECKING ...");
    Set<LinkDescription> links = new HashSet<>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, cannot load links, will be retried", deviceId);
        return links;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        DeviceService deviceService = this.handler().get(DeviceService.class);
        Iterable<Device> devices = deviceService.getAvailableDevices();
        Map<String, Device> lookup = new HashMap<>();
        for (Device d : devices) {
            lookup.put(d.annotations().value("macAddress"), d);
        }
        log.info("MAP: {}", lookup);
        XPath xp = XPathFactory.newInstance().newXPath();
        Node node = TemplateManager.doRequest(session, "discoverPortDetails");
        NodeList nodeList = (NodeList) xp.evaluate("waveserver-ports/ports", node, XPathConstants.NODESET);
        int count = nodeList.getLength();
        Node nodeListItem;
        for (int i = 0; i < count; i += 1) {
            Long portAsLong;
            Long destPortAsLong;
            String destChassis = null;
            String destPort = null;
            nodeListItem = nodeList.item(i);
            log.info("CHECKING: {}", xp.evaluate("port-id/text()", nodeListItem));
            if (xp.evaluate("id/type/text()", nodeListItem).equals("otn")) {
                String label = xp.evaluate("id/label/text()", nodeListItem);
                final String r1 = "\\$\\{remote_mac:(.*?)\\}";
                final Pattern p1 = Pattern.compile(r1);
                final Matcher m1 = p1.matcher(label);
                if (m1.find()) {
                    destChassis = m1.group(1);
                }
                final String r2 = "\\$\\{remote_port:(.*?)\\}";
                final Pattern p2 = Pattern.compile(r2);
                final Matcher m2 = p2.matcher(label);
                if (m2.find()) {
                    destPort = m2.group(1);
                }
                if (destChassis != null && destPort != null) {
                    log.info("LOOKING FOR: {}", destChassis);
                    Device dest = lookup.get(destChassis);
                    if (dest != null) {
                        String port = xp.evaluate("port-id/text()", nodeListItem);
                        portAsLong = TemplateManager.portIdConvert(port);
                        destPortAsLong = TemplateManager.portIdConvert(port);
                        links.add(new DefaultLinkDescription(new ConnectPoint(deviceId, PortNumber.portNumber(portAsLong, port)), new ConnectPoint(dest.id(), PortNumber.portNumber(destPortAsLong, destPort)), Link.Type.DIRECT, true));
                    } else {
                        log.info("DEST CHASSIS is NULL for {}", xp.evaluate("port-id/text()", nodeListItem));
                    }
                } else {
                    log.info("NO LINK for {}", xp.evaluate("port-id/text()", nodeListItem));
                }
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.info("Unable to retrieve links for device {}, {}", deviceId, e);
    }
    return links;
}
#method_after
@Override
public Set<LinkDescription> getLinks() {
    log.debug("LINKS CHECKING ...");
    Set<LinkDescription> links = new HashSet<>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, cannot load links, will be retried", deviceId);
        return links;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        DeviceService deviceService = this.handler().get(DeviceService.class);
        Iterable<Device> devices = deviceService.getAvailableDevices();
        Map<String, Device> lookup = new HashMap<>();
        for (Device d : devices) {
            lookup.put(d.chassisId().toString(), d);
        }
        log.debug("MAP: {}", lookup);
        XPath xp = XPathFactory.newInstance().newXPath();
        Node node = TEMPLATE_MANAGER.doRequest(session, "discoverPortDetails");
        NodeList nodeList = (NodeList) xp.evaluate("waveserver-ports/ports", node, XPathConstants.NODESET);
        int count = nodeList.getLength();
        Node nodeListItem;
        for (int i = 0; i < count; i += 1) {
            Long portAsLong;
            Long destPortAsLong;
            String destChassis = null;
            String destPort = null;
            nodeListItem = nodeList.item(i);
            String port = xp.evaluate("port-id/text()", nodeListItem);
            portAsLong = portIdConvert(port);
            log.debug("CHECKING: {}", port);
            if (xp.evaluate("id/type/text()", nodeListItem).equals("otn")) {
                String label = xp.evaluate("id/label/text()", nodeListItem);
                final String r1 = "\\$\\{remote_mac:(.*?)\\}";
                final Pattern p1 = Pattern.compile(r1);
                final Matcher m1 = p1.matcher(label);
                if (m1.find()) {
                    destChassis = m1.group(1).replaceFirst("^0+(?!$)", "");
                }
                final String r2 = "\\$\\{remote_port:(.*?)\\}";
                final Pattern p2 = Pattern.compile(r2);
                final Matcher m2 = p2.matcher(label);
                if (m2.find()) {
                    destPort = m2.group(1);
                }
                destPortAsLong = portIdConvert(destPort);
                if (destChassis != null && destPort != null) {
                    log.debug("LOOKING FOR OTN neighbor chassis: {}", destChassis);
                    Device dest = lookup.get(destChassis);
                    if (dest != null) {
                        links.add(new DefaultLinkDescription(new ConnectPoint(deviceId, PortNumber.portNumber(portAsLong, port)), new ConnectPoint(dest.id(), PortNumber.portNumber(destPortAsLong, destPort)), Link.Type.TUNNEL, true));
                    } else {
                        log.error("DEST OTN CHASSIS is NULL for {}", xp.evaluate("port-id/text()", nodeListItem));
                    }
                } else {
                    log.error("NO LINK for {}", xp.evaluate("port-id/text()", nodeListItem));
                }
            } else if (xp.evaluate("id/type/text()", nodeListItem).equals("ethernet")) {
                Map<String, Object> templateContext = new HashMap<>();
                templateContext.put("port-number", port);
                node = TEMPLATE_MANAGER.doRequest(session, "getLinks", templateContext);
                String chassisIdSubtype = xp.evaluate("waveserver-lldp/port/remote/chassis/chassis-id/chassis-id-subtype/text()", node);
                if (chassisIdSubtype.equals("mac-address")) {
                    destChassis = xp.evaluate("waveserver-lldp/port/remote/chassis/chassis-id/chassis-id/text()", node).trim().toLowerCase();
                    if (destChassis.startsWith("0x")) {
                        destChassis = destChassis.substring(2);
                    }
                } else {
                    log.error("Unknown Chassis-id-subtype {}", xp.evaluate("waveserver-lldp/port/remote/chassis/chassis-id/chassis-id-subtype/text()", node));
                }
                destPort = xp.evaluate("waveserver-lldp/port/remote/port/id/id/text()", node);
                destPortAsLong = Long.valueOf(destPort);
                if (destChassis != null && !destPort.equals("")) {
                    log.debug("LOOKING FOR ethernet neighbor chassisId: {}", destChassis);
                    Device dest = lookup.get(destChassis);
                    if (dest != null) {
                        links.add(new DefaultLinkDescription(new ConnectPoint(deviceId, PortNumber.portNumber(portAsLong, port)), new ConnectPoint(dest.id(), PortNumber.portNumber(destPortAsLong, destPort)), Link.Type.TUNNEL, true));
                    } else {
                        log.debug("DEST CHASSIS is NULL for port {}", xp.evaluate("port-id/text()", nodeListItem));
                    }
                } else {
                    log.debug("NO LINK for {}", xp.evaluate("port-id/text()", nodeListItem));
                }
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve links for device {}, {}", deviceId, e);
    }
    return links;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mockDeviceId = DeviceId.deviceId("netconf:1.2.3.4:830");
    controller = new MockNetconfController();
    MockNetconfDevice device = (MockNetconfDevice) controller.connectDevice(mockDeviceId);
    device.setNcSessionImpl(MockNetconfSessionWaveserverAi.class);
    IntentTestsMocks.MockDeviceService deviceService = new IntentTestsMocks.MockDeviceService();
    deviceService.getDevice(mockDeviceId);
    deviceDescription = new CienaWaveserverAiDeviceDescription();
    deviceDescription.setHandler(new MockWaveserverAiDriverHandler());
    assertNotNull(deviceDescription.handler().data().deviceId());
}
#method_after
@Before
public void setUp() throws Exception {
    mockDeviceId = DeviceId.deviceId("netconf:1.2.3.4:830");
    IntentTestsMocks.MockDeviceService deviceService = new IntentTestsMocks.MockDeviceService();
    deviceService.getDevice(mockDeviceId);
    deviceDescription = new CienaWaveserverAiDeviceDescription();
    deviceDescription.setHandler(new MockWaveserverAiDriverHandler());
    assertNotNull(deviceDescription.handler().data().deviceId());
}
#end_block

#method_before
@Test
public void testDiscoverDeviceDetails() {
    XPath xp = XPathFactory.newInstance().newXPath();
    SparseAnnotations expectAnnotation = DefaultAnnotations.builder().set("hostname", "hostnameWaveServer").build();
    DefaultDeviceDescription expectResult = new DefaultDeviceDescription(mockDeviceId.uri(), Device.Type.OTN, "Ciena", "WaverserverAi", "waveserver-1.1.0.302", "M000", new ChassisId(0L), expectAnnotation);
    try {
        Node node = TemplateManager.doRequest("/response/discoverDeviceDetails.xml", "/rpc-reply/data");
        SparseAnnotations annotationDevice = DefaultAnnotations.builder().set("hostname", xp.evaluate("waveserver-system/host-name/current-host-name/text()", node)).build();
        DefaultDeviceDescription result = new DefaultDeviceDescription(mockDeviceId.uri(), Device.Type.OTN, "Ciena", "WaverserverAi", xp.evaluate("waveserver-software/status/active-version/text()", node), xp.evaluate("waveserver-chassis/identification/serial-number/text()", node), new ChassisId(0L), annotationDevice);
        assertEquals(expectResult, result);
    } catch (XPathExpressionException e) {
        e.printStackTrace();
    }
}
#method_after
@Test
public void testDiscoverDeviceDetails() {
    XPath xp = XPathFactory.newInstance().newXPath();
    SparseAnnotations expectAnnotation = DefaultAnnotations.builder().set("hostname", "hostnameWaveServer").build();
    DefaultDeviceDescription expectResult = new DefaultDeviceDescription(mockDeviceId.uri(), Device.Type.OTN, "Ciena", "WaverserverAi", "waveserver-1.1.0.302", "M000", new ChassisId(0L), expectAnnotation);
    try {
        Node node = doRequest("/response/discoverDeviceDetails.xml", "/rpc-reply/data");
        SparseAnnotations annotationDevice = DefaultAnnotations.builder().set("hostname", xp.evaluate("waveserver-system/host-name/current-host-name/text()", node)).build();
        DefaultDeviceDescription result = new DefaultDeviceDescription(mockDeviceId.uri(), Device.Type.OTN, "Ciena", "WaverserverAi", xp.evaluate("waveserver-software/status/active-version/text()", node), xp.evaluate("waveserver-chassis/identification/serial-number/text()", node), new ChassisId(0L), annotationDevice);
        assertEquals(expectResult, result);
    } catch (XPathExpressionException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
@Test
public void testDiscoverPortDetails() {
    List<PortDescription> result = new ArrayList<>();
    List<PortDescription> expectResult = getExpectedPorts();
    try {
        XPath xp = XPathFactory.newInstance().newXPath();
        Node nodeListItem;
        Node node = TemplateManager.doRequest("/response/discoverPortDetails.xml", "/rpc-reply/data");
        NodeList nodeList = (NodeList) xp.evaluate("waveserver-ports/ports", node, XPathConstants.NODESET);
        int count = nodeList.getLength();
        for (int i = 0; i < count; ++i) {
            nodeListItem = nodeList.item(i);
            DefaultAnnotations annotationPort = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, xp.evaluate("port-id/text()", nodeListItem)).set(AnnotationKeys.PROTOCOL, xp.evaluate("id/type/text()", nodeListItem)).build();
            String port = xp.evaluate("port-id/text()", nodeListItem);
            result.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(TemplateManager.portIdConvert(port), port)).isEnabled(TemplateManager.portStateConvert(xp.evaluate("state/operational-state/text()", nodeListItem))).portSpeed(TemplateManager.portSpeedToLong(xp.evaluate("id/speed/text()", nodeListItem))).type(Port.Type.PACKET).annotations(annotationPort).build());
        }
    } catch (XPathExpressionException e) {
        e.printStackTrace();
    }
    assertEquals(expectResult, result);
}
#method_after
@Test
public void testDiscoverPortDetails() {
    List<PortDescription> result = new ArrayList<>();
    List<PortDescription> expectResult = getExpectedPorts();
    try {
        XPath xp = XPathFactory.newInstance().newXPath();
        Node nodeListItem;
        Node node = doRequest("/response/discoverPortDetails.xml", "/rpc-reply/data");
        NodeList nodeList = (NodeList) xp.evaluate("waveserver-ports/ports", node, XPathConstants.NODESET);
        int count = nodeList.getLength();
        for (int i = 0; i < count; ++i) {
            nodeListItem = nodeList.item(i);
            DefaultAnnotations annotationPort = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, xp.evaluate("port-id/text()", nodeListItem)).set(AnnotationKeys.PROTOCOL, xp.evaluate("id/type/text()", nodeListItem)).build();
            String port = xp.evaluate("port-id/text()", nodeListItem);
            result.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(portIdConvert(port), port)).isEnabled(portStateConvert(xp.evaluate("state/operational-state/text()", nodeListItem))).portSpeed(portSpeedToLong(xp.evaluate("id/speed/text()", nodeListItem))).type(Port.Type.PACKET).annotations(annotationPort).build());
        }
    } catch (XPathExpressionException e) {
        e.printStackTrace();
    }
    assertEquals(expectResult, result);
}
#end_block

#method_before
@Test
public void testDiscoverPortStatistics() {
    Collection<PortStatistics> result = new ArrayList<>();
    Collection<PortStatistics> expectResult = getExpectedPortsStatistics();
    try {
        XPath xp = XPathFactory.newInstance().newXPath();
        String tx = "current-bin/statistics/interface-counts/tx/";
        String rx = "current-bin/statistics/interface-counts/rx/";
        Node node = TemplateManager.doRequest("/response/discoverPortStatistics.xml", "/rpc-reply/data");
        NodeList nodeList = (NodeList) xp.evaluate("waveserver-pm/ethernet-performance-instances", node, XPathConstants.NODESET);
        Node nodeListItem;
        int count = nodeList.getLength();
        for (int i = 0; i < count; ++i) {
            nodeListItem = nodeList.item(i);
            result.add(DefaultPortStatistics.builder().setDeviceId(mockDeviceId).setPort(PortNumber.portNumber(TemplateManager.portIdConvert(xp.evaluate("instance-name/text()", nodeListItem)))).setBytesReceived(Long.parseLong(xp.evaluate(rx + "bytes/value/text()", nodeListItem))).setPacketsReceived(Long.parseLong(xp.evaluate(rx + "packets/value/text()", nodeListItem))).setBytesSent(Long.parseLong(xp.evaluate(tx + "bytes/value/text()", nodeListItem))).setPacketsSent(Long.parseLong(xp.evaluate(tx + "packets/value/text()", nodeListItem))).build());
        }
    } catch (XPathExpressionException e) {
        e.printStackTrace();
    }
// TODO: the builder causes this test to fail
// assertEquals(expectResult, result);
}
#method_after
@Test
public void testDiscoverPortStatistics() {
    Collection<PortStatistics> result = new ArrayList<>();
    Collection<PortStatistics> expectResult = getExpectedPortsStatistics();
    try {
        XPath xp = XPathFactory.newInstance().newXPath();
        String tx = "current-bin/statistics/interface-counts/tx/";
        String rx = "current-bin/statistics/interface-counts/rx/";
        Node node = doRequest("/response/discoverPortStatistics.xml", "/rpc-reply/data");
        NodeList nodeList = (NodeList) xp.evaluate("waveserver-pm/ethernet-performance-instances", node, XPathConstants.NODESET);
        Node nodeListItem;
        int count = nodeList.getLength();
        for (int i = 0; i < count; ++i) {
            nodeListItem = nodeList.item(i);
            result.add(DefaultPortStatistics.builder().setDeviceId(mockDeviceId).setPort(PortNumber.portNumber(portIdConvert(xp.evaluate("instance-name/text()", nodeListItem)))).setBytesReceived(Long.parseLong(xp.evaluate(rx + "bytes/value/text()", nodeListItem))).setPacketsReceived(Long.parseLong(xp.evaluate(rx + "packets/value/text()", nodeListItem))).setBytesSent(Long.parseLong(xp.evaluate(tx + "bytes/value/text()", nodeListItem))).setPacketsSent(Long.parseLong(xp.evaluate(tx + "packets/value/text()", nodeListItem))).build());
        }
    } catch (XPathExpressionException e) {
        e.printStackTrace();
    }
// TODO: the builder causes this test to fail
// assertEquals(expectResult, result);
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Node systemInfo = TemplateManager.doRequest(session, "systemInfo");
        Node chassisMac = TemplateManager.doRequest(session, "chassis-mac");
        Node softwareVersion = TemplateManager.doRequest(session, "softwareVersion");
        XPath xp = XPathFactory.newInstance().newXPath();
        String mac = xp.evaluate("lldp-global-operational/chassis-id/text()", chassisMac).toUpperCase();
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, "Ciena", xp.evaluate("components/component/name/text()", systemInfo), xp.evaluate("software-state/running-package/package-version/text()", softwareVersion), mac, new ChassisId(Long.valueOf(mac, 16)));
    } catch (XPathExpressionException | NetconfException ne) {
        log.error("failed to query system info from device {}", handler().data().deviceId(), ne);
    }
    return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, "Ciena", "5170", "Unknown", "Unknown", new ChassisId());
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Node systemInfo = TEMPLATE_MANAGER.doRequest(session, "systemInfo");
        Node chassisMac = TEMPLATE_MANAGER.doRequest(session, "chassis-mac");
        Node softwareVersion = TEMPLATE_MANAGER.doRequest(session, "softwareVersion");
        XPath xp = XPathFactory.newInstance().newXPath();
        String mac = xp.evaluate("lldp-global-operational/chassis-id/text()", chassisMac).toUpperCase();
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, "Ciena", xp.evaluate("components/component/name/text()", systemInfo), xp.evaluate("software-state/running-package/package-version/text()", softwareVersion), mac, new ChassisId(Long.valueOf(mac, 16)));
    } catch (XPathExpressionException | NetconfException ne) {
        log.error("failed to query system info from device {} : {}", handler().data().deviceId(), ne.getMessage(), ne);
    }
    return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, "Ciena", "5170", "Unknown", "Unknown", new ChassisId());
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    List<PortDescription> ports = new ArrayList<PortDescription>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, will be retried", deviceId);
        return ports;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        Node logicalPorts = TemplateManager.doRequest(session, "logicalPorts");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList nl = (NodeList) xp.evaluate("interfaces/interface/config", logicalPorts, XPathConstants.NODESET);
        int count = nl.getLength();
        Node node;
        for (int i = 0; i < count; i += 1) {
            node = nl.item(i);
            if (xp.evaluate("type/text()", node).equals("ettp")) {
                ports.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(xp.evaluate("name/text()", node))).isEnabled(Boolean.valueOf(xp.evaluate("admin-status/text()", node))).portSpeed(portSpeedToLong(xp.evaluate("port-speed/text()", node))).type(Port.Type.PACKET).build());
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port information for device {}, {}", deviceId, e);
    }
    return ports;
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    List<PortDescription> ports = new ArrayList<PortDescription>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, will be retried", deviceId);
        return ports;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        Node logicalPorts = TEMPLATE_MANAGER.doRequest(session, "logicalPorts");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList nl = (NodeList) xp.evaluate("interfaces/interface/config", logicalPorts, XPathConstants.NODESET);
        int count = nl.getLength();
        Node node;
        for (int i = 0; i < count; i += 1) {
            node = nl.item(i);
            if (xp.evaluate("type/text()", node).equals("ettp")) {
                ports.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(xp.evaluate("name/text()", node))).isEnabled(Boolean.valueOf(xp.evaluate("admin-status/text()", node))).portSpeed(portSpeedToLong(xp.evaluate("port-speed/text()", node))).type(Port.Type.PACKET).build());
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port information for device {}, {}", deviceId, e);
    }
    return ports;
}
#end_block

#method_before
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    List<PortStatistics> stats = new ArrayList<PortStatistics>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, will be retried", deviceId);
        return stats;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        Node data = TemplateManager.doRequest(session, "port-stats");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList interfaces = (NodeList) xp.evaluate("interfaces/interface", data, XPathConstants.NODESET);
        int count = interfaces.getLength();
        for (int i = 0; i < count; i += 1) {
            Node iface = interfaces.item(i);
            if (xp.evaluate("config/type/text()", iface).equals("ettp")) {
                stats.add(DefaultPortStatistics.builder().setDeviceId(deviceId).setPort(PortNumber.portNumber(xp.evaluate("name/text()", iface))).setBytesReceived(Long.valueOf(xp.evaluate("state/counters/in-octets/text()", iface))).setBytesSent(Long.valueOf(xp.evaluate("state/counters/out-octets/text()", iface))).setPacketsReceived(Long.valueOf(xp.evaluate("state/counters/in-pkts/text()", iface))).setPacketsSent(Long.valueOf(xp.evaluate("state/counters/out-pkts/text()", iface))).setPacketsTxErrors(Long.valueOf(xp.evaluate("state/counters/out-errors/text()", iface))).setPacketsRxErrors(Long.valueOf(xp.evaluate("state/counters/in-errors/text()", iface))).build());
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port statistics for device {}, {}", deviceId, e);
    }
    return stats;
}
#method_after
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    List<PortStatistics> stats = new ArrayList<PortStatistics>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, will be retried", deviceId);
        return stats;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        Node data = TEMPLATE_MANAGER.doRequest(session, "port-stats");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList interfaces = (NodeList) xp.evaluate("interfaces/interface", data, XPathConstants.NODESET);
        int count = interfaces.getLength();
        for (int i = 0; i < count; i += 1) {
            Node iface = interfaces.item(i);
            if (xp.evaluate("config/type/text()", iface).equals("ettp")) {
                stats.add(DefaultPortStatistics.builder().setDeviceId(deviceId).setPort(PortNumber.portNumber(xp.evaluate("name/text()", iface))).setBytesReceived(Long.valueOf(xp.evaluate("state/counters/in-octets/text()", iface))).setBytesSent(Long.valueOf(xp.evaluate("state/counters/out-octets/text()", iface))).setPacketsReceived(Long.valueOf(xp.evaluate("state/counters/in-pkts/text()", iface))).setPacketsSent(Long.valueOf(xp.evaluate("state/counters/out-pkts/text()", iface))).setPacketsTxErrors(Long.valueOf(xp.evaluate("state/counters/out-errors/text()", iface))).setPacketsRxErrors(Long.valueOf(xp.evaluate("state/counters/in-errors/text()", iface))).build());
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port statistics for device {}, {}", deviceId, e);
    }
    return stats;
}
#end_block

#method_before
@Override
public Set<LinkDescription> getLinks() {
    log.debug("LINKS CHECKING ...");
    Set<LinkDescription> links = new HashSet<LinkDescription>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, cannot load links, will be retried", deviceId);
        return links;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        DeviceService deviceService = this.handler().get(DeviceService.class);
        Iterable<Device> devices = deviceService.getAvailableDevices();
        Map<String, Device> lookup = new HashMap<String, Device>();
        for (Device d : devices) {
            lookup.put(d.chassisId().toString().toUpperCase(), d);
        }
        Node logicalPorts = TemplateManager.doRequest(session, "link-info");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList ifaces = (NodeList) xp.evaluate("interfaces/interface", logicalPorts, XPathConstants.NODESET);
        int count = ifaces.getLength();
        Node iface;
        Node destChassis;
        for (int i = 0; i < count; i += 1) {
            iface = ifaces.item(i);
            if (xp.evaluate("config/type/text()", iface).equals("ettp")) {
                destChassis = (Node) xp.evaluate("state/lldp-remote-port-operational/chassis-id", iface, XPathConstants.NODE);
                if (destChassis != null) {
                    Device dest = lookup.get(destChassis.getTextContent().toUpperCase());
                    if (dest != null) {
                        links.add(new DefaultLinkDescription(new ConnectPoint(deviceId, PortNumber.portNumber(xp.evaluate("name/text()", iface))), new ConnectPoint(dest.id(), PortNumber.portNumber(xp.evaluate("state/lldp-remote-port-operational/port-id/text()", iface))), Link.Type.DIRECT, true));
                    } else {
                        log.error("DEST CHASSIS is NULL for {}", xp.evaluate("name/text()", iface));
                    }
                } else {
                    log.debug("NO LINK for {}", xp.evaluate("name/text()", iface));
                }
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve links for device {}, {}", deviceId, e);
    }
    return links;
}
#method_after
@Override
public Set<LinkDescription> getLinks() {
    log.debug("LINKS CHECKING ...");
    Set<LinkDescription> links = new HashSet<LinkDescription>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, cannot load links, will be retried", deviceId);
        return links;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        DeviceService deviceService = this.handler().get(DeviceService.class);
        Iterable<Device> devices = deviceService.getAvailableDevices();
        Map<String, Device> lookup = new HashMap<String, Device>();
        for (Device d : devices) {
            lookup.put(d.chassisId().toString().toUpperCase(), d);
        }
        Node logicalPorts = TEMPLATE_MANAGER.doRequest(session, "link-info");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList ifaces = (NodeList) xp.evaluate("interfaces/interface", logicalPorts, XPathConstants.NODESET);
        int count = ifaces.getLength();
        Node iface;
        Node destChassis;
        for (int i = 0; i < count; i += 1) {
            iface = ifaces.item(i);
            if (xp.evaluate("config/type/text()", iface).equals("ettp")) {
                destChassis = (Node) xp.evaluate("state/lldp-remote-port-operational/chassis-id", iface, XPathConstants.NODE);
                if (destChassis != null) {
                    Device dest = lookup.get(destChassis.getTextContent().toUpperCase());
                    if (dest != null) {
                        links.add(new DefaultLinkDescription(new ConnectPoint(deviceId, PortNumber.portNumber(xp.evaluate("name/text()", iface))), new ConnectPoint(dest.id(), PortNumber.portNumber(xp.evaluate("state/lldp-remote-port-operational/port-id/text()", iface))), Link.Type.DIRECT, true));
                    } else {
                        log.error("DEST CHASSIS is NULL for {}", xp.evaluate("name/text()", iface));
                    }
                } else {
                    log.debug("NO LINK for {}", xp.evaluate("name/text()", iface));
                }
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve links for device {}, {}", deviceId, e);
    }
    return links;
}
#end_block

#method_before
private CompletableFuture<Boolean> setAdminState(PortNumber number, Boolean value) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toLong());
        templateContext.put("admin-state", value.toString());
        Node req = (Node) TemplateManager.doRequest(session, "port-admin-state", templateContext, "/", XPathConstants.NODE);
        XPath xp = XPathFactory.newInstance().newXPath();
        // If OK element exists then it worked.
        Node ok = (Node) xp.evaluate("/rpc-reply/ok", req, XPathConstants.NODE);
        return CompletableFuture.completedFuture(ok != null);
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to set port admin state for port {} to {}", number, handler().data().deviceId(), value, e);
    }
    return CompletableFuture.completedFuture(false);
}
#method_after
private CompletableFuture<Boolean> setAdminState(PortNumber number, Boolean value) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toLong());
        templateContext.put("admin-state", value.toString());
        Node req = (Node) TEMPLATE_MANAGER.doRequest(session, "port-admin-state", templateContext, "/", XPathConstants.NODE);
        XPath xp = XPathFactory.newInstance().newXPath();
        // If OK element exists then it worked.
        Node ok = (Node) xp.evaluate("/rpc-reply/ok", req, XPathConstants.NODE);
        return CompletableFuture.completedFuture(ok != null);
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to set port admin state for port {} to {}", number, handler().data().deviceId(), value, e);
    }
    return CompletableFuture.completedFuture(false);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isEnabled(PortNumber number) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toString());
        Node port = TemplateManager.doRequest(session, "logicalPort", templateContext);
        XPath xp = XPathFactory.newInstance().newXPath();
        log.error("SOMEONE IS LOOKING: {}", Boolean.valueOf(xp.evaluate("admin-status/text()", port)));
        return CompletableFuture.completedFuture(Boolean.valueOf(xp.evaluate("admin-status/text()", port)));
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to query port state for port {} from device {}", number, handler().data().deviceId(), e);
    }
    return CompletableFuture.completedFuture(false);
}
#method_after
@Override
public CompletableFuture<Boolean> isEnabled(PortNumber number) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toString());
        Node port = TEMPLATE_MANAGER.doRequest(session, "logicalPort", templateContext);
        XPath xp = XPathFactory.newInstance().newXPath();
        return CompletableFuture.completedFuture(Boolean.valueOf(xp.evaluate("admin-status/text()", port)));
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to query port state for port {} from device {}", number, handler().data().deviceId(), e);
    }
    return CompletableFuture.completedFuture(false);
}
#end_block

#method_before
private CompletableFuture<Boolean> setAdminState(PortNumber number, Boolean value) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toLong());
        templateContext.put("admin-state", value.toString());
        Node req = (Node) TemplateManager.doRequest(session, "port-admin-state", templateContext, "/", XPathConstants.NODE);
        XPath xp = XPathFactory.newInstance().newXPath();
        // If OK element exists then it worked.
        Node ok = (Node) xp.evaluate("/rpc-reply/ok", req, XPathConstants.NODE);
        return CompletableFuture.completedFuture(ok != null);
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to set port admin state for port {} to {}", number, handler().data().deviceId(), value, e);
    }
    return CompletableFuture.completedFuture(false);
}
#method_after
private CompletableFuture<Boolean> setAdminState(PortNumber number, Boolean value) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toLong());
        templateContext.put("admin-state", value.toString());
        Node req = (Node) TEMPLATE_MANAGER.doRequest(session, "port-admin-state", templateContext, "/", XPathConstants.NODE);
        XPath xp = XPathFactory.newInstance().newXPath();
        // If OK element exists then it worked.
        Node ok = (Node) xp.evaluate("/rpc-reply/ok", req, XPathConstants.NODE);
        return CompletableFuture.completedFuture(ok != null);
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to set port admin state for port {} to {}", number, handler().data().deviceId(), value, e);
    }
    return CompletableFuture.completedFuture(false);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isEnabled(PortNumber number) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toString());
        Node port = TemplateManager.doRequest(session, "logicalPort", templateContext);
        XPath xp = XPathFactory.newInstance().newXPath();
        log.error("SOMEONE IS LOOKING: {}", Boolean.valueOf(xp.evaluate("admin-status/text()", port)));
        return CompletableFuture.completedFuture(Boolean.valueOf(xp.evaluate("admin-status/text()", port)));
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to query port state for port {} from device {}", number, handler().data().deviceId(), e);
    }
    return CompletableFuture.completedFuture(false);
}
#method_after
@Override
public CompletableFuture<Boolean> isEnabled(PortNumber number) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Map<String, Object> templateContext = new HashMap<String, Object>();
        templateContext.put("port-number", number.toString());
        Node port = TEMPLATE_MANAGER.doRequest(session, "logicalPort", templateContext);
        XPath xp = XPathFactory.newInstance().newXPath();
        return CompletableFuture.completedFuture(Boolean.valueOf(xp.evaluate("admin-status/text()", port)));
    } catch (XPathExpressionException | NetconfException e) {
        log.error("Unable to query port state for port {} from device {}", number, handler().data().deviceId(), e);
    }
    return CompletableFuture.completedFuture(false);
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Node systemInfo = TemplateManager.doRequest(session, "systemInfo");
        Node softwareVersion = TemplateManager.doRequest(session, "softwareVersion");
        XPath xp = XPathFactory.newInstance().newXPath();
        String mac = xp.evaluate("components/component/properties/property/state/value/text()", systemInfo).toUpperCase();
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, xp.evaluate("components/component/state/mfg-name/text()", systemInfo), xp.evaluate("components/component/state/name/text()", systemInfo), xp.evaluate("software-state/running-package/package-version/text()", softwareVersion), xp.evaluate("components/component/state/serial-no/text()", systemInfo), new ChassisId(Long.valueOf(mac, 16)));
    } catch (XPathExpressionException | NetconfException ne) {
        log.error("failed to query system info from device {}", handler().data().deviceId(), ne);
    }
    return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, "Ciena", "5162", "Unknown", "Unknown", new ChassisId());
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        Node systemInfo = TEMPLATE_MANAGER.doRequest(session, "systemInfo");
        Node softwareVersion = TEMPLATE_MANAGER.doRequest(session, "softwareVersion");
        XPath xp = XPathFactory.newInstance().newXPath();
        String mac = xp.evaluate("components/component/properties/property/state/value/text()", systemInfo).toUpperCase();
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, xp.evaluate("components/component/state/mfg-name/text()", systemInfo), xp.evaluate("components/component/state/name/text()", systemInfo), xp.evaluate("software-state/running-package/package-version/text()", softwareVersion), xp.evaluate("components/component/state/serial-no/text()", systemInfo), new ChassisId(Long.valueOf(mac, 16)));
    } catch (XPathExpressionException | NetconfException ne) {
        log.error("failed to query system info from device {}", handler().data().deviceId(), ne);
    }
    return new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, "Ciena", "5162", "Unknown", "Unknown", new ChassisId());
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    List<PortDescription> ports = new ArrayList<PortDescription>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, will be retried", deviceId);
        return ports;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        Node logicalPorts = TemplateManager.doRequest(session, "logicalPorts");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList nl = (NodeList) xp.evaluate("interfaces/interface/config", logicalPorts, XPathConstants.NODESET);
        int count = nl.getLength();
        Node node;
        for (int i = 0; i < count; i += 1) {
            node = nl.item(i);
            if (xp.evaluate("type/text()", node).equals("ettp")) {
                ports.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(xp.evaluate("name/text()", node))).isEnabled(Boolean.valueOf(xp.evaluate("admin-status/text()", node))).portSpeed(portSpeedToLong(xp.evaluate("port-speed/text()", node))).type(Port.Type.PACKET).build());
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port information for device {}, {}", deviceId, e);
    }
    return ports;
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    List<PortDescription> ports = new ArrayList<PortDescription>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, will be retried", deviceId);
        return ports;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        Node logicalPorts = TEMPLATE_MANAGER.doRequest(session, "logicalPorts");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList nl = (NodeList) xp.evaluate("interfaces/interface/config", logicalPorts, XPathConstants.NODESET);
        int count = nl.getLength();
        Node node;
        for (int i = 0; i < count; i += 1) {
            node = nl.item(i);
            if (xp.evaluate("type/text()", node).equals("ettp")) {
                ports.add(DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(xp.evaluate("name/text()", node))).isEnabled(Boolean.valueOf(xp.evaluate("admin-status/text()", node))).portSpeed(portSpeedToLong(xp.evaluate("port-speed/text()", node))).type(Port.Type.PACKET).build());
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port information for device {}, {}", deviceId, e);
    }
    return ports;
}
#end_block

#method_before
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    List<PortStatistics> stats = new ArrayList<PortStatistics>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, will be retried", deviceId);
        return stats;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        Node data = TemplateManager.doRequest(session, "port-stats");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList interfaces = (NodeList) xp.evaluate("interfaces/interface", data, XPathConstants.NODESET);
        int count = interfaces.getLength();
        for (int i = 0; i < count; i += 1) {
            Node iface = interfaces.item(i);
            if (xp.evaluate("config/type/text()", iface).equals("ettp")) {
                stats.add(DefaultPortStatistics.builder().setDeviceId(deviceId).setPort(PortNumber.portNumber(xp.evaluate("name/text()", iface))).setBytesReceived(Long.valueOf(xp.evaluate("state/counters/in-octets/text()", iface))).setBytesSent(Long.valueOf(xp.evaluate("state/counters/out-octets/text()", iface))).setPacketsReceived(Long.valueOf(xp.evaluate("state/counters/in-pkts/text()", iface))).setPacketsSent(Long.valueOf(xp.evaluate("state/counters/out-pkts/text()", iface))).setPacketsTxErrors(Long.valueOf(xp.evaluate("state/counters/out-errors/text()", iface))).setPacketsRxErrors(Long.valueOf(xp.evaluate("state/counters/in-errors/text()", iface))).build());
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port statistics for device {}, {}", deviceId, e);
    }
    return stats;
}
#method_after
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    List<PortStatistics> stats = new ArrayList<PortStatistics>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, will be retried", deviceId);
        return stats;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        Node data = TEMPLATE_MANAGER.doRequest(session, "port-stats");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList interfaces = (NodeList) xp.evaluate("interfaces/interface", data, XPathConstants.NODESET);
        int count = interfaces.getLength();
        for (int i = 0; i < count; i += 1) {
            Node iface = interfaces.item(i);
            if (xp.evaluate("config/type/text()", iface).equals("ettp")) {
                stats.add(DefaultPortStatistics.builder().setDeviceId(deviceId).setPort(PortNumber.portNumber(xp.evaluate("name/text()", iface))).setBytesReceived(Long.valueOf(xp.evaluate("state/counters/in-octets/text()", iface))).setBytesSent(Long.valueOf(xp.evaluate("state/counters/out-octets/text()", iface))).setPacketsReceived(Long.valueOf(xp.evaluate("state/counters/in-pkts/text()", iface))).setPacketsSent(Long.valueOf(xp.evaluate("state/counters/out-pkts/text()", iface))).setPacketsTxErrors(Long.valueOf(xp.evaluate("state/counters/out-errors/text()", iface))).setPacketsRxErrors(Long.valueOf(xp.evaluate("state/counters/in-errors/text()", iface))).build());
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve port statistics for device {}, {}", deviceId, e);
    }
    return stats;
}
#end_block

#method_before
@Override
public Set<LinkDescription> getLinks() {
    log.debug("LINKS CHECKING ...");
    Set<LinkDescription> links = new HashSet<LinkDescription>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, cannot load links, will be retried", deviceId);
        return links;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        DeviceService deviceService = this.handler().get(DeviceService.class);
        Iterable<Device> devices = deviceService.getAvailableDevices();
        Map<String, Device> lookup = new HashMap<String, Device>();
        for (Device d : devices) {
            lookup.put(d.chassisId().toString().toUpperCase(), d);
        }
        Node logicalPorts = TemplateManager.doRequest(session, "link-info");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList ifaces = (NodeList) xp.evaluate("interfaces/interface", logicalPorts, XPathConstants.NODESET);
        int count = ifaces.getLength();
        Node iface;
        Node destChassis;
        for (int i = 0; i < count; i += 1) {
            iface = ifaces.item(i);
            if (xp.evaluate("config/type/text()", iface).equals("ettp")) {
                destChassis = (Node) xp.evaluate("state/lldp-remote-port-operational/chassis-id", iface, XPathConstants.NODE);
                if (destChassis != null) {
                    Device dest = lookup.get(destChassis.getTextContent().toUpperCase());
                    if (dest != null) {
                        links.add(new DefaultLinkDescription(new ConnectPoint(deviceId, PortNumber.portNumber(xp.evaluate("name/text()", iface))), new ConnectPoint(dest.id(), PortNumber.portNumber(xp.evaluate("state/lldp-remote-port-operational/port-id/text()", iface))), Link.Type.DIRECT, true));
                    } else {
                        log.error("DEST CHASSIS is NULL for {}", xp.evaluate("name/text()", iface));
                    }
                } else {
                    log.debug("NO LINK for {}", xp.evaluate("name/text()", iface));
                }
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve links for device {}, {}", deviceId, e);
    }
    return links;
}
#method_after
@Override
public Set<LinkDescription> getLinks() {
    log.debug("LINKS CHECKING ...");
    Set<LinkDescription> links = new HashSet<LinkDescription>();
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    if (controller == null || controller.getDevicesMap() == null || controller.getDevicesMap().get(deviceId) == null) {
        log.warn("NETCONF session to device {} not yet established, cannot load links, will be retried", deviceId);
        return links;
    }
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        DeviceService deviceService = this.handler().get(DeviceService.class);
        Iterable<Device> devices = deviceService.getAvailableDevices();
        Map<String, Device> lookup = new HashMap<String, Device>();
        for (Device d : devices) {
            lookup.put(d.chassisId().toString().toUpperCase(), d);
        }
        Node logicalPorts = TEMPLATE_MANAGER.doRequest(session, "link-info");
        XPath xp = XPathFactory.newInstance().newXPath();
        NodeList ifaces = (NodeList) xp.evaluate("interfaces/interface", logicalPorts, XPathConstants.NODESET);
        int count = ifaces.getLength();
        Node iface;
        Node destChassis;
        for (int i = 0; i < count; i += 1) {
            iface = ifaces.item(i);
            if (xp.evaluate("config/type/text()", iface).equals("ettp")) {
                destChassis = (Node) xp.evaluate("state/lldp-remote-port-operational/chassis-id", iface, XPathConstants.NODE);
                if (destChassis != null) {
                    Device dest = lookup.get(destChassis.getTextContent().toUpperCase());
                    if (dest != null) {
                        links.add(new DefaultLinkDescription(new ConnectPoint(deviceId, PortNumber.portNumber(xp.evaluate("name/text()", iface))), new ConnectPoint(dest.id(), PortNumber.portNumber(xp.evaluate("state/lldp-remote-port-operational/port-id/text()", iface))), Link.Type.DIRECT, true));
                    } else {
                        log.error("DEST CHASSIS is NULL for {}", xp.evaluate("name/text()", iface));
                    }
                } else {
                    log.debug("NO LINK for {}", xp.evaluate("name/text()", iface));
                }
            }
        }
    } catch (NetconfException | XPathExpressionException e) {
        log.error("Unable to retrieve links for device {}, {}", deviceId, e);
    }
    return links;
}
#end_block

#method_before
private void process(DeviceId deviceId, Objective originalObjective) {
    // Inject ObjectiveContext such that we can get notified when it is completed
    Objective.Builder objBuilder = originalObjective.copy();
    Optional<ObjectiveContext> originalContext = originalObjective.context();
    ObjectiveContext context = new ObjectiveContext() {

        @Override
        public void onSuccess(Objective objective) {
            log.trace("Flow objective onSuccess {}", objective);
            dequeue(deviceId, objective, false);
            originalContext.ifPresent(c -> c.onSuccess(objective));
        }

        @Override
        public void onError(Objective objective, ObjectiveError error) {
            log.warn("Flow objective onError {}. {}", objective, error);
            dequeue(deviceId, objective, true);
            originalContext.ifPresent(c -> c.onError(objective, error));
        }
    };
    // Preserve Objective.Operation
    Objective objective;
    switch(originalObjective.op()) {
        case ADD:
            objective = objBuilder.add(context);
            break;
        case ADD_TO_EXISTING:
            objective = ((NextObjective.Builder) objBuilder).addToExisting(context);
            break;
        case REMOVE:
            objective = objBuilder.remove(context);
            break;
        case REMOVE_FROM_EXISTING:
            objective = ((NextObjective.Builder) objBuilder).removeFromExisting(context);
            break;
        case MODIFY:
            objective = ((NextObjective.Builder) objBuilder).modify(context);
            break;
        case VERIFY:
            objective = ((NextObjective.Builder) objBuilder).verify(context);
            break;
        default:
            log.error("Unknown flow objecitve operation {}", originalObjective.op());
            return;
    }
    enqueue(deviceId, objective);
}
#method_after
private void process(DeviceId deviceId, Objective originalObjective) {
    // Inject ObjectiveContext such that we can get notified when it is completed
    Objective.Builder objBuilder = originalObjective.copy();
    Optional<ObjectiveContext> originalContext = originalObjective.context();
    ObjectiveContext context = new ObjectiveContext() {

        @Override
        public void onSuccess(Objective objective) {
            log.trace("Flow objective onSuccess {}", objective);
            dequeue(deviceId, objective, null);
            originalContext.ifPresent(c -> c.onSuccess(objective));
        }

        @Override
        public void onError(Objective objective, ObjectiveError error) {
            log.warn("Flow objective onError {}. Reason = {}", objective, error);
            dequeue(deviceId, objective, error);
            originalContext.ifPresent(c -> c.onError(objective, error));
        }
    };
    // Preserve Objective.Operation
    Objective objective;
    switch(originalObjective.op()) {
        case ADD:
            objective = objBuilder.add(context);
            break;
        case ADD_TO_EXISTING:
            objective = ((NextObjective.Builder) objBuilder).addToExisting(context);
            break;
        case REMOVE:
            objective = objBuilder.remove(context);
            break;
        case REMOVE_FROM_EXISTING:
            objective = ((NextObjective.Builder) objBuilder).removeFromExisting(context);
            break;
        case MODIFY:
            objective = ((NextObjective.Builder) objBuilder).modify(context);
            break;
        case VERIFY:
            objective = ((NextObjective.Builder) objBuilder).verify(context);
            break;
        default:
            log.error("Unknown flow objecitve operation {}", originalObjective.op());
            return;
    }
    enqueue(deviceId, objective);
}
#end_block

#method_before
private synchronized void dequeue(DeviceId deviceId, Objective obj, boolean isError) {
    List<Objective> remaining;
    int priority = obj.priority();
    LogLevel logLevel = (obj.op() == Objective.Operation.VERIFY) ? LogLevel.TRACE : LogLevel.DEBUG;
    Tools.log(log, logLevel, "Dequeue {}", obj);
    if (obj instanceof FilteringObjective) {
        FilteringObjQueueKey k = new FilteringObjQueueKey(deviceId, priority, ((FilteringObjective) obj).key());
        filtObjQueueHead.invalidate(k);
        filtObjQueue.remove(k, obj);
        remaining = filtObjQueue.get(k);
    } else if (obj instanceof ForwardingObjective) {
        ForwardingObjQueueKey k = new ForwardingObjQueueKey(deviceId, priority, ((ForwardingObjective) obj).selector());
        fwdObjQueueHead.invalidate(k);
        fwdObjQueue.remove(k, obj);
        remaining = fwdObjQueue.get(k);
    } else if (obj instanceof NextObjective) {
        if (isError) {
            // Remove pendingForwards and pendingNexts if next objective failed
            pendingForwards.remove(obj.id());
            pendingNexts.remove(obj.id());
        }
        NextObjQueueKey k = new NextObjQueueKey(deviceId, obj.id());
        nextObjQueueHead.invalidate(k);
        nextObjQueue.remove(k, obj);
        remaining = nextObjQueue.get(k);
    } else {
        log.error("Unknown flow objective instance: {}", obj.getClass().getName());
        return;
    }
    log.trace("{} queue size {}", obj.getClass().getSimpleName(), remaining.size());
    // Submit the next one in the queue, if any
    if (remaining.size() > 0) {
        execute(deviceId, remaining.get(0));
    }
}
#method_after
private synchronized void dequeue(DeviceId deviceId, Objective obj, ObjectiveError error) {
    List<Objective> remaining;
    int priority = obj.priority();
    LogLevel logLevel = (obj.op() == Objective.Operation.VERIFY) ? LogLevel.TRACE : LogLevel.DEBUG;
    Tools.log(log, logLevel, "Dequeue {}", obj);
    if (obj instanceof FilteringObjective) {
        FilteringObjQueueKey k = new FilteringObjQueueKey(deviceId, priority, ((FilteringObjective) obj).key());
        filtObjQueueHead.invalidate(k);
        filtObjQueue.remove(k, obj);
        remaining = filtObjQueue.get(k);
    } else if (obj instanceof ForwardingObjective) {
        ForwardingObjQueueKey k = new ForwardingObjQueueKey(deviceId, priority, ((ForwardingObjective) obj).selector());
        fwdObjQueueHead.invalidate(k);
        fwdObjQueue.remove(k, obj);
        remaining = fwdObjQueue.get(k);
    } else if (obj instanceof NextObjective) {
        if (error != null) {
            // Remove pendingForwards and pendingNexts if next objective failed
            Set<PendingFlowObjective> removedForwards = pendingForwards.remove(obj.id());
            List<PendingFlowObjective> removedNexts = pendingNexts.remove(obj.id());
            if (removedForwards != null) {
                removedForwards.stream().map(PendingFlowObjective::flowObjective).forEach(pendingObj -> pendingObj.context().ifPresent(c -> c.onError(pendingObj, error)));
            }
            if (removedNexts != null) {
                removedNexts.stream().map(PendingFlowObjective::flowObjective).forEach(pendingObj -> pendingObj.context().ifPresent(c -> c.onError(pendingObj, error)));
            }
        }
        NextObjQueueKey k = new NextObjQueueKey(deviceId, obj.id());
        nextObjQueueHead.invalidate(k);
        nextObjQueue.remove(k, obj);
        remaining = nextObjQueue.get(k);
    } else {
        log.error("Unknown flow objective instance: {}", obj.getClass().getName());
        return;
    }
    log.trace("{} queue size {}", obj.getClass().getSimpleName(), remaining.size());
    // Submit the next one in the queue, if any
    if (remaining.size() > 0) {
        execute(deviceId, remaining.get(0));
    }
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<DummyVlanIdStoreKey, VlanId> dummyVlanIdMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dummyVlanIdStore = dummyVlanIdMapBuilder.withName("dummyvlanidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    topologyHandler = new TopologyHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    topologyService.addListener(topologyListener);
    linkHandler.init();
    l2TunnelHandler.init();
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    mainEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-main", "%d", log));
    hostEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-host", "%d", log));
    routeEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-route", "%d", log));
    mcastEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-mcast", "%d", log));
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<DummyVlanIdStoreKey, VlanId> dummyVlanIdMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dummyVlanIdStore = dummyVlanIdMapBuilder.withName("dummyvlanidstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    topologyHandler = new TopologyHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    topologyService.addListener(topologyListener);
    mastershipService.addListener(mastershipListener);
    clusterService.addListener(clusterListener);
    linkHandler.init();
    l2TunnelHandler.init();
    networkConfigCompletion.whenComplete((value, ex) -> {
        // setting to null for easier fall through
        networkConfigCompletion = null;
        // process all queued events
        queuedEvents.forEach(event -> {
            mainEventExecutor.execute(new InternalEventHandler(event));
        });
    });
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    topologyService.removeListener(topologyListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    dummyVlanIdStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    mainEventExecutor.shutdown();
    hostEventExecutor.shutdown();
    routeEventExecutor.shutdown();
    mcastEventExecutor.shutdown();
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    topologyService.removeListener(topologyListener);
    mastershipService.removeListener(mastershipListener);
    clusterService.removeListener(clusterListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.forEach((k, v) -> v.shutdown());
    groupHandlerMap.clear();
    defaultRoutingHandler.shutdown();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    dummyVlanIdStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#end_block

#method_before
public VlanId allocateDummyVlanId(ConnectPoint cp, IpAddress ipAddress) {
    Set<VlanId> usedVlanId = Sets.union(getVlanPortMap(cp.deviceId()).keySet(), dummyVlanIdStore.entrySet().stream().filter(entry -> (entry.getKey()).connectPoint().equals(cp)).map(Map.Entry::getValue).collect(Collectors.toSet()));
    VlanId dummyVlanId = IntStream.range(MIN_DUMMY_VLAN_ID, MAX_DUMMY_VLAN_ID).mapToObj(i -> VlanId.vlanId((short) (i & 0xFFFF))).filter(vlanId -> !usedVlanId.contains(vlanId)).findFirst().orElse(VlanId.NONE);
    if (!dummyVlanId.equals(VlanId.NONE)) {
        this.dummyVlanIdStore.put(new DummyVlanIdStoreKey(cp, ipAddress), dummyVlanId);
        log.debug("Dummy VLAN ID {} is allocated to {}, {}", dummyVlanId, cp, ipAddress);
    } else {
        log.info("Failed to allocate dummy VLAN ID for {}, {}", cp, ipAddress);
    }
    return dummyVlanId;
}
#method_after
public synchronized VlanId allocateDummyVlanId(ConnectPoint cp, IpAddress ipAddress) {
    Set<VlanId> usedVlanId = Sets.union(getVlanPortMap(cp.deviceId()).keySet(), dummyVlanIdStore.entrySet().stream().filter(entry -> (entry.getKey()).connectPoint().equals(cp)).map(Map.Entry::getValue).collect(Collectors.toSet()));
    VlanId dummyVlanId = IntStream.range(MIN_DUMMY_VLAN_ID, MAX_DUMMY_VLAN_ID).mapToObj(i -> VlanId.vlanId((short) (i & 0xFFFF))).filter(vlanId -> !usedVlanId.contains(vlanId)).findFirst().orElse(VlanId.NONE);
    if (!dummyVlanId.equals(VlanId.NONE)) {
        this.dummyVlanIdStore.put(new DummyVlanIdStoreKey(cp, ipAddress), dummyVlanId);
        log.debug("Dummy VLAN ID {} is allocated to {}, {}", dummyVlanId, cp, ipAddress);
    } else {
        log.error("Failed to allocate dummy VLAN ID for {}, {}", cp, ipAddress);
    }
    return dummyVlanId;
}
#end_block

#method_before
@Override
public void run() {
    try {
        // TODO We should also change SR routing and PW to listen to TopologyEvents
        if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
            linkHandler.processLinkAdded((Link) event.subject());
        } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
            linkHandler.processLinkRemoved((Link) event.subject());
        } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
            DeviceId deviceId = ((Device) event.subject()).id();
            if (deviceService.isAvailable(deviceId)) {
                log.info("** DEVICE UP Processing device event {} " + "for available device {}", event.type(), ((Device) event.subject()).id());
                processDeviceAdded((Device) event.subject());
            } else {
                log.info(" ** DEVICE DOWN Processing device event {}" + " for unavailable device {}", event.type(), ((Device) event.subject()).id());
                processDeviceRemoved((Device) event.subject());
            }
        } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
            // typically these calls come when device is added first time
            // so port filtering rules are handled at the device_added event.
            // port added calls represent all ports on the device,
            // enabled or not.
            log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
        } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
            // these calls happen for every subsequent event
            // ports enabled, disabled, switch goes away, comes back
            log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
            processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
        } else if (event.type() == TopologyEvent.Type.TOPOLOGY_CHANGED) {
            // Process topology event, needed for all modules relying on
            // topology service for path computation
            TopologyEvent topologyEvent = (TopologyEvent) event;
            log.info("Processing topology event {}, topology age {}, reasons {}", event.type(), topologyEvent.subject().time(), topologyEvent.reasons().size());
            topologyHandler.processTopologyChange(topologyEvent.reasons());
        } else if (event.type() == HostEvent.Type.HOST_ADDED) {
            hostHandler.processHostAddedEvent((HostEvent) event);
        } else if (event.type() == HostEvent.Type.HOST_MOVED) {
            hostHandler.processHostMovedEvent((HostEvent) event);
            routeHandler.processHostMovedEvent((HostEvent) event);
        } else if (event.type() == HostEvent.Type.HOST_REMOVED) {
            hostHandler.processHostRemovedEvent((HostEvent) event);
        } else if (event.type() == HostEvent.Type.HOST_UPDATED) {
            hostHandler.processHostUpdatedEvent((HostEvent) event);
        } else if (event.type() == RouteEvent.Type.ROUTE_ADDED) {
            routeHandler.processRouteAdded((RouteEvent) event);
        } else if (event.type() == RouteEvent.Type.ROUTE_UPDATED) {
            routeHandler.processRouteUpdated((RouteEvent) event);
        } else if (event.type() == RouteEvent.Type.ROUTE_REMOVED) {
            routeHandler.processRouteRemoved((RouteEvent) event);
        } else if (event.type() == RouteEvent.Type.ALTERNATIVE_ROUTES_CHANGED) {
            routeHandler.processAlternativeRoutesChanged((RouteEvent) event);
        } else if (event.type() == McastEvent.Type.SOURCES_ADDED || event.type() == McastEvent.Type.SOURCES_REMOVED || event.type() == McastEvent.Type.SINKS_ADDED || event.type() == McastEvent.Type.SINKS_REMOVED || event.type() == McastEvent.Type.ROUTE_ADDED || event.type() == McastEvent.Type.ROUTE_REMOVED) {
            mcastHandler.processMcastEvent((McastEvent) event);
        } else if (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED) {
            NetworkConfigEvent netcfgEvent = (NetworkConfigEvent) event;
            Class configClass = netcfgEvent.configClass();
            if (configClass.equals(SegmentRoutingAppConfig.class)) {
                appCfgHandler.processAppConfigAdded(netcfgEvent);
                log.info("App config event .. configuring network");
                cfgListener.configureNetwork();
            } else if (configClass.equals(SegmentRoutingDeviceConfig.class)) {
                log.info("Segment Routing Device Config added for {}", event.subject());
                cfgListener.configureNetwork();
            } else if (configClass.equals(XConnectConfig.class)) {
                xConnectHandler.processXConnectConfigAdded(netcfgEvent);
            } else if (configClass.equals(InterfaceConfig.class)) {
                log.info("Interface Config added for {}", event.subject());
                cfgListener.configureNetwork();
            } else {
                log.error("Unhandled config class: {}", configClass);
            }
        } else if (event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED) {
            NetworkConfigEvent netcfgEvent = (NetworkConfigEvent) event;
            Class configClass = netcfgEvent.configClass();
            if (configClass.equals(SegmentRoutingAppConfig.class)) {
                appCfgHandler.processAppConfigUpdated(netcfgEvent);
                log.info("App config event .. configuring network");
                cfgListener.configureNetwork();
            } else if (configClass.equals(SegmentRoutingDeviceConfig.class)) {
                log.info("Segment Routing Device Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
            } else if (configClass.equals(XConnectConfig.class)) {
                xConnectHandler.processXConnectConfigUpdated(netcfgEvent);
            } else if (configClass.equals(InterfaceConfig.class)) {
                log.info("Interface Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                updateInterface((InterfaceConfig) netcfgEvent.config().get(), (InterfaceConfig) netcfgEvent.prevConfig().get());
            } else {
                log.error("Unhandled config class: {}", configClass);
            }
        } else if (event.type() == NetworkConfigEvent.Type.CONFIG_REMOVED) {
            NetworkConfigEvent netcfgEvent = (NetworkConfigEvent) event;
            Class configClass = netcfgEvent.configClass();
            if (configClass.equals(SegmentRoutingAppConfig.class)) {
                appCfgHandler.processAppConfigRemoved(netcfgEvent);
                log.info("App config event .. configuring network");
                cfgListener.configureNetwork();
            } else if (configClass.equals(SegmentRoutingDeviceConfig.class)) {
                // TODO Handle sr device config removal
                log.info("SegmentRoutingDeviceConfig removal is not handled in current implementation");
            } else if (configClass.equals(XConnectConfig.class)) {
                xConnectHandler.processXConnectConfigRemoved(netcfgEvent);
            } else if (configClass.equals(InterfaceConfig.class)) {
                // TODO Handle interface removal
                log.info("InterfaceConfig removal is not handled in current implementation");
            } else {
                log.error("Unhandled config class: {}", configClass);
            }
        } else {
            log.warn("Unhandled event type: {}", event.type());
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler thread thrown an exception: {}", e.getMessage(), e);
    }
}
#method_after
@Override
public void run() {
    try {
        // TODO We should also change SR routing and PW to listen to TopologyEvents
        if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
            linkHandler.processLinkAdded((Link) event.subject());
        } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
            linkHandler.processLinkRemoved((Link) event.subject());
        } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
            DeviceId deviceId = ((Device) event.subject()).id();
            if (deviceService.isAvailable(deviceId)) {
                log.info("** DEVICE UP Processing device event {} " + "for available device {}", event.type(), ((Device) event.subject()).id());
                processDeviceAdded((Device) event.subject());
            } else {
                log.info(" ** DEVICE DOWN Processing device event {}" + " for unavailable device {}", event.type(), ((Device) event.subject()).id());
                processDeviceRemoved((Device) event.subject());
            }
        } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
            // typically these calls come when device is added first time
            // so port filtering rules are handled at the device_added event.
            // port added calls represent all ports on the device,
            // enabled or not.
            log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
        } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
            // these calls happen for every subsequent event
            // ports enabled, disabled, switch goes away, comes back
            log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
            processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
        } else if (event.type() == TopologyEvent.Type.TOPOLOGY_CHANGED) {
            // Process topology event, needed for all modules relying on
            // topology service for path computation
            TopologyEvent topologyEvent = (TopologyEvent) event;
            log.info("Processing topology event {}, topology age {}, reasons {}", event.type(), topologyEvent.subject().time(), topologyEvent.reasons().size());
            topologyHandler.processTopologyChange(topologyEvent.reasons());
        } else if (event.type() == HostEvent.Type.HOST_ADDED) {
            hostHandler.processHostAddedEvent((HostEvent) event);
        } else if (event.type() == HostEvent.Type.HOST_MOVED) {
            hostHandler.processHostMovedEvent((HostEvent) event);
            routeHandler.processHostMovedEvent((HostEvent) event);
        } else if (event.type() == HostEvent.Type.HOST_REMOVED) {
            hostHandler.processHostRemovedEvent((HostEvent) event);
        } else if (event.type() == HostEvent.Type.HOST_UPDATED) {
            hostHandler.processHostUpdatedEvent((HostEvent) event);
        } else if (event.type() == RouteEvent.Type.ROUTE_ADDED) {
            routeHandler.processRouteAdded((RouteEvent) event);
        } else if (event.type() == RouteEvent.Type.ROUTE_UPDATED) {
            routeHandler.processRouteUpdated((RouteEvent) event);
        } else if (event.type() == RouteEvent.Type.ROUTE_REMOVED) {
            routeHandler.processRouteRemoved((RouteEvent) event);
        } else if (event.type() == RouteEvent.Type.ALTERNATIVE_ROUTES_CHANGED) {
            routeHandler.processAlternativeRoutesChanged((RouteEvent) event);
        } else if (event.type() == McastEvent.Type.SOURCES_ADDED || event.type() == McastEvent.Type.SOURCES_REMOVED || event.type() == McastEvent.Type.SINKS_ADDED || event.type() == McastEvent.Type.SINKS_REMOVED || event.type() == McastEvent.Type.ROUTE_ADDED || event.type() == McastEvent.Type.ROUTE_REMOVED) {
            mcastHandler.processMcastEvent((McastEvent) event);
        } else if (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED) {
            NetworkConfigEvent netcfgEvent = (NetworkConfigEvent) event;
            Class configClass = netcfgEvent.configClass();
            if (configClass.equals(SegmentRoutingAppConfig.class)) {
                appCfgHandler.processAppConfigAdded(netcfgEvent);
                log.info("App config event .. configuring network");
                cfgListener.configureNetwork();
            } else if (configClass.equals(SegmentRoutingDeviceConfig.class)) {
                log.info("Segment Routing Device Config added for {}", event.subject());
                cfgListener.configureNetwork();
            } else if (configClass.equals(XConnectConfig.class)) {
                xConnectHandler.processXConnectConfigAdded(netcfgEvent);
            } else if (configClass.equals(InterfaceConfig.class)) {
                log.info("Interface Config added for {}", event.subject());
                cfgListener.configureNetwork();
            } else {
                log.error("Unhandled config class: {}", configClass);
            }
        } else if (event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED) {
            NetworkConfigEvent netcfgEvent = (NetworkConfigEvent) event;
            Class configClass = netcfgEvent.configClass();
            if (configClass.equals(SegmentRoutingAppConfig.class)) {
                appCfgHandler.processAppConfigUpdated(netcfgEvent);
                log.info("App config event .. configuring network");
                cfgListener.configureNetwork();
            } else if (configClass.equals(SegmentRoutingDeviceConfig.class)) {
                log.info("Segment Routing Device Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
            } else if (configClass.equals(XConnectConfig.class)) {
                xConnectHandler.processXConnectConfigUpdated(netcfgEvent);
            } else if (configClass.equals(InterfaceConfig.class)) {
                log.info("Interface Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                updateInterface((InterfaceConfig) netcfgEvent.config().get(), (InterfaceConfig) netcfgEvent.prevConfig().get());
            } else {
                log.error("Unhandled config class: {}", configClass);
            }
        } else if (event.type() == NetworkConfigEvent.Type.CONFIG_REMOVED) {
            NetworkConfigEvent netcfgEvent = (NetworkConfigEvent) event;
            Class configClass = netcfgEvent.configClass();
            if (configClass.equals(SegmentRoutingAppConfig.class)) {
                appCfgHandler.processAppConfigRemoved(netcfgEvent);
                log.info("App config event .. configuring network");
                cfgListener.configureNetwork();
            } else if (configClass.equals(SegmentRoutingDeviceConfig.class)) {
                // TODO Handle sr device config removal
                log.info("SegmentRoutingDeviceConfig removal is not handled in current implementation");
            } else if (configClass.equals(XConnectConfig.class)) {
                xConnectHandler.processXConnectConfigRemoved(netcfgEvent);
            } else if (configClass.equals(InterfaceConfig.class)) {
                // TODO Handle interface removal
                log.info("InterfaceConfig removal is not handled in current implementation");
            } else {
                log.error("Unhandled config class: {}", configClass);
            }
        } else if (event.type() == MastershipEvent.Type.MASTER_CHANGED) {
            MastershipEvent me = (MastershipEvent) event;
            DeviceId deviceId = me.subject();
            Optional<DeviceId> pairDeviceId = getPairDeviceId(deviceId);
            log.info(" ** MASTERSHIP CHANGED Invalidating shouldProgram cache" + " for {}/pair={} due to change", deviceId, pairDeviceId);
            defaultRoutingHandler.invalidateShouldProgramCache(deviceId);
            pairDeviceId.ifPresent(defaultRoutingHandler::invalidateShouldProgramCache);
            defaultRoutingHandler.checkFullRerouteForMasterChange(deviceId, me);
        } else {
            log.warn("Unhandled event type: {}", event.type());
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler thread thrown an exception: {}", e.getMessage(), e);
    }
}
#end_block

#method_before
void configureNetwork() {
    log.info("Configuring network ...");
    createOrUpdateDeviceConfiguration();
    arpHandler = new ArpHandler(srManager);
    icmpHandler = new IcmpHandler(srManager);
    ipHandler = new IpHandler(srManager);
    routingRulePopulator = new RoutingRulePopulator(srManager);
    defaultRoutingHandler = new DefaultRoutingHandler(srManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    // add a small delay to absorb multiple network config added notifications
    if (!programmingScheduled.get()) {
        log.info("Buffering config calls for {} secs", PROGRAM_DELAY);
        programmingScheduled.set(true);
        mainEventExecutor.schedule(new ConfigChange(), PROGRAM_DELAY, TimeUnit.SECONDS);
    }
    mcastHandler.init();
}
#method_after
void configureNetwork() {
    log.info("Configuring network ...");
    // Setting handling of network configuration events completable future
    // The completable future is needed because of the async behaviour of the configureNetwork,
    // listener registration and event arrival
    // Enables us to buffer the events and execute them when the configure network is done.
    networkConfigCompletion = new CompletableFuture<>();
    // add a small delay to absorb multiple network config added notifications
    if (!programmingScheduled.get()) {
        log.info("Buffering config calls for {} secs", PROGRAM_DELAY);
        programmingScheduled.set(true);
        mainEventExecutor.schedule(new ConfigChange(), PROGRAM_DELAY, TimeUnit.SECONDS);
    }
    createOrUpdateDeviceConfiguration();
    arpHandler = new ArpHandler(srManager);
    icmpHandler = new IcmpHandler(srManager);
    ipHandler = new IpHandler(srManager);
    routingRulePopulator = new RoutingRulePopulator(srManager);
    createOrUpdateDefaultRoutingHandler();
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    networkConfigCompletion.complete(true);
    mcastHandler.init();
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
    checkState(xConnectHandler != null, "XConnectHandler is not initialized");
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
        case CONFIG_REMOVED:
            log.trace("Schedule Network Config event {}", event);
            mainEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
    checkState(xConnectHandler != null, "XConnectHandler is not initialized");
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
        case CONFIG_REMOVED:
            log.trace("Schedule Network Config event {}", event);
            if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
                mainEventExecutor.execute(new InternalEventHandler(event));
            } else {
                queuedEvents.add(event);
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void event(LinkEvent event) {
    if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED || event.type() == LinkEvent.Type.LINK_REMOVED) {
        log.trace("Schedule Link event {}", event);
        mainEventExecutor.execute(new InternalEventHandler(event));
    }
}
#method_after
@Override
public void event(LinkEvent event) {
    if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED || event.type() == LinkEvent.Type.LINK_REMOVED) {
        log.trace("Schedule Link event {}", event);
        if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
            mainEventExecutor.execute(new InternalEventHandler(event));
        } else {
            queuedEvents.add(event);
        }
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_UPDATED:
        case PORT_ADDED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.trace("Schedule Device event {}", event);
            mainEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_UPDATED:
        case PORT_ADDED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.trace("Schedule Device event {}", event);
            if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
                mainEventExecutor.execute(new InternalEventHandler(event));
            } else {
                queuedEvents.add(event);
            }
            break;
        default:
    }
}
#end_block

#method_before
@Override
public void event(TopologyEvent event) {
    switch(event.type()) {
        case TOPOLOGY_CHANGED:
            log.trace("Schedule Topology event {}", event);
            mainEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
    }
}
#method_after
@Override
public void event(TopologyEvent event) {
    switch(event.type()) {
        case TOPOLOGY_CHANGED:
            log.trace("Schedule Topology event {}", event);
            if (networkConfigCompletion == null || networkConfigCompletion.isDone()) {
                mainEventExecutor.execute(new InternalEventHandler(event));
            } else {
                queuedEvents.add(event);
            }
            break;
        default:
    }
}
#end_block

#method_before
@Override
public void event(McastEvent event) {
    switch(event.type()) {
        case SOURCES_ADDED:
        case SOURCES_REMOVED:
        case SINKS_ADDED:
        case SINKS_REMOVED:
        case ROUTE_REMOVED:
            log.trace("Schedule Mcast event {}", event);
            mcastEventExecutor.execute(new InternalEventHandler(event));
            break;
        case ROUTE_ADDED:
        default:
            log.warn("Unsupported mcast event type: {}", event.type());
            break;
    }
}
#method_after
@Override
public void event(McastEvent event) {
    switch(event.type()) {
        case SOURCES_ADDED:
        case SOURCES_REMOVED:
        case SINKS_ADDED:
        case SINKS_REMOVED:
        case ROUTE_REMOVED:
        case ROUTE_ADDED:
            log.trace("Schedule Mcast event {}", event);
            mcastEventExecutor.execute(new InternalEventHandler(event));
            break;
        default:
            log.warn("Unsupported mcast event type: {}", event.type());
            break;
    }
}
#end_block

#method_before
private void updateInterface(InterfaceConfig conf, InterfaceConfig prevConf) {
    try {
        Set<Interface> intfs = conf.getInterfaces();
        Set<Interface> prevIntfs = prevConf.getInterfaces();
        // Now we only handle one interface config at each port.
        if (intfs.size() != 1 || prevIntfs.size() != 1) {
            log.warn("Interface update aborted - one at a time is allowed, " + "but {} / {}(prev) received.", intfs.size(), prevIntfs.size());
            return;
        }
        Interface intf = intfs.stream().findFirst().get();
        Interface prevIntf = prevIntfs.stream().findFirst().get();
        DeviceId deviceId = intf.connectPoint().deviceId();
        PortNumber portNum = intf.connectPoint().port();
        removeSubnetConfig(prevIntf.connectPoint(), Sets.difference(new HashSet<>(prevIntf.ipAddressesList()), new HashSet<>(intf.ipAddressesList())));
        if (!prevIntf.vlanNative().equals(VlanId.NONE) && !prevIntf.vlanNative().equals(intf.vlanUntagged()) && !prevIntf.vlanNative().equals(intf.vlanNative())) {
            if (intf.vlanTagged().contains(prevIntf.vlanNative())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, prevIntf.vlanNative(), false);
            } else {
                // RemoveVlanNative
                updateVlanConfigInternal(deviceId, portNum, prevIntf.vlanNative(), true, false);
            }
        }
        if (!prevIntf.vlanUntagged().equals(VlanId.NONE) && !prevIntf.vlanUntagged().equals(intf.vlanUntagged()) && !prevIntf.vlanUntagged().equals(intf.vlanNative())) {
            if (intf.vlanTagged().contains(prevIntf.vlanUntagged())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, prevIntf.vlanUntagged(), false);
            } else {
                // RemoveVlanUntagged
                updateVlanConfigInternal(deviceId, portNum, prevIntf.vlanUntagged(), true, false);
            }
        }
        if (!prevIntf.vlanTagged().isEmpty() && !intf.vlanTagged().equals(prevIntf.vlanTagged())) {
            // RemoveVlanTagged
            Sets.difference(prevIntf.vlanTagged(), intf.vlanTagged()).stream().filter(i -> !intf.vlanUntagged().equals(i)).filter(i -> !intf.vlanNative().equals(i)).forEach(vlanId -> updateVlanConfigInternal(deviceId, portNum, vlanId, false, false));
        }
        if (!intf.vlanNative().equals(VlanId.NONE) && !prevIntf.vlanNative().equals(intf.vlanNative()) && !prevIntf.vlanUntagged().equals(intf.vlanNative())) {
            if (prevIntf.vlanTagged().contains(intf.vlanNative())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, intf.vlanNative(), true);
            } else {
                // AddVlanNative
                updateVlanConfigInternal(deviceId, portNum, intf.vlanNative(), true, true);
            }
        }
        if (!intf.vlanTagged().isEmpty() && !intf.vlanTagged().equals(prevIntf.vlanTagged())) {
            // AddVlanTagged
            Sets.difference(intf.vlanTagged(), prevIntf.vlanTagged()).stream().filter(i -> !prevIntf.vlanUntagged().equals(i)).filter(i -> !prevIntf.vlanNative().equals(i)).forEach(vlanId -> updateVlanConfigInternal(deviceId, portNum, vlanId, false, true));
        }
        if (!intf.vlanUntagged().equals(VlanId.NONE) && !prevIntf.vlanUntagged().equals(intf.vlanUntagged()) && !prevIntf.vlanNative().equals(intf.vlanUntagged())) {
            if (prevIntf.vlanTagged().contains(intf.vlanUntagged())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, intf.vlanUntagged(), true);
            } else {
                // AddVlanUntagged
                updateVlanConfigInternal(deviceId, portNum, intf.vlanUntagged(), true, true);
            }
        }
        addSubnetConfig(prevIntf.connectPoint(), Sets.difference(new HashSet<>(intf.ipAddressesList()), new HashSet<>(prevIntf.ipAddressesList())));
    } catch (ConfigException e) {
        log.error("Error in configuration");
    }
}
#method_after
private void updateInterface(InterfaceConfig conf, InterfaceConfig prevConf) {
    try {
        Set<Interface> intfs = conf.getInterfaces();
        Set<Interface> prevIntfs = prevConf.getInterfaces();
        // Now we only handle one interface config at each port.
        if (intfs.size() != 1 || prevIntfs.size() != 1) {
            log.warn("Interface update aborted - one at a time is allowed, " + "but {} / {}(prev) received.", intfs.size(), prevIntfs.size());
            return;
        }
        // The system is in an incoherent state, abort
        if (defaultRoutingHandler == null) {
            log.warn("Interface update aborted, defaultRoutingHandler is null");
            return;
        }
        Interface intf = intfs.stream().findFirst().get();
        Interface prevIntf = prevIntfs.stream().findFirst().get();
        DeviceId deviceId = intf.connectPoint().deviceId();
        PortNumber portNum = intf.connectPoint().port();
        removeSubnetConfig(prevIntf.connectPoint(), Sets.difference(new HashSet<>(prevIntf.ipAddressesList()), new HashSet<>(intf.ipAddressesList())));
        if (!prevIntf.vlanNative().equals(VlanId.NONE) && !prevIntf.vlanNative().equals(intf.vlanUntagged()) && !prevIntf.vlanNative().equals(intf.vlanNative())) {
            if (intf.vlanTagged().contains(prevIntf.vlanNative())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, prevIntf.vlanNative(), false);
            } else {
                // RemoveVlanNative
                updateVlanConfigInternal(deviceId, portNum, prevIntf.vlanNative(), true, false);
            }
        }
        if (!prevIntf.vlanUntagged().equals(VlanId.NONE) && !prevIntf.vlanUntagged().equals(intf.vlanUntagged()) && !prevIntf.vlanUntagged().equals(intf.vlanNative())) {
            if (intf.vlanTagged().contains(prevIntf.vlanUntagged())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, prevIntf.vlanUntagged(), false);
            } else {
                // RemoveVlanUntagged
                updateVlanConfigInternal(deviceId, portNum, prevIntf.vlanUntagged(), true, false);
            }
        }
        if (!prevIntf.vlanTagged().isEmpty() && !intf.vlanTagged().equals(prevIntf.vlanTagged())) {
            // RemoveVlanTagged
            Sets.difference(prevIntf.vlanTagged(), intf.vlanTagged()).stream().filter(i -> !intf.vlanUntagged().equals(i)).filter(i -> !intf.vlanNative().equals(i)).forEach(vlanId -> updateVlanConfigInternal(deviceId, portNum, vlanId, false, false));
        }
        if (!intf.vlanNative().equals(VlanId.NONE) && !prevIntf.vlanNative().equals(intf.vlanNative()) && !prevIntf.vlanUntagged().equals(intf.vlanNative())) {
            if (prevIntf.vlanTagged().contains(intf.vlanNative())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, intf.vlanNative(), true);
            } else {
                // AddVlanNative
                updateVlanConfigInternal(deviceId, portNum, intf.vlanNative(), true, true);
            }
        }
        if (!intf.vlanTagged().isEmpty() && !intf.vlanTagged().equals(prevIntf.vlanTagged())) {
            // AddVlanTagged
            Sets.difference(intf.vlanTagged(), prevIntf.vlanTagged()).stream().filter(i -> !prevIntf.vlanUntagged().equals(i)).filter(i -> !prevIntf.vlanNative().equals(i)).forEach(vlanId -> updateVlanConfigInternal(deviceId, portNum, vlanId, false, true));
        }
        if (!intf.vlanUntagged().equals(VlanId.NONE) && !prevIntf.vlanUntagged().equals(intf.vlanUntagged()) && !prevIntf.vlanNative().equals(intf.vlanUntagged())) {
            if (prevIntf.vlanTagged().contains(intf.vlanUntagged())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, intf.vlanUntagged(), true);
            } else {
                // AddVlanUntagged
                updateVlanConfigInternal(deviceId, portNum, intf.vlanUntagged(), true, true);
            }
        }
        addSubnetConfig(prevIntf.connectPoint(), Sets.difference(new HashSet<>(intf.ipAddressesList()), new HashSet<>(prevIntf.ipAddressesList())));
    } catch (ConfigException e) {
        log.error("Error in configuration");
    }
}
#end_block

#method_before
// ////////////////////////////////////
// Route path handling
// ////////////////////////////////////
/* The following three methods represent the three major ways in which
     * route-path handling is triggered in the network
     *      a) due to configuration change
     *      b) due to route-added event
     *      c) due to change in the topology
     */
public void populateAllRoutingRules() {
    lastRoutingChange = Instant.now();
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished. Cannot" + " proceed with populateAllRoutingRules");
            return;
        }
        populationStatus = Status.STARTED;
        rulePopulator.resetCounter();
        log.info("Starting to populate all routing rules");
        log.debug("populateAllRoutingRules: populationStatus is STARTED");
        // take a snapshot of the topology
        updatedEcmpSpgMap = new HashMap<>();
        Set<EdgePair> edgePairs = new HashSet<>();
        Set<ArrayList<DeviceId>> routeChanges = new HashSet<>();
        for (DeviceId dstSw : srManager.deviceConfiguration.getRouters()) {
            EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(dstSw, srManager);
            updatedEcmpSpgMap.put(dstSw, ecmpSpgUpdated);
            Optional<DeviceId> pairDev = srManager.getPairDeviceId(dstSw);
            if (pairDev.isPresent()) {
                // pairDev may not be available yet, but we still need to add
                ecmpSpgUpdated = new EcmpShortestPathGraph(pairDev.get(), srManager);
                updatedEcmpSpgMap.put(pairDev.get(), ecmpSpgUpdated);
                edgePairs.add(new EdgePair(dstSw, pairDev.get()));
            }
            if (!shouldProgram(dstSw)) {
                continue;
            }
            // To do a full reroute, assume all routes have changed
            for (DeviceId dev : deviceAndItsPair(dstSw)) {
                for (DeviceId targetSw : srManager.deviceConfiguration.getRouters()) {
                    if (targetSw.equals(dev)) {
                        continue;
                    }
                    routeChanges.add(Lists.newArrayList(targetSw, dev));
                }
            }
        }
        if (!redoRouting(routeChanges, edgePairs, null)) {
            log.debug("populateAllRoutingRules: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate all routing rules.");
            return;
        }
        log.debug("populateAllRoutingRules: populationStatus is SUCCEEDED");
        populationStatus = Status.SUCCEEDED;
        log.info("Completed all routing rule population. Total # of rules pushed : {}", rulePopulator.getCounter());
        return;
    } finally {
        statusLock.unlock();
    }
}
#method_after
// ////////////////////////////////////
// Route path handling
// ////////////////////////////////////
/* The following three methods represent the three major ways in which
     * route-path handling is triggered in the network
     *      a) due to configuration change
     *      b) due to route-added event
     *      c) due to change in the topology
     */
public void populateAllRoutingRules() {
    lastRoutingChange = Instant.now();
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished. Cannot" + " proceed with populateAllRoutingRules");
            return;
        }
        populationStatus = Status.STARTED;
        rulePopulator.resetCounter();
        log.info("Starting to populate all routing rules");
        log.debug("populateAllRoutingRules: populationStatus is STARTED");
        // take a snapshot of the topology
        updatedEcmpSpgMap = new HashMap<>();
        Set<EdgePair> edgePairs = new HashSet<>();
        Set<ArrayList<DeviceId>> routeChanges = new HashSet<>();
        for (DeviceId dstSw : srManager.deviceConfiguration.getRouters()) {
            EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(dstSw, srManager);
            updatedEcmpSpgMap.put(dstSw, ecmpSpgUpdated);
            Optional<DeviceId> pairDev = srManager.getPairDeviceId(dstSw);
            if (pairDev.isPresent()) {
                // pairDev may not be available yet, but we still need to add
                ecmpSpgUpdated = new EcmpShortestPathGraph(pairDev.get(), srManager);
                updatedEcmpSpgMap.put(pairDev.get(), ecmpSpgUpdated);
                edgePairs.add(new EdgePair(dstSw, pairDev.get()));
            }
            if (!shouldProgram(dstSw)) {
                lastProgrammed.remove(dstSw);
                continue;
            } else {
                lastProgrammed.add(dstSw);
            }
            // To do a full reroute, assume all route-paths have changed
            for (DeviceId dev : deviceAndItsPair(dstSw)) {
                for (DeviceId targetSw : srManager.deviceConfiguration.getRouters()) {
                    if (targetSw.equals(dev)) {
                        continue;
                    }
                    routeChanges.add(Lists.newArrayList(targetSw, dev));
                }
            }
        }
        if (!redoRouting(routeChanges, edgePairs, null)) {
            log.debug("populateAllRoutingRules: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate all routing rules.");
            return;
        }
        log.debug("populateAllRoutingRules: populationStatus is SUCCEEDED");
        populationStatus = Status.SUCCEEDED;
        log.info("Completed all routing rule population. Total # of rules pushed : {}", rulePopulator.getCounter());
        return;
    } finally {
        statusLock.unlock();
    }
}
#end_block

#method_before
void populateDoubleTaggedRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId dummyVlan, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, PortNumber outPort) {
    if (srManager.mastershipService.isLocalMaster(deviceId)) {
        srManager.routingRulePopulator.populateDoubleTaggedRoute(deviceId, prefix, hostMac, dummyVlan, innerVlan, outerVlan, outerTpid, outPort);
    }
}
#method_after
void populateDoubleTaggedRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, PortNumber outPort) {
    if (srManager.mastershipService.isLocalMaster(deviceId)) {
        VlanId dummyVlan = srManager.allocateDummyVlanId(new ConnectPoint(deviceId, outPort), prefix.address());
        if (!dummyVlan.equals(VlanId.NONE)) {
            srManager.routingRulePopulator.populateDoubleTaggedRoute(deviceId, prefix, hostMac, dummyVlan, innerVlan, outerVlan, outerTpid, outPort);
            srManager.routingRulePopulator.processDoubleTaggedFilter(deviceId, outPort, outerVlan, innerVlan, true);
        } else {
            log.error("Failed to allocate dummy VLAN ID for host {} at {}/{}", prefix.address(), deviceId, outPort);
        }
    }
}
#end_block

#method_before
void revokeDoubleTaggedRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId dummyVlan, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, PortNumber outPort) {
    if (srManager.mastershipService.isLocalMaster(deviceId)) {
        srManager.routingRulePopulator.revokeDoubleTaggedRoute(deviceId, prefix, hostMac, dummyVlan, innerVlan, outerVlan, outerTpid, outPort);
    }
}
#method_after
void revokeDoubleTaggedRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, PortNumber outPort) {
    // if this node is the leader (even when device is unavailable)
    if (!srManager.mastershipService.isLocalMaster(deviceId)) {
        if (srManager.deviceService.isAvailable(deviceId)) {
            // Master node will revoke specified rule.
            log.debug("This node is not a master for {}, stop revoking route.", deviceId);
            return;
        }
        // isLocalMaster will return false when the device is unavailable.
        // Verify if this node is the leader in that case.
        NodeId leader = srManager.leadershipService.runForLeadership(deviceId.toString()).leaderNodeId();
        if (!srManager.clusterService.getLocalNode().id().equals(leader)) {
            // Leader node will revoke specified rule.
            log.debug("This node is not a master for {}, stop revoking route.", deviceId);
            return;
        }
    }
    VlanId dummyVlan = srManager.dummyVlanIdStore().get(new DummyVlanIdStoreKey(new ConnectPoint(deviceId, outPort), prefix.address()));
    if (dummyVlan == null) {
        log.error("Failed to get dummyVlanId for host {} at {}/{}.", prefix.address(), deviceId, outPort);
    } else {
        srManager.routingRulePopulator.revokeDoubleTaggedRoute(deviceId, prefix, hostMac, dummyVlan, innerVlan, outerVlan, outerTpid, outPort);
        srManager.routingRulePopulator.processDoubleTaggedFilter(deviceId, outPort, outerVlan, innerVlan, false);
    }
}
#end_block

#method_before
protected void purgeEcmpGraph(DeviceId deviceId) {
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished. Cannot" + " proceeed with purgeEcmpGraph for {}", deviceId);
            return;
        }
        log.debug("Updating ECMPspg for unavailable dev:{}", deviceId);
        currentEcmpSpgMap.remove(deviceId);
        if (updatedEcmpSpgMap != null) {
            updatedEcmpSpgMap.remove(deviceId);
        }
    } finally {
        statusLock.unlock();
    }
}
#method_after
void purgeEcmpGraph(DeviceId deviceId) {
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished. Cannot" + " proceeed with purgeEcmpGraph for {}", deviceId);
            return;
        }
        log.debug("Updating ECMPspg for unavailable dev:{}", deviceId);
        currentEcmpSpgMap.remove(deviceId);
        if (updatedEcmpSpgMap != null) {
            updatedEcmpSpgMap.remove(deviceId);
        }
    } finally {
        statusLock.unlock();
    }
}
#end_block

#method_before
// ////////////////////////////////////
// Routing helper methods and classes
// ////////////////////////////////////
private Set<ArrayList<DeviceId>> computeDamagedRoutes(Link linkFail) {
    Set<ArrayList<DeviceId>> routes = new HashSet<>();
    for (Device sw : srManager.deviceService.getDevices()) {
        log.debug("Computing the impacted routes for device {} due to link fail", sw.id());
        if (!shouldProgram(sw.id())) {
            continue;
        }
        for (DeviceId rootSw : deviceAndItsPair(sw.id())) {
            EcmpShortestPathGraph ecmpSpg = currentEcmpSpgMap.get(rootSw);
            if (ecmpSpg == null) {
                log.warn("No existing ECMP graph for switch {}. Aborting optimized" + " rerouting and opting for full-reroute", rootSw);
                return null;
            }
            if (log.isDebugEnabled()) {
                log.debug("Root switch: {}", rootSw);
                log.debug("  Current/Existing SPG: {}", ecmpSpg);
                log.debug("       New/Updated SPG: {}", updatedEcmpSpgMap.get(rootSw));
            }
            HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
            // figure out if the broken link affected any route-paths in this graph
            for (Integer itrIdx : switchVia.keySet()) {
                log.trace("Current/Exiting SPG Iterindex# {}", itrIdx);
                HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
                for (DeviceId targetSw : swViaMap.keySet()) {
                    log.trace("TargetSwitch {} --> RootSwitch {}", targetSw, rootSw);
                    for (ArrayList<DeviceId> via : swViaMap.get(targetSw)) {
                        log.trace(" Via:");
                        via.forEach(e -> log.trace("  {}", e));
                    }
                    Set<ArrayList<DeviceId>> subLinks = computeLinks(targetSw, rootSw, swViaMap);
                    for (ArrayList<DeviceId> alink : subLinks) {
                        if ((alink.get(0).equals(linkFail.src().deviceId()) && alink.get(1).equals(linkFail.dst().deviceId())) || (alink.get(0).equals(linkFail.dst().deviceId()) && alink.get(1).equals(linkFail.src().deviceId()))) {
                            log.debug("Impacted route:{}->{}", targetSw, rootSw);
                            ArrayList<DeviceId> aRoute = new ArrayList<>();
                            // switch with rules to populate
                            aRoute.add(targetSw);
                            // towards this destination
                            aRoute.add(rootSw);
                            routes.add(aRoute);
                            break;
                        }
                    }
                }
            }
        }
    }
    return routes;
}
#method_after
// ////////////////////////////////////
// Routing helper methods and classes
// ////////////////////////////////////
private Set<ArrayList<DeviceId>> computeDamagedRoutes(Link linkFail) {
    Set<ArrayList<DeviceId>> routes = new HashSet<>();
    for (Device sw : srManager.deviceService.getDevices()) {
        log.debug("Computing the impacted routes for device {} due to link fail", sw.id());
        if (!shouldProgram(sw.id())) {
            lastProgrammed.remove(sw.id());
            continue;
        }
        for (DeviceId rootSw : deviceAndItsPair(sw.id())) {
            // check for mastership change since last run
            if (!lastProgrammed.contains(sw.id())) {
                lastProgrammed.add(sw.id());
                log.warn("New reponsibility for this node to program dev:{}" + " ... nuking current ECMPspg", sw.id());
                currentEcmpSpgMap.remove(sw.id());
            }
            EcmpShortestPathGraph ecmpSpg = currentEcmpSpgMap.get(rootSw);
            if (ecmpSpg == null) {
                log.warn("No existing ECMP graph for switch {}. Aborting optimized" + " rerouting and opting for full-reroute", rootSw);
                return null;
            }
            if (log.isDebugEnabled()) {
                log.debug("Root switch: {}", rootSw);
                log.debug("  Current/Existing SPG: {}", ecmpSpg);
                log.debug("       New/Updated SPG: {}", updatedEcmpSpgMap.get(rootSw));
            }
            HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
            // figure out if the broken link affected any route-paths in this graph
            for (Integer itrIdx : switchVia.keySet()) {
                log.trace("Current/Exiting SPG Iterindex# {}", itrIdx);
                HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
                for (DeviceId targetSw : swViaMap.keySet()) {
                    log.trace("TargetSwitch {} --> RootSwitch {}", targetSw, rootSw);
                    for (ArrayList<DeviceId> via : swViaMap.get(targetSw)) {
                        log.trace(" Via:");
                        via.forEach(e -> log.trace("  {}", e));
                    }
                    Set<ArrayList<DeviceId>> subLinks = computeLinks(targetSw, rootSw, swViaMap);
                    for (ArrayList<DeviceId> alink : subLinks) {
                        if ((alink.get(0).equals(linkFail.src().deviceId()) && alink.get(1).equals(linkFail.dst().deviceId())) || (alink.get(0).equals(linkFail.dst().deviceId()) && alink.get(1).equals(linkFail.src().deviceId()))) {
                            log.debug("Impacted route:{}->{}", targetSw, rootSw);
                            ArrayList<DeviceId> aRoute = new ArrayList<>();
                            // switch with rules to populate
                            aRoute.add(targetSw);
                            // towards this destination
                            aRoute.add(rootSw);
                            routes.add(aRoute);
                            break;
                        }
                    }
                }
            }
        }
    }
    return routes;
}
#end_block

#method_before
private Set<ArrayList<DeviceId>> computeRouteChange(DeviceId failedSwitch) {
    ImmutableSet.Builder<ArrayList<DeviceId>> changedRtBldr = ImmutableSet.builder();
    for (Device sw : srManager.deviceService.getDevices()) {
        log.debug("Computing the impacted routes for device {}", sw.id());
        if (!shouldProgram(sw.id())) {
            continue;
        }
        for (DeviceId rootSw : deviceAndItsPair(sw.id())) {
            if (log.isTraceEnabled()) {
                log.trace("Device links for dev: {}", rootSw);
                for (Link link : srManager.linkService.getDeviceLinks(rootSw)) {
                    log.trace("{} -> {} ", link.src().deviceId(), link.dst().deviceId());
                }
            }
            EcmpShortestPathGraph currEcmpSpg = currentEcmpSpgMap.get(rootSw);
            if (currEcmpSpg == null) {
                log.debug("No existing ECMP graph for device {}.. adding self as " + "changed route", rootSw);
                changedRtBldr.add(Lists.newArrayList(rootSw));
                continue;
            }
            EcmpShortestPathGraph newEcmpSpg = updatedEcmpSpgMap.get(rootSw);
            if (newEcmpSpg == null) {
                log.warn("Cannot find updated ECMP graph for dev:{}", rootSw);
                continue;
            }
            if (log.isDebugEnabled()) {
                log.debug("Root switch: {}", rootSw);
                log.debug("  Current/Existing SPG: {}", currEcmpSpg);
                log.debug("       New/Updated SPG: {}", newEcmpSpg);
            }
            // first use the updated/new map to compare to current/existing map
            // as new links may have come up
            changedRtBldr.addAll(compareGraphs(newEcmpSpg, currEcmpSpg, rootSw));
            // then use the current/existing map to compare to updated/new map
            // as switch may have been removed
            changedRtBldr.addAll(compareGraphs(currEcmpSpg, newEcmpSpg, rootSw));
        }
    }
    // not have a pair, or the pair is not available
    if (failedSwitch != null) {
        Optional<DeviceId> pairDev = srManager.getPairDeviceId(failedSwitch);
        if (!pairDev.isPresent() || !srManager.deviceService.isAvailable(pairDev.get())) {
            log.debug("Proxy Route changes to downed Sw:{}", failedSwitch);
            srManager.deviceService.getDevices().forEach(dev -> {
                if (!dev.id().equals(failedSwitch) && srManager.mastershipService.isLocalMaster(dev.id())) {
                    log.debug(" : {}", dev.id());
                    changedRtBldr.add(Lists.newArrayList(dev.id(), failedSwitch));
                }
            });
        }
    }
    Set<ArrayList<DeviceId>> changedRoutes = changedRtBldr.build();
    for (ArrayList<DeviceId> route : changedRoutes) {
        log.debug("Route changes Target -> Root");
        if (route.size() == 1) {
            log.debug(" : all -> {}", route.get(0));
        } else {
            log.debug(" : {} -> {}", route.get(0), route.get(1));
        }
    }
    return changedRoutes;
}
#method_after
private Set<ArrayList<DeviceId>> computeRouteChange(DeviceId failedSwitch) {
    ImmutableSet.Builder<ArrayList<DeviceId>> changedRtBldr = ImmutableSet.builder();
    for (Device sw : srManager.deviceService.getDevices()) {
        log.debug("Computing the impacted routes for device {}", sw.id());
        if (!shouldProgram(sw.id())) {
            lastProgrammed.remove(sw.id());
            continue;
        }
        for (DeviceId rootSw : deviceAndItsPair(sw.id())) {
            if (log.isTraceEnabled()) {
                log.trace("Device links for dev: {}", rootSw);
                for (Link link : srManager.linkService.getDeviceLinks(rootSw)) {
                    log.trace("{} -> {} ", link.src().deviceId(), link.dst().deviceId());
                }
            }
            // check for mastership change since last run
            if (!lastProgrammed.contains(sw.id())) {
                lastProgrammed.add(sw.id());
                log.warn("New reponsibility for this node to program dev:{}" + " ... nuking current ECMPspg", sw.id());
                currentEcmpSpgMap.remove(sw.id());
            }
            EcmpShortestPathGraph currEcmpSpg = currentEcmpSpgMap.get(rootSw);
            if (currEcmpSpg == null) {
                log.debug("No existing ECMP graph for device {}.. adding self as " + "changed route", rootSw);
                changedRtBldr.add(Lists.newArrayList(rootSw));
                continue;
            }
            EcmpShortestPathGraph newEcmpSpg = updatedEcmpSpgMap.get(rootSw);
            if (newEcmpSpg == null) {
                log.warn("Cannot find updated ECMP graph for dev:{}", rootSw);
                continue;
            }
            if (log.isDebugEnabled()) {
                log.debug("Root switch: {}", rootSw);
                log.debug("  Current/Existing SPG: {}", currEcmpSpg);
                log.debug("       New/Updated SPG: {}", newEcmpSpg);
            }
            // first use the updated/new map to compare to current/existing map
            // as new links may have come up
            changedRtBldr.addAll(compareGraphs(newEcmpSpg, currEcmpSpg, rootSw));
            // then use the current/existing map to compare to updated/new map
            // as switch may have been removed
            changedRtBldr.addAll(compareGraphs(currEcmpSpg, newEcmpSpg, rootSw));
        }
    }
    // not have a pair, or the pair is not available
    if (failedSwitch != null) {
        Optional<DeviceId> pairDev = srManager.getPairDeviceId(failedSwitch);
        if (!pairDev.isPresent() || !srManager.deviceService.isAvailable(pairDev.get())) {
            log.debug("Proxy Route changes to downed Sw:{}", failedSwitch);
            srManager.deviceService.getDevices().forEach(dev -> {
                if (!dev.id().equals(failedSwitch) && srManager.mastershipService.isLocalMaster(dev.id())) {
                    log.debug(" : {}", dev.id());
                    changedRtBldr.add(Lists.newArrayList(dev.id(), failedSwitch));
                }
            });
        }
    }
    Set<ArrayList<DeviceId>> changedRoutes = changedRtBldr.build();
    for (ArrayList<DeviceId> route : changedRoutes) {
        log.debug("Route changes Target -> Root");
        if (route.size() == 1) {
            log.debug(" : all -> {}", route.get(0));
        } else {
            log.debug(" : {} -> {}", route.get(0), route.get(1));
        }
    }
    return changedRoutes;
}
#end_block

#method_before
boolean shouldProgram(DeviceId deviceId) {
    Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(deviceId);
    NodeId currentNodeId = srManager.clusterService.getLocalNode().id();
    NodeId masterNodeId = srManager.mastershipService.getMasterFor(deviceId);
    Optional<NodeId> pairMasterNodeId = pairDeviceId.map(srManager.mastershipService::getMasterFor);
    log.debug("Evaluate shouldProgram {}/pair={}. current={}, master={}, pairMaster={}", deviceId, pairDeviceId, currentNodeId, masterNodeId, pairMasterNodeId);
    // No pair device configured. Only handle when current instance is the master of the device
    if (!pairDeviceId.isPresent()) {
        log.debug("No pair device. current={}, master={}", currentNodeId, masterNodeId);
        return currentNodeId.equals(masterNodeId);
    }
    // Should not handle if current instance is not the master of either switch
    if (!currentNodeId.equals(masterNodeId) && !(pairMasterNodeId.isPresent() && currentNodeId.equals(pairMasterNodeId.get()))) {
        log.debug("Current node {} is neither the master of target device {} nor pair device {}", currentNodeId, deviceId, pairDeviceId);
        return false;
    }
    Set<DeviceId> key = Sets.newHashSet(deviceId, pairDeviceId.get());
    NodeId king = shouldProgram.compute(key, ((k, v) -> {
        if (v == null) {
            // There is no value in the map. Elect a node
            return elect(Lists.newArrayList(masterNodeId, pairMasterNodeId.orElse(null)));
        } else {
            if (v.equals(masterNodeId) || v.equals(pairMasterNodeId.orElse(null))) {
                // Use the node in the map if it is still alive and is a master of any of the two switches
                return v;
            } else {
                // Previously elected node is no longer the master of either switch. Re-elect a node.
                return elect(Lists.newArrayList(masterNodeId, pairMasterNodeId.orElse(null)));
            }
        }
    }));
    if (king != null) {
        log.debug("{} should handle routing for {}/pair={}", king, deviceId, pairDeviceId);
        return king.equals(currentNodeId);
    } else {
        log.error("Fail to elect a king for {}/pair={}. Abort.", deviceId, pairDeviceId);
        return false;
    }
}
#method_after
boolean shouldProgram(DeviceId deviceId) {
    Boolean cached = shouldProgramCache.get(deviceId);
    if (cached != null) {
        log.debug("shouldProgram dev:{} cached:{}", deviceId, cached);
        return cached;
    }
    Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(deviceId);
    NodeId currentNodeId = srManager.clusterService.getLocalNode().id();
    NodeId masterNodeId = srManager.mastershipService.getMasterFor(deviceId);
    Optional<NodeId> pairMasterNodeId = pairDeviceId.map(srManager.mastershipService::getMasterFor);
    log.debug("Evaluate shouldProgram {}/pair={}. current={}, master={}, pairMaster={}", deviceId, pairDeviceId, currentNodeId, masterNodeId, pairMasterNodeId);
    // No pair device configured. Only handle when current instance is the master of the device
    if (!pairDeviceId.isPresent()) {
        log.debug("No pair device. current={}, master={}", currentNodeId, masterNodeId);
        return currentNodeId.equals(masterNodeId);
    }
    // Should not handle if current instance is not the master of either switch
    if (!currentNodeId.equals(masterNodeId) && !(pairMasterNodeId.isPresent() && currentNodeId.equals(pairMasterNodeId.get()))) {
        log.debug("Current node {} is neither the master of target device {} nor pair device {}", currentNodeId, deviceId, pairDeviceId);
        return false;
    }
    Set<DeviceId> key = Sets.newHashSet(deviceId, pairDeviceId.get());
    NodeId king = shouldProgram.compute(key, ((k, v) -> {
        if (v == null) {
            // There is no value in the map. Elect a node
            return elect(Lists.newArrayList(masterNodeId, pairMasterNodeId.orElse(null)));
        } else {
            if (v.equals(masterNodeId) || v.equals(pairMasterNodeId.orElse(null))) {
                // Use the node in the map if it is still alive and is a master of any of the two switches
                return v;
            } else {
                // Previously elected node is no longer the master of either switch. Re-elect a node.
                return elect(Lists.newArrayList(masterNodeId, pairMasterNodeId.orElse(null)));
            }
        }
    }));
    if (king != null) {
        log.debug("{} should handle routing for {}/pair={}", king, deviceId, pairDeviceId);
        shouldProgramCache.put(deviceId, king.equals(currentNodeId));
        return king.equals(currentNodeId);
    } else {
        log.error("Fail to elect a king for {}/pair={}. Abort.", deviceId, pairDeviceId);
        shouldProgramCache.remove(deviceId);
        return false;
    }
}
#end_block

#method_before
private Set<DeviceId> getNextHops(DeviceId targetSw, DeviceId dstSw) {
    boolean targetIsEdge = false;
    try {
        targetIsEdge = srManager.deviceConfiguration.isEdgeDevice(targetSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + "Cannot determine if targetIsEdge {}.. " + "continuing to getNextHops", targetSw);
    }
    EcmpShortestPathGraph ecmpSpg = updatedEcmpSpgMap.get(dstSw);
    if (ecmpSpg == null) {
        log.debug("No ecmpSpg found for dstSw: {}", dstSw);
        return ImmutableSet.of();
    }
    HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
    for (Integer itrIdx : switchVia.keySet()) {
        HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
        for (DeviceId target : swViaMap.keySet()) {
            if (!target.equals(targetSw)) {
                continue;
            }
            if (!targetIsEdge && itrIdx > 1) {
                // optimization for spines to not use leaves to get
                // to a spine or other leaves
                boolean pathdevIsEdge = false;
                for (ArrayList<DeviceId> via : swViaMap.get(targetSw)) {
                    for (DeviceId pathdev : via) {
                        try {
                            pathdevIsEdge = srManager.deviceConfiguration.isEdgeDevice(pathdev);
                        } catch (DeviceConfigNotFoundException e) {
                            log.warn(e.getMessage());
                        }
                        if (pathdevIsEdge) {
                            log.debug("Avoiding {} hop path for non-edge targetSw:{}" + " --> dstSw:{} which goes through an edge" + " device {} in path {}", itrIdx, targetSw, dstSw, pathdev, via);
                            return ImmutableSet.of();
                        }
                    }
                }
            }
            Set<DeviceId> nextHops = new HashSet<>();
            for (ArrayList<DeviceId> via : swViaMap.get(targetSw)) {
                if (via.isEmpty()) {
                    // the dstSw is the next-hop from the targetSw
                    nextHops.add(dstSw);
                } else {
                    // first elem is next-hop in each ECMP path
                    nextHops.add(via.get(0));
                }
            }
            return nextHops;
        }
    }
    // no next-hops found
    return ImmutableSet.of();
}
#method_after
private Set<DeviceId> getNextHops(DeviceId targetSw, DeviceId dstSw) {
    boolean targetIsEdge = false;
    try {
        targetIsEdge = srManager.deviceConfiguration.isEdgeDevice(targetSw);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + "Cannot determine if targetIsEdge {}.. " + "continuing to getNextHops", targetSw);
    }
    EcmpShortestPathGraph ecmpSpg = updatedEcmpSpgMap.get(dstSw);
    if (ecmpSpg == null) {
        log.debug("No ecmpSpg found for dstSw: {}", dstSw);
        return ImmutableSet.of();
    }
    HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia = ecmpSpg.getAllLearnedSwitchesAndVia();
    for (Integer itrIdx : switchVia.keySet()) {
        HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
        for (DeviceId target : swViaMap.keySet()) {
            if (!target.equals(targetSw)) {
                continue;
            }
            // leaves to get to the destination
            if ((!targetIsEdge && itrIdx > 1) || targetIsEdge) {
                boolean pathdevIsEdge = false;
                for (ArrayList<DeviceId> via : swViaMap.get(targetSw)) {
                    log.debug("Evaluating next-hop in path: {}", via);
                    for (DeviceId pathdev : via) {
                        try {
                            pathdevIsEdge = srManager.deviceConfiguration.isEdgeDevice(pathdev);
                        } catch (DeviceConfigNotFoundException e) {
                            log.warn(e.getMessage());
                        }
                        if (pathdevIsEdge) {
                            log.debug("Avoiding {} hop path for non-edge targetSw:{}" + " --> dstSw:{} which goes through an edge" + " device {} in path {}", itrIdx, targetSw, dstSw, pathdev, via);
                            return ImmutableSet.of();
                        }
                    }
                }
            }
            Set<DeviceId> nextHops = new HashSet<>();
            for (ArrayList<DeviceId> via : swViaMap.get(targetSw)) {
                if (via.isEmpty()) {
                    // the dstSw is the next-hop from the targetSw
                    nextHops.add(dstSw);
                } else {
                    // first elem is next-hop in each ECMP path
                    nextHops.add(via.get(0));
                }
            }
            log.debug("target {} --> dst: {} has next-hops:{}", targetSw, dstSw, nextHops);
            return nextHops;
        }
    }
    log.debug("No next hops found for target:{} --> dst: {}", targetSw, dstSw);
    // no next-hops found
    return ImmutableSet.of();
}
#end_block

#method_before
// ////////////////////////////////////
// Filtering rule creation
// ////////////////////////////////////
public void populatePortAddressingRules(DeviceId deviceId) {
    // Although device is added, sometimes device store does not have the
    // ports for this device yet. It results in missing filtering rules in the
    // switch. We will attempt it a few times. If it still does not work,
    // user can manually repopulate using CLI command sr-reroute-network
    PortFilterInfo firstRun = rulePopulator.populateVlanMacFilters(deviceId);
    if (firstRun == null) {
        firstRun = new PortFilterInfo(0, 0, 0);
    }
    executorService.schedule(new RetryFilters(deviceId, firstRun), RETRY_INTERVAL_MS, TimeUnit.MILLISECONDS);
}
#method_after
// ////////////////////////////////////
// Filtering rule creation
// ////////////////////////////////////
void populatePortAddressingRules(DeviceId deviceId) {
    // Although device is added, sometimes device store does not have the
    // ports for this device yet. It results in missing filtering rules in the
    // switch. We will attempt it a few times. If it still does not work,
    // user can manually repopulate using CLI command sr-reroute-network
    PortFilterInfo firstRun = rulePopulator.populateVlanMacFilters(deviceId);
    if (firstRun == null) {
        firstRun = new PortFilterInfo(0, 0, 0);
    }
    executorService.schedule(new RetryFilters(deviceId, firstRun), RETRY_INTERVAL_MS, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
void processHostMovedEvent(HostEvent event) {
    MacAddress hostMac = event.subject().mac();
    VlanId hostVlanId = event.subject().vlan();
    Set<HostLocation> prevLocations = event.prevSubject().locations();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    Set<HostLocation> newLocations = event.subject().locations();
    Set<IpAddress> newIps = event.subject().ipAddresses();
    // The permanent solution would be introducing CompletableFuture and wait for it
    if (prevLocations.size() == 1 && newLocations.size() == 2) {
        log.debug("Delay event handling when host {}/{} moves from 1 to 2 locations", hostMac, hostVlanId);
        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        executorService.schedule(() -> processHostMoved(event.subject(), prevLocations, prevIps, newLocations, newIps), HOST_MOVED_DELAY_MS, TimeUnit.MILLISECONDS);
    } else {
        processHostMoved(event.subject(), prevLocations, prevIps, newLocations, newIps);
    }
}
#method_after
void processHostMovedEvent(HostEvent event) {
    Set<HostLocation> prevLocations = event.prevSubject().locations();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    Set<HostLocation> newLocations = event.subject().locations();
    Set<IpAddress> newIps = event.subject().ipAddresses();
    processHostMoved(event.subject(), prevLocations, prevIps, newLocations, newIps);
}
#end_block

#method_before
private void processHostMoved(Host host, Set<HostLocation> prevLocations, Set<IpAddress> prevIps, Set<HostLocation> newLocations, Set<IpAddress> newIps) {
    MacAddress hostMac = host.mac();
    VlanId hostVlanId = host.vlan();
    EthType hostTpid = host.tpid();
    boolean doubleTaggedHost = isDoubleTaggedHost(host);
    log.info("Host {}/{} is moved from {} to {}", hostMac, hostVlanId, prevLocations, newLocations);
    Set<DeviceId> newDeviceIds = newLocations.stream().map(HostLocation::deviceId).collect(Collectors.toSet());
    // For each old location
    Sets.difference(prevLocations, newLocations).forEach(prevLocation -> {
        // Remove routing rules for old IPs
        Sets.difference(prevIps, newIps).forEach(ip -> {
            if (doubleTaggedHost) {
                processDoubleTaggedRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, true);
            } else {
                processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true);
            }
        });
        // Redirect the flows to pair link if configured
        // Note: Do not continue removing any rule
        Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(prevLocation.deviceId());
        Optional<PortNumber> pairLocalPort = srManager.getPairLocalPorts(prevLocation.deviceId());
        if (pairDeviceId.isPresent() && pairLocalPort.isPresent() && newLocations.stream().anyMatch(location -> location.deviceId().equals(pairDeviceId.get()))) {
            // NOTE: Since the pairLocalPort is trunk port, use assigned vlan of original port
            // when the host is untagged
            VlanId vlanId = Optional.ofNullable(srManager.getInternalVlanId(prevLocation)).orElse(hostVlanId);
            processBridgingRule(prevLocation.deviceId(), pairLocalPort.get(), hostMac, vlanId, false);
            newIps.forEach(ip -> processRoutingRule(prevLocation.deviceId(), pairLocalPort.get(), hostMac, vlanId, ip, false));
            return;
        }
        // Otherwise, do not remove and let the adding part update the old flow
        if (!newDeviceIds.contains(prevLocation.deviceId())) {
            processBridgingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, true);
            Sets.intersection(prevIps, newIps).forEach(ip -> {
                if (doubleTaggedHost) {
                    processDoubleTaggedRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, true);
                } else {
                    processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true);
                }
            });
        }
        // Otherwise, do not remove and let the adding part update the old flow
        if (newLocations.stream().noneMatch(newLocation -> {
            VlanId oldAssignedVlan = srManager.getInternalVlanId(prevLocation);
            VlanId newAssignedVlan = srManager.getInternalVlanId(newLocation);
            // Host is tagged and the new location has the host vlan in vlan-tagged
            return srManager.getTaggedVlanId(newLocation).contains(hostVlanId) || (oldAssignedVlan != null && newAssignedVlan != null && // Host is untagged and the new location has the same assigned vlan
            oldAssignedVlan.equals(newAssignedVlan));
        })) {
            processBridgingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, true);
        }
        // Remove routing rules for unchanged IPs if none of the subnet of new location contains
        // the IP. Otherwise, do not remove and let the adding part update the old flow
        Sets.intersection(prevIps, newIps).forEach(ip -> {
            if (newLocations.stream().noneMatch(newLocation -> srManager.deviceConfiguration.inSameSubnet(newLocation, ip))) {
                if (doubleTaggedHost) {
                    processDoubleTaggedRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, true);
                } else {
                    processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true);
                }
            }
        });
    });
    // For each new location, add all new IPs.
    Sets.difference(newLocations, prevLocations).stream().forEach(newLocation -> {
        processBridgingRule(newLocation.deviceId(), newLocation.port(), hostMac, hostVlanId, false);
        newIps.forEach(ip -> {
            if (doubleTaggedHost) {
                processDoubleTaggedRoutingRule(newLocation.deviceId(), newLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, false);
            } else {
                processRoutingRule(newLocation.deviceId(), newLocation.port(), hostMac, hostVlanId, ip, false);
            }
        });
    });
    // For each unchanged location, add new IPs and remove old IPs.
    Sets.intersection(newLocations, prevLocations).stream().forEach(unchangedLocation -> {
        Sets.difference(prevIps, newIps).forEach(ip -> {
            if (doubleTaggedHost) {
                processDoubleTaggedRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, true);
            } else {
                processRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, hostVlanId, ip, true);
            }
        });
        Sets.difference(newIps, prevIps).forEach(ip -> {
            if (doubleTaggedHost) {
                processDoubleTaggedRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, false);
            } else {
                processRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, hostVlanId, ip, false);
            }
        });
    });
    // ensure dual-homed host locations have viable uplinks
    if (newLocations.size() > prevLocations.size()) {
        newLocations.forEach(loc -> {
            if (srManager.mastershipService.isLocalMaster(loc.deviceId())) {
                srManager.linkHandler.checkUplinksForDualHomedHosts(loc);
            }
        });
    }
}
#method_after
private void processHostMoved(Host host, Set<HostLocation> prevLocations, Set<IpAddress> prevIps, Set<HostLocation> newLocations, Set<IpAddress> newIps) {
    MacAddress hostMac = host.mac();
    VlanId hostVlanId = host.vlan();
    EthType hostTpid = host.tpid();
    boolean doubleTaggedHost = isDoubleTaggedHost(host);
    log.info("Host {}/{} is moved from {} to {}", hostMac, hostVlanId, prevLocations, newLocations);
    Set<DeviceId> newDeviceIds = newLocations.stream().map(HostLocation::deviceId).collect(Collectors.toSet());
    // For each old location
    Sets.difference(prevLocations, newLocations).forEach(prevLocation -> {
        // Remove routing rules for old IPs
        Sets.difference(prevIps, newIps).forEach(ip -> {
            if (doubleTaggedHost) {
                processDoubleTaggedRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, true);
            } else {
                processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true);
            }
        });
        // Redirect the flows to pair link if configured
        // Note: Do not continue removing any rule
        Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(prevLocation.deviceId());
        Optional<PortNumber> pairLocalPort = srManager.getPairLocalPorts(prevLocation.deviceId());
        if (pairDeviceId.isPresent() && pairLocalPort.isPresent() && newLocations.stream().anyMatch(location -> location.deviceId().equals(pairDeviceId.get()))) {
            // NOTE: Since the pairLocalPort is trunk port, use assigned vlan of original port
            // when the host is untagged
            VlanId vlanId = Optional.ofNullable(srManager.getInternalVlanId(prevLocation)).orElse(hostVlanId);
            processBridgingRule(prevLocation.deviceId(), pairLocalPort.get(), hostMac, vlanId, false);
            newIps.forEach(ip -> processRoutingRule(prevLocation.deviceId(), pairLocalPort.get(), hostMac, vlanId, ip, false));
            return;
        }
        // Otherwise, do not remove and let the adding part update the old flow
        if (!newDeviceIds.contains(prevLocation.deviceId())) {
            processBridgingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, true);
            Sets.intersection(prevIps, newIps).forEach(ip -> {
                if (doubleTaggedHost) {
                    processDoubleTaggedRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, true);
                } else {
                    processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true);
                }
            });
        }
        // Otherwise, do not remove and let the adding part update the old flow
        if (newLocations.stream().noneMatch(newLocation -> {
            VlanId oldAssignedVlan = srManager.getInternalVlanId(prevLocation);
            VlanId newAssignedVlan = srManager.getInternalVlanId(newLocation);
            // Host is tagged and the new location has the host vlan in vlan-tagged
            return srManager.getTaggedVlanId(newLocation).contains(hostVlanId) || (oldAssignedVlan != null && newAssignedVlan != null && // Host is untagged and the new location has the same assigned vlan
            oldAssignedVlan.equals(newAssignedVlan));
        })) {
            processBridgingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, true);
        }
        // Remove routing rules for unchanged IPs if none of the subnet of new location contains
        // the IP. Otherwise, do not remove and let the adding part update the old flow
        Sets.intersection(prevIps, newIps).forEach(ip -> {
            if (newLocations.stream().noneMatch(newLocation -> srManager.deviceConfiguration.inSameSubnet(newLocation, ip))) {
                if (doubleTaggedHost) {
                    processDoubleTaggedRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, true);
                } else {
                    processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true);
                }
            }
        });
    });
    // For each new location, add all new IPs.
    Sets.difference(newLocations, prevLocations).forEach(newLocation -> {
        processBridgingRule(newLocation.deviceId(), newLocation.port(), hostMac, hostVlanId, false);
        newIps.forEach(ip -> {
            if (doubleTaggedHost) {
                processDoubleTaggedRoutingRule(newLocation.deviceId(), newLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, false);
            } else {
                processRoutingRule(newLocation.deviceId(), newLocation.port(), hostMac, hostVlanId, ip, false);
            }
        });
    });
    // For each unchanged location, add new IPs and remove old IPs.
    Sets.intersection(newLocations, prevLocations).forEach(unchangedLocation -> {
        Sets.difference(prevIps, newIps).forEach(ip -> {
            if (doubleTaggedHost) {
                processDoubleTaggedRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, true);
            } else {
                processRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, hostVlanId, ip, true);
            }
        });
        Sets.difference(newIps, prevIps).forEach(ip -> {
            if (doubleTaggedHost) {
                processDoubleTaggedRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, host.innerVlan(), hostVlanId, hostTpid, ip, false);
            } else {
                processRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, hostVlanId, ip, false);
            }
        });
    });
    // ensure dual-homed host locations have viable uplinks
    if (newLocations.size() > prevLocations.size()) {
        newLocations.forEach(loc -> {
            if (srManager.mastershipService.isLocalMaster(loc.deviceId())) {
                srManager.linkHandler.checkUplinksForDualHomedHosts(loc);
            }
        });
    }
}
#end_block

#method_before
private void processDoubleTaggedRoutingRule(DeviceId deviceId, PortNumber port, MacAddress mac, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, IpAddress ip, boolean revoke) {
    ConnectPoint location = new ConnectPoint(deviceId, port);
    VlanId dummyVlan;
    if (!srManager.deviceConfiguration.inSameSubnet(location, ip)) {
        log.info("{} is not included in the subnet config of {}/{}. Ignored.", ip, deviceId, port);
        return;
    }
    log.info("{} routing rule for double-tagged host {} at {}", revoke ? "Revoking" : "Populating", ip, location);
    if (revoke) {
        dummyVlan = srManager.dummyVlanIdStore().get(new DummyVlanIdStoreKey(location, ip));
        if (dummyVlan == null) {
            log.info("Failed to get dummyVlanId for host {} at {}.", ip, location);
        } else {
            srManager.defaultRoutingHandler.revokeDoubleTaggedRoute(deviceId, ip.toIpPrefix(), mac, dummyVlan, innerVlan, outerVlan, outerTpid, port);
        }
    } else {
        dummyVlan = srManager.allocateDummyVlanId(location, ip);
        if (!dummyVlan.equals(VlanId.NONE)) {
            srManager.defaultRoutingHandler.populateDoubleTaggedRoute(deviceId, ip.toIpPrefix(), mac, dummyVlan, innerVlan, outerVlan, outerTpid, port);
        }
    }
    // TODO: move this to appropriate place
    srManager.routingRulePopulator.processDoubleTaggedFilter(deviceId, port, outerVlan, innerVlan, !revoke);
}
#method_after
private void processDoubleTaggedRoutingRule(DeviceId deviceId, PortNumber port, MacAddress mac, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, IpAddress ip, boolean revoke) {
    ConnectPoint location = new ConnectPoint(deviceId, port);
    if (!srManager.deviceConfiguration.inSameSubnet(location, ip)) {
        log.info("{} is not included in the subnet config of {}/{}. Ignored.", ip, deviceId, port);
        return;
    }
    log.info("{} routing rule for double-tagged host {} at {}", revoke ? "Revoking" : "Populating", ip, location);
    if (revoke) {
        srManager.defaultRoutingHandler.revokeDoubleTaggedRoute(deviceId, ip.toIpPrefix(), mac, innerVlan, outerVlan, outerTpid, port);
    } else {
        srManager.defaultRoutingHandler.populateDoubleTaggedRoute(deviceId, ip.toIpPrefix(), mac, innerVlan, outerVlan, outerTpid, port);
    }
}
#end_block

#method_before
void processIntfVlanUpdatedEvent(DeviceId deviceId, PortNumber portNum, VlanId vlanId, boolean popVlan, boolean install) {
    ConnectPoint connectPoint = new ConnectPoint(deviceId, portNum);
    Set<Host> hosts = hostService.getConnectedHosts(connectPoint);
    if (hosts == null || hosts.size() == 0) {
        return;
    }
    hosts.forEach(host -> {
        MacAddress mac = host.mac();
        VlanId hostVlanId = host.vlan();
        // Check whether the host vlan is valid for new interface configuration
        if ((!popVlan && hostVlanId.equals(vlanId)) || (popVlan && hostVlanId.equals(VlanId.NONE))) {
            srManager.defaultRoutingHandler.updateBridging(deviceId, portNum, mac, vlanId, popVlan, install);
            // Update Forwarding objective and corresponding simple Next objective
            // for each host and IP address connected to given port
            host.ipAddresses().forEach(ipAddress -> srManager.defaultRoutingHandler.updateFwdObj(deviceId, portNum, ipAddress.toIpPrefix(), mac, vlanId, popVlan, install));
        }
    });
}
#method_after
void processIntfVlanUpdatedEvent(DeviceId deviceId, PortNumber portNum, VlanId vlanId, boolean popVlan, boolean install) {
    ConnectPoint connectPoint = new ConnectPoint(deviceId, portNum);
    Set<Host> hosts = hostService.getConnectedHosts(connectPoint);
    if (hosts == null || hosts.size() == 0) {
        log.debug("processIntfVlanUpdatedEvent: No hosts connected to {}", connectPoint);
        return;
    }
    hosts.forEach(host -> {
        MacAddress mac = host.mac();
        VlanId hostVlanId = host.vlan();
        // Check whether the host vlan is valid for new interface configuration
        if ((!popVlan && hostVlanId.equals(vlanId)) || (popVlan && hostVlanId.equals(VlanId.NONE))) {
            srManager.defaultRoutingHandler.updateBridging(deviceId, portNum, mac, vlanId, popVlan, install);
            // Update Forwarding objective and corresponding simple Next objective
            // for each host and IP address connected to given port
            host.ipAddresses().forEach(ipAddress -> srManager.defaultRoutingHandler.updateFwdObj(deviceId, portNum, ipAddress.toIpPrefix(), mac, vlanId, popVlan, install));
        }
    });
}
#end_block

#method_before
void processIntfIpUpdatedEvent(ConnectPoint cp, Set<IpPrefix> ipPrefixSet, boolean install) {
    Set<Host> hosts = hostService.getConnectedHosts(cp);
    if (hosts == null || hosts.size() == 0) {
        log.warn("processIntfIpUpdatedEvent: No hosts connected to {}", cp);
        return;
    }
    // Check whether the host IP address is in the interface's subnet
    hosts.forEach(host -> host.ipAddresses().forEach(hostIpAddress -> {
        ipPrefixSet.forEach(ipPrefix -> {
            if (install && ipPrefix.contains(hostIpAddress)) {
                srManager.defaultRoutingHandler.populateRoute(cp.deviceId(), hostIpAddress.toIpPrefix(), host.mac(), host.vlan(), cp.port());
            } else if (!install && ipPrefix.contains(hostIpAddress)) {
                srManager.defaultRoutingHandler.revokeRoute(cp.deviceId(), hostIpAddress.toIpPrefix(), host.mac(), host.vlan(), cp.port());
            }
        });
    }));
}
#method_after
void processIntfIpUpdatedEvent(ConnectPoint cp, Set<IpPrefix> ipPrefixSet, boolean install) {
    Set<Host> hosts = hostService.getConnectedHosts(cp);
    if (hosts == null || hosts.size() == 0) {
        log.debug("processIntfIpUpdatedEvent: No hosts connected to {}", cp);
        return;
    }
    // Check whether the host IP address is in the interface's subnet
    hosts.forEach(host -> host.ipAddresses().forEach(hostIpAddress -> {
        ipPrefixSet.forEach(ipPrefix -> {
            if (install && ipPrefix.contains(hostIpAddress)) {
                srManager.defaultRoutingHandler.populateRoute(cp.deviceId(), hostIpAddress.toIpPrefix(), host.mac(), host.vlan(), cp.port());
            } else if (!install && ipPrefix.contains(hostIpAddress)) {
                srManager.defaultRoutingHandler.revokeRoute(cp.deviceId(), hostIpAddress.toIpPrefix(), host.mac(), host.vlan(), cp.port());
            }
        });
    }));
}
#end_block

#method_before
private FilteringObjective.Builder buildDoubleTaggedFilteringObj(DeviceId deviceId, PortNumber portNum, VlanId outerVlan, VlanId innerVlan) {
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Processing DoubleTaggedFilters aborted");
        return null;
    }
    FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
    // Outer vlan id match should be appeared before inner vlan id match.
    fob.withKey(Criteria.matchInPort(portNum)).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(outerVlan)).addCondition(Criteria.matchVlanId(innerVlan)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    // Pop outer vlan
    tBuilder.popVlan();
    // Set inner vlan id for internal use
    tBuilder.setVlanId(INTERNAL_VLAN);
    // within the same VLAN on this device.
    if (noMoreEnabledPort(deviceId, outerVlan)) {
        tBuilder.wipeDeferred();
    }
    fob.withMeta(tBuilder.build());
    fob.permit().fromApp(srManager.appId);
    return fob;
}
#method_after
private FilteringObjective.Builder buildDoubleTaggedFilteringObj(DeviceId deviceId, PortNumber portNum, VlanId outerVlan, VlanId innerVlan) {
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Processing DoubleTaggedFilters aborted");
        return null;
    }
    FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
    // Outer vlan id match should be appeared before inner vlan id match.
    fob.withKey(Criteria.matchInPort(portNum)).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(outerVlan)).addCondition(Criteria.matchVlanId(innerVlan)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    // Pop outer vlan
    tBuilder.popVlan();
    // within the same VLAN on this device.
    if (noMoreEnabledPort(deviceId, outerVlan)) {
        tBuilder.wipeDeferred();
    }
    fob.withMeta(tBuilder.build());
    fob.permit().fromApp(srManager.appId);
    return fob;
}
#end_block

#method_before
void populateDoubleTaggedRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlan, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, PortNumber outPort) {
    ForwardingObjective.Builder fwdBuilder;
    log.debug("Populate direct routing entry for double-tagged host route {} at {}:{}", prefix, deviceId, outPort);
    ConnectPoint cp = new ConnectPoint(deviceId, outPort);
    IpAddress ipAddress = prefix.address();
    DummyVlanIdStoreKey key = new DummyVlanIdStoreKey(cp, ipAddress);
    VlanId dummyVlanId = srManager.dummyVlanIdStore().get(key);
    if (dummyVlanId == null) {
        log.warn("Failed to retrieve dummy VLAN ID for {} and {}", cp, ipAddress);
        return;
    }
    ForwardingObjective.Builder egressFwdBuilder = egressFwdObjBuilder(cp.port(), dummyVlanId, innerVlan, outerVlan, outerTpid);
    DefaultObjectiveContext egressFwdContext = new DefaultObjectiveContext(objective -> log.debug("Egress rule for IP {} is populated", ipAddress), (objective, error) -> {
        log.warn("Failed to populate egress rule for IP {}: {}", ipAddress, error);
        srManager.dummyVlanIdStore().remove(key);
    });
    try {
        fwdBuilder = routingFwdObjBuilder(deviceId, prefix, hostMac, hostVlan, outPort, false);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateDoubleTaggedRoute");
        return;
    }
    if (fwdBuilder == null) {
        log.warn("Aborting double-tagged host routing table entry due to error for dev:{} route:{}", deviceId, prefix);
        return;
    }
    // Egress forwarding objective should be installed after the nextObjective for the output port is installed.
    // Installation of routingFwdObj will ensure the installation of the nextObjective.
    int nextId = fwdBuilder.add().nextId();
    DefaultObjectiveContext context = new DefaultObjectiveContext(objective -> {
        log.debug("Direct routing rule for double-tagged host route {} populated. nextId={}", prefix, nextId);
        srManager.flowObjectiveService.forward(deviceId, egressFwdBuilder.add(egressFwdContext));
    }, (objective, error) -> log.warn("Failed to populate direct routing rule for double-tagged host route {}: {}", prefix, error));
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(context));
    rulePopulationCounter.incrementAndGet();
}
#method_after
void populateDoubleTaggedRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId dummyVlan, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, PortNumber outPort) {
    ForwardingObjective.Builder fwdBuilder;
    log.debug("Populate direct routing entry for double-tagged host route {} at {}:{}", prefix, deviceId, outPort);
    ForwardingObjective.Builder egressFwdBuilder = egressFwdObjBuilder(outPort, dummyVlan, innerVlan, outerVlan, outerTpid);
    DefaultObjectiveContext egressFwdContext = new DefaultObjectiveContext(objective -> log.debug("Egress rule for IP {} is populated", prefix.address()), (objective, error) -> {
        log.warn("Failed to populate egress rule for IP {}: {}", prefix.address(), error);
        srManager.dummyVlanIdStore().remove(new DummyVlanIdStoreKey(new ConnectPoint(deviceId, outPort), prefix.address()));
    });
    try {
        fwdBuilder = routingFwdObjBuilder(deviceId, prefix, hostMac, dummyVlan, outPort, false);
    } catch (DeviceConfigNotFoundException e) {
        log.error(e.getMessage() + " Aborting populateDoubleTaggedRoute");
        return;
    }
    if (fwdBuilder == null) {
        log.error("Aborting double-tagged host routing table entry due to error for dev:{} route:{}", deviceId, prefix);
        return;
    }
    // Egress forwarding objective should be installed after the nextObjective for the output port is installed.
    // Installation of routingFwdObj will ensure the installation of the nextObjective.
    int nextId = fwdBuilder.add().nextId();
    DefaultObjectiveContext context = new DefaultObjectiveContext(objective -> {
        log.debug("Direct routing rule for double-tagged host route {} populated. nextId={}", prefix, nextId);
        srManager.flowObjectiveService.forward(deviceId, egressFwdBuilder.add(egressFwdContext));
    }, (objective, error) -> log.warn("Failed to populate direct routing rule for double-tagged host route {}: {}", prefix, error));
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(context));
    rulePopulationCounter.incrementAndGet();
}
#end_block

#method_before
void revokeDoubleTaggedRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlan, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, PortNumber outPort) {
    revokeRoute(deviceId, prefix, hostMac, hostVlan, outPort);
    ConnectPoint cp = new ConnectPoint(deviceId, outPort);
    IpAddress ipAddress = prefix.address();
    DummyVlanIdStoreKey key = new DummyVlanIdStoreKey(cp, ipAddress);
    VlanId dummyVlanId = srManager.dummyVlanIdStore().get(key);
    if (dummyVlanId == null) {
        log.warn("Failed to retrieve dummy VLAN ID for {} and {}", cp, ipAddress);
        return;
    }
    ForwardingObjective.Builder fob = egressFwdObjBuilder(cp.port(), dummyVlanId, innerVlan, outerVlan, outerTpid);
    DefaultObjectiveContext context = new DefaultObjectiveContext(objective -> {
        log.debug("Egress rule for IP {} revoked", ipAddress);
        srManager.dummyVlanIdStore().remove(key);
    }, (objective, error) -> {
        log.warn("Failed to revoke egress rule for IP {}: {}", ipAddress, error);
    });
    srManager.flowObjectiveService.forward(cp.deviceId(), fob.remove(context));
}
#method_after
void revokeDoubleTaggedRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlan, VlanId innerVlan, VlanId outerVlan, EthType outerTpid, PortNumber outPort) {
    revokeRoute(deviceId, prefix, hostMac, hostVlan, outPort);
    DummyVlanIdStoreKey key = new DummyVlanIdStoreKey(new ConnectPoint(deviceId, outPort), prefix.address());
    VlanId dummyVlanId = srManager.dummyVlanIdStore().get(key);
    if (dummyVlanId == null) {
        log.warn("Failed to retrieve dummy VLAN ID for {}/{} and {}", deviceId, outPort, prefix.address());
        return;
    }
    ForwardingObjective.Builder fob = egressFwdObjBuilder(outPort, dummyVlanId, innerVlan, outerVlan, outerTpid);
    DefaultObjectiveContext context = new DefaultObjectiveContext(objective -> {
        log.debug("Egress rule for IP {} revoked", prefix.address());
        srManager.dummyVlanIdStore().remove(key);
    }, (objective, error) -> {
        log.warn("Failed to revoke egress rule for IP {}: {}", prefix.address(), error);
    });
    srManager.flowObjectiveService.forward(deviceId, fob.remove(context));
}
#end_block

#method_before
protected Collection<FlowRule> processEgress(ForwardingObjective fwd) {
    log.debug("Processing egress forwarding objective:{} in dev:{}", fwd, deviceId);
    List<FlowRule> rules = new ArrayList<>();
    // Build selector
    TrafficSelector.Builder sb = DefaultTrafficSelector.builder();
    VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) fwd.selector().getCriterion(Criterion.Type.VLAN_VID);
    if (vlanIdCriterion == null) {
        log.error("Egress forwarding objective:{} must include vlanId", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return rules;
    }
    Optional<Instruction> outInstr = fwd.treatment().allInstructions().stream().filter(instruction -> instruction instanceof OutputInstruction).findFirst();
    if (!outInstr.isPresent()) {
        log.error("Egress forwarding objective:{} must include output port", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return rules;
    }
    PortNumber portNumber = ((OutputInstruction) outInstr.get()).port();
    sb.matchVlanId(vlanIdCriterion.vlanId());
    OfdpaMatchActsetOutput actsetOutput = new OfdpaMatchActsetOutput(portNumber);
    sb.extension(actsetOutput, deviceId);
    sb.extension(new OfdpaMatchAllowVlanTranslation(Short.valueOf("1")), deviceId);
    // Build a flow rule for Egress VLAN Flow table
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    tb.transition(EGRESS_DSCP_PCP_REMARK_FLOW_TABLE);
    if (fwd.treatment() != null) {
        for (Instruction instr : fwd.treatment().allInstructions()) {
            if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.VLAN_ID) {
                tb.immediate().add(instr);
            }
            if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.VLAN_PUSH) {
                tb.immediate().pushVlan();
                EthType ethType = ((L2ModificationInstruction.ModVlanHeaderInstruction) instr).ethernetType();
                if (ethType.equals(EtherType.QINQ.ethType())) {
                    // Build a flow rule for Egress TPID Flow table
                    TrafficSelector tpidSelector = DefaultTrafficSelector.builder().extension(actsetOutput, deviceId).matchVlanId(VlanId.ANY).build();
                    // OXM_ID 0x80000c02: VLAN_VID
                    // OXM_ID 0x80010200: PACKET_REG(1)
                    TrafficTreatment tpidTreatment = DefaultTrafficTreatment.builder().extension(new Ofdpa3CopyField(12, 0, 0, 0x80010200, 0x80000c02), deviceId).popVlan().pushVlan(EtherType.QINQ.ethType()).extension(new Ofdpa3CopyField(12, 0, 0, 0x80000c02, 0x80010200), deviceId).build();
                    FlowRule.Builder tpidRuleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(tpidSelector).withTreatment(tpidTreatment).makePermanent().forTable(EGRESS_TPID_FLOW_TABLE);
                    rules.add(tpidRuleBuilder.build());
                }
            }
        }
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sb.build()).withTreatment(tb.build()).makePermanent().forTable(EGRESS_VLAN_FLOW_TABLE);
    rules.add(ruleBuilder.build());
    return rules;
}
#method_after
protected Collection<FlowRule> processEgress(ForwardingObjective fwd) {
    log.debug("Processing egress forwarding objective:{} in dev:{}", fwd, deviceId);
    List<FlowRule> rules = new ArrayList<>();
    // Build selector
    TrafficSelector.Builder sb = DefaultTrafficSelector.builder();
    VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) fwd.selector().getCriterion(Criterion.Type.VLAN_VID);
    if (vlanIdCriterion == null) {
        log.error("Egress forwarding objective:{} must include vlanId", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return rules;
    }
    Optional<Instruction> outInstr = fwd.treatment().allInstructions().stream().filter(instruction -> instruction instanceof OutputInstruction).findFirst();
    if (!outInstr.isPresent()) {
        log.error("Egress forwarding objective:{} must include output port", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return rules;
    }
    PortNumber portNumber = ((OutputInstruction) outInstr.get()).port();
    sb.matchVlanId(vlanIdCriterion.vlanId());
    OfdpaMatchActsetOutput actsetOutput = new OfdpaMatchActsetOutput(portNumber);
    sb.extension(actsetOutput, deviceId);
    sb.extension(new OfdpaMatchAllowVlanTranslation(ALLOW_VLAN_TRANSLATION), deviceId);
    // Build a flow rule for Egress VLAN Flow table
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    tb.transition(EGRESS_DSCP_PCP_REMARK_FLOW_TABLE);
    if (fwd.treatment() != null) {
        for (Instruction instr : fwd.treatment().allInstructions()) {
            if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.VLAN_ID) {
                tb.immediate().add(instr);
            }
            if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.VLAN_PUSH) {
                tb.immediate().pushVlan();
                EthType ethType = ((L2ModificationInstruction.ModVlanHeaderInstruction) instr).ethernetType();
                if (ethType.equals(EtherType.QINQ.ethType())) {
                    // Build a flow rule for Egress TPID Flow table
                    TrafficSelector tpidSelector = DefaultTrafficSelector.builder().extension(actsetOutput, deviceId).matchVlanId(VlanId.ANY).build();
                    TrafficTreatment tpidTreatment = DefaultTrafficTreatment.builder().extension(new Ofdpa3CopyField(COPY_FIELD_NBITS, COPY_FIELD_OFFSET, COPY_FIELD_OFFSET, OXM_ID_VLAN_VID, OXM_ID_PACKET_REG_1), deviceId).popVlan().pushVlan(EtherType.QINQ.ethType()).extension(new Ofdpa3CopyField(COPY_FIELD_NBITS, COPY_FIELD_OFFSET, COPY_FIELD_OFFSET, OXM_ID_PACKET_REG_1, OXM_ID_VLAN_VID), deviceId).build();
                    FlowRule.Builder tpidRuleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(tpidSelector).withTreatment(tpidTreatment).makePermanent().forTable(EGRESS_TPID_FLOW_TABLE);
                    rules.add(tpidRuleBuilder.build());
                }
            }
        }
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sb.build()).withTreatment(tb.build()).makePermanent().forTable(EGRESS_VLAN_FLOW_TABLE);
    rules.add(ruleBuilder.build());
    return rules;
}
#end_block

#method_before
private void processDoubleTaggedFilter(FilteringObjective filteringObjective, boolean install, ApplicationId applicationId) {
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion innervidCriterion = null;
    VlanIdCriterion outerVidCriterion = null;
    VlanId egressVlan = null;
    boolean popVlan = false;
    TrafficTreatment meta = filteringObjective.meta();
    if (!filteringObjective.key().equals(Criteria.dummy()) && filteringObjective.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filteringObjective.key();
    }
    if (portCriterion == null) {
        log.warn("No IN_PORT defined in filtering objective from app: {}" + "Failed to program VLAN tables.", applicationId);
        return;
    } else {
        log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    }
    if (meta != null && meta.allInstructions().size() == 2) {
        for (Instruction inst : meta.allInstructions()) {
            L2ModificationInstruction l2Inst = (L2ModificationInstruction) inst;
            switch(l2Inst.subtype()) {
                case VLAN_POP:
                    popVlan = true;
                    break;
                case VLAN_ID:
                    egressVlan = ((L2ModificationInstruction.ModVlanIdInstruction) l2Inst).vlanId();
                    break;
                default:
                    log.info("Unsupported action {}", l2Inst);
                    break;
            }
        }
    }
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filteringObjective.conditions()) {
        switch(criterion.type()) {
            case ETH_DST:
            case ETH_DST_MASKED:
                ethCriterion = (EthCriterion) criterion;
                break;
            case VLAN_VID:
                if (innervidCriterion == null) {
                    innervidCriterion = (VlanIdCriterion) criterion;
                } else {
                    outerVidCriterion = innervidCriterion;
                    innervidCriterion = (VlanIdCriterion) criterion;
                }
                break;
            default:
                log.warn("Unsupported filter {}", criterion);
                fail(filteringObjective, ObjectiveError.UNSUPPORTED);
                return;
        }
    }
    if (innervidCriterion == null || outerVidCriterion == null) {
        log.warn("filtering objective should have two vidCriterion.");
        return;
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.warn("filtering objective missing dstMac, cannot program TMAC table");
        return;
    } else {
        MacAddress unicastMac = readEthDstFromTreatment(filteringObjective.meta());
        // Build a dummy VlanIdCriterion matching VlanId.NONE,
        // to make packets to be handled as untagged
        VlanIdCriterion vidCriterion = (VlanIdCriterion) Criteria.matchVlanId(VlanId.NONE);
        List<List<FlowRule>> allStages = processEthDstFilter(portCriterion, ethCriterion, vidCriterion, egressVlan, unicastMac, applicationId);
        for (List<FlowRule> flowRules : allStages) {
            log.trace("Starting a new flow rule stage for TMAC table flow");
            ops.newStage();
            for (FlowRule flowRule : flowRules) {
                log.trace("{} flow rules in TMAC table: {} for dev: {}", (install) ? "adding" : "removing", flowRules, deviceId);
                if (install) {
                    ops = ops.add(flowRule);
                } else {
                    // same VLAN on this device if TMAC doesn't support matching on in_port.
                    if (matchInPortTmacTable() || (filteringObjective.meta() != null && filteringObjective.meta().clearedDeferred())) {
                        ops = ops.remove(flowRule);
                    } else {
                        log.debug("Abort TMAC flow removal on {}. Some other ports still share this TMAC flow");
                    }
                }
            }
        }
    }
    List<FlowRule> rules;
    rules = processDoubleVlanIdFilter(portCriterion, innervidCriterion, outerVidCriterion, popVlan, egressVlan, applicationId);
    for (FlowRule flowRule : rules) {
        log.trace("{} flow rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", flowRule, deviceId);
        ops = install ? ops.add(flowRule) : ops.remove(flowRule);
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.debug("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filteringObjective);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filteringObjective, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
private void processDoubleTaggedFilter(FilteringObjective filteringObjective, boolean install, ApplicationId applicationId) {
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion innervidCriterion = null;
    VlanIdCriterion outerVidCriterion = null;
    boolean popVlan = false;
    TrafficTreatment meta = filteringObjective.meta();
    if (!filteringObjective.key().equals(Criteria.dummy()) && filteringObjective.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filteringObjective.key();
    }
    if (portCriterion == null) {
        log.warn("No IN_PORT defined in filtering objective from app: {}" + "Failed to program VLAN tables.", applicationId);
        return;
    } else {
        log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    }
    // meta should have only one instruction, popVlan.
    if (meta != null && meta.allInstructions().size() == 1) {
        L2ModificationInstruction l2Inst = (L2ModificationInstruction) meta.allInstructions().get(0);
        if (l2Inst.subtype().equals(L2SubType.VLAN_POP)) {
            popVlan = true;
        } else {
            log.warn("Filtering objective can have only VLAN_POP instruction.");
            return;
        }
    } else {
        log.warn("Filtering objective should have one instruction.");
        return;
    }
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filteringObjective.conditions()) {
        switch(criterion.type()) {
            case ETH_DST:
            case ETH_DST_MASKED:
                ethCriterion = (EthCriterion) criterion;
                break;
            case VLAN_VID:
                if (innervidCriterion == null) {
                    innervidCriterion = (VlanIdCriterion) criterion;
                } else {
                    outerVidCriterion = innervidCriterion;
                    innervidCriterion = (VlanIdCriterion) criterion;
                }
                break;
            default:
                log.warn("Unsupported filter {}", criterion);
                fail(filteringObjective, ObjectiveError.UNSUPPORTED);
                return;
        }
    }
    if (innervidCriterion == null || outerVidCriterion == null) {
        log.warn("filtering objective should have two vidCriterion.");
        return;
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.warn("filtering objective missing dstMac, cannot program TMAC table");
        return;
    } else {
        MacAddress unicastMac = readEthDstFromTreatment(filteringObjective.meta());
        List<List<FlowRule>> allStages = processEthDstFilter(portCriterion, ethCriterion, innervidCriterion, innervidCriterion.vlanId(), unicastMac, applicationId);
        for (List<FlowRule> flowRules : allStages) {
            log.trace("Starting a new flow rule stage for TMAC table flow");
            ops.newStage();
            for (FlowRule flowRule : flowRules) {
                log.trace("{} flow rules in TMAC table: {} for dev: {}", (install) ? "adding" : "removing", flowRules, deviceId);
                if (install) {
                    ops = ops.add(flowRule);
                } else {
                    // same VLAN on this device if TMAC doesn't support matching on in_port.
                    if (matchInPortTmacTable() || (filteringObjective.meta() != null && filteringObjective.meta().clearedDeferred())) {
                        ops = ops.remove(flowRule);
                    } else {
                        log.debug("Abort TMAC flow removal on {}. Some other ports still share this TMAC flow");
                    }
                }
            }
        }
    }
    List<FlowRule> rules;
    rules = processDoubleVlanIdFilter(portCriterion, innervidCriterion, outerVidCriterion, popVlan, applicationId);
    for (FlowRule flowRule : rules) {
        log.trace("{} flow rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", flowRule, deviceId);
        ops = install ? ops.add(flowRule) : ops.remove(flowRule);
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.debug("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filteringObjective);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filteringObjective, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
private List<FlowRule> processDoubleVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion innerVidCriterion, VlanIdCriterion outerVidCriterion, boolean popVlan, VlanId egressVlan, ApplicationId applicationId) {
    TrafficSelector.Builder outerSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder outerTreatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder innerSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder innerTreatment = DefaultTrafficTreatment.builder();
    VlanId outerVlanId = outerVidCriterion.vlanId();
    VlanId innerVlanId = innerVidCriterion.vlanId();
    PortNumber portNumber = portCriterion.port();
    // Check arguments
    if (PortNumber.ALL.equals(portNumber) || outerVlanId.equals(VlanId.NONE) || innerVlanId.equals(VlanId.NONE)) {
        log.warn("Incomplete Filtering Objective. " + "VLAN Table cannot be programmed for {}", deviceId);
        return ImmutableList.of();
    } else {
        outerSelector.matchInPort(portNumber);
        innerSelector.matchInPort(portNumber);
        outerTreatment.transition(VLAN_1_TABLE);
        innerTreatment.transition(TMAC_TABLE);
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaOuterMatchVlanVid = new OfdpaMatchVlanVid(outerVlanId);
            outerSelector.extension(ofdpaOuterMatchVlanVid, deviceId);
            OfdpaMatchVlanVid ofdpaInnerMatchVlanVid = new OfdpaMatchVlanVid(innerVlanId);
            innerSelector.extension(ofdpaInnerMatchVlanVid, deviceId);
        } else {
            outerSelector.matchVlanId(outerVlanId);
            innerSelector.matchVlanId(innerVlanId);
        }
        innerSelector.extension(new Ofdpa3MatchOvid(outerVlanId), deviceId);
        outerTreatment.extension(new Ofdpa3SetOvid(outerVlanId), deviceId);
        innerTreatment.setVlanId(egressVlan);
        if (popVlan) {
            outerTreatment.popVlan();
        }
    }
    FlowRule outerRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(outerSelector.build()).withTreatment(outerTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
    FlowRule innerRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(innerSelector.build()).withTreatment(innerTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_1_TABLE).build();
    return ImmutableList.of(outerRule, innerRule);
}
#method_after
private List<FlowRule> processDoubleVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion innerVidCriterion, VlanIdCriterion outerVidCriterion, boolean popVlan, ApplicationId applicationId) {
    TrafficSelector.Builder outerSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder outerTreatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder innerSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder innerTreatment = DefaultTrafficTreatment.builder();
    VlanId outerVlanId = outerVidCriterion.vlanId();
    VlanId innerVlanId = innerVidCriterion.vlanId();
    PortNumber portNumber = portCriterion.port();
    // Check arguments
    if (PortNumber.ALL.equals(portNumber) || outerVlanId.equals(VlanId.NONE) || innerVlanId.equals(VlanId.NONE)) {
        log.warn("Incomplete Filtering Objective. " + "VLAN Table cannot be programmed for {}", deviceId);
        return ImmutableList.of();
    } else {
        outerSelector.matchInPort(portNumber);
        innerSelector.matchInPort(portNumber);
        outerTreatment.transition(VLAN_1_TABLE);
        innerTreatment.transition(TMAC_TABLE);
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaOuterMatchVlanVid = new OfdpaMatchVlanVid(outerVlanId);
            outerSelector.extension(ofdpaOuterMatchVlanVid, deviceId);
            OfdpaMatchVlanVid ofdpaInnerMatchVlanVid = new OfdpaMatchVlanVid(innerVlanId);
            innerSelector.extension(ofdpaInnerMatchVlanVid, deviceId);
        } else {
            outerSelector.matchVlanId(outerVlanId);
            innerSelector.matchVlanId(innerVlanId);
        }
        innerSelector.extension(new Ofdpa3MatchOvid(outerVlanId), deviceId);
        outerTreatment.extension(new Ofdpa3SetOvid(outerVlanId), deviceId);
        if (popVlan) {
            outerTreatment.popVlan();
        }
    }
    FlowRule outerRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(outerSelector.build()).withTreatment(outerTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
    FlowRule innerRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(innerSelector.build()).withTreatment(innerTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_1_TABLE).build();
    return ImmutableList.of(outerRule, innerRule);
}
#end_block

#method_before
private boolean isDoubleTagged(FilteringObjective fob) {
    return fob.meta() != null && fob.meta().allInstructions().stream().anyMatch(inst -> inst.type() == L2MODIFICATION && ((L2ModificationInstruction) inst).subtype() == L2SubType.VLAN_ID) && fob.conditions().stream().filter(criterion -> criterion.type() == VLAN_VID).count() == 2;
}
#method_after
private boolean isDoubleTagged(FilteringObjective fob) {
    return fob.meta() != null && fob.meta().allInstructions().stream().anyMatch(inst -> inst.type() == L2MODIFICATION && ((L2ModificationInstruction) inst).subtype() == L2SubType.VLAN_POP) && fob.conditions().stream().filter(criterion -> criterion.type() == VLAN_VID).count() == 2;
}
#end_block

#method_before
@Override
public void handleIqStanza(IQ iq) {
    if (isPubSub(iq)) {
        log.info("IQ");
        notifyListeners(iq);
    }
}
#method_after
@Override
public void handleIqStanza(IQ iq) {
    if (isPubSub(iq)) {
        notifyListeners(iq);
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    coreService.registerApplication(APP_ID, this::cleanup);
    // FIXME: properties registration temporary removed because of strange issue while activating
    // cfgService.registerProperties(getClass());
    deviceFactory.init(agent);
    xmppServer.setConfiguration(context.getProperties());
    xmppServer.start(deviceFactory);
    log.info("XmppControllerImpl started.");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    coreService.registerApplication(APP_ID, this::cleanup);
    cfgService.registerProperties(getClass());
    deviceFactory.init(agent);
    xmppServer.setConfiguration(context.getProperties());
    xmppServer.start(deviceFactory);
    log.info("XmppControllerImpl started.");
}
#end_block

#method_before
@Test
public void testNotifyEvent() {
    XmppEventNotification eventNotification = new XmppEventNotification("test", new DefaultElement("test"));
    pubSubController.notify(DeviceId.NONE, eventNotification);
    assertThat(testDevice.sentPackets.size(), is(1));
    assertThat(testDevice.sentPackets.get(0), is(eventNotification));
}
#method_after
@Test
public void testNotifyEvent() {
    XmppEventNotification eventNotification = new XmppEventNotification(nodeAttribute, new DefaultElement(nodeAttribute));
    pubSubController.notify(DeviceId.NONE, eventNotification);
    assertThat(testDevice.sentPackets.size(), is(1));
    assertThat(testDevice.sentPackets.get(0), is(eventNotification));
}
#end_block

#method_before
@Test
public void testNotifyError() {
    XmppPubSubError xmppPubSubError = new XmppPubSubError(XmppPubSubError.PubSubApplicationCondition.ITEM_NOT_FOUND);
    pubSubController.notifyError(DeviceId.NONE, xmppPubSubError);
    assertThat(testDevice.sentErrors.size(), is(1));
}
#method_after
@Test
public void testNotifyError() {
    XmppPubSubError xmppPubSubError = new XmppPubSubError(ITEM_NOT_FOUND);
    pubSubController.notifyError(DeviceId.NONE, xmppPubSubError);
    assertThat(testDevice.sentErrors.size(), is(1));
}
#end_block

#method_before
private XmppSubscribe buildXmppSubscribe() {
    IQ iq = new IQ(IQ.Type.set);
    iq.setTo("xmpp@onosproject.org");
    iq.setFrom("test@xmpp.org");
    Element element = new DefaultElement("pubsub", Namespace.get(XmppPubSubConstants.PUBSUB_NAMESPACE));
    Element childElement = new DefaultElement("subscribe");
    childElement.addAttribute("node", "test");
    element.add(childElement);
    iq.setChildElement(element);
    XmppSubscribe xmppSubscribe = new XmppSubscribe(iq);
    return xmppSubscribe;
}
#method_after
private XmppSubscribe buildXmppSubscribe() {
    IQ iq = new IQ(IQ.Type.set);
    iq.setTo(toJid);
    iq.setFrom(fromJid);
    Element element = new DefaultElement(pubSub, Namespace.get(XmppPubSubConstants.PUBSUB_NAMESPACE));
    Element childElement = new DefaultElement(subscribe);
    childElement.addAttribute(node, nodeAttribute);
    element.add(childElement);
    iq.setChildElement(element);
    XmppSubscribe xmppSubscribe = new XmppSubscribe(iq);
    return xmppSubscribe;
}
#end_block

#method_before
private XmppUnsubscribe buildXmppUnsubscribe() {
    IQ iq = new IQ(IQ.Type.set);
    iq.setTo("xmpp@onosproject.org");
    iq.setFrom("test@xmpp.org");
    Element element = new DefaultElement("pubsub", Namespace.get(XmppPubSubConstants.PUBSUB_NAMESPACE));
    Element childElement = new DefaultElement("unsubscribe");
    childElement.addAttribute("node", "test");
    element.add(childElement);
    iq.setChildElement(element);
    XmppUnsubscribe xmppUnsubscribe = new XmppUnsubscribe(iq);
    return xmppUnsubscribe;
}
#method_after
private XmppUnsubscribe buildXmppUnsubscribe() {
    IQ iq = new IQ(IQ.Type.set);
    iq.setTo(toJid);
    iq.setFrom(fromJid);
    Element element = new DefaultElement(pubSub, Namespace.get(XmppPubSubConstants.PUBSUB_NAMESPACE));
    Element childElement = new DefaultElement(unsubscribe);
    childElement.addAttribute(node, nodeAttribute);
    element.add(childElement);
    iq.setChildElement(element);
    XmppUnsubscribe xmppUnsubscribe = new XmppUnsubscribe(iq);
    return xmppUnsubscribe;
}
#end_block

#method_before
private XmppPublish buildXmppPublish() {
    IQ iq = new IQ(IQ.Type.set);
    iq.setTo("xmpp@onosproject.org");
    iq.setFrom("test@xmpp.org");
    Element element = new DefaultElement("pubsub", Namespace.get(XmppPubSubConstants.PUBSUB_NAMESPACE));
    Element publishElement = new DefaultElement("publish").addAttribute("node", "test");
    Element itemElement = new DefaultElement("item").addAttribute("id", "id-000");
    Element entryElement = new DefaultElement("entry", Namespace.get("jabber:test:item"));
    itemElement.add(entryElement);
    publishElement.add(itemElement);
    element.add(publishElement);
    iq.setChildElement(element);
    XmppPublish xmppPublish = new XmppPublish(iq);
    return xmppPublish;
}
#method_after
private XmppPublish buildXmppPublish() {
    IQ iq = new IQ(IQ.Type.set);
    iq.setTo(toJid);
    iq.setFrom(fromJid);
    Element element = new DefaultElement(pubSub, Namespace.get(XmppPubSubConstants.PUBSUB_NAMESPACE));
    Element publishElement = new DefaultElement(publish).addAttribute(node, nodeAttribute);
    Element itemElement = new DefaultElement(item).addAttribute(id, itemId);
    Element entryElement = new DefaultElement(entry, Namespace.get(testNamespace));
    itemElement.add(entryElement);
    publishElement.add(itemElement);
    element.add(publishElement);
    iq.setChildElement(element);
    XmppPublish xmppPublish = new XmppPublish(iq);
    return xmppPublish;
}
#end_block

#method_before
private XmppRetract buildXmppRetract() {
    IQ iq = new IQ(IQ.Type.set);
    iq.setTo("xmpp@onosproject.org");
    iq.setFrom("test@xmpp.org");
    Element element = new DefaultElement("pubsub", Namespace.get(XmppPubSubConstants.PUBSUB_NAMESPACE));
    Element retractElement = new DefaultElement("retract").addAttribute("node", "test");
    Element itemElement = new DefaultElement("item").addAttribute("id", "id-000");
    retractElement.add(itemElement);
    element.add(retractElement);
    iq.setChildElement(element);
    XmppRetract xmppRetract = new XmppRetract(iq);
    return xmppRetract;
}
#method_after
private XmppRetract buildXmppRetract() {
    IQ iq = new IQ(IQ.Type.set);
    iq.setTo(toJid);
    iq.setFrom(fromJid);
    Element element = new DefaultElement(pubSub, Namespace.get(XmppPubSubConstants.PUBSUB_NAMESPACE));
    Element retractElement = new DefaultElement(retract).addAttribute(node, nodeAttribute);
    Element itemElement = new DefaultElement(item).addAttribute(id, itemId);
    retractElement.add(itemElement);
    element.add(retractElement);
    iq.setChildElement(element);
    XmppRetract xmppRetract = new XmppRetract(iq);
    return xmppRetract;
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    mainEventExecutor.shutdown();
    hostEventExecutor.shutdown();
    routeEventExecutor.shutdown();
    mcastEventExecutor.shutdown();
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    topologyService.removeListener(topologyListener);
    mastershipService.removeListener(mastershipListener);
    clusterService.removeListener(clusterListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.forEach((k, v) -> v.shutdown());
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    mainEventExecutor.shutdown();
    hostEventExecutor.shutdown();
    routeEventExecutor.shutdown();
    mcastEventExecutor.shutdown();
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    topologyService.removeListener(topologyListener);
    mastershipService.removeListener(mastershipListener);
    clusterService.removeListener(clusterListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.forEach((k, v) -> v.shutdown());
    groupHandlerMap.clear();
    defaultRoutingHandler.shutdown();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(DHCP_V4_RELAY_APP);
    hostService.addListener(hostListener);
    providerService = providerRegistry.register(this);
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    modified(context);
    appId = coreService.registerApplication(DHCP_V4_RELAY_APP);
    hostService.addListener(hostListener);
    providerService = providerRegistry.register(this);
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    providerRegistry.unregister(this);
    hostService.removeListener(hostListener);
    defaultServerInfoList.forEach(this::stopMonitoringIps);
    defaultServerInfoList.clear();
    indirectServerInfoList.forEach(this::stopMonitoringIps);
    indirectServerInfoList.clear();
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    providerRegistry.unregister(this);
    hostService.removeListener(hostListener);
    defaultServerInfoList.forEach(this::stopMonitoringIps);
    defaultServerInfoList.clear();
    indirectServerInfoList.forEach(this::stopMonitoringIps);
    indirectServerInfoList.clear();
}
#end_block

#method_before
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    Boolean isConfigValid = false;
    for (DhcpServerConfig serverConfig : configs) {
        if (serverConfig.getDhcpServerIp4().isPresent()) {
            isConfigValid = true;
            break;
        }
    }
    if (!isConfigValid) {
        log.warn("No IP V4 server address found.");
        // No IP V6 address found
        return;
    }
    // if (!serverInfoList.isEmpty()) {
    for (DhcpServerInfo oldServerInfo : serverInfoList) {
        log.info("In for (DhcpServerInfo oldServerInfo : serverInfoList) {");
        // remove old server info
        // DhcpServerInfo oldServerInfo = serverInfoList.remove(0);
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp4().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp4().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    // Create new server info according to the config
    serverInfoList.clear();
    for (DhcpServerConfig serverConfig : configs) {
        log.info("// Create new server info according to the config");
        DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V4);
        checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
        checkState(newServerInfo.getDhcpServerIp4().isPresent(), "IP of DHCP server not exists");
        log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp4().orElse(null));
        Ip4Address serverIp = newServerInfo.getDhcpServerIp4().get();
        Ip4Address ipToProbe;
        if (newServerInfo.getDhcpGatewayIp4().isPresent()) {
            ipToProbe = newServerInfo.getDhcpGatewayIp4().get();
        } else {
            ipToProbe = newServerInfo.getDhcpServerIp4().orElse(null);
        }
        log.info("Probe_IP {}", ipToProbe);
        String hostToProbe = newServerInfo.getDhcpGatewayIp4().map(ip -> "gateway").orElse("server");
        log.debug("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            Host host = hosts.iterator().next();
            newServerInfo.setDhcpConnectVlan(host.vlan());
            newServerInfo.setDhcpConnectMac(host.mac());
        }
        // Add new server info
        synchronized (this) {
            // serverInfoList.clear();
            serverInfoList.add(newServerInfo);
        }
        requestDhcpPacket(serverIp);
    }
}
#method_after
public void setDhcpServerConfigs(Collection<DhcpServerConfig> configs, List<DhcpServerInfo> serverInfoList) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    Boolean isConfigValid = false;
    for (DhcpServerConfig serverConfig : configs) {
        if (serverConfig.getDhcpServerIp4().isPresent()) {
            isConfigValid = true;
            break;
        }
    }
    if (!isConfigValid) {
        log.warn("No IP V4 server address found.");
        // No IP V6 address found
        return;
    }
    // if (!serverInfoList.isEmpty()) {
    for (DhcpServerInfo oldServerInfo : serverInfoList) {
        log.info("In for (DhcpServerInfo oldServerInfo : serverInfoList) {");
        // remove old server info
        // DhcpServerInfo oldServerInfo = serverInfoList.remove(0);
        // stop monitoring gateway or server
        oldServerInfo.getDhcpGatewayIp4().ifPresent(gatewayIp -> {
            hostService.stopMonitoringIp(gatewayIp);
        });
        oldServerInfo.getDhcpServerIp4().ifPresent(serverIp -> {
            hostService.stopMonitoringIp(serverIp);
            cancelDhcpPacket(serverIp);
        });
    }
    // Create new server info according to the config
    serverInfoList.clear();
    for (DhcpServerConfig serverConfig : configs) {
        log.debug("Create new server info according to the config");
        DhcpServerInfo newServerInfo = new DhcpServerInfo(serverConfig, DhcpServerInfo.Version.DHCP_V4);
        checkState(newServerInfo.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
        checkState(newServerInfo.getDhcpServerIp4().isPresent(), "IP of DHCP server not exists");
        log.debug("DHCP server connect point: {}", newServerInfo.getDhcpServerConnectPoint().orElse(null));
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp4().orElse(null));
        Ip4Address serverIp = newServerInfo.getDhcpServerIp4().get();
        Ip4Address ipToProbe;
        if (newServerInfo.getDhcpGatewayIp4().isPresent()) {
            ipToProbe = newServerInfo.getDhcpGatewayIp4().get();
        } else {
            ipToProbe = newServerInfo.getDhcpServerIp4().orElse(null);
        }
        log.info("Probe_IP {}", ipToProbe);
        String hostToProbe = newServerInfo.getDhcpGatewayIp4().map(ip -> "gateway").orElse("server");
        log.debug("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        hostService.startMonitoringIp(ipToProbe);
        Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
        if (!hosts.isEmpty()) {
            Host host = hosts.iterator().next();
            newServerInfo.setDhcpConnectVlan(host.vlan());
            newServerInfo.setDhcpConnectMac(host.mac());
        }
        // Add new server info
        synchronized (this) {
            // serverInfoList.clear();
            serverInfoList.add(newServerInfo);
        }
        requestDhcpPacket(serverIp);
    }
}
#end_block

#method_before
private void handleLeaseQueryActivateMsg(Ethernet packet, DHCP dhcpPayload) {
    log.debug("LQ: Got DHCPLEASEACTIVE packet!");
    if (learnRouteFromLeasequery) {
        // TODO: release the ip address from client
        MacAddress clientMacAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
        VlanId vlanId = VlanId.vlanId(packet.getVlanID());
        HostId hostId = HostId.hostId(clientMacAddress, vlanId);
        DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
        if (record == null) {
            log.warn("Can't find record for host {} when processing DHCPLEASEACTIVE", hostId);
            return;
        }
        // need to update routes
        log.debug("Lease Query for Client results in DHCPLEASEACTIVE - route needs to be modified");
        // get current route
        // find the ip of that client with the DhcpRelay store
        Ip4Address clientIP = record.ip4Address().orElse(null);
        log.debug("LQ: IP of host is " + clientIP.getIp4Address());
        MacAddress nextHopMac = record.nextHop().orElse(null);
        log.debug("LQ: MAC of resulting *OLD* NH for that host is " + nextHopMac.toString());
        // find the new NH by looking at the src MAC of the dhcp request
        // from the LQ store
        // record.nextHopTemp().orElse(null);
        MacAddress newNextHopMac = nextHopMac;
        log.debug("LQ: MAC of resulting *NEW* NH for that host is " + newNextHopMac.toString());
        log.debug("LQ: updating dhcp relay record with new NH");
        record.nextHop(newNextHopMac);
        // find the next hop IP from its mac
        HostId gwHostId = HostId.hostId(newNextHopMac, vlanId);
        Host gwHost = hostService.getHost(gwHostId);
        if (gwHost == null) {
            log.warn("Can't find gateway for new NH host " + gwHostId);
            return;
        }
        Ip4Address nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
        if (nextHopIp == null) {
            log.warn("Can't find IP address of gateway " + gwHost);
            return;
        }
        log.debug("LQ: *NEW* NH IP for host is " + nextHopIp.getIp4Address());
        Route route = new Route(Route.Source.STATIC, clientIP.toIpPrefix(), nextHopIp);
        routeStore.updateRoute(route);
        // remove from temp store
        dhcpRelayStore.removeDhcpRecord(hostId);
    }
    // and forward to client
    InternalPacket ethernetPacket = processLeaseQueryFromServer(packet);
    if (ethernetPacket != null) {
        sendResponseToClient(ethernetPacket, dhcpPayload);
    }
}
#method_after
private void handleLeaseQueryActivateMsg(Ethernet packet, DHCP dhcpPayload) {
    log.debug("LQ: Got DHCPLEASEACTIVE packet!");
    if (learnRouteFromLeasequery) {
        // TODO: release the ip address from client
        MacAddress clientMacAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
        VlanId vlanId = VlanId.vlanId(packet.getVlanID());
        HostId hostId = HostId.hostId(clientMacAddress, vlanId);
        DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
        if (record == null) {
            log.warn("Can't find record for host {} when processing DHCPLEASEACTIVE", hostId);
            return;
        }
        // need to update routes
        log.debug("Lease Query for Client results in DHCPLEASEACTIVE - route needs to be modified");
        // get current route
        // find the ip of that client with the DhcpRelay store
        Ip4Address clientIP = record.ip4Address().orElse(null);
        log.debug("LQ: IP of host is " + clientIP.getIp4Address());
        MacAddress nextHopMac = record.nextHop().orElse(null);
        log.debug("LQ: MAC of resulting *OLD* NH for that host is " + nextHopMac.toString());
        // find the new NH by looking at the src MAC of the dhcp request
        // from the LQ store
        MacAddress newNextHopMac = record.nextHopTemp().orElse(null);
        log.debug("LQ: MAC of resulting *NEW* NH for that host is " + newNextHopMac.toString());
        log.debug("LQ: updating dhcp relay record with new NH");
        record.nextHop(newNextHopMac);
        // find the next hop IP from its mac
        HostId gwHostId = HostId.hostId(newNextHopMac, vlanId);
        Host gwHost = hostService.getHost(gwHostId);
        if (gwHost == null) {
            log.warn("Can't find gateway for new NH host " + gwHostId);
            return;
        }
        Ip4Address nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
        if (nextHopIp == null) {
            log.warn("Can't find IP address of gateway " + gwHost);
            return;
        }
        log.debug("LQ: *NEW* NH IP for host is " + nextHopIp.getIp4Address());
        Route route = new Route(Route.Source.DHCP, clientIP.toIpPrefix(), nextHopIp);
        routeStore.updateRoute(route);
    }
    // and forward to client
    InternalPacket ethernetPacket = processLeaseQueryFromServer(packet);
    if (ethernetPacket != null) {
        sendResponseToClient(ethernetPacket, dhcpPayload);
    }
}
#end_block

#method_before
private void handleLeaseQueryUnknown(Ethernet packet, DHCP dhcpPayload) {
    log.debug("Lease Query for Client results in DHCPLEASEUNASSIGNED or " + "DHCPLEASEUNKNOWN - removing route & forwarding reply to originator");
    if (learnRouteFromLeasequery) {
        MacAddress clientMacAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
        VlanId vlanId = VlanId.vlanId(packet.getVlanID());
        HostId hostId = HostId.hostId(clientMacAddress, vlanId);
        DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
        if (record == null) {
            log.warn("Can't find record for host {} when handling LQ UNKNOWN/UNASSIGNED message", hostId);
            return;
        }
        Ip4Address clientIP = record.ip4Address().orElse(null);
        log.debug("LQ: IP of host is " + clientIP.getIp4Address());
        // find the new NH by looking at the src MAC of the dhcp request
        // from the LQ store
        MacAddress nextHopMac = record.nextHop().orElse(null);
        log.debug("LQ: MAC of resulting *Existing* NH for that route is " + nextHopMac.toString());
        // find the next hop IP from its mac
        HostId gwHostId = HostId.hostId(nextHopMac, vlanId);
        Host gwHost = hostService.getHost(gwHostId);
        if (gwHost == null) {
            log.warn("Can't find gateway for new NH host " + gwHostId);
            return;
        }
        Ip4Address nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
        if (nextHopIp == null) {
            log.warn("Can't find IP address of gateway {}", gwHost);
            return;
        }
        log.debug("LQ: *Existing* NH IP for host is " + nextHopIp.getIp4Address() + " removing route for it");
        Route route = new Route(Route.Source.STATIC, clientIP.toIpPrefix(), nextHopIp);
        routeStore.removeRoute(route);
        // remove from temp store
        dhcpRelayStore.removeDhcpRecord(hostId);
    }
    // and forward to client
    InternalPacket ethernetPacket = processLeaseQueryFromServer(packet);
    if (ethernetPacket != null) {
        sendResponseToClient(ethernetPacket, dhcpPayload);
    }
}
#method_after
private void handleLeaseQueryUnknown(Ethernet packet, DHCP dhcpPayload) {
    log.debug("Lease Query for Client results in DHCPLEASEUNASSIGNED or " + "DHCPLEASEUNKNOWN - removing route & forwarding reply to originator");
    if (learnRouteFromLeasequery) {
        MacAddress clientMacAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
        VlanId vlanId = VlanId.vlanId(packet.getVlanID());
        HostId hostId = HostId.hostId(clientMacAddress, vlanId);
        DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
        if (record == null) {
            log.warn("Can't find record for host {} when handling LQ UNKNOWN/UNASSIGNED message", hostId);
            return;
        }
        Ip4Address clientIP = record.ip4Address().orElse(null);
        log.debug("LQ: IP of host is " + clientIP.getIp4Address());
        // find the new NH by looking at the src MAC of the dhcp request
        // from the LQ store
        MacAddress nextHopMac = record.nextHop().orElse(null);
        log.debug("LQ: MAC of resulting *Existing* NH for that route is " + nextHopMac.toString());
        // find the next hop IP from its mac
        HostId gwHostId = HostId.hostId(nextHopMac, vlanId);
        Host gwHost = hostService.getHost(gwHostId);
        if (gwHost == null) {
            log.warn("Can't find gateway for new NH host " + gwHostId);
            return;
        }
        Ip4Address nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
        if (nextHopIp == null) {
            log.warn("Can't find IP address of gateway {}", gwHost);
            return;
        }
        log.debug("LQ: *Existing* NH IP for host is " + nextHopIp.getIp4Address() + " removing route for it");
        Route route = new Route(Route.Source.DHCP, clientIP.toIpPrefix(), nextHopIp);
        routeStore.removeRoute(route);
        // remove from temp store
        dhcpRelayStore.removeDhcpRecord(hostId);
    }
    // and forward to client
    InternalPacket ethernetPacket = processLeaseQueryFromServer(packet);
    if (ethernetPacket != null) {
        sendResponseToClient(ethernetPacket, dhcpPayload);
    }
}
#end_block

#method_before
private List<InternalPacket> processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip4Address relayAgentIp = null;
    relayAgentIp = Dhcp4HandlerUtil.getRelayAgentIPv4Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv4 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    log.debug("Multi DHCP V4 processDhcpPacketFromClient on port {}", clientInterfaces.iterator().next().connectPoint());
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return null;
    }
    boolean isDirectlyConnected = directlyConnected(dhcpPacket);
    boolean directConnFlag = directlyConnected(dhcpPacket);
    // Multi DHCP Start
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(ethernetPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> Dhcp4HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        etherReply = (Ethernet) ethernetPacket.clone();
        ipv4Packet = (IPv4) etherReply.getPayload();
        udpPacket = (UDP) ipv4Packet.getPayload();
        dhcpPacket = (DHCP) udpPacket.getPayload();
        if (!checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
        MacAddress macFacingServer = serverInterface.mac();
        log.debug("Interfacing server {} Mac : {} ", ipFacingServer, macFacingServer);
        if (ipFacingServer == null || macFacingServer == null) {
            log.warn("No IP address for server Interface {}", serverInterface);
            // return null;
            continue;
        }
        etherReply.setSourceMACAddress(macFacingServer);
        // set default info and replace with indirect if available later on.
        if (newServerInfo.getDhcpConnectMac().isPresent()) {
            etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
        }
        if (newServerInfo.getDhcpConnectVlan().isPresent()) {
            etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
        }
        ipv4Packet.setSourceAddress(ipFacingServer.toInt());
        ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
        log.debug("Directly connected {}", isDirectlyConnected);
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp4().get());
        if (isDirectlyConnected) {
            log.debug("Default DHCP server IP: {}", newServerInfo.getDhcpServerIp4().get());
            if (newServerInfo.getDhcpConnectMac().isPresent()) {
                etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
            }
            if (newServerInfo.getDhcpConnectVlan().isPresent()) {
                etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
            }
            ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
            ConnectPoint inPort = context.inPacket().receivedFrom();
            VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
            // add connected in port and vlan
            CircuitId cid = new CircuitId(inPort.toString(), vlanId);
            byte[] circuitId = cid.serialize();
            DhcpOption circuitIdSubOpt = new DhcpOption();
            circuitIdSubOpt.setCode(CIRCUIT_ID.getValue()).setLength((byte) circuitId.length).setData(circuitId);
            DhcpRelayAgentOption newRelayAgentOpt = new DhcpRelayAgentOption();
            newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
            newRelayAgentOpt.addSubOption(circuitIdSubOpt);
            // Removes END option first
            List<DhcpOption> options = dhcpPacket.getOptions().stream().filter(opt -> opt.getCode() != OptionCode_END.getValue()).collect(Collectors.toList());
            // push relay agent option
            options.add(newRelayAgentOpt);
            // make sure option 255(End) is the last option
            DhcpOption endOption = new DhcpOption();
            endOption.setCode(OptionCode_END.getValue());
            options.add(endOption);
            dhcpPacket.setOptions(options);
            relayAgentIp = serverInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
            // Sets relay agent IP
            int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
            dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            log.debug("In Default, Relay Agent IP {}", effectiveRelayAgentIp);
        } else {
            if (!newServerInfo.getDhcpServerIp4().isPresent()) {
            // do nothing
            } else if (!newServerInfo.getDhcpConnectMac().isPresent()) {
                continue;
            } else {
                relayAgentIp = newServerInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
                // Sets relay agent IP
                int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
                dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            }
        }
        // Remove broadcast flag
        dhcpPacket.setFlags((short) 0);
        udpPacket.setPayload(dhcpPacket);
        // As a DHCP relay, the source port should be server port( instead
        // of client port.
        udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
        udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
        ipv4Packet.setPayload(udpPacket);
        ipv4Packet.setTtl((byte) 64);
        etherReply.setPayload(ipv4Packet);
        InternalPacket internalPacket = Dhcp4HandlerUtil.internalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    return internalPackets;
}
#method_after
private List<InternalPacket> processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip4Address relayAgentIp = null;
    relayAgentIp = Dhcp4HandlerUtil.getRelayAgentIPv4Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv4 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return Lists.newArrayList();
    }
    log.debug("Multi DHCP V4 processDhcpPacketFromClient on port {}", clientInterfaces.iterator().next().connectPoint());
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return Lists.newArrayList();
    }
    boolean isDirectlyConnected = directlyConnected(dhcpPacket);
    boolean directConnFlag = directlyConnected(dhcpPacket);
    // Multi DHCP Start
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(ethernetPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> Dhcp4HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        etherReply = (Ethernet) ethernetPacket.clone();
        ipv4Packet = (IPv4) etherReply.getPayload();
        udpPacket = (UDP) ipv4Packet.getPayload();
        dhcpPacket = (DHCP) udpPacket.getPayload();
        if (!checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
        MacAddress macFacingServer = serverInterface.mac();
        log.debug("Interfacing server {} Mac : {} ", ipFacingServer, macFacingServer);
        if (ipFacingServer == null || macFacingServer == null) {
            log.warn("No IP address for server Interface {}", serverInterface);
            continue;
        }
        etherReply.setSourceMACAddress(macFacingServer);
        // set default info and replace with indirect if available later on.
        if (newServerInfo.getDhcpConnectMac().isPresent()) {
            etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
        }
        if (newServerInfo.getDhcpConnectVlan().isPresent()) {
            etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
        }
        ipv4Packet.setSourceAddress(ipFacingServer.toInt());
        ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
        log.debug("Directly connected {}", isDirectlyConnected);
        log.debug("DHCP server IP: {}", newServerInfo.getDhcpServerIp4().get());
        if (isDirectlyConnected) {
            log.debug("Default DHCP server IP: {}", newServerInfo.getDhcpServerIp4().get());
            if (newServerInfo.getDhcpConnectMac().isPresent()) {
                etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
            }
            if (newServerInfo.getDhcpConnectVlan().isPresent()) {
                etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
            }
            ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
            ConnectPoint inPort = context.inPacket().receivedFrom();
            VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
            // add connected in port and vlan
            CircuitId cid = new CircuitId(inPort.toString(), vlanId);
            byte[] circuitId = cid.serialize();
            DhcpOption circuitIdSubOpt = new DhcpOption();
            circuitIdSubOpt.setCode(CIRCUIT_ID.getValue()).setLength((byte) circuitId.length).setData(circuitId);
            DhcpRelayAgentOption newRelayAgentOpt = new DhcpRelayAgentOption();
            newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
            newRelayAgentOpt.addSubOption(circuitIdSubOpt);
            // Removes END option first
            List<DhcpOption> options = dhcpPacket.getOptions().stream().filter(opt -> opt.getCode() != OptionCode_END.getValue()).collect(Collectors.toList());
            // push relay agent option
            options.add(newRelayAgentOpt);
            // make sure option 255(End) is the last option
            DhcpOption endOption = new DhcpOption();
            endOption.setCode(OptionCode_END.getValue());
            options.add(endOption);
            dhcpPacket.setOptions(options);
            relayAgentIp = serverInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
            // Sets relay agent IP
            int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
            dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            log.debug("In Default, Relay Agent IP {}", effectiveRelayAgentIp);
        } else {
            if (!newServerInfo.getDhcpServerIp4().isPresent()) {
            // do nothing
            } else if (!newServerInfo.getDhcpConnectMac().isPresent()) {
                continue;
            } else {
                relayAgentIp = newServerInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
                // Sets relay agent IP
                int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
                dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            }
        }
        // Remove broadcast flag
        dhcpPacket.setFlags((short) 0);
        udpPacket.setPayload(dhcpPacket);
        // As a DHCP relay, the source port should be server port( instead
        // of client port.
        udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
        udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
        ipv4Packet.setPayload(udpPacket);
        ipv4Packet.setTtl((byte) 64);
        etherReply.setPayload(ipv4Packet);
        InternalPacket internalPacket = InternalPacket.internalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    return internalPackets;
}
#end_block

#method_before
private List<InternalPacket> processLeaseQueryFromAgent(PacketContext context, Ethernet ethernetPacket) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    Ip4Address relayAgentIp;
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return null;
    }
    boolean isDirectlyConnected = directlyConnected(dhcpPacket);
    boolean directConnFlag = directlyConnected(dhcpPacket);
    // Multi DHCP Start
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        // get dhcp header.
        etherReply = (Ethernet) ethernetPacket.clone();
        ipv4Packet = (IPv4) etherReply.getPayload();
        udpPacket = (UDP) ipv4Packet.getPayload();
        dhcpPacket = (DHCP) udpPacket.getPayload();
        if (!checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
        MacAddress macFacingServer = serverInterface.mac();
        if (ipFacingServer == null || macFacingServer == null) {
            log.warn("No IP address for server Interface {}", serverInterface);
            continue;
        }
        etherReply.setSourceMACAddress(macFacingServer);
        etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
        etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
        ipv4Packet.setSourceAddress(ipFacingServer.toInt());
        ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
        if (isDirectlyConnected) {
            // set default info and replace with indirect if available later on.
            if (newServerInfo.getDhcpConnectMac().isPresent()) {
                etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
            }
            if (newServerInfo.getDhcpConnectVlan().isPresent()) {
                etherReply.setVlanID(serverInfo.getDhcpConnectVlan().get().toShort());
            }
            if (learnRouteFromLeasequery) {
                relayAgentIp = newServerInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
                // Sets relay agent IP
                int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
                dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            }
        } else {
            if (!newServerInfo.getDhcpServerIp4().isPresent()) {
            // do nothing
            } else if (!newServerInfo.getDhcpConnectMac().isPresent()) {
                continue;
            } else if (learnRouteFromLeasequery) {
                relayAgentIp = newServerInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
                // Sets relay agent IP
                int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
                dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
                log.debug("Relay Agent IP {}", relayAgentIp);
            }
            log.trace("Indirect");
        }
        // Remove broadcast flag
        dhcpPacket.setFlags((short) 0);
        udpPacket.setPayload(dhcpPacket);
        // As a DHCP relay, the source port should be server port( instead
        // of client port.
        udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
        udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
        ipv4Packet.setPayload(udpPacket);
        ipv4Packet.setTtl((byte) 64);
        etherReply.setPayload(ipv4Packet);
        udpPacket.resetChecksum();
        // //return etherReply;
        Dhcp4HandlerUtil.InternalPacket internalPacket = Dhcp4HandlerUtil.internalPacket(etherReply, newServerInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.debug("num of processLeaseQueryFromAgent packets to send is: {}", internalPackets.size());
    return internalPackets;
}
#method_after
private List<InternalPacket> processLeaseQueryFromAgent(PacketContext context, Ethernet ethernetPacket) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    Ip4Address relayAgentIp;
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return null;
    }
    boolean isDirectlyConnected = directlyConnected(dhcpPacket);
    boolean directConnFlag = directlyConnected(dhcpPacket);
    // Multi DHCP Start
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        // get dhcp header.
        etherReply = (Ethernet) ethernetPacket.clone();
        ipv4Packet = (IPv4) etherReply.getPayload();
        udpPacket = (UDP) ipv4Packet.getPayload();
        dhcpPacket = (DHCP) udpPacket.getPayload();
        if (!checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
        MacAddress macFacingServer = serverInterface.mac();
        if (ipFacingServer == null || macFacingServer == null) {
            log.warn("No IP address for server Interface {}", serverInterface);
            continue;
        }
        etherReply.setSourceMACAddress(macFacingServer);
        etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
        etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
        ipv4Packet.setSourceAddress(ipFacingServer.toInt());
        ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
        if (isDirectlyConnected) {
            // set default info and replace with indirect if available later on.
            if (newServerInfo.getDhcpConnectMac().isPresent()) {
                etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
            }
            if (newServerInfo.getDhcpConnectVlan().isPresent()) {
                etherReply.setVlanID(serverInfo.getDhcpConnectVlan().get().toShort());
            }
            if (learnRouteFromLeasequery) {
                relayAgentIp = newServerInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
                // Sets relay agent IP
                int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
                dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            }
        } else {
            if (!newServerInfo.getDhcpServerIp4().isPresent()) {
            // do nothing
            } else if (!newServerInfo.getDhcpConnectMac().isPresent()) {
                continue;
            } else if (learnRouteFromLeasequery) {
                relayAgentIp = newServerInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
                // Sets relay agent IP
                int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
                dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
                log.debug("Relay Agent IP {}", relayAgentIp);
            }
            log.trace("Indirect");
        }
        // Remove broadcast flag
        dhcpPacket.setFlags((short) 0);
        udpPacket.setPayload(dhcpPacket);
        // As a DHCP relay, the source port should be server port( instead
        // of client port.
        udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
        udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
        ipv4Packet.setPayload(udpPacket);
        ipv4Packet.setTtl((byte) 64);
        etherReply.setPayload(ipv4Packet);
        udpPacket.resetChecksum();
        // //return etherReply;
        InternalPacket internalPacket = InternalPacket.internalPacket(etherReply, newServerInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.debug("num of processLeaseQueryFromAgent packets to send is: {}", internalPackets.size());
    return internalPackets;
}
#end_block

#method_before
private InternalPacket processDhcpPacketFromServer(PacketContext context, Ethernet ethernetPacket) {
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
    // determine the vlanId of the client host - note that this vlan id
    // could be different from the vlan in the packet from the server
    Interface clientInterface = getClientInterface(ethernetPacket, dhcpPayload).orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot find the interface for the DHCP {}", dhcpPayload);
        return null;
    }
    VlanId vlanId;
    ConnectPoint inPort = context.inPacket().receivedFrom();
    boolean directConnFlag = directlyConnected(dhcpPayload);
    DhcpServerInfo foundServerInfo = findServerInfoFromServer(directConnFlag, inPort);
    if (foundServerInfo == null) {
        log.warn("Cannot find server info");
        return null;
    } else {
        if (Dhcp4HandlerUtil.isServerIpEmpty(foundServerInfo)) {
            log.warn("Cannot find server info's ipaddress");
            return null;
        }
    }
    if (clientInterface.vlanTagged().isEmpty()) {
        vlanId = clientInterface.vlan();
    } else {
        // might be multiple vlan in same interface
        vlanId = getVlanIdFromRelayAgentOption(dhcpPayload);
    }
    if (vlanId == null) {
        vlanId = VlanId.NONE;
    }
    etherReply.setVlanID(vlanId.toShort());
    etherReply.setSourceMACAddress(clientInterface.mac());
    if (!directlyConnected(dhcpPayload)) {
        // if client is indirectly connected, try use next hop mac address
        MacAddress macAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
        HostId hostId = HostId.hostId(macAddress, vlanId);
        if (((int) dhcpPayload.getFlags() & 0x8000) == 0x0000) {
            DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
            if (record != null) {
                // if next hop can be found, use mac address of next hop
                record.nextHop().ifPresent(etherReply::setDestinationMACAddress);
            } else {
                // otherwise, discard the packet
                log.warn("Can't find record for host id {}, discard packet", hostId);
                return null;
            }
        } else {
            etherReply.setDestinationMACAddress(MacAddress.BROADCAST);
        }
    } else {
        etherReply.setDestinationMACAddress(dhcpPayload.getClientHardwareAddress());
    }
    // we leave the srcMac from the original packet
    // figure out the relay agent IP corresponding to the original request
    Ip4Address ipFacingClient = getFirstIpFromInterface(clientInterface);
    if (ipFacingClient == null) {
        log.warn("Cannot determine relay agent interface Ipv4 addr for host {}/{}. " + "Aborting relay for dhcp packet from server {}", etherReply.getDestinationMAC(), clientInterface.vlan(), ethernetPacket);
        return null;
    }
    // SRC_IP: relay agent IP
    // DST_IP: offered IP
    ipv4Packet.setSourceAddress(ipFacingClient.toInt());
    if (((int) dhcpPayload.getFlags() & 0x8000) == 0x0000) {
        ipv4Packet.setDestinationAddress(dhcpPayload.getYourIPAddress());
    } else {
        ipv4Packet.setDestinationAddress(BROADCAST_IP);
    }
    udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
    if (directlyConnected(dhcpPayload)) {
        udpPacket.setDestinationPort(UDP.DHCP_CLIENT_PORT);
    } else {
        // forward to another dhcp relay
        // FIXME: Currently we assume the DHCP comes from a L2 relay with
        // Option 82, this might not work if DHCP message comes from
        // L3 relay.
        udpPacket.setDestinationPort(UDP.DHCP_CLIENT_PORT);
    }
    udpPacket.setPayload(dhcpPayload);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return Dhcp4HandlerUtil.internalPacket(etherReply, clientInterface.connectPoint());
}
#method_after
private InternalPacket processDhcpPacketFromServer(PacketContext context, Ethernet ethernetPacket) {
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
    // determine the vlanId of the client host - note that this vlan id
    // could be different from the vlan in the packet from the server
    Interface clientInterface = getClientInterface(ethernetPacket, dhcpPayload).orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot find the interface for the DHCP {}", dhcpPayload);
        return null;
    }
    VlanId vlanId;
    ConnectPoint inPort = context.inPacket().receivedFrom();
    boolean directConnFlag = directlyConnected(dhcpPayload);
    DhcpServerInfo foundServerInfo = findServerInfoFromServer(directConnFlag, inPort);
    if (foundServerInfo == null) {
        log.warn("Cannot find server info");
        return null;
    } else {
        if (Dhcp4HandlerUtil.isServerIpEmpty(foundServerInfo)) {
            log.warn("Cannot find server info's ipaddress");
            return null;
        }
    }
    if (clientInterface.vlanTagged().isEmpty()) {
        vlanId = clientInterface.vlan();
    } else {
        // might be multiple vlan in same interface
        vlanId = getVlanIdFromRelayAgentOption(dhcpPayload);
    }
    if (vlanId == null) {
        vlanId = VlanId.NONE;
    }
    etherReply.setVlanID(vlanId.toShort());
    etherReply.setSourceMACAddress(clientInterface.mac());
    if (!directlyConnected(dhcpPayload)) {
        // if client is indirectly connected, try use next hop mac address
        MacAddress macAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
        HostId hostId = HostId.hostId(macAddress, vlanId);
        if (((int) dhcpPayload.getFlags() & 0x8000) == 0x0000) {
            DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
            if (record != null) {
                // if next hop can be found, use mac address of next hop
                record.nextHop().ifPresent(etherReply::setDestinationMACAddress);
            } else {
                // otherwise, discard the packet
                log.warn("Can't find record for host id {}, discard packet", hostId);
                return null;
            }
        } else {
            etherReply.setDestinationMACAddress(MacAddress.BROADCAST);
        }
    } else {
        etherReply.setDestinationMACAddress(dhcpPayload.getClientHardwareAddress());
    }
    // we leave the srcMac from the original packet
    // figure out the relay agent IP corresponding to the original request
    Ip4Address ipFacingClient = getFirstIpFromInterface(clientInterface);
    if (ipFacingClient == null) {
        log.warn("Cannot determine relay agent interface Ipv4 addr for host {}/{}. " + "Aborting relay for dhcp packet from server {}", etherReply.getDestinationMAC(), clientInterface.vlan(), ethernetPacket);
        return null;
    }
    // SRC_IP: relay agent IP
    // DST_IP: offered IP
    ipv4Packet.setSourceAddress(ipFacingClient.toInt());
    if (((int) dhcpPayload.getFlags() & 0x8000) == 0x0000) {
        ipv4Packet.setDestinationAddress(dhcpPayload.getYourIPAddress());
    } else {
        ipv4Packet.setDestinationAddress(BROADCAST_IP);
    }
    udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
    if (directlyConnected(dhcpPayload)) {
        udpPacket.setDestinationPort(UDP.DHCP_CLIENT_PORT);
    } else {
        // forward to another dhcp relay
        // FIXME: Currently we assume the DHCP comes from a L2 relay with
        // Option 82, this might not work if DHCP message comes from
        // L3 relay.
        udpPacket.setDestinationPort(UDP.DHCP_CLIENT_PORT);
    }
    udpPacket.setPayload(dhcpPayload);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return InternalPacket.internalPacket(etherReply, clientInterface.connectPoint());
}
#end_block

#method_before
private InternalPacket processLeaseQueryFromServer(Ethernet ethernetPacket) {
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
    // determine the vlanId of the client host - note that this vlan id
    // could be different from the vlan in the packet from the server
    Interface clientInterface = null;
    MacAddress destinationMac = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
    if (!learnRouteFromLeasequery) {
        int giaddr = ipv4Packet.getDestinationAddress();
        IpAddress destinationAddress = Ip4Address.valueOf(giaddr);
        log.debug("DHCPLEASEQUERYRESP giaddr: {}({})", giaddr, destinationAddress);
        Host destinationHost = hostService.getHostsByIp(destinationAddress).stream().findFirst().orElse(null);
        if (destinationHost != null) {
            destinationMac = destinationHost.mac();
            log.trace("DHCPLEASEQUERYRESP destination mac is: {}", destinationMac);
            ConnectPoint destinationLocation = destinationHost.location();
            log.trace("Lookup for client interface by destination location {}", destinationLocation);
            clientInterface = interfaceService.getInterfacesByPort(destinationLocation).stream().filter(iface -> interfaceContainsVlan(iface, VlanId.vlanId(etherReply.getVlanID()))).findFirst().orElse(null);
            log.trace("Found Host {} by ip {}", destinationHost, destinationAddress);
            log.debug("DHCPLEASEQUERYRESP Client interface: {}", (clientInterface != null ? clientInterface : "not resolved"));
        }
    } else {
        clientInterface = getClientInterface(ethernetPacket, dhcpPayload).orElse(null);
    }
    if (clientInterface == null) {
        log.warn("Cannot find the interface for the DHCP {}", dhcpPayload);
        return null;
    }
    VlanId vlanId;
    if (clientInterface.vlanTagged().isEmpty()) {
        vlanId = clientInterface.vlan();
    } else {
        // might be multiple vlan in same interface
        vlanId = getVlanIdFromRelayAgentOption(dhcpPayload);
    }
    if (vlanId == null) {
        vlanId = VlanId.NONE;
    }
    etherReply.setVlanID(vlanId.toShort());
    etherReply.setSourceMACAddress(clientInterface.mac());
    if (!directlyConnected(dhcpPayload) && learnRouteFromLeasequery) {
        // if client is indirectly connected, try use next hop mac address
        MacAddress macAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
        HostId hostId = HostId.hostId(macAddress, vlanId);
        DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
        if (record != null) {
            // if next hop can be found, use mac address of next hop
            Optional<MacAddress> nextHop = record.nextHopTemp();
            if (!nextHop.isPresent()) {
                nextHop = record.nextHop();
            }
            nextHop.ifPresent(etherReply::setDestinationMACAddress);
        } else {
            // otherwise, discard the packet
            log.warn("Can't find record for host id {}, discard packet", hostId);
            return null;
        }
    } else {
        etherReply.setDestinationMACAddress(destinationMac);
    }
    // default is client port
    udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
    udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
    udpPacket.setPayload(dhcpPayload);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    udpPacket.resetChecksum();
    return Dhcp4HandlerUtil.internalPacket(etherReply, clientInterface.connectPoint());
}
#method_after
private InternalPacket processLeaseQueryFromServer(Ethernet ethernetPacket) {
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
    // determine the vlanId of the client host - note that this vlan id
    // could be different from the vlan in the packet from the server
    Interface clientInterface = null;
    MacAddress destinationMac = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
    if (!learnRouteFromLeasequery) {
        int giaddr = ipv4Packet.getDestinationAddress();
        IpAddress destinationAddress = Ip4Address.valueOf(giaddr);
        log.debug("DHCPLEASEQUERYRESP giaddr: {}({})", giaddr, destinationAddress);
        Host destinationHost = hostService.getHostsByIp(destinationAddress).stream().findFirst().orElse(null);
        if (destinationHost != null) {
            destinationMac = destinationHost.mac();
            log.trace("DHCPLEASEQUERYRESP destination mac is: {}", destinationMac);
            ConnectPoint destinationLocation = destinationHost.location();
            log.trace("Lookup for client interface by destination location {}", destinationLocation);
            clientInterface = interfaceService.getInterfacesByPort(destinationLocation).stream().filter(iface -> interfaceContainsVlan(iface, VlanId.vlanId(etherReply.getVlanID()))).findFirst().orElse(null);
            log.trace("Found Host {} by ip {}", destinationHost, destinationAddress);
            log.debug("DHCPLEASEQUERYRESP Client interface: {}", (clientInterface != null ? clientInterface : "not resolved"));
        }
    } else {
        clientInterface = getClientInterface(ethernetPacket, dhcpPayload).orElse(null);
    }
    if (clientInterface == null) {
        log.warn("Cannot find the interface for the DHCP {}", dhcpPayload);
        return null;
    }
    VlanId vlanId;
    if (clientInterface.vlanTagged().isEmpty()) {
        vlanId = clientInterface.vlan();
    } else {
        // might be multiple vlan in same interface
        vlanId = getVlanIdFromRelayAgentOption(dhcpPayload);
    }
    if (vlanId == null) {
        vlanId = VlanId.NONE;
    }
    etherReply.setVlanID(vlanId.toShort());
    etherReply.setSourceMACAddress(clientInterface.mac());
    if (!directlyConnected(dhcpPayload) && learnRouteFromLeasequery) {
        // if client is indirectly connected, try use next hop mac address
        MacAddress macAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
        HostId hostId = HostId.hostId(macAddress, vlanId);
        DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
        if (record != null) {
            // if next hop can be found, use mac address of next hop
            Optional<MacAddress> nextHop = record.nextHopTemp();
            if (!nextHop.isPresent()) {
                nextHop = record.nextHop();
            }
            nextHop.ifPresent(etherReply::setDestinationMACAddress);
        } else {
            // otherwise, discard the packet
            log.warn("Can't find record for host id {}, discard packet", hostId);
            return null;
        }
    } else {
        etherReply.setDestinationMACAddress(destinationMac);
    }
    udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
    if (directlyConnected(dhcpPayload)) {
        udpPacket.setDestinationPort(UDP.DHCP_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
    }
    udpPacket.setPayload(dhcpPayload);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    udpPacket.resetChecksum();
    return InternalPacket.internalPacket(etherReply, clientInterface.connectPoint());
}
#end_block

#method_before
private void handleDhcpAck(Ethernet ethernetPacketAck, DHCP dhcpPayload) {
    Optional<Interface> outInterface = getClientInterface(ethernetPacketAck, dhcpPayload);
    if (!outInterface.isPresent()) {
        log.warn("Can't find output interface for dhcp: {}", dhcpPayload);
        return;
    }
    Interface outIface = outInterface.get();
    HostLocation hostLocation = new HostLocation(outIface.connectPoint(), System.currentTimeMillis());
    MacAddress macAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
    VlanId vlanId = getVlanIdFromRelayAgentOption(dhcpPayload);
    if (vlanId == null) {
        vlanId = outIface.vlan();
    }
    HostId hostId = HostId.hostId(macAddress, vlanId);
    Ip4Address ip = Ip4Address.valueOf(dhcpPayload.getYourIPAddress());
    if (directlyConnected(dhcpPayload)) {
        // Add to host store if it connect to network directly
        Set<IpAddress> ips = Sets.newHashSet(ip);
        Host host = hostService.getHost(hostId);
        Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
        if (host != null) {
            // Dual homing support:
            // if host exists, use old locations and new location
            hostLocations.addAll(host.locations());
        }
        HostDescription desc = new DefaultHostDescription(macAddress, vlanId, hostLocations, ips, false);
        // Add IP address when dhcp server give the host new ip address
        providerService.hostDetected(hostId, desc, false);
    } else {
        // Add to route store if it does not connect to network directly
        // Get gateway host IP according to host mac address
        // TODO: remove relay store here
        DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
        if (record == null) {
            log.warn("Can't find DHCP record of host {}", hostId);
            return;
        }
        MacAddress gwMac = record.nextHop().orElse(null);
        if (gwMac == null) {
            log.warn("Can't find gateway mac address from record {}", record);
            return;
        }
        HostId gwHostId = HostId.hostId(gwMac, record.vlanId());
        Host gwHost = hostService.getHost(gwHostId);
        if (gwHost == null) {
            log.warn("Can't find gateway host {}", gwHostId);
            return;
        }
        Ip4Address nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
        if (nextHopIp == null) {
            log.warn("Can't find IP address of gateway {}", gwHost);
            return;
        }
        Route route = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
        routeStore.updateRoute(route);
    }
}
#method_after
private void handleDhcpAck(Ethernet ethernetPacketAck, DHCP dhcpPayload) {
    Optional<Interface> outInterface = getClientInterface(ethernetPacketAck, dhcpPayload);
    if (!outInterface.isPresent()) {
        log.warn("Can't find output interface for dhcp: {}", dhcpPayload);
        return;
    }
    Interface outIface = outInterface.get();
    HostLocation hostLocation = new HostLocation(outIface.connectPoint(), System.currentTimeMillis());
    MacAddress macAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
    VlanId vlanId = getVlanIdFromRelayAgentOption(dhcpPayload);
    if (vlanId == null) {
        vlanId = outIface.vlan();
    }
    HostId hostId = HostId.hostId(macAddress, vlanId);
    Ip4Address ip = Ip4Address.valueOf(dhcpPayload.getYourIPAddress());
    if (directlyConnected(dhcpPayload)) {
        // Add to host store if it connect to network directly
        Set<IpAddress> ips = Sets.newHashSet(ip);
        Host host = hostService.getHost(hostId);
        Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
        if (host != null) {
            // Dual homing support:
            // if host exists, use old locations and new location
            hostLocations.addAll(host.locations());
        }
        HostDescription desc = new DefaultHostDescription(macAddress, vlanId, hostLocations, ips, false);
        // Add IP address when dhcp server give the host new ip address
        providerService.hostDetected(hostId, desc, false);
    } else {
        // Add to route store if it does not connect to network directly
        // Get gateway host IP according to host mac address
        // TODO: remove relay store here
        DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
        if (record == null) {
            log.warn("Can't find DHCP record of host {}", hostId);
            return;
        }
        MacAddress gwMac = record.nextHop().orElse(null);
        if (gwMac == null) {
            log.warn("Can't find gateway mac address from record {}", record);
            return;
        }
        HostId gwHostId = HostId.hostId(gwMac, record.vlanId());
        Host gwHost = hostService.getHost(gwHostId);
        if (gwHost == null) {
            log.warn("Can't find gateway host {}", gwHostId);
            return;
        }
        Ip4Address nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
        if (nextHopIp == null) {
            log.warn("Can't find IP address of gateway {}", gwHost);
            return;
        }
        Route route = new Route(Route.Source.DHCP, ip.toIpPrefix(), nextHopIp);
        routeStore.updateRoute(route);
    }
}
#end_block

#method_before
private void sendResponseToClient(InternalPacket thePacket, DHCP dhcpPayload) {
    Ethernet ethPacket = thePacket.getPacket();
    if (directlyConnected(dhcpPayload)) {
        ethPacket = removeRelayAgentOption(ethPacket);
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(thePacket.getDestLocation().port()).build();
    OutboundPacket o = new DefaultOutboundPacket(thePacket.getDestLocation().deviceId(), treatment, ByteBuffer.wrap(ethPacket.serialize()));
    if (log.isTraceEnabled()) {
        log.trace("Relaying packet to DHCP client {} via {}", ethPacket, thePacket.getDestLocation());
    }
    packetService.emit(o);
}
#method_after
private void sendResponseToClient(InternalPacket thePacket, DHCP dhcpPayload) {
    checkNotNull(thePacket, "Nothing to send");
    checkNotNull(thePacket.getPacket(), "Packet to send must not be empty");
    checkNotNull(thePacket.getDestLocation(), "Packet destination not be empty");
    Ethernet ethPacket = thePacket.getPacket();
    if (directlyConnected(dhcpPayload)) {
        ethPacket = removeRelayAgentOption(ethPacket);
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(thePacket.getDestLocation().port()).build();
    OutboundPacket o = new DefaultOutboundPacket(thePacket.getDestLocation().deviceId(), treatment, ByteBuffer.wrap(ethPacket.serialize()));
    if (log.isTraceEnabled()) {
        log.trace("Relaying packet to DHCP client {} via {}", ethPacket, thePacket.getDestLocation());
    }
    packetService.emit(o);
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    if (!configured()) {
        return;
    }
    switch(event.type()) {
        case HOST_ADDED:
        case HOST_UPDATED:
            hostUpdated(event.subject());
            break;
        case HOST_REMOVED:
            hostRemoved(event.subject());
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(HostEvent event) {
    if (!configured()) {
        return;
    }
    switch(event.type()) {
        case HOST_ADDED:
        case HOST_UPDATED:
            log.trace("Scheduled host event {}", event);
            hostEventExecutor.execute(() -> hostUpdated(event.subject()));
            break;
        case HOST_REMOVED:
            log.trace("Scheduled host event {}", event);
            hostEventExecutor.execute(() -> hostRemoved(event.subject()));
            break;
        default:
            break;
    }
}
#end_block

#method_before
protected void updateConfig(Config config) {
    if (config instanceof IndirectDhcpRelayConfig) {
        IndirectDhcpRelayConfig indirectConfig = (IndirectDhcpRelayConfig) config;
        v4Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
        v6Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        DefaultDhcpRelayConfig defaultConfig = (DefaultDhcpRelayConfig) config;
        v4Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
        v6Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
    }
    if (config instanceof IgnoreDhcpConfig) {
        v4Handler.updateIgnoreVlanConfig((IgnoreDhcpConfig) config);
        v6Handler.updateIgnoreVlanConfig((IgnoreDhcpConfig) config);
    }
    if (config instanceof GeneralAppConfig) {
        v4Handler.updateGeneralAppConfig((GeneralAppConfig) config);
        v6Handler.updateGeneralAppConfig((GeneralAppConfig) config);
    }
}
#method_after
protected void updateConfig(Config config) {
    if (config instanceof IndirectDhcpRelayConfig) {
        IndirectDhcpRelayConfig indirectConfig = (IndirectDhcpRelayConfig) config;
        v4Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
        v6Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        DefaultDhcpRelayConfig defaultConfig = (DefaultDhcpRelayConfig) config;
        v4Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
        v6Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
    }
    if (config instanceof IgnoreDhcpConfig) {
        v4Handler.updateIgnoreVlanConfig((IgnoreDhcpConfig) config);
        v6Handler.updateIgnoreVlanConfig((IgnoreDhcpConfig) config);
    }
}
#end_block

#method_before
protected void removeConfig(Config config) {
    if (config instanceof IndirectDhcpRelayConfig) {
        v4Handler.setIndirectDhcpServerConfigs(Collections.emptyList());
        v6Handler.setIndirectDhcpServerConfigs(Collections.emptyList());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        v4Handler.setDefaultDhcpServerConfigs(Collections.emptyList());
        v6Handler.setDefaultDhcpServerConfigs(Collections.emptyList());
    }
    if (config instanceof IgnoreDhcpConfig) {
        v4Handler.updateIgnoreVlanConfig(null);
        v6Handler.updateIgnoreVlanConfig(null);
    }
    if (config instanceof GeneralAppConfig) {
        v4Handler.updateGeneralAppConfig(null);
        v6Handler.updateGeneralAppConfig(null);
    }
}
#method_after
protected void removeConfig(Config config) {
    if (config instanceof IndirectDhcpRelayConfig) {
        v4Handler.setIndirectDhcpServerConfigs(Collections.emptyList());
        v6Handler.setIndirectDhcpServerConfigs(Collections.emptyList());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        v4Handler.setDefaultDhcpServerConfigs(Collections.emptyList());
        v6Handler.setDefaultDhcpServerConfigs(Collections.emptyList());
    }
    if (config instanceof IgnoreDhcpConfig) {
        v4Handler.updateIgnoreVlanConfig(null);
        v6Handler.updateIgnoreVlanConfig(null);
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_UPDATED:
        case CONFIG_ADDED:
            event.config().ifPresent(config -> {
                updateConfig(config);
                log.info("{} updated", config.getClass().getSimpleName());
            });
            break;
        case CONFIG_REMOVED:
            event.prevConfig().ifPresent(config -> {
                removeConfig(config);
                log.info("{} removed", config.getClass().getSimpleName());
            });
            break;
        default:
            log.warn("Unsupported event type {}", event.type());
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_UPDATED:
        case CONFIG_ADDED:
            event.config().ifPresent(config -> {
                updateConfig(config);
                log.info("{} updated", config.getClass().getSimpleName());
            });
            break;
        case CONFIG_REMOVED:
            event.prevConfig().ifPresent(config -> {
                removeConfig(config);
                log.info("{} removed", config.getClass().getSimpleName());
            });
            break;
        case CONFIG_REGISTERED:
        case CONFIG_UNREGISTERED:
            break;
        default:
            log.warn("Unsupported event type {}", event.type());
            break;
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.configClass().equals(DefaultDhcpRelayConfig.class) || event.configClass().equals(IndirectDhcpRelayConfig.class) || event.configClass().equals(IgnoreDhcpConfig.class) || event.configClass().equals(GeneralAppConfig.class)) {
        return true;
    }
    log.debug("Ignore irrelevant event class {}", event.configClass().getName());
    return false;
}
#method_after
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.configClass().equals(DefaultDhcpRelayConfig.class) || event.configClass().equals(IndirectDhcpRelayConfig.class) || event.configClass().equals(IgnoreDhcpConfig.class)) {
        return true;
    }
    log.debug("Ignore irrelevant event class {}", event.configClass().getName());
    return false;
}
#end_block

#method_before
public static Deserializer<Dhcp6Option> deserializer() {
    return (data, offset, length) -> {
        Dhcp6Option dhcp6Option = Dhcp6Option.deserializer().deserialize(data, offset, length);
        Dhcp6LeaseQueryOption lQ6Option = new Dhcp6LeaseQueryOption(dhcp6Option);
        byte[] optionData = lQ6Option.getData();
        if (optionData.length >= 17) {
            // 61 is LQ option length + 4 header
            ByteBuffer bb = ByteBuffer.wrap(optionData);
            // fetch the Query type - just pop the byte from the byte buffer for subsequent parsing...
            lQ6Option.queryType = bb.get();
            byte[] ipv6Addr = new byte[16];
            bb.get(ipv6Addr);
            lQ6Option.linkAddress = Ip6Address.valueOf(ipv6Addr);
            // int optionsLen = dhcp6Option.getLength() - 1 - 16; // query type (1) + link address (16)
            lQ6Option.options = Lists.newArrayList();
            while (bb.remaining() >= Dhcp6Option.DEFAULT_LEN) {
                Dhcp6Option option;
                ByteBuffer optByteBuffer = ByteBuffer.wrap(optionData, bb.position(), optionData.length - bb.position());
                short code = optByteBuffer.getShort();
                short len = optByteBuffer.getShort();
                int optLen = UNSIGNED_SHORT_MASK & len;
                byte[] subOptData = new byte[Dhcp6Option.DEFAULT_LEN + optLen];
                bb.get(subOptData);
                // TODO: put more sub-options?
                if (code == DHCP6.OptionCode.IAADDR.value()) {
                    option = Dhcp6IaAddressOption.deserializer().deserialize(subOptData, 0, subOptData.length);
                } else if (code == DHCP6.OptionCode.ORO.value()) {
                    option = Dhcp6Option.deserializer().deserialize(subOptData, 0, subOptData.length);
                } else {
                    option = Dhcp6Option.deserializer().deserialize(subOptData, 0, subOptData.length);
                }
                lQ6Option.options.add(option);
            }
        }
        return lQ6Option;
    };
}
#method_after
public static Deserializer<Dhcp6Option> deserializer() {
    return (data, offset, length) -> {
        Dhcp6Option dhcp6Option = Dhcp6Option.deserializer().deserialize(data, offset, length);
        Dhcp6LeaseQueryOption lQ6Option = new Dhcp6LeaseQueryOption(dhcp6Option);
        byte[] optionData = lQ6Option.getData();
        if (optionData.length >= DEFAULT_LEN) {
            ByteBuffer bb = ByteBuffer.wrap(optionData);
            // fetch the Query type - just pop the byte from the byte buffer for subsequent parsing...
            lQ6Option.queryType = bb.get();
            byte[] ipv6Addr = new byte[16];
            bb.get(ipv6Addr);
            lQ6Option.linkAddress = Ip6Address.valueOf(ipv6Addr);
            // int optionsLen = dhcp6Option.getLength() - 1 - 16; // query type (1) + link address (16)
            lQ6Option.options = Lists.newArrayList();
            while (bb.remaining() >= Dhcp6Option.DEFAULT_LEN) {
                Dhcp6Option option;
                ByteBuffer optByteBuffer = ByteBuffer.wrap(optionData, bb.position(), optionData.length - bb.position());
                short code = optByteBuffer.getShort();
                short len = optByteBuffer.getShort();
                int optLen = UNSIGNED_SHORT_MASK & len;
                byte[] subOptData = new byte[Dhcp6Option.DEFAULT_LEN + optLen];
                bb.get(subOptData);
                // TODO: put more sub-options?
                if (code == DHCP6.OptionCode.IAADDR.value()) {
                    option = Dhcp6IaAddressOption.deserializer().deserialize(subOptData, 0, subOptData.length);
                } else if (code == DHCP6.OptionCode.ORO.value()) {
                    option = Dhcp6Option.deserializer().deserialize(subOptData, 0, subOptData.length);
                } else {
                    option = Dhcp6Option.deserializer().deserialize(subOptData, 0, subOptData.length);
                }
                lQ6Option.options.add(option);
            }
        }
        return lQ6Option;
    };
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(DHCP_V6_RELAY_APP);
    providerService = providerRegistry.register(this);
    hostService.addListener(hostListener);
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    modified(context);
    appId = coreService.registerApplication(DHCP_V6_RELAY_APP);
    providerService = providerRegistry.register(this);
    hostService.addListener(hostListener);
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    providerRegistry.unregister(this);
    hostService.removeListener(hostListener);
    defaultServerInfoList.forEach(this::stopMonitoringIps);
    defaultServerInfoList.clear();
    indirectServerInfoList.forEach(this::stopMonitoringIps);
    indirectServerInfoList.clear();
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    providerRegistry.unregister(this);
    hostService.removeListener(hostListener);
    defaultServerInfoList.forEach(this::stopMonitoringIps);
    defaultServerInfoList.clear();
    indirectServerInfoList.forEach(this::stopMonitoringIps);
    indirectServerInfoList.clear();
}
#end_block

#method_before
public void handleLeaseQuery6ReplyMsg(PacketContext context, DHCP6 dhcp6Payload) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    log.info("Got LQV6-REPLY on port {}", inPort);
    List<Dhcp6Option> lopt = dhcp6Payload.getOptions();
    log.info("Options list: {}", lopt);
    // find out if this lease is known is
    Dhcp6ClientDataOption clientDataOption = dhcp6Payload.getOptions().stream().filter(opt -> opt instanceof Dhcp6ClientDataOption).map(pld -> (Dhcp6ClientDataOption) pld).findFirst().orElse(null);
    if (clientDataOption == null) {
        log.warn("clientDataOption option is not present, " + "lease is UNKNOWN - not adding any new route...");
    } else {
        Dhcp6IaAddressOption aiAddressOption = clientDataOption.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(pld -> (Dhcp6IaAddressOption) pld).findFirst().orElse(null);
        Dhcp6ClientIdOption clientIdOption = clientDataOption.getOptions().stream().filter(opt -> opt instanceof Dhcp6ClientIdOption).map(pld -> (Dhcp6ClientIdOption) pld).findFirst().orElse(null);
        if (aiAddressOption == null) {
            log.warn("clientDataOption from DHCP server does not " + "contains Dhcp6IaAddressOption for the client - giving up...");
        } else {
            Ip6Address clientAddress = aiAddressOption.getIp6Address();
            MacAddress clientMacAddress = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
            Ethernet packet = context.inPacket().parsed();
            VlanId vlanId = VlanId.vlanId(packet.getVlanID());
            MacAddress potentialNextHopMac = findNextHopMacForIp6FromRelayStore(clientAddress, clientMacAddress, vlanId);
            if (potentialNextHopMac == null) {
                log.warn("Can't find next hop host mac for client {} mac:{}/{}", clientAddress, clientMacAddress, vlanId);
                return;
            } else {
                log.info("Next hop mac for {}/{}/{} is {}", clientAddress, clientMacAddress, vlanId, potentialNextHopMac.toString());
            }
            // search the next hop in the hosts store
            HostId gwHostId = HostId.hostId(potentialNextHopMac, vlanId);
            Host gwHost = hostService.getHost(gwHostId);
            if (gwHost == null) {
                log.warn("Can't find next hop host ID {}", gwHostId);
                return;
            }
            Ip6Address nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp6).filter(IpAddress::isLinkLocal).map(IpAddress::getIp6Address).findFirst().orElse(null);
            if (nextHopIp == null) {
                log.warn("Can't find IP6 address of next hop {}", gwHost);
                return;
            }
            log.info("client " + clientAddress + " is known !");
            Route routeForIP6 = new Route(Route.Source.STATIC, clientAddress.toIpPrefix(), nextHopIp);
            log.debug("updating route of Client for indirectly connected.");
            log.debug("client ip: " + clientAddress + ", next hop ip6: " + nextHopIp);
            routeStore.updateRoute(routeForIP6);
        }
    }
}
#method_after
public void handleLeaseQuery6ReplyMsg(PacketContext context, DHCP6 dhcp6Payload) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    log.info("Got LQV6-REPLY on port {}", inPort);
    List<Dhcp6Option> lopt = dhcp6Payload.getOptions();
    log.info("Options list: {}", lopt);
    // find out if this lease is known is
    Dhcp6ClientDataOption clientDataOption = dhcp6Payload.getOptions().stream().filter(opt -> opt instanceof Dhcp6ClientDataOption).map(pld -> (Dhcp6ClientDataOption) pld).findFirst().orElse(null);
    if (clientDataOption == null) {
        log.warn("clientDataOption option is not present, " + "lease is UNKNOWN - not adding any new route...");
    } else {
        Dhcp6IaAddressOption aiAddressOption = clientDataOption.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(pld -> (Dhcp6IaAddressOption) pld).findFirst().orElse(null);
        Dhcp6ClientIdOption clientIdOption = clientDataOption.getOptions().stream().filter(opt -> opt instanceof Dhcp6ClientIdOption).map(pld -> (Dhcp6ClientIdOption) pld).findFirst().orElse(null);
        if (aiAddressOption == null) {
            log.warn("clientDataOption from DHCP server does not " + "contains Dhcp6IaAddressOption for the client - giving up...");
        } else {
            Ip6Address clientAddress = aiAddressOption.getIp6Address();
            MacAddress clientMacAddress = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
            Ethernet packet = context.inPacket().parsed();
            VlanId vlanId = VlanId.vlanId(packet.getVlanID());
            MacAddress potentialNextHopMac = findNextHopMacForIp6FromRelayStore(clientAddress, clientMacAddress, vlanId);
            if (potentialNextHopMac == null) {
                log.warn("Can't find next hop host mac for client {} mac:{}/{}", clientAddress, clientMacAddress, vlanId);
                return;
            } else {
                log.info("Next hop mac for {}/{}/{} is {}", clientAddress, clientMacAddress, vlanId, potentialNextHopMac.toString());
            }
            // search the next hop in the hosts store
            HostId gwHostId = HostId.hostId(potentialNextHopMac, vlanId);
            Host gwHost = hostService.getHost(gwHostId);
            if (gwHost == null) {
                log.warn("Can't find next hop host ID {}", gwHostId);
                return;
            }
            Ip6Address nextHopIp = gwHost.ipAddresses().stream().filter(IpAddress::isIp6).filter(IpAddress::isLinkLocal).map(IpAddress::getIp6Address).findFirst().orElse(null);
            if (nextHopIp == null) {
                log.warn("Can't find IP6 address of next hop {}", gwHost);
                return;
            }
            log.info("client " + clientAddress + " is known !");
            Route routeForIP6 = new Route(Route.Source.DHCP, clientAddress.toIpPrefix(), nextHopIp);
            log.debug("updating route of Client for indirectly connected.");
            log.debug("client ip: " + clientAddress + ", next hop ip6: " + nextHopIp);
            routeStore.updateRoute(routeForIP6);
        }
    }
}
#end_block

#method_before
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. " + "Abort packet processing dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgTypeVal = dhcp6Payload.getMsgType();
    MsgType msgType = DHCP6.MsgType.getType(msgTypeVal);
    log.debug("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incoming ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    if (msgTypeVal == DHCP6.MsgType.LEASEQUERY.value()) {
        List<InternalPacket> ethernetClientPackets = learnRouteFromLeasequery ? processLQ6PacketFromClient(context, receivedPacket, receivingInterfaces, dhcp6Payload) : processDhcp6ForwardOnly(context, receivedPacket, receivingInterfaces, dhcp6Payload);
        for (InternalPacket internalPacket : ethernetClientPackets) {
            forwardPacket(internalPacket);
        }
    } else if (msgTypeVal == DHCP6.MsgType.LEASEQUERY_REPLY.value() && learnRouteFromLeasequery) {
        IPv6 clientIpv6 = (IPv6) receivedPacket.getPayload();
        UDP clientUdp = (UDP) clientIpv6.getPayload();
        DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
        Interface serverInterface = Dhcp6HandlerUtil.directlyConnected(clientDhcp6) ? getServerInterface() : getIndirectServerInterface();
        InternalPacket ethernetPacketReply = Dhcp6HandlerUtil.processLQ6PacketFromServer(defaultServerInfoList, indirectServerInfoList, serverInterface, interfaceService, hostService, context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
        handleLeaseQuery6ReplyMsg(context, dhcp6Payload);
    } else {
        if (MSG_TYPE_FROM_CLIENT.contains(msgTypeVal)) {
            List<InternalPacket> ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
            for (InternalPacket internalPacket : ethernetClientPacket) {
                forwardPacket(internalPacket);
            }
        } else if (MSG_TYPE_FROM_SERVER.contains(msgTypeVal)) {
            log.debug("calling processDhcp6PacketFromServer with RELAY_REPL {}, {}", receivedPacket, dhcp6Payload);
            InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
            if (ethernetPacketReply != null) {
                forwardPacket(ethernetPacketReply);
            }
        } else {
            log.warn("Not so fast, packet type {} not supported yet", msgTypeVal);
        }
    }
}
#method_after
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. " + "Abort packet processing dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgTypeVal = dhcp6Payload.getMsgType();
    MsgType msgType = DHCP6.MsgType.getType(msgTypeVal);
    log.debug("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incoming ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    if (msgTypeVal == DHCP6.MsgType.LEASEQUERY.value()) {
        List<InternalPacket> ethernetClientPackets = learnRouteFromLeasequery ? processLQ6PacketFromClient(context, receivedPacket, receivingInterfaces, dhcp6Payload) : processDhcp6ForwardOnly(context, receivedPacket, receivingInterfaces, dhcp6Payload);
        for (InternalPacket internalPacket : ethernetClientPackets) {
            forwardPacket(internalPacket);
        }
    } else if (msgTypeVal == DHCP6.MsgType.LEASEQUERY_REPLY.value() && learnRouteFromLeasequery) {
        IPv6 clientIpv6 = (IPv6) receivedPacket.getPayload();
        UDP clientUdp = (UDP) clientIpv6.getPayload();
        DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
        Interface serverInterface = Dhcp6HandlerUtil.directlyConnected(clientDhcp6) ? getServerInterface() : getIndirectServerInterface();
        InternalPacket ethernetPacketReply = Dhcp6HandlerUtil.processLQ6PacketFromServer(defaultServerInfoList, indirectServerInfoList, serverInterface, interfaceService, hostService, context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
        handleLeaseQuery6ReplyMsg(context, dhcp6Payload);
    } else if (MSG_TYPE_FROM_CLIENT.contains(msgTypeVal)) {
        List<InternalPacket> ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
        for (InternalPacket internalPacket : ethernetClientPacket) {
            forwardPacket(internalPacket);
        }
    } else if (MSG_TYPE_FROM_SERVER.contains(msgTypeVal)) {
        log.debug("calling processDhcp6PacketFromServer with RELAY_REPL {}, {}", receivedPacket, dhcp6Payload);
        InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
    } else {
        log.warn("Not so fast, packet type {} not supported yet", msgTypeVal);
    }
}
#end_block

#method_before
private void forwardPacket(InternalPacket packet) {
    // send Packetout to dhcp server connectpoint.
    if (packet.destLocation != null) {
        TrafficTreatment t = DefaultTrafficTreatment.builder().setOutput(packet.destLocation.port()).build();
        OutboundPacket o = new DefaultOutboundPacket(packet.destLocation.deviceId(), t, ByteBuffer.wrap(packet.packet.serialize()));
        packetService.emit(o);
        if (log.isTraceEnabled()) {
            IPv6 ip6 = (IPv6) packet.packet.getPayload();
            UDP udp = (UDP) ip6.getPayload();
            DHCP6 dhcp6 = (DHCP6) udp.getPayload();
            log.trace("Relaying packet to destination {} eth: {} dhcp: {}", packet.destLocation, packet.packet, dhcp6);
        }
    }
}
#method_after
private void forwardPacket(InternalPacket packet) {
    // send Packetout to dhcp server connectpoint.
    if (packet.getDestLocation() != null) {
        TrafficTreatment t = DefaultTrafficTreatment.builder().setOutput(packet.getDestLocation().port()).build();
        OutboundPacket o = new DefaultOutboundPacket(packet.getDestLocation().deviceId(), t, ByteBuffer.wrap(packet.getPacket().serialize()));
        packetService.emit(o);
        if (log.isTraceEnabled()) {
            IPv6 ip6 = (IPv6) packet.getPacket().getPayload();
            UDP udp = (UDP) ip6.getPayload();
            DHCP6 dhcp6 = (DHCP6) udp.getPayload();
            log.trace("Relaying packet to destination {} eth: {} dhcp: {}", packet.getDestLocation(), packet.getPacket(), dhcp6);
        }
    }
}
#end_block

#method_before
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    } else {
        record = record.clone();
    }
    Boolean isMsgRelease = Dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = Dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    }
    if (record != null) {
        record.getV6Counters().incrementCounter(Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        record.addLocation(new HostLocation(location, System.currentTimeMillis()));
        record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
        record.setDirectlyConnected(directConnFlag);
        if (!directConnFlag) {
            // Update gateway mac address if the host is not directly connected
            record.nextHop(srcMac);
        }
        record.updateLastSeen();
    }
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
#method_after
private void removeHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Packet, Ethernet clientPacket, IPv6 clientIpv6, Interface clientInterface) {
    log.debug("removeHostOrRoute  enters {}", dhcp6Packet);
    VlanId vlanId = clientInterface.vlan();
    // could be gw or host
    MacAddress srcMac = clientPacket.getSourceMAC();
    MacAddress leafClientMac;
    byte leafMsgType;
    log.debug("client mac {} client vlan {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId);
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, dhcp6Packet);
    if (clientIdOption != null) {
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. Don't create DhcpRelay Record.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(leafHostId);
    } else {
        record = record.clone();
    }
    Boolean isMsgRelease = Dhcp6HandlerUtil.isDhcp6Release(dhcp6Packet);
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it is connected to network directly
        ipInfo = extractIpAddress(dhcp6Packet);
        if (ipInfo != null) {
            if (isMsgRelease) {
                HostId hostId = HostId.hostId(srcMac, vlanId);
                log.debug("remove Host {} ip for directly connected.", hostId.toString());
                providerService.removeIpFromHost(hostId, ipInfo.ip6Address);
            }
        } else {
            log.debug("ipAddress not found. Do not remove Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = dhcp6Packet.getMsgType();
    } else {
        // Remove from route store if it is not connected to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = Dhcp6HandlerUtil.getDhcp6Leaf(dhcp6Packet);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgRelease) {
                Route routeForIP = new Route(Route.Source.DHCP, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("removing route of 128 address for indirectly connected.");
                log.debug("128 ip {}, nexthop {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgRelease) {
                Route routeForPrefix = new Route(Route.Source.DHCP, pdInfo.pdPrefix, nextHopIp);
                log.debug("removing route of PD for indirectly connected.");
                log.debug("pd ip {}, nexthop {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"), HexString.toHexString(nextHopIp.toOctets(), ":"));
                routeStore.removeRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    dhcpFpmPrefixStore.removeFpmRecord(pdInfo.pdPrefix);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (isMsgRelease) {
        log.debug("DHCP6 RELEASE msg.");
        if (record != null) {
            if (ipInfo != null) {
                log.debug("DhcpRelay Record ip6Address is set to null.");
                record.ip6Address(null);
            }
            if (pdInfo != null) {
                log.debug("DhcpRelay Record pdPrefix is set to null.");
            }
            if (!record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
                log.warn("IP6 address and IP6 PD both are null. Remove record.");
            // do not remove a record. Let timer task handler it.
            // dhcpRelayStore.removeDhcpRecord(HostId.hostId(leafClientMac, vlanId));
            }
        }
    }
    if (record != null) {
        record.getV6Counters().incrementCounter(Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        record.addLocation(new HostLocation(location, System.currentTimeMillis()));
        record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
        record.setDirectlyConnected(directConnFlag);
        if (!directConnFlag) {
            // Update gateway mac address if the host is not directly connected
            record.nextHop(srcMac);
        }
        record.updateLastSeen();
    }
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
#end_block

#method_before
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = Dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.warn("ipAddress not found. Do not add Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = Dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.STATIC, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.STATIC, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("Client IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
            record.updateAddrPrefTime(ipInfo.prefTime);
            record.updateLastIp6Update();
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
            record.pdPrefix(pdInfo.pdPrefix);
            record.updatePdPrefTime(pdInfo.prefTime);
            record.updateLastPdUpdate();
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.getV6Counters().incrementCounter(Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
#method_after
private void addHostOrRoute(boolean directConnFlag, ConnectPoint location, DHCP6 dhcp6Relay, DHCP6 embeddedDhcp6, MacAddress srcMac, Interface clientInterface) {
    log.debug("addHostOrRoute entered.");
    VlanId vlanId = clientInterface.vlan();
    Boolean isMsgReply = Dhcp6HandlerUtil.isDhcp6Reply(dhcp6Relay);
    MacAddress leafClientMac;
    Byte leafMsgType;
    Dhcp6ClientIdOption clientIdOption = extractClinedId(directConnFlag, embeddedDhcp6);
    if (clientIdOption != null) {
        log.debug("CLIENTID option found {}", clientIdOption);
        if ((clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LLT) || (clientIdOption.getDuid().getDuidType() == Dhcp6Duid.DuidType.DUID_LL)) {
            leafClientMac = MacAddress.valueOf(clientIdOption.getDuid().getLinkLayerAddress());
        } else {
            log.warn("Link-Layer Address not supported in CLIENTID option. No DhcpRelay Record created.");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_FAIL);
            return;
        }
    } else {
        log.warn("CLIENTID option NOT found. No DhcpRelay Record created.");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENTID_FAIL);
        return;
    }
    HostId leafHostId = HostId.hostId(leafClientMac, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(leafHostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(leafClientMac, vlanId));
    } else {
        record = record.clone();
    }
    IpAddressInfo ipInfo;
    PdPrefixInfo pdInfo = null;
    if (directConnFlag) {
        // Add to host store if it connect to network directly
        ipInfo = extractIpAddress(embeddedDhcp6);
        if (ipInfo != null) {
            if (isMsgReply) {
                Set<IpAddress> ips = Sets.newHashSet(ipInfo.ip6Address);
                HostId hostId = HostId.hostId(srcMac, vlanId);
                Host host = hostService.getHost(hostId);
                HostLocation hostLocation = new HostLocation(clientInterface.connectPoint(), System.currentTimeMillis());
                Set<HostLocation> hostLocations = Sets.newHashSet(hostLocation);
                if (host != null) {
                    // Dual homing support:
                    // if host exists, use old locations and new location
                    hostLocations.addAll(host.locations());
                }
                HostDescription desc = new DefaultHostDescription(srcMac, vlanId, hostLocations, ips, false);
                log.debug("adding Host for directly connected.");
                log.debug("client mac {} client vlan {} hostlocation {}", HexString.toHexString(srcMac.toBytes(), ":"), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                providerService.hostDetected(hostId, desc, false);
            }
        } else {
            log.warn("ipAddress not found. Do not add Host {} for directly connected.", HostId.hostId(srcMac, vlanId).toString());
        }
        leafMsgType = embeddedDhcp6.getMsgType();
    } else {
        // Add to route store if it does not connect to network directly
        // pick out the first link-local ip address
        IpAddress nextHopIp = getFirstIpByHost(directConnFlag, srcMac, vlanId);
        if (nextHopIp == null) {
            log.warn("Can't find link-local IP address of gateway mac {} vlanId {}", srcMac, vlanId);
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_LINKLOCAL_GW);
            return;
        }
        DHCP6 leafDhcp = Dhcp6HandlerUtil.getDhcp6Leaf(embeddedDhcp6);
        ipInfo = extractIpAddress(leafDhcp);
        if (ipInfo == null) {
            log.debug("ip is null");
        } else {
            if (isMsgReply) {
                Route routeForIP = new Route(Route.Source.DHCP, ipInfo.ip6Address.toIpPrefix(), nextHopIp);
                log.debug("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
        }
        pdInfo = extractPrefix(leafDhcp);
        if (pdInfo == null) {
            log.debug("ipPrefix is null ");
        } else {
            if (isMsgReply) {
                Route routeForPrefix = new Route(Route.Source.DHCP, pdInfo.pdPrefix, nextHopIp);
                log.debug("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
                if (this.dhcpFpmEnabled) {
                    FpmRecord fpmRecord = new FpmRecord(pdInfo.pdPrefix, nextHopIp, FpmRecord.Type.DHCP_RELAY);
                    dhcpFpmPrefixStore.addFpmRecord(pdInfo.pdPrefix, fpmRecord);
                }
            }
        }
        leafMsgType = leafDhcp.getMsgType();
    }
    if (leafMsgType == DHCP6.MsgType.RELEASE.value() || (leafMsgType == DHCP6.MsgType.REPLY.value()) && ipInfo == null) {
        log.warn("DHCP6 RELEASE/REPLY(null ip) from Server. MsgType {}", leafMsgType);
    // return;
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    if (leafMsgType == DHCP6.MsgType.REPLY.value()) {
        if (ipInfo != null) {
            log.debug("IP6 address is being stored into dhcp-relay store.");
            log.debug("Client IP6 address {}", HexString.toHexString(ipInfo.ip6Address.toOctets(), ":"));
            record.ip6Address(ipInfo.ip6Address);
            record.updateAddrPrefTime(ipInfo.prefTime);
            record.updateLastIp6Update();
        } else {
            log.debug("IP6 address is not returned from server. Maybe only PD is returned.");
        }
        if (pdInfo != null) {
            log.debug("IP6 PD address {}", HexString.toHexString(pdInfo.pdPrefix.address().toOctets(), ":"));
            record.pdPrefix(pdInfo.pdPrefix);
            record.updatePdPrefTime(pdInfo.prefTime);
            record.updateLastPdUpdate();
        } else {
            log.debug("IP6 PD address is not returned from server. Maybe only IPAddress is returned.");
        }
    }
    record.getV6Counters().incrementCounter(Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
    record.ip6Status(DHCP6.MsgType.getType(leafMsgType));
    record.setDirectlyConnected(directConnFlag);
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(leafHostId, record);
    // TODO Use AtomicInteger for the counters
    try {
        recordSemaphore.acquire();
        try {
            dhcpRelayCountersStore.incrementCounter(gCount, Dhcp6HandlerUtil.getMsgTypeStr(leafMsgType));
        } finally {
            // calling release() after a successful acquire()
            recordSemaphore.release();
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
#end_block

#method_before
private List<InternalPacket> processDhcp6ForwardOnly(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces, DHCP6 dhcpPacket) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    log.trace("Got DHCPv6 on port {}", inPort);
    boolean directConnFlag = Dhcp6HandlerUtil.directlyConnected(dhcpPacket);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    for (DhcpServerInfo dhcpServer : serverInfoList) {
        Ethernet newPacket = Dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, dhcpServer, getServerInterface(dhcpServer));
        log.trace("Built packet for server {} : {}", dhcpServer, newPacket);
        internalPackets.add(Dhcp6HandlerUtil.internalPacket(newPacket, dhcpServer.getDhcpServerConnectPoint().get()));
    }
    return internalPackets;
}
#method_after
private List<InternalPacket> processDhcp6ForwardOnly(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces, DHCP6 dhcpPacket) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    log.trace("Got DHCPv6 on port {}", inPort);
    boolean directConnFlag = Dhcp6HandlerUtil.directlyConnected(dhcpPacket);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    for (DhcpServerInfo dhcpServer : serverInfoList) {
        Ethernet newPacket = Dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, dhcpServer, getServerInterface(dhcpServer));
        log.trace("Built packet for server {} : {}", dhcpServer, newPacket);
        internalPackets.add(InternalPacket.internalPacket(newPacket, dhcpServer.getDhcpServerConnectPoint().get()));
    }
    return internalPackets;
}
#end_block

#method_before
private List<InternalPacket> processLQ6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces, DHCP6 dhcp6Payload) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    log.info("Got LQ-REQUEST V6 on port {}", inPort);
    List<Dhcp6Option> lopt = dhcp6Payload.getOptions();
    log.info("Options list: {}", lopt);
    Dhcp6LeaseQueryOption lqoption = dhcp6Payload.getOptions().stream().filter(opt -> opt instanceof Dhcp6LeaseQueryOption).map(pld -> (Dhcp6LeaseQueryOption) pld).findFirst().orElse(null);
    if (lqoption == null) {
        // Can't find dhcp payload
        log.warn("Can't find dhcp6 lease query message - aborting");
        return null;
    } else {
        log.info("dhcp6 lqv6 options found: {}", lqoption);
    }
    log.warn("LQv6 for " + lqoption.linkAddress.toString() + " comes from " + inPort.toString());
    Ethernet packet = context.inPacket().parsed();
    Ip6Address clientAddress = lqoption.linkAddress;
    IPv6 ipv6Packet = (IPv6) packet.getPayload();
    Ip6Address nextHopIp = findNextHopIp6FromRelayStore(clientAddress);
    // 1. only if there is a route to remove - remove it
    if (nextHopIp != null) {
        Route routeForIP6 = new Route(Route.Source.STATIC, clientAddress.toIpPrefix(), nextHopIp);
        log.debug("Removing route of Client " + clientAddress + " for indirectly connected - next hop ip6 " + nextHopIp);
        routeStore.removeRoute(routeForIP6);
    }
    // 2. note the potential NH this packet came from in case it's a known lease
    // this NH will then be used to build the route
    MacAddress potentialNH = packet.getSourceMAC();
    VlanId vlanId = VlanId.vlanId(packet.getVlanID());
    setPotentialNextHopForIp6InRelayStore(clientAddress, vlanId, potentialNH);
    // 3. route this LQ6 to all relevant servers
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = Dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> Dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!Dhcp6HandlerUtil.checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherRouted = (Ethernet) clientPacket.clone();
        MacAddress macFacingServer = serverInterface.mac();
        if (macFacingServer == null) {
            log.warn("No MAC address for server Interface {}", serverInterface);
            return null;
        }
        etherRouted.setSourceMACAddress(macFacingServer);
        etherRouted.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
        InternalPacket internalPacket = Dhcp6HandlerUtil.internalPacket(etherRouted, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
        log.debug("Sending LQ to DHCP server {}", newServerInfo.getDhcpServerIp6());
    }
    log.debug("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#method_after
private List<InternalPacket> processLQ6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces, DHCP6 dhcp6Payload) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    log.info("Got LQ-REQUEST V6 on port {}", inPort);
    List<Dhcp6Option> lopt = dhcp6Payload.getOptions();
    log.info("Options list: {}", lopt);
    Dhcp6LeaseQueryOption lqoption = dhcp6Payload.getOptions().stream().filter(opt -> opt instanceof Dhcp6LeaseQueryOption).map(pld -> (Dhcp6LeaseQueryOption) pld).findFirst().orElse(null);
    if (lqoption == null) {
        // Can't find dhcp payload
        log.warn("Can't find dhcp6 lease query message - aborting");
        return null;
    } else {
        log.info("dhcp6 lqv6 options found: {}", lqoption);
    }
    log.warn("LQv6 for " + lqoption.linkAddress.toString() + " comes from " + inPort.toString());
    Ethernet packet = context.inPacket().parsed();
    Ip6Address clientAddress = lqoption.linkAddress;
    IPv6 ipv6Packet = (IPv6) packet.getPayload();
    Ip6Address nextHopIp = findNextHopIp6FromRelayStore(clientAddress);
    // 1. only if there is a route to remove - remove it
    if (nextHopIp != null) {
        Route routeForIP6 = new Route(Route.Source.DHCP, clientAddress.toIpPrefix(), nextHopIp);
        log.debug("Removing route of Client " + clientAddress + " for indirectly connected - next hop ip6 " + nextHopIp);
        routeStore.removeRoute(routeForIP6);
    }
    // 2. note the potential NH this packet came from in case it's a known lease
    // this NH will then be used to build the route
    MacAddress potentialNH = packet.getSourceMAC();
    VlanId vlanId = VlanId.vlanId(packet.getVlanID());
    setPotentialNextHopForIp6InRelayStore(clientAddress, vlanId, potentialNH);
    // 3. route this LQ6 to all relevant servers
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = Dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!Dhcp6HandlerUtil.checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherRouted = (Ethernet) clientPacket.clone();
        MacAddress macFacingServer = serverInterface.mac();
        if (macFacingServer == null) {
            log.warn("No MAC address for server Interface {}", serverInterface);
            return null;
        }
        etherRouted.setSourceMACAddress(macFacingServer);
        etherRouted.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
        InternalPacket internalPacket = InternalPacket.internalPacket(etherRouted, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
        log.debug("Sending LQ to DHCP server {}", newServerInfo.getDhcpServerIp6());
    }
    log.debug("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#end_block

#method_before
private List<InternalPacket> processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip6Address relayAgentIp = Dhcp6HandlerUtil.getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
        return Lists.newArrayList();
    }
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = Dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> Dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!Dhcp6HandlerUtil.checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherReply = Dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, newServerInfo, serverInterface);
        removeHostOrRoute(directConnFlag, clientConnectionPoint, clientDhcp6, clientPacket, clientIpv6, clientInterface);
        InternalPacket internalPacket = Dhcp6HandlerUtil.internalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.debug("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#method_after
private List<InternalPacket> processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    Ip6Address relayAgentIp = Dhcp6HandlerUtil.getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
        return Lists.newArrayList();
    }
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = Dhcp6HandlerUtil.directlyConnected(clientDhcp6);
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(clientPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> Dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        if (!Dhcp6HandlerUtil.checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ethernet etherReply = Dhcp6HandlerUtil.buildDhcp6PacketFromClient(context, clientPacket, clientInterfaces, newServerInfo, serverInterface);
        removeHostOrRoute(directConnFlag, clientConnectionPoint, clientDhcp6, clientPacket, clientIpv6, clientInterface);
        InternalPacket internalPacket = InternalPacket.internalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    log.debug("num of client packets to send is{}", internalPackets.size());
    return internalPackets;
}
#end_block

#method_before
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    // get dhcp6 header.
    Ethernet etherReply = receivedPacket.duplicate();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = Dhcp6HandlerUtil.directlyConnected(dhcp6Relay);
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    DhcpServerInfo foundServerInfo = findServerInfoFromServer(directConnFlag, inPort);
    if (foundServerInfo == null) {
        log.warn("Cannot find server info");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_SERVER_INFO);
        return null;
    } else {
        if (Dhcp6HandlerUtil.isServerIpEmpty(foundServerInfo)) {
            log.warn("Cannot find server info's ipaddress");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_SERVER_IP6ADDR);
            return null;
        }
    }
    Dhcp6InterfaceIdOption interfaceIdOption = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6InterfaceIdOption).map(opt -> (Dhcp6InterfaceIdOption) opt).findFirst().orElse(null);
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.OPTION_MISSING_FAIL);
        return null;
    }
    MacAddress peerMac = interfaceIdOption.getMacAddress();
    String clientConnectionPointStr = new String(interfaceIdOption.getInPort());
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId vlanIdInUse = VlanId.vlanId(interfaceIdOption.getVlanId());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> Dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot get client interface for from packet, abort... vlan {}", vlanIdInUse.toString());
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_MATCHING_INTF);
        return null;
    }
    MacAddress relayAgentMac = clientInterface.mac();
    if (relayAgentMac == null) {
        log.warn("Can not get client interface mac, abort packet..");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac;
    Ip6Address peerAddress = Ip6Address.valueOf(dhcp6Relay.getPeerAddress());
    Set<Host> clients = hostService.getHostsByIp(peerAddress);
    if (clients.isEmpty()) {
        log.trace("There's no host found for this address {}", HexString.toHexString(dhcp6Relay.getPeerAddress(), ":"));
        log.trace("Let's look up interfaceId {}", HexString.toHexString(peerMac.toBytes(), ":"));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
            return null;
        }
        log.trace("Client mac address found from getHostByIp");
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    boolean hostOrRouteAllowed = learnRouteFromLeasequery || Dhcp6HandlerUtil.getDhcp6LeafMessageType(dhcp6Relay) != MsgType.LEASEQUERY_REPLY;
    log.debug("Can add host or route: {}", hostOrRouteAllowed);
    if (hostOrRouteAllowed) {
        // add host or route
        addHostOrRoute(directConnFlag, clientConnectionPoint, dhcp6Relay, embeddedDhcp6, clientMac, clientInterface);
    }
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return Dhcp6HandlerUtil.internalPacket(etherReply, clientConnectionPoint);
}
#method_after
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    // get dhcp6 header.
    Ethernet etherReply = receivedPacket.duplicate();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = Dhcp6HandlerUtil.directlyConnected(dhcp6Relay);
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    DhcpServerInfo foundServerInfo = findServerInfoFromServer(directConnFlag, inPort);
    if (foundServerInfo == null) {
        log.warn("Cannot find server info");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_SERVER_INFO);
        return null;
    } else {
        if (Dhcp6HandlerUtil.isServerIpEmpty(foundServerInfo)) {
            log.warn("Cannot find server info's ipaddress");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_SERVER_IP6ADDR);
            return null;
        }
    }
    Dhcp6InterfaceIdOption interfaceIdOption = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6InterfaceIdOption).map(opt -> (Dhcp6InterfaceIdOption) opt).findFirst().orElse(null);
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.OPTION_MISSING_FAIL);
        return null;
    }
    MacAddress peerMac = interfaceIdOption.getMacAddress();
    String clientConnectionPointStr = new String(interfaceIdOption.getInPort());
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId vlanIdInUse = VlanId.vlanId(interfaceIdOption.getVlanId());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> Dhcp6HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    if (clientInterface == null) {
        log.warn("Cannot get client interface for from packet, abort... vlan {}", vlanIdInUse.toString());
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_MATCHING_INTF);
        return null;
    }
    etherReply.setVlanID(vlanIdInUse.toShort());
    MacAddress relayAgentMac = clientInterface.mac();
    if (relayAgentMac == null) {
        log.warn("Can not get client interface mac, abort packet..");
        dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac;
    Ip6Address peerAddress = Ip6Address.valueOf(dhcp6Relay.getPeerAddress());
    Set<Host> clients = hostService.getHostsByIp(peerAddress);
    if (clients.isEmpty()) {
        log.trace("There's no host found for this address {}", HexString.toHexString(dhcp6Relay.getPeerAddress(), ":"));
        log.trace("Let's look up interfaceId {}", HexString.toHexString(peerMac.toBytes(), ":"));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            dhcpRelayCountersStore.incrementCounter(gCount, DhcpRelayCounters.NO_CLIENT_INTF_MAC);
            return null;
        }
        log.trace("Client mac address found from getHostByIp");
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    boolean hostOrRouteAllowed = learnRouteFromLeasequery || Dhcp6HandlerUtil.getDhcp6LeafMessageType(dhcp6Relay) != MsgType.LEASEQUERY_REPLY;
    log.debug("Can add host or route: {}", hostOrRouteAllowed);
    if (hostOrRouteAllowed) {
        // add host or route
        addHostOrRoute(directConnFlag, clientConnectionPoint, dhcp6Relay, embeddedDhcp6, clientMac, clientInterface);
    }
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return InternalPacket.internalPacket(etherReply, clientConnectionPoint);
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    switch(event.type()) {
        case HOST_ADDED:
        case HOST_UPDATED:
            hostUpdated(event.subject());
            break;
        case HOST_REMOVED:
            hostRemoved(event.subject());
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(HostEvent event) {
    switch(event.type()) {
        case HOST_ADDED:
        case HOST_UPDATED:
            log.trace("Scheduled host event {}", event);
            hostEventExecutor.execute(() -> hostUpdated(event.subject()));
            break;
        case HOST_REMOVED:
            log.trace("Scheduled host event {}", event);
            hostEventExecutor.execute(() -> hostRemoved(event.subject()));
            break;
        default:
            break;
    }
}
#end_block

#method_before
public void timeTick() {
    long currentTime = System.currentTimeMillis();
    Collection<DhcpRecord> records = dhcpRelayStore.getDhcpRecords();
    log.debug("timeTick called currenttime {} records num {} ", currentTime, records.size());
    records.forEach(record -> {
        boolean addrOrPdRemoved = false;
        DHCP6.MsgType ip6Status = record.ip6Status().orElse(null);
        if (ip6Status == null) {
            log.debug("record is not valid v6 record.");
            return;
        }
        if ((currentTime - record.getLastIp6Update()) > ((record.addrPrefTime() + getDhcp6PollInterval() / 2) * 1000)) {
            // remove ipaddress from host/route table
            IpAddress ip = record.ip6Address().orElse(null);
            if (ip != null) {
                if (record.directlyConnected()) {
                    providerService.removeIpFromHost(HostId.hostId(record.macAddress(), record.vlanId()), ip);
                } else {
                    MacAddress gwMac = record.nextHop().orElse(null);
                    if (gwMac == null) {
                        log.warn("Can't find gateway mac address from record {} for ip6Addr", record);
                        return;
                    }
                    IpAddress nextHopIp = getFirstIpByHost(record.directlyConnected(), gwMac, record.vlanId());
                    Route route = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                    routeStore.removeRoute(route);
                }
                record.updateAddrPrefTime(0);
                record.ip6Address(null);
                addrOrPdRemoved = true;
                dhcpRelayStore.updateDhcpRecord(HostId.hostId(record.macAddress(), record.vlanId()), record);
                log.warn("IP6 address is set to null. delta {} lastUpdate {} addrPrefTime {}", (currentTime - record.getLastIp6Update()), record.getLastIp6Update(), record.addrPrefTime());
            }
        }
        if ((currentTime - record.getLastPdUpdate()) > ((record.pdPrefTime() + getDhcp6PollInterval() / 2) * 1000)) {
            // remove PD from route/fpm table
            IpPrefix pdIpPrefix = record.pdPrefix().orElse(null);
            if (pdIpPrefix != null) {
                if (record.directlyConnected()) {
                    providerService.removeIpFromHost(HostId.hostId(record.macAddress(), record.vlanId()), pdIpPrefix.address().getIp6Address());
                } else {
                    MacAddress gwMac = record.nextHop().orElse(null);
                    if (gwMac == null) {
                        log.warn("Can't find gateway mac address from record {} for PD prefix", record);
                        return;
                    }
                    IpAddress nextHopIp = getFirstIpByHost(record.directlyConnected(), gwMac, record.vlanId());
                    Route route = new Route(Route.Source.STATIC, pdIpPrefix, nextHopIp);
                    routeStore.removeRoute(route);
                    if (this.dhcpFpmEnabled) {
                        dhcpFpmPrefixStore.removeFpmRecord(pdIpPrefix);
                    }
                }
                record.updatePdPrefTime(0);
                record.pdPrefix(null);
                addrOrPdRemoved = true;
                dhcpRelayStore.updateDhcpRecord(HostId.hostId(record.macAddress(), record.vlanId()), record);
                log.warn("PD prefix is set to null.delta {} pdPrefTime {}", (currentTime - record.getLastPdUpdate()), record.pdPrefTime());
            }
        }
        if (addrOrPdRemoved && !record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
            log.warn("ip6Status {} IP6 address and IP6 PD both are null. Remove record.", ip6Status);
            dhcpRelayStore.removeDhcpRecord(HostId.hostId(record.macAddress(), record.vlanId()));
        }
    });
}
#method_after
public void timeTick() {
    long currentTime = System.currentTimeMillis();
    Collection<DhcpRecord> records = dhcpRelayStore.getDhcpRecords();
    log.debug("timeTick called currenttime {} records num {} ", currentTime, records.size());
    records.forEach(record -> {
        boolean addrOrPdRemoved = false;
        DHCP6.MsgType ip6Status = record.ip6Status().orElse(null);
        if (ip6Status == null) {
            log.debug("record is not valid v6 record.");
            return;
        }
        if ((currentTime - record.getLastIp6Update()) > ((record.addrPrefTime() + getDhcp6PollInterval() / 2) * 1000)) {
            // remove ipaddress from host/route table
            IpAddress ip = record.ip6Address().orElse(null);
            if (ip != null) {
                if (record.directlyConnected()) {
                    providerService.removeIpFromHost(HostId.hostId(record.macAddress(), record.vlanId()), ip);
                } else {
                    MacAddress gwMac = record.nextHop().orElse(null);
                    if (gwMac == null) {
                        log.warn("Can't find gateway mac address from record {} for ip6Addr", record);
                        return;
                    }
                    IpAddress nextHopIp = getFirstIpByHost(record.directlyConnected(), gwMac, record.vlanId());
                    Route route = new Route(Route.Source.DHCP, ip.toIpPrefix(), nextHopIp);
                    routeStore.removeRoute(route);
                }
                record.updateAddrPrefTime(0);
                record.ip6Address(null);
                addrOrPdRemoved = true;
                dhcpRelayStore.updateDhcpRecord(HostId.hostId(record.macAddress(), record.vlanId()), record);
                log.warn("IP6 address is set to null. delta {} lastUpdate {} addrPrefTime {}", (currentTime - record.getLastIp6Update()), record.getLastIp6Update(), record.addrPrefTime());
            }
        }
        if ((currentTime - record.getLastPdUpdate()) > ((record.pdPrefTime() + getDhcp6PollInterval() / 2) * 1000)) {
            // remove PD from route/fpm table
            IpPrefix pdIpPrefix = record.pdPrefix().orElse(null);
            if (pdIpPrefix != null) {
                if (record.directlyConnected()) {
                    providerService.removeIpFromHost(HostId.hostId(record.macAddress(), record.vlanId()), pdIpPrefix.address().getIp6Address());
                } else {
                    MacAddress gwMac = record.nextHop().orElse(null);
                    if (gwMac == null) {
                        log.warn("Can't find gateway mac address from record {} for PD prefix", record);
                        return;
                    }
                    IpAddress nextHopIp = getFirstIpByHost(record.directlyConnected(), gwMac, record.vlanId());
                    Route route = new Route(Route.Source.DHCP, pdIpPrefix, nextHopIp);
                    routeStore.removeRoute(route);
                    if (this.dhcpFpmEnabled) {
                        dhcpFpmPrefixStore.removeFpmRecord(pdIpPrefix);
                    }
                }
                record.updatePdPrefTime(0);
                record.pdPrefix(null);
                addrOrPdRemoved = true;
                dhcpRelayStore.updateDhcpRecord(HostId.hostId(record.macAddress(), record.vlanId()), record);
                log.warn("PD prefix is set to null.delta {} pdPrefTime {}", (currentTime - record.getLastPdUpdate()), record.pdPrefTime());
            }
        }
        if (addrOrPdRemoved && !record.ip6Address().isPresent() && !record.pdPrefix().isPresent()) {
            log.warn("ip6Status {} IP6 address and IP6 PD both are null. Remove record.", ip6Status);
            dhcpRelayStore.removeDhcpRecord(HostId.hostId(record.macAddress(), record.vlanId()));
        }
    });
}
#end_block

#method_before
public static Ip6Address getFirstIpFromInterface(Interface iface) {
    checkNotNull(iface, "Interface can't be null");
    return iface.ipAddressesList().stream().map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp6).map(IpAddress::getIp6Address).findFirst().orElse(null);
}
#method_after
private static Ip6Address getFirstIpFromInterface(Interface iface) {
    checkNotNull(iface, "Interface can't be null");
    return iface.ipAddressesList().stream().map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp6).map(IpAddress::getIp6Address).findFirst().orElse(null);
}
#end_block

#method_before
public static InternalPacket processLQ6PacketFromServer(List<DhcpServerInfo> defaultServerInfoList, List<DhcpServerInfo> indirectServerInfoList, Interface serverInterface, InterfaceService interfaceService, HostService hostService, PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    // get dhcp6 header.
    Ethernet etherReply = (Ethernet) receivedPacket.clone();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 lq6Reply = (DHCP6) udpPacket.getPayload();
    // TODO: refactor
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    DhcpServerInfo serverInfo;
    Ip6Address dhcpServerIp = null;
    ConnectPoint dhcpServerConnectPoint = null;
    MacAddress dhcpConnectMac = null;
    VlanId dhcpConnectVlan = null;
    Ip6Address dhcpGatewayIp = null;
    // todo: refactor
    Ip6Address indirectDhcpServerIp = null;
    ConnectPoint indirectDhcpServerConnectPoint = null;
    MacAddress indirectDhcpConnectMac = null;
    VlanId indirectDhcpConnectVlan = null;
    Ip6Address indirectDhcpGatewayIp = null;
    Ip6Address indirectRelayAgentIpFromCfg = null;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        serverInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        indirectDhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        indirectDhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        indirectDhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        indirectRelayAgentIpFromCfg = serverInfo.getRelayAgentIp6(receivedFromDevice).orElse(null);
    }
    Boolean directConnFlag = directlyConnected(lq6Reply);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if ((directConnFlag || indirectDhcpServerIp == null) && !inPort.equals(dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for direct or indirect-null", inPort, dhcpServerConnectPoint);
        return null;
    }
    if (!directConnFlag && indirectDhcpServerIp != null && !inPort.equals(indirectDhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for indirect", inPort, indirectDhcpServerConnectPoint);
        return null;
    }
    Ip6Address nextHopIP = Ip6Address.valueOf(ipv6Packet.getDestinationAddress());
    // use hosts store to find out the next hop mac and connection point
    Set<Host> hosts = hostService.getHostsByIp(nextHopIP);
    Host host;
    if (!hosts.isEmpty()) {
        host = hosts.iterator().next();
    } else {
        log.warn("Host {} is not in store", nextHopIP);
        return null;
    }
    HostLocation hl = host.location();
    // iterator().next());
    String clientConnectionPointStr = hl.toString();
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId originalPacketVlanId = VlanId.vlanId(etherReply.getVlanID());
    Interface iface;
    iface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface1 -> interfaceContainsVlan(iface1, originalPacketVlanId)).findFirst().orElse(null);
    etherReply.setSourceMACAddress(iface.mac());
    etherReply.setDestinationMACAddress(host.mac());
    // workaround for a bug where core sends src port as 547 (server)
    udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    udpPacket.setPayload(lq6Reply);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, clientConnectionPoint);
}
#method_after
public static InternalPacket processLQ6PacketFromServer(List<DhcpServerInfo> defaultServerInfoList, List<DhcpServerInfo> indirectServerInfoList, Interface serverInterface, InterfaceService interfaceService, HostService hostService, PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    // get dhcp6 header.
    Ethernet etherReply = (Ethernet) receivedPacket.clone();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 lq6Reply = (DHCP6) udpPacket.getPayload();
    // TODO: refactor
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    DhcpServerInfo serverInfo;
    Ip6Address dhcpServerIp = null;
    ConnectPoint dhcpServerConnectPoint = null;
    MacAddress dhcpConnectMac = null;
    VlanId dhcpConnectVlan = null;
    Ip6Address dhcpGatewayIp = null;
    // todo: refactor
    Ip6Address indirectDhcpServerIp = null;
    ConnectPoint indirectDhcpServerConnectPoint = null;
    MacAddress indirectDhcpConnectMac = null;
    VlanId indirectDhcpConnectVlan = null;
    Ip6Address indirectDhcpGatewayIp = null;
    Ip6Address indirectRelayAgentIpFromCfg = null;
    if (!defaultServerInfoList.isEmpty()) {
        serverInfo = defaultServerInfoList.get(0);
        dhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        dhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        dhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        dhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        dhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
    }
    if (!indirectServerInfoList.isEmpty()) {
        serverInfo = indirectServerInfoList.get(0);
        indirectDhcpConnectMac = serverInfo.getDhcpConnectMac().orElse(null);
        indirectDhcpGatewayIp = serverInfo.getDhcpGatewayIp6().orElse(null);
        indirectDhcpServerIp = serverInfo.getDhcpServerIp6().orElse(null);
        indirectDhcpServerConnectPoint = serverInfo.getDhcpServerConnectPoint().orElse(null);
        indirectDhcpConnectVlan = serverInfo.getDhcpConnectVlan().orElse(null);
        indirectRelayAgentIpFromCfg = serverInfo.getRelayAgentIp6(receivedFromDevice).orElse(null);
    }
    Boolean directConnFlag = directlyConnected(lq6Reply);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if ((directConnFlag || indirectDhcpServerIp == null) && !inPort.equals(dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for direct or indirect-null", inPort, dhcpServerConnectPoint);
        return null;
    }
    if (!directConnFlag && indirectDhcpServerIp != null && !inPort.equals(indirectDhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server connect point {} for indirect", inPort, indirectDhcpServerConnectPoint);
        return null;
    }
    Ip6Address nextHopIP = Ip6Address.valueOf(ipv6Packet.getDestinationAddress());
    // use hosts store to find out the next hop mac and connection point
    Set<Host> hosts = hostService.getHostsByIp(nextHopIP);
    Host host;
    if (!hosts.isEmpty()) {
        host = hosts.iterator().next();
    } else {
        log.warn("Host {} is not in store", nextHopIP);
        return null;
    }
    HostLocation hl = host.location();
    // iterator().next());
    String clientConnectionPointStr = hl.toString();
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    VlanId originalPacketVlanId = VlanId.vlanId(etherReply.getVlanID());
    Interface iface;
    iface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface1 -> interfaceContainsVlan(iface1, originalPacketVlanId)).findFirst().orElse(null);
    etherReply.setSourceMACAddress(iface.mac());
    etherReply.setDestinationMACAddress(host.mac());
    // workaround for a bug where core sends src port as 547 (server)
    udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    udpPacket.setPayload(lq6Reply);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return InternalPacket.internalPacket(etherReply, clientConnectionPoint);
}
#end_block

#method_before
@Override
public ExtensionTreatment mapAction(OFAction action) throws UnsupportedOperationException {
    if (action.getType().equals(OFActionType.SET_FIELD)) {
        OFActionSetField setFieldAction = (OFActionSetField) action;
        OFOxm<?> oxm = setFieldAction.getField();
        switch(oxm.getMatchField().id) {
            case OFDPA_MPLS_TYPE:
                OFOxmOfdpaMplsType mplsType = (OFOxmOfdpaMplsType) oxm;
                return new Ofdpa3SetMplsType(mplsType.getValue().getRaw());
            case OFDPA_OVID:
                OFOxmOfdpaOvid ovid = ((OFOxmOfdpaOvid) oxm);
                short mask = (short) 0x0FFF;
                short oVid = (short) (mask & ovid.getValue().getRaw());
                VlanId vlanId = VlanId.vlanId(oVid);
                return new Ofdpa3SetOvid(vlanId);
            case OFDPA_MPLS_L2_PORT:
                OFOxmOfdpaMplsL2Port mplsl2Port = ((OFOxmOfdpaMplsL2Port) oxm);
                Integer mplsL2Port = mplsl2Port.getValue().getRaw();
                if ((mplsL2Port >= 0 && mplsL2Port <= 0x0000FFFF) || (mplsL2Port >= 0x00020000 && mplsL2Port <= 0x0002FFFF)) {
                    return new Ofdpa3SetMplsL2Port(mplsL2Port);
                }
                break;
            case OFDPA_QOS_INDEX:
                OFOxmOfdpaQosIndex qosindex = ((OFOxmOfdpaQosIndex) oxm);
                Integer qosIndex = (int) qosindex.getValue().getRaw();
                if (qosIndex >= 0 && qosIndex <= 255) {
                    return new Ofdpa3SetQosIndex(qosIndex);
                }
                break;
            case OFDPA_ALLOW_VLAN_TRANSLATION:
                OFOxmOfdpaAllowVlanTranslation allowVlanTranslation = ((OFOxmOfdpaAllowVlanTranslation) oxm);
                Byte allowVlan = allowVlanTranslation.getValue().getRaw();
                if ((allowVlan == 0) || (allowVlan == 1)) {
                    return new OfdpaSetAllowVlanTranslation(allowVlan);
                }
                break;
            default:
                throw new UnsupportedOperationException("Driver does not support extension type " + oxm.getMatchField().id);
        }
    } else if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter experimenter = (OFActionExperimenter) action;
        if (Long.valueOf(experimenter.getExperimenter()).intValue() == TYPE_OFDPA) {
            OFActionOfdpa ofdpa = (OFActionOfdpa) experimenter;
            switch(ofdpa.getExpType()) {
                case SUB_TYPE_PUSH_L2_HEADER:
                    return new Ofdpa3PushL2Header();
                case SUB_TYPE_POP_L2_HEADER:
                    return new Ofdpa3PopL2Header();
                case SUB_TYPE_PUSH_CW:
                    return new Ofdpa3PushCw();
                case SUB_TYPE_POP_CW:
                    return new Ofdpa3PopCw();
                default:
                    throw new UnsupportedOperationException("Unexpected OFAction: " + action.toString());
            }
        } else if (Long.valueOf(experimenter.getExperimenter()).intValue() == TYPE_ONF) {
            OFActionOnf onf = (OFActionOnf) experimenter;
            switch(onf.getExpType()) {
                case SUB_TYPE_COPY_FIELD:
                    return new Ofdpa3CopyField(((OFActionOnfCopyField) onf).getNBits(), ((OFActionOnfCopyField) onf).getSrcOffset(), ((OFActionOnfCopyField) onf).getDstOffset(), (int) ((OFActionOnfCopyField) onf).getSrc(), (int) ((OFActionOnfCopyField) onf).getDst());
                default:
                    throw new UnsupportedOperationException("Unexpected OFAction: " + action.toString());
            }
        }
        throw new UnsupportedOperationException("Unexpected OFAction: " + action.toString());
    }
    throw new UnsupportedOperationException("Unexpected OFAction: " + action.toString());
}
#method_after
@Override
public ExtensionTreatment mapAction(OFAction action) throws UnsupportedOperationException {
    if (action.getType().equals(OFActionType.SET_FIELD)) {
        OFActionSetField setFieldAction = (OFActionSetField) action;
        OFOxm<?> oxm = setFieldAction.getField();
        switch(oxm.getMatchField().id) {
            case OFDPA_MPLS_TYPE:
                OFOxmOfdpaMplsType mplsType = (OFOxmOfdpaMplsType) oxm;
                return new Ofdpa3SetMplsType(mplsType.getValue().getRaw());
            case OFDPA_OVID:
                OFOxmOfdpaOvid ovid = ((OFOxmOfdpaOvid) oxm);
                short mask = (short) 0x0FFF;
                short oVid = (short) (mask & ovid.getValue().getRaw());
                VlanId vlanId = VlanId.vlanId(oVid);
                return new Ofdpa3SetOvid(vlanId);
            case OFDPA_MPLS_L2_PORT:
                OFOxmOfdpaMplsL2Port mplsl2Port = ((OFOxmOfdpaMplsL2Port) oxm);
                Integer mplsL2Port = mplsl2Port.getValue().getRaw();
                if ((mplsL2Port >= 0 && mplsL2Port <= 0x0000FFFF) || (mplsL2Port >= 0x00020000 && mplsL2Port <= 0x0002FFFF)) {
                    return new Ofdpa3SetMplsL2Port(mplsL2Port);
                }
                break;
            case OFDPA_QOS_INDEX:
                OFOxmOfdpaQosIndex qosindex = ((OFOxmOfdpaQosIndex) oxm);
                Integer qosIndex = (int) qosindex.getValue().getRaw();
                if (qosIndex >= 0 && qosIndex <= 255) {
                    return new Ofdpa3SetQosIndex(qosIndex);
                }
                break;
            case OFDPA_ALLOW_VLAN_TRANSLATION:
                OFOxmOfdpaAllowVlanTranslation allowVlanTranslation = (OFOxmOfdpaAllowVlanTranslation) oxm;
                Byte allowVlan = allowVlanTranslation.getValue().getRaw();
                if ((allowVlan == 0) || (allowVlan == 1)) {
                    return new OfdpaSetAllowVlanTranslation(allowVlan);
                }
                break;
            default:
                throw new UnsupportedOperationException("Driver does not support extension type " + oxm.getMatchField().id);
        }
    } else if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter experimenter = (OFActionExperimenter) action;
        if (Long.valueOf(experimenter.getExperimenter()).intValue() == TYPE_OFDPA) {
            OFActionOfdpa ofdpa = (OFActionOfdpa) experimenter;
            switch(ofdpa.getExpType()) {
                case SUB_TYPE_PUSH_L2_HEADER:
                    return new Ofdpa3PushL2Header();
                case SUB_TYPE_POP_L2_HEADER:
                    return new Ofdpa3PopL2Header();
                case SUB_TYPE_PUSH_CW:
                    return new Ofdpa3PushCw();
                case SUB_TYPE_POP_CW:
                    return new Ofdpa3PopCw();
                default:
                    throw new UnsupportedOperationException("Unexpected OFAction: " + action.toString());
            }
        } else if (Long.valueOf(experimenter.getExperimenter()).intValue() == TYPE_ONF) {
            OFActionOnf onf = (OFActionOnf) experimenter;
            switch(onf.getExpType()) {
                case SUB_TYPE_COPY_FIELD:
                    return new Ofdpa3CopyField(((OFActionOnfCopyField) onf).getNBits(), ((OFActionOnfCopyField) onf).getSrcOffset(), ((OFActionOnfCopyField) onf).getDstOffset(), (int) ((OFActionOnfCopyField) onf).getSrc(), (int) ((OFActionOnfCopyField) onf).getDst());
                default:
                    throw new UnsupportedOperationException("Unexpected OFAction: " + action.toString());
            }
        }
        throw new UnsupportedOperationException("Unexpected OFAction: " + action.toString());
    }
    throw new UnsupportedOperationException("Unexpected OFAction: " + action.toString());
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("ofdpaAllowVlanTranslation", vlanTranslation).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("ofdpaSetAllowVlanTranslation", vlanTranslation).toString();
}
#end_block

#method_before
@Override
protected void execute() {
    service = get(IntentService.class);
    workPartitionService = get(WorkPartitionService.class);
    contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
    Iterable<Intent> intents;
    if (pending) {
        intents = service.getPending();
    } else {
        intents = service.getIntents();
    }
    // Remove intents
    if (remove != null && !remove.isEmpty()) {
        filter.add(remove);
        contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
        IntentRemoveCommand intentRemoveCmd = new IntentRemoveCommand();
        if (!remove.isEmpty()) {
            intentRemoveCmd.purgeIntentsInteractive(filterIntents(service));
        }
        return;
    }
    // Show detailed intents
    if (!intentIds.isEmpty()) {
        IntentDetailsCommand intentDetailsCmd = new IntentDetailsCommand();
        intentDetailsCmd.detailIntents(intentIds);
        return;
    }
    // Show brief intents
    if (intentsSummary || miniSummary) {
        Map<String, IntentSummary> summarized = summarize(intents);
        if (outputJson()) {
            ObjectNode summaries = mapper().createObjectNode();
            summarized.forEach((n, s) -> summaries.set(uncapitalize(n), s.json(mapper())));
            print("%s", summaries);
        } else if (miniSummary) {
            StringBuilder builder = new StringBuilder();
            builder.append(summarized.remove("All").miniSummary());
            summarized.values().forEach(s -> builder.append(s.miniSummary()));
            print("%s", builder.toString());
        } else {
            StringBuilder builder = new StringBuilder();
            builder.append(SUMMARY_TITLES);
            builder.append('\n').append(SEPARATOR);
            builder.append(summarized.remove("All").summary());
            summarized.values().forEach(s -> builder.append(s.summary()));
            print("%s", builder.toString());
        }
        return;
    }
    // JSON or default output
    if (outputJson()) {
        print("%s", json(intents));
    } else {
        for (Intent intent : intents) {
            IntentState state = service.getIntentState(intent.key());
            StringBuilder intentFormat = fullFormat(intent, state);
            StringBuilder detailsIntentFormat = detailsFormat(intent, state);
            String formatted = intentFormat.append(detailsIntentFormat).toString();
            if (contentFilter.filter(formatted)) {
                print("%s\n", formatted);
            }
        }
    }
}
#method_after
@Override
protected void execute() {
    service = get(IntentService.class);
    workPartitionService = get(WorkPartitionService.class);
    if (workPartitionService == null) {
        return;
    }
    contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
    Iterable<Intent> intents;
    if (pending) {
        intents = service.getPending();
    } else {
        intents = service.getIntents();
    }
    // Remove intents
    if (remove != null && !remove.isEmpty()) {
        filter.add(remove);
        contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
        IntentRemoveCommand intentRemoveCmd = new IntentRemoveCommand();
        if (!remove.isEmpty()) {
            intentRemoveCmd.purgeIntentsInteractive(filterIntents(service));
        }
        return;
    }
    // Show detailed intents
    if (!intentIds.isEmpty()) {
        IntentDetailsCommand intentDetailsCmd = new IntentDetailsCommand();
        intentDetailsCmd.detailIntents(intentIds);
        return;
    }
    // Show brief intents
    if (intentsSummary || miniSummary) {
        Map<String, IntentSummary> summarized = summarize(intents);
        if (outputJson()) {
            ObjectNode summaries = mapper().createObjectNode();
            summarized.forEach((n, s) -> summaries.set(uncapitalize(n), s.json(mapper())));
            print("%s", summaries);
        } else if (miniSummary) {
            StringBuilder builder = new StringBuilder();
            builder.append(summarized.remove("All").miniSummary());
            summarized.values().forEach(s -> builder.append(s.miniSummary()));
            print("%s", builder.toString());
        } else {
            StringBuilder builder = new StringBuilder();
            builder.append(SUMMARY_TITLES);
            builder.append('\n').append(SEPARATOR);
            builder.append(summarized.remove("All").summary());
            summarized.values().forEach(s -> builder.append(s.summary()));
            print("%s", builder.toString());
        }
        return;
    }
    // JSON or default output
    if (outputJson()) {
        print("%s", json(intents));
    } else {
        for (Intent intent : intents) {
            IntentState state = service.getIntentState(intent.key());
            StringBuilder intentFormat = fullFormat(intent, state);
            StringBuilder detailsIntentFormat = detailsFormat(intent, state);
            String formatted = intentFormat.append(detailsIntentFormat).toString();
            if (contentFilter.filter(formatted)) {
                print("%s\n", formatted);
            }
        }
    }
}
#end_block

#method_before
private StringBuilder fullFormat(Intent intent, IntentState state) {
    StringBuilder builder = new StringBuilder();
    NodeId nodeId = workPartitionService == null ? null : workPartitionService.getLeader(intent.key(), Key::hash);
    builder.append(format(ID, intent.id()));
    if (state != null) {
        builder.append('\n').append(format(STATE, state));
    }
    builder.append('\n').append(format(KEY, intent.key()));
    builder.append('\n').append(format(TYPE, intent.getClass().getSimpleName()));
    builder.append('\n').append(format(APP_ID, intent.appId().name()));
    if (nodeId != null) {
        builder.append('\n').append(format(LEADER_ID, nodeId.id()));
    }
    return builder;
}
#method_after
private StringBuilder fullFormat(Intent intent, IntentState state) {
    StringBuilder builder = new StringBuilder();
    NodeId nodeId = workPartitionService.getLeader(intent.key(), Key::hash);
    builder.append(format(ID, intent.id()));
    if (state != null) {
        builder.append('\n').append(format(STATE, state));
    }
    builder.append('\n').append(format(KEY, intent.key()));
    builder.append('\n').append(format(TYPE, intent.getClass().getSimpleName()));
    builder.append('\n').append(format(APP_ID, intent.appId().name()));
    builder.append('\n').append(nodeId == null ? NONE : format(LEADER_ID, nodeId.id()));
    return builder;
}
#end_block

#method_before
public DeviceEvent markOnline(DeviceId deviceId) {
    if (devices.containsKey(deviceId)) {
        availableDevices.add(deviceId);
    }
    log.warn("Device {} does not exist in store", deviceId);
    return null;
}
#method_after
public DeviceEvent markOnline(DeviceId deviceId) {
    if (devices.containsKey(deviceId)) {
        if (availableDevices.add(deviceId)) {
            return new DeviceEvent(DEVICE_AVAILABILITY_CHANGED, devices.get(deviceId), null);
        }
    }
    log.warn("Device {} does not exist in store", deviceId);
    return null;
}
#end_block

#method_before
@Activate
public void activate() {
    executor = newCachedThreadPool(groupedThreads("onos/device", "fg-%d", log));
    backgroundExecutor = newSingleThreadScheduledExecutor(minPriority(groupedThreads("onos/device", "bg-%d", log)));
    addSubscriber(DEVICE_UPDATE, this::handleDeviceEvent);
    addSubscriber(DEVICE_OFFLINE, this::handleDeviceOfflineEvent);
    addSubscriber(DEVICE_ONLINE, this::handleDeviceOnlineEvent);
    addSubscriber(DEVICE_REMOVE_REQ, this::handleRemoveRequest);
    addSubscriber(DEVICE_REMOVED, this::handleDeviceRemovedEvent);
    addSubscriber(PORT_UPDATE, this::handlePortEvent);
    addSubscriber(PORT_STATUS_UPDATE, this::handlePortStatusEvent);
    addSubscriber(DEVICE_ADVERTISE, this::handleDeviceAdvertisement);
    // start anti-entropy thread
    backgroundExecutor.scheduleAtFixedRate(new SendAdvertisementTask(), initialDelaySec, periodSec, TimeUnit.SECONDS);
    // Create a distributed map for port stats.
    KryoNamespace.Builder deviceDataSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).register(MultiValuedTimestamp.class);
    devicePortStats = storageService.<DeviceId, Map<PortNumber, PortStatistics>>eventuallyConsistentMapBuilder().withName("port-stats").withSerializer(deviceDataSerializer).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    devicePortDeltaStats = storageService.<DeviceId, Map<PortNumber, PortStatistics>>eventuallyConsistentMapBuilder().withName("port-stats-delta").withSerializer(deviceDataSerializer).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    devicePortStats.addListener(portStatsListener);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    executor = newCachedThreadPool(groupedThreads("onos/device", "fg-%d", log));
    backgroundExecutor = newSingleThreadScheduledExecutor(minPriority(groupedThreads("onos/device", "bg-%d", log)));
    addSubscriber(DEVICE_UPDATE, this::handleDeviceEvent);
    addSubscriber(DEVICE_STATUS_CHANGE, this::handleDeviceStatusChangeEvent);
    addSubscriber(DEVICE_REMOVE_REQ, this::handleRemoveRequest);
    addSubscriber(DEVICE_REMOVED, this::handleDeviceRemovedEvent);
    addSubscriber(PORT_UPDATE, this::handlePortEvent);
    addSubscriber(PORT_STATUS_UPDATE, this::handlePortStatusEvent);
    addSubscriber(DEVICE_ADVERTISE, this::handleDeviceAdvertisement);
    // start anti-entropy thread
    backgroundExecutor.scheduleAtFixedRate(new SendAdvertisementTask(), initialDelaySec, periodSec, TimeUnit.SECONDS);
    // Create a distributed map for port stats.
    KryoNamespace.Builder deviceDataSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).register(MultiValuedTimestamp.class);
    devicePortStats = storageService.<DeviceId, Map<PortNumber, PortStatistics>>eventuallyConsistentMapBuilder().withName("port-stats").withSerializer(deviceDataSerializer).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    devicePortDeltaStats = storageService.<DeviceId, Map<PortNumber, PortStatistics>>eventuallyConsistentMapBuilder().withName("port-stats-delta").withSerializer(deviceDataSerializer).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    devicePortStats.addListener(portStatsListener);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    devicePortStats.removeListener(portStatsListener);
    devicePortStats.destroy();
    devicePortDeltaStats.destroy();
    executor.shutdownNow();
    backgroundExecutor.shutdownNow();
    try {
        if (!backgroundExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
            log.error("Timeout during executor shutdown");
        }
    } catch (InterruptedException e) {
        log.error("Error during executor shutdown", e);
        Thread.currentThread().interrupt();
    }
    deviceDescs.clear();
    devices.clear();
    devicePorts.clear();
    availableDevices.clear();
    clusterCommunicator.removeSubscriber(DEVICE_UPDATE);
    clusterCommunicator.removeSubscriber(DEVICE_OFFLINE);
    clusterCommunicator.removeSubscriber(DEVICE_ONLINE);
    clusterCommunicator.removeSubscriber(DEVICE_REMOVE_REQ);
    clusterCommunicator.removeSubscriber(DEVICE_REMOVED);
    clusterCommunicator.removeSubscriber(PORT_UPDATE);
    clusterCommunicator.removeSubscriber(PORT_STATUS_UPDATE);
    clusterCommunicator.removeSubscriber(DEVICE_ADVERTISE);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    devicePortStats.removeListener(portStatsListener);
    devicePortStats.destroy();
    devicePortDeltaStats.destroy();
    executor.shutdownNow();
    backgroundExecutor.shutdownNow();
    try {
        if (!backgroundExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
            log.error("Timeout during executor shutdown");
        }
    } catch (InterruptedException e) {
        log.error("Error during executor shutdown", e);
        Thread.currentThread().interrupt();
    }
    deviceDescs.clear();
    devices.clear();
    devicePorts.clear();
    availableDevices.clear();
    clusterCommunicator.removeSubscriber(DEVICE_UPDATE);
    clusterCommunicator.removeSubscriber(DEVICE_STATUS_CHANGE);
    clusterCommunicator.removeSubscriber(DEVICE_REMOVE_REQ);
    clusterCommunicator.removeSubscriber(DEVICE_REMOVED);
    clusterCommunicator.removeSubscriber(PORT_UPDATE);
    clusterCommunicator.removeSubscriber(PORT_STATUS_UPDATE);
    clusterCommunicator.removeSubscriber(DEVICE_ADVERTISE);
    log.info("Stopped");
}
#end_block

#method_before
private DeviceEvent markOffline(DeviceId deviceId, Timestamp timestamp) {
    final DeviceEvent event = markOfflineInternal(deviceId, timestamp);
    if (event != null) {
        log.debug("Notifying peers of a device offline topology event for deviceId: {} {}", deviceId, timestamp);
        notifyPeers(new InternalDeviceOfflineEvent(deviceId, timestamp));
    }
    return event;
}
#method_after
private DeviceEvent markOffline(DeviceId deviceId, Timestamp timestamp) {
    final DeviceEvent event = markOfflineInternal(deviceId, timestamp);
    if (event != null) {
        log.debug("Notifying peers of a device offline topology event for deviceId: {} {}", deviceId, timestamp);
        notifyPeers(new InternalDeviceStatusChangeEvent(deviceId, timestamp, false));
    }
    return event;
}
#end_block

#method_before
private DeviceEvent markOnline(DeviceId deviceId, Timestamp timestamp, boolean notifyPeers) {
    final DeviceEvent event = markOnlineInternal(deviceId, timestamp);
    if (event != null && notifyPeers) {
        log.debug("Notifying peers of a device online topology event for deviceId: {} {}", deviceId, timestamp);
        notifyPeers(new InternalDeviceOnlineEvent(deviceId, timestamp));
    }
    return event;
}
#method_after
private DeviceEvent markOnline(DeviceId deviceId, Timestamp timestamp, boolean notifyPeers) {
    final DeviceEvent event = markOnlineInternal(deviceId, timestamp);
    if (event != null && notifyPeers) {
        log.debug("Notifying peers of a device online topology event for deviceId: {} {}", deviceId, timestamp);
        notifyPeers(new InternalDeviceStatusChangeEvent(deviceId, timestamp, true));
    }
    return event;
}
#end_block

#method_before
private void notifyPeers(InternalPortStatusEvent event) {
    broadcastMessage(GossipDeviceStoreMessageSubjects.PORT_STATUS_UPDATE, event);
}
#method_after
private void notifyPeers(InternalDeviceStatusChangeEvent event) {
    broadcastMessage(GossipDeviceStoreMessageSubjects.DEVICE_STATUS_CHANGE, event);
}
#end_block

#method_before
private void notifyPeer(NodeId recipient, InternalPortStatusEvent event) {
    try {
        unicastMessage(recipient, GossipDeviceStoreMessageSubjects.PORT_STATUS_UPDATE, event);
    } catch (IOException e) {
        log.error("Failed to send" + event + " to " + recipient, e);
    }
}
#method_after
private void notifyPeer(NodeId recipient, InternalDeviceStatusChangeEvent event) {
    try {
        unicastMessage(recipient, GossipDeviceStoreMessageSubjects.DEVICE_STATUS_CHANGE, event);
    } catch (IOException e) {
        log.error("Failed to send" + event + " to " + recipient, e);
    }
}
#end_block

#method_before
private void handleAdvertisement(DeviceAntiEntropyAdvertisement advertisement) {
    final NodeId sender = advertisement.sender();
    Map<DeviceFragmentId, Timestamp> devAds = new HashMap<>(advertisement.deviceFingerPrints());
    Map<PortFragmentId, Timestamp> portAds = new HashMap<>(advertisement.ports());
    Map<DeviceId, Timestamp> offlineAds = new HashMap<>(advertisement.offline());
    // Fragments to request
    Collection<DeviceFragmentId> reqDevices = new ArrayList<>();
    Collection<PortFragmentId> reqPorts = new ArrayList<>();
    for (Entry<DeviceId, Map<ProviderId, DeviceDescriptions>> de : deviceDescs.entrySet()) {
        final DeviceId deviceId = de.getKey();
        final Map<ProviderId, DeviceDescriptions> lDevice = de.getValue();
        synchronized (lDevice) {
            // latestTimestamp across provider
            // Note: can be null initially
            Timestamp localLatest = offline.get(deviceId);
            // handle device Ads
            for (Entry<ProviderId, DeviceDescriptions> prov : lDevice.entrySet()) {
                final ProviderId provId = prov.getKey();
                final DeviceDescriptions lDeviceDescs = prov.getValue();
                final DeviceFragmentId devFragId = new DeviceFragmentId(deviceId, provId);
                Timestamped<DeviceDescription> lProvDevice = lDeviceDescs.getDeviceDesc();
                Timestamp advDevTimestamp = devAds.get(devFragId);
                if (advDevTimestamp == null || lProvDevice.isNewerThan(advDevTimestamp)) {
                    // remote does not have it or outdated, suggest
                    notifyPeer(sender, new InternalDeviceEvent(provId, deviceId, lProvDevice));
                } else if (!lProvDevice.timestamp().equals(advDevTimestamp)) {
                    // local is outdated, request
                    reqDevices.add(devFragId);
                }
                // handle port Ads
                for (Entry<PortNumber, Timestamped<PortDescription>> pe : lDeviceDescs.getPortDescs().entrySet()) {
                    final PortNumber num = pe.getKey();
                    final Timestamped<PortDescription> lPort = pe.getValue();
                    final PortFragmentId portFragId = new PortFragmentId(deviceId, provId, num);
                    Timestamp advPortTimestamp = portAds.get(portFragId);
                    if (advPortTimestamp == null || lPort.isNewerThan(advPortTimestamp)) {
                        // remote does not have it or outdated, suggest
                        notifyPeer(sender, new InternalPortStatusEvent(provId, deviceId, lPort));
                    } else if (!lPort.timestamp().equals(advPortTimestamp)) {
                        // local is outdated, request
                        log.trace("need update {} < {}", lPort.timestamp(), advPortTimestamp);
                        reqPorts.add(portFragId);
                    }
                    // remove port Ad already processed
                    portAds.remove(portFragId);
                }
                // end local port loop
                // remove device Ad already processed
                devAds.remove(devFragId);
                // find latest and update
                final Timestamp providerLatest = lDeviceDescs.getLatestTimestamp();
                if (localLatest == null || providerLatest.compareTo(localLatest) > 0) {
                    localLatest = providerLatest;
                }
            }
            // end local provider loop
            // checking if remote timestamp is more recent.
            Timestamp rOffline = offlineAds.get(deviceId);
            if (localLatest == null || (rOffline != null && rOffline.compareTo(localLatest) > 0)) {
                // remote offline timestamp suggests that the
                // device is off-line
                markOfflineInternal(deviceId, rOffline);
            }
            Timestamp lOffline = offline.get(deviceId);
            if (lOffline != null && rOffline == null) {
                // locally offline, but remote is online, suggest offline
                notifyPeer(sender, new InternalDeviceOfflineEvent(deviceId, lOffline));
            }
            // remove device offline Ad already processed
            offlineAds.remove(deviceId);
        }
    // end local device loop
    }
    // device lock
    // If there is any Ads left, request them
    log.trace("Ads left {}, {}", devAds, portAds);
    reqDevices.addAll(devAds.keySet());
    reqPorts.addAll(portAds.keySet());
    if (reqDevices.isEmpty() && reqPorts.isEmpty()) {
        log.trace("Nothing to request to remote peer {}", sender);
        return;
    }
    log.debug("Need to sync {} {}", reqDevices, reqPorts);
    // 2-way Anti-Entropy for now
    try {
        unicastMessage(sender, DEVICE_ADVERTISE, createAdvertisement());
    } catch (IOException e) {
        log.error("Failed to send response advertisement to " + sender, e);
    }
// Sketch of 3-way Anti-Entropy
// DeviceAntiEntropyRequest request = new DeviceAntiEntropyRequest(self, reqDevices, reqPorts);
// ClusterMessage message = new ClusterMessage(
// clusterService.getLocalNode().id(),
// GossipDeviceStoreMessageSubjects.DEVICE_REQUEST,
// SERIALIZER.encode(request));
// 
// try {
// clusterCommunicator.unicast(message, advertisement.sender());
// } catch (IOException e) {
// log.error("Failed to send advertisement reply to "
// + advertisement.sender(), e);
// }
}
#method_after
private void handleAdvertisement(DeviceAntiEntropyAdvertisement advertisement) {
    final NodeId sender = advertisement.sender();
    Map<DeviceFragmentId, Timestamp> devAds = new HashMap<>(advertisement.deviceFingerPrints());
    Map<PortFragmentId, Timestamp> portAds = new HashMap<>(advertisement.ports());
    Map<DeviceId, Timestamp> offlineAds = new HashMap<>(advertisement.offline());
    // Fragments to request
    Collection<DeviceFragmentId> reqDevices = new ArrayList<>();
    Collection<PortFragmentId> reqPorts = new ArrayList<>();
    for (Entry<DeviceId, Map<ProviderId, DeviceDescriptions>> de : deviceDescs.entrySet()) {
        final DeviceId deviceId = de.getKey();
        final Map<ProviderId, DeviceDescriptions> lDevice = de.getValue();
        synchronized (lDevice) {
            // latestTimestamp across provider
            // Note: can be null initially
            Timestamp localLatest = offline.get(deviceId);
            // handle device Ads
            for (Entry<ProviderId, DeviceDescriptions> prov : lDevice.entrySet()) {
                final ProviderId provId = prov.getKey();
                final DeviceDescriptions lDeviceDescs = prov.getValue();
                final DeviceFragmentId devFragId = new DeviceFragmentId(deviceId, provId);
                Timestamped<DeviceDescription> lProvDevice = lDeviceDescs.getDeviceDesc();
                Timestamp advDevTimestamp = devAds.get(devFragId);
                if (advDevTimestamp == null || lProvDevice.isNewerThan(advDevTimestamp)) {
                    // remote does not have it or outdated, suggest
                    notifyPeer(sender, new InternalDeviceEvent(provId, deviceId, lProvDevice));
                } else if (!lProvDevice.timestamp().equals(advDevTimestamp)) {
                    // local is outdated, request
                    reqDevices.add(devFragId);
                }
                // handle port Ads
                for (Entry<PortNumber, Timestamped<PortDescription>> pe : lDeviceDescs.getPortDescs().entrySet()) {
                    final PortNumber num = pe.getKey();
                    final Timestamped<PortDescription> lPort = pe.getValue();
                    final PortFragmentId portFragId = new PortFragmentId(deviceId, provId, num);
                    Timestamp advPortTimestamp = portAds.get(portFragId);
                    if (advPortTimestamp == null || lPort.isNewerThan(advPortTimestamp)) {
                        // remote does not have it or outdated, suggest
                        notifyPeer(sender, new InternalPortStatusEvent(provId, deviceId, lPort));
                    } else if (!lPort.timestamp().equals(advPortTimestamp)) {
                        // local is outdated, request
                        log.trace("need update {} < {}", lPort.timestamp(), advPortTimestamp);
                        reqPorts.add(portFragId);
                    }
                    // remove port Ad already processed
                    portAds.remove(portFragId);
                }
                // end local port loop
                // remove device Ad already processed
                devAds.remove(devFragId);
                // find latest and update
                final Timestamp providerLatest = lDeviceDescs.getLatestTimestamp();
                if (localLatest == null || providerLatest.compareTo(localLatest) > 0) {
                    localLatest = providerLatest;
                }
            }
            // end local provider loop
            // checking if remote timestamp is more recent.
            Timestamp rOffline = offlineAds.get(deviceId);
            if (localLatest == null || (rOffline != null && rOffline.compareTo(localLatest) > 0)) {
                // remote offline timestamp suggests that the
                // device is off-line
                markOfflineInternal(deviceId, rOffline);
            }
            Timestamp lOffline = offline.get(deviceId);
            if (lOffline != null && rOffline == null) {
                // locally offline, but remote is online, suggest offline
                notifyPeer(sender, new InternalDeviceStatusChangeEvent(deviceId, lOffline, false));
            }
            // remove device offline Ad already processed
            offlineAds.remove(deviceId);
        }
    // end local device loop
    }
    // device lock
    // If there is any Ads left, request them
    log.trace("Ads left {}, {}", devAds, portAds);
    reqDevices.addAll(devAds.keySet());
    reqPorts.addAll(portAds.keySet());
    if (reqDevices.isEmpty() && reqPorts.isEmpty()) {
        log.trace("Nothing to request to remote peer {}", sender);
        return;
    }
    log.debug("Need to sync {} {}", reqDevices, reqPorts);
    // 2-way Anti-Entropy for now
    try {
        unicastMessage(sender, DEVICE_ADVERTISE, createAdvertisement());
    } catch (IOException e) {
        log.error("Failed to send response advertisement to " + sender, e);
    }
// Sketch of 3-way Anti-Entropy
// DeviceAntiEntropyRequest request = new DeviceAntiEntropyRequest(self, reqDevices, reqPorts);
// ClusterMessage message = new ClusterMessage(
// clusterService.getLocalNode().id(),
// GossipDeviceStoreMessageSubjects.DEVICE_REQUEST,
// SERIALIZER.encode(request));
// 
// try {
// clusterCommunicator.unicast(message, advertisement.sender());
// } catch (IOException e) {
// log.error("Failed to send advertisement reply to "
// + advertisement.sender(), e);
// }
}
#end_block

#method_before
public VlanId innerVlan() {
    return innerVlan;
}
#method_after
@Override
public VlanId innerVlan() {
    return innerVlan;
}
#end_block

#method_before
public short tpid() {
    return tpid;
}
#method_after
@Override
public EthType tpid() {
    return tpid;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultHost) {
        final DefaultHost other = (DefaultHost) obj;
        return Objects.equals(this.id, other.id) && Objects.equals(this.mac, other.mac) && Objects.equals(this.vlan, other.vlan) && Objects.equals(this.locations, other.locations) && Objects.equals(this.ipAddresses(), other.ipAddresses()) && Objects.equals(this.configured(), other.configured()) && Objects.equals(this.innerVlan(), other.innerVlan()) && Objects.equals(this.tpid(), other.tpid()) && Objects.equals(this.annotations(), other.annotations());
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultHost) {
        final DefaultHost other = (DefaultHost) obj;
        return Objects.equals(this.id, other.id) && Objects.equals(this.mac, other.mac) && Objects.equals(this.vlan, other.vlan) && Objects.equals(this.locations, other.locations) && Objects.equals(this.ipAddresses(), other.ipAddresses()) && Objects.equals(this.innerVlan, other.innerVlan) && Objects.equals(this.tpid, other.tpid) && Objects.equals(this.annotations(), other.annotations());
    }
    return false;
}
#end_block

#method_before
private static PiTableEntry decodeTableEntryMsg(TableEntry tableEntryMsg, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    PiTableEntry.Builder piTableEntryBuilder = PiTableEntry.builder();
    P4InfoOuterClass.Table tableInfo = browser.tables().getById(tableEntryMsg.getTableId());
    // Table id.
    piTableEntryBuilder.forTable(PiTableId.of(tableInfo.getPreamble().getName()));
    // Priority.
    piTableEntryBuilder.withPriority(tableEntryMsg.getPriority());
    // Controller metadata (cookie)
    piTableEntryBuilder.withCookie(tableEntryMsg.getControllerMetadata());
    // Table action.
    if (tableEntryMsg.hasAction()) {
        piTableEntryBuilder.withAction(decodeTableActionMsg(tableEntryMsg.getAction(), browser));
    } else {
        piTableEntryBuilder.withNoAction();
    }
    // Timeout.
    // FIXME: how to decode table entry messages with timeout, given that the timeout value is lost after encoding?
    // Match key for field matches.
    piTableEntryBuilder.withMatchKey(decodeFieldMatchMsgs(tableEntryMsg.getMatchList(), tableInfo, browser));
    return piTableEntryBuilder.build();
}
#method_after
private static PiTableEntry decodeTableEntryMsg(TableEntry tableEntryMsg, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    PiTableEntry.Builder piTableEntryBuilder = PiTableEntry.builder();
    P4InfoOuterClass.Table tableInfo = browser.tables().getById(tableEntryMsg.getTableId());
    // Table id.
    piTableEntryBuilder.forTable(PiTableId.of(tableInfo.getPreamble().getName()));
    // Priority.
    piTableEntryBuilder.withPriority(tableEntryMsg.getPriority());
    // Controller metadata (cookie)
    piTableEntryBuilder.withCookie(tableEntryMsg.getControllerMetadata());
    // Table action.
    if (tableEntryMsg.hasAction()) {
        piTableEntryBuilder.withAction(decodeTableActionMsg(tableEntryMsg.getAction(), browser));
    }
    // Timeout.
    // FIXME: how to decode table entry messages with timeout, given that the timeout value is lost after encoding?
    // Match key for field matches.
    piTableEntryBuilder.withMatchKey(decodeFieldMatchMsgs(tableEntryMsg.getMatchList(), tableInfo, browser));
    return piTableEntryBuilder.build();
}
#end_block

#method_before
static TableAction encodePiTableAction(PiTableAction piTableAction, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    checkNotNull(piTableAction);
    TableAction.Builder tableActionMsgBuilder = TableAction.newBuilder();
    switch(piTableAction.type()) {
        case ACTION:
            PiAction piAction = (PiAction) piTableAction;
            Action theAction = encodePiAction(piAction, browser);
            tableActionMsgBuilder.setAction(theAction);
            break;
        case ACTION_GROUP_ID:
            PiActionGroupId actionGroupId = (PiActionGroupId) piTableAction;
            tableActionMsgBuilder.setActionProfileGroupId(actionGroupId.id());
            break;
        case GROUP_MEMBER_ID:
            PiActionGroupMemberId actionGroupMemberId = (PiActionGroupMemberId) piTableAction;
            tableActionMsgBuilder.setActionProfileMemberId(actionGroupMemberId.id());
            break;
        default:
            throw new EncodeException(format("Building of table action type %s not implemented", piTableAction.type()));
    }
    return tableActionMsgBuilder.build();
}
#method_after
static TableAction encodePiTableAction(PiTableAction piTableAction, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    checkNotNull(piTableAction, "Cannot encode null PiTableAction");
    TableAction.Builder tableActionMsgBuilder = TableAction.newBuilder();
    switch(piTableAction.type()) {
        case ACTION:
            PiAction piAction = (PiAction) piTableAction;
            Action theAction = encodePiAction(piAction, browser);
            tableActionMsgBuilder.setAction(theAction);
            break;
        case ACTION_GROUP_ID:
            PiActionGroupId actionGroupId = (PiActionGroupId) piTableAction;
            tableActionMsgBuilder.setActionProfileGroupId(actionGroupId.id());
            break;
        case GROUP_MEMBER_ID:
            PiActionGroupMemberId actionGroupMemberId = (PiActionGroupMemberId) piTableAction;
            tableActionMsgBuilder.setActionProfileMemberId(actionGroupMemberId.id());
            break;
        default:
            throw new EncodeException(format("Building of table action type %s not implemented", piTableAction.type()));
    }
    return tableActionMsgBuilder.build();
}
#end_block

#method_before
static PiTableEntry translate(FlowRule rule, PiPipeconf pipeconf, Device device) throws PiTranslationException {
    PiPipelineModel pipelineModel = pipeconf.pipelineModel();
    // Retrieve interpreter, if any.
    final PiPipelineInterpreter interpreter = getInterpreterOrNull(device, pipeconf);
    // Get table model.
    final PiTableId piTableId = translateTableId(rule.table(), interpreter);
    final PiTableModel tableModel = getTableModel(piTableId, pipelineModel);
    // Translate selector.
    final PiMatchKey piMatchKey;
    final boolean needPriority;
    if (rule.selector().criteria().isEmpty()) {
        piMatchKey = PiMatchKey.EMPTY;
        needPriority = false;
    } else {
        final Collection<PiFieldMatch> fieldMatches = translateFieldMatches(interpreter, rule.selector(), tableModel);
        piMatchKey = PiMatchKey.builder().addFieldMatches(fieldMatches).build();
        // FIXME: P4Runtime limit
        // Need to ignore priority if no TCAM lookup match field
        needPriority = fieldMatches.stream().anyMatch(match -> match.type() == PiMatchType.TERNARY || match.type() == PiMatchType.RANGE);
    }
    // Translate treatment.
    final PiTableAction piTableAction = translateTreatment(rule.treatment(), interpreter, piTableId, pipelineModel);
    // Build PI entry.
    final PiTableEntry.Builder tableEntryBuilder = PiTableEntry.builder();
    tableEntryBuilder.forTable(piTableId).withMatchKey(piMatchKey).withAction(piTableAction);
    if (piTableAction != null) {
        tableEntryBuilder.withAction(piTableAction);
    } else {
        tableEntryBuilder.withNoAction();
    }
    if (needPriority) {
        tableEntryBuilder.withPriority(rule.priority());
    }
    if (!rule.isPermanent()) {
        if (tableModel.supportsAging()) {
            tableEntryBuilder.withTimeout((double) rule.timeout());
        } else {
            log.warn("Flow rule is temporary, but table '{}' doesn't support " + "aging, translating to permanent.", tableModel.id());
        }
    }
    return tableEntryBuilder.build();
}
#method_after
static PiTableEntry translate(FlowRule rule, PiPipeconf pipeconf, Device device) throws PiTranslationException {
    PiPipelineModel pipelineModel = pipeconf.pipelineModel();
    // Retrieve interpreter, if any.
    final PiPipelineInterpreter interpreter = getInterpreterOrNull(device, pipeconf);
    // Get table model.
    final PiTableId piTableId = translateTableId(rule.table(), interpreter);
    final PiTableModel tableModel = getTableModel(piTableId, pipelineModel);
    // Translate selector.
    final PiMatchKey piMatchKey;
    final boolean needPriority;
    if (rule.selector().criteria().isEmpty()) {
        piMatchKey = PiMatchKey.EMPTY;
        needPriority = false;
    } else {
        final Collection<PiFieldMatch> fieldMatches = translateFieldMatches(interpreter, rule.selector(), tableModel);
        piMatchKey = PiMatchKey.builder().addFieldMatches(fieldMatches).build();
        // FIXME: P4Runtime limit
        // Need to ignore priority if no TCAM lookup match field
        needPriority = fieldMatches.stream().anyMatch(match -> match.type() == PiMatchType.TERNARY || match.type() == PiMatchType.RANGE);
    }
    // Translate treatment.
    final PiTableAction piTableAction = translateTreatment(rule.treatment(), interpreter, piTableId, pipelineModel);
    // Build PI entry.
    final PiTableEntry.Builder tableEntryBuilder = PiTableEntry.builder();
    tableEntryBuilder.forTable(piTableId).withMatchKey(piMatchKey).withAction(piTableAction);
    if (piTableAction != null) {
        tableEntryBuilder.withAction(piTableAction);
    }
    if (needPriority) {
        tableEntryBuilder.withPriority(rule.priority());
    }
    if (!rule.isPermanent()) {
        if (tableModel.supportsAging()) {
            tableEntryBuilder.withTimeout((double) rule.timeout());
        } else {
            log.warn("Flow rule is temporary, but table '{}' doesn't support " + "aging, translating to permanent.", tableModel.id());
        }
    }
    return tableEntryBuilder.build();
}
#end_block

#method_before
private static PiTableAction typeCheckAction(PiTableAction piTableAction, PiTableModel table) throws PiTranslationException {
    if (piTableAction == null) {
        // skip table action if null
        return null;
    }
    switch(piTableAction.type()) {
        case ACTION:
            return checkPiAction((PiAction) piTableAction, table);
        default:
            // FIXME: should we check? how?
            return piTableAction;
    }
}
#method_after
private static PiTableAction typeCheckAction(PiTableAction piTableAction, PiTableModel table) throws PiTranslationException {
    if (piTableAction == null) {
        // skip check if null
        return null;
    }
    switch(piTableAction.type()) {
        case ACTION:
            return checkPiAction((PiAction) piTableAction, table);
        default:
            // FIXME: should we check? how?
            return piTableAction;
    }
}
#end_block

#method_before
public Builder forTable(PiTableId tableId) {
    this.tableId = checkNotNull(tableId);
    return this;
}
#method_after
public Builder forTable(PiTableId tableId) {
    this.tableId = checkNotNull(tableId, "Table ID cannot be null");
    return this;
}
#end_block

#method_before
public Builder withAction(PiTableAction tableAction) {
    this.tableAction = checkNotNull(tableAction);
    return this;
}
#method_after
public Builder withAction(PiTableAction tableAction) {
    this.tableAction = checkNotNull(tableAction, "Action cannot be null");
    return this;
}
#end_block

#method_before
public Builder withMatchKey(PiMatchKey matchKey) {
    this.matchKey = matchKey;
    return this;
}
#method_after
public Builder withMatchKey(PiMatchKey matchKey) {
    this.matchKey = checkNotNull(matchKey, "Match key cannot be null");
    return this;
}
#end_block

#method_before
public PiTableEntry build() {
    checkNotNull(tableId);
    return new PiTableEntry(tableId, matchKey, tableAction, cookie, priority, timeout);
}
#method_after
public PiTableEntry build() {
    checkNotNull(tableId);
    checkNotNull(matchKey);
    return new PiTableEntry(tableId, matchKey, tableAction, cookie, priority, timeout);
}
#end_block

#method_before
@Override
public String localStatus(DeviceId deviceId) {
    checkPermission(DEVICE_READ);
    checkNotNull(deviceId, DEVICE_ID_NULL);
    DeviceStore.LocalStatus ls = store.getDeviceLocalStatus(deviceId);
    if (ls == null) {
        return "No Record";
    }
    String timeAgo = Tools.timeAgo(ls.dateTime.toEpochMilli());
    return (ls.connected) ? "connected " + timeAgo : "disconnected " + timeAgo;
}
#method_after
@Override
public String localStatus(DeviceId deviceId) {
    LocalStatus ls = deviceLocalStatus.get(deviceId);
    if (ls == null) {
        return "No Record";
    }
    String timeAgo = Tools.timeAgo(ls.dateTime.toEpochMilli());
    return (ls.connected) ? "connected " + timeAgo : "disconnected " + timeAgo;
}
#end_block

#method_before
@Override
public long getLastUpdatedInstant(DeviceId deviceId) {
    DeviceStore.LocalStatus ls = store.getDeviceLocalStatus(deviceId);
    if (ls == null) {
        return 0;
    }
    return ls.dateTime.toEpochMilli();
}
#method_after
@Override
public long getLastUpdatedInstant(DeviceId deviceId) {
    LocalStatus ls = deviceLocalStatus.get(deviceId);
    if (ls == null) {
        return 0;
    }
    return ls.dateTime.toEpochMilli();
}
#end_block

#method_before
private boolean isReachable(DeviceId deviceId) {
    if (deviceId == null) {
        return false;
    }
    DeviceProvider provider = getProvider(deviceId);
    if (provider != null) {
        return provider.isReachable(deviceId);
    } else {
        log.debug("Provider not found for {}", deviceId);
        return false;
    }
}
#method_after
// Check a device for control channel connectivity
private boolean isReachable(DeviceId deviceId) {
    if (deviceId == null) {
        return false;
    }
    DeviceProvider provider = getProvider(deviceId);
    if (provider != null) {
        boolean reachable = provider.isReachable(deviceId);
        if (reachable && !isLocallyConnected(deviceId)) {
            deviceLocalStatus.put(deviceId, new LocalStatus(true, Instant.now()));
        } else if (!reachable && isLocallyConnected(deviceId)) {
            deviceLocalStatus.put(deviceId, new LocalStatus(false, Instant.now()));
        }
        return reachable;
    } else {
        log.debug("Provider not found for {}", deviceId);
        return false;
    }
}
#end_block

#method_before
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    store.setDeviceLocalStatus(deviceId, true);
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    PortDescriptionsConfig portConfig = networkConfigService.getConfig(deviceId, PortDescriptionsConfig.class);
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    DeviceAnnotationConfig annoConfig = networkConfigService.getConfig(deviceId, DeviceAnnotationConfig.class);
    if (annoConfig != null) {
        deviceDescription = deviceAnnotationOp.combine(deviceId, deviceDescription, Optional.of(annoConfig));
    }
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    if (portConfig != null) {
        // updating the ports if configration exists
        List<PortDescription> complete = store.getPortDescriptions(provider().id(), deviceId).collect(Collectors.toList());
        complete.addAll(portConfig.portDescriptions());
        List<PortDescription> portDescriptions = complete.stream().map(e -> applyAllPortOps(deviceId, e)).collect(Collectors.toList());
        store.updatePorts(provider().id(), deviceId, portDescriptions);
    }
    if (deviceDescription.isDefaultAvailable()) {
        log.info("Device {} connected", deviceId);
    } else {
        log.info("Device {} registered", deviceId);
    }
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#method_after
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    deviceLocalStatus.put(deviceId, new LocalStatus(true, Instant.now()));
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    PortDescriptionsConfig portConfig = networkConfigService.getConfig(deviceId, PortDescriptionsConfig.class);
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    DeviceAnnotationConfig annoConfig = networkConfigService.getConfig(deviceId, DeviceAnnotationConfig.class);
    if (annoConfig != null) {
        deviceDescription = deviceAnnotationOp.combine(deviceId, deviceDescription, Optional.of(annoConfig));
    }
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    if (portConfig != null) {
        // updating the ports if configration exists
        List<PortDescription> complete = store.getPortDescriptions(provider().id(), deviceId).collect(Collectors.toList());
        complete.addAll(portConfig.portDescriptions());
        List<PortDescription> portDescriptions = complete.stream().map(e -> applyAllPortOps(deviceId, e)).collect(Collectors.toList());
        store.updatePorts(provider().id(), deviceId, portDescriptions);
    }
    if (deviceDescription.isDefaultAvailable()) {
        log.info("Device {} connected", deviceId);
    } else {
        log.info("Device {} registered", deviceId);
    }
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#end_block

#method_before
@Override
public void deviceDisconnected(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkValidity();
    store.setDeviceLocalStatus(deviceId, false);
    log.info("Device {} disconnected from this node", deviceId);
    List<PortDescription> descs = store.getPortDescriptions(provider().id(), deviceId).map(desc -> ensurePortEnabledState(desc, false)).collect(Collectors.toList());
    store.updatePorts(this.provider().id(), deviceId, descs);
    try {
        if (mastershipService.isLocalMaster(deviceId)) {
            post(store.markOffline(deviceId));
        }
    } catch (IllegalStateException e) {
        log.warn("Failed to mark {} offline", deviceId);
        // only the MASTER should be marking off-line in normal cases,
        // but if I was the last STANDBY connection, etc. and no one else
        // was there to mark the device offline, this instance may need to
        // temporarily request for Master Role and mark offline.
        // there are times when this node will correctly have mastership, BUT
        // that isn't reflected in the ClockManager before the device disconnects.
        // we want to let go of the device anyways, so make sure this happens.
        // FIXME: Store semantics leaking out as IllegalStateException.
        // Consider revising store API to handle this scenario.
        CompletableFuture<MastershipRole> roleFuture = mastershipService.requestRoleFor(deviceId);
        roleFuture.whenComplete((role, error) -> {
            MastershipTerm term = termService.getMastershipTerm(deviceId);
            // TODO: Move this type of check inside device clock manager, etc.
            if (term != null && localNodeId.equals(term.master())) {
                log.info("Retry marking {} offline", deviceId);
                post(store.markOffline(deviceId));
            } else {
                log.info("Failed again marking {} offline. {}", deviceId, role);
            }
        });
    } finally {
        try {
            // relinquish master role and ability to be backup.
            mastershipService.relinquishMastership(deviceId).get();
        } catch (InterruptedException e) {
            log.warn("Interrupted while reliquishing role for {}", deviceId);
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            log.error("Exception thrown while relinquishing role for {}", deviceId, e);
        }
    }
}
#method_after
@Override
public void deviceDisconnected(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkValidity();
    deviceLocalStatus.put(deviceId, new LocalStatus(false, Instant.now()));
    log.info("Device {} disconnected from this node", deviceId);
    List<PortDescription> descs = store.getPortDescriptions(provider().id(), deviceId).map(desc -> ensurePortEnabledState(desc, false)).collect(Collectors.toList());
    store.updatePorts(this.provider().id(), deviceId, descs);
    try {
        if (mastershipService.isLocalMaster(deviceId)) {
            post(store.markOffline(deviceId));
        }
    } catch (IllegalStateException e) {
        log.warn("Failed to mark {} offline", deviceId);
        // only the MASTER should be marking off-line in normal cases,
        // but if I was the last STANDBY connection, etc. and no one else
        // was there to mark the device offline, this instance may need to
        // temporarily request for Master Role and mark offline.
        // there are times when this node will correctly have mastership, BUT
        // that isn't reflected in the ClockManager before the device disconnects.
        // we want to let go of the device anyways, so make sure this happens.
        // FIXME: Store semantics leaking out as IllegalStateException.
        // Consider revising store API to handle this scenario.
        CompletableFuture<MastershipRole> roleFuture = mastershipService.requestRoleFor(deviceId);
        roleFuture.whenComplete((role, error) -> {
            MastershipTerm term = termService.getMastershipTerm(deviceId);
            // TODO: Move this type of check inside device clock manager, etc.
            if (term != null && localNodeId.equals(term.master())) {
                log.info("Retry marking {} offline", deviceId);
                post(store.markOffline(deviceId));
            } else {
                log.info("Failed again marking {} offline. {}", deviceId, role);
            }
        });
    } finally {
        try {
            // relinquish master role and ability to be backup.
            mastershipService.relinquishMastership(deviceId).get();
        } catch (InterruptedException e) {
            log.warn("Interrupted while reliquishing role for {}", deviceId);
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            log.error("Exception thrown while relinquishing role for {}", deviceId, e);
        }
    }
}
#end_block

#method_before
@Override
public void notify(DeviceEvent event) {
    post(event);
    if (event.type().equals(DeviceEvent.Type.DEVICE_REMOVED)) {
        store.removeDeviceLocalStatus(event.subject().id());
    }
}
#method_after
@Override
public void notify(DeviceEvent event) {
    post(event);
    if (event.type().equals(DeviceEvent.Type.DEVICE_REMOVED)) {
        deviceLocalStatus.remove(event.subject().id());
    }
}
#end_block

#method_before
public HostId sink() {
    return sink;
}
#method_after
public ConnectPoint sink() {
    return sink;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof McastCacheKey)) {
        return false;
    }
    McastCacheKey that = (McastCacheKey) o;
    return (Objects.equals(this.mcastIp, that.mcastIp) && Objects.equals(this.sink, that.sink));
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof McastCacheKey)) {
        return false;
    }
    McastCacheKey that = (McastCacheKey) o;
    return (Objects.equals(this.mcastIp, that.mcastIp) && Objects.equals(this.sink, that.sink) && Objects.equals(this.sinkHost, that.sinkHost));
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(getClass()).add("mcastIp", mcastIp).add("sink", sink).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(getClass()).add("mcastIp", mcastIp).add("sink", sink).add("sinkHost", sinkHost).toString();
}
#end_block

#method_before
public void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, INGRESS).stream().findAny().orElse(null);
            Set<DeviceId> transitDevices = getDevice(mcastIp, TRANSIT);
            Set<DeviceId> egressDevices = getDevice(mcastIp, EGRESS);
            ConnectPoint source = mcastUtils.getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.debug("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Remove entire transit
            transitDevices.forEach(transitDevice -> removeGroupFromDevice(transitDevice, mcastIp, mcastUtils.assignedVlan(null)));
            // Remove transit-facing ports on the ingress device
            removeIngressTransitPorts(mcastIp, ingressDevice, source);
            // Compute mcast tree for the the egress devices
            Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, egressDevices);
            // We have to verify, if there are egresses without paths
            Set<DeviceId> notRecovered = Sets.newHashSet();
            mcastTree.forEach((egressDevice, paths) -> {
                // Let's check if there is at least a path
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths);
                // No paths, we have to try with alternative location
                if (!mcastPath.isPresent()) {
                    notRecovered.add(egressDevice);
                    // We were not able to find an alternative path for this egress
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, mcastUtils.assignedVlan(null));
                }
            });
            // Fast path, we can recover all the locations
            if (notRecovered.isEmpty()) {
                // Construct a new path for each egress device
                mcastTree.forEach((egressDevice, paths) -> {
                    // We try to enforce the sinks path on the mcast tree
                    Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths);
                    // If a path is present, let's install it
                    if (mcastPath.isPresent()) {
                        installPath(mcastIp, source, mcastPath.get());
                    }
                });
            } else {
                // Let's try to recover using alternate
                recoverSinks(egressDevices, notRecovered, mcastIp, ingressDevice, source, true);
            }
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
public void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, INGRESS).stream().findAny().orElse(null);
            Set<DeviceId> transitDevices = getDevice(mcastIp, TRANSIT);
            Set<DeviceId> egressDevices = getDevice(mcastIp, EGRESS);
            ConnectPoint source = mcastUtils.getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.debug("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Remove entire transit
            transitDevices.forEach(transitDevice -> removeGroupFromDevice(transitDevice, mcastIp, mcastUtils.assignedVlan(null)));
            // Remove transit-facing ports on the ingress device
            removeIngressTransitPorts(mcastIp, ingressDevice, source);
            // TODO create a shared procedure with DEVICE_DOWN
            // Compute mcast tree for the the egress devices
            Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, egressDevices);
            // We have to verify, if there are egresses without paths
            Set<DeviceId> notRecovered = Sets.newHashSet();
            mcastTree.forEach((egressDevice, paths) -> {
                // Let's check if there is at least a path
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths);
                // No paths, we have to try with alternative location
                if (!mcastPath.isPresent()) {
                    notRecovered.add(egressDevice);
                    // We were not able to find an alternative path for this egress
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, mcastUtils.assignedVlan(null));
                }
            });
            // Fast path, we can recover all the locations
            if (notRecovered.isEmpty()) {
                // Construct a new path for each egress device
                mcastTree.forEach((egressDevice, paths) -> {
                    // We try to enforce the sinks path on the mcast tree
                    Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths);
                    // If a path is present, let's install it
                    if (mcastPath.isPresent()) {
                        installPath(mcastIp, source, mcastPath.get());
                    }
                });
            } else {
                // Let's try to recover using alternate
                recoverSinks(egressDevices, notRecovered, mcastIp, ingressDevice, source, true);
            }
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void recoverSinks(Set<DeviceId> egressDevices, Set<DeviceId> notRecovered, IpAddress mcastIp, DeviceId ingressDevice, ConnectPoint source, boolean isLinkFailure) {
    // Recovered devices
    Set<DeviceId> recovered = Sets.difference(egressDevices, notRecovered);
    // Total affected sinks
    Set<ConnectPoint> totalAffectedSinks = Sets.newHashSet();
    // Total sinks
    Set<ConnectPoint> totalSinks = Sets.newHashSet();
    // Let's compute all the affected sinks and all the sinks
    notRecovered.forEach(deviceId -> {
        Set<ConnectPoint> currentAffectedConnectPoints = mcastUtils.getAffectedSinks(deviceId, mcastIp).values().stream().flatMap(Collection::stream).filter(connectPoint -> connectPoint.deviceId().equals(deviceId)).collect(Collectors.toSet());
        Set<ConnectPoint> currentConnectPoints = mcastUtils.getAffectedSinks(deviceId, mcastIp).values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
        totalAffectedSinks.addAll(currentAffectedConnectPoints);
        totalSinks.addAll(currentConnectPoints);
    });
    // Sinks to be added
    Set<ConnectPoint> sinksToBeAdded = Sets.difference(totalSinks, totalAffectedSinks);
    // New egress devices, filtering out the source
    Set<DeviceId> newEgressDevice = sinksToBeAdded.stream().map(ConnectPoint::deviceId).collect(Collectors.toSet());
    // Let's add the devices recovered from the previous round
    newEgressDevice.addAll(recovered);
    // Let's do a copy of the new egresses and filter out the source
    Set<DeviceId> copyNewEgressDevice = ImmutableSet.copyOf(newEgressDevice);
    newEgressDevice = newEgressDevice.stream().filter(deviceId -> !deviceId.equals(ingressDevice)).collect(Collectors.toSet());
    // Re-compute mcast tree for the the egress devices
    Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, newEgressDevice);
    // if the source was originally in the new locations, add new sinks
    if (copyNewEgressDevice.contains(ingressDevice)) {
        sinksToBeAdded.stream().filter(connectPoint -> connectPoint.deviceId().equals(ingressDevice)).forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, ImmutableList.of()));
    }
    // Construct a new path for each egress device
    mcastTree.forEach((egressDevice, paths) -> {
        // We try to enforce the sinks path on the mcast tree
        Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths);
        // If a path is present, let's install it
        if (mcastPath.isPresent()) {
            // Using recovery procedure
            if (recovered.contains(egressDevice)) {
                installPath(mcastIp, source, mcastPath.get());
            } else {
                // otherwise we need to threat as new sink
                sinksToBeAdded.stream().filter(connectPoint -> connectPoint.deviceId().equals(egressDevice)).forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, paths));
            }
        } else {
            // We were not able to find an alternative path for this egress
            log.warn("Fail to recover egress device {} from {} failure", egressDevice, isLinkFailure ? "Link" : "Device");
            removeGroupFromDevice(egressDevice, mcastIp, mcastUtils.assignedVlan(null));
        }
    });
}
#method_after
private void recoverSinks(Set<DeviceId> egressDevices, Set<DeviceId> notRecovered, IpAddress mcastIp, DeviceId ingressDevice, ConnectPoint source, boolean isLinkFailure) {
    // Recovered devices
    Set<DeviceId> recovered = Sets.difference(egressDevices, notRecovered);
    // Total affected sinks
    Set<ConnectPoint> totalAffectedSinks = Sets.newHashSet();
    // Total sinks
    Set<ConnectPoint> totalSinks = Sets.newHashSet();
    // Let's compute all the affected sinks and all the sinks
    notRecovered.forEach(deviceId -> {
        totalAffectedSinks.addAll(mcastUtils.getAffectedSinks(deviceId, mcastIp).values().stream().flatMap(Collection::stream).filter(connectPoint -> connectPoint.deviceId().equals(deviceId)).collect(Collectors.toSet()));
        totalSinks.addAll(mcastUtils.getAffectedSinks(deviceId, mcastIp).values().stream().flatMap(Collection::stream).collect(Collectors.toSet()));
    });
    // Sinks to be added
    Set<ConnectPoint> sinksToBeAdded = Sets.difference(totalSinks, totalAffectedSinks);
    // New egress devices, filtering out the source
    Set<DeviceId> newEgressDevice = sinksToBeAdded.stream().map(ConnectPoint::deviceId).collect(Collectors.toSet());
    // Let's add the devices recovered from the previous round
    newEgressDevice.addAll(recovered);
    // Let's do a copy of the new egresses and filter out the source
    Set<DeviceId> copyNewEgressDevice = ImmutableSet.copyOf(newEgressDevice);
    newEgressDevice = newEgressDevice.stream().filter(deviceId -> !deviceId.equals(ingressDevice)).collect(Collectors.toSet());
    // Re-compute mcast tree for the the egress devices
    Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, newEgressDevice);
    // if the source was originally in the new locations, add new sinks
    if (copyNewEgressDevice.contains(ingressDevice)) {
        sinksToBeAdded.stream().filter(connectPoint -> connectPoint.deviceId().equals(ingressDevice)).forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, ImmutableList.of()));
    }
    // Construct a new path for each egress device
    mcastTree.forEach((egressDevice, paths) -> {
        // We try to enforce the sinks path on the mcast tree
        Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths);
        // If a path is present, let's install it
        if (mcastPath.isPresent()) {
            // Using recovery procedure
            if (recovered.contains(egressDevice)) {
                installPath(mcastIp, source, mcastPath.get());
            } else {
                // otherwise we need to threat as new sink
                sinksToBeAdded.stream().filter(connectPoint -> connectPoint.deviceId().equals(egressDevice)).forEach(sink -> processSinkAddedInternal(source, sink, mcastIp, paths));
            }
        } else {
            // We were not able to find an alternative path for this egress
            log.warn("Fail to recover egress device {} from {} failure", egressDevice, isLinkFailure ? "Link" : "Device");
            removeGroupFromDevice(egressDevice, mcastIp, mcastUtils.assignedVlan(null));
        }
    });
}
#end_block

#method_before
private Set<ConnectPoint> processSinksToBeRecovered(IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> sinks) {
    // Iterate over the sinks in order to build the set
    // of the connect points to be served by this group
    final Set<ConnectPoint> sinksToBeProcessed = Sets.newHashSet();
    sinks.forEach((hostId, connectPoints) -> {
        // If it has more than 1 locations
        if (connectPoints.size() > 1 || connectPoints.size() == 0) {
            log.warn("Skip {} since sink {} has {} locations", mcastIp, hostId, connectPoints.size());
            return;
        }
        sinksToBeProcessed.add(connectPoints.stream().findFirst().orElseGet(null));
    });
    return sinksToBeProcessed;
}
#method_after
private Set<ConnectPoint> processSinksToBeRecovered(IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> sinks) {
    // Iterate over the sinks in order to build the set
    // of the connect points to be served by this group
    final Set<ConnectPoint> sinksToBeProcessed = Sets.newHashSet();
    sinks.forEach((hostId, connectPoints) -> {
        // If it has more than 1 locations
        if (connectPoints.size() > 1 || connectPoints.size() == 0) {
            log.debug("Skip {} since sink {} has {} locations", mcastIp, hostId, connectPoints.size());
            return;
        }
        sinksToBeProcessed.add(connectPoints.stream().findFirst().orElseGet(null));
    });
    return sinksToBeProcessed;
}
#end_block

#method_before
private Set<ConnectPoint> processSinksToBeAdded(ConnectPoint source, IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> sinks) {
    // Iterate over the sinks in order to build the set
    // of the connect points to be served by this group
    final Set<ConnectPoint> sinksToBeProcessed = Sets.newHashSet();
    sinks.forEach(((hostId, connectPoints) -> {
        // If it has more than 2 locations
        if (connectPoints.size() > 2 || connectPoints.size() == 0) {
            log.warn("Skip {} since sink {} has {} locations", mcastIp, hostId, connectPoints.size());
            return;
        }
        // If it has one location, just use it
        if (connectPoints.size() == 1) {
            sinksToBeProcessed.add(connectPoints.stream().findFirst().orElseGet(null));
            return;
        }
        // We prefer to reuse existing flows
        ConnectPoint sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> {
            // Let's check if we are already serving that location
            McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, connectPoint.deviceId());
            if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
                return false;
            }
            // Get next and check with the port
            NextObjective mcastNext = mcastNextObjStore.get(mcastStoreKey).value();
            return mcastUtils.getPorts(mcastNext.next()).contains(connectPoint.port());
        }).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Otherwise we prefer to reuse existing egresses
        Set<DeviceId> egresses = getDevice(mcastIp, EGRESS);
        sinkToBeProcessed = connectPoints.stream().filter(egresses::contains).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Otherwise we prefer a location co-located with the source (if it exists)
        sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> connectPoint.deviceId().equals(source.deviceId())).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Finally, we randomly pick a new location
        sinksToBeProcessed.add(connectPoints.stream().findFirst().orElseGet(null));
    }));
    // We have done, return the set
    return sinksToBeProcessed;
}
#method_after
private Set<ConnectPoint> processSinksToBeAdded(ConnectPoint source, IpAddress mcastIp, Map<HostId, Set<ConnectPoint>> sinks) {
    // Iterate over the sinks in order to build the set
    // of the connect points to be served by this group
    final Set<ConnectPoint> sinksToBeProcessed = Sets.newHashSet();
    sinks.forEach(((hostId, connectPoints) -> {
        // If it has more than 2 locations
        if (connectPoints.size() > 2 || connectPoints.size() == 0) {
            log.debug("Skip {} since sink {} has {} locations", mcastIp, hostId, connectPoints.size());
            return;
        }
        // If it has one location, just use it
        if (connectPoints.size() == 1) {
            sinksToBeProcessed.add(connectPoints.stream().findFirst().orElseGet(null));
            return;
        }
        // We prefer to reuse existing flows
        ConnectPoint sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> {
            // Let's check if we are already serving that location
            McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, connectPoint.deviceId());
            if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
                return false;
            }
            // Get next and check with the port
            NextObjective mcastNext = mcastNextObjStore.get(mcastStoreKey).value();
            return mcastUtils.getPorts(mcastNext.next()).contains(connectPoint.port());
        }).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Otherwise we prefer to reuse existing egresses
        Set<DeviceId> egresses = getDevice(mcastIp, EGRESS);
        sinkToBeProcessed = connectPoints.stream().filter(egresses::contains).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Otherwise we prefer a location co-located with the source (if it exists)
        sinkToBeProcessed = connectPoints.stream().filter(connectPoint -> connectPoint.deviceId().equals(source.deviceId())).findFirst().orElse(null);
        if (sinkToBeProcessed != null) {
            sinksToBeProcessed.add(sinkToBeProcessed);
            return;
        }
        // Finally, we randomly pick a new location
        sinksToBeProcessed.add(connectPoints.stream().findFirst().orElseGet(null));
    }));
    // We have done, return the set
    return sinksToBeProcessed;
}
#end_block

#method_before
void addFilterToDevice(DeviceId deviceId, PortNumber port, VlanId assignedVlan, IpAddress mcastIp, McastRole mcastRole) {
    // Do nothing if the port is configured as suppressed
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId(), SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
        log.info("Ignore suppressed port {}", connectPoint);
        return;
    }
    MacAddress routerMac;
    try {
        routerMac = srManager.deviceConfiguration().getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException dcnfe) {
        log.warn("Fail to push filtering objective since device is not configured. Abort");
        return;
    }
    FilteringObjective.Builder filtObjBuilder = filterObjBuilder(port, assignedVlan, mcastIp, routerMac, mcastRole);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add filter on {}/{}, vlan {}", deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add filter on {}/{}, vlan {}: {}", deviceId, port.toLong(), assignedVlan, error));
    srManager.flowObjectiveService.filter(deviceId, filtObjBuilder.add(context));
}
#method_after
void addFilterToDevice(DeviceId deviceId, PortNumber port, VlanId assignedVlan, IpAddress mcastIp, McastRole mcastRole) {
    MacAddress routerMac = getRouterMac(deviceId, port);
    if (routerMac.equals(MacAddress.NONE)) {
        return;
    }
    FilteringObjective.Builder filtObjBuilder = filterObjBuilder(port, assignedVlan, mcastIp, routerMac, mcastRole);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add filter on {}/{}, vlan {}", deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add filter on {}/{}, vlan {}: {}", deviceId, port.toLong(), assignedVlan, error));
    srManager.flowObjectiveService.filter(deviceId, filtObjBuilder.add(context));
}
#end_block

#method_before
void removeFilterToDevice(DeviceId deviceId, PortNumber port, VlanId assignedVlan, IpAddress mcastIp, McastRole mcastRole) {
    // Do nothing if the port is configured as suppressed
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId(), SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
        log.info("Ignore suppressed port {}", connectPoint);
        return;
    }
    MacAddress routerMac;
    try {
        routerMac = srManager.deviceConfiguration().getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException dcnfe) {
        log.warn("Fail to push filtering objective since device is not configured. Abort");
        return;
    }
    FilteringObjective.Builder filtObjBuilder = filterObjBuilder(port, assignedVlan, mcastIp, routerMac, mcastRole);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully removed filter on {}/{}, vlan {}", deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to remove filter on {}/{}, vlan {}: {}", deviceId, port.toLong(), assignedVlan, error));
    srManager.flowObjectiveService.filter(deviceId, filtObjBuilder.remove(context));
}
#method_after
void removeFilterToDevice(DeviceId deviceId, PortNumber port, VlanId assignedVlan, IpAddress mcastIp, McastRole mcastRole) {
    MacAddress routerMac = getRouterMac(deviceId, port);
    if (routerMac.equals(MacAddress.NONE)) {
        return;
    }
    FilteringObjective.Builder filtObjBuilder = filterObjBuilder(port, assignedVlan, mcastIp, routerMac, mcastRole);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully removed filter on {}/{}, vlan {}", deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to remove filter on {}/{}, vlan {}: {}", deviceId, port.toLong(), assignedVlan, error));
    srManager.flowObjectiveService.filter(deviceId, filtObjBuilder.remove(context));
}
#end_block

#method_before
ForwardingObjective.Builder fwdObjBuilder(IpAddress mcastIp, VlanId assignedVlan, int nextId) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    // Let's the matching on the group address
    if (mcastIp.isIp6()) {
        sbuilder.matchEthType(Ethernet.TYPE_IPV6);
        sbuilder.matchIPv6Dst(mcastIp.toIpPrefix());
    } else {
        sbuilder.matchEthType(Ethernet.TYPE_IPV4);
        sbuilder.matchIPDst(mcastIp.toIpPrefix());
    }
    // Then build the meta selector
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder();
    metabuilder.matchVlanId(assignedVlan);
    // Finally return the completed builder
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder();
    fwdBuilder.withSelector(sbuilder.build()).withMeta(metabuilder.build()).nextStep(nextId).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(srManager.appId()).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    return fwdBuilder;
}
#method_after
ForwardingObjective.Builder fwdObjBuilder(IpAddress mcastIp, VlanId assignedVlan, int nextId) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    // TODO SSM support in future
    if (mcastIp.isIp6()) {
        sbuilder.matchEthType(Ethernet.TYPE_IPV6);
        sbuilder.matchIPv6Dst(mcastIp.toIpPrefix());
    } else {
        sbuilder.matchEthType(Ethernet.TYPE_IPV4);
        sbuilder.matchIPDst(mcastIp.toIpPrefix());
    }
    // Then build the meta selector
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder();
    metabuilder.matchVlanId(assignedVlan);
    // Finally return the completed builder
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder();
    fwdBuilder.withSelector(sbuilder.build()).withMeta(metabuilder.build()).nextStep(nextId).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(srManager.appId()).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    return fwdBuilder;
}
#end_block

#method_before
@Override
public Weight weight(TopologyEdge edge) {
    // If the link is a pair link just return infinite value
    if (isPairLink(edge.link())) {
        return ScalarWeight.NON_VIABLE_WEIGHT;
    }
    // To avoid funny paths we need to influence the path computation
    // to return infinite value for all other links having as a src
    // a leaf different from the source we are passing to the weigher
    DeviceId srcDeviceLink = edge.link().src().deviceId();
    // Identify the link as leaf-spine link
    boolean isLeafSpine;
    try {
        isLeafSpine = srManager.deviceConfiguration().isEdgeDevice(srcDeviceLink);
    } catch (DeviceConfigNotFoundException e) {
        isLeafSpine = false;
    }
    // If it is not the source just return infinite value
    if (isLeafSpine && !srcDeviceLink.equals(srcPath)) {
        return ScalarWeight.NON_VIABLE_WEIGHT;
    }
    // All other cases we return
    return new ScalarWeight(HOP_WEIGHT_VALUE);
}
#method_after
@Override
public Weight weight(TopologyEdge edge) {
    // If the link is a pair link just return infinite value
    if (isPairLink(edge.link())) {
        return ScalarWeight.NON_VIABLE_WEIGHT;
    }
    // To avoid that the paths go through other leaves we need to influence
    // the path computation to return infinite value for all other links having
    // as a src a leaf different from the source we are passing to the weigher
    DeviceId srcDeviceLink = edge.link().src().deviceId();
    // Identify the link as leaf-spine link
    boolean isLeafSpine;
    try {
        isLeafSpine = srManager.deviceConfiguration().isEdgeDevice(srcDeviceLink);
    } catch (DeviceConfigNotFoundException e) {
        isLeafSpine = false;
    }
    // If it is not the source just return infinite value
    if (isLeafSpine && !srcDeviceLink.equals(srcPath)) {
        return ScalarWeight.NON_VIABLE_WEIGHT;
    }
    // If the links are not in the list of the links to be enforce
    if (!linksToEnforce.isEmpty() && !linksToEnforce.contains(edge.link())) {
        // 100 should be a good confidence threshold
        return LINK_TO_AVOID_WEIGHT;
    }
    // All other cases we return
    return new ScalarWeight(HOP_WEIGHT_VALUE);
}
#end_block

#method_before
private void enqueueMcastEvent(McastEvent mcastEvent) {
    log.debug("Enqueue mcastEvent {}", mcastEvent);
    final McastRouteInfo mcastRouteInfo = mcastEvent.subject();
    // Let's create the keys of the cache
    ImmutableSet.Builder<ConnectPoint> sinksBuilder = ImmutableSet.builder();
    // For this event we will have a set of sinks
    if (mcastEvent.type() == SOURCE_ADDED || mcastEvent.type() == SOURCE_UPDATED || mcastEvent.type() == ROUTE_REMOVED) {
        // Add all the sinks
        sinksBuilder.addAll(mcastRouteInfo.sinks());
    } else {
        // We have just one sink in this case
        ConnectPoint sink = mcastRouteInfo.sink().orElse(null);
        // in the mcast route store
        if (sink != null) {
            sinksBuilder.add(sink);
        }
    }
    // Push the elements in the cache
    sinksBuilder.build().forEach(sink -> {
        McastCacheKey cacheKey = new McastCacheKey(mcastRouteInfo.route().group(), sink);
        mcastEventCache.put(cacheKey, mcastEvent);
    });
}
#method_after
private void enqueueMcastEvent(McastEvent mcastEvent) {
    log.debug("Enqueue mcastEvent {}", mcastEvent);
    final McastRouteUpdate mcastRouteUpdate = mcastEvent.subject();
    final McastRouteUpdate prevUpdate = mcastEvent.prevSubject();
    final IpAddress group = prevUpdate.route().group();
    // Let's create the keys of the cache
    ImmutableSet.Builder<ConnectPoint> sinksBuilder = ImmutableSet.builder();
    Set<ConnectPoint> sinks;
    // For this event we will have a set of sinks
    if (mcastEvent.type() == SOURCES_ADDED || mcastEvent.type() == SOURCES_REMOVED) {
        // FIXME To be addressed with multiple sources support
        sinks = mcastRouteUpdate.sinks().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
    } else {
        Set<ConnectPoint> prevSinks = prevUpdate.sinks().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
        if (mcastEvent.type() == ROUTE_REMOVED) {
            // Get the old sinks, since current subject is null
            sinks = prevSinks;
        } else {
            // Get new sinks
            Set<ConnectPoint> newsinks = mcastRouteUpdate.sinks().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
            // If it is a SINKS_ADDED event
            if (mcastEvent.type() == SINKS_ADDED) {
                // Let's do the difference between current and prev subjects
                sinks = Sets.difference(newsinks, prevSinks);
            } else {
                // Let's do the difference between prev and current subjects
                sinks = Sets.difference(prevSinks, newsinks);
            }
        }
    }
    // Add all the sinks
    sinksBuilder.addAll(sinks);
    // Push the elements in the cache
    sinksBuilder.build().forEach(sink -> {
        McastCacheKey cacheKey = new McastCacheKey(group, sink);
        mcastEventCache.put(cacheKey, mcastEvent);
    });
}
#end_block

#method_before
private void dequeueMcastEvent(McastEvent mcastEvent) {
    log.debug("Dequeue mcastEvent {}", mcastEvent);
    final McastRouteInfo mcastRouteInfo = mcastEvent.subject();
    // Get source, mcast group
    ConnectPoint source = mcastRouteInfo.source().orElse(null);
    IpAddress mcastIp = mcastRouteInfo.route().group();
    // According to the event type let's call the proper method
    switch(mcastEvent.type()) {
        case SOURCE_ADDED:
            // Get all the sinks
            Set<ConnectPoint> sinks = mcastRouteInfo.sinks();
            // Compute the Mcast tree
            Map<ConnectPoint, List<Path>> mcasTree = computeSinksMcastTree(source.deviceId(), sinks);
            // Process the given sinks using the pre-computed paths
            mcasTree.forEach((sink, paths) -> processSinkAddedInternal(source, sink, mcastIp, paths));
            break;
        case SOURCE_UPDATED:
            // Get old source
            ConnectPoint oldSource = mcastEvent.prevSubject().source().orElse(null);
            // Just the first cached element will be processed
            processSourceUpdatedInternal(mcastIp, source, oldSource);
            break;
        case ROUTE_REMOVED:
            // Process the route removed, just the first cached element will be processed
            processRouteRemovedInternal(source, mcastIp);
            break;
        case SINK_ADDED:
            // Get the only sink and process
            ConnectPoint sink = mcastRouteInfo.sink().orElse(null);
            processSinkAddedInternal(source, sink, mcastIp, null);
            break;
        case SINK_REMOVED:
            sink = mcastRouteInfo.sink().orElse(null);
            processSinkRemovedInternal(source, sink, mcastIp);
            break;
        default:
            break;
    }
}
#method_after
private void dequeueMcastEvent(McastEvent mcastEvent) {
    log.debug("Dequeue mcastEvent {}", mcastEvent);
    final McastRouteUpdate mcastRouteUpdate = mcastEvent.subject();
    final McastRouteUpdate prevUpdate = mcastEvent.prevSubject();
    // Get source, mcast group
    // FIXME To be addressed with multiple sources support
    ConnectPoint prevSource = prevUpdate.sources().stream().findFirst().orElse(null);
    IpAddress mcastIp = prevUpdate.route().group();
    Set<ConnectPoint> prevSinks = prevUpdate.sinks().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
    Set<ConnectPoint> newSinks;
    // Sinks to handled by SINKS_ADDED and SINKS_REMOVED procedures
    Set<ConnectPoint> sinks;
    // According to the event type let's call the proper method
    switch(mcastEvent.type()) {
        case SOURCES_ADDED:
            // mcasTree.forEach((sink, paths) -> processSinkAddedInternal(source, sink, mcastIp, paths));
            break;
        case SOURCES_REMOVED:
            // processSourceUpdatedInternal(mcastIp, source, oldSource);
            break;
        case ROUTE_REMOVED:
            // Process the route removed, just the first cached element will be processed
            processRouteRemovedInternal(prevSource, mcastIp);
            break;
        case SINKS_ADDED:
            // Get the only sinks to be processed (new ones)
            newSinks = mcastRouteUpdate.sinks().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
            sinks = Sets.difference(newSinks, prevSinks);
            sinks.forEach(sink -> processSinkAddedInternal(prevSource, sink, mcastIp, null));
            break;
        case SINKS_REMOVED:
            // Get the only sinks to be processed (old ones)
            newSinks = mcastRouteUpdate.sinks().values().stream().flatMap(Collection::stream).collect(Collectors.toSet());
            sinks = Sets.difference(prevSinks, newSinks);
            sinks.forEach(sink -> processSinkRemovedInternal(prevSource, sink, mcastIp));
            break;
        default:
            break;
    }
}
#end_block

#method_before
public void init() {
    srManager.multicastRouteService.getRoutes().forEach(mcastRoute -> {
        ConnectPoint source = srManager.multicastRouteService.fetchSource(mcastRoute);
        Set<ConnectPoint> sinks = srManager.multicastRouteService.fetchSinks(mcastRoute);
        // Compute the Mcast tree
        Map<ConnectPoint, List<Path>> mcasTree = computeSinksMcastTree(source.deviceId(), sinks);
        // Process the given sinks using the pre-computed paths
        mcasTree.forEach((sink, paths) -> processSinkAddedInternal(source, sink, mcastRoute.group(), paths));
    });
}
#method_after
public void init() {
    srManager.multicastRouteService.getRoutes().forEach(mcastRoute -> {
        // FIXME To be addressed with multiple sources support
        ConnectPoint source = srManager.multicastRouteService.sources(mcastRoute).stream().findFirst().orElse(null);
        Set<ConnectPoint> sinks = srManager.multicastRouteService.sinks(mcastRoute);
        // Filter out all the working sinks, we do not want to move them
        sinks = sinks.stream().filter(sink -> {
            McastStoreKey mcastKey = new McastStoreKey(mcastRoute.group(), sink.deviceId());
            Versioned<NextObjective> verMcastNext = mcastNextObjStore.get(mcastKey);
            return verMcastNext == null || !getPorts(verMcastNext.value().next()).contains(sink.port());
        }).collect(Collectors.toSet());
        // Compute the Mcast tree
        Map<ConnectPoint, List<Path>> mcasTree = computeSinkMcastTree(source.deviceId(), sinks);
        // Process the given sinks using the pre-computed paths
        mcasTree.forEach((sink, paths) -> processSinkAddedInternal(source, sink, mcastRoute.group(), paths));
    });
}
#end_block

#method_before
public void processMcastEvent(McastEvent event) {
    log.info("process {}", event);
    // Verify if it is a complete event
    McastRouteInfo mcastRouteInfo = event.subject();
    if (!mcastRouteInfo.isComplete()) {
        log.info("Incompleted McastRouteInfo. Abort {}", event.type());
        return;
    }
    // Just enqueue for now
    enqueueMcastEvent(event);
}
#method_after
public void processMcastEvent(McastEvent event) {
    log.info("process {}", event);
    // Just enqueue for now
    enqueueMcastEvent(event);
}
#end_block

#method_before
public void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, INGRESS).stream().findAny().orElse(null);
            Set<DeviceId> transitDevices = getDevice(mcastIp, TRANSIT);
            Set<DeviceId> egressDevices = getDevice(mcastIp, EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.debug("Skip {} due to lack of mastership of the source device {}", source.deviceId());
                return;
            }
            // Remove entire transit
            transitDevices.forEach(transitDevice -> removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null)));
            // Remove transit-facing ports on the ingress device
            removeIngressTransitPorts(mcastIp, ingressDevice, source);
            // Compute mcast tree for the the egress devices
            Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, egressDevices);
            // Construct a new path for each egress device
            mcastTree.forEach((egressDevice, paths) -> {
                // We try to enforce the sinks path on the mcast tree
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths);
                // If a path is present, let's install it
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
public void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, INGRESS).stream().findAny().orElse(null);
            Set<DeviceId> transitDevices = getDevice(mcastIp, TRANSIT);
            Set<DeviceId> egressDevices = getDevice(mcastIp, EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.debug("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Remove entire transit
            transitDevices.forEach(transitDevice -> removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null)));
            // Remove transit-facing ports on the ingress device
            removeIngressTransitPorts(mcastIp, ingressDevice, source);
            // Compute mcast tree for the the egress devices
            Map<DeviceId, List<Path>> mcastTree = computeMcastTree(ingressDevice, egressDevices);
            // Construct a new path for each egress device
            mcastTree.forEach((egressDevice, paths) -> {
                // We try to enforce the sinks path on the mcast tree
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp, paths);
                // If a path is present, let's install it
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private Map<DeviceId, List<Path>> computeMcastTree(DeviceId source, Set<DeviceId> egresses) {
    // The high level idea is to calculate all the paths reaching sinks
    final Map<DeviceId, List<Path>> mcastTree = Maps.newHashMap();
    final Map<DeviceId, Integer> pathLength = Maps.newHashMap();
    // Takes a snapshot of the topology
    final Topology currentTopology = topologyService.currentTopology();
    // Build a specific link weigher for this path computation
    final LinkWeigher linkWeigher = new SRLinkWeigher(srManager, source);
    egresses.forEach(egress -> {
        // We will use our custom link weigher for our path
        // computations and build the list of valid paths
        List<Path> allPaths = Lists.newArrayList(topologyService.getPaths(currentTopology, source, egress, linkWeigher));
        // Save the path first
        mcastTree.put(egress, allPaths);
        // Then update the cost of this subtree
        if (allPaths.isEmpty()) {
            pathLength.put(egress, 0);
            return;
        }
        // Get the first and use its cost
        Path path = allPaths.get(0);
        pathLength.put(egress, path.links().size());
    });
    // Build a sorted map according to the path lengths
    final Map<DeviceId, List<Path>> sortedMcastTree = mcastTree.entrySet().stream().sorted((o1, o2) -> {
        int o1Len = pathLength.get(o1.getKey());
        int o2Len = pathLength.get(o2.getKey());
        return o1Len == o2Len ? 0 : (o1Len > o2Len ? -1 : -1);
    }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -> oldValue, LinkedHashMap::new));
    // Done, return the shared links
    log.debug("McastTree {}", sortedMcastTree);
    return sortedMcastTree;
}
#method_after
private Map<DeviceId, List<Path>> computeMcastTree(DeviceId source, Set<DeviceId> egresses) {
    // Pre-compute all the paths
    Map<DeviceId, List<Path>> availablePaths = Maps.newHashMap();
    // No links to enforce
    egresses.forEach(egress -> availablePaths.put(egress, getPaths(source, egress, Collections.emptySet())));
    // Explore the topology looking for shared links amongst the egresses
    Set<Link> linksToEnforce = exploreMcastTree(Sets.newHashSet(egresses), availablePaths);
    // Remove all the paths from the previous computation
    availablePaths.clear();
    // Build the final paths enforcing the shared links between egress devices
    egresses.forEach(egress -> availablePaths.put(egress, getPaths(source, egress, linksToEnforce)));
    return availablePaths;
}
#end_block

#method_before
private List<Path> getPaths(DeviceId src, DeviceId dst) {
    // Takes a snapshot of the topology
    final Topology currentTopology = topologyService.currentTopology();
    // Build a specific link weigher for this path computation
    final LinkWeigher linkWeigher = new SRLinkWeigher(srManager, src);
    // We will use our custom link weigher for our path
    // computations and build the list of valid paths
    List<Path> allPaths = Lists.newArrayList(topologyService.getPaths(currentTopology, src, dst, linkWeigher));
    // If there are no valid paths, just exit
    log.debug("{} path(s) found from {} to {}", allPaths.size(), src, dst);
    return allPaths;
}
#method_after
private List<Path> getPaths(DeviceId src, DeviceId dst, Set<Link> linksToEnforce) {
    // Takes a snapshot of the topology
    final Topology currentTopology = topologyService.currentTopology();
    // Build a specific link weigher for this path computation
    final LinkWeigher linkWeigher = new SRLinkWeigher(srManager, src, linksToEnforce);
    // We will use our custom link weigher for our path
    // computations and build the list of valid paths
    List<Path> allPaths = Lists.newArrayList(topologyService.getPaths(currentTopology, src, dst, linkWeigher));
    // If there are no valid paths, just exit
    log.debug("{} path(s) found from {} to {}", allPaths.size(), src, dst);
    return allPaths;
}
#end_block

#method_before
private Optional<Path> getPath(DeviceId src, DeviceId dst, IpAddress mcastIp, List<Path> allPaths) {
    // Firstly we get all the valid paths, if the supplied are null
    if (allPaths == null) {
        allPaths = getPaths(src, dst);
    }
    // If there are no paths just exit
    if (allPaths.isEmpty()) {
        return Optional.empty();
    }
    // Create a map index of suitablity-to-list of paths. For example
    // a path in the list associated to the index 1 shares only the
    // first hop and it is less suitable of a path belonging to the index
    // 2 that shares leaf-spine.
    Map<Integer, List<Path>> eligiblePaths = Maps.newHashMap();
    // Some init steps
    int nhop;
    McastStoreKey mcastStoreKey;
    Link hop;
    PortNumber srcPort;
    Set<PortNumber> existingPorts;
    NextObjective nextObj;
    // Iterate over paths looking for eligible paths
    for (Path path : allPaths) {
        // Unlikely, it will happen...
        if (!src.equals(path.links().get(0).src().deviceId())) {
            continue;
        }
        nhop = 0;
        // Iterate over the links
        while (nhop < path.links().size()) {
            // Get the link and verify if a next related
            // to the src device exist in the store
            hop = path.links().get(nhop);
            mcastStoreKey = new McastStoreKey(mcastIp, hop.src().deviceId());
            // It does not exist in the store, exit
            if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
                break;
            }
            // Get the output ports on the next
            nextObj = mcastNextObjStore.get(mcastStoreKey).value();
            existingPorts = getPorts(nextObj.next());
            // And the src port on the link
            srcPort = hop.src().port();
            // the src port is not used as output, exit
            if (!existingPorts.contains(srcPort)) {
                break;
            }
            nhop++;
        }
        // n_hop defines the index
        if (nhop > 0) {
            eligiblePaths.compute(nhop, (index, paths) -> {
                paths = paths == null ? Lists.newArrayList() : paths;
                paths.add(path);
                return paths;
            });
        }
    }
    // No suitable paths
    if (eligiblePaths.isEmpty()) {
        log.debug("No eligiblePath(s) found from {} to {}", src, dst);
        // Otherwise, randomly pick a path
        Collections.shuffle(allPaths);
        return allPaths.stream().findFirst();
    }
    // Let's take the best ones
    Integer bestIndex = eligiblePaths.keySet().stream().sorted(Comparator.reverseOrder()).findFirst().orElse(null);
    List<Path> bestPaths = eligiblePaths.get(bestIndex);
    log.debug("{} eligiblePath(s) found from {} to {}", bestPaths.size(), src, dst);
    // randomly pick a path on the highest index
    Collections.shuffle(bestPaths);
    return bestPaths.stream().findFirst();
}
#method_after
private Optional<Path> getPath(DeviceId src, DeviceId dst, IpAddress mcastIp, List<Path> allPaths) {
    // Firstly we get all the valid paths, if the supplied are null
    if (allPaths == null) {
        allPaths = getPaths(src, dst, Collections.emptySet());
    }
    // If there are no paths just exit
    if (allPaths.isEmpty()) {
        return Optional.empty();
    }
    // Create a map index of suitablity-to-list of paths. For example
    // a path in the list associated to the index 1 shares only the
    // first hop and it is less suitable of a path belonging to the index
    // 2 that shares leaf-spine.
    Map<Integer, List<Path>> eligiblePaths = Maps.newHashMap();
    // Some init steps
    int nhop;
    McastStoreKey mcastStoreKey;
    Link hop;
    PortNumber srcPort;
    Set<PortNumber> existingPorts;
    NextObjective nextObj;
    // Iterate over paths looking for eligible paths
    for (Path path : allPaths) {
        // Unlikely, it will happen...
        if (!src.equals(path.links().get(0).src().deviceId())) {
            continue;
        }
        nhop = 0;
        // Iterate over the links
        while (nhop < path.links().size()) {
            // Get the link and verify if a next related
            // to the src device exist in the store
            hop = path.links().get(nhop);
            mcastStoreKey = new McastStoreKey(mcastIp, hop.src().deviceId());
            // It does not exist in the store, exit
            if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
                break;
            }
            // Get the output ports on the next
            nextObj = mcastNextObjStore.get(mcastStoreKey).value();
            existingPorts = getPorts(nextObj.next());
            // And the src port on the link
            srcPort = hop.src().port();
            // the src port is not used as output, exit
            if (!existingPorts.contains(srcPort)) {
                break;
            }
            nhop++;
        }
        // n_hop defines the index
        if (nhop > 0) {
            eligiblePaths.compute(nhop, (index, paths) -> {
                paths = paths == null ? Lists.newArrayList() : paths;
                paths.add(path);
                return paths;
            });
        }
    }
    // No suitable paths
    if (eligiblePaths.isEmpty()) {
        log.debug("No eligiblePath(s) found from {} to {}", src, dst);
        // Otherwise, randomly pick a path
        Collections.shuffle(allPaths);
        return allPaths.stream().findFirst();
    }
    // Let's take the best ones
    Integer bestIndex = eligiblePaths.keySet().stream().sorted(Comparator.reverseOrder()).findFirst().orElse(null);
    List<Path> bestPaths = eligiblePaths.get(bestIndex);
    log.debug("{} eligiblePath(s) found from {} to {}", bestPaths.size(), src, dst);
    // randomly pick a path on the highest index
    Collections.shuffle(bestPaths);
    return bestPaths.stream().findFirst();
}
#end_block

#method_before
private Set<DeviceId> getDevice(IpAddress mcastIp, McastRole role) {
    return mcastRoleStore.entrySet().stream().filter(entry -> entry.getKey().mcastIp().equals(mcastIp) && entry.getValue().value() == role).map(Map.Entry::getKey).map(McastStoreKey::deviceId).collect(Collectors.toSet());
}
#method_after
private Set<DeviceId> getDevice(IpAddress mcastIp, McastRole role) {
    return mcastRoleStore.entrySet().stream().filter(entry -> entry.getKey().mcastIp().equals(mcastIp) && entry.getValue().value() == role).map(Entry::getKey).map(McastStoreKey::deviceId).collect(Collectors.toSet());
}
#end_block

#method_before
private ConnectPoint getSource(IpAddress mcastIp) {
    return srManager.multicastRouteService.getRoutes().stream().filter(mcastRoute -> mcastRoute.group().equals(mcastIp)).map(mcastRoute -> srManager.multicastRouteService.fetchSource(mcastRoute)).findAny().orElse(null);
}
#method_after
/**
 * Gets source connect point of given multicast group.
 *
 * @param mcastIp multicast IP
 * @return source connect point or null if not found
 */
private ConnectPoint getSource(IpAddress mcastIp) {
    // FIXME we should support different types of routes
    McastRoute mcastRoute = srManager.multicastRouteService.getRoutes().stream().filter(mcastRouteInternal -> mcastRouteInternal.group().equals(mcastIp)).findFirst().orElse(null);
    return mcastRoute == null ? null : srManager.multicastRouteService.sources(mcastRoute).stream().findFirst().orElse(null);
}
#end_block

#method_before
private Set<ConnectPoint> getSinks(IpAddress mcastIp) {
    return srManager.multicastRouteService.getRoutes().stream().filter(mcastRoute -> mcastRoute.group().equals(mcastIp)).map(mcastRoute -> srManager.multicastRouteService.fetchSinks(mcastRoute)).findAny().orElse(Collections.emptySet());
}
#method_after
private Set<ConnectPoint> getSinks(IpAddress mcastIp) {
    // FIXME we should support different types of routes
    McastRoute mcastRoute = srManager.multicastRouteService.getRoutes().stream().filter(mcastRouteInternal -> mcastRouteInternal.group().equals(mcastIp)).findFirst().orElse(null);
    return mcastRoute == null ? Collections.emptySet() : srManager.multicastRouteService.sinks(mcastRoute);
}
#end_block

#method_before
private Set<IpAddress> getAffectedGroups(Link link) {
    DeviceId deviceId = link.src().deviceId();
    PortNumber port = link.src().port();
    return mcastNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(deviceId) && getPorts(entry.getValue().value().next()).contains(port)).map(Map.Entry::getKey).map(McastStoreKey::mcastIp).collect(Collectors.toSet());
}
#method_after
private Set<IpAddress> getAffectedGroups(Link link) {
    DeviceId deviceId = link.src().deviceId();
    PortNumber port = link.src().port();
    return mcastNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(deviceId) && getPorts(entry.getValue().value().next()).contains(port)).map(Entry::getKey).map(McastStoreKey::mcastIp).collect(Collectors.toSet());
}
#end_block

#method_before
private Set<IpAddress> getAffectedGroups(DeviceId deviceId) {
    return mcastNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(deviceId)).map(Map.Entry::getKey).map(McastStoreKey::mcastIp).collect(Collectors.toSet());
}
#method_after
private Set<IpAddress> getAffectedGroups(DeviceId deviceId) {
    return mcastNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(deviceId)).map(Entry::getKey).map(McastStoreKey::mcastIp).collect(Collectors.toSet());
}
#end_block

#method_before
public void updateFilterToDevice(DeviceId deviceId, PortNumber portNum, VlanId vlanId, boolean install) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Iterates over the route and updates properly the filtering objective
        // on the source device.
        srManager.multicastRouteService.getRoutes().forEach(mcastRoute -> {
            ConnectPoint source = srManager.multicastRouteService.fetchSource(mcastRoute);
            if (source.deviceId().equals(deviceId) && source.port().equals(portNum)) {
                if (install) {
                    addFilterToDevice(deviceId, portNum, vlanId, mcastRoute.group(), INGRESS);
                } else {
                    removeFilterToDevice(deviceId, portNum, vlanId, mcastRoute.group(), null);
                }
            }
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
public void updateFilterToDevice(DeviceId deviceId, PortNumber portNum, VlanId vlanId, boolean install) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Iterates over the route and updates properly the filtering objective
        // on the source device.
        srManager.multicastRouteService.getRoutes().forEach(mcastRoute -> {
            // FIXME To be addressed with multiple sources support
            ConnectPoint source = srManager.multicastRouteService.sources(mcastRoute).stream().findFirst().orElse(null);
            if (source.deviceId().equals(deviceId) && source.port().equals(portNum)) {
                if (install) {
                    addFilterToDevice(deviceId, portNum, vlanId, mcastRoute.group(), INGRESS);
                } else {
                    removeFilterToDevice(deviceId, portNum, vlanId, mcastRoute.group(), null);
                }
            }
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
public Map<McastStoreKey, Integer> getMcastNextIds(IpAddress mcastIp) {
    // If mcast ip is present
    if (mcastIp != null) {
        return mcastNextObjStore.entrySet().stream().filter(mcastEntry -> mcastIp.equals(mcastEntry.getKey().mcastIp())).collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().value().id()));
    }
    // Otherwise take all the groups
    return mcastNextObjStore.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().value().id()));
}
#method_after
public Map<McastStoreKey, Integer> getMcastNextIds(IpAddress mcastIp) {
    // If mcast ip is present
    if (mcastIp != null) {
        return mcastNextObjStore.entrySet().stream().filter(mcastEntry -> mcastIp.equals(mcastEntry.getKey().mcastIp())).collect(Collectors.toMap(Entry::getKey, entry -> entry.getValue().value().id()));
    }
    // Otherwise take all the groups
    return mcastNextObjStore.entrySet().stream().collect(Collectors.toMap(Entry::getKey, entry -> entry.getValue().value().id()));
}
#end_block

#method_before
public Map<McastStoreKey, McastRole> getMcastRoles(IpAddress mcastIp) {
    // If mcast ip is present
    if (mcastIp != null) {
        return mcastRoleStore.entrySet().stream().filter(mcastEntry -> mcastIp.equals(mcastEntry.getKey().mcastIp())).collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().value()));
    }
    // Otherwise take all the groups
    return mcastRoleStore.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().value()));
}
#method_after
public Map<McastStoreKey, McastRole> getMcastRoles(IpAddress mcastIp) {
    // If mcast ip is present
    if (mcastIp != null) {
        return mcastRoleStore.entrySet().stream().filter(mcastEntry -> mcastIp.equals(mcastEntry.getKey().mcastIp())).collect(Collectors.toMap(Entry::getKey, entry -> entry.getValue().value()));
    }
    // Otherwise take all the groups
    return mcastRoleStore.entrySet().stream().collect(Collectors.toMap(Entry::getKey, entry -> entry.getValue().value()));
}
#end_block

#method_before
@Override
public L2TunnelHandler.Result addPseudowiresBulk(List<DefaultL2TunnelDescription> bulkPseudowires) {
    // get both added and pending pseudowires
    List<L2TunnelDescription> pseudowires = new ArrayList<>();
    pseudowires.addAll(l2TunnelHandler.getL2Descriptions(false));
    pseudowires.addAll(l2TunnelHandler.getL2Descriptions(true));
    pseudowires.addAll(bulkPseudowires);
    Set<L2TunnelDescription> newPseudowires = new HashSet(bulkPseudowires);
    // check global validity for all the new pseudowires, if it fails
    // do not add any of them
    log.debug("Verifying set of pseudowires {}", pseudowires);
    boolean res = configurationValidity(pseudowires);
    if (res) {
        log.debug("Pseudowire configuration is valid, deploying pseudowires!");
        l2TunnelHandler.deploy(newPseudowires);
        return L2TunnelHandler.Result.SUCCESS;
    } else {
        log.error("Bulk pseudowires {} can not be added, error in global configuration!", newPseudowires);
        return L2TunnelHandler.Result.ADDITION_ERROR;
    }
}
#method_after
@Deprecated
public L2TunnelHandler.Result addPseudowiresBulk(List<DefaultL2TunnelDescription> bulkPseudowires) {
    // get both added and pending pseudowires
    List<L2TunnelDescription> pseudowires = new ArrayList<>();
    pseudowires.addAll(l2TunnelHandler.getL2Descriptions(false));
    pseudowires.addAll(l2TunnelHandler.getL2Descriptions(true));
    pseudowires.addAll(bulkPseudowires);
    Set<L2TunnelDescription> newPseudowires = new HashSet(bulkPseudowires);
    L2TunnelHandler.Result retRes = L2TunnelHandler.Result.SUCCESS;
    L2TunnelHandler.Result res;
    for (DefaultL2TunnelDescription pw : bulkPseudowires) {
        res = addPseudowire(pw);
        if (res != L2TunnelHandler.Result.SUCCESS) {
            log.error("Pseudowire with id {} can not be instantiated !", res);
            retRes = res;
        }
    }
    return retRes;
}
#end_block

#method_before
@Override
public L2TunnelHandler.Result addPseudowire(L2TunnelDescription l2TunnelDescription) {
    // get both added and pending pseudowires
    List<L2TunnelDescription> newPseudowires = new ArrayList<>();
    newPseudowires.addAll(l2TunnelHandler.getL2Descriptions(false));
    newPseudowires.addAll(l2TunnelHandler.getL2Descriptions(true));
    // add the new pseudowire to the List
    newPseudowires.add(l2TunnelDescription);
    // validate the new list of pseudowires
    boolean res = configurationValidity(newPseudowires);
    if (res) {
        // deploy a set with ONLY the new pseudowire
        Set<L2TunnelDescription> pwToDeploy = new HashSet<>();
        pwToDeploy.add(l2TunnelDescription);
        l2TunnelHandler.deploy(pwToDeploy);
        log.info("Pseudowire with {} deployment started, check log for any errors in this process!", l2TunnelDescription.l2Tunnel().tunnelId());
        return L2TunnelHandler.Result.SUCCESS;
    } else {
        log.error("Pseudowire with {} can not be added!", l2TunnelDescription.l2Tunnel().tunnelId());
        return L2TunnelHandler.Result.ADDITION_ERROR;
    }
}
#method_after
@Override
public L2TunnelHandler.Result addPseudowire(L2TunnelDescription l2TunnelDescription) {
    return l2TunnelHandler.deployPseudowire(l2TunnelDescription);
}
#end_block

#method_before
@Override
public L2TunnelHandler.Result removePseudowire(Integer pwId) {
    // get both added and pending pseudowires
    Set<L2TunnelDescription> pseudowires = l2TunnelHandler.getL2Descriptions(false).stream().filter(pw -> pw.l2Tunnel().tunnelId() == pwId).collect(Collectors.toSet());
    Set<L2TunnelDescription> pendingPseudowires = l2TunnelHandler.getL2Descriptions(true).stream().filter(pw -> pw.l2Tunnel().tunnelId() == pwId).collect(Collectors.toSet());
    if ((pendingPseudowires.size() == 0) && (pseudowires.size() == 0)) {
        log.error("Pseudowire with id {} does not exist", pwId);
        return L2TunnelHandler.Result.REMOVAL_ERROR;
    }
    if (pendingPseudowires.size() != 0) {
        log.info("Remove pseudowire from pending store!");
    // will fill when we implement failure mechanism detection.
    }
    if (pseudowires.size() != 0) {
        l2TunnelHandler.tearDown(new HashSet<>(pseudowires));
        log.info("Removal of pseudowire with {} started, check log for any errors in this process!", pwId);
    }
    return L2TunnelHandler.Result.SUCCESS;
}
#method_after
@Override
public L2TunnelHandler.Result removePseudowire(Integer pwId) {
    return l2TunnelHandler.tearDownPseudowire(pwId);
}
#end_block

#method_before
void processLinkAdded(Link link) {
    log.info("** LINK ADDED {}", link.toString());
    if (!isLinkValid(link)) {
        return;
    }
    // Irrespective of whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules if needed,
    // as in a multi-instance setup, instances can initiate groups for any
    // device. Also update local groupHandler stores.
    DefaultGroupHandler groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portUpForLink(link);
    } else {
        Device device = srManager.deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added notification without " + "Device Added event, still handling it");
            srManager.processDeviceAdded(device);
            groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
            if (groupHandler != null) {
                groupHandler.portUpForLink(link);
            }
        }
    }
    if (isSeenLink(link)) {
        // temp store retains previous state, just before the state is updated in
        // seenLinks; previous state is necessary when processing the
        // linkupdate in defaultRoutingHandler
        seenBefore.add(link);
    }
    updateSeenLink(link, true);
    if (srManager.deviceConfiguration == null || !srManager.deviceConfiguration.isConfigured(link.src().deviceId())) {
        log.warn("Source device of this link is not configured.. " + "not processing further");
        return;
    }
    // process link only if it is bidirectional
    if (!isBidirectionalLinkUp(link)) {
        log.debug("Link not bidirectional.. waiting for other direction " + "src {} --> dst {} ", link.dst(), link.src());
        return;
    }
    // link is bidi, process both unidirectional links
    Link reverseLink = linkService.getLink(link.dst(), link.src());
    List<Link> componentLinks;
    if (reverseLink == null) {
        log.error("cannot find reverse link for declared bidi-link: {}", link);
        componentLinks = Lists.newArrayList(link);
    } else {
        log.info("processing bidi links {} <--> {} UP", link.src(), link.dst());
        componentLinks = Lists.newArrayList(reverseLink, link);
    }
    for (Link ulink : componentLinks) {
        log.info("Starting optimized route-path processing for component " + "unidirectional link {} --> {} UP", ulink.src(), ulink.dst());
        srManager.defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, ulink, null, seenBefore.contains(ulink));
        if (srManager.mastershipService.isLocalMaster(ulink.src().deviceId())) {
            // handle edge-ports for dual-homed hosts
            updateDualHomedHostPorts(ulink, true);
            // for the link that has come up.
            if (groupHandler != null) {
                if (!seenBefore.contains(ulink) && isParallelLink(ulink)) {
                    // if link seen first time, we need to ensure hash-groups have
                    // all ports
                    log.debug("Attempting retryHash for paralled first-time link {}", ulink);
                    groupHandler.retryHash(ulink, false, true);
                } else {
                    // seen before-link
                    if (isParallelLink(ulink)) {
                        log.debug("Attempting retryHash for paralled seen-before " + "link {}", ulink);
                        groupHandler.retryHash(ulink, false, false);
                    }
                }
            }
        }
        // clean up temp state
        seenBefore.remove(ulink);
    }
}
#method_after
void processLinkAdded(Link link) {
    log.info("** LINK ADDED {}", link.toString());
    if (!isLinkValid(link)) {
        return;
    }
    // Irrespective of whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules if needed,
    // as in a multi-instance setup, instances can initiate groups for any
    // device. Also update local groupHandler stores.
    DefaultGroupHandler groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portUpForLink(link);
    } else {
        Device device = srManager.deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added notification without " + "Device Added event, still handling it");
            srManager.processDeviceAdded(device);
            groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
            if (groupHandler != null) {
                groupHandler.portUpForLink(link);
            }
        }
    }
    if (isSeenLink(link)) {
        // temp store retains previous state, just before the state is updated in
        // seenLinks; previous state is necessary when processing the
        // linkupdate in defaultRoutingHandler
        seenBefore.add(link);
    }
    updateSeenLink(link, true);
    if (srManager.deviceConfiguration == null || !srManager.deviceConfiguration.isConfigured(link.src().deviceId())) {
        log.warn("Source device of this link is not configured.. " + "not processing further");
        return;
    }
    // process link only if it is bidirectional
    if (!isBidirectionalLinkUp(link)) {
        log.debug("Link not bidirectional.. waiting for other direction " + "src {} --> dst {} ", link.dst(), link.src());
        return;
    }
    log.info("processing bidi links {} <--> {} UP", link.src(), link.dst());
    for (Link ulink : getBidiComponentLinks(link)) {
        log.info("Starting optimized route-path processing for component " + "unidirectional link {} --> {} UP", ulink.src(), ulink.dst());
        srManager.defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, ulink, null, seenBefore.contains(ulink));
        if (srManager.mastershipService.isLocalMaster(ulink.src().deviceId())) {
            // handle edge-ports for dual-homed hosts
            updateDualHomedHostPorts(ulink, true);
            // groups to include new buckets for the link that has come up.
            if (groupHandler != null) {
                if (!seenBefore.contains(ulink) && isParallelLink(ulink)) {
                    // if link seen first time, we need to ensure hash-groups have
                    // all ports
                    log.debug("Attempting retryHash for paralled first-time link {}", ulink);
                    groupHandler.retryHash(ulink, false, true);
                } else {
                    // seen before-link
                    if (isParallelLink(ulink)) {
                        log.debug("Attempting retryHash for paralled seen-before " + "link {}", ulink);
                        groupHandler.retryHash(ulink, false, false);
                    }
                }
            }
        }
        // clean up temp state
        seenBefore.remove(ulink);
    }
}
#end_block

#method_before
void processLinkRemoved(Link link) {
    log.info("** LINK REMOVED {}", link.toString());
    if (!isLinkValid(link)) {
        return;
    }
    // when removing links, update seen links first, before doing route-path
    // changes
    updateSeenLink(link, false);
    // handle edge-ports for dual-homed hosts
    if (srManager.mastershipService.isLocalMaster(link.src().deviceId())) {
        updateDualHomedHostPorts(link, false);
    }
    // when switch comes back.
    if (link.src().elementId() instanceof DeviceId && !srManager.deviceService.isAvailable(link.src().deviceId())) {
        purgeSeenLink(link);
        return;
    }
    if (link.dst().elementId() instanceof DeviceId && !srManager.deviceService.isAvailable(link.dst().deviceId())) {
        purgeSeenLink(link);
        return;
    }
    // process link only if it is bidirectional
    if (!isBidirectionalLinkDown(link)) {
        log.debug("Link not bidirectional.. waiting for other direction " + "src {} --> dst {} ", link.dst(), link.src());
        return;
    }
    // link is bidi, process both unidirectional links
    Link reverseLink = getReverseLink(link);
    List<Link> componentLinks;
    if (reverseLink == null) {
        log.error("cannot find reverse link for declared bidi-link: {}", link);
        componentLinks = Lists.newArrayList(link);
    } else {
        log.info("processing bidi links {} <--> {} DOWN", link.src(), link.dst());
        componentLinks = Lists.newArrayList(reverseLink, link);
    }
    for (Link ulink : componentLinks) {
        log.info("Starting optimized route-path processing for component " + "unidirectional link {} --> {} DOWN", ulink.src(), ulink.dst());
        srManager.defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(ulink, null, null, true);
        // attempt rehashing for parallel links
        DefaultGroupHandler groupHandler = srManager.groupHandlerMap.get(ulink.src().deviceId());
        if (groupHandler != null) {
            if (srManager.mastershipService.isLocalMaster(ulink.src().deviceId()) && isParallelLink(ulink)) {
                log.debug("* retrying hash for parallel link removed:{}", ulink);
                groupHandler.retryHash(ulink, true, false);
            } else {
                log.debug("Not attempting retry-hash for link removed: {} .. {}", ulink, (srManager.mastershipService.isLocalMaster(ulink.src().deviceId())) ? "not parallel" : "not master");
            }
            // ensure local stores are updated after all rerouting or rehashing
            groupHandler.portDownForLink(ulink);
        } else {
            log.warn("group handler not found for dev:{} when removing link: {}", ulink.src().deviceId(), ulink);
        }
    }
}
#method_after
void processLinkRemoved(Link link) {
    log.info("** LINK REMOVED {}", link.toString());
    if (!isLinkValid(link)) {
        return;
    }
    // when removing links, update seen links first, before doing route-path
    // changes
    updateSeenLink(link, false);
    // handle edge-ports for dual-homed hosts
    if (srManager.mastershipService.isLocalMaster(link.src().deviceId())) {
        updateDualHomedHostPorts(link, false);
    }
    // when switch comes back.
    if (link.src().elementId() instanceof DeviceId && !srManager.deviceService.isAvailable(link.src().deviceId())) {
        purgeSeenLink(link);
        return;
    }
    if (link.dst().elementId() instanceof DeviceId && !srManager.deviceService.isAvailable(link.dst().deviceId())) {
        purgeSeenLink(link);
        return;
    }
    // process link only if it is bidirectional
    if (!isBidirectionalLinkDown(link)) {
        log.debug("Link not bidirectional.. waiting for other direction " + "src {} --> dst {} ", link.dst(), link.src());
        return;
    }
    log.info("processing bidi links {} <--> {} DOWN", link.src(), link.dst());
    for (Link ulink : getBidiComponentLinks(link)) {
        log.info("Starting optimized route-path processing for component " + "unidirectional link {} --> {} DOWN", ulink.src(), ulink.dst());
        srManager.defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(ulink, null, null, true);
        // attempt rehashing for parallel links
        DefaultGroupHandler groupHandler = srManager.groupHandlerMap.get(ulink.src().deviceId());
        if (groupHandler != null) {
            if (srManager.mastershipService.isLocalMaster(ulink.src().deviceId()) && isParallelLink(ulink)) {
                log.debug("* retrying hash for parallel link removed:{}", ulink);
                groupHandler.retryHash(ulink, true, false);
            } else {
                log.debug("Not attempting retry-hash for link removed: {} .. {}", ulink, (srManager.mastershipService.isLocalMaster(ulink.src().deviceId())) ? "not parallel" : "not master");
            }
            // ensure local stores are updated after all rerouting or rehashing
            groupHandler.portDownForLink(ulink);
        } else {
            log.warn("group handler not found for dev:{} when removing link: {}", ulink.src().deviceId(), ulink);
        }
    }
}
#end_block

#method_before
private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {
    return CompletableFuture.supplyAsync(() -> {
        // TODO: explore a more relaxed locking strategy.
        writeLock.lock();
        try {
            return supplier.get();
        } catch (Throwable ex) {
            if (ex instanceof StatusRuntimeException) {
                log.warn("Unable to execute {} on {}: {}", opDescription, deviceId, ex.toString());
            } else {
                log.error("Exception in client of {}, executing {}", deviceId, opDescription, ex);
            }
            throw ex;
        } finally {
            writeLock.unlock();
        }
    }, contextExecutor);
}
#method_after
private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {
    return CompletableFuture.supplyAsync(() -> {
        // TODO: explore a more relaxed locking strategy.
        writeLock.lock();
        try {
            return supplier.get();
        } catch (StatusRuntimeException ex) {
            log.warn("Unable to execute {} on {}: {}", opDescription, deviceId, ex.toString());
            throw ex;
        } catch (Throwable ex) {
            log.error("Exception in client of {}, executing {}", deviceId, opDescription, ex);
            throw ex;
        } finally {
            writeLock.unlock();
        }
    }, contextExecutor);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> setPipelineConfig(PiPipeconf pipeconf, ExtensionType targetConfigExtType) {
    return supplyInContext(() -> doSetPipelineConfig(pipeconf, targetConfigExtType), "setPipelineConfig");
}
#method_after
@Override
public CompletableFuture<Boolean> setPipelineConfig(PiPipeconf pipeconf, ByteBuffer deviceData) {
    return supplyInContext(() -> doSetPipelineConfig(pipeconf, deviceData), "setPipelineConfig");
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<PiCounterCellData>> readAllCounterCells(Set<PiCounterId> counterIds, PiPipeconf pipeconf) {
    /*
        From p4runtime.proto, the scope of a ReadRequest is defined as follows:
        CounterEntry:
            - All counter cells for all meters if counter_id = 0 (default).
            - All counter cells for given counter_id if index = 0 (default).
        DirectCounterEntry:
            - All counter cells for all meters if counter_id = 0 (default).
            - All counter cells for given counter_id if table_entry.match is empty.
         */
    Set<PiCounterCellId> cellIds = Sets.newHashSet();
    for (PiCounterId counterId : counterIds) {
        switch(counterId.type()) {
            case INDIRECT:
                cellIds.add(PiIndirectCounterCellId.of(counterId, 0));
                break;
            case DIRECT:
                cellIds.add(PiDirectCounterCellId.of(counterId, PiTableEntry.EMTPY));
                break;
            default:
                log.warn("Unrecognized PI counter ID '{}'", counterId.type());
        }
    }
    return supplyInContext(() -> doReadCounterCells(cellIds, pipeconf), "readAllCounterCells-" + cellIds.hashCode());
}
#method_after
@Override
public CompletableFuture<Collection<PiCounterCellData>> readAllCounterCells(Set<PiCounterId> counterIds, PiPipeconf pipeconf) {
    /*
        From p4runtime.proto, the scope of a ReadRequest is defined as follows:
        CounterEntry:
            - All counter cells for all meters if counter_id = 0 (default).
            - All counter cells for given counter_id if index = 0 (default).
        DirectCounterEntry:
            - All counter cells for all meters if counter_id = 0 (default).
            - All counter cells for given counter_id if table_entry.match is empty.
         */
    Set<PiCounterCellId> cellIds = Sets.newHashSet();
    for (PiCounterId counterId : counterIds) {
        if (!pipeconf.pipelineModel().counter(counterId).isPresent()) {
            log.warn("Unable to find counter '{}' in pipeline model", counterId);
            continue;
        }
        PiCounterType counterType = pipeconf.pipelineModel().counter(counterId).get().counterType();
        switch(counterType) {
            case INDIRECT:
                cellIds.add(PiCounterCellId.ofIndirect(counterId, 0));
                break;
            case DIRECT:
                cellIds.add(PiCounterCellId.ofDirect(counterId, PiTableEntry.EMTPY));
                break;
            default:
                log.warn("Unrecognized PI counter type '{}'", counterType);
        }
    }
    return supplyInContext(() -> doReadCounterCells(cellIds, pipeconf), "readAllCounterCells-" + cellIds.hashCode());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> writeActionGroupMembers(PiActionGroup group, Collection<PiActionGroupMember> members, WriteOperationType opType, PiPipeconf pipeconf) {
    return supplyInContext(() -> doWriteActionGroupMembers(group, members, opType, pipeconf), "writeActionGroupMembers-" + opType.name());
}
#method_after
@Override
public CompletableFuture<Boolean> writeActionGroupMembers(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    return supplyInContext(() -> doWriteActionGroupMembers(group, opType, pipeconf), "writeActionGroupMembers-" + opType.name());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> writeMeterCells(Collection<PiMeterCellConfig> cellIds, WriteOperationType opType, PiPipeconf pipeconf) {
    return supplyInContext(() -> doWriteMeterCells(cellIds, opType, pipeconf), "writeMeterCells-" + opType.name());
}
#method_after
public CompletableFuture<Boolean> writeMeterCells(Collection<PiMeterCellConfig> cellIds, PiPipeconf pipeconf) {
    return supplyInContext(() -> doWriteMeterCells(cellIds, pipeconf), "writeMeterCells");
}
#end_block

#method_before
public CompletableFuture<Collection<PiMeterCellConfig>> readMeterCells(Set<PiMeterCellId> cellIds, PiPipeconf pipeconf) {
    return supplyInContext(() -> doReadMeterCells(cellIds, pipeconf), "readMeterCells-" + cellIds.hashCode());
}
#method_after
@Override
public CompletableFuture<Collection<PiMeterCellConfig>> readMeterCells(Set<PiMeterCellId> cellIds, PiPipeconf pipeconf) {
    return supplyInContext(() -> doReadMeterCells(cellIds, pipeconf), "readMeterCells-" + cellIds.hashCode());
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<PiMeterCellConfig>> readAllMeterCells(Set<PiMeterId> meterIds, PiPipeconf pipeconf) {
    /*
        From p4runtime.proto, the scope of a ReadRequest is defined as follows:
        MeterEntry:
            - All meter cells for all meters if meter_id = 0 (default).
            - All meter cells for given meter_id if index = 0 (default).
        DirectCounterEntry:
            - All meter cells for all meters if meter_id = 0 (default).
            - All meter cells for given meter_id if table_entry.match is empty.
         */
    Set<PiMeterCellId> cellIds = Sets.newHashSet();
    for (PiMeterId meterId : meterIds) {
        switch(meterId.type()) {
            case INDIRECT:
                cellIds.add(PiIndirectMeterCellId.of(meterId, 0));
                break;
            case DIRECT:
                cellIds.add(PiDirectMeterCellId.of(meterId, PiTableEntry.EMTPY));
                break;
            default:
                log.warn("Unrecognized PI counter ID '{}'", meterId.type());
        }
    }
    return supplyInContext(() -> doReadMeterCells(cellIds, pipeconf), "readAllMeterCells-" + cellIds.hashCode());
}
#method_after
@Override
public CompletableFuture<Collection<PiMeterCellConfig>> readAllMeterCells(Set<PiMeterId> meterIds, PiPipeconf pipeconf) {
    /*
        From p4runtime.proto, the scope of a ReadRequest is defined as follows:
        MeterEntry:
            - All meter cells for all meters if meter_id = 0 (default).
            - All meter cells for given meter_id if index = 0 (default).
        DirectCounterEntry:
            - All meter cells for all meters if meter_id = 0 (default).
            - All meter cells for given meter_id if table_entry.match is empty.
         */
    Set<PiMeterCellId> cellIds = Sets.newHashSet();
    for (PiMeterId meterId : meterIds) {
        PiMeterType meterType = pipeconf.pipelineModel().meter(meterId).get().meterType();
        switch(meterType) {
            case INDIRECT:
                cellIds.add(PiMeterCellId.ofIndirect(meterId, DEFAULT_INDEX));
                break;
            case DIRECT:
                cellIds.add(PiMeterCellId.ofDirect(meterId, PiTableEntry.EMTPY));
                break;
            default:
                log.warn("Unrecognized PI meter type '{}'", meterType);
        }
    }
    return supplyInContext(() -> doReadMeterCells(cellIds, pipeconf), "readAllMeterCells-" + cellIds.hashCode());
}
#end_block

#method_before
private boolean doArbitrationUpdate() {
    log.info("Sending arbitration update to {}...", deviceId);
    StreamMessageRequest requestMsg = StreamMessageRequest.newBuilder().setArbitration(MasterArbitrationUpdate.newBuilder().setDeviceId(p4DeviceId).build()).build();
    try {
        streamRequestObserver.onNext(requestMsg);
        return true;
    } catch (StatusRuntimeException e) {
        log.warn("Arbitration update failed for {}: {}", deviceId, e);
        return false;
    }
}
#method_after
/* Blocking method implementations below */
private boolean doArbitrationUpdate() {
    CompletableFuture<Boolean> result = new CompletableFuture<>();
    // TODO: currently we use 64-bit Long type for election id, should
    // we use 128-bit ?
    long nextElectId = controller.getNewMasterElectionId();
    Uint128 newElectionId = Uint128.newBuilder().setLow(nextElectId).build();
    MasterArbitrationUpdate arbitrationUpdate = MasterArbitrationUpdate.newBuilder().setDeviceId(p4DeviceId).setElectionId(newElectionId).build();
    StreamMessageRequest requestMsg = StreamMessageRequest.newBuilder().setArbitration(arbitrationUpdate).build();
    log.debug("Sending arbitration update to {} with election id {}...", deviceId, newElectionId);
    arbitrationUpdateMap.put(newElectionId, result);
    try {
        streamRequestObserver.onNext(requestMsg);
        return result.get();
    } catch (StatusRuntimeException e) {
        log.error("Unable to perform arbitration update on {}: {}", deviceId, e.getMessage());
        arbitrationUpdateMap.remove(newElectionId);
        return false;
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Arbitration update failed for {} due to {}", deviceId, e);
        arbitrationUpdateMap.remove(newElectionId);
        return false;
    }
}
#end_block

#method_before
/* Blocking method implementations below */
private boolean doInitStreamChannel() {
    // To listen for packets and other events, we need to start the RPC.
    // Here we do it by sending a master arbitration update.
    log.info("initializing stream chanel on {}...", deviceId);
    if (!doArbitrationUpdate()) {
        log.warn("Unable to initialize stream channel for {}", deviceId);
        return false;
    } else {
        return true;
    }
}
#method_after
private boolean doInitStreamChannel() {
    // Here we do it by sending a master arbitration update.
    return doArbitrationUpdate();
}
#end_block

#method_before
private boolean doSetPipelineConfig(PiPipeconf pipeconf, ExtensionType targetConfigExtType) {
    log.info("Setting pipeline config for {} to {} using {}...", deviceId, pipeconf.id(), targetConfigExtType);
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return false;
    }
    ForwardingPipelineConfig.Builder pipelineConfigBuilder = ForwardingPipelineConfig.newBuilder().setDeviceId(p4DeviceId).setP4Info(p4Info);
    // if the target config extension is null we don't want to add the config.
    if (targetConfigExtType != null) {
        if (!pipeconf.extension(targetConfigExtType).isPresent()) {
            log.warn("Missing extension {} in pipeconf {}", targetConfigExtType, pipeconf.id());
            return false;
        }
        InputStream targetConfig = pipeconf.extension(targetConfigExtType).get();
        P4Config.P4DeviceConfig p4DeviceConfigMsg;
        try {
            p4DeviceConfigMsg = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.readFrom(targetConfig)).build();
            pipelineConfigBuilder.setP4DeviceConfig(p4DeviceConfigMsg.toByteString());
        } catch (IOException ex) {
            log.warn("Unable to load target-specific config for {}: {}", deviceId, ex.getMessage());
            return false;
        }
    }
    SetForwardingPipelineConfigRequest request = SetForwardingPipelineConfigRequest.newBuilder().setAction(VERIFY_AND_COMMIT).addConfigs(pipelineConfigBuilder.build()).build();
    try {
        this.blockingStub.setForwardingPipelineConfig(request);
    } catch (StatusRuntimeException ex) {
        log.warn("Unable to set pipeline config for {}: {}", deviceId, ex.getMessage());
        return false;
    }
    return true;
}
#method_after
private boolean doSetPipelineConfig(PiPipeconf pipeconf, ByteBuffer deviceData) {
    log.info("Setting pipeline config for {} to {}...", deviceId, pipeconf.id());
    checkNotNull(deviceData, "deviceData cannot be null");
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return false;
    }
    P4Config.P4DeviceConfig p4DeviceConfigMsg = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.copyFrom(deviceData)).build();
    ForwardingPipelineConfig pipelineConfig = ForwardingPipelineConfig.newBuilder().setP4Info(p4Info).setP4DeviceConfig(p4DeviceConfigMsg.toByteString()).build();
    SetForwardingPipelineConfigRequest request = SetForwardingPipelineConfigRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).setAction(VERIFY_AND_COMMIT).setConfig(pipelineConfig).build();
    try {
        this.blockingStub.setForwardingPipelineConfig(request);
        return true;
    } catch (StatusRuntimeException ex) {
        log.warn("Unable to set pipeline config on {}: {}", deviceId, ex.getMessage());
        return false;
    }
}
#end_block

#method_before
private boolean doWriteTableEntries(Collection<PiTableEntry> piTableEntries, WriteOperationType opType, PiPipeconf pipeconf) {
    WriteRequest.Builder writeRequestBuilder = WriteRequest.newBuilder();
    Collection<Update> updateMsgs = TableEntryEncoder.encode(piTableEntries, pipeconf).stream().map(tableEntryMsg -> Update.newBuilder().setEntity(Entity.newBuilder().setTableEntry(tableEntryMsg).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        return true;
    }
    writeRequestBuilder.setDeviceId(p4DeviceId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestBuilder.build());
        return true;
    } catch (StatusRuntimeException e) {
        log.warn("Unable to write table entries ({}): {}", opType, e.getMessage());
        return false;
    }
}
#method_after
private boolean doWriteTableEntries(Collection<PiTableEntry> piTableEntries, WriteOperationType opType, PiPipeconf pipeconf) {
    WriteRequest.Builder writeRequestBuilder = WriteRequest.newBuilder();
    if (piTableEntries.size() == 0) {
        return true;
    }
    Collection<Update> updateMsgs = null;
    try {
        updateMsgs = TableEntryEncoder.encode(piTableEntries, pipeconf).stream().map(tableEntryMsg -> Update.newBuilder().setEntity(Entity.newBuilder().setTableEntry(tableEntryMsg).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    } catch (EncodeException e) {
        log.error("Unable to encode table entries, aborting {} operation: {}", opType.name(), e.getMessage());
        return false;
    }
    writeRequestBuilder.setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestBuilder.build());
        return true;
    } catch (StatusRuntimeException e) {
        logWriteErrors(piTableEntries, e, opType, "table entry");
        return false;
    }
}
#end_block

#method_before
private Collection<PiTableEntry> doDumpTable(PiTableId piTableId, PiPipeconf pipeconf) {
    log.debug("Dumping table {} from {} (pipeconf {})...", piTableId, deviceId, pipeconf.id());
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    int tableId;
    try {
        tableId = browser.tables().getByName(piTableId.id()).getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    ReadRequest requestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setTableEntry(TableEntry.newBuilder().setTableId(tableId).build()).build()).build();
    Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    Iterable<ReadResponse> responseIterable = () -> responses;
    List<TableEntry> tableEntryMsgs = StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == TABLE_ENTRY).map(Entity::getTableEntry).collect(Collectors.toList());
    log.debug("Retrieved {} entries from table {} on {}...", tableEntryMsgs.size(), piTableId, deviceId);
    return TableEntryEncoder.decode(tableEntryMsgs, pipeconf);
}
#method_after
private Collection<PiTableEntry> doDumpTable(PiTableId piTableId, PiPipeconf pipeconf) {
    log.debug("Dumping table {} from {} (pipeconf {})...", piTableId, deviceId, pipeconf.id());
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    int tableId;
    try {
        tableId = browser.tables().getByName(piTableId.id()).getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    ReadRequest requestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setTableEntry(TableEntry.newBuilder().setTableId(tableId).build()).build()).build();
    Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to dump table {} from {}: {}", piTableId, deviceId, e.getMessage());
        return Collections.emptyList();
    }
    Iterable<ReadResponse> responseIterable = () -> responses;
    List<TableEntry> tableEntryMsgs = StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == TABLE_ENTRY).map(Entity::getTableEntry).collect(Collectors.toList());
    log.debug("Retrieved {} entries from table {} on {}...", tableEntryMsgs.size(), piTableId, deviceId);
    return TableEntryEncoder.decode(tableEntryMsgs, pipeconf);
}
#end_block

#method_before
private void doPacketIn(PacketIn packetInMsg) {
    // Retrieve the pipeconf for this client's device.
    PiPipeconfService pipeconfService = DefaultServiceDirectory.getService(PiPipeconfService.class);
    if (pipeconfService == null) {
        throw new IllegalStateException("PiPipeconfService is null. Can't handle packet in.");
    }
    final PiPipeconf pipeconf;
    if (pipeconfService.ofDevice(deviceId).isPresent() && pipeconfService.getPipeconf(pipeconfService.ofDevice(deviceId).get()).isPresent()) {
        pipeconf = pipeconfService.getPipeconf(pipeconfService.ofDevice(deviceId).get()).get();
    } else {
        log.warn("Unable to get pipeconf of {}. Can't handle packet in", deviceId);
        return;
    }
    // Decode packet message and post event.
    PiPacketOperation packetOperation = PacketIOCodec.decodePacketIn(packetInMsg, pipeconf);
    DefaultPacketIn packetInEventSubject = new DefaultPacketIn(deviceId, packetOperation);
    P4RuntimeEvent event = new P4RuntimeEvent(P4RuntimeEvent.Type.PACKET_IN, packetInEventSubject);
    log.debug("Received packet in: {}", event);
    controller.postEvent(event);
}
#method_after
private void doPacketIn(PacketIn packetInMsg) {
    // Retrieve the pipeconf for this client's device.
    PiPipeconfService pipeconfService = DefaultServiceDirectory.getService(PiPipeconfService.class);
    if (pipeconfService == null) {
        throw new IllegalStateException("PiPipeconfService is null. Can't handle packet in.");
    }
    final PiPipeconf pipeconf;
    if (pipeconfService.ofDevice(deviceId).isPresent() && pipeconfService.getPipeconf(pipeconfService.ofDevice(deviceId).get()).isPresent()) {
        pipeconf = pipeconfService.getPipeconf(pipeconfService.ofDevice(deviceId).get()).get();
    } else {
        log.warn("Unable to get pipeconf of {}. Can't handle packet in", deviceId);
        return;
    }
    // Decode packet message and post event.
    PiPacketOperation packetOperation = PacketIOCodec.decodePacketIn(packetInMsg, pipeconf, deviceId);
    DefaultPacketIn packetInEventSubject = new DefaultPacketIn(deviceId, packetOperation);
    P4RuntimeEvent event = new P4RuntimeEvent(P4RuntimeEvent.Type.PACKET_IN, packetInEventSubject);
    log.debug("Received packet in: {}", event);
    controller.postEvent(event);
}
#end_block

#method_before
private void doArbitrationUpdateFromDevice(MasterArbitrationUpdate arbitrationMsg) {
    log.warn("Received arbitration update from {} (NOT IMPLEMENTED YET): {}", deviceId, arbitrationMsg);
}
#method_after
private void doArbitrationUpdateFromDevice(MasterArbitrationUpdate arbitrationMsg) {
    log.debug("Received arbitration update from {}: {}", deviceId, arbitrationMsg);
    Uint128 electionId = arbitrationMsg.getElectionId();
    CompletableFuture<Boolean> mastershipFeature = arbitrationUpdateMap.remove(electionId);
    if (mastershipFeature == null) {
        log.warn("Can't find completable future of election id {}", electionId);
        return;
    }
    this.p4RuntimeElectionId = electionId;
    int statusCode = arbitrationMsg.getStatus().getCode();
    MastershipRole arbitrationRole;
    if (statusCode == Status.OK.getCode().value()) {
        mastershipFeature.complete(true);
        arbitrationRole = MastershipRole.MASTER;
    } else {
        mastershipFeature.complete(false);
        arbitrationRole = MastershipRole.STANDBY;
    }
    DefaultArbitration arbitrationEventSubject = new DefaultArbitration(arbitrationRole, electionId);
    P4RuntimeEvent event = new P4RuntimeEvent(P4RuntimeEvent.Type.ARBITRATION, arbitrationEventSubject);
    controller.postEvent(event);
}
#end_block

#method_before
private Collection<PiCounterCellData> doReadCounterCells(Collection<PiCounterCellId> cellIds, PiPipeconf pipeconf) {
    // We use this map to remember the original PI counter IDs of the returned response.
    final Map<Integer, PiCounterId> counterIdMap = Maps.newHashMap();
    final ReadRequest request = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addAllEntities(CounterEntryCodec.encodePiCounterCellIds(cellIds, counterIdMap, pipeconf)).build();
    if (request.getEntitiesList().size() == 0) {
        return Collections.emptyList();
    }
    final Iterable<ReadResponse> responses;
    try {
        responses = () -> blockingStub.read(request);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read counters: {}", e.getMessage());
        return Collections.emptyList();
    }
    List<Entity> entities = StreamSupport.stream(responses.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).collect(Collectors.toList());
    return CounterEntryCodec.decodeCounterEntities(entities, counterIdMap, pipeconf);
}
#method_after
private Collection<PiCounterCellData> doReadCounterCells(Collection<PiCounterCellId> cellIds, PiPipeconf pipeconf) {
    // We use this map to remember the original PI counter IDs of the returned response.
    final Map<Integer, PiCounterId> counterIdMap = Maps.newHashMap();
    final ReadRequest request = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addAllEntities(CounterEntryCodec.encodePiCounterCellIds(cellIds, counterIdMap, pipeconf)).build();
    if (request.getEntitiesList().size() == 0) {
        return Collections.emptyList();
    }
    final Iterable<ReadResponse> responses;
    try {
        responses = () -> blockingStub.read(request);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read counter cells from {}: {}", deviceId, e.getMessage());
        return Collections.emptyList();
    }
    List<Entity> entities = StreamSupport.stream(responses.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).collect(Collectors.toList());
    return CounterEntryCodec.decodeCounterEntities(entities, counterIdMap, pipeconf);
}
#end_block

#method_before
private boolean doWriteActionGroupMembers(PiActionGroup group, Collection<PiActionGroupMember> members, WriteOperationType opType, PiPipeconf pipeconf) {
    WriteRequest.Builder writeRequestBuilder = WriteRequest.newBuilder();
    Collection<ActionProfileMember> actionProfileMembers = Lists.newArrayList();
    try {
        for (PiActionGroupMember member : members) {
            actionProfileMembers.add(ActionProfileMemberEncoder.encode(group, member, pipeconf));
        }
    } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
        log.warn("Can't encode group member {} due to {}", members, e.getMessage());
        return false;
    }
    Collection<Update> updateMsgs = actionProfileMembers.stream().map(actionProfileMember -> Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileMember(actionProfileMember).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        // Nothing to update
        return true;
    }
    writeRequestBuilder.setDeviceId(p4DeviceId).addAllUpdates(updateMsgs);
    try {
        blockingStub.write(writeRequestBuilder.build());
        return true;
    } catch (StatusRuntimeException e) {
        log.warn("Unable to write table entries ({}): {}", opType, e.getMessage());
        return false;
    }
}
#method_after
private boolean doWriteActionGroupMembers(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    final Collection<ActionProfileMember> actionProfileMembers = Lists.newArrayList();
    for (PiActionGroupMember member : group.members()) {
        try {
            actionProfileMembers.add(ActionProfileMemberEncoder.encode(group, member, pipeconf));
        } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
            log.warn("Unable to encode group member, aborting {} operation: {} [{}]", opType.name(), e.getMessage(), member.toString());
            return false;
        }
    }
    final Collection<Update> updateMsgs = actionProfileMembers.stream().map(actionProfileMember -> Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileMember(actionProfileMember).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        // Nothing to update.
        return true;
    }
    WriteRequest writeRequestMsg = WriteRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestMsg);
        return true;
    } catch (StatusRuntimeException e) {
        logWriteErrors(group.members(), e, opType, "group member");
        return false;
    }
}
#end_block

#method_before
private Collection<PiActionGroup> doDumpGroups(PiActionProfileId piActionProfileId, PiPipeconf pipeconf) {
    log.debug("Dumping groups from action profile {} from {} (pipeconf {})...", piActionProfileId.id(), deviceId, pipeconf.id());
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    if (browser == null) {
        log.warn("Unable to get a P4Info browser for pipeconf {}, skipping dump action profile {}", pipeconf, piActionProfileId);
        return Collections.emptySet();
    }
    int actionProfileId;
    try {
        P4InfoOuterClass.ActionProfile actionProfile = browser.actionProfiles().getByName(piActionProfileId.id());
        actionProfileId = actionProfile.getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Can't find action profile {} from p4info", piActionProfileId);
        return Collections.emptySet();
    }
    ActionProfileGroup actionProfileGroup = ActionProfileGroup.newBuilder().setActionProfileId(actionProfileId).build();
    ReadRequest requestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setActionProfileGroup(actionProfileGroup).build()).build();
    Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read action profile {} due to {}", piActionProfileId, e.getMessage());
        return Collections.emptySet();
    }
    List<ActionProfileGroup> actionProfileGroups = Tools.stream(() -> responses).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == ACTION_PROFILE_GROUP).map(Entity::getActionProfileGroup).collect(Collectors.toList());
    log.debug("Retrieved {} groups from action profile {} on {}...", actionProfileGroups.size(), piActionProfileId.id(), deviceId);
    // group id -> members
    Multimap<Integer, ActionProfileMember> actionProfileMemberMap = HashMultimap.create();
    AtomicLong memberCount = new AtomicLong(0);
    AtomicBoolean success = new AtomicBoolean(true);
    actionProfileGroups.forEach(actProfGrp -> {
        actProfGrp.getMembersList().forEach(member -> {
            ActionProfileMember actProfMember = ActionProfileMember.newBuilder().setActionProfileId(actProfGrp.getActionProfileId()).setMemberId(member.getMemberId()).build();
            Entity entity = Entity.newBuilder().setActionProfileMember(actProfMember).build();
            ReadRequest reqMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(entity).build();
            Iterator<ReadResponse> resps;
            try {
                resps = blockingStub.read(reqMsg);
            } catch (StatusRuntimeException e) {
                log.warn("Unable to read member {} from action profile {} due to {}", member, piActionProfileId, e.getMessage());
                success.set(false);
                return;
            }
            Tools.stream(() -> resps).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(e -> e.getEntityCase() == ACTION_PROFILE_MEMBER).map(Entity::getActionProfileMember).forEach(m -> {
                actionProfileMemberMap.put(actProfGrp.getGroupId(), m);
                memberCount.incrementAndGet();
            });
        });
    });
    if (!success.get()) {
        // Can't read members
        return Collections.emptySet();
    }
    log.info("Retrieved {} group members from action profile {} on {}...", memberCount.get(), piActionProfileId.id(), deviceId);
    Collection<PiActionGroup> piActionGroups = Sets.newHashSet();
    for (ActionProfileGroup apg : actionProfileGroups) {
        try {
            Collection<ActionProfileMember> members = actionProfileMemberMap.get(apg.getGroupId());
            PiActionGroup decodedGroup = ActionProfileGroupEncoder.decode(apg, members, pipeconf);
            piActionGroups.add(decodedGroup);
        } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
            log.warn("Can't decode group {} due to {}", apg, e.getMessage());
            return Collections.emptySet();
        }
    }
    return piActionGroups;
}
#method_after
private Collection<PiActionGroup> doDumpGroups(PiActionProfileId piActionProfileId, PiPipeconf pipeconf) {
    log.debug("Dumping groups from action profile {} from {} (pipeconf {})...", piActionProfileId.id(), deviceId, pipeconf.id());
    final P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    if (browser == null) {
        log.warn("Unable to get a P4Info browser for pipeconf {}, aborting dump action profile", pipeconf);
        return Collections.emptySet();
    }
    final int actionProfileId;
    try {
        actionProfileId = browser.actionProfiles().getByName(piActionProfileId.id()).getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to dump groups: {}", e.getMessage());
        return Collections.emptySet();
    }
    // Prepare read request to read all groups from the given action profile.
    final ReadRequest groupRequestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setActionProfileGroup(ActionProfileGroup.newBuilder().setActionProfileId(actionProfileId).build()).build()).build();
    // Read groups.
    final Iterator<ReadResponse> groupResponses;
    try {
        groupResponses = blockingStub.read(groupRequestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to dump action profile {} from {}: {}", piActionProfileId, deviceId, e.getMessage());
        return Collections.emptySet();
    }
    final List<ActionProfileGroup> groupMsgs = Tools.stream(() -> groupResponses).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == ACTION_PROFILE_GROUP).map(Entity::getActionProfileGroup).collect(Collectors.toList());
    log.debug("Retrieved {} groups from action profile {} on {}...", groupMsgs.size(), piActionProfileId.id(), deviceId);
    // Returned groups contain only a minimal description of their members.
    // We need to issue a new request to get the full description of each member.
    // Keep a map of all member IDs for each group ID, will need it later.
    final Multimap<Integer, Integer> groupIdToMemberIdsMap = HashMultimap.create();
    groupMsgs.forEach(g -> groupIdToMemberIdsMap.putAll(g.getGroupId(), g.getMembersList().stream().map(ActionProfileGroup.Member::getMemberId).collect(Collectors.toList())));
    // Prepare one big read request to read all members in one shot.
    final Set<Entity> entityMsgs = groupMsgs.stream().flatMap(g -> g.getMembersList().stream()).map(ActionProfileGroup.Member::getMemberId).distinct().map(id -> ActionProfileMember.newBuilder().setActionProfileId(actionProfileId).setMemberId(id).build()).map(m -> Entity.newBuilder().setActionProfileMember(m).build()).collect(Collectors.toSet());
    final ReadRequest memberRequestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addAllEntities(entityMsgs).build();
    // Read members.
    final Iterator<ReadResponse> memberResponses;
    try {
        memberResponses = blockingStub.read(memberRequestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read members of action profile {} from {}: {}", piActionProfileId, deviceId, e.getMessage());
        return Collections.emptyList();
    }
    final Multimap<Integer, ActionProfileMember> groupIdToMembersMap = HashMultimap.create();
    Tools.stream(() -> memberResponses).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(e -> e.getEntityCase() == ACTION_PROFILE_MEMBER).map(Entity::getActionProfileMember).forEach(member -> groupIdToMemberIdsMap.asMap().entrySet().stream().filter(entry -> entry.getValue().contains(member.getMemberId())).map(Map.Entry::getKey).forEach(gid -> groupIdToMembersMap.put(gid, member)));
    log.debug("Retrieved {} group members from action profile {} on {}...", groupIdToMembersMap.size(), piActionProfileId.id(), deviceId);
    return groupMsgs.stream().map(groupMsg -> {
        try {
            return ActionProfileGroupEncoder.decode(groupMsg, groupIdToMembersMap.get(groupMsg.getGroupId()), pipeconf);
        } catch (P4InfoBrowser.NotFoundException | EncodeException e) {
            log.warn("Unable to decode group: {}\n {}", e.getMessage(), groupMsg);
            return null;
        }
    }).filter(Objects::nonNull).collect(Collectors.toList());
}
#end_block

#method_before
private boolean doWriteActionGroup(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    WriteRequest.Builder writeRequestBuilder = WriteRequest.newBuilder();
    ActionProfileGroup actionProfileGroup;
    try {
        actionProfileGroup = ActionProfileGroupEncoder.encode(group, pipeconf);
    } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
        log.warn("Can't encode group {} due to {}", e.getMessage());
        return false;
    }
    Update updateMessage = Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileGroup(actionProfileGroup).build()).setType(UPDATE_TYPES.get(opType)).build();
    writeRequestBuilder.setDeviceId(p4DeviceId).addUpdates(updateMessage);
    try {
        blockingStub.write(writeRequestBuilder.build());
        return true;
    } catch (StatusRuntimeException e) {
        log.warn("Unable to write table entries ({}): {}", opType, e.getMessage());
        return false;
    }
}
#method_after
private boolean doWriteActionGroup(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    final ActionProfileGroup actionProfileGroup;
    try {
        actionProfileGroup = ActionProfileGroupEncoder.encode(group, pipeconf);
    } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to encode group, aborting {} operation: {}", e.getMessage(), opType.name());
        return false;
    }
    final WriteRequest writeRequestMsg = WriteRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addUpdates(Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileGroup(actionProfileGroup).build()).setType(UPDATE_TYPES.get(opType)).build()).build();
    try {
        blockingStub.write(writeRequestMsg);
        return true;
    } catch (StatusRuntimeException e) {
        logWriteErrors(Collections.singleton(group), e, opType, "group");
        return false;
    }
}
#end_block

#method_before
private Collection<PiMeterCellConfig> doReadMeterCells(Collection<PiMeterCellId> cellIds, PiPipeconf pipeconf) {
    // We use this map to remember the original PI meter IDs of the returned response.
    final Map<Integer, PiMeterId> meterIdMap = Maps.newHashMap();
    Collection<PiMeterCellConfig> piMeterCellConfigs = cellIds.stream().map(cellId -> new PiMeterCellConfig(cellId, 0, 0, 0, 0)).collect(Collectors.toList());
    final ReadRequest request = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addAllEntities(MeterEntryCodec.encodePiMeterCellConfigs(piMeterCellConfigs, meterIdMap, pipeconf)).build();
    if (request.getEntitiesList().size() == 0) {
        return Collections.emptyList();
    }
    final Iterable<ReadResponse> responses;
    try {
        responses = () -> blockingStub.read(request);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read meters config: {}", e.getMessage());
        return Collections.emptyList();
    }
    List<Entity> entities = StreamSupport.stream(responses.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).collect(Collectors.toList());
    return MeterEntryCodec.decodeMeterEntities(entities, meterIdMap, pipeconf);
}
#method_after
private Collection<PiMeterCellConfig> doReadMeterCells(Collection<PiMeterCellId> cellIds, PiPipeconf pipeconf) {
    // We use this map to remember the original PI meter IDs of the returned response.
    Map<Integer, PiMeterId> meterIdMap = Maps.newHashMap();
    Collection<PiMeterCellConfig> piMeterCellConfigs = cellIds.stream().map(cellId -> PiMeterCellConfig.builder().withMeterCellId(cellId).build()).collect(Collectors.toList());
    final ReadRequest request = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addAllEntities(MeterEntryCodec.encodePiMeterCellConfigs(piMeterCellConfigs, meterIdMap, pipeconf)).build();
    if (request.getEntitiesList().size() == 0) {
        return Collections.emptyList();
    }
    final Iterable<ReadResponse> responses;
    try {
        responses = () -> blockingStub.read(request);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read meters config: {}", e.getMessage());
        log.debug("exception", e);
        return Collections.emptyList();
    }
    List<Entity> entities = StreamSupport.stream(responses.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).collect(Collectors.toList());
    return MeterEntryCodec.decodeMeterEntities(entities, meterIdMap, pipeconf);
}
#end_block

#method_before
private boolean doWriteMeterCells(Collection<PiMeterCellConfig> cellIds, WriteOperationType opType, PiPipeconf pipeconf) {
    final Map<Integer, PiMeterId> meterIdMap = Maps.newHashMap();
    WriteRequest.Builder writeRequestBuilder = WriteRequest.newBuilder();
    Collection<Update> updateMsgs = MeterEntryCodec.encodePiMeterCellConfigs(cellIds, meterIdMap, pipeconf).stream().map(meterEntryMsg -> Update.newBuilder().setEntity(meterEntryMsg).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        return true;
    }
    writeRequestBuilder.setDeviceId(p4DeviceId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestBuilder.build());
        return true;
    } catch (StatusRuntimeException e) {
        log.warn("Unable to write meter entries ({}): {}", opType, e.getMessage());
        return false;
    }
}
#method_after
private boolean doWriteMeterCells(Collection<PiMeterCellConfig> cellIds, PiPipeconf pipeconf) {
    final Map<Integer, PiMeterId> meterIdMap = Maps.newHashMap();
    WriteRequest.Builder writeRequestBuilder = WriteRequest.newBuilder();
    Collection<Update> updateMsgs = MeterEntryCodec.encodePiMeterCellConfigs(cellIds, meterIdMap, pipeconf).stream().map(meterEntryMsg -> Update.newBuilder().setEntity(meterEntryMsg).setType(UPDATE_TYPES.get(WriteOperationType.MODIFY)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        return true;
    }
    writeRequestBuilder.setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestBuilder.build());
        return true;
    } catch (StatusRuntimeException e) {
        log.warn("Unable to write meter entries : {}", e.getMessage());
        log.debug("exception", e);
        return false;
    }
}
#end_block

#method_before
@Override
public void shutdown() {
    log.info("Shutting down client for {}...", deviceId);
    writeLock.lock();
    try {
        if (streamRequestObserver != null) {
            streamRequestObserver.onCompleted();
            cancellableContext.cancel(new InterruptedException("Requested client shutdown"));
        }
        this.executorService.shutdown();
        try {
            executorService.awaitTermination(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.warn("Executor service didn't shutdown in time.");
        }
    } finally {
        writeLock.unlock();
    }
}
#method_after
@Override
public void shutdown() {
    log.info("Shutting down client for {}...", deviceId);
    writeLock.lock();
    try {
        if (streamRequestObserver != null) {
            streamRequestObserver.onCompleted();
            cancellableContext.cancel(new InterruptedException("Requested client shutdown"));
        }
        this.executorService.shutdown();
        try {
            executorService.awaitTermination(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.warn("Executor service didn't shutdown in time.");
            Thread.currentThread().interrupt();
        }
    } finally {
        writeLock.unlock();
    }
}
#end_block

#method_before
static Collection<Entity> encodePiMeterCellConfigs(Collection<PiMeterCellConfig> cellConfigs, Map<Integer, PiMeterId> meterIdMap, PiPipeconf pipeconf) {
    return cellConfigs.stream().map(cellConfig -> {
        try {
            return encodePiMeterCellConfig(cellConfig, meterIdMap, pipeconf);
        } catch (P4InfoBrowser.NotFoundException | EncodeException e) {
            log.warn("Unable to encode PI meter cell id: {}", e.getMessage());
            return null;
        }
    }).filter(Objects::nonNull).collect(Collectors.toList());
}
#method_after
static Collection<Entity> encodePiMeterCellConfigs(Collection<PiMeterCellConfig> cellConfigs, Map<Integer, PiMeterId> meterIdMap, PiPipeconf pipeconf) {
    return cellConfigs.stream().map(cellConfig -> {
        try {
            return encodePiMeterCellConfig(cellConfig, meterIdMap, pipeconf);
        } catch (P4InfoBrowser.NotFoundException | EncodeException e) {
            log.warn("Unable to encode PI meter cell id: {}", e.getMessage());
            log.debug("exception", e);
            return null;
        }
    }).filter(Objects::nonNull).collect(Collectors.toList());
}
#end_block

#method_before
private static Entity encodePiMeterCellConfig(PiMeterCellConfig config, Map<Integer, PiMeterId> meterIdMap, PiPipeconf pipeconf) throws P4InfoBrowser.NotFoundException, EncodeException {
    final P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    int meterId;
    Entity entity;
    // Encode PI cell ID into entity message and add to read request.
    switch(config.cellId().type()) {
        case INDIRECT:
            meterId = browser.meters().getByNameOrAlias(config.cellId().meterId().name()).getPreamble().getId();
            PiIndirectMeterCellId indCellId = (PiIndirectMeterCellId) config.cellId();
            entity = Entity.newBuilder().setMeterEntry(MeterEntry.newBuilder().setMeterId(meterId).setIndex(indCellId.index()).setConfig(MeterConfig.newBuilder().setCir(config.cir()).setCburst(config.cburst()).setPir(config.pir()).setPburst(config.pburst()).build()).build()).build();
            break;
        case DIRECT:
            meterId = browser.directMeters().getByNameOrAlias(config.cellId().meterId().name()).getPreamble().getId();
            PiDirectMeterCellId dirCellId = (PiDirectMeterCellId) config.cellId();
            DirectMeterEntry.Builder entryBuilder = DirectMeterEntry.newBuilder().setMeterId(meterId).setConfig(MeterConfig.newBuilder().setCir(config.cir()).setCburst(config.cburst()).setPir(config.pir()).setPburst(config.pburst()).build());
            if (!dirCellId.tableEntry().equals(PiTableEntry.EMTPY)) {
                entryBuilder.setTableEntry(TableEntryEncoder.encode(dirCellId.tableEntry(), pipeconf));
            }
            entity = Entity.newBuilder().setDirectMeterEntry(entryBuilder.build()).build();
            break;
        default:
            throw new EncodeException(format("Unrecognized PI meter cell ID type '%s'", config.cellId().type()));
    }
    meterIdMap.put(meterId, config.cellId().meterId());
    return entity;
}
#method_after
private static Entity encodePiMeterCellConfig(PiMeterCellConfig config, Map<Integer, PiMeterId> meterIdMap, PiPipeconf pipeconf) throws P4InfoBrowser.NotFoundException, EncodeException {
    final P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    int meterId;
    Entity entity;
    // The band with bigger burst is peak if rate of them is equal,
    // if bands are not specificed, using default value(0).
    long cir = 0;
    long cburst = 0;
    long pir = 0;
    long pburst = 0;
    PiMeterBand[] bands = config.meterBands().toArray(new PiMeterBand[config.meterBands().size()]);
    if (bands.length == 2) {
        if (bands[0].rate() > bands[1].rate()) {
            cir = bands[1].rate();
            cburst = bands[1].burst();
            pir = bands[0].rate();
            pburst = bands[0].burst();
        } else {
            cir = bands[0].rate();
            cburst = bands[0].burst();
            pir = bands[1].rate();
            pburst = bands[1].burst();
        }
    }
    // Encode PI cell ID into entity message and add to read request.
    switch(config.cellId().meterType()) {
        case INDIRECT:
            meterId = browser.meters().getByName(config.cellId().meterId().id()).getPreamble().getId();
            entity = Entity.newBuilder().setMeterEntry(MeterEntry.newBuilder().setMeterId(meterId).setIndex(config.cellId().index()).setConfig(MeterConfig.newBuilder().setCir(cir).setCburst(cburst).setPir(pir).setPburst(pburst).build()).build()).build();
            break;
        case DIRECT:
            meterId = browser.directMeters().getByName(config.cellId().meterId().id()).getPreamble().getId();
            DirectMeterEntry.Builder entryBuilder = DirectMeterEntry.newBuilder().setMeterId(meterId).setConfig(MeterConfig.newBuilder().setCir(cir).setCburst(cburst).setPir(pir).setPburst(pburst).build());
            if (!config.cellId().tableEntry().equals(PiTableEntry.EMTPY)) {
                entryBuilder.setTableEntry(TableEntryEncoder.encode(config.cellId().tableEntry(), pipeconf));
            }
            entity = Entity.newBuilder().setDirectMeterEntry(entryBuilder.build()).build();
            break;
        default:
            throw new EncodeException(format("Unrecognized PI meter cell ID type '%s'", config.cellId().meterType()));
    }
    meterIdMap.put(meterId, config.cellId().meterId());
    return entity;
}
#end_block

#method_before
private static PiMeterCellConfig decodeMeterEntity(Entity entity, Map<Integer, PiMeterId> meterIdMap, PiPipeconf pipeconf) throws EncodeException, P4InfoBrowser.NotFoundException {
    int meterId;
    MeterConfig meterConfig;
    if (entity.getEntityCase() == METER_ENTRY) {
        meterId = entity.getMeterEntry().getMeterId();
        meterConfig = entity.getMeterEntry().getConfig();
    } else {
        meterId = entity.getDirectMeterEntry().getMeterId();
        meterConfig = entity.getDirectMeterEntry().getConfig();
    }
    // Process only meter IDs that were requested in the first place.
    if (!meterIdMap.containsKey(meterId)) {
        throw new EncodeException(format("Unrecognized meter ID '%s'", meterId));
    }
    PiMeterId piMeterId = meterIdMap.get(meterId);
    // Compute PI cell ID.
    PiMeterCellId piCellId;
    switch(piMeterId.type()) {
        case INDIRECT:
            if (entity.getEntityCase() != METER_ENTRY) {
                throw new EncodeException(format("Meter ID '%s' is indirect, but processed entity is %s", piMeterId, entity.getEntityCase()));
            }
            piCellId = PiIndirectMeterCellId.of(piMeterId, entity.getMeterEntry().getIndex());
            break;
        case DIRECT:
            if (entity.getEntityCase() != DIRECT_METER_ENTRY) {
                throw new EncodeException(format("Meter ID '%s' is direct, but processed entity is %s", piMeterId, entity.getEntityCase()));
            }
            PiTableEntry piTableEntry = TableEntryEncoder.decode(entity.getDirectMeterEntry().getTableEntry(), pipeconf);
            piCellId = PiDirectMeterCellId.of(piMeterId, piTableEntry);
            break;
        default:
            throw new EncodeException(format("Unrecognized PI meter ID type '%s'", piMeterId.type()));
    }
    return new PiMeterCellConfig(piCellId, meterConfig.getCir(), meterConfig.getCburst(), meterConfig.getPir(), meterConfig.getPburst());
}
#method_after
private static PiMeterCellConfig decodeMeterEntity(Entity entity, Map<Integer, PiMeterId> meterIdMap, PiPipeconf pipeconf) throws EncodeException, P4InfoBrowser.NotFoundException {
    int meterId;
    MeterConfig meterConfig;
    if (entity.getEntityCase() == METER_ENTRY) {
        meterId = entity.getMeterEntry().getMeterId();
        meterConfig = entity.getMeterEntry().getConfig();
    } else {
        meterId = entity.getDirectMeterEntry().getMeterId();
        meterConfig = entity.getDirectMeterEntry().getConfig();
    }
    // Process only meter IDs that were requested in the first place.
    if (!meterIdMap.containsKey(meterId)) {
        throw new EncodeException(format("Unrecognized meter ID '%s'", meterId));
    }
    PiMeterId piMeterId = meterIdMap.get(meterId);
    if (!pipeconf.pipelineModel().meter(piMeterId).isPresent()) {
        throw new EncodeException(format("Unable to find meter '{}' in pipeline model", meterId));
    }
    PiMeterType piMeterType = pipeconf.pipelineModel().meter(piMeterId).get().meterType();
    // Compute PI cell ID.
    PiMeterCellId piCellId;
    switch(piMeterType) {
        case INDIRECT:
            if (entity.getEntityCase() != METER_ENTRY) {
                throw new EncodeException(format("Meter ID '%s' is indirect, but processed entity is %s", piMeterId, entity.getEntityCase()));
            }
            piCellId = PiMeterCellId.ofIndirect(piMeterId, entity.getMeterEntry().getIndex());
            break;
        case DIRECT:
            if (entity.getEntityCase() != DIRECT_METER_ENTRY) {
                throw new EncodeException(format("Meter ID '%s' is direct, but processed entity is %s", piMeterId, entity.getEntityCase()));
            }
            PiTableEntry piTableEntry = TableEntryEncoder.decode(entity.getDirectMeterEntry().getTableEntry(), pipeconf);
            piCellId = PiMeterCellId.ofDirect(piMeterId, piTableEntry);
            break;
        default:
            throw new EncodeException(format("Unrecognized PI meter ID type '%s'", piMeterType));
    }
    PiMeterCellConfig.Builder builder = PiMeterCellConfig.builder();
    builder.withMeterBand(new PiMeterBand(meterConfig.getCir(), meterConfig.getCburst()));
    builder.withMeterBand(new PiMeterBand(meterConfig.getPir(), meterConfig.getPburst()));
    return builder.withMeterCellId(piCellId).build();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof PiMeterCellConfig)) {
        return false;
    }
    PiMeterCellConfig that = (PiMeterCellConfig) o;
    return cir == that.cir && cburst == that.cburst && pir == that.pir && pburst == that.pburst && Objects.equal(cellId, that.cellId);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof PiMeterCellConfig)) {
        return false;
    }
    PiMeterCellConfig that = (PiMeterCellConfig) o;
    return piMeterBands.containsAll((that.piMeterBands)) && piMeterBands.size() == that.piMeterBands.size() && Objects.equal(cellId, that.cellId);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(cellId, cir, cburst, pir, pburst);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(cellId, piMeterBands);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("cellId", cellId).add("cir", cir).add("cburst", cburst).add("pir", pir).add("pburst", pburst).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("cellId", cellId).add("meterBands", piMeterBands).toString();
}
#end_block

#method_before
public ObjectNode encodeFailedPseudowires(List<Pair<DefaultL2TunnelDescription, String>> failedPws, CodecContext context) {
    ArrayNode failedNodes = context.mapper().createArrayNode();
    failedPws.stream().forEach(failed -> failedNodes.add(encodeError(failed.getKey(), failed.getValue(), context)));
    log.info("{}", failedNodes.toString());
    final ObjectNode toReturn = context.mapper().createObjectNode();
    toReturn.set(FAILED_PWS, failedNodes);
    return toReturn;
}
#method_after
public ObjectNode encodeFailedPseudowires(List<Pair<DefaultL2TunnelDescription, String>> failedPws, CodecContext context) {
    ArrayNode failedNodes = context.mapper().createArrayNode();
    failedPws.stream().forEach(failed -> failedNodes.add(encodeError(failed.getKey(), failed.getValue(), context)));
    final ObjectNode toReturn = context.mapper().createObjectNode();
    toReturn.set(FAILED_PWS, failedNodes);
    return toReturn;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
private void scheduleEventHandlerIfNotScheduled(Event event) {
    synchronized (THREAD_SCHED_LOCK) {
        eventQueue.add(event);
        numOfEventsQueued++;
        if ((numOfHandlerScheduled - numOfHandlerExecution) == 0) {
            // No pending scheduled event handling threads. So start a new one.
            eventHandlerFuture = executorService.schedule(eventHandler, 100, TimeUnit.MILLISECONDS);
            numOfHandlerScheduled++;
        }
        log.trace("numOfEventsQueued {}, numOfEventHandlerScheduled {}", numOfEventsQueued, numOfHandlerScheduled);
    }
}
#method_after
@SuppressWarnings("rawtypes")
private void scheduleEventHandlerIfNotScheduled(Event event) {
    synchronized (THREAD_SCHED_LOCK) {
        eventQueue.add(event);
        numOfEventsQueued++;
        if ((numOfHandlerScheduled - numOfHandlerExecution) == 0) {
            // No pending scheduled event handling threads. So start a new one.
            executorService.schedule(eventHandler, 100, TimeUnit.MILLISECONDS);
            numOfHandlerScheduled++;
        }
        log.trace("numOfEventsQueued {}, numOfEventHandlerScheduled {}", numOfEventsQueued, numOfHandlerScheduled);
    }
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        try {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            // TODO We should also change SR routing and PW to listen to TopologyEvents
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                linkHandler.processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                linkHandler.processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("** DEVICE UP Processing device event {} " + "for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info(" ** DEVICE DOWN Processing device event {}" + " for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else if (event.type() == TopologyEvent.Type.TOPOLOGY_CHANGED) {
                // Process topology event, needed for all modules relying on
                // topology service for path computation
                TopologyEvent topologyEvent = (TopologyEvent) event;
                log.info("Processing topology event {}, topology age {}, reasons {}", event.type(), topologyEvent.subject().time(), topologyEvent.reasons().size());
                topologyHandler.processTopologyChange(topologyEvent.reasons());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        } catch (Exception e) {
            log.error("SegmentRouting event handler thread thrown an exception: {}", e.getMessage(), e);
        }
    }
}
#method_after
@Override
public void run() {
    while (true) {
        try {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            // TODO We should also change SR routing and PW to listen to TopologyEvents
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                linkHandler.processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                linkHandler.processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("** DEVICE UP Processing device event {} " + "for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info(" ** DEVICE DOWN Processing device event {}" + " for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else if (event.type() == TopologyEvent.Type.TOPOLOGY_CHANGED) {
                // Process topology event, needed for all modules relying on
                // topology service for path computation
                TopologyEvent topologyEvent = (TopologyEvent) event;
                log.info("Processing topology event {}, topology age {}, reasons {}", event.type(), topologyEvent.subject().time(), topologyEvent.reasons().size());
                topologyHandler.processTopologyChange(topologyEvent.reasons());
            } else if (event.type() == HostEvent.Type.HOST_ADDED) {
                hostHandler.processHostAddedEvent((HostEvent) event);
            } else if (event.type() == HostEvent.Type.HOST_MOVED) {
                hostHandler.processHostMovedEvent((HostEvent) event);
                routeHandler.processHostMovedEvent((HostEvent) event);
            } else if (event.type() == HostEvent.Type.HOST_REMOVED) {
                hostHandler.processHostRemovedEvent((HostEvent) event);
            } else if (event.type() == HostEvent.Type.HOST_UPDATED) {
                hostHandler.processHostUpdatedEvent((HostEvent) event);
            } else if (event.type() == RouteEvent.Type.ROUTE_ADDED) {
                routeHandler.processRouteAdded((RouteEvent) event);
            } else if (event.type() == RouteEvent.Type.ROUTE_UPDATED) {
                routeHandler.processRouteUpdated((RouteEvent) event);
            } else if (event.type() == RouteEvent.Type.ROUTE_REMOVED) {
                routeHandler.processRouteRemoved((RouteEvent) event);
            } else if (event.type() == RouteEvent.Type.ALTERNATIVE_ROUTES_CHANGED) {
                routeHandler.processAlternativeRoutesChanged((RouteEvent) event);
            } else if (event.type() == McastEvent.Type.SOURCE_ADDED || event.type() == McastEvent.Type.SOURCE_UPDATED || event.type() == McastEvent.Type.SINK_ADDED || event.type() == McastEvent.Type.SINK_REMOVED || event.type() == McastEvent.Type.ROUTE_REMOVED) {
                mcastHandler.processMcastEvent((McastEvent) event);
            } else if (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED) {
                NetworkConfigEvent netcfgEvent = (NetworkConfigEvent) event;
                Class configClass = netcfgEvent.configClass();
                if (configClass.equals(SegmentRoutingAppConfig.class)) {
                    appCfgHandler.processAppConfigAdded(netcfgEvent);
                    log.info("App config event .. configuring network");
                    cfgListener.configureNetwork();
                } else if (configClass.equals(SegmentRoutingDeviceConfig.class)) {
                    log.info("Segment Routing Device Config added for {}", event.subject());
                    cfgListener.configureNetwork();
                } else if (configClass.equals(XConnectConfig.class)) {
                    xConnectHandler.processXConnectConfigAdded(netcfgEvent);
                } else if (configClass.equals(InterfaceConfig.class)) {
                    log.info("Interface Config added for {}", event.subject());
                    cfgListener.configureNetwork();
                } else {
                    log.error("Unhandled config class: {}", configClass);
                }
            } else if (event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED) {
                NetworkConfigEvent netcfgEvent = (NetworkConfigEvent) event;
                Class configClass = netcfgEvent.configClass();
                if (configClass.equals(SegmentRoutingAppConfig.class)) {
                    appCfgHandler.processAppConfigUpdated(netcfgEvent);
                    log.info("App config event .. configuring network");
                    cfgListener.configureNetwork();
                } else if (configClass.equals(SegmentRoutingDeviceConfig.class)) {
                    log.info("Segment Routing Device Config updated for {}", event.subject());
                    createOrUpdateDeviceConfiguration();
                } else if (configClass.equals(XConnectConfig.class)) {
                    xConnectHandler.processXConnectConfigUpdated(netcfgEvent);
                } else if (configClass.equals(InterfaceConfig.class)) {
                    log.info("Interface Config updated for {}", event.subject());
                    createOrUpdateDeviceConfiguration();
                    updateInterface((InterfaceConfig) netcfgEvent.config().get(), (InterfaceConfig) netcfgEvent.prevConfig().get());
                } else {
                    log.error("Unhandled config class: {}", configClass);
                }
            } else if (event.type() == NetworkConfigEvent.Type.CONFIG_REMOVED) {
                NetworkConfigEvent netcfgEvent = (NetworkConfigEvent) event;
                Class configClass = netcfgEvent.configClass();
                if (configClass.equals(SegmentRoutingAppConfig.class)) {
                    appCfgHandler.processAppConfigRemoved(netcfgEvent);
                    log.info("App config event .. configuring network");
                    cfgListener.configureNetwork();
                } else if (configClass.equals(SegmentRoutingDeviceConfig.class)) {
                    // TODO Handle sr device config removal
                    log.info("SegmentRoutingDeviceConfig removal is not handled in current implementation");
                } else if (configClass.equals(XConnectConfig.class)) {
                    xConnectHandler.processXConnectConfigRemoved(netcfgEvent);
                } else if (configClass.equals(InterfaceConfig.class)) {
                    // TODO Handle interface removal
                    log.info("InterfaceConfig removal is not handled in current implementation");
                } else {
                    log.error("Unhandled config class: {}", configClass);
                }
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        } catch (Exception e) {
            log.error("SegmentRouting event handler thread thrown an exception: {}", e.getMessage(), e);
        }
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Device Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(InterfaceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Interface Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Interface Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // Following code will be uncommented when [CORD-634] is fully implemented.
                // [CORD-634] Add dynamic config support for interfaces
                updateInterface((InterfaceConfig) event.config().get(), (InterfaceConfig) event.prevConfig().get());
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
        log.info("App config event .. configuring network");
        configureNetwork();
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
    checkState(xConnectHandler != null, "XConnectHandler is not initialized");
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
        case CONFIG_REMOVED:
            log.trace("Schedule Network Config event {}", event);
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void event(LinkEvent event) {
    if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED || event.type() == LinkEvent.Type.LINK_REMOVED) {
        log.debug("Event {} received from Link Service", event.type());
        scheduleEventHandlerIfNotScheduled(event);
    }
}
#method_after
@Override
public void event(LinkEvent event) {
    if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED || event.type() == LinkEvent.Type.LINK_REMOVED) {
        log.trace("Schedule Link event {}", event);
        scheduleEventHandlerIfNotScheduled(event);
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_UPDATED:
        case PORT_ADDED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.trace("Event {} received from Device Service", event.type());
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case PORT_UPDATED:
        case PORT_ADDED:
        case DEVICE_UPDATED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.trace("Schedule Device event {}", event);
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
    }
}
#end_block

#method_before
@Override
public void event(TopologyEvent event) {
    switch(event.type()) {
        case TOPOLOGY_CHANGED:
            log.debug("Event {} received from TopologyService", event.type());
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
    }
}
#method_after
@Override
public void event(TopologyEvent event) {
    switch(event.type()) {
        case TOPOLOGY_CHANGED:
            log.trace("Schedule Topology event {}", event);
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
    }
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    switch(event.type()) {
        case HOST_ADDED:
            hostHandler.processHostAddedEvent(event);
            break;
        case HOST_MOVED:
            hostHandler.processHostMovedEvent(event);
            routeHandler.processHostMovedEvent(event);
            break;
        case HOST_REMOVED:
            hostHandler.processHostRemovedEvent(event);
            break;
        case HOST_UPDATED:
            hostHandler.processHostUpdatedEvent(event);
            break;
        default:
            log.warn("Unsupported host event type: {}", event.type());
            break;
    }
}
#method_after
@Override
public void event(HostEvent event) {
    switch(event.type()) {
        case HOST_ADDED:
        case HOST_MOVED:
        case HOST_REMOVED:
        case HOST_UPDATED:
            log.trace("Schedule Host event {}", event);
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
            log.warn("Unsupported host event type: {}", event.type());
            break;
    }
}
#end_block

#method_before
@Override
public void event(McastEvent event) {
    switch(event.type()) {
        case SOURCE_ADDED:
        case SOURCE_UPDATED:
        case SINK_ADDED:
        case SINK_REMOVED:
        case ROUTE_REMOVED:
            mcastHandler.processMcastEvent(event);
            break;
        case ROUTE_ADDED:
        default:
            break;
    }
}
#method_after
@Override
public void event(McastEvent event) {
    switch(event.type()) {
        case SOURCE_ADDED:
        case SOURCE_UPDATED:
        case SINK_ADDED:
        case SINK_REMOVED:
        case ROUTE_REMOVED:
            log.trace("Schedule Mcast event {}", event);
            scheduleEventHandlerIfNotScheduled(event);
            break;
        case ROUTE_ADDED:
        default:
            log.warn("Unsupported mcast event type: {}", event.type());
            break;
    }
}
#end_block

#method_before
@Override
public void event(RouteEvent event) {
    switch(event.type()) {
        case ROUTE_ADDED:
            routeHandler.processRouteAdded(event);
            break;
        case ROUTE_UPDATED:
            routeHandler.processRouteUpdated(event);
            break;
        case ROUTE_REMOVED:
            routeHandler.processRouteRemoved(event);
            break;
        case ALTERNATIVE_ROUTES_CHANGED:
            routeHandler.processAlternativeRoutesChanged(event);
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(RouteEvent event) {
    switch(event.type()) {
        case ROUTE_ADDED:
        case ROUTE_UPDATED:
        case ROUTE_REMOVED:
        case ALTERNATIVE_ROUTES_CHANGED:
            log.trace("Schedule Route event {}", event);
            scheduleEventHandlerIfNotScheduled(event);
            break;
        default:
            log.warn("Unsupported route event type: {}", event.type());
            break;
    }
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    DefaultL2TunnelDescription pseudowire = PSEUDOWIRE_CODEC.decode(pseudowireJson, this);
    if (pseudowire == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    long tunId = pseudowire.l2Tunnel().tunnelId();
    log.debug("Creating pseudowire {} from rest api!", tunId);
    L2TunnelHandler.Result res = srService.addPseudowire(pseudowire);
    switch(res) {
        case WRONG_PARAMETERS:
        case CONFIGURATION_ERROR:
        case PATH_NOT_FOUND:
        case INTERNAL_ERROR:
            log.error("Pseudowire {} could not be added : {}", tunId, res.getSpecificError());
            return Response.serverError().status(Response.Status.INTERNAL_SERVER_ERROR).build();
        case SUCCESS:
            log.info("Pseudowire {} succesfully deployed!", pseudowire.l2Tunnel().tunnelId());
            return Response.ok().build();
        default:
            return Response.ok().build();
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = readTreeFromStream(mapper, input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    DefaultL2TunnelDescription pseudowire = PSEUDOWIRE_CODEC.decode(pseudowireJson, this);
    if (pseudowire == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    long tunId = pseudowire.l2Tunnel().tunnelId();
    log.debug("Creating pseudowire {} from rest api!", tunId);
    L2TunnelHandler.Result res = srService.addPseudowire(pseudowire);
    switch(res) {
        case WRONG_PARAMETERS:
        case CONFIGURATION_ERROR:
        case PATH_NOT_FOUND:
        case INTERNAL_ERROR:
            log.error("Pseudowire {} could not be added : {}", tunId, res.getSpecificError());
            return Response.serverError().status(Response.Status.INTERNAL_SERVER_ERROR).build();
        case SUCCESS:
            log.info("Pseudowire {} succesfully deployed!", pseudowire.l2Tunnel().tunnelId());
            return Response.ok().build();
        default:
            return Response.ok().build();
    }
}
#end_block

#method_before
@POST
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<DefaultL2TunnelDescription> pseudowires;
    try {
        ArrayNode pseudowiresArray = nullIsIllegal((ArrayNode) pseudowireJson.get(PWS), PWS_KEY_ERROR);
        pseudowires = PSEUDOWIRE_CODEC.decode(pseudowiresArray, this);
    } catch (ItemNotFoundException e) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.debug("Creating pseudowires {} from rest api!", pseudowires);
    List<Pair<DefaultL2TunnelDescription, String>> failed = new ArrayList<>();
    for (DefaultL2TunnelDescription pw : pseudowires) {
        L2TunnelHandler.Result res = srService.addPseudowire(pw);
        if (!(res == L2TunnelHandler.Result.SUCCESS)) {
            log.trace("Could not create pseudowire {} : {}", pw.l2Tunnel().tunnelId(), res.getSpecificError());
            failed.add(new Pair<>(pw, res.getSpecificError()));
        }
    }
    if (failed.size() == 0) {
        // all pseudowires were instantiated
        return Response.ok().build();
    } else {
        PseudowireCodec pwCodec = new PseudowireCodec();
        // some failed, need to report them to user
        ObjectNode result = pwCodec.encodeFailedPseudowires(failed, this);
        return Response.serverError().entity(result).build();
    }
}
#method_after
@POST
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = readTreeFromStream(mapper, input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<DefaultL2TunnelDescription> pseudowires;
    try {
        ArrayNode pseudowiresArray = nullIsIllegal((ArrayNode) pseudowireJson.get(PWS), PWS_KEY_ERROR);
        pseudowires = PSEUDOWIRE_CODEC.decode(pseudowiresArray, this);
    } catch (ItemNotFoundException e) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.debug("Creating pseudowires {} from rest api!", pseudowires);
    List<Pair<DefaultL2TunnelDescription, String>> failed = new ArrayList<>();
    for (DefaultL2TunnelDescription pw : pseudowires) {
        L2TunnelHandler.Result res = srService.addPseudowire(pw);
        if (!(res == L2TunnelHandler.Result.SUCCESS)) {
            log.trace("Could not create pseudowire {} : {}", pw.l2Tunnel().tunnelId(), res.getSpecificError());
            failed.add(new Pair<>(pw, res.getSpecificError()));
        }
    }
    if (failed.size() == 0) {
        // all pseudowires were instantiated
        return Response.ok().build();
    } else {
        PseudowireCodec pwCodec = new PseudowireCodec();
        // some failed, need to report them to user
        ObjectNode result = pwCodec.encodeFailedPseudowires(failed, this);
        return Response.serverError().entity(result).build();
    }
}
#end_block

#method_before
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Integer pseudowireId = PSEUDOWIRE_CODEC.decodeId(pseudowireJson);
    if (pseudowireId == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.debug("Deleting pseudowire {} from rest api!", pseudowireId);
    L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
    switch(res) {
        case WRONG_PARAMETERS:
        case INTERNAL_ERROR:
            log.error("Pseudowire {} could not be removed : {}", pseudowireId, res.getSpecificError());
            return Response.noContent().build();
        case SUCCESS:
            log.debug("Pseudowire {} was removed succesfully!", pseudowireId);
            return Response.noContent().build();
        default:
            return Response.noContent().build();
    }
}
#method_after
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = readTreeFromStream(mapper, input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Integer pseudowireId = PSEUDOWIRE_CODEC.decodeId(pseudowireJson);
    if (pseudowireId == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.debug("Deleting pseudowire {} from rest api!", pseudowireId);
    L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
    switch(res) {
        case WRONG_PARAMETERS:
        case INTERNAL_ERROR:
            log.error("Pseudowire {} could not be removed : {}", pseudowireId, res.getSpecificError());
            return Response.noContent().build();
        case SUCCESS:
            log.debug("Pseudowire {} was removed succesfully!", pseudowireId);
            return Response.noContent().build();
        default:
            return Response.noContent().build();
    }
}
#end_block

#method_before
@DELETE
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<Integer> ids = new ArrayList<>();
    // throw an exception and stop process
    try {
        for (JsonNode node : pseudowireJson.withArray(PWS)) {
            Integer idToDelete = PseudowireCodec.decodeId((ObjectNode) node);
            if (idToDelete == null) {
                log.error("Error when parsing pseudowire for deletion in REST API.");
                throw new IllegalArgumentException("Id of pseudowire should be an integer!");
            }
            ids.add(idToDelete);
        }
    } catch (IllegalArgumentException e) {
        log.error("Pseudowire ID should be an integer.");
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    } catch (UnsupportedOperationException e) {
        log.error("Pseudowires for deletion should be an array of pseudowire ids.");
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    for (Integer pseudowireId : ids) {
        L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
        switch(res) {
            case WRONG_PARAMETERS:
            case INTERNAL_ERROR:
                log.error("Pseudowire {} could not be removed, internal error : {}", pseudowireId, res.getSpecificError());
                break;
            case SUCCESS:
                log.debug("Pseudowire {} was removed succesfully!", pseudowireId);
                break;
            default:
        }
    }
    return Response.noContent().build();
}
#method_after
@DELETE
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = readTreeFromStream(mapper, input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<Integer> ids = new ArrayList<>();
    // throw an exception and stop process
    try {
        for (JsonNode node : pseudowireJson.withArray(PWS)) {
            Integer idToDelete = PseudowireCodec.decodeId((ObjectNode) node);
            if (idToDelete == null) {
                log.error("Error when parsing pseudowire for deletion in REST API.");
                throw new IllegalArgumentException("Id of pseudowire should be an integer!");
            }
            ids.add(idToDelete);
        }
    } catch (IllegalArgumentException e) {
        log.error("Pseudowire ID should be an integer.");
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    } catch (UnsupportedOperationException e) {
        log.error("Pseudowires for deletion should be an array of pseudowire ids.");
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    for (Integer pseudowireId : ids) {
        L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
        switch(res) {
            case WRONG_PARAMETERS:
            case INTERNAL_ERROR:
                log.error("Pseudowire {} could not be removed, internal error : {}", pseudowireId, res.getSpecificError());
                break;
            case SUCCESS:
                log.debug("Pseudowire {} was removed succesfully!", pseudowireId);
                break;
            default:
        }
    }
    return Response.noContent().build();
}
#end_block

#method_before
private boolean isValidPath(List<Link> path, boolean leafSpinePw) {
    List<DeviceId> devices = getDevicesOnPath(path);
    try {
        if (leafSpinePw) {
            // can either be leaf-spine-spine or leaf-spine
            // first device is leaf, all other must be spines
            log.debug("Devices on path are {} for leaf to spine pseudowire", devices);
            // if first device is a leaf then all other must be spines
            if (srManager.deviceConfiguration().isEdgeDevice(devices.get(0))) {
                devices.remove(0);
                for (DeviceId devId : devices) {
                    log.debug("Device {} should be a spine!", devId);
                    if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                        return false;
                    }
                }
            } else {
                // all other devices must be spines
                if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(devices.size() - 1))) {
                    return false;
                }
                devices.remove(devices.size() - 1);
                for (DeviceId devId : devices) {
                    log.debug("Device {} should be a spine!", devId);
                    if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                        return false;
                    }
                }
            }
        } else {
            // can either be leaf-leaf (paired leafs) / leaf-spine-leaf
            // or leaf-spine-spine-leaf
            log.debug("Devices on path are {} for leaf to leaf pseudowire", devices);
            // check first device, needs to be a leaf
            if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(0))) {
                return false;
            }
            // check last device, needs to be a leaf
            if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(devices.size() - 1))) {
                return false;
            }
            // remove these devices, rest must all be spines
            devices.remove(0);
            devices.remove(devices.size() - 1);
            for (DeviceId devId : devices) {
                log.debug("Device {} should be a spine!", devId);
                if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                    return false;
                }
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.error("Device not found in configuration : {}", e);
        return false;
    }
    return true;
}
#method_after
private boolean isValidPath(List<Link> path, boolean leafSpinePw) {
    List<DeviceId> devices = getDevicesOnPath(path);
    if (devices.size() < 2) {
        log.error("Path size for pseudowire should be greater than 1!");
        return false;
    }
    try {
        if (leafSpinePw) {
            // can either be leaf-spine-spine or leaf-spine
            // first device is leaf, all other must be spines
            log.debug("Devices on path are {} for leaf to spine pseudowire", devices);
            // if first device is a leaf then all other must be spines
            if (srManager.deviceConfiguration().isEdgeDevice(devices.get(0))) {
                devices.remove(0);
                for (DeviceId devId : devices) {
                    log.debug("Device {} should be a spine!", devId);
                    if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                        return false;
                    }
                }
            } else {
                // all other devices must be spines
                if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(devices.size() - 1))) {
                    return false;
                }
                devices.remove(devices.size() - 1);
                for (DeviceId devId : devices) {
                    log.debug("Device {} should be a spine!", devId);
                    if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                        return false;
                    }
                }
            }
        } else {
            // can either be leaf-leaf (paired leafs) / leaf-spine-leaf
            // or leaf-spine-spine-leaf
            log.debug("Devices on path are {} for leaf to leaf pseudowire", devices);
            // check first device, needs to be a leaf
            if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(0))) {
                return false;
            }
            // check last device, needs to be a leaf
            if (!srManager.deviceConfiguration().isEdgeDevice(devices.get(devices.size() - 1))) {
                return false;
            }
            // remove these devices, rest must all be spines
            devices.remove(0);
            devices.remove(devices.size() - 1);
            for (DeviceId devId : devices) {
                log.debug("Device {} should be a spine!", devId);
                if (srManager.deviceConfiguration().isEdgeDevice(devId)) {
                    return false;
                }
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        log.error("Device not found in configuration : {}", e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public List<Alarm> consumeAlarms() {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    checkNotNull(controller, "Netconf controller is null");
    MastershipService mastershipService = handler.get(MastershipService.class);
    deviceId = handler.data().deviceId();
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("Not master for {} Use {} to execute command", deviceId, mastershipService.getMasterFor(deviceId));
        return null;
    }
    List<Alarm> alarms = new ArrayList<>();
    try {
        String request = xmlEmpty(KEY_SYSTEMALARMS_XMLNS);
        String reply = controller.getDevicesMap().get(deviceId).getSession().get(request, null);
        if (reply != null) {
            alarms = parseAlarms(reply);
        }
    } catch (NetconfException e) {
        log.error("Error reading alarms for device {} exception {}", deviceId, e);
    }
    return ImmutableList.copyOf(alarms);
}
#method_after
@Override
public List<Alarm> consumeAlarms() {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    checkNotNull(controller, "Netconf controller is null");
    MastershipService mastershipService = handler.get(MastershipService.class);
    deviceId = handler.data().deviceId();
    List<Alarm> alarms = new ArrayList<>();
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("Not master for {} Use {} to execute command", deviceId, mastershipService.getMasterFor(deviceId));
        return ImmutableList.copyOf(alarms);
    }
    try {
        String request = xmlEmpty(KEY_SYSTEMALARMS_XMLNS);
        String reply = controller.getDevicesMap().get(deviceId).getSession().get(request, null);
        if (reply != null) {
            alarms = parseAlarms(reply);
        }
    } catch (NetconfException e) {
        log.error("Error reading alarms for device {} exception {}", deviceId, e);
    }
    return ImmutableList.copyOf(alarms);
}
#end_block

#method_before
@Override
public void switchAdded(Dpid dpid) {
    if (providerService == null) {
        return;
    }
    DeviceId did = deviceId(uri(dpid));
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    if (sw == null) {
        LOG.error("Switch {} is not found", dpid);
        return;
    }
    ChassisId cId = new ChassisId(dpid.value());
    DefaultAnnotations.Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PROTOCOL, sw.factory().getVersion().toString()).set(AnnotationKeys.CHANNEL_ID, sw.channelId()).set(AnnotationKeys.MANAGEMENT_ADDRESS, sw.channelId().split(":")[0]);
    // FIXME following ignores driver specified by name
    Driver driver = driverService.getDriver(sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription());
    // FIXME: The following breaks the STC tests and will require to be revisited.
    // if (driver != null) {
    // annotationsBuilder.set(AnnotationKeys.DRIVER, driver.name());
    // }
    SparseAnnotations annotations = annotationsBuilder.build();
    DeviceDescription description = new DefaultDeviceDescription(did.uri(), sw.deviceType(), sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription(), sw.serialNumber(), cId, annotations);
    providerService.deviceConnected(did, description);
    providerService.updatePorts(did, buildPortDescriptions(sw));
    sendPortDescStatsRequest(dpid);
    if (sw.features().getCapabilities().contains(OFCapabilities.PORT_STATS)) {
        PortStatsCollector psc = new PortStatsCollector(timer, sw, portStatsPollFrequency);
        stopCollectorIfNeeded(collectors.put(dpid, psc));
        psc.start();
    }
    // figure out race condition for collectors.remove() and collectors.put()
    if (controller.getSwitch(dpid) == null) {
        switchRemoved(dpid);
    }
}
#method_after
@Override
public void switchAdded(Dpid dpid) {
    if (providerService == null) {
        return;
    }
    DeviceId did = deviceId(uri(dpid));
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    if (sw == null) {
        LOG.error("Switch {} is not found", dpid);
        return;
    }
    ChassisId cId = new ChassisId(dpid.value());
    DefaultAnnotations.Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PROTOCOL, sw.factory().getVersion().toString()).set(AnnotationKeys.CHANNEL_ID, sw.channelId()).set(AnnotationKeys.MANAGEMENT_ADDRESS, sw.channelId().split(":")[0]);
    // FIXME following ignores driver specified by name
    Driver driver = driverService.getDriver(sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription());
    // FIXME: The following breaks the STC tests and will require to be revisited.
    // if (driver != null) {
    // annotationsBuilder.set(AnnotationKeys.DRIVER, driver.name());
    // }
    SparseAnnotations annotations = annotationsBuilder.build();
    DeviceDescription description = new DefaultDeviceDescription(did.uri(), sw.deviceType(), sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription(), sw.serialNumber(), cId, annotations);
    providerService.deviceConnected(did, description);
    providerService.updatePorts(did, buildPortDescriptions(sw));
    // sends port description stats request again if OF version supports
    if (sw.features().getVersion().compareTo(OFVersion.OF_13) >= 0) {
        sendPortDescStatsRequest(sw);
    }
    if (sw.features().getCapabilities().contains(OFCapabilities.PORT_STATS)) {
        PortStatsCollector psc = new PortStatsCollector(timer, sw, portStatsPollFrequency);
        stopCollectorIfNeeded(collectors.put(dpid, psc));
        psc.start();
    }
    // figure out race condition for collectors.remove() and collectors.put()
    if (controller.getSwitch(dpid) == null) {
        switchRemoved(dpid);
    }
}
#end_block

#method_before
private void sendPortDescStatsRequest(Dpid dpid) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    if (sw == null) {
        return;
    }
    // Long statsXid = xidAtomic.getAndIncrement();
    OFPortDescStatsRequest descStatsRequest = sw.factory().buildPortDescStatsRequest().build();
    sw.sendMsg(descStatsRequest);
}
#method_after
private void sendPortDescStatsRequest(OpenFlowSwitch sw) {
    if (sw == null) {
        return;
    }
    OFPortDescStatsRequest descStatsRequest = sw.factory().buildPortDescStatsRequest().build();
    sw.sendMsg(descStatsRequest);
}
#end_block

#method_before
private void setUpstreamRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(instPort.portNumber()).build();
    Network network = osNetworkService.network(instPort.networkId());
    if (network == null) {
        log.warn("network is null");
        return;
    }
    PortNumber portNumber = osNodeService.node(instPort.deviceId()).phyIntfPortNum(network.getProviderPhyNet());
    if (portNumber == null) {
        log.warn("port number is null");
        return;
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(portNumber).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_FLAT_RULE, SRC_VNI_TABLE, install);
    selector = DefaultTrafficSelector.builder().matchInPort(instPort.portNumber()).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(TpPort.tpPort(UDP.DHCP_SERVER_PORT)).matchUdpSrc(TpPort.tpPort(UDP.DHCP_CLIENT_PORT)).build();
    treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_FLAT_DHCP_RULE, SRC_VNI_TABLE, install);
}
#method_after
private void setUpstreamRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(instPort.portNumber()).build();
    Network network = osNetworkService.network(instPort.networkId());
    if (network == null) {
        log.warn("The network does not exist");
        return;
    }
    PortNumber portNumber = osNodeService.node(instPort.deviceId()).phyIntfPortNum(network.getProviderPhyNet());
    if (portNumber == null) {
        log.warn("The port number does not exist");
        return;
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(portNumber).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_FLAT_RULE, SRC_VNI_TABLE, install);
}
#end_block

#method_before
@Activate
@Override
protected void activate() {
    factories.forEach(registry::registerConfigFactory);
    uiExtensionService.register(glyphFactory);
    super.activate();
}
#method_after
@Activate
@Override
protected void activate() {
    uiExtensionService.register(glyphFactory);
    super.activate();
}
#end_block

#method_before
@Deactivate
@Override
protected void deactivate() {
    factories.forEach(registry::unregisterConfigFactory);
    uiExtensionService.unregister(glyphFactory);
    super.deactivate();
}
#method_after
@Deactivate
@Override
protected void deactivate() {
    uiExtensionService.unregister(glyphFactory);
    super.deactivate();
}
#end_block

#method_before
@Override
protected void execute() {
    Arrays.asList(controllersListStrings).forEach(cInfoString -> controllers.add(parseCInfoString(cInfoString)));
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    ControllerConfig config = h.behaviour(ControllerConfig.class);
    print("before:");
    config.getControllers().forEach(c -> print(c.target()));
    try {
        if (removeCont) {
            config.removeControllers(controllers);
        } else {
            if (controllers.isEmpty()) {
                print("Controllers list is empty, cannot set empty controllers");
            } else {
                config.setControllers(controllers);
            }
        }
    } catch (NullPointerException e) {
        print("No Device with requested parameters {} ", uri);
    }
    print("after:");
    config.getControllers().forEach(c -> print(c.target()));
    print("size %d", config.getControllers().size());
}
#method_after
@Override
protected void execute() {
    Arrays.asList(controllersListStrings).forEach(cInfoString -> controllers.add(parseCInfoString(cInfoString)));
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    ControllerConfig config = h.behaviour(ControllerConfig.class);
    print("before:");
    config.getControllers().forEach(c -> print(c.target()));
    try {
        if (removeAll) {
            if (!controllers.isEmpty()) {
                print("Controllers list should be empty to remove all controllers");
            } else {
                List<ControllerInfo> controllersToRemove = config.getControllers();
                controllersToRemove.forEach(c -> print("Will remove " + c.target()));
                config.removeControllers(controllersToRemove);
            }
        } else {
            if (controllers.isEmpty()) {
                print("Controllers list is empty, cannot set/remove empty controllers");
            } else {
                if (removeCont) {
                    print("Will remove specified controllers");
                    config.removeControllers(controllers);
                } else {
                    print("Will add specified controllers");
                    config.setControllers(controllers);
                }
            }
        }
    } catch (NullPointerException e) {
        print("No Device with requested parameters {} ", uri);
    }
    print("after:");
    config.getControllers().forEach(c -> print(c.target()));
    print("size %d", config.getControllers().size());
}
#end_block

#method_before
private Result manageIntermediateFiltering(L2TunnelDescription pw, boolean leafSpinePw) {
    // only leaf-spine-spine should need intermediate rules for now
    if (!leafSpinePw) {
        return Result.SUCCESS;
    }
    if (pw.l2Tunnel().pathUsed().size() != 2) {
        return Result.SUCCESS;
    }
    List<Link> path = pw.l2Tunnel().pathUsed();
    DeviceId intermediateSpineId = pw.l2Tunnel().pathUsed().get(0).dst().deviceId();
    L2Tunnel l2Tunnel = pw.l2Tunnel();
    log.info("Installing intermediate filtering rules for spine {} , for pseudowire {}", intermediateSpineId, pw.l2Tunnel().tunnelId());
    MacAddress dstMac;
    try {
        dstMac = srManager.deviceConfiguration().getDeviceMac(intermediateSpineId);
    } catch (Exception e) {
        log.info("Device not found in configuration, no programming of MAC address");
        dstMac = null;
    }
    PortNumber inPort;
    inPort = path.get(0).dst().port();
    log.info("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {} for device {}", l2Tunnel.transportVlan(), inPort, dstMac, intermediateSpineId);
    FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
    DefaultObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    filteringObjectiveBuilder.withMeta(treatment.build());
    srManager.flowObjectiveService.filter(intermediateSpineId, filteringObjectiveBuilder.add(context));
    inPort = path.get(1).src().port();
    log.info("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {} for device {}", l2Tunnel.transportVlan(), inPort, dstMac, intermediateSpineId);
    filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
    context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    treatment = DefaultTrafficTreatment.builder();
    filteringObjectiveBuilder.withMeta(treatment.build());
    srManager.flowObjectiveService.filter(intermediateSpineId, filteringObjectiveBuilder.add(context));
    return Result.SUCCESS;
}
#method_after
private Result manageIntermediateFiltering(L2TunnelDescription pw, boolean leafSpinePw) {
    // only leaf-spine-spine should need intermediate rules for now
    if (!leafSpinePw) {
        return Result.SUCCESS;
    }
    if (pw.l2Tunnel().pathUsed().size() != 2) {
        return Result.SUCCESS;
    }
    List<Link> path = pw.l2Tunnel().pathUsed();
    DeviceId intermediateSpineId = pw.l2Tunnel().pathUsed().get(0).dst().deviceId();
    L2Tunnel l2Tunnel = pw.l2Tunnel();
    log.info("Installing intermediate filtering rules for spine {} , for pseudowire {}", intermediateSpineId, pw.l2Tunnel().tunnelId());
    MacAddress dstMac;
    try {
        dstMac = srManager.deviceConfiguration().getDeviceMac(intermediateSpineId);
    } catch (Exception e) {
        log.info("Device not found in configuration, no programming of MAC address");
        dstMac = null;
    }
    PortNumber inPort;
    inPort = path.get(0).dst().port();
    log.debug("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {} for device {}", l2Tunnel.transportVlan(), inPort, dstMac, intermediateSpineId);
    FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
    DefaultObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    filteringObjectiveBuilder.withMeta(treatment.build());
    srManager.flowObjectiveService.filter(intermediateSpineId, filteringObjectiveBuilder.add(context));
    inPort = path.get(1).src().port();
    log.debug("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {} for device {}", l2Tunnel.transportVlan(), inPort, dstMac, intermediateSpineId);
    filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
    context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    treatment = DefaultTrafficTreatment.builder();
    filteringObjectiveBuilder.withMeta(treatment.build());
    srManager.flowObjectiveService.filter(intermediateSpineId, filteringObjectiveBuilder.add(context));
    return Result.SUCCESS;
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    topologyHandler = new TopologyHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    topologyService.addListener(topologyListener);
    l2TunnelHandler.init();
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    topologyHandler = new TopologyHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    topologyService.addListener(topologyListener);
    linkHandler.init();
    l2TunnelHandler.init();
    log.info("Started");
}
#end_block

#method_before
@Override
public L2TunnelHandler.Result addPseudowiresBulk(List<DefaultL2TunnelDescription> bulkPseudowires) {
    // get both added and pending pseudowires
    List<L2TunnelDescription> pseudowires = new ArrayList<>();
    pseudowires.addAll(l2TunnelHandler.getL2Descriptions(false));
    pseudowires.addAll(l2TunnelHandler.getL2Descriptions(true));
    pseudowires.addAll(bulkPseudowires);
    Set<L2TunnelDescription> newPseudowires = new HashSet(bulkPseudowires);
    // check global validity for all the new pseudowires, if it fails
    // do not add any of them
    log.info("Verifying set of pseudowires {}", pseudowires);
    boolean res = configurationValidity(pseudowires);
    if (res) {
        log.info("Pseudowire configuration is valid, deploying pseudowires!");
        l2TunnelHandler.deploy(newPseudowires);
        return L2TunnelHandler.Result.SUCCESS;
    } else {
        log.error("Bulk pseudowires {} can not be added, error in global configuration!", newPseudowires);
        return L2TunnelHandler.Result.ADDITION_ERROR;
    }
}
#method_after
@Override
public L2TunnelHandler.Result addPseudowiresBulk(List<DefaultL2TunnelDescription> bulkPseudowires) {
    // get both added and pending pseudowires
    List<L2TunnelDescription> pseudowires = new ArrayList<>();
    pseudowires.addAll(l2TunnelHandler.getL2Descriptions(false));
    pseudowires.addAll(l2TunnelHandler.getL2Descriptions(true));
    pseudowires.addAll(bulkPseudowires);
    Set<L2TunnelDescription> newPseudowires = new HashSet(bulkPseudowires);
    // check global validity for all the new pseudowires, if it fails
    // do not add any of them
    log.debug("Verifying set of pseudowires {}", pseudowires);
    boolean res = configurationValidity(pseudowires);
    if (res) {
        log.debug("Pseudowire configuration is valid, deploying pseudowires!");
        l2TunnelHandler.deploy(newPseudowires);
        return L2TunnelHandler.Result.SUCCESS;
    } else {
        log.error("Bulk pseudowires {} can not be added, error in global configuration!", newPseudowires);
        return L2TunnelHandler.Result.ADDITION_ERROR;
    }
}
#end_block

#method_before
@Override
public Set<L2TunnelDescription> getL2Descriptions() {
    List<L2Tunnel> tunnels = getL2Tunnels();
    List<L2TunnelPolicy> policies = getL2Policies();
    // determine affected pseudowires and update them at once
    List<L2TunnelDescription> tunnList = tunnels.stream().map(l2Tunnel -> {
        L2TunnelPolicy policy = null;
        for (L2TunnelPolicy l2Policy : policies) {
            if (l2Policy.tunnelId() == l2Tunnel.tunnelId()) {
                policy = l2Policy;
                break;
            }
        }
        return new DefaultL2TunnelDescription(l2Tunnel, policy);
    }).collect(Collectors.toList());
    return new HashSet<>(tunnList);
}
#method_after
@Override
public Set<L2TunnelDescription> getL2Descriptions() {
    List<L2Tunnel> tunnels = getL2Tunnels();
    List<L2TunnelPolicy> policies = getL2Policies();
    // determine affected pseudowires and update them at once
    return tunnels.stream().map(l2Tunnel -> {
        L2TunnelPolicy policy = null;
        for (L2TunnelPolicy l2Policy : policies) {
            if (l2Policy.tunnelId() == l2Tunnel.tunnelId()) {
                policy = l2Policy;
                break;
            }
        }
        return new DefaultL2TunnelDescription(l2Tunnel, policy);
    }).collect(Collectors.toSet());
}
#end_block

#method_before
private Result deployPseudowire(L2TunnelDescription pw, boolean spinePw) {
    Result result;
    long l2TunnelId;
    l2TunnelId = pw.l2Tunnel().tunnelId();
    // The tunnel id cannot be 0.
    if (l2TunnelId == 0) {
        log.warn("Tunnel id id must be > 0");
        return Result.ADDITION_ERROR;
    }
    // get path here, need to use the same for fwd and rev direction
    List<Link> path = getPath(pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP2());
    if (path == null) {
        log.info("Deploying process : No path between the connection points for pseudowire {}", l2TunnelId);
        return WRONG_PARAMETERS;
    }
    Link fwdNextHop;
    Link revNextHop;
    if ((path.size() != 1) && (path.size() != 2) && (path.size() != 3) && (path.size() != 4)) {
        log.error("Deploying process : Path size for pseudowire should be of" + " one of the following sizes = [0, 1, 3, 4], for pseudowire {}", l2TunnelId);
        return INTERNAL_ERROR;
    }
    // if size>1 we need to push intermediate labels also.
    if (path.size() > 1) {
        spinePw = false;
    }
    fwdNextHop = path.get(0);
    revNextHop = reverseLink(path.get(path.size() - 1));
    pw.l2Tunnel().setPath(path);
    pw.l2Tunnel().setTransportVlan(determineTransportVlan(spinePw));
    // next hops for next objectives
    log.info("Deploying process : Establishing forward direction for pseudowire {}", l2TunnelId);
    VlanId egressVlan = determineEgressVlan(pw.l2TunnelPolicy().cP1OuterTag(), pw.l2TunnelPolicy().cP1InnerTag(), pw.l2TunnelPolicy().cP2OuterTag(), pw.l2TunnelPolicy().cP2InnerTag());
    // We establish the tunnel.
    // result.nextId will be used in fwd
    result = deployPseudoWireInit(pw.l2Tunnel(), pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP2(), FWD, fwdNextHop, spinePw, egressVlan);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire initiation for CP1");
        return Result.ADDITION_ERROR;
    }
    // We create the policy.
    result = deployPolicy(l2TunnelId, pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP1InnerTag(), pw.l2TunnelPolicy().cP1OuterTag(), egressVlan, result.nextId);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire policy for CP1");
        return Result.ADDITION_ERROR;
    }
    // We terminate the tunnel
    result = deployPseudoWireTerm(pw.l2Tunnel(), pw.l2TunnelPolicy().cP2(), egressVlan, FWD, spinePw);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire termination for CP1");
        return Result.ADDITION_ERROR;
    }
    log.info("Deploying process : Establishing reverse direction for pseudowire {}", l2TunnelId);
    egressVlan = determineEgressVlan(pw.l2TunnelPolicy().cP2OuterTag(), pw.l2TunnelPolicy().cP2InnerTag(), pw.l2TunnelPolicy().cP1OuterTag(), pw.l2TunnelPolicy().cP1InnerTag());
    // We establish the reverse tunnel.
    result = deployPseudoWireInit(pw.l2Tunnel(), pw.l2TunnelPolicy().cP2(), pw.l2TunnelPolicy().cP1(), REV, revNextHop, spinePw, egressVlan);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire initiation for CP2");
        return Result.ADDITION_ERROR;
    }
    result = deployPolicy(l2TunnelId, pw.l2TunnelPolicy().cP2(), pw.l2TunnelPolicy().cP2InnerTag(), pw.l2TunnelPolicy().cP2OuterTag(), egressVlan, result.nextId);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying policy for CP2");
        return Result.ADDITION_ERROR;
    }
    result = deployPseudoWireTerm(pw.l2Tunnel(), pw.l2TunnelPolicy().cP1(), egressVlan, REV, spinePw);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire termination for CP2");
        return Result.ADDITION_ERROR;
    }
    log.info("Deploying process : Updating relevant information for pseudowire {}", l2TunnelId);
    // Populate stores
    l2TunnelStore.put(Long.toString(l2TunnelId), pw.l2Tunnel());
    l2PolicyStore.put(Long.toString(l2TunnelId), pw.l2TunnelPolicy());
    return Result.SUCCESS;
}
#method_after
private Result deployPseudowire(L2TunnelDescription pw, boolean spinePw) {
    Result result;
    long l2TunnelId;
    l2TunnelId = pw.l2Tunnel().tunnelId();
    // The tunnel id cannot be 0.
    if (l2TunnelId == 0) {
        log.warn("Tunnel id id must be > 0");
        return Result.ADDITION_ERROR;
    }
    // get path here, need to use the same for fwd and rev direction
    List<Link> path = getPath(pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP2());
    if (path == null) {
        log.info("Deploying process : No path between the connection points for pseudowire {}", l2TunnelId);
        return WRONG_PARAMETERS;
    }
    Link fwdNextHop;
    Link revNextHop;
    if (!isValidPathSize(path.size())) {
        log.error("Deploying process : Path size for pseudowire should be of" + " one of the following sizes = [1, 2, 3, 4], for pseudowire {}", l2TunnelId);
        return INTERNAL_ERROR;
    }
    // if size>1 we need to push intermediate labels also.
    if (path.size() > 1) {
        spinePw = false;
    }
    fwdNextHop = path.get(0);
    revNextHop = reverseLink(path.get(path.size() - 1));
    pw.l2Tunnel().setPath(path);
    pw.l2Tunnel().setTransportVlan(determineTransportVlan(spinePw));
    // next hops for next objectives
    log.info("Deploying process : Establishing forward direction for pseudowire {}", l2TunnelId);
    VlanId egressVlan = determineEgressVlan(pw.l2TunnelPolicy().cP1OuterTag(), pw.l2TunnelPolicy().cP1InnerTag(), pw.l2TunnelPolicy().cP2OuterTag(), pw.l2TunnelPolicy().cP2InnerTag());
    // We establish the tunnel.
    // result.nextId will be used in fwd
    result = deployPseudoWireInit(pw.l2Tunnel(), pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP2(), FWD, fwdNextHop, spinePw, egressVlan);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire initiation for CP1");
        return Result.ADDITION_ERROR;
    }
    // We create the policy.
    result = deployPolicy(l2TunnelId, pw.l2TunnelPolicy().cP1(), pw.l2TunnelPolicy().cP1InnerTag(), pw.l2TunnelPolicy().cP1OuterTag(), egressVlan, result.nextId);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire policy for CP1");
        return Result.ADDITION_ERROR;
    }
    // We terminate the tunnel
    result = deployPseudoWireTerm(pw.l2Tunnel(), pw.l2TunnelPolicy().cP2(), egressVlan, FWD, spinePw);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire termination for CP1");
        return Result.ADDITION_ERROR;
    }
    log.info("Deploying process : Establishing reverse direction for pseudowire {}", l2TunnelId);
    egressVlan = determineEgressVlan(pw.l2TunnelPolicy().cP2OuterTag(), pw.l2TunnelPolicy().cP2InnerTag(), pw.l2TunnelPolicy().cP1OuterTag(), pw.l2TunnelPolicy().cP1InnerTag());
    // We establish the reverse tunnel.
    result = deployPseudoWireInit(pw.l2Tunnel(), pw.l2TunnelPolicy().cP2(), pw.l2TunnelPolicy().cP1(), REV, revNextHop, spinePw, egressVlan);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire initiation for CP2");
        return Result.ADDITION_ERROR;
    }
    result = deployPolicy(l2TunnelId, pw.l2TunnelPolicy().cP2(), pw.l2TunnelPolicy().cP2InnerTag(), pw.l2TunnelPolicy().cP2OuterTag(), egressVlan, result.nextId);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying policy for CP2");
        return Result.ADDITION_ERROR;
    }
    result = deployPseudoWireTerm(pw.l2Tunnel(), pw.l2TunnelPolicy().cP1(), egressVlan, REV, spinePw);
    if (result != SUCCESS) {
        log.info("Deploying process : Error in deploying pseudowire termination for CP2");
        return Result.ADDITION_ERROR;
    }
    log.info("Deploying process : Updating relevant information for pseudowire {}", l2TunnelId);
    // Populate stores
    l2TunnelStore.put(Long.toString(l2TunnelId), pw.l2Tunnel());
    l2PolicyStore.put(Long.toString(l2TunnelId), pw.l2TunnelPolicy());
    return Result.SUCCESS;
}
#end_block

#method_before
private void updatePw(L2TunnelDescription oldPw, L2TunnelDescription newPw) {
    ConnectPoint oldCp1 = oldPw.l2TunnelPolicy().cP1();
    long tunnelId = oldPw.l2Tunnel().tunnelId();
    // only determine if the new pseudowire is leaf-spine, because
    // removal process is the same for both leaf-leaf and leaf-spine pws
    boolean newPwSpine;
    try {
        newPwSpine = !srManager.deviceConfiguration().isEdgeDevice(newPw.l2TunnelPolicy().cP1().deviceId()) || !srManager.deviceConfiguration().isEdgeDevice(newPw.l2TunnelPolicy().cP2().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        // if exception is caught treat the new pw as leaf-leaf
        newPwSpine = false;
    }
    // copy the variable here because we need to use it in lambda thus it needs to be final
    boolean finalNewPwSpine = newPwSpine;
    log.info("Updating pseudowire {}", oldPw.l2Tunnel().tunnelId());
    // The async tasks to orchestrate the next and forwarding update
    CompletableFuture<ObjectiveError> fwdInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdPwFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revPwFuture = new CompletableFuture<>();
    // first delete all information from our stores, we can not do it asynchronously
    l2PolicyStore.remove(Long.toString(tunnelId));
    // grab the old l2 tunnel from the store, since it carries information which is not exposed
    // to the user configuration and set it to oldPw.
    oldPw.setL2Tunnel(l2TunnelStore.get(Long.toString(tunnelId)).value());
    VlanId transportVlan = l2TunnelStore.get(Long.toString(tunnelId)).value().transportVlan();
    l2TunnelStore.remove(Long.toString(tunnelId));
    // remove the reserved transport vlan, if one is used
    if (!transportVlan.equals(UNTAGGED_TRANSPORT_VLAN)) {
        vlanStore.remove(transportVlan);
    }
    // First we remove both policy.
    log.debug("Start deleting fwd policy for {}", tunnelId);
    VlanId egressVlan = determineEgressVlan(oldPw.l2TunnelPolicy().cP1OuterTag(), oldPw.l2TunnelPolicy().cP1InnerTag(), oldPw.l2TunnelPolicy().cP2OuterTag(), oldPw.l2TunnelPolicy().cP2InnerTag());
    deletePolicy(tunnelId, oldPw.l2TunnelPolicy().cP1(), oldPw.l2TunnelPolicy().cP1InnerTag(), oldPw.l2TunnelPolicy().cP1OuterTag(), egressVlan, fwdInitNextFuture, FWD);
    deletePolicy(tunnelId, oldPw.l2TunnelPolicy().cP2(), oldPw.l2TunnelPolicy().cP2InnerTag(), oldPw.l2TunnelPolicy().cP2OuterTag(), egressVlan, revInitNextFuture, REV);
    // Finally we remove both the tunnels.
    fwdInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Fwd policy removed. " + "Now remove fwd {} for {}", INITIATION, tunnelId);
            tearDownPseudoWireInit(tunnelId, oldPw.l2TunnelPolicy().cP1(), fwdTermNextFuture, FWD);
        }
    });
    revInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Rev policy removed. " + "Now remove rev {} for {}", INITIATION, tunnelId);
            tearDownPseudoWireInit(tunnelId, oldPw.l2TunnelPolicy().cP2(), revTermNextFuture, REV);
        }
    });
    fwdTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Fwd {} removed. " + "Now remove fwd {} for {}", INITIATION, TERMINATION, tunnelId);
            tearDownPseudoWireTerm(oldPw.l2Tunnel(), oldPw.l2TunnelPolicy().cP2(), fwdPwFuture, FWD);
        }
    });
    revTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Rev {} removed. " + "Now remove rev {} for {}", INITIATION, TERMINATION, tunnelId);
            tearDownPseudoWireTerm(oldPw.l2Tunnel(), oldPw.l2TunnelPolicy().cP1(), revPwFuture, REV);
        }
    });
    // get path here, need to use the same for fwd and rev direction
    List<Link> path = getPath(newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP2());
    if (path == null) {
        log.error("Update process : " + "No path between the connection points for pseudowire {}", newPw.l2Tunnel().tunnelId());
        return;
    }
    Link fwdNextHop, revNextHop;
    if ((path.size() != 1) && (path.size() != 2) && (path.size() != 3) && (path.size() != 4)) {
        log.error("Deploying process : Path size for pseudowire should be of one of the following sizes" + " = [0, 1, 3, 4], for pseudowire {}", newPw.l2Tunnel().tunnelId());
        return;
    }
    // if size>1 we need to push intermediate labels also.
    if (path.size() > 1) {
        newPwSpine = false;
    }
    fwdNextHop = path.get(0);
    revNextHop = reverseLink(path.get(path.size() - 1));
    // set new path and transport vlan.
    newPw.l2Tunnel().setPath(path);
    newPw.l2Tunnel().setTransportVlan(determineTransportVlan(newPwSpine));
    // At the end we install the updated PW.
    fwdPwFuture.thenAcceptAsync(status -> {
        if (status == null) {
            // Upgrade stores and book keeping information, need to move this here
            // cause this call is asynchronous.
            l2PolicyStore.put(Long.toString(tunnelId), newPw.l2TunnelPolicy());
            l2TunnelStore.put(Long.toString(tunnelId), newPw.l2Tunnel());
            VlanId egressVlanId = determineEgressVlan(newPw.l2TunnelPolicy().cP1OuterTag(), newPw.l2TunnelPolicy().cP1InnerTag(), newPw.l2TunnelPolicy().cP2OuterTag(), newPw.l2TunnelPolicy().cP2InnerTag());
            log.debug("Update process : Deploying new fwd pw for {}", tunnelId);
            Result lamdaResult = deployPseudoWireInit(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP2(), FWD, fwdNextHop, finalNewPwSpine, egressVlanId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            lamdaResult = deployPolicy(tunnelId, newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP1InnerTag(), newPw.l2TunnelPolicy().cP1OuterTag(), egressVlanId, lamdaResult.nextId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            deployPseudoWireTerm(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP2(), egressVlanId, FWD, finalNewPwSpine);
        }
    });
    revPwFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Deploying new rev pw for {}", tunnelId);
            VlanId egressVlanId = determineEgressVlan(newPw.l2TunnelPolicy().cP2OuterTag(), newPw.l2TunnelPolicy().cP2InnerTag(), newPw.l2TunnelPolicy().cP1OuterTag(), newPw.l2TunnelPolicy().cP1InnerTag());
            Result lamdaResult = deployPseudoWireInit(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP1(), REV, revNextHop, finalNewPwSpine, egressVlanId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            lamdaResult = deployPolicy(tunnelId, newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP2InnerTag(), newPw.l2TunnelPolicy().cP2OuterTag(), egressVlanId, lamdaResult.nextId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            deployPseudoWireTerm(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP1(), egressVlanId, REV, finalNewPwSpine);
        }
    });
}
#method_after
private void updatePw(L2TunnelDescription oldPw, L2TunnelDescription newPw) {
    ConnectPoint oldCp1 = oldPw.l2TunnelPolicy().cP1();
    long tunnelId = oldPw.l2Tunnel().tunnelId();
    // only determine if the new pseudowire is leaf-spine, because
    // removal process is the same for both leaf-leaf and leaf-spine pws
    boolean newPwSpine;
    try {
        newPwSpine = !srManager.deviceConfiguration().isEdgeDevice(newPw.l2TunnelPolicy().cP1().deviceId()) || !srManager.deviceConfiguration().isEdgeDevice(newPw.l2TunnelPolicy().cP2().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        // if exception is caught treat the new pw as leaf-leaf
        newPwSpine = false;
    }
    // copy the variable here because we need to use it in lambda thus it needs to be final
    boolean finalNewPwSpine = newPwSpine;
    log.info("Updating pseudowire {}", oldPw.l2Tunnel().tunnelId());
    // The async tasks to orchestrate the next and forwarding update
    CompletableFuture<ObjectiveError> fwdInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revInitNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revTermNextFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> fwdPwFuture = new CompletableFuture<>();
    CompletableFuture<ObjectiveError> revPwFuture = new CompletableFuture<>();
    // first delete all information from our stores, we can not do it asynchronously
    l2PolicyStore.remove(Long.toString(tunnelId));
    // grab the old l2 tunnel from the store, since it carries information which is not exposed
    // to the user configuration and set it to oldPw.
    oldPw.setL2Tunnel(l2TunnelStore.get(Long.toString(tunnelId)).value());
    VlanId transportVlan = l2TunnelStore.get(Long.toString(tunnelId)).value().transportVlan();
    l2TunnelStore.remove(Long.toString(tunnelId));
    // remove the reserved transport vlan, if one is used
    if (!transportVlan.equals(UNTAGGED_TRANSPORT_VLAN)) {
        vlanStore.remove(transportVlan);
    }
    // First we remove both policy.
    log.debug("Start deleting fwd policy for {}", tunnelId);
    VlanId egressVlan = determineEgressVlan(oldPw.l2TunnelPolicy().cP1OuterTag(), oldPw.l2TunnelPolicy().cP1InnerTag(), oldPw.l2TunnelPolicy().cP2OuterTag(), oldPw.l2TunnelPolicy().cP2InnerTag());
    deletePolicy(tunnelId, oldPw.l2TunnelPolicy().cP1(), oldPw.l2TunnelPolicy().cP1InnerTag(), oldPw.l2TunnelPolicy().cP1OuterTag(), egressVlan, fwdInitNextFuture, FWD);
    deletePolicy(tunnelId, oldPw.l2TunnelPolicy().cP2(), oldPw.l2TunnelPolicy().cP2InnerTag(), oldPw.l2TunnelPolicy().cP2OuterTag(), egressVlan, revInitNextFuture, REV);
    // Finally we remove both the tunnels.
    fwdInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Fwd policy removed. " + "Now remove fwd {} for {}", INITIATION, tunnelId);
            tearDownPseudoWireInit(tunnelId, oldPw.l2TunnelPolicy().cP1(), fwdTermNextFuture, FWD);
        }
    });
    revInitNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Rev policy removed. " + "Now remove rev {} for {}", INITIATION, tunnelId);
            tearDownPseudoWireInit(tunnelId, oldPw.l2TunnelPolicy().cP2(), revTermNextFuture, REV);
        }
    });
    fwdTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Fwd {} removed. " + "Now remove fwd {} for {}", INITIATION, TERMINATION, tunnelId);
            tearDownPseudoWireTerm(oldPw.l2Tunnel(), oldPw.l2TunnelPolicy().cP2(), fwdPwFuture, FWD);
        }
    });
    revTermNextFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Rev {} removed. " + "Now remove rev {} for {}", INITIATION, TERMINATION, tunnelId);
            tearDownPseudoWireTerm(oldPw.l2Tunnel(), oldPw.l2TunnelPolicy().cP1(), revPwFuture, REV);
        }
    });
    // get path here, need to use the same for fwd and rev direction
    List<Link> path = getPath(newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP2());
    if (path == null) {
        log.error("Update process : " + "No path between the connection points for pseudowire {}", newPw.l2Tunnel().tunnelId());
        return;
    }
    Link fwdNextHop, revNextHop;
    if (!isValidPathSize(path.size())) {
        log.error("Deploying process : Path size for pseudowire should be of one of the following sizes" + " = [1, 2, 3, 4], for pseudowire {}", newPw.l2Tunnel().tunnelId());
        return;
    }
    // if size>1 we need to push intermediate labels also.
    if (path.size() > 1) {
        newPwSpine = false;
    }
    fwdNextHop = path.get(0);
    revNextHop = reverseLink(path.get(path.size() - 1));
    // set new path and transport vlan.
    newPw.l2Tunnel().setPath(path);
    newPw.l2Tunnel().setTransportVlan(determineTransportVlan(newPwSpine));
    // At the end we install the updated PW.
    fwdPwFuture.thenAcceptAsync(status -> {
        if (status == null) {
            // Upgrade stores and book keeping information, need to move this here
            // cause this call is asynchronous.
            l2PolicyStore.put(Long.toString(tunnelId), newPw.l2TunnelPolicy());
            l2TunnelStore.put(Long.toString(tunnelId), newPw.l2Tunnel());
            VlanId egressVlanId = determineEgressVlan(newPw.l2TunnelPolicy().cP1OuterTag(), newPw.l2TunnelPolicy().cP1InnerTag(), newPw.l2TunnelPolicy().cP2OuterTag(), newPw.l2TunnelPolicy().cP2InnerTag());
            log.debug("Update process : Deploying new fwd pw for {}", tunnelId);
            Result lamdaResult = deployPseudoWireInit(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP2(), FWD, fwdNextHop, finalNewPwSpine, egressVlanId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            lamdaResult = deployPolicy(tunnelId, newPw.l2TunnelPolicy().cP1(), newPw.l2TunnelPolicy().cP1InnerTag(), newPw.l2TunnelPolicy().cP1OuterTag(), egressVlanId, lamdaResult.nextId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            deployPseudoWireTerm(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP2(), egressVlanId, FWD, finalNewPwSpine);
        }
    });
    revPwFuture.thenAcceptAsync(status -> {
        if (status == null) {
            log.debug("Update process : Deploying new rev pw for {}", tunnelId);
            VlanId egressVlanId = determineEgressVlan(newPw.l2TunnelPolicy().cP2OuterTag(), newPw.l2TunnelPolicy().cP2InnerTag(), newPw.l2TunnelPolicy().cP1OuterTag(), newPw.l2TunnelPolicy().cP1InnerTag());
            Result lamdaResult = deployPseudoWireInit(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP1(), REV, revNextHop, finalNewPwSpine, egressVlanId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            lamdaResult = deployPolicy(tunnelId, newPw.l2TunnelPolicy().cP2(), newPw.l2TunnelPolicy().cP2InnerTag(), newPw.l2TunnelPolicy().cP2OuterTag(), egressVlanId, lamdaResult.nextId);
            if (lamdaResult != SUCCESS) {
                return;
            }
            deployPseudoWireTerm(newPw.l2Tunnel(), newPw.l2TunnelPolicy().cP1(), egressVlanId, REV, finalNewPwSpine);
        }
    });
}
#end_block

#method_before
@Override
public L2TunnelHandler.Result addPseudowiresBulk(List<DefaultL2TunnelDescription> bulkPseudowires) {
    Set<L2TunnelDescription> pseudowires = l2TunnelHandler.getL2Descriptions();
    bulkPseudowires.stream().forEach(newPw -> pseudowires.add(newPw));
    Set<L2TunnelDescription> newPseudowires = new HashSet(bulkPseudowires);
    // check global validity for all the new pseudowires, if it fails
    // do not add any of them
    boolean res = configurationValidity(pseudowires);
    if (res) {
        l2TunnelHandler.deploy(newPseudowires);
        return L2TunnelHandler.Result.SUCCESS;
    } else {
        log.error("Bulk pseudowires {} can not be added, error in global configuration!", newPseudowires);
        return L2TunnelHandler.Result.ADDITION_ERROR;
    }
}
#method_after
@Override
public L2TunnelHandler.Result addPseudowiresBulk(List<DefaultL2TunnelDescription> bulkPseudowires) {
    Set<L2TunnelDescription> pseudowires = l2TunnelHandler.getL2Descriptions();
    pseudowires.addAll(bulkPseudowires);
    Set<L2TunnelDescription> newPseudowires = new HashSet(bulkPseudowires);
    // check global validity for all the new pseudowires, if it fails
    // do not add any of them
    boolean res = configurationValidity(pseudowires);
    if (res) {
        l2TunnelHandler.deploy(newPseudowires);
        return L2TunnelHandler.Result.SUCCESS;
    } else {
        log.error("Bulk pseudowires {} can not be added, error in global configuration!", newPseudowires);
        return L2TunnelHandler.Result.ADDITION_ERROR;
    }
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    DefaultL2TunnelDescription pseudowire = PSEUDOWIRE_CODEC.decode(pseudowireJson, this);
    if (pseudowire == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.info("Creating pseudowire {} from rest api!", pseudowire.l2Tunnel().tunnelId());
    L2TunnelHandler.Result res = srService.addPseudowire(pseudowire);
    switch(res) {
        case ADDITION_ERROR:
            log.error("Pseudowire {} could not be added, error in configuration," + " please check logs for more details!", pseudowire.l2Tunnel().tunnelId());
            return Response.serverError().status(Response.Status.INTERNAL_SERVER_ERROR).build();
        case SUCCESS:
            log.info("Pseudowire {} succesfully deployed!", pseudowire.l2Tunnel().tunnelId());
            return Response.ok().build();
        default:
            return Response.ok().build();
    }
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    DefaultL2TunnelDescription pseudowire = PSEUDOWIRE_CODEC.decode(pseudowireJson, this);
    if (pseudowire == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.debug("Creating pseudowire {} from rest api!", pseudowire.l2Tunnel().tunnelId());
    L2TunnelHandler.Result res = srService.addPseudowire(pseudowire);
    switch(res) {
        case ADDITION_ERROR:
            log.error("Pseudowire {} could not be added, error in configuration," + " please check logs for more details!", pseudowire.l2Tunnel().tunnelId());
            return Response.serverError().status(Response.Status.INTERNAL_SERVER_ERROR).build();
        case SUCCESS:
            log.debug("Pseudowire {} succesfully deployed!", pseudowire.l2Tunnel().tunnelId());
            return Response.ok().build();
        default:
            return Response.ok().build();
    }
}
#end_block

#method_before
@POST
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<DefaultL2TunnelDescription> pseudowires;
    try {
        ArrayNode pseudowiresArray = nullIsIllegal((ArrayNode) pseudowireJson.get(PWS), PWS_KEY_ERROR);
        pseudowires = PSEUDOWIRE_CODEC.decode(pseudowiresArray, this);
    } catch (ItemNotFoundException e) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.info("Creating pseudowires {} from rest api!", pseudowires);
    L2TunnelHandler.Result res = srService.addPseudowiresBulk(pseudowires);
    switch(res) {
        case ADDITION_ERROR:
            log.error("Bulk of pseudowires {} could not be added, error in configuration," + " please check logs for more details!", pseudowires);
            return Response.serverError().status(Response.Status.INTERNAL_SERVER_ERROR).build();
        case SUCCESS:
            log.info("Bulk of pseudowires {} succesfully deployed!", pseudowires);
            return Response.ok().build();
        default:
            return Response.ok().build();
    }
}
#method_after
@POST
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response createPseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<DefaultL2TunnelDescription> pseudowires;
    try {
        ArrayNode pseudowiresArray = nullIsIllegal((ArrayNode) pseudowireJson.get(PWS), PWS_KEY_ERROR);
        pseudowires = PSEUDOWIRE_CODEC.decode(pseudowiresArray, this);
    } catch (ItemNotFoundException e) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.debug("Creating pseudowires {} from rest api!", pseudowires);
    L2TunnelHandler.Result res = srService.addPseudowiresBulk(pseudowires);
    switch(res) {
        case ADDITION_ERROR:
            log.error("Bulk of pseudowires {} could not be added, error in configuration," + " please check logs for more details!", pseudowires);
            return Response.serverError().status(Response.Status.INTERNAL_SERVER_ERROR).build();
        case SUCCESS:
            log.debug("Bulk of pseudowires {} succesfully deployed!", pseudowires);
            return Response.ok().build();
        default:
            return Response.ok().build();
    }
}
#end_block

#method_before
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Integer pseudowireId = PSEUDOWIRE_CODEC.decodeId(pseudowireJson);
    if (pseudowireId == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.info("Deleting pseudowire {} from rest api!", pseudowireId);
    L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
    switch(res) {
        case REMOVAL_ERROR:
            log.error("Pseudowire {} could not be removed, error in configuration," + " please check logs for more details!", pseudowireId);
            return Response.noContent().build();
        case SUCCESS:
            log.info("Pseudowire {} was removed succesfully!", pseudowireId);
            return Response.noContent().build();
        default:
            return Response.noContent().build();
    }
}
#method_after
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Integer pseudowireId = PSEUDOWIRE_CODEC.decodeId(pseudowireJson);
    if (pseudowireId == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.debug("Deleting pseudowire {} from rest api!", pseudowireId);
    L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
    switch(res) {
        case REMOVAL_ERROR:
            log.error("Pseudowire {} could not be removed, error in configuration," + " please check logs for more details!", pseudowireId);
            return Response.noContent().build();
        case SUCCESS:
            log.debug("Pseudowire {} was removed succesfully!", pseudowireId);
            return Response.noContent().build();
        default:
            return Response.noContent().build();
    }
}
#end_block

#method_before
@DELETE
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<Integer> ids = new ArrayList<>();
    // throw an exception and stop process
    try {
        for (JsonNode node : pseudowireJson.withArray(PWS)) {
            Integer idToDelete = PseudowireCodec.decodeId((ObjectNode) node);
            if (idToDelete == null) {
                log.error("Error when parsing pseudowire for deletion in REST API.");
                throw new IllegalArgumentException("Id of pseudowire should be an integer!");
            }
            ids.add(idToDelete);
        }
    } catch (Exception e) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    for (Integer pseudowireId : ids) {
        L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
        switch(res) {
            case REMOVAL_ERROR:
                log.error("Pseudowire {} could not be removed, error in configuration," + " please check logs for more details!", pseudowireId);
            case SUCCESS:
                log.info("Pseudowire {} was removed succesfully!", pseudowireId);
            default:
        }
    }
    return Response.noContent().build();
}
#method_after
@DELETE
@Path("/bulk")
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowiresBulk(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    List<Integer> ids = new ArrayList<>();
    // throw an exception and stop process
    try {
        for (JsonNode node : pseudowireJson.withArray(PWS)) {
            Integer idToDelete = PseudowireCodec.decodeId((ObjectNode) node);
            if (idToDelete == null) {
                log.error("Error when parsing pseudowire for deletion in REST API.");
                throw new IllegalArgumentException("Id of pseudowire should be an integer!");
            }
            ids.add(idToDelete);
        }
    } catch (IllegalArgumentException e) {
        log.error("Pseudowire ID should be an integer.");
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    } catch (UnsupportedOperationException e) {
        log.error("Pseudowires for deletion should be an array of pseudowire ids.");
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    for (Integer pseudowireId : ids) {
        L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
        switch(res) {
            case REMOVAL_ERROR:
                log.error("Pseudowire {} could not be removed, error in configuration," + " please check logs for more details!", pseudowireId);
            case SUCCESS:
                log.debug("Pseudowire {} was removed succesfully!", pseudowireId);
            default:
        }
    }
    return Response.noContent().build();
}
#end_block

#method_before
@Before
public void setUp() {
    loader = new OpticalDriversLoader();
    ((OpticalDriversLoader) loader).uiExtensionService = new MockUiExtensionService();
}
#method_after
@Before
public void setUp() {
    loader = new OpticalDriversLoader();
    ((OpticalDriversLoader) loader).uiExtensionService = new UiExtensionServiceAdapter();
}
#end_block

#method_before
protected ObjectNode deviceMessage(DeviceEvent event) {
    Device device = event.subject();
    String uiType = device.annotations().value(AnnotationKeys.UI_TYPE);
    String devType = uiType;
    if (devType == null) {
        GlyphBehaviour glyphBehaviour = null;
        if (device.is(GlyphBehaviour.class)) {
            glyphBehaviour = device.as(GlyphBehaviour.class);
        }
        devType = glyphBehaviour.id() != null ? glyphBehaviour.id() : device.type().toString().toLowerCase();
    }
    String name = device.annotations().value(AnnotationKeys.NAME);
    name = isNullOrEmpty(name) ? device.id().toString() : name;
    ObjectNode payload = objectNode().put("id", device.id().toString()).put("type", devType).put("online", services.device().isAvailable(device.id())).put("master", master(device.id()));
    payload.set("labels", labels("", name, device.id().toString()));
    payload.set("props", props(device.annotations()));
    addGeoLocation(device, payload);
    addGridLocation(device, payload);
    addMetaUi(device.id().toString(), payload);
    String type = DEVICE_EVENT.get(event.type());
    return JsonUtils.envelope(type, payload);
}
#method_after
protected ObjectNode deviceMessage(DeviceEvent event) {
    Device device = event.subject();
    String uiType = device.annotations().value(AnnotationKeys.UI_TYPE);
    String devType = uiType != null ? uiType : services.driver().getDriver(device.id()).getProperty(AnnotationKeys.UI_TYPE);
    if (devType == null) {
        devType = device.type().toString().toLowerCase();
    }
    String name = device.annotations().value(AnnotationKeys.NAME);
    name = isNullOrEmpty(name) ? device.id().toString() : name;
    ObjectNode payload = objectNode().put("id", device.id().toString()).put("type", devType).put("online", services.device().isAvailable(device.id())).put("master", master(device.id()));
    payload.set("labels", labels("", name, device.id().toString()));
    payload.set("props", props(device.annotations()));
    addGeoLocation(device, payload);
    addGridLocation(device, payload);
    addMetaUi(device.id().toString(), payload);
    String type = DEVICE_EVENT.get(event.type());
    return JsonUtils.envelope(type, payload);
}
#end_block

#method_before
private void routerUpdated(Router osRouter) {
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
        Network network = osNetworkService.network(osNetworkService.subnet(iface.getSubnetId()).getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), !osRouter.isAdminStateUp());
    });
    VlanId vlanId;
    ExternalPeerRouter externalPeerRouter = osNetworkService.externalPeerRouter(exGateway);
    if (externalPeerRouter != null) {
        vlanId = externalPeerRouter.externalPeerRouterVlanId();
    } else {
        vlanId = VlanId.NONE;
    }
    if (exGateway == null) {
        osNetworkService.deleteExternalPeerRouter(exGateway);
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(osRouter, iface, false);
        });
    } else {
        osNetworkService.deriveExternalPeerRouterMac(exGateway, osRouter, vlanId);
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(osRouter, iface, exGateway.isEnableSnat());
        });
    }
}
#method_after
private void routerUpdated(Router osRouter) {
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
        Network network = osNetworkService.network(osNetworkService.subnet(iface.getSubnetId()).getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), !osRouter.isAdminStateUp());
    });
    ExternalPeerRouter externalPeerRouter = osNetworkService.externalPeerRouter(exGateway);
    VlanId vlanId = externalPeerRouter == null ? VlanId.NONE : externalPeerRouter.externalPeerRouterVlanId();
    if (exGateway == null) {
        osNetworkService.deleteExternalPeerRouter(exGateway);
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> setSourceNat(iface, false));
    } else {
        osNetworkService.deriveExternalPeerRouterMac(exGateway, osRouter, vlanId);
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> setSourceNat(iface, exGateway.isEnableSnat()));
    }
}
#end_block

#method_before
private void routerIfaceAdded(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format("Failed to set flows for router %s: subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    if (!osRouter.isAdminStateUp()) {
        Network network = osNetworkService.network(osSubnet.getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), true);
    }
    setInternalRoutes(osRouter, osSubnet, true);
    setGatewayIcmp(osSubnet, true);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouter, osRouterIface, true);
    }
    log.info("Connected subnet({}) to {}", osSubnet.getCidr(), osRouter.getName());
}
#method_after
private void routerIfaceAdded(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format("Failed to set flows for router %s: subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    if (!osRouter.isAdminStateUp()) {
        Network network = osNetworkService.network(osSubnet.getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), true);
    }
    setInternalRoutes(osRouter, osSubnet, true);
    setGatewayIcmp(osSubnet, true);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, true);
    }
    log.info("Connected subnet({}) to {}", osSubnet.getCidr(), osRouter.getName());
}
#end_block

#method_before
private void routerIfaceRemoved(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format("Failed to set flows for router %s: subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    if (!osRouter.isAdminStateUp()) {
        Network network = osNetworkService.network(osSubnet.getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), false);
    }
    setInternalRoutes(osRouter, osSubnet, false);
    setGatewayIcmp(osSubnet, false);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouter, osRouterIface, false);
    }
    log.info("Disconnected subnet({}) from {}", osSubnet.getCidr(), osRouter.getName());
}
#method_after
private void routerIfaceRemoved(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format("Failed to set flows for router %s: subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    if (!osRouter.isAdminStateUp()) {
        Network network = osNetworkService.network(osSubnet.getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), false);
    }
    setInternalRoutes(osRouter, osSubnet, false);
    setGatewayIcmp(osSubnet, false);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, false);
    }
    log.info("Disconnected subnet({}) from {}", osSubnet.getCidr(), osRouter.getName());
}
#end_block

#method_before
private void setSourceNat(Router osRouter, RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes(COMPUTE).forEach(cNode -> {
        setRulesToGateway(cNode, osNet.getProviderSegID(), IpPrefix.valueOf(osSubnet.getCidr()), osNet.getNetworkType(), install);
    });
    if (useStatefulSnat) {
        setStatefulSnatRules(routerIface, install);
    } else {
        setReactiveSnatRules(routerIface, install);
    }
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.info(updateStr + "external access for subnet({})", osSubnet.getCidr());
}
#method_after
private void setSourceNat(RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes(COMPUTE).forEach(cNode -> {
        setRulesToGateway(cNode, osNet.getProviderSegID(), IpPrefix.valueOf(osSubnet.getCidr()), osNet.getNetworkType(), install);
    });
    if (useStatefulSnat) {
        setStatefulSnatRules(routerIface, install);
    } else {
        setReactiveSnatRules(routerIface, install);
    }
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.info(updateStr + "external access for subnet({})", osSubnet.getCidr());
}
#end_block

#method_before
private void setStatefulSnatRules(RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    Optional<Router> osRouter = osRouterService.routers().stream().filter(router -> osRouterService.routerInterfaces(routerIface.getId()) != null).findAny();
    if (!osRouter.isPresent()) {
        log.error("Cannot find a router for router interface {} ", routerIface);
        return;
    }
    IpAddress natAddress = getGatewayIpAddress(osRouter.get());
    if (natAddress == null) {
        return;
    }
    String netId = osNetworkService.subnet(routerIface.getSubnetId()).getNetworkId();
    osNodeService.completeNodes(OpenstackNode.NodeType.GATEWAY).forEach(gwNode -> {
        instancePortService.instancePorts(netId).stream().forEach(port -> setRulesForSnatIngressRule(gwNode.intgBridge(), Long.parseLong(osNet.getProviderSegID()), IpPrefix.valueOf(port.ipAddress(), 32), port.deviceId(), install));
        setOvsNatIngressRule(gwNode.intgBridge(), IpPrefix.valueOf(natAddress, 32), Constants.DEFAULT_EXTERNAL_ROUTER_MAC, install);
        setOvsNatEgressRule(gwNode.intgBridge(), natAddress, Long.parseLong(osNet.getProviderSegID()), gwNode.patchPortNum(), install);
    });
}
#method_after
private void setStatefulSnatRules(RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    Optional<Router> osRouter = osRouterService.routers().stream().filter(router -> osRouterService.routerInterfaces(routerIface.getId()) != null).findAny();
    if (!osRouter.isPresent()) {
        log.error("Cannot find a router for router interface {} ", routerIface);
        return;
    }
    IpAddress natAddress = getGatewayIpAddress(osRouter.get());
    if (natAddress == null) {
        return;
    }
    String netId = osNetworkService.subnet(routerIface.getSubnetId()).getNetworkId();
    osNodeService.completeNodes(OpenstackNode.NodeType.GATEWAY).forEach(gwNode -> {
        instancePortService.instancePorts(netId).forEach(port -> setRulesForSnatIngressRule(gwNode.intgBridge(), Long.parseLong(osNet.getProviderSegID()), IpPrefix.valueOf(port.ipAddress(), 32), port.deviceId(), install));
        setOvsNatIngressRule(gwNode.intgBridge(), IpPrefix.valueOf(natAddress, 32), Constants.DEFAULT_EXTERNAL_ROUTER_MAC, install);
        setOvsNatEgressRule(gwNode.intgBridge(), natAddress, Long.parseLong(osNet.getProviderSegID()), gwNode.patchPortNum(), install);
    });
}
#end_block

#method_before
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    OpenstackNode sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.dataIp() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.vlanPortNum() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format("%s %s", ERR_UNSUPPORTED_NET_TYPE, network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        setGatewayIcmpRule(gatewayIp, gNode.intgBridge(), install);
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#method_after
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    OpenstackNode sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.dataIp() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.vlanPortNum() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format("%s %s", ERR_UNSUPPORTED_NET_TYPE, network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> setGatewayIcmpRule(gatewayIp, gNode.intgBridge(), install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#end_block

#method_before
@Override
public void updateExternalPeerRouterVlan(IpAddress ipAddress, VlanId vlanId) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> {
            return new DefaultExternalPeerRouter(ipAddress, existing.externalPeerRouterMac(), vlanId);
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
}
#method_after
@Override
public void updateExternalPeerRouterVlan(IpAddress ipAddress, VlanId vlanId) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> new DefaultExternalPeerRouter(ipAddress, existing.externalPeerRouterMac(), vlanId));
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
}
#end_block

#method_before
private IpAddress getExternalPeerRouterIp(ExternalGateway externalGateway) {
    Optional<Subnet> externalSubnet = subnets(externalGateway.getNetworkId()).stream().findFirst();
    if (externalSubnet.isPresent()) {
        return IpAddress.valueOf(externalSubnet.get().getGateway());
    } else {
        return null;
    }
}
#method_after
private IpAddress getExternalPeerRouterIp(ExternalGateway externalGateway) {
    Optional<Subnet> externalSubnet = subnets(externalGateway.getNetworkId()).stream().findFirst();
    return externalSubnet.map(subnet -> IpAddress.valueOf(subnet.getGateway())).orElse(null);
}
#end_block

#method_before
private void processArpPacket(PacketContext context, Ethernet ethernet) {
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        if (log.isTraceEnabled()) {
            log.trace("ARP request received from {} for {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
        }
        IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
        MacAddress targetMac = null;
        NetFloatingIP floatingIP = osRouterService.floatingIps().stream().filter(ip -> ip.getFloatingIpAddress().equals(targetIp.toString())).findAny().orElse(null);
        // In case target ip is for associated floating ip, sets target mac to vm's.
        if (floatingIP != null && floatingIP.getPortId() != null) {
            targetMac = MacAddress.valueOf(osNetworkService.port(floatingIP.getPortId()).getMacAddress());
        }
        if (isExternalGatewaySourceIp(targetIp.getIp4Address())) {
            targetMac = Constants.DEFAULT_GATEWAY_MAC;
        }
        if (targetMac == null) {
            log.trace("Unknown target ARP request for {}, ignore it", targetIp);
            return;
        }
        Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port());
        packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), tBuilder.build(), ByteBuffer.wrap(ethReply.serialize())));
        context.block();
    } else if (arp.getOpCode() == ARP.OP_REPLY) {
        PortNumber receivedPortNum = context.inPacket().receivedFrom().port();
        log.debug("ARP reply ip: {}, mac: {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
        try {
            if (receivedPortNum.equals(osNodeService.node(context.inPacket().receivedFrom().deviceId()).uplinkPortNum())) {
                osNetworkService.updateExternalPeerRouterMac(Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
            }
        } catch (Exception e) {
            log.error("Exception occurred because of {}", e.toString());
        }
    }
}
#method_after
private void processArpPacket(PacketContext context, Ethernet ethernet) {
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        if (log.isTraceEnabled()) {
            log.trace("ARP request received from {} for {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
        }
        IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
        MacAddress targetMac = null;
        NetFloatingIP floatingIP = osRouterService.floatingIps().stream().filter(ip -> ip.getFloatingIpAddress().equals(targetIp.toString())).findAny().orElse(null);
        // In case target ip is for associated floating ip, sets target mac to vm's.
        if (floatingIP != null && floatingIP.getPortId() != null) {
            targetMac = MacAddress.valueOf(osNetworkService.port(floatingIP.getPortId()).getMacAddress());
        }
        if (isExternalGatewaySourceIp(targetIp.getIp4Address())) {
            targetMac = Constants.DEFAULT_GATEWAY_MAC;
        }
        if (targetMac == null) {
            log.trace("Unknown target ARP request for {}, ignore it", targetIp);
            return;
        }
        Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
        packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
        context.block();
    } else if (arp.getOpCode() == ARP.OP_REPLY) {
        PortNumber receivedPortNum = context.inPacket().receivedFrom().port();
        log.debug("ARP reply ip: {}, mac: {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
        try {
            if (receivedPortNum.equals(osNodeService.node(context.inPacket().receivedFrom().deviceId()).uplinkPortNum())) {
                osNetworkService.updateExternalPeerRouterMac(Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
            }
        } catch (Exception e) {
            log.error("Exception occurred because of {}", e.toString());
        }
    }
}
#end_block

#method_before
private boolean multipleRoutes(StaticPacketTrace trace) {
    boolean multipleRoutes = false;
    IPCriterion ipCriterion = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV4_DST));
    IpAddress ip = null;
    if (ipCriterion != null) {
        ip = ipCriterion.ip().address();
    } else if (trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_DST) != null) {
        ip = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_DST)).ip().address();
    }
    Optional<ResolvedRoute> optionalRoute = routeService.longestPrefixLookup(ip);
    if (ip != null && optionalRoute.isPresent()) {
        ResolvedRoute route = optionalRoute.get();
        route.prefix();
        multipleRoutes = routeService.getAllRoutes(route.prefix()).size() > 1;
    }
    return multipleRoutes;
}
#method_after
private boolean multipleRoutes(StaticPacketTrace trace) {
    boolean multipleRoutes = false;
    IPCriterion ipCriterion = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV4_DST));
    IpAddress ip = null;
    if (ipCriterion != null) {
        ip = ipCriterion.ip().address();
    } else if (trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_DST) != null) {
        ip = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_DST)).ip().address();
    }
    Optional<ResolvedRoute> optionalRoute = routeService.longestPrefixLookup(ip);
    if (ip != null && optionalRoute.isPresent()) {
        ResolvedRoute route = optionalRoute.get();
        route.prefix();
        multipleRoutes = routeService.getAllResolvedRoutes(route.prefix()).size() > 1;
    }
    return multipleRoutes;
}
#end_block

#method_before
@Activate
protected void activate() {
    log.info("Started");
    dynConfigService.addListener(dynamicConfigServiceListener);
}
#method_after
@Activate
protected void activate() {
    log.info("Started");
    dynConfigService.addListener(dynamicConfigServiceListener);
    rpcRegistry.registerRpcService(rpcTapiConnectivity);
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    log.info("Stopped");
    dynConfigService.removeListener(dynamicConfigServiceListener);
}
#method_after
@Deactivate
protected void deactivate() {
    log.info("Stopped");
    rpcRegistry.unregisterRpcService(rpcTapiConnectivity);
    dynConfigService.removeListener(dynamicConfigServiceListener);
}
#end_block

#method_before
@Override
public void event(DynamicConfigEvent event) {
    ResourceId rsId = event.subject();
    DataNode node;
    try {
        Filter filter = Filter.builder().addCriteria(rsId).build();
        log.info("DEBUG: readNode({},..)", ResourceIds.toInstanceIdentifier(rsId));
        node = dynConfigService.readNode(rsId, filter);
    } catch (FailedException e) {
        log.error("Something failed", e);
        node = null;
    }
    switch(event.type()) {
        case NODE_ADDED:
            onDcsNodeAdded(rsId, node);
            break;
        case NODE_DELETED:
            onDcsNodeDeleted(node);
            break;
        default:
            log.warn("Unknown Event", event.type());
            break;
    }
}
#method_after
@Override
public void event(DynamicConfigEvent event) {
    ResourceId rsId = event.subject();
    DataNode node;
    try {
        Filter filter = Filter.builder().addCriteria(rsId).build();
        node = dynConfigService.readNode(rsId, filter);
    } catch (FailedException e) {
        node = null;
    }
    switch(event.type()) {
        case NODE_ADDED:
            onDcsNodeAdded(rsId, node);
            break;
        case NODE_DELETED:
            onDcsNodeDeleted(node);
            break;
        default:
            log.warn("Unknown Event", event.type());
            break;
    }
}
#end_block

#method_before
private void onDcsNodeAdded(ResourceId rsId, DataNode node) {
    log.info("onDcsNodeAdded({}, {})", ResourceIds.toInstanceIdentifier(rsId), node);
    switch(node.type()) {
        case SINGLE_INSTANCE_NODE:
            break;
        case MULTI_INSTANCE_NODE:
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            break;
        default:
            break;
    }
    NodeKey dataNodeKey = node.key();
    SchemaId schemaId = dataNodeKey.schemaId();
    if (!schemaId.namespace().contains("tapi")) {
        return;
    }
    // Consolidate events
    log.info("namespace {}", schemaId.namespace());
}
#method_after
private void onDcsNodeAdded(ResourceId rsId, DataNode node) {
    switch(node.type()) {
        case SINGLE_INSTANCE_NODE:
            break;
        case MULTI_INSTANCE_NODE:
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            break;
        default:
            break;
    }
    NodeKey dataNodeKey = node.key();
    SchemaId schemaId = dataNodeKey.schemaId();
    if (!schemaId.namespace().contains("tapi")) {
        return;
    }
    // Consolidate events
    log.info("namespace {}", schemaId.namespace());
}
#end_block

#method_before
public void validateStream(StreamOpen stream) throws XmppValidationException {
    try {
        String jid = stream.getElement().attribute("from").getValue();
        validateJid(jid);
    } catch (Exception e) {
        throw new XmppValidationException(true);
    }
}
#method_after
public void validateStream(XmppStreamOpen stream) throws XmppValidationException {
    try {
        String jid = stream.getElement().attribute("from").getValue();
        validateJid(jid);
    } catch (Exception e) {
        throw new XmppValidationException(true);
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    log.info("XmppControllerImpl started.");
    coreService.registerApplication(APP_ID, this::cleanup);
    cfgService.registerProperties(getClass());
    deviceFactory.init(manager, driverService);
    xmppServer.setConfiguration(context.getProperties());
    xmppServer.start(deviceFactory);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    log.info("XmppControllerImpl started.");
    coreService.registerApplication(APP_ID, this::cleanup);
    cfgService.registerProperties(getClass());
    deviceFactory.init(agent);
    xmppServer.setConfiguration(context.getProperties());
    xmppServer.start(deviceFactory);
}
#end_block

#method_before
private void cleanup() {
    xmppServer.stop();
    deviceFactory.cleanManager();
    connectedDevices.values().forEach(XmppDevice::disconnectDevice);
    connectedDevices.clear();
}
#method_after
private void cleanup() {
    xmppServer.stop();
    deviceFactory.cleanAgent();
    connectedDevices.values().forEach(XmppDevice::disconnectDevice);
    connectedDevices.clear();
}
#end_block

#method_before
private void handleStreamError(StreamError streamError) {
// TODO: handle stream errors
}
#method_after
private void handleStreamError(XmppStreamError streamError) {
// TODO: handle stream errors
}
#end_block

#method_before
private void sendStreamCloseReply() {
    StreamClose streamClose = new StreamClose();
    channel.writeAndFlush(streamClose);
}
#method_after
private void sendStreamCloseReply() {
    XmppStreamClose streamClose = new XmppStreamClose();
    channel.writeAndFlush(streamClose);
}
#end_block

#method_before
private void sendStreamOpenReply(StreamOpen streamOpen) {
    Element element = streamOpen.getElement().createCopy();
    element.addAttribute("from", streamOpen.getToJid().toString());
    element.addAttribute("to", streamOpen.getFromJid().toString());
    StreamOpen streamOpenReply = new StreamOpen(element);
    channel.writeAndFlush(streamOpenReply);
}
#method_after
private void sendStreamOpenReply(XmppStreamOpen xmppStreamOpen) {
    Element element = xmppStreamOpen.getElement().createCopy();
    element.addAttribute("from", xmppStreamOpen.getToJid().toString());
    element.addAttribute("to", xmppStreamOpen.getFromJid().toString());
    XmppStreamOpen xmppStreamOpenReply = new XmppStreamOpen(element);
    channel.writeAndFlush(xmppStreamOpenReply);
}
#end_block

#method_before
private void sendStreamError(StreamError.Condition condition) {
    StreamError error = new StreamError(condition);
    channel.writeAndFlush(error);
}
#method_after
private void sendStreamError(XmppStreamError.Condition condition) {
    XmppStreamError error = new XmppStreamError(condition);
    channel.writeAndFlush(error);
}
#end_block

#method_before
private void handleChannelException(Throwable cause) {
    StreamError.Condition condition = getStreamErrorCondition(cause.getCause());
    sendStreamError(condition);
    sendStreamCloseReply();
}
#method_after
private void handleChannelException(Throwable cause) {
    XmppStreamError.Condition condition = getStreamErrorCondition(cause.getCause());
    sendStreamError(condition);
    sendStreamCloseReply();
}
#end_block

#method_before
private StreamError.Condition getStreamErrorCondition(Throwable cause) {
    // TODO: add error handle mechanisms for each cases
    if (cause instanceof UnsupportedStanzaTypeException) {
        return StreamError.Condition.unsupported_stanza_type;
    } else if (cause instanceof WFCException) {
        return StreamError.Condition.bad_format;
    } else if (cause instanceof XmppValidationException) {
        return StreamError.Condition.bad_format;
    } else {
        return StreamError.Condition.internal_server_error;
    }
}
#method_after
private XmppStreamError.Condition getStreamErrorCondition(Throwable cause) {
    // TODO: add error handle mechanisms for each cases
    if (cause instanceof UnsupportedStanzaTypeException) {
        return XmppStreamError.Condition.unsupported_stanza_type;
    } else if (cause instanceof WFCException) {
        return XmppStreamError.Condition.bad_format;
    } else if (cause instanceof XmppValidationException) {
        return XmppStreamError.Condition.bad_format;
    } else {
        return XmppStreamError.Condition.internal_server_error;
    }
}
#end_block

#method_before
@Override
protected void decode(ChannelHandlerContext channelHandlerContext, Object object, List out) throws Exception {
    if (object instanceof Element) {
        Element root = (Element) object;
        try {
            Packet packet = recognizeAndReturnXmppPacket(root);
            validate(packet);
            out.add(packet);
        } catch (UnsupportedStanzaTypeException e) {
            throw e;
        } catch (Exception e) {
            throw new XmppValidationException(false);
        }
    } else if (object instanceof XMLEvent) {
        XMLEvent event = (XMLEvent) object;
        if (event.isStartElement()) {
            final StartElement element = event.asStartElement();
            if (element.getName().getLocalPart().equals(XmppConstants.STREAM_QNAME)) {
                DocumentFactory df = DocumentFactory.getInstance();
                QName qname = (element.getName().getPrefix() == null) ? df.createQName(element.getName().getLocalPart(), element.getName().getNamespaceURI()) : df.createQName(element.getName().getLocalPart(), element.getName().getPrefix(), element.getName().getNamespaceURI());
                Element newElement = df.createElement(qname);
                Iterator nsIt = element.getNamespaces();
                // add all relevant XML namespaces to Element
                while (nsIt.hasNext()) {
                    Namespace ns = (Namespace) nsIt.next();
                    newElement.addNamespace(ns.getPrefix(), ns.getNamespaceURI());
                }
                Iterator attrIt = element.getAttributes();
                // add all attributes to Element
                while (attrIt.hasNext()) {
                    Attribute attr = (Attribute) attrIt.next();
                    newElement.addAttribute(attr.getName().getLocalPart(), attr.getValue());
                }
                StreamOpen streamOpen = new StreamOpen(newElement);
                validator.validateStream(streamOpen);
                out.add(streamOpen);
            }
        } else if (event.isEndElement()) {
            out.add(new StreamClose());
        }
    }
}
#method_after
@Override
protected void decode(ChannelHandlerContext channelHandlerContext, Object object, List out) throws Exception {
    if (object instanceof Element) {
        Element root = (Element) object;
        try {
            Packet packet = recognizeAndReturnXmppPacket(root);
            validate(packet);
            out.add(packet);
        } catch (UnsupportedStanzaTypeException e) {
            throw e;
        } catch (Exception e) {
            throw new XmppValidationException(false);
        }
    } else if (object instanceof XMLEvent) {
        XMLEvent event = (XMLEvent) object;
        if (event.isStartElement()) {
            final StartElement element = event.asStartElement();
            if (element.getName().getLocalPart().equals(XmppConstants.STREAM_QNAME)) {
                DocumentFactory df = DocumentFactory.getInstance();
                QName qname = (element.getName().getPrefix() == null) ? df.createQName(element.getName().getLocalPart(), element.getName().getNamespaceURI()) : df.createQName(element.getName().getLocalPart(), element.getName().getPrefix(), element.getName().getNamespaceURI());
                Element newElement = df.createElement(qname);
                Iterator nsIt = element.getNamespaces();
                // add all relevant XML namespaces to Element
                while (nsIt.hasNext()) {
                    Namespace ns = (Namespace) nsIt.next();
                    newElement.addNamespace(ns.getPrefix(), ns.getNamespaceURI());
                }
                Iterator attrIt = element.getAttributes();
                // add all attributes to Element
                while (attrIt.hasNext()) {
                    Attribute attr = (Attribute) attrIt.next();
                    newElement.addAttribute(attr.getName().getLocalPart(), attr.getValue());
                }
                XmppStreamOpen xmppStreamOpen = new XmppStreamOpen(newElement);
                validator.validateStream(xmppStreamOpen);
                out.add(xmppStreamOpen);
            }
        } else if (event.isEndElement()) {
            out.add(new XmppStreamClose());
        }
    }
}
#end_block

#method_before
@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
    logger.info("Exception caught: {}", cause.getMessage());
    if (cause.getCause() instanceof XmppValidationException) {
        if (((XmppValidationException) cause.getCause()).isStreamValidationException()) {
            StreamError.Condition condition = StreamError.Condition.bad_format;
            StreamError error = new StreamError(condition);
            ctx.channel().writeAndFlush(error);
            ctx.channel().writeAndFlush(new StreamClose());
            return;
        }
    }
    logger.info("Not a StreamValidationException. Sending exception upstream.");
    ctx.fireExceptionCaught(cause);
}
#method_after
@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
    logger.info("Exception caught: {}", cause.getMessage());
    if (cause.getCause() instanceof XmppValidationException) {
        if (((XmppValidationException) cause.getCause()).isStreamValidationException()) {
            XmppStreamError.Condition condition = XmppStreamError.Condition.bad_format;
            XmppStreamError error = new XmppStreamError(condition);
            ctx.channel().writeAndFlush(error);
            ctx.channel().writeAndFlush(new XmppStreamClose());
            return;
        }
    }
    logger.info("Not a StreamValidationException. Sending exception upstream.");
    ctx.fireExceptionCaught(cause);
}
#end_block

#method_before
@Before
public void setUp() {
    device1 = new XmppDeviceAdapter();
    jid1 = new XmppDeviceId(new JID("agent1@testxmpp.org"));
    device2 = new XmppDeviceAdapter();
    jid2 = new XmppDeviceId(new JID("agent2@testxmpp.org"));
    device3 = new XmppDeviceAdapter();
    jid3 = new XmppDeviceId(new JID("agent3@testxmpp.org"));
    controller = new XmppControllerImpl();
    manager = controller.manager;
    testXmppDeviceListener = new TestXmppDeviceListener();
    controller.addXmppDeviceListener(testXmppDeviceListener);
    testXmppIqListener = new TestXmppIqListener();
    controller.addXmppIqListener(testXmppIqListener);
    testXmppMessageListener = new TestXmppMessageListener();
    controller.addXmppMessageListener(testXmppMessageListener);
    testXmppPresenceListener = new TestXmppPresenceListener();
    controller.addXmppPresenceListener(testXmppPresenceListener);
    CoreService mockCoreService = EasyMock.createMock(CoreService.class);
    controller.coreService = mockCoreService;
    ComponentConfigService mockCfgService = EasyMock.createMock(ComponentConfigService.class);
    expect(mockCfgService.getProperties(anyObject())).andReturn(ImmutableSet.of());
    mockCfgService.registerProperties(controller.getClass());
    expectLastCall();
    mockCfgService.unregisterProperties(controller.getClass(), false);
    expectLastCall();
    expect(mockCfgService.getProperties(anyObject())).andReturn(ImmutableSet.of());
    controller.cfgService = mockCfgService;
    replay(mockCfgService);
    DriverService mockDriverService = EasyMock.createMock(DriverService.class);
    controller.driverService = mockDriverService;
    ComponentContext mockContext = EasyMock.createMock(ComponentContext.class);
    Dictionary<String, Object> properties = new Hashtable<>();
    properties.put("xmppPort", "5269");
    expect(mockContext.getProperties()).andReturn(properties);
    replay(mockContext);
    controller.activate(mockContext);
}
#method_after
@Before
public void setUp() {
    device1 = new XmppDeviceAdapter();
    jid1 = new XmppDeviceId(new JID("agent1@testxmpp.org"));
    device2 = new XmppDeviceAdapter();
    jid2 = new XmppDeviceId(new JID("agent2@testxmpp.org"));
    device3 = new XmppDeviceAdapter();
    jid3 = new XmppDeviceId(new JID("agent3@testxmpp.org"));
    controller = new XmppControllerImpl();
    agent = controller.agent;
    testXmppDeviceListener = new TestXmppDeviceListener();
    controller.addXmppDeviceListener(testXmppDeviceListener);
    testXmppIqListener = new TestXmppIqListener();
    controller.addXmppIqListener(testXmppIqListener);
    testXmppMessageListener = new TestXmppMessageListener();
    controller.addXmppMessageListener(testXmppMessageListener);
    testXmppPresenceListener = new TestXmppPresenceListener();
    controller.addXmppPresenceListener(testXmppPresenceListener);
    CoreService mockCoreService = EasyMock.createMock(CoreService.class);
    controller.coreService = mockCoreService;
    ComponentConfigService mockCfgService = EasyMock.createMock(ComponentConfigService.class);
    expect(mockCfgService.getProperties(anyObject())).andReturn(ImmutableSet.of());
    mockCfgService.registerProperties(controller.getClass());
    expectLastCall();
    mockCfgService.unregisterProperties(controller.getClass(), false);
    expectLastCall();
    expect(mockCfgService.getProperties(anyObject())).andReturn(ImmutableSet.of());
    controller.cfgService = mockCfgService;
    replay(mockCfgService);
    ComponentContext mockContext = EasyMock.createMock(ComponentContext.class);
    Dictionary<String, Object> properties = new Hashtable<>();
    properties.put("xmppPort", "5269");
    expect(mockContext.getProperties()).andReturn(properties);
    replay(mockContext);
    controller.activate(mockContext);
}
#end_block

#method_before
@Test
public void testAddRemoveConnectedDevice() {
    // test adding connected devices
    boolean add1 = manager.addConnectedDevice(jid1, device1);
    assertThat(add1, is(true));
    assertThat(testXmppDeviceListener.addedDevices, hasSize(1));
    boolean add2 = manager.addConnectedDevice(jid2, device2);
    assertThat(add2, is(true));
    assertThat(testXmppDeviceListener.addedDevices, hasSize(2));
    boolean add3 = manager.addConnectedDevice(jid3, device3);
    assertThat(add3, is(true));
    assertThat(testXmppDeviceListener.addedDevices, hasSize(3));
    assertThat(testXmppDeviceListener.addedDevices, hasItems(jid1, jid2, jid3));
    // Test adding a device twice - it should fail
    boolean addError1 = manager.addConnectedDevice(jid1, device1);
    assertThat(addError1, is(false));
    assertThat(controller.connectedDevices.size(), is(3));
    // test querying the individual device
    XmppDevice queriedDevice = controller.getDevice(jid1);
    assertThat(queriedDevice, is(device1));
    // test removing device
    manager.removeConnectedDevice(jid3);
    assertThat(controller.connectedDevices.size(), is(2));
    // Make sure the listener delete callbacks fired
    assertThat(testXmppDeviceListener.removedDevices, hasSize(1));
    assertThat(testXmppDeviceListener.removedDevices, hasItems(jid3));
}
#method_after
@Test
public void testAddRemoveConnectedDevice() {
    // test adding connected devices
    boolean add1 = agent.addConnectedDevice(jid1, device1);
    assertThat(add1, is(true));
    assertThat(testXmppDeviceListener.addedDevices, hasSize(1));
    boolean add2 = agent.addConnectedDevice(jid2, device2);
    assertThat(add2, is(true));
    assertThat(testXmppDeviceListener.addedDevices, hasSize(2));
    boolean add3 = agent.addConnectedDevice(jid3, device3);
    assertThat(add3, is(true));
    assertThat(testXmppDeviceListener.addedDevices, hasSize(3));
    assertThat(testXmppDeviceListener.addedDevices, hasItems(jid1, jid2, jid3));
    // Test adding a device twice - it should fail
    boolean addError1 = agent.addConnectedDevice(jid1, device1);
    assertThat(addError1, is(false));
    assertThat(controller.connectedDevices.size(), is(3));
    // test querying the individual device
    XmppDevice queriedDevice = controller.getDevice(jid1);
    assertThat(queriedDevice, is(device1));
    // test removing device
    agent.removeConnectedDevice(jid3);
    assertThat(controller.connectedDevices.size(), is(2));
    // Make sure the listener delete callbacks fired
    assertThat(testXmppDeviceListener.removedDevices, hasSize(1));
    assertThat(testXmppDeviceListener.removedDevices, hasItems(jid3));
}
#end_block

#method_before
@Test
public void handlePackets() {
    // IQ packets
    Packet iq = new IQ();
    manager.processUpstreamEvent(jid1, iq);
    assertThat(testXmppIqListener.handledIqs, hasSize(1));
    manager.processUpstreamEvent(jid2, iq);
    assertThat(testXmppIqListener.handledIqs, hasSize(2));
    // Message packets
    Packet message = new Message();
    manager.processUpstreamEvent(jid1, message);
    assertThat(testXmppMessageListener.handledMessages, hasSize(1));
    manager.processUpstreamEvent(jid2, message);
    assertThat(testXmppMessageListener.handledMessages, hasSize(2));
    Packet presence = new Presence();
    manager.processUpstreamEvent(jid1, presence);
    assertThat(testXmppPresenceListener.handledPresenceStanzas, hasSize(1));
    manager.processUpstreamEvent(jid2, presence);
    assertThat(testXmppPresenceListener.handledPresenceStanzas, hasSize(2));
}
#method_after
@Test
public void handlePackets() {
    // IQ packets
    Packet iq = new IQ();
    agent.processUpstreamEvent(jid1, iq);
    assertThat(testXmppIqListener.handledIqs, hasSize(1));
    agent.processUpstreamEvent(jid2, iq);
    assertThat(testXmppIqListener.handledIqs, hasSize(2));
    // Message packets
    Packet message = new Message();
    agent.processUpstreamEvent(jid1, message);
    assertThat(testXmppMessageListener.handledMessages, hasSize(1));
    agent.processUpstreamEvent(jid2, message);
    assertThat(testXmppMessageListener.handledMessages, hasSize(2));
    Packet presence = new Presence();
    agent.processUpstreamEvent(jid1, presence);
    assertThat(testXmppPresenceListener.handledPresenceStanzas, hasSize(1));
    agent.processUpstreamEvent(jid2, presence);
    assertThat(testXmppPresenceListener.handledPresenceStanzas, hasSize(2));
}
#end_block

#method_before
public void init(XmppDeviceManager manager, DriverService driverService) {
    setManager(manager);
    setDriverService(driverService);
}
#method_after
public void init(XmppDeviceAgent manager) {
    setAgent(manager);
}
#end_block

#method_before
public XmppDevice getXmppDevice(JID jid) {
    XmppDeviceId xmppDeviceId = new XmppDeviceId(jid);
    return getXmppDeviceInstance(xmppDeviceId);
}
#method_after
public XmppDevice getXmppDevice(JID jid, XmppSession session) {
    XmppDeviceId xmppDeviceId = new XmppDeviceId(jid);
    return getXmppDeviceInstance(xmppDeviceId, session);
}
#end_block

#method_before
private XmppDevice getXmppDeviceInstance(XmppDeviceId xmppDeviceId) {
    XmppDevice device = manager.getDevice(xmppDeviceId);
    if (device != null) {
        return device;
    } else {
        // temporary solution, TODO: getDriver for device
        XmppDevice newDevice = createXmppDriverInstance(xmppDeviceId);
        newDevice.setManager(this.manager);
        return newDevice;
    }
}
#method_after
private XmppDevice getXmppDeviceInstance(XmppDeviceId xmppDeviceId, XmppSession session) {
    XmppDevice device = agent.getDevice(xmppDeviceId);
    if (device != null) {
        return device;
    } else {
        XmppDevice newDevice = createXmppDeviceInstance(xmppDeviceId, session);
        return newDevice;
    }
}
#end_block

#method_before
@Override
protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {
    byte[] bytes = null;
    if (msg instanceof StreamEvent) {
        StreamEvent streamEvent = (StreamEvent) msg;
        logger.info("SENDING: {}", streamEvent.toXml());
        bytes = streamEvent.toXml().getBytes(CharsetUtil.UTF_8);
    }
    if (msg instanceof Packet) {
        Packet pkt = (Packet) msg;
        logger.info("SENDING /n, {}", pkt.toString());
        bytes = pkt.toXML().getBytes(CharsetUtil.UTF_8);
    }
    out.writeBytes(checkNotNull(bytes));
}
#method_after
@Override
protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {
    byte[] bytes = null;
    if (msg instanceof XmppStreamEvent) {
        XmppStreamEvent streamEvent = (XmppStreamEvent) msg;
        logger.info("SENDING: {}", streamEvent.toXml());
        bytes = streamEvent.toXml().getBytes(CharsetUtil.UTF_8);
    }
    if (msg instanceof Packet) {
        Packet pkt = (Packet) msg;
        logger.info("SENDING /n, {}", pkt.toString());
        bytes = pkt.toXML().getBytes(CharsetUtil.UTF_8);
    }
    out.writeBytes(checkNotNull(bytes));
}
#end_block

#method_before
@Test
public void testDecodeStream() throws Exception {
    List<Object> out = Lists.newArrayList();
    xmppDecoder.decode(mockChannelHandlerContext, streamOpen, out);
    assertThat(out.size(), is(1));
    assertThat(out.get(0), is(instanceOf(StreamOpen.class)));
    StreamOpen stream = (StreamOpen) out.get(0);
    assertThat(stream.getElement(), is(notNullValue()));
    assertThat(stream.getToJid(), is(new JID("xmpp.onosproject.org")));
    assertThat(stream.getFromJid(), is(new JID("test@xmpp.org")));
}
#method_after
@Test
public void testDecodeStream() throws Exception {
    List<Object> out = Lists.newArrayList();
    xmppDecoder.decode(mockChannelHandlerContext, streamOpen, out);
    assertThat(out.size(), is(1));
    assertThat(out.get(0), is(instanceOf(XmppStreamOpen.class)));
    XmppStreamOpen stream = (XmppStreamOpen) out.get(0);
    assertThat(stream.getElement(), is(notNullValue()));
    assertThat(stream.getToJid(), is(new JID("xmpp.onosproject.org")));
    assertThat(stream.getFromJid(), is(new JID("test@xmpp.org")));
}
#end_block

#method_before
private void addFilterToDevice(DeviceId deviceId, PortNumber port, VlanId assignedVlan, IpAddress mcastIp) {
    // Do nothing if the port is configured as suppressed
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId(), SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
        log.info("Ignore suppressed port {}", connectPoint);
        return;
    }
    FilteringObjective.Builder filtObjBuilder = filterObjBuilder(deviceId, port, assignedVlan, mcastIp);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add filter on {}/{}, vlan {}", deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add filter on {}/{}, vlan {}: {}", deviceId, port.toLong(), assignedVlan, error));
    srManager.flowObjectiveService.filter(deviceId, filtObjBuilder.add(context));
}
#method_after
private void addFilterToDevice(DeviceId deviceId, PortNumber port, VlanId assignedVlan, IpAddress mcastIp) {
    // Do nothing if the port is configured as suppressed
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId(), SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
        log.info("Ignore suppressed port {}", connectPoint);
        return;
    }
    MacAddress routerMac;
    try {
        routerMac = srManager.deviceConfiguration().getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException dcnfe) {
        log.warn("Fail to push filtering objective since device is not configured. Abort");
        return;
    }
    FilteringObjective.Builder filtObjBuilder = filterObjBuilder(deviceId, port, assignedVlan, mcastIp, routerMac);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add filter on {}/{}, vlan {}", deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add filter on {}/{}, vlan {}: {}", deviceId, port.toLong(), assignedVlan, error));
    srManager.flowObjectiveService.filter(deviceId, filtObjBuilder.add(context));
}
#end_block

#method_before
private FilteringObjective.Builder filterObjBuilder(DeviceId deviceId, PortNumber ingressPort, VlanId assignedVlan, IpAddress mcastIp) {
    FilteringObjective.Builder filtBuilder = DefaultFilteringObjective.builder();
    if (mcastIp.isIp4()) {
        filtBuilder.withKey(Criteria.matchInPort(ingressPort)).addCondition(Criteria.matchEthDstMasked(MacAddress.IPV4_MULTICAST, MacAddress.IPV4_MULTICAST_MASK)).addCondition(Criteria.matchVlanId(egressVlan())).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    } else {
        filtBuilder.withKey(Criteria.matchInPort(ingressPort)).addCondition(Criteria.matchEthDstMasked(MacAddress.IPV6_MULTICAST, MacAddress.IPV6_MULTICAST_MASK)).addCondition(Criteria.matchVlanId(egressVlan())).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    }
    TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
    filtBuilder.withMeta(tt);
    return filtBuilder.permit().fromApp(srManager.appId());
}
#method_after
private FilteringObjective.Builder filterObjBuilder(DeviceId deviceId, PortNumber ingressPort, VlanId assignedVlan, IpAddress mcastIp, MacAddress routerMac) {
    FilteringObjective.Builder filtBuilder = DefaultFilteringObjective.builder();
    if (mcastIp.isIp4()) {
        filtBuilder.withKey(Criteria.matchInPort(ingressPort)).addCondition(Criteria.matchEthDstMasked(MacAddress.IPV4_MULTICAST, MacAddress.IPV4_MULTICAST_MASK)).addCondition(Criteria.matchVlanId(egressVlan())).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    } else {
        filtBuilder.withKey(Criteria.matchInPort(ingressPort)).addCondition(Criteria.matchEthDstMasked(MacAddress.IPV6_MULTICAST, MacAddress.IPV6_MULTICAST_MASK)).addCondition(Criteria.matchVlanId(egressVlan())).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    }
    TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).setEthDst(routerMac).build();
    filtBuilder.withMeta(tt);
    return filtBuilder.permit().fromApp(srManager.appId());
}
#end_block

#method_before
private void removeFilterToDevice(DeviceId deviceId, PortNumber port, VlanId assignedVlan, IpAddress mcastIp) {
    // Do nothing if the port is configured as suppressed
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId(), SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
        log.info("Ignore suppressed port {}", connectPoint);
        return;
    }
    FilteringObjective.Builder filtObjBuilder = filterObjBuilder(deviceId, port, assignedVlan, mcastIp);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully removed filter on {}/{}, vlan {}", deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to remove filter on {}/{}, vlan {}: {}", deviceId, port.toLong(), assignedVlan, error));
    srManager.flowObjectiveService.filter(deviceId, filtObjBuilder.remove(context));
}
#method_after
private void removeFilterToDevice(DeviceId deviceId, PortNumber port, VlanId assignedVlan, IpAddress mcastIp) {
    // Do nothing if the port is configured as suppressed
    ConnectPoint connectPoint = new ConnectPoint(deviceId, port);
    SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId(), SegmentRoutingAppConfig.class);
    if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
        log.info("Ignore suppressed port {}", connectPoint);
        return;
    }
    MacAddress routerMac;
    try {
        routerMac = srManager.deviceConfiguration().getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException dcnfe) {
        log.warn("Fail to push filtering objective since device is not configured. Abort");
        return;
    }
    FilteringObjective.Builder filtObjBuilder = filterObjBuilder(deviceId, port, assignedVlan, mcastIp, routerMac);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully removed filter on {}/{}, vlan {}", deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to remove filter on {}/{}, vlan {}: {}", deviceId, port.toLong(), assignedVlan, error));
    srManager.flowObjectiveService.filter(deviceId, filtObjBuilder.remove(context));
}
#end_block

#method_before
public void addPort(Port port) {
    Long portNum = port.number().toLong();
    String portName = port.annotations().value(PORT_NAME);
    boolean newPort = portMap.containsKey(portNum);
    portMap.put(portNum, portName);
    boolean isMaster = context.mastershipService().isLocalMaster(device.id());
    if (newPort && isMaster) {
        log.debug("Sending initial probe to port {}@{}", port.number().toLong(), device.id());
        sendProbes(portNum, portName);
    }
}
#method_after
public void addPort(Port port) {
    Long portNum = port.number().toLong();
    String portName = port.annotations().value(PORT_NAME);
    boolean newPort = containsPort(portNum);
    portMap.put(portNum, portName);
    boolean isMaster = context.mastershipService().isLocalMaster(device.id());
    if (newPort && isMaster) {
        log.debug("Sending initial probe to port {}@{}", port.number().toLong(), device.id());
        sendProbes(portNum, portName);
    }
}
#end_block

#method_before
@Override
public void run(Timeout t) {
    if (isStopped()) {
        return;
    }
    if (context.mastershipService().isLocalMaster(device.id())) {
        log.trace("Sending probes from {}", device.id());
        portMap.keySet().forEach(portNum -> sendProbes(portNum, portMap.get(portNum)));
    }
    if (!isStopped()) {
        timeout = t.timer().newTimeout(this, context.probeRate(), MILLISECONDS);
    }
}
#method_after
@Override
public void run(Timeout t) {
    if (isStopped()) {
        return;
    }
    if (context.mastershipService().isLocalMaster(device.id())) {
        log.trace("Sending probes from {}", device.id());
        portMap.entrySet().forEach(e -> sendProbes(e.getKey(), e.getValue()));
    }
    if (!isStopped()) {
        timeout = t.timer().newTimeout(this, context.probeRate(), MILLISECONDS);
    }
}
#end_block

#method_before
// updates a port description whose port type has not changed.
private static PortDescription updateDescription(PortNumber port, SparseAnnotations sa, PortDescription descr) {
    if (port.exactlyEquals(descr.portNumber()) && sa.equals(descr.annotations())) {
        // result is no-op
        return descr;
    }
    return DefaultPortDescription.builder(descr).withPortNumer(port).annotations(sa).build();
}
#method_after
// updates a port description whose port type has not changed.
private static PortDescription updateDescription(PortNumber port, SparseAnnotations sa, PortDescription descr) {
    if (port.exactlyEquals(descr.portNumber()) && sa.equals(descr.annotations())) {
        // result is no-op
        return descr;
    }
    return DefaultPortDescription.builder(descr).withPortNumber(port).annotations(sa).build();
}
#end_block

#method_before
public Builder withPortNumer(PortNumber number) {
    this.number = checkNotNull(number);
    return this;
}
#method_after
/**
 * Sets mandatory field PortNumber.
 *
 * @param number to set
 * @return self
 *
 * @deprecated in 1.13.0 use withPortNumber() instead.
 */
@Deprecated
public Builder withPortNumer(PortNumber number) {
    return withPortNumber(number);
}
#end_block

#method_before
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean popMpls = false;
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        if (buildIpv4Selector(filteredSelector, complementarySelector, fwd, allowDefaultRoute) < 0) {
            return Collections.emptyList();
        }
        // We need to set properly the next table
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            forTableId = MULTICAST_ROUTING_TABLE;
        } else {
            forTableId = UNICAST_ROUTING_TABLE;
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        if (buildIpv6Selector(filteredSelector, fwd) < 0) {
            return Collections.emptyList();
        }
        // We need to set the proper next table
        IpPrefix ipv6Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV6_DST)).ip();
        if (ipv6Dst.isMulticast()) {
            forTableId = MULTICAST_ROUTING_TABLE;
        } else {
            forTableId = UNICAST_ROUTING_TABLE;
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(MPLS_BOS);
        if (bos != null && requireMplsBosMatch()) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    popMpls = true;
                    // setting the MPLS_TYPE so pop can happen down the pipeline
                    if (requireMplsPop()) {
                        if (mplsNextTable == MPLS_TYPE_TABLE && isNotMplsBos(selector)) {
                            tb.immediate().popMpls();
                        }
                    } else {
                        // Skip mpls pop action for mpls_unicast label
                        if (instr instanceof ModMplsHeaderInstruction && !((ModMplsHeaderInstruction) instr).ethernetType().equals(EtherType.MPLS_UNICAST.ethType())) {
                            tb.immediate().add(instr);
                        }
                    }
                }
                if (requireMplsTtlModification()) {
                    if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                        // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                        tb.immediate().decMplsTtl();
                    }
                    if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                        tb.immediate().add(instr);
                    }
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        if (forTableId == MPLS_TABLE_1 && !popMpls) {
            log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
            // XXX We could convert to forwarding to a single-port, via a MPLS interface,
            // or a MPLS SWAP (with-same) but that would have to be handled in the next-objective.
            // Also the pop-mpls logic used here won't work in non-BoS case.
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (isNotMplsBos(selector) && group.type().equals(SELECT)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting this flow {} -> next:{}" + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // retrying flows may be necessary due to bug CORD-554
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                if (shouldRetry()) {
                    log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                    emptyGroup = true;
                }
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (!allowDefaultRoute) {
        flowRuleCollection.add(defaultRoute(fwd, complementarySelector, forTableId, tb));
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#method_after
protected Collection<FlowRule> processEthTypeSpecificInternal(ForwardingObjective fwd, boolean allowDefaultRoute, int mplsNextTable) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    boolean emptyGroup = false;
    int forTableId;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        if (buildIpv4Selector(filteredSelector, complementarySelector, fwd, allowDefaultRoute) < 0) {
            return Collections.emptyList();
        }
        // We need to set properly the next table
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            forTableId = MULTICAST_ROUTING_TABLE;
        } else {
            forTableId = UNICAST_ROUTING_TABLE;
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        if (buildIpv6Selector(filteredSelector, fwd) < 0) {
            return Collections.emptyList();
        }
        // We need to set the proper next table
        IpPrefix ipv6Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV6_DST)).ip();
        if (ipv6Dst.isMulticast()) {
            forTableId = MULTICAST_ROUTING_TABLE;
        } else {
            forTableId = UNICAST_ROUTING_TABLE;
        }
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                // XXX decrementing IP ttl is done automatically for routing, this
                // action is ignored or rejected in ofdpa as it is not fully implemented
                // tb.deferred().add(instr);
                }
            }
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(MPLS_BOS);
        if (bos != null && requireMplsBosMatch()) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
        if (fwd.treatment() != null) {
            for (Instruction instr : fwd.treatment().allInstructions()) {
                if (instr instanceof L2ModificationInstruction && ((L2ModificationInstruction) instr).subtype() == L2SubType.MPLS_POP) {
                    // setting the MPLS_TYPE so pop can happen down the pipeline
                    if (requireMplsPop()) {
                        if (mplsNextTable == MPLS_TYPE_TABLE && isNotMplsBos(selector)) {
                            tb.immediate().popMpls();
                        }
                    } else {
                        // Skip mpls pop action for mpls_unicast label
                        if (instr instanceof ModMplsHeaderInstruction && !((ModMplsHeaderInstruction) instr).ethernetType().equals(EtherType.MPLS_UNICAST.ethType())) {
                            tb.immediate().add(instr);
                        }
                    }
                }
                if (requireMplsTtlModification()) {
                    if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.DEC_TTL) {
                        // FIXME Should modify the app to send the correct DEC_MPLS_TTL instruction
                        tb.immediate().decMplsTtl();
                    }
                    if (instr instanceof L3ModificationInstruction && ((L3ModificationInstruction) instr).subtype() == L3SubType.TTL_IN) {
                        tb.immediate().add(instr);
                    }
                }
            }
        }
    }
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            if (isNotMplsBos(selector) && group.type().equals(SELECT)) {
                log.warn("SR CONTINUE case cannot be handled as MPLS ECMP " + "is not implemented in OF-DPA yet. Aborting flow {} -> next:{} " + "in this device {}", fwd.id(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
            // retrying flows may be necessary due to bug CORD-554
            if (gkeys.size() == 1 && gkeys.get(0).size() == 1) {
                if (shouldRetry()) {
                    log.warn("Found empty group 0x{} in dev:{} .. will retry fwd:{}", Integer.toHexString(group.id().id()), deviceId, fwd.id());
                    emptyGroup = true;
                }
            }
        } else {
            log.warn("Cannot find group for nextId:{} in dev:{}. Aborting fwd:{}", fwd.nextId(), deviceId, fwd.id());
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
            return Collections.emptySet();
        }
    }
    if (forTableId == MPLS_TABLE_1) {
        if (mplsNextTable == MPLS_L3_TYPE_TABLE) {
            Ofdpa3SetMplsType setMplsType = new Ofdpa3SetMplsType(Ofdpa3MplsType.L3_PHP);
            // set mpls type as apply_action
            tb.immediate().extension(setMplsType, deviceId);
        }
        tb.transition(mplsNextTable);
    } else {
        tb.transition(ACL_TABLE);
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (!allowDefaultRoute) {
        flowRuleCollection.add(defaultRoute(fwd, complementarySelector, forTableId, tb));
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    if (emptyGroup) {
        executorService.schedule(new RetryFlows(fwd, flowRuleCollection), RETRY_MS, TimeUnit.MILLISECONDS);
    }
    return flowRuleCollection;
}
#end_block

#method_before
private Collection<ForwardingObjective> handleMpls(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops, int segmentId, IpAddress routerIp, boolean isMplsBos) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = Lists.newArrayList();
    // For the transport of Pwaas we can use two or three MPLS label
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    sbuilder.matchMplsBos(isMplsBos);
    TrafficSelector selector = sbuilder.build();
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since mpls next-hops are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(SegmentRoutingManager.INTERNAL_VLAN);
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        // If the next hop is the destination router for the segment, do pop
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with pop to next-hops {}", segmentId, targetSwId, nextHops);
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, true, isMplsBos, metabuilder.build(), routerIp, segmentId, destSwId);
        // Error case, we cannot handle, exit.
        if (fwdObjNoBosBuilder == null) {
            return Collections.emptyList();
        }
        fwdObjBuilders.add(fwdObjNoBosBuilder);
    } else if (!destSwId.equals(nextHops.toArray()[0])) {
        // next hop is not destination, SR CONTINUE case (swap with self)
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without pop to next-hops {}", segmentId, targetSwId, nextHops);
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, false, isMplsBos, metabuilder.build(), routerIp, segmentId, destSwId);
        // Error case, we cannot handle, exit.
        if (fwdObjNoBosBuilder == null) {
            return Collections.emptyList();
        }
        fwdObjBuilders.add(fwdObjNoBosBuilder);
    }
    List<ForwardingObjective> fwdObjs = Lists.newArrayList();
    // We add the final property to the fwdObjs.
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(SegmentRoutingService.DEFAULT_PRIORITY)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("MPLS rule {} for SID {} populated in dev:{} ", objective.id(), segmentId, targetSwId), (objective, error) -> log.warn("Failed to populate MPLS rule {} for SID {}: {} in dev:{}", objective.id(), segmentId, error, targetSwId));
        ForwardingObjective fob = fwdObjBuilder.add(context);
        fwdObjs.add(fob);
    }
    return fwdObjs;
}
#method_after
private Collection<ForwardingObjective> handleMpls(DeviceId targetSwId, DeviceId destSwId, Set<DeviceId> nextHops, int segmentId, IpAddress routerIp, boolean isMplsBos) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    List<ForwardingObjective.Builder> fwdObjBuilders = Lists.newArrayList();
    // For the transport of Pwaas we can use two or three MPLS label
    sbuilder.matchEthType(Ethernet.MPLS_UNICAST);
    sbuilder.matchMplsLabel(MplsLabel.mplsLabel(segmentId));
    sbuilder.matchMplsBos(isMplsBos);
    TrafficSelector selector = sbuilder.build();
    // setup metadata to pass to nextObjective - indicate the vlan on egress
    // if needed by the switch pipeline. Since mpls next-hops are always to
    // other neighboring routers, there is no subnet assigned on those ports.
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder(selector);
    metabuilder.matchVlanId(SegmentRoutingManager.INTERNAL_VLAN);
    if (nextHops.size() == 1 && destSwId.equals(nextHops.toArray()[0])) {
        // If the next hop is the destination router for the segment, do pop
        log.debug("populateMplsRule: Installing MPLS forwarding objective for " + "label {} in switch {} with pop to next-hops {}", segmentId, targetSwId, nextHops);
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, true, isMplsBos, metabuilder.build(), routerIp, segmentId, destSwId);
        // Error case, we cannot handle, exit.
        if (fwdObjNoBosBuilder == null) {
            return Collections.emptyList();
        }
        fwdObjBuilders.add(fwdObjNoBosBuilder);
    } else {
        // next hop is not destination, irrespective of the number of next
        // hops (1 or more) -- SR CONTINUE case (swap with self)
        log.debug("Installing MPLS forwarding objective for " + "label {} in switch {} without pop to next-hops {}", segmentId, targetSwId, nextHops);
        ForwardingObjective.Builder fwdObjNoBosBuilder = getMplsForwardingObjective(targetSwId, nextHops, false, isMplsBos, metabuilder.build(), routerIp, segmentId, destSwId);
        // Error case, we cannot handle, exit.
        if (fwdObjNoBosBuilder == null) {
            return Collections.emptyList();
        }
        fwdObjBuilders.add(fwdObjNoBosBuilder);
    }
    List<ForwardingObjective> fwdObjs = Lists.newArrayList();
    // We add the final property to the fwdObjs.
    for (ForwardingObjective.Builder fwdObjBuilder : fwdObjBuilders) {
        ((Builder) ((Builder) fwdObjBuilder.fromApp(srManager.appId).makePermanent()).withSelector(selector).withPriority(SegmentRoutingService.DEFAULT_PRIORITY)).withFlag(ForwardingObjective.Flag.SPECIFIC);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("MPLS rule {} for SID {} populated in dev:{} ", objective.id(), segmentId, targetSwId), (objective, error) -> log.warn("Failed to populate MPLS rule {} for SID {}: {} in dev:{}", objective.id(), segmentId, error, targetSwId));
        ForwardingObjective fob = fwdObjBuilder.add(context);
        fwdObjs.add(fob);
    }
    return fwdObjs;
}
#end_block

#method_before
private ForwardingObjective.Builder getMplsForwardingObjective(DeviceId targetSw, Set<DeviceId> nextHops, boolean phpRequired, boolean isBos, TrafficSelector meta, IpAddress routerIp, int segmentId, DeviceId destSw) {
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.SPECIFIC);
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    DestinationSet ds = null;
    boolean simple = false;
    if (phpRequired) {
        // php case - pop should always be flow-action
        log.debug("getMplsForwardingObjective: php required");
        tbuilder.deferred().copyTtlIn();
        if (isBos) {
            if (routerIp.isIp4()) {
                tbuilder.deferred().popMpls(EthType.EtherType.IPV4.ethType());
            } else {
                tbuilder.deferred().popMpls(EthType.EtherType.IPV6.ethType());
            }
            tbuilder.decNwTtl();
        } else {
            tbuilder.deferred().popMpls(EthType.EtherType.MPLS_UNICAST.ethType()).decMplsTtl();
        }
        // standard case -> BoS == True; pop results in IP packet and forwarding
        // is via an ECMP group
        ds = new DestinationSet(false, false, destSw);
        // depending on configuration we can ECMP this packet or choose one output
        if (!isBos && srManager.getMplsEcmp()) {
            ds = new DestinationSet(true, false, destSw);
        } else if (!isBos && !srManager.getMplsEcmp()) {
            ds = new DestinationSet(true, false, destSw);
            simple = true;
        }
    } else {
        // swap with self case - SR CONTINUE
        log.debug("getMplsForwardingObjective: swap with self");
        tbuilder.deferred().decMplsTtl();
        // depending on configuration we can ECMP this packet or choose one output
        if (srManager.getMplsEcmp()) {
            ds = new DestinationSet(false, true, segmentId, destSw);
        } else {
            ds = new DestinationSet(false, true, segmentId, destSw);
            simple = true;
        }
    }
    fwdBuilder.withTreatment(tbuilder.build());
    log.debug("Trying to get a nextObjId for mpls rule on device:{} to ds:{}", targetSw, ds);
    DefaultGroupHandler gh = srManager.getGroupHandler(targetSw);
    if (gh == null) {
        log.warn("getNextObjectiveId query - groupHandler for device {} " + "not found", targetSw);
        return null;
    }
    Map<DeviceId, Set<DeviceId>> dstNextHops = new HashMap<>();
    dstNextHops.put(destSw, nextHops);
    int nextId = gh.getNextObjectiveId(ds, dstNextHops, meta, simple);
    if (nextId <= 0) {
        log.warn("No next objective in {} for ds: {}", targetSw, ds);
        return null;
    } else {
        log.debug("nextObjId found:{} for mpls rule on device:{} to ds:{}", nextId, targetSw, ds);
    }
    fwdBuilder.nextStep(nextId);
    return fwdBuilder;
}
#method_after
private ForwardingObjective.Builder getMplsForwardingObjective(DeviceId targetSw, Set<DeviceId> nextHops, boolean phpRequired, boolean isBos, TrafficSelector meta, IpAddress routerIp, int segmentId, DeviceId destSw) {
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.SPECIFIC);
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    DestinationSet ds = null;
    boolean simple = false;
    if (phpRequired) {
        // php case - pop should always be flow-action
        log.debug("getMplsForwardingObjective: php required");
        tbuilder.deferred().copyTtlIn();
        if (isBos) {
            if (routerIp.isIp4()) {
                tbuilder.deferred().popMpls(EthType.EtherType.IPV4.ethType());
            } else {
                tbuilder.deferred().popMpls(EthType.EtherType.IPV6.ethType());
            }
            tbuilder.decNwTtl();
            // standard case -> BoS == True; pop results in IP packet and forwarding
            // is via an ECMP group
            ds = new DestinationSet(false, false, destSw);
        } else {
            tbuilder.deferred().popMpls(EthType.EtherType.MPLS_UNICAST.ethType()).decMplsTtl();
            // depending on configuration we can ECMP this packet or choose one output
            if (srManager.getMplsEcmp()) {
                ds = new DestinationSet(true, false, destSw);
            } else {
                ds = new DestinationSet(true, false, destSw);
                simple = true;
            }
        }
    } else {
        // swap with self case - SR CONTINUE
        log.debug("getMplsForwardingObjective: swap with self");
        tbuilder.deferred().decMplsTtl();
        // depending on configuration we can ECMP this packet or choose one output
        if (srManager.getMplsEcmp()) {
            ds = new DestinationSet(false, true, segmentId, destSw);
        } else {
            ds = new DestinationSet(false, true, segmentId, destSw);
            simple = true;
        }
    }
    fwdBuilder.withTreatment(tbuilder.build());
    log.debug("Trying to get a nextObjId for mpls rule on device:{} to ds:{}", targetSw, ds);
    DefaultGroupHandler gh = srManager.getGroupHandler(targetSw);
    if (gh == null) {
        log.warn("getNextObjectiveId query - groupHandler for device {} " + "not found", targetSw);
        return null;
    }
    Map<DeviceId, Set<DeviceId>> dstNextHops = new HashMap<>();
    dstNextHops.put(destSw, nextHops);
    int nextId = gh.getNextObjectiveId(ds, dstNextHops, meta, simple);
    if (nextId <= 0) {
        log.warn("No next objective in {} for ds: {}", targetSw, ds);
        return null;
    } else {
        log.debug("nextObjId found:{} for mpls rule on device:{} to ds:{}", nextId, targetSw, ds);
    }
    fwdBuilder.nextStep(nextId);
    return fwdBuilder;
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    l2TunnelHandler.init();
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    topologyHandler = new TopologyHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    topologyService.addListener(topologyListener);
    l2TunnelHandler.init();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    topologyService.removeListener(topologyListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public Map<McastStoreKey, McastHandler.McastRole> getMcastRoles(IpAddress mcastIp) {
    return mcastHandler.getMcastRoles(mcastIp);
}
#method_after
@Override
public Map<McastStoreKey, McastRole> getMcastRoles(IpAddress mcastIp) {
    return mcastHandler.getMcastRoles(mcastIp);
}
#end_block

#method_before
VlanId getInternalVlanId(ConnectPoint connectPoint) {
    VlanId untaggedVlanId = getUntaggedVlanId(connectPoint);
    VlanId nativeVlanId = getNativeVlanId(connectPoint);
    return untaggedVlanId != null ? untaggedVlanId : nativeVlanId;
}
#method_after
public VlanId getInternalVlanId(ConnectPoint connectPoint) {
    VlanId untaggedVlanId = getUntaggedVlanId(connectPoint);
    VlanId nativeVlanId = getNativeVlanId(connectPoint);
    return untaggedVlanId != null ? untaggedVlanId : nativeVlanId;
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        try {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                linkHandler.processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                linkHandler.processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        } catch (Exception e) {
            log.error("SegmentRouting event handler thread thrown an exception: {}", e.getMessage(), e);
        }
    }
}
#method_after
@Override
public void run() {
    while (true) {
        try {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            // TODO We should also change SR routing and PW to listen to TopologyEvents
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                linkHandler.processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                linkHandler.processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else if (event.type() == TopologyEvent.Type.TOPOLOGY_CHANGED) {
                // Process topology event, needed for all modules relying on
                // topology service for path computation
                TopologyEvent topologyEvent = (TopologyEvent) event;
                log.info("Processing topology event {}, topology age {}, reasons {}", event.type(), topologyEvent.subject().time(), topologyEvent.reasons().size());
                topologyHandler.processTopologyChange(topologyEvent.reasons());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        } catch (Exception e) {
            log.error("SegmentRouting event handler thread thrown an exception: {}", e.getMessage(), e);
        }
    }
}
#end_block

#method_before
private void processDeviceRemoved(Device device) {
    dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> dsNextObjStore.remove(entry.getKey()));
    vlanNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> vlanNextObjStore.remove(entry.getKey()));
    portNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> portNextObjStore.remove(entry.getKey()));
    linkHandler.processDeviceRemoved(device);
    DefaultGroupHandler gh = groupHandlerMap.remove(device.id());
    if (gh != null) {
        gh.shutdown();
    }
    // Note that a switch going down is associated with all of its links
    // going down as well, but it is treated as a single switch down event
    // while the link-downs are ignored.
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, null, device.id());
    defaultRoutingHandler.purgeEcmpGraph(device.id());
    mcastHandler.processDeviceDown(device.id());
    xConnectHandler.removeDevice(device.id());
    // Cleanup all internal groupHandler stores for this device. Should be
    // done after all rerouting or rehashing has been completed
    groupHandlerMap.entrySet().forEach(entry -> entry.getValue().cleanUpForNeighborDown(device.id()));
}
#method_after
private void processDeviceRemoved(Device device) {
    dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> dsNextObjStore.remove(entry.getKey()));
    vlanNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> vlanNextObjStore.remove(entry.getKey()));
    portNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> portNextObjStore.remove(entry.getKey()));
    linkHandler.processDeviceRemoved(device);
    DefaultGroupHandler gh = groupHandlerMap.remove(device.id());
    if (gh != null) {
        gh.shutdown();
    }
    // Note that a switch going down is associated with all of its links
    // going down as well, but it is treated as a single switch down event
    // while the link-downs are ignored.
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, null, device.id());
    defaultRoutingHandler.purgeEcmpGraph(device.id());
    xConnectHandler.removeDevice(device.id());
    // Cleanup all internal groupHandler stores for this device. Should be
    // done after all rerouting or rehashing has been completed
    groupHandlerMap.entrySet().forEach(entry -> entry.getValue().cleanUpForNeighborDown(device.id()));
}
#end_block

#method_before
@Override
public void event(McastEvent event) {
    switch(event.type()) {
        case SOURCE_ADDED:
            mcastHandler.processSourceAdded(event);
            break;
        case SINK_ADDED:
            mcastHandler.processSinkAdded(event);
            break;
        case SINK_REMOVED:
            mcastHandler.processSinkRemoved(event);
            break;
        case ROUTE_REMOVED:
            mcastHandler.processRouteRemoved(event);
            break;
        case ROUTE_ADDED:
        default:
            break;
    }
}
#method_after
@Override
public void event(McastEvent event) {
    switch(event.type()) {
        case SOURCE_ADDED:
            mcastHandler.processSourceAdded(event);
            break;
        case SOURCE_UPDATED:
            mcastHandler.processSourceUpdated(event);
            break;
        case SINK_ADDED:
            mcastHandler.processSinkAdded(event);
            break;
        case SINK_REMOVED:
            mcastHandler.processSinkRemoved(event);
            break;
        case ROUTE_REMOVED:
            mcastHandler.processRouteRemoved(event);
            break;
        case ROUTE_ADDED:
        default:
            break;
    }
}
#end_block

#method_before
private void createL2L3AndMplsTreatments(TrafficTreatment treatment, TrafficTreatment.Builder l2L3Treatment, TrafficTreatment.Builder mplsTreatment) {
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                // These instructions have to go in the l2/l3 treatment.
                case ETH_DST:
                case ETH_SRC:
                case VLAN_ID:
                case VLAN_POP:
                    l2L3Treatment.add(ins);
                    break;
                // These instructions have to go in the mpls treatment.
                case MPLS_BOS:
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_PUSH:
                    mplsTreatment.add(ins);
                    break;
                default:
                    log.warn("Driver does not handle TrafficTreatment" + " L2Mod {} for pw next-obj", l2ins.subtype());
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            // The output goes in the l2/l3 treatment.
            l2L3Treatment.add(ins);
        } else if (ins.type() == Instruction.Type.L3MODIFICATION) {
            // We support partially the l3 instructions.
            L3ModificationInstruction l3ins = (L3ModificationInstruction) ins;
            switch(l3ins.subtype()) {
                case TTL_OUT:
                    mplsTreatment.add(ins);
                    break;
                default:
                    log.warn("Driver does not handle TrafficTreatment" + " L3Mod for pw next-obj", l3ins.subtype());
            }
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction fpr pw next-obj: {} - {}", ins.type(), ins);
        }
    }
}
#method_after
private void createL2L3AndMplsTreatments(TrafficTreatment treatment, TrafficTreatment.Builder l2L3Treatment, TrafficTreatment.Builder mplsTreatment) {
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                // These instructions have to go in the l2/l3 treatment.
                case ETH_DST:
                case ETH_SRC:
                case VLAN_ID:
                case VLAN_POP:
                    l2L3Treatment.add(ins);
                    break;
                // These instructions have to go in the mpls treatment.
                case MPLS_BOS:
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_PUSH:
                    mplsTreatment.add(ins);
                    break;
                default:
                    log.warn("Driver does not handle TrafficTreatment" + " L2Mod {} for pw next-obj", l2ins.subtype());
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            // The output goes in the l2/l3 treatment.
            l2L3Treatment.add(ins);
        } else if (ins.type() == Instruction.Type.L3MODIFICATION) {
            // We support partially the l3 instructions.
            L3ModificationInstruction l3ins = (L3ModificationInstruction) ins;
            switch(l3ins.subtype()) {
                case TTL_OUT:
                    mplsTreatment.add(ins);
                    break;
                default:
                    log.warn("Driver does not handle TrafficTreatment" + " L3Mod for pw next-obj", l3ins.subtype());
            }
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction for pw next-obj: {} - {}", ins.type(), ins);
        }
    }
}
#end_block

#method_before
public void portDownForLink(PortNumber port) {
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#method_after
public void portDownForLink(Link link) {
    PortNumber port = link.src().port();
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#end_block

#method_before
void processLinkAdded(Link link) {
    log.info("** LINK ADDED {}", link.toString());
    if (!isLinkValid(link)) {
        return;
    }
    // Irrespective of whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules if needed,
    // as in a multi-instance setup, instances can initiate groups for any
    // device. Also update local groupHandler stores.
    DefaultGroupHandler groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portUpForLink(link);
    } else {
        Device device = srManager.deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added notification without " + "Device Added event, still handling it");
            srManager.processDeviceAdded(device);
            groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
            if (groupHandler != null) {
                groupHandler.portUpForLink(link);
            }
        }
    }
    if (srManager.deviceConfiguration == null || !srManager.deviceConfiguration.isConfigured(link.src().deviceId())) {
        updateSeenLink(link, true);
        log.warn("Source device of this link is not configured.. " + "not processing further");
        return;
    }
    /*
         // process link only if it is bidirectional
         if (!isBidirectional(link)) {
            log.debug("Link not bidirectional.. waiting for other direction " +
                      "src {} --> dst {} ", link.dst(), link.src());
            // note that if we are not processing for routing, it should at least
            // be considered a seen-link
            updateSeenLink(link, true); return;
          }
         //TODO ensure that rehash is still done correctly even if link is not processed for
         //rerouting - perhaps rehash in both directions when it ultimately becomes bidi?
         */
    log.debug("Starting optimized route-path processing for added link " + "{} --> {}", link.src(), link.dst());
    boolean seenBefore = isSeenLink(link);
    // seenLink updates will be done after route-path changes
    srManager.defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, link, null);
    if (srManager.mastershipService.isLocalMaster(link.src().deviceId())) {
        // handle edge-ports for dual-homed hosts
        updateDualHomedHostPorts(link, true);
        // for the link that has come up.
        if (groupHandler != null) {
            if (!seenBefore && isParallelLink(link)) {
                // if link seen first time, we need to ensure hash-groups have
                // all ports
                log.debug("Attempting retryHash for paralled first-time link {}", link);
                groupHandler.retryHash(link, false, true);
            } else {
                // seen before-link
                if (isParallelLink(link)) {
                    log.debug("Attempting retryHash for paralled seen-before " + "link {}", link);
                    groupHandler.retryHash(link, false, false);
                }
            }
        }
    }
    srManager.mcastHandler.init();
}
#method_after
void processLinkAdded(Link link) {
    log.info("** LINK ADDED {}", link.toString());
    if (!isLinkValid(link)) {
        return;
    }
    // Irrespective of whether the local is a MASTER or not for this device,
    // create group handler instance and push default TTP flow rules if needed,
    // as in a multi-instance setup, instances can initiate groups for any
    // device. Also update local groupHandler stores.
    DefaultGroupHandler groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        groupHandler.portUpForLink(link);
    } else {
        Device device = srManager.deviceService.getDevice(link.src().deviceId());
        if (device != null) {
            log.warn("processLinkAdded: Link Added notification without " + "Device Added event, still handling it");
            srManager.processDeviceAdded(device);
            groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
            if (groupHandler != null) {
                groupHandler.portUpForLink(link);
            }
        }
    }
    if (srManager.deviceConfiguration == null || !srManager.deviceConfiguration.isConfigured(link.src().deviceId())) {
        updateSeenLink(link, true);
        log.warn("Source device of this link is not configured.. " + "not processing further");
        return;
    }
    /*
         // process link only if it is bidirectional
         if (!isBidirectional(link)) {
            log.debug("Link not bidirectional.. waiting for other direction " +
                      "src {} --> dst {} ", link.dst(), link.src());
            // note that if we are not processing for routing, it should at least
            // be considered a seen-link
            updateSeenLink(link, true); return;
          }
         //TODO ensure that rehash is still done correctly even if link is not processed for
         //rerouting - perhaps rehash in both directions when it ultimately becomes bidi?
         */
    log.debug("Starting optimized route-path processing for added link " + "{} --> {}", link.src(), link.dst());
    boolean seenBefore = isSeenLink(link);
    // seenLink updates will be done after route-path changes
    srManager.defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, link, null);
    if (srManager.mastershipService.isLocalMaster(link.src().deviceId())) {
        // handle edge-ports for dual-homed hosts
        updateDualHomedHostPorts(link, true);
        // for the link that has come up.
        if (groupHandler != null) {
            if (!seenBefore && isParallelLink(link)) {
                // if link seen first time, we need to ensure hash-groups have
                // all ports
                log.debug("Attempting retryHash for paralled first-time link {}", link);
                groupHandler.retryHash(link, false, true);
            } else {
                // seen before-link
                if (isParallelLink(link)) {
                    log.debug("Attempting retryHash for paralled seen-before " + "link {}", link);
                    groupHandler.retryHash(link, false, false);
                }
            }
        }
    }
}
#end_block

#method_before
void processLinkRemoved(Link link) {
    log.info("** LINK REMOVED {}", link.toString());
    if (!isLinkValid(link)) {
        return;
    }
    // when removing links, update seen links first, before doing route-path
    // changes
    updateSeenLink(link, false);
    // handle edge-ports for dual-homed hosts
    if (srManager.mastershipService.isLocalMaster(link.src().deviceId())) {
        updateDualHomedHostPorts(link, false);
    }
    // when switch comes back.
    if (link.src().elementId() instanceof DeviceId && !srManager.deviceService.isAvailable(link.src().deviceId())) {
        purgeSeenLink(link);
        return;
    }
    if (link.dst().elementId() instanceof DeviceId && !srManager.deviceService.isAvailable(link.dst().deviceId())) {
        purgeSeenLink(link);
        return;
    }
    log.debug("Starting optimized route-path processing for removed link " + "{} --> {}", link.src(), link.dst());
    srManager.defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link, null, null);
    // attempt rehashing for parallel links
    DefaultGroupHandler groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        if (srManager.mastershipService.isLocalMaster(link.src().deviceId()) && isParallelLink(link)) {
            log.debug("* retrying hash for parallel link removed:{}", link);
            groupHandler.retryHash(link, true, false);
        } else {
            log.debug("Not attempting retry-hash for link removed: {} .. {}", link, (srManager.mastershipService.isLocalMaster(link.src().deviceId())) ? "not parallel" : "not master");
        }
        // ensure local stores are updated after all rerouting or rehashing
        groupHandler.portDownForLink(link.src().port());
    } else {
        log.warn("group handler not found for dev:{} when removing link: {}", link.src().deviceId(), link);
    }
    srManager.mcastHandler.processLinkDown(link);
}
#method_after
void processLinkRemoved(Link link) {
    log.info("** LINK REMOVED {}", link.toString());
    if (!isLinkValid(link)) {
        return;
    }
    // when removing links, update seen links first, before doing route-path
    // changes
    updateSeenLink(link, false);
    // handle edge-ports for dual-homed hosts
    if (srManager.mastershipService.isLocalMaster(link.src().deviceId())) {
        updateDualHomedHostPorts(link, false);
    }
    // when switch comes back.
    if (link.src().elementId() instanceof DeviceId && !srManager.deviceService.isAvailable(link.src().deviceId())) {
        purgeSeenLink(link);
        return;
    }
    if (link.dst().elementId() instanceof DeviceId && !srManager.deviceService.isAvailable(link.dst().deviceId())) {
        purgeSeenLink(link);
        return;
    }
    log.debug("Starting optimized route-path processing for removed link " + "{} --> {}", link.src(), link.dst());
    srManager.defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(link, null, null);
    // attempt rehashing for parallel links
    DefaultGroupHandler groupHandler = srManager.groupHandlerMap.get(link.src().deviceId());
    if (groupHandler != null) {
        if (srManager.mastershipService.isLocalMaster(link.src().deviceId()) && isParallelLink(link)) {
            log.debug("* retrying hash for parallel link removed:{}", link);
            groupHandler.retryHash(link, true, false);
        } else {
            log.debug("Not attempting retry-hash for link removed: {} .. {}", link, (srManager.mastershipService.isLocalMaster(link.src().deviceId())) ? "not parallel" : "not master");
        }
        // ensure local stores are updated after all rerouting or rehashing
        groupHandler.portDownForLink(link);
    } else {
        log.warn("group handler not found for dev:{} when removing link: {}", link.src().deviceId(), link);
    }
}
#end_block

#method_before
private boolean isLinkValid(Link link) {
    if (link.type() != Link.Type.DIRECT) {
        // NOTE: A DIRECT link might be transiently marked as INDIRECT
        // if BDDP is received before LLDP. We can safely ignore that
        // until the LLDP is received and the link is marked as DIRECT.
        log.info("Ignore link {}->{}. Link type is {} instead of DIRECT.", link.src(), link.dst(), link.type());
        return false;
    }
    DeviceId srcId = link.src().deviceId();
    DeviceId dstId = link.dst().deviceId();
    if (srcId.equals(dstId)) {
        log.warn("Links between ports on the same switch are not " + "allowed .. ignoring link {}", link);
        return false;
    }
    DeviceConfiguration devConfig = srManager.deviceConfiguration;
    if (devConfig == null) {
        log.warn("Cannot check validity of link without device config");
        return true;
    }
    try {
        /*if (!devConfig.isEdgeDevice(srcId)
                    && !devConfig.isEdgeDevice(dstId)) {
                // ignore links between spines
                // XXX revisit when handling multi-stage fabrics
                log.warn("Links between spines not allowed...ignoring "
                        + "link {}", link);
                return false;
            }*/
        if (devConfig.isEdgeDevice(srcId) && devConfig.isEdgeDevice(dstId)) {
            // one pair-link
            if (devConfig.getPairDeviceId(srcId).equals(dstId) && devConfig.getPairLocalPort(srcId).equals(link.src().port()) && devConfig.getPairLocalPort(dstId).equals(link.dst().port())) {
                // found pair link - allow it
                return true;
            } else {
                log.warn("Links between leaves other than pair-links are " + "not allowed...ignoring link {}", link);
                return false;
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        // We still want to count the links in seenLinks even though there
        // is no config. So we let it return true
        log.warn("Could not check validity of link {} as subtending devices " + "are not yet configured", link);
    }
    return true;
}
#method_after
boolean isLinkValid(Link link) {
    if (link.type() != Link.Type.DIRECT) {
        // NOTE: A DIRECT link might be transiently marked as INDIRECT
        // if BDDP is received before LLDP. We can safely ignore that
        // until the LLDP is received and the link is marked as DIRECT.
        log.info("Ignore link {}->{}. Link type is {} instead of DIRECT.", link.src(), link.dst(), link.type());
        return false;
    }
    DeviceId srcId = link.src().deviceId();
    DeviceId dstId = link.dst().deviceId();
    if (srcId.equals(dstId)) {
        log.warn("Links between ports on the same switch are not " + "allowed .. ignoring link {}", link);
        return false;
    }
    DeviceConfiguration devConfig = srManager.deviceConfiguration;
    if (devConfig == null) {
        log.warn("Cannot check validity of link without device config");
        return true;
    }
    try {
        /*if (!devConfig.isEdgeDevice(srcId)
                    && !devConfig.isEdgeDevice(dstId)) {
                // ignore links between spines
                // XXX revisit when handling multi-stage fabrics
                log.warn("Links between spines not allowed...ignoring "
                        + "link {}", link);
                return false;
            }*/
        if (devConfig.isEdgeDevice(srcId) && devConfig.isEdgeDevice(dstId)) {
            // one pair-link
            if (devConfig.getPairDeviceId(srcId).equals(dstId) && devConfig.getPairLocalPort(srcId).equals(link.src().port()) && devConfig.getPairLocalPort(dstId).equals(link.dst().port())) {
                // found pair link - allow it
                return true;
            } else {
                log.warn("Links between leaves other than pair-links are " + "not allowed...ignoring link {}", link);
                return false;
            }
        }
    } catch (DeviceConfigNotFoundException e) {
        // We still want to count the links in seenLinks even though there
        // is no config. So we let it return true
        log.warn("Could not check validity of link {} as subtending devices " + "are not yet configured", link);
    }
    return true;
}
#end_block

#method_before
/**
 * Populate ECMP rules for subnets from target to destination via nexthops.
 *
 * @param targetSw Device ID of target switch in which rules will be programmed
 * @param destSw1 Device ID of final destination switch to which the rules will forward
 * @param destSw2 Device ID of paired destination switch to which the rules will forward
 *                A null deviceId indicates packets should only be sent to destSw1
 * @param nextHops Map of a set of next hops per destSw
 * @param subnets Subnets to be populated. If empty, populate all configured subnets.
 * @return true if it succeeds in populating rules
 */
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops, Set<IpPrefix> subnets) {
    boolean result;
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean dest1IsEdge;
    Ip4Address dest1RouterIpv4, dest2RouterIpv4 = null;
    Ip6Address dest1RouterIpv6, dest2RouterIpv6 = null;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        dest1IsEdge = config.isEdgeDevice(destSw1);
        dest1RouterIpv4 = config.getRouterIpv4(destSw1);
        dest1RouterIpv6 = config.getRouterIpv6(destSw1);
        if (destSw2 != null) {
            dest2RouterIpv4 = config.getRouterIpv4(destSw2);
            dest2RouterIpv6 = config.getRouterIpv6(destSw2);
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && dest1IsEdge) {
        subnets = (subnets != null && !subnets.isEmpty()) ? Sets.newHashSet(subnets) : Sets.newHashSet(config.getSubnets(destSw1));
        // XXX - Rethink this - ignoring routerIPs in all other switches
        // even edge to edge switches
        /*subnets.add(dest1RouterIpv4.toIpPrefix());
            if (dest1RouterIpv6 != null) {
                subnets.add(dest1RouterIpv6.toIpPrefix());
            }
            if (destSw2 != null && dest2RouterIpv4 != null) {
                subnets.add(dest2RouterIpv4.toIpPrefix());
                if (dest2RouterIpv6 != null) {
                    subnets.add(dest2RouterIpv6.toIpPrefix());
                }
            }*/
        log.debug(". populateEcmpRoutingRulePartial in device {} towards {} {} " + "for subnets {}", targetSw, destSw1, (destSw2 != null) ? ("& " + destSw2) : "", subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw1, destSw2, nextHops);
        if (!result) {
            return false;
        }
    }
    if (!targetIsEdge && dest1IsEdge) {
        // MPLS rules in all non-edge target devices. These rules are for
        // individual destinations, even if the dsts are part of edge-pairs.
        log.debug(". populateEcmpRoutingRulePartial in device{} towards {} for " + "all MPLS rules", targetSw, destSw1);
        result = rulePopulator.populateMplsRule(targetSw, destSw1, nextHops.get(destSw1), dest1RouterIpv4);
        if (!result) {
            return false;
        }
        if (dest1RouterIpv6 != null) {
            result = rulePopulator.populateMplsRule(targetSw, destSw1, nextHops.get(destSw1), dest1RouterIpv6);
            if (!result) {
                return false;
            }
        }
    }
    // avoid loopback IP rules in edge-devices to non-edge-devices
    return true;
}
#method_after
/**
 * Populate ECMP rules for subnets from target to destination via nexthops.
 *
 * @param targetSw Device ID of target switch in which rules will be programmed
 * @param destSw1 Device ID of final destination switch to which the rules will forward
 * @param destSw2 Device ID of paired destination switch to which the rules will forward
 *                A null deviceId indicates packets should only be sent to destSw1
 * @param nextHops Map of a set of next hops per destSw
 * @param subnets Subnets to be populated. If empty, populate all configured subnets.
 * @return true if it succeeds in populating rules
 */
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops, Set<IpPrefix> subnets) {
    boolean result;
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean dest1IsEdge;
    Ip4Address dest1RouterIpv4, dest2RouterIpv4 = null;
    Ip6Address dest1RouterIpv6, dest2RouterIpv6 = null;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        dest1IsEdge = config.isEdgeDevice(destSw1);
        dest1RouterIpv4 = config.getRouterIpv4(destSw1);
        dest1RouterIpv6 = config.getRouterIpv6(destSw1);
        if (destSw2 != null) {
            dest2RouterIpv4 = config.getRouterIpv4(destSw2);
            dest2RouterIpv6 = config.getRouterIpv6(destSw2);
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && dest1IsEdge) {
        subnets = (subnets != null && !subnets.isEmpty()) ? Sets.newHashSet(subnets) : Sets.newHashSet(config.getSubnets(destSw1));
        // XXX - Rethink this - ignoring routerIPs in all other switches
        // even edge to edge switches
        /*subnets.add(dest1RouterIpv4.toIpPrefix());
            if (dest1RouterIpv6 != null) {
                subnets.add(dest1RouterIpv6.toIpPrefix());
            }
            if (destSw2 != null && dest2RouterIpv4 != null) {
                subnets.add(dest2RouterIpv4.toIpPrefix());
                if (dest2RouterIpv6 != null) {
                    subnets.add(dest2RouterIpv6.toIpPrefix());
                }
            }*/
        log.debug(". populateEcmpRoutingRulePartial in device {} towards {} {} " + "for subnets {}", targetSw, destSw1, (destSw2 != null) ? ("& " + destSw2) : "", subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw1, destSw2, nextHops);
        if (!result) {
            return false;
        }
    }
    if (!targetIsEdge && dest1IsEdge) {
        // MPLS rules in all non-edge target devices. These rules are for
        // individual destinations, even if the dsts are part of edge-pairs.
        log.debug(". populateEcmpRoutingRulePartial in device{} towards {} for " + "all MPLS rules", targetSw, destSw1);
        result = rulePopulator.populateMplsRule(targetSw, destSw1, nextHops.get(destSw1), dest1RouterIpv4);
        if (!result) {
            return false;
        }
        if (dest1RouterIpv6 != null) {
            int v4sid = 0, v6sid = 0;
            try {
                v4sid = config.getIPv4SegmentId(destSw1);
                v6sid = config.getIPv6SegmentId(destSw1);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage());
            }
            if (v4sid != v6sid) {
                result = rulePopulator.populateMplsRule(targetSw, destSw1, nextHops.get(destSw1), dest1RouterIpv6);
                if (!result) {
                    return false;
                }
            }
        }
    }
    // avoid loopback IP rules in edge-devices to non-edge-devices
    return true;
}
#end_block

#method_before
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP payload can't be null");
    checkState(payload instanceof DHCP, "Payload is not a DHCP");
    DHCP dhcpPayload = (DHCP) payload;
    if (!configured()) {
        log.warn("Missing default DHCP relay server config. Abort packet processing");
        return;
    }
    ConnectPoint inPort = context.inPacket().receivedFrom();
    checkNotNull(dhcpPayload, "Can't find DHCP payload");
    Ethernet packet = context.inPacket().parsed();
    DHCP.MsgType incomingPacketType = dhcpPayload.getOptions().stream().filter(dhcpOption -> dhcpOption.getCode() == OptionCode_MessageType.getValue()).map(DhcpOption::getData).map(data -> DHCP.MsgType.getType(data[0])).findFirst().orElse(null);
    checkNotNull(incomingPacketType, "Can't get message type from DHCP payload {}", dhcpPayload);
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    switch(incomingPacketType) {
        case DHCPDISCOVER:
            // Add the gateway IP as virtual interface IP for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            List<InternalPacket> ethernetClientPacket = processDhcpPacketFromClient(context, packet, receivingInterfaces);
            // if (ethernetPacketDiscover != null) {
            for (InternalPacket internalPacket : ethernetClientPacket) {
                log.info("DHCPDISCOVER Forward to server");
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                // handleDhcpDiscoverAndRequest(ethernetClientPacket., dhcpPayload);
                forwardPacket(internalPacket);
            }
            break;
        case DHCPOFFER:
            // reply to dhcp client.
            Ethernet ethernetPacketOffer = processDhcpPacketFromServer(context, packet);
            if (ethernetPacketOffer != null) {
                writeResponseDhcpRecord(ethernetPacketOffer, dhcpPayload);
                sendResponseToClient(ethernetPacketOffer, dhcpPayload);
            }
            break;
        case DHCPREQUEST:
            // add the gateway ip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            List<InternalPacket> ethernetPacketRequest = processDhcpPacketFromClient(context, packet, receivingInterfaces);
            // if (ethernetPacketRequest != null) {
            for (InternalPacket internalPacket : ethernetPacketRequest) {
                log.info("DHCPREQUEST Forward to server");
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                // handleDhcpDiscoverAndRequest(ethernetPacketRequest, dhcpPayload);
                forwardPacket(internalPacket);
            }
            break;
        case DHCPDECLINE:
            break;
        case DHCPACK:
            // reply to dhcp client.
            Ethernet ethernetPacketAck = processDhcpPacketFromServer(context, packet);
            if (ethernetPacketAck != null) {
                writeResponseDhcpRecord(ethernetPacketAck, dhcpPayload);
                handleDhcpAck(ethernetPacketAck, dhcpPayload);
                sendResponseToClient(ethernetPacketAck, dhcpPayload);
            }
            break;
        case DHCPNAK:
            break;
        case DHCPRELEASE:
            // TODO: release the ip address from client
            break;
        case DHCPINFORM:
            break;
        case DHCPFORCERENEW:
            break;
        case DHCPLEASEQUERY:
            handleLeaseQueryMsg(context, packet, dhcpPayload);
            break;
        case DHCPLEASEACTIVE:
            handleLeaseQueryActivateMsg(packet, dhcpPayload);
            break;
        case DHCPLEASEUNASSIGNED:
        case DHCPLEASEUNKNOWN:
            handleLeaseQueryUnknown(packet, dhcpPayload);
            break;
        default:
            break;
    }
}
#method_after
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP payload can't be null");
    checkState(payload instanceof DHCP, "Payload is not a DHCP");
    DHCP dhcpPayload = (DHCP) payload;
    if (!configured()) {
        log.warn("Missing default DHCP relay server config. Abort packet processing");
        return;
    }
    ConnectPoint inPort = context.inPacket().receivedFrom();
    checkNotNull(dhcpPayload, "Can't find DHCP payload");
    Ethernet packet = context.inPacket().parsed();
    DHCP.MsgType incomingPacketType = dhcpPayload.getOptions().stream().filter(dhcpOption -> dhcpOption.getCode() == OptionCode_MessageType.getValue()).map(DhcpOption::getData).map(data -> DHCP.MsgType.getType(data[0])).findFirst().orElse(null);
    checkNotNull(incomingPacketType, "Can't get message type from DHCP payload {}", dhcpPayload);
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    switch(incomingPacketType) {
        case DHCPDISCOVER:
            // Add the gateway IP as virtual interface IP for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            List<InternalPacket> ethernetClientPacket = processDhcpPacketFromClient(context, packet, receivingInterfaces);
            for (InternalPacket internalPacket : ethernetClientPacket) {
                log.debug("DHCPDISCOVER from {} Forward to server", inPort);
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                forwardPacket(internalPacket);
            }
            break;
        case DHCPOFFER:
            // reply to dhcp client.
            Ethernet ethernetPacketOffer = processDhcpPacketFromServer(context, packet);
            if (ethernetPacketOffer != null) {
                writeResponseDhcpRecord(ethernetPacketOffer, dhcpPayload);
                sendResponseToClient(ethernetPacketOffer, dhcpPayload);
            }
            break;
        case DHCPREQUEST:
            // add the gateway ip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            List<InternalPacket> ethernetPacketRequest = processDhcpPacketFromClient(context, packet, receivingInterfaces);
            for (InternalPacket internalPacket : ethernetPacketRequest) {
                log.debug("DHCPDISCOVER from {} Forward to server", inPort);
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                forwardPacket(internalPacket);
            }
            break;
        case DHCPDECLINE:
            break;
        case DHCPACK:
            // reply to dhcp client.
            Ethernet ethernetPacketAck = processDhcpPacketFromServer(context, packet);
            if (ethernetPacketAck != null) {
                writeResponseDhcpRecord(ethernetPacketAck, dhcpPayload);
                handleDhcpAck(ethernetPacketAck, dhcpPayload);
                sendResponseToClient(ethernetPacketAck, dhcpPayload);
            }
            break;
        case DHCPNAK:
            break;
        case DHCPRELEASE:
            // TODO: release the ip address from client
            break;
        case DHCPINFORM:
            break;
        case DHCPFORCERENEW:
            break;
        case DHCPLEASEQUERY:
            handleLeaseQueryMsg(context, packet, dhcpPayload);
            break;
        case DHCPLEASEACTIVE:
            handleLeaseQueryActivateMsg(packet, dhcpPayload);
            break;
        case DHCPLEASEUNASSIGNED:
        case DHCPLEASEUNKNOWN:
            handleLeaseQueryUnknown(packet, dhcpPayload);
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void handleLeaseQueryMsg(PacketContext context, Ethernet packet, DHCP dhcpPayload) {
    log.debug("LQ: Got DHCPLEASEQUERY packet!");
    MacAddress clientMacAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
    log.debug("LQ: got DHCPLEASEQUERY with MAC " + clientMacAddress.toString());
    // add the client mac (hostid) of this request to a store (the entry will be removed with
    // the reply sent to the originator)
    VlanId vlanId = VlanId.vlanId(packet.getVlanID());
    HostId hId = HostId.hostId(clientMacAddress, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(hId).orElse(null);
    if (record != null) {
        // new NH is to be taken from src mac of LQ packet
        MacAddress newNextHop = packet.getSourceMAC();
        record.nextHopTemp(newNextHop);
        record.ip4Status(dhcpPayload.getPacketType());
        record.updateLastSeen();
        // do a basic routing of the packet (this is unicast routing
        // not a relay operation like for other broadcast dhcp packets
        List<InternalPacket> ethernetPacketRequest = processLeaseQueryFromAgent(context, packet);
        // handleDhcpDiscoverAndRequest(ethernetPacketLQ, dhcpPayload);
        for (InternalPacket internalPacket : ethernetPacketRequest) {
            log.info("LeaseQueryMsg forward to server");
            forwardPacket(internalPacket);
        }
    } else {
        log.warn("LQ: Error! - DHCP relay record for that client not found - ignoring LQ!");
    }
}
#method_after
private void handleLeaseQueryMsg(PacketContext context, Ethernet packet, DHCP dhcpPayload) {
    log.debug("LQ: Got DHCPLEASEQUERY packet!");
    MacAddress clientMacAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
    log.debug("LQ: got DHCPLEASEQUERY with MAC " + clientMacAddress.toString());
    // add the client mac (hostid) of this request to a store (the entry will be removed with
    // the reply sent to the originator)
    VlanId vlanId = VlanId.vlanId(packet.getVlanID());
    HostId hId = HostId.hostId(clientMacAddress, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(hId).orElse(null);
    if (record != null) {
        // new NH is to be taken from src mac of LQ packet
        MacAddress newNextHop = packet.getSourceMAC();
        record.nextHopTemp(newNextHop);
        record.ip4Status(dhcpPayload.getPacketType());
        record.updateLastSeen();
        // do a basic routing of the packet (this is unicast routing
        // not a relay operation like for other broadcast dhcp packets
        List<InternalPacket> ethernetPacketRequest = processLeaseQueryFromAgent(context, packet);
        // and forward to server
        for (InternalPacket internalPacket : ethernetPacketRequest) {
            log.debug("LeaseQueryMsg forward to server");
            forwardPacket(internalPacket);
        }
    } else {
        log.warn("LQ: Error! - DHCP relay record for that client not found - ignoring LQ!");
    }
}
#end_block

#method_before
private List<InternalPacket> processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip4Address relayAgentIp = null;
    relayAgentIp = dhcp4HandlerUtil.getRelayAgentIPv4Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv4 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    log.info("Multi DHCP V4 processDhcpPacketFromClient");
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return null;
    }
    boolean isDirectlyConnected = directlyConnected(dhcpPacket);
    boolean directConnFlag = directlyConnected(dhcpPacket);
    // Multi DHCP Start
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(ethernetPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> dhcp4HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        etherReply = (Ethernet) ethernetPacket.clone();
        ipv4Packet = (IPv4) etherReply.getPayload();
        udpPacket = (UDP) ipv4Packet.getPayload();
        dhcpPacket = (DHCP) udpPacket.getPayload();
        if (!checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
        MacAddress macFacingServer = serverInterface.mac();
        log.info("Interfacing server {} Mac : {} ", ipFacingServer, macFacingServer);
        if (ipFacingServer == null || macFacingServer == null) {
            log.warn("No IP address for server Interface {}", serverInterface);
            // return null;
            continue;
        }
        etherReply.setSourceMACAddress(macFacingServer);
        // set default info and replace with indirect if available later on.
        if (newServerInfo.getDhcpConnectMac().isPresent()) {
            etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
        }
        if (newServerInfo.getDhcpConnectVlan().isPresent()) {
            etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
        }
        ipv4Packet.setSourceAddress(ipFacingServer.toInt());
        ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
        log.info("Directly connected {}", isDirectlyConnected);
        log.info("Dhcp Server IP: {}", newServerInfo.getDhcpServerIp4().get());
        if (isDirectlyConnected) {
            log.info("**Default****Dhcp Server IP: {}", newServerInfo.getDhcpServerIp4().get());
            if (newServerInfo.getDhcpConnectMac().isPresent()) {
                etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
            }
            if (newServerInfo.getDhcpConnectVlan().isPresent()) {
                etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
            }
            ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
            ConnectPoint inPort = context.inPacket().receivedFrom();
            VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
            // add connected in port and vlan
            CircuitId cid = new CircuitId(inPort.toString(), vlanId);
            byte[] circuitId = cid.serialize();
            DhcpOption circuitIdSubOpt = new DhcpOption();
            circuitIdSubOpt.setCode(CIRCUIT_ID.getValue()).setLength((byte) circuitId.length).setData(circuitId);
            DhcpRelayAgentOption newRelayAgentOpt = new DhcpRelayAgentOption();
            newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
            newRelayAgentOpt.addSubOption(circuitIdSubOpt);
            // Removes END option first
            List<DhcpOption> options = dhcpPacket.getOptions().stream().filter(opt -> opt.getCode() != OptionCode_END.getValue()).collect(Collectors.toList());
            // push relay agent option
            options.add(newRelayAgentOpt);
            // make sure option 255(End) is the last option
            DhcpOption endOption = new DhcpOption();
            endOption.setCode(OptionCode_END.getValue());
            options.add(endOption);
            dhcpPacket.setOptions(options);
            relayAgentIp = serverInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
            // Sets relay agent IP
            int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
            dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            log.info("In Default, Relay Agent IP {}", effectiveRelayAgentIp);
        } else {
            if (!newServerInfo.getDhcpServerIp4().isPresent()) {
            // do nothing
            } else if (!newServerInfo.getDhcpConnectMac().isPresent()) {
                continue;
            } else {
                relayAgentIp = newServerInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
                // Sets relay agent IP
                int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
                dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            }
        }
        // Remove broadcast flag
        dhcpPacket.setFlags((short) 0);
        udpPacket.setPayload(dhcpPacket);
        // As a DHCP relay, the source port should be server port( instead
        // of client port.
        udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
        udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
        ipv4Packet.setPayload(udpPacket);
        ipv4Packet.setTtl((byte) 64);
        etherReply.setPayload(ipv4Packet);
        InternalPacket internalPacket = new Dhcp4HandlerUtil().new InternalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    return internalPackets;
}
#method_after
private List<InternalPacket> processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket, Set<Interface> clientInterfaces) {
    ConnectPoint receivedFrom = context.inPacket().receivedFrom();
    DeviceId receivedFromDevice = receivedFrom.deviceId();
    Ip4Address relayAgentIp = null;
    relayAgentIp = dhcp4HandlerUtil.getRelayAgentIPv4Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv4 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    log.debug("Multi DHCP V4 processDhcpPacketFromClient on port {}", clientInterfaces.iterator().next().connectPoint());
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return null;
    }
    boolean isDirectlyConnected = directlyConnected(dhcpPacket);
    boolean directConnFlag = directlyConnected(dhcpPacket);
    // Multi DHCP Start
    ConnectPoint clientConnectionPoint = context.inPacket().receivedFrom();
    VlanId vlanIdInUse = VlanId.vlanId(ethernetPacket.getVlanID());
    Interface clientInterface = interfaceService.getInterfacesByPort(clientConnectionPoint).stream().filter(iface -> dhcp4HandlerUtil.interfaceContainsVlan(iface, vlanIdInUse)).findFirst().orElse(null);
    List<InternalPacket> internalPackets = new ArrayList<>();
    List<DhcpServerInfo> serverInfoList = findValidServerInfo(directConnFlag);
    List<DhcpServerInfo> copyServerInfoList = new ArrayList<DhcpServerInfo>(serverInfoList);
    for (DhcpServerInfo serverInfo : copyServerInfoList) {
        etherReply = (Ethernet) ethernetPacket.clone();
        ipv4Packet = (IPv4) etherReply.getPayload();
        udpPacket = (UDP) ipv4Packet.getPayload();
        dhcpPacket = (DHCP) udpPacket.getPayload();
        if (!checkDhcpServerConnPt(directConnFlag, serverInfo)) {
            log.warn("Can't get server connect point, ignore");
            continue;
        }
        DhcpServerInfo newServerInfo = getHostInfoForServerInfo(serverInfo, serverInfoList);
        if (newServerInfo == null) {
            log.warn("Can't get server interface with host info resolved, ignore");
            continue;
        }
        Interface serverInterface = getServerInterface(newServerInfo);
        if (serverInterface == null) {
            log.warn("Can't get server interface, ignore");
            continue;
        }
        Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
        MacAddress macFacingServer = serverInterface.mac();
        log.debug("Interfacing server {} Mac : {} ", ipFacingServer, macFacingServer);
        if (ipFacingServer == null || macFacingServer == null) {
            log.warn("No IP address for server Interface {}", serverInterface);
            // return null;
            continue;
        }
        etherReply.setSourceMACAddress(macFacingServer);
        // set default info and replace with indirect if available later on.
        if (newServerInfo.getDhcpConnectMac().isPresent()) {
            etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
        }
        if (newServerInfo.getDhcpConnectVlan().isPresent()) {
            etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
        }
        ipv4Packet.setSourceAddress(ipFacingServer.toInt());
        ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
        log.info("Directly connected {}", isDirectlyConnected);
        log.info("Dhcp Server IP: {}", newServerInfo.getDhcpServerIp4().get());
        if (isDirectlyConnected) {
            log.info("**Default****Dhcp Server IP: {}", newServerInfo.getDhcpServerIp4().get());
            if (newServerInfo.getDhcpConnectMac().isPresent()) {
                etherReply.setDestinationMACAddress(newServerInfo.getDhcpConnectMac().get());
            }
            if (newServerInfo.getDhcpConnectVlan().isPresent()) {
                etherReply.setVlanID(newServerInfo.getDhcpConnectVlan().get().toShort());
            }
            ipv4Packet.setDestinationAddress(newServerInfo.getDhcpServerIp4().get().toInt());
            ConnectPoint inPort = context.inPacket().receivedFrom();
            VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
            // add connected in port and vlan
            CircuitId cid = new CircuitId(inPort.toString(), vlanId);
            byte[] circuitId = cid.serialize();
            DhcpOption circuitIdSubOpt = new DhcpOption();
            circuitIdSubOpt.setCode(CIRCUIT_ID.getValue()).setLength((byte) circuitId.length).setData(circuitId);
            DhcpRelayAgentOption newRelayAgentOpt = new DhcpRelayAgentOption();
            newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
            newRelayAgentOpt.addSubOption(circuitIdSubOpt);
            // Removes END option first
            List<DhcpOption> options = dhcpPacket.getOptions().stream().filter(opt -> opt.getCode() != OptionCode_END.getValue()).collect(Collectors.toList());
            // push relay agent option
            options.add(newRelayAgentOpt);
            // make sure option 255(End) is the last option
            DhcpOption endOption = new DhcpOption();
            endOption.setCode(OptionCode_END.getValue());
            options.add(endOption);
            dhcpPacket.setOptions(options);
            relayAgentIp = serverInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
            // Sets relay agent IP
            int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
            dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            log.info("In Default, Relay Agent IP {}", effectiveRelayAgentIp);
        } else {
            if (!newServerInfo.getDhcpServerIp4().isPresent()) {
            // do nothing
            } else if (!newServerInfo.getDhcpConnectMac().isPresent()) {
                continue;
            } else {
                relayAgentIp = newServerInfo.getRelayAgentIp4(receivedFromDevice).orElse(null);
                // Sets relay agent IP
                int effectiveRelayAgentIp = relayAgentIp != null ? relayAgentIp.toInt() : clientInterfaceIp.toInt();
                dhcpPacket.setGatewayIPAddress(effectiveRelayAgentIp);
            }
        }
        // Remove broadcast flag
        dhcpPacket.setFlags((short) 0);
        udpPacket.setPayload(dhcpPacket);
        // As a DHCP relay, the source port should be server port( instead
        // of client port.
        udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
        udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
        ipv4Packet.setPayload(udpPacket);
        ipv4Packet.setTtl((byte) 64);
        etherReply.setPayload(ipv4Packet);
        InternalPacket internalPacket = new Dhcp4HandlerUtil().new InternalPacket(etherReply, serverInfo.getDhcpServerConnectPoint().get());
        internalPackets.add(internalPacket);
    }
    return internalPackets;
}
#end_block

#method_before
private Ethernet removeRelayAgentOption(Ethernet ethPacket) {
    Ethernet ethernet = (Ethernet) ethPacket.clone();
    IPv4 ipv4 = (IPv4) ethernet.getPayload();
    UDP udp = (UDP) ipv4.getPayload();
    DHCP dhcpPayload = (DHCP) udp.getPayload();
    // removes relay agent information option
    List<DhcpOption> options = dhcpPayload.getOptions();
    options = options.stream().filter(option -> option.getCode() != OptionCode_CircuitID.getValue()).collect(Collectors.toList());
    dhcpPayload.setOptions(options);
    dhcpPayload.setGatewayIPAddress(0);
    udp.setPayload(dhcpPayload);
    ipv4.setPayload(udp);
    ethernet.setPayload(ipv4);
    return ethernet;
}
#method_after
private Ethernet removeRelayAgentOption(Ethernet ethPacket) {
    Ethernet ethernet = (Ethernet) ethPacket.duplicate();
    IPv4 ipv4 = (IPv4) ethernet.getPayload();
    UDP udp = (UDP) ipv4.getPayload();
    DHCP dhcpPayload = (DHCP) udp.getPayload();
    // removes relay agent information option
    List<DhcpOption> options = dhcpPayload.getOptions();
    options = options.stream().filter(option -> option.getCode() != OptionCode_CircuitID.getValue()).collect(Collectors.toList());
    dhcpPayload.setOptions(options);
    dhcpPayload.setGatewayIPAddress(0);
    udp.setPayload(dhcpPayload);
    ipv4.setPayload(udp);
    ethernet.setPayload(ipv4);
    return ethernet;
}
#end_block

#method_before
private void forwardPacket(InternalPacket packet) {
    // send Packetout to dhcp server connectpoint.
    if (packet.destLocation != null) {
        TrafficTreatment t = DefaultTrafficTreatment.builder().setOutput(packet.destLocation.port()).build();
        OutboundPacket o = new DefaultOutboundPacket(packet.destLocation.deviceId(), t, ByteBuffer.wrap(packet.packet.serialize()));
        if (log.isTraceEnabled()) {
            log.trace("Relaying packet to destination {}", packet.destLocation);
        }
        log.info("DHCP RELAY: packetService.emit(o) to port {}", packet.destLocation);
        packetService.emit(o);
    }
// if
}
#method_after
private void forwardPacket(InternalPacket packet) {
    // send Packetout to dhcp server connectpoint.
    if (packet.destLocation != null) {
        TrafficTreatment t = DefaultTrafficTreatment.builder().setOutput(packet.destLocation.port()).build();
        OutboundPacket o = new DefaultOutboundPacket(packet.destLocation.deviceId(), t, ByteBuffer.wrap(packet.packet.serialize()));
        if (log.isTraceEnabled()) {
            log.trace("Relaying packet to destination {}", packet.destLocation);
        }
        log.info("DHCP RELAY: packetService.emit(o) to port {}", packet.destLocation);
        packetService.emit(o);
    }
}
#end_block

#method_before
// Returns the first v4 interface ip out of a set of interfaces or null.
public Ip4Address getRelayAgentIPv4Address(Set<Interface> intfs) {
    for (Interface intf : intfs) {
        for (InterfaceIpAddress ip : intf.ipAddressesList()) {
            Ip4Address relayAgentIp = ip.ipAddress().getIp4Address();
            if (relayAgentIp != null) {
                return relayAgentIp;
            }
        }
    }
    return null;
}
#method_after
public Ip4Address getRelayAgentIPv4Address(Set<Interface> intfs) {
    for (Interface intf : intfs) {
        for (InterfaceIpAddress ip : intf.ipAddressesList()) {
            Ip4Address relayAgentIp = ip.ipAddress().getIp4Address();
            if (relayAgentIp != null) {
                return relayAgentIp;
            }
        }
    }
    return null;
}
#end_block

#method_before
private void updateInterface(InterfaceConfig conf, InterfaceConfig prevConf) {
    try {
        Set<Interface> intfs = conf.getInterfaces();
        Set<Interface> prevIntfs = prevConf.getInterfaces();
        // Now we only handle one interface config at each port.
        if (intfs.size() != 1 || prevIntfs.size() != 1) {
            log.warn("Interface update aborted - one at a time is allowed, " + "but {} / {}(prev) received.", intfs.size(), prevIntfs.size());
            return;
        }
        Interface intf = intfs.stream().findFirst().get();
        Interface prevIntf = prevIntfs.stream().findFirst().get();
        DeviceId deviceId = intf.connectPoint().deviceId();
        PortNumber portNum = intf.connectPoint().port();
        if (!mastershipService.isLocalMaster(deviceId)) {
            log.debug("CONFIG_UPDATED event for interfaces should be " + "handled by master node for device {}", deviceId);
            return;
        }
        removeSubnetConfig(prevIntf.connectPoint(), Sets.difference(new HashSet<>(prevIntf.ipAddressesList()), new HashSet<>(intf.ipAddressesList())));
        if (prevIntf.vlanNative() != VlanId.NONE && !intf.vlanNative().equals(prevIntf.vlanNative())) {
            // RemoveVlanNative
            updateVlanConfigInternal(deviceId, portNum, prevIntf.vlanNative(), true, false);
        }
        if (!prevIntf.vlanTagged().isEmpty() && !intf.vlanTagged().equals(prevIntf.vlanTagged())) {
            // RemoveVlanTagged
            prevIntf.vlanTagged().stream().filter(i -> !intf.vlanTagged().contains(i)).forEach(vlanId -> updateVlanConfigInternal(deviceId, portNum, vlanId, false, false));
        }
        if (prevIntf.vlanUntagged() != VlanId.NONE && !intf.vlanUntagged().equals(prevIntf.vlanUntagged())) {
            // RemoveVlanUntagged
            updateVlanConfigInternal(deviceId, portNum, prevIntf.vlanUntagged(), true, false);
        }
        if (intf.vlanNative() != VlanId.NONE && !prevIntf.vlanNative().equals(intf.vlanNative())) {
            // AddVlanNative
            updateVlanConfigInternal(deviceId, portNum, intf.vlanNative(), true, true);
        }
        if (!intf.vlanTagged().isEmpty() && !intf.vlanTagged().equals(prevIntf.vlanTagged())) {
            // AddVlanTagged
            intf.vlanTagged().stream().filter(i -> !prevIntf.vlanTagged().contains(i)).forEach(vlanId -> updateVlanConfigInternal(deviceId, portNum, vlanId, false, true));
        }
        if (intf.vlanUntagged() != VlanId.NONE && !prevIntf.vlanUntagged().equals(intf.vlanUntagged())) {
            // AddVlanUntagged
            updateVlanConfigInternal(deviceId, portNum, intf.vlanUntagged(), true, true);
        }
        addSubnetConfig(prevIntf.connectPoint(), Sets.difference(new HashSet<>(intf.ipAddressesList()), new HashSet<>(prevIntf.ipAddressesList())));
    } catch (ConfigException e) {
        log.error("Error in configuration");
    }
}
#method_after
private void updateInterface(InterfaceConfig conf, InterfaceConfig prevConf) {
    try {
        Set<Interface> intfs = conf.getInterfaces();
        Set<Interface> prevIntfs = prevConf.getInterfaces();
        // Now we only handle one interface config at each port.
        if (intfs.size() != 1 || prevIntfs.size() != 1) {
            log.warn("Interface update aborted - one at a time is allowed, " + "but {} / {}(prev) received.", intfs.size(), prevIntfs.size());
            return;
        }
        Interface intf = intfs.stream().findFirst().get();
        Interface prevIntf = prevIntfs.stream().findFirst().get();
        DeviceId deviceId = intf.connectPoint().deviceId();
        PortNumber portNum = intf.connectPoint().port();
        if (!mastershipService.isLocalMaster(deviceId)) {
            log.debug("CONFIG_UPDATED event for interfaces should be " + "handled by master node for device {}", deviceId);
            return;
        }
        removeSubnetConfig(prevIntf.connectPoint(), Sets.difference(new HashSet<>(prevIntf.ipAddressesList()), new HashSet<>(intf.ipAddressesList())));
        if (!prevIntf.vlanNative().equals(VlanId.NONE) && !prevIntf.vlanNative().equals(intf.vlanUntagged()) && !prevIntf.vlanNative().equals(intf.vlanNative())) {
            if (intf.vlanTagged().contains(prevIntf.vlanNative())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, prevIntf.vlanNative(), false);
            } else {
                // RemoveVlanNative
                updateVlanConfigInternal(deviceId, portNum, prevIntf.vlanNative(), true, false);
            }
        }
        if (!prevIntf.vlanUntagged().equals(VlanId.NONE) && !prevIntf.vlanUntagged().equals(intf.vlanUntagged()) && !prevIntf.vlanUntagged().equals(intf.vlanNative())) {
            if (intf.vlanTagged().contains(prevIntf.vlanUntagged())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, prevIntf.vlanUntagged(), false);
            } else {
                // RemoveVlanUntagged
                updateVlanConfigInternal(deviceId, portNum, prevIntf.vlanUntagged(), true, false);
            }
        }
        if (!prevIntf.vlanTagged().isEmpty() && !intf.vlanTagged().equals(prevIntf.vlanTagged())) {
            // RemoveVlanTagged
            Sets.difference(prevIntf.vlanTagged(), intf.vlanTagged()).stream().filter(i -> !intf.vlanUntagged().equals(i)).filter(i -> !intf.vlanNative().equals(i)).forEach(vlanId -> updateVlanConfigInternal(deviceId, portNum, vlanId, false, false));
        }
        if (!intf.vlanNative().equals(VlanId.NONE) && !prevIntf.vlanNative().equals(intf.vlanNative()) && !prevIntf.vlanUntagged().equals(intf.vlanNative())) {
            if (prevIntf.vlanTagged().contains(intf.vlanNative())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, intf.vlanNative(), true);
            } else {
                // AddVlanNative
                updateVlanConfigInternal(deviceId, portNum, intf.vlanNative(), true, true);
            }
        }
        if (!intf.vlanTagged().isEmpty() && !intf.vlanTagged().equals(prevIntf.vlanTagged())) {
            // AddVlanTagged
            Sets.difference(intf.vlanTagged(), prevIntf.vlanTagged()).stream().filter(i -> !prevIntf.vlanUntagged().equals(i)).filter(i -> !prevIntf.vlanNative().equals(i)).forEach(vlanId -> updateVlanConfigInternal(deviceId, portNum, vlanId, false, true));
        }
        if (!intf.vlanUntagged().equals(VlanId.NONE) && !prevIntf.vlanUntagged().equals(intf.vlanUntagged()) && !prevIntf.vlanNative().equals(intf.vlanUntagged())) {
            if (prevIntf.vlanTagged().contains(intf.vlanUntagged())) {
                // Update filtering objective and L2IG group bucket
                updatePortVlanTreatment(deviceId, portNum, intf.vlanUntagged(), true);
            } else {
                // AddVlanUntagged
                updateVlanConfigInternal(deviceId, portNum, intf.vlanUntagged(), true, true);
            }
        }
        addSubnetConfig(prevIntf.connectPoint(), Sets.difference(new HashSet<>(intf.ipAddressesList()), new HashSet<>(prevIntf.ipAddressesList())));
    } catch (ConfigException e) {
        log.error("Error in configuration");
    }
}
#end_block

#method_before
private void updateVlanConfigInternal(DeviceId deviceId, PortNumber portNum, VlanId vlanId, boolean pushVlan, boolean install) {
    DefaultGroupHandler grpHandler = getGroupHandler(deviceId);
    if (grpHandler == null) {
        log.warn("Failed to retrieve group handler for device {}", deviceId);
        return;
    }
    // Update filtering objective for a single port
    routingRulePopulator.updateSinglePortFilters(deviceId, portNum, pushVlan, vlanId, install);
    // Update filtering objective for multicast ingress port
    mcastHandler.updateFilterToDevice(deviceId, portNum, vlanId, install);
    int nextId = getVlanNextObjectiveId(deviceId, vlanId);
    if (nextId != -1 && !install) {
        // Update next objective for a single port as an output port
        // Remove a single port from L2FG
        grpHandler.updateGroupFromVlanConfiguration(portNum, Collections.singleton(vlanId), nextId, install);
        // Remove L2 Bridging rule and L3 Unicast rule to the host
        hostHandler.processIntfVlanUpdatedEvent(deviceId, portNum, vlanId, pushVlan, install);
        // only if there is no port configured on that VLAN ID
        if (!getVlanPortMap(deviceId).containsKey(vlanId)) {
            // Remove broadcast forwarding rule for the VLAN
            routingRulePopulator.updateSubnetBroadcastRule(deviceId, vlanId, install);
            // Remove L2FG for VLAN
            grpHandler.removeBcastGroupFromVlan(deviceId, portNum, vlanId, pushVlan);
        } else {
            // Remove L2IG of the port
            grpHandler.removePortNextObjective(deviceId, portNum, vlanId, pushVlan);
        }
    } else if (install) {
        if (nextId != -1) {
            // Add a single port to L2FG
            grpHandler.updateGroupFromVlanConfiguration(portNum, Collections.singleton(vlanId), nextId, install);
        } else {
            // Create L2FG for VLAN
            grpHandler.createBcastGroupFromVlan(vlanId, Collections.singleton(portNum));
            routingRulePopulator.updateSubnetBroadcastRule(deviceId, vlanId, install);
        }
        hostHandler.processIntfVlanUpdatedEvent(deviceId, portNum, vlanId, pushVlan, install);
    } else {
        log.warn("Failed to retrieve next objective for vlan {} in device {}:{}", vlanId, deviceId, portNum);
    }
}
#method_after
private void updateVlanConfigInternal(DeviceId deviceId, PortNumber portNum, VlanId vlanId, boolean pushVlan, boolean install) {
    DefaultGroupHandler grpHandler = getGroupHandler(deviceId);
    if (grpHandler == null) {
        log.warn("Failed to retrieve group handler for device {}", deviceId);
        return;
    }
    // Update filtering objective for a single port
    routingRulePopulator.updateSinglePortFilters(deviceId, portNum, pushVlan, vlanId, install);
    // Update filtering objective for multicast ingress port
    mcastHandler.updateFilterToDevice(deviceId, portNum, vlanId, install);
    int nextId = getVlanNextObjectiveId(deviceId, vlanId);
    if (nextId != -1 && !install) {
        // Update next objective for a single port as an output port
        // Remove a single port from L2FG
        grpHandler.updateGroupFromVlanConfiguration(vlanId, portNum, nextId, install);
        // Remove L2 Bridging rule and L3 Unicast rule to the host
        hostHandler.processIntfVlanUpdatedEvent(deviceId, portNum, vlanId, pushVlan, install);
        // only if there is no port configured on that VLAN ID
        if (!getVlanPortMap(deviceId).containsKey(vlanId)) {
            // Remove broadcast forwarding rule for the VLAN
            routingRulePopulator.updateSubnetBroadcastRule(deviceId, vlanId, install);
            // Remove L2FG for VLAN
            grpHandler.removeBcastGroupFromVlan(deviceId, portNum, vlanId, pushVlan);
        } else {
            // Remove L2IG of the port
            grpHandler.removePortNextObjective(deviceId, portNum, vlanId, pushVlan);
        }
    } else if (install) {
        if (nextId != -1) {
            // Add a single port to L2FG
            grpHandler.updateGroupFromVlanConfiguration(vlanId, portNum, nextId, install);
        } else {
            // Create L2FG for VLAN
            grpHandler.createBcastGroupFromVlan(vlanId, Collections.singleton(portNum));
            routingRulePopulator.updateSubnetBroadcastRule(deviceId, vlanId, install);
        }
        hostHandler.processIntfVlanUpdatedEvent(deviceId, portNum, vlanId, pushVlan, install);
    } else {
        log.warn("Failed to retrieve next objective for vlan {} in device {}:{}", vlanId, deviceId, portNum);
    }
}
#end_block

#method_before
@Override
protected void execute() {
    TroubleshootService service = get(TroubleshootService.class);
    EtherType type = EtherType.valueOf(ethType.toUpperCase());
    print("Tracing between all %s hosts", ethType);
    if (!type.equals(EtherType.IPV4) && !type.equals(EtherType.IPV6)) {
        print("Command only support IPv4 or IPv6");
    } else {
        print("--------------------------------------------------------------------------");
        // Obtain the list of traces
        List<StaticPacketTrace> traces = service.pingAll(type);
        if (traces.size() == 0) {
            print("No traces were obtained, please check system configuration");
        }
        traces.forEach(trace -> {
            if (trace.getInitialPacket() != null) {
                if (verbosity1) {
                    printVerbose(trace);
                } else {
                    printResultOnly(trace);
                }
            } else {
                if (trace.getEndpointHosts().isPresent()) {
                    Host source = trace.getEndpointHosts().get().getLeft();
                    Host destination = trace.getEndpointHosts().get().getRight();
                    print("Source %s --> Destination %s", source.id(), destination.id());
                }
                print("Error in obtaining trace: %s", trace.resultMessage());
            }
            print("--------------------------------------------------------------------------");
        });
    }
}
#method_after
@Override
protected void execute() {
    TroubleshootService service = get(TroubleshootService.class);
    EtherType type = EtherType.valueOf(ethType.toUpperCase());
    print("Tracing between all %s hosts", ethType);
    if (!type.equals(EtherType.IPV4) && !type.equals(EtherType.IPV6)) {
        print("Command only support IPv4 or IPv6");
    } else {
        print("%s", StringUtils.leftPad("", 100, '-'));
        // Obtain the list of traces
        List<StaticPacketTrace> traces = service.pingAll(type);
        if (traces.size() == 0) {
            print("No traces were obtained, please check system configuration");
        }
        boolean ipv4 = type.equals(EtherType.IPV4);
        traces.forEach(trace -> {
            if (trace.getInitialPacket() != null) {
                if (verbosity1) {
                    printVerbose(trace);
                } else {
                    printResultOnly(trace, ipv4);
                }
            } else {
                if (trace.getEndpointHosts().isPresent()) {
                    Host source = trace.getEndpointHosts().get().getLeft();
                    Host destination = trace.getEndpointHosts().get().getRight();
                    print("Source %s --> Destination %s", source.id(), destination.id());
                }
                print("Error in obtaining trace: %s", trace.resultMessage());
            }
            print("%s", StringUtils.leftPad("", 100, '-'));
        });
    }
}
#end_block

#method_before
private void printResultOnly(StaticPacketTrace trace) {
    if (trace.getEndpointHosts().isPresent()) {
        Host source = trace.getEndpointHosts().get().getLeft();
        Host destination = trace.getEndpointHosts().get().getRight();
        print("Source %s --> Destination %s", source.id(), destination.id());
        print("%s", trace.resultMessage());
    } else {
        print("Can't gather host information from trace");
        print("%s", trace.resultMessage());
    }
}
#method_after
private void printResultOnly(StaticPacketTrace trace, boolean ipv4) {
    if (trace.getEndpointHosts().isPresent()) {
        Host source = trace.getEndpointHosts().get().getLeft();
        Host destination = trace.getEndpointHosts().get().getRight();
        IpAddress srcIP;
        IpAddress dstIP;
        if (ipv4 && trace.getInitialPacket().getCriterion(Criterion.Type.IPV4_SRC) != null) {
            srcIP = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV4_SRC)).ip().address();
            dstIP = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV4_DST)).ip().address();
            print("Source %s (%s) --> Destination %s (%s)", source.id(), srcIP, destination.id(), dstIP);
        } else if (trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_SRC) != null) {
            srcIP = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_SRC)).ip().address();
            dstIP = ((IPCriterion) trace.getInitialPacket().getCriterion(Criterion.Type.IPV6_DST)).ip().address();
            print("Source %s (%s) --> Destination %s (%s)", source.id(), srcIP, destination.id(), dstIP);
        } else {
            print("Source %s --> Destination %s", source.id(), destination.id());
        }
        print("%s", trace.resultMessage());
    } else {
        print("Can't gather host information from trace");
        print("%s", trace.resultMessage());
    }
}
#end_block

#method_before
@Override
public List<StaticPacketTrace> pingAll(EtherType type) {
    ImmutableList.Builder<StaticPacketTrace> tracesBuilder = ImmutableList.builder();
    hostService.getHosts().forEach(host -> {
        List<IpAddress> ipAddresses = getIpAddresses(host, type, false);
        if (ipAddresses.size() > 0) {
            // check if the host has only local IPs of that ETH type
            boolean onlyLocalSrc = ipAddresses.size() == 1 && ipAddresses.get(0).isLinkLocal();
            hostService.getHosts().forEach(hostToPing -> {
                List<IpAddress> ipAddressesToPing = getIpAddresses(hostToPing, type, false);
                // check if the other host has only local IPs of that ETH type
                boolean onlyLocalDst = ipAddressesToPing.size() == 1 && ipAddressesToPing.get(0).isLinkLocal();
                // trace is done only if they are both local or not local and if they are not the same host.
                if (onlyLocalSrc == onlyLocalDst && ipAddressesToPing.size() > 0 && !host.equals(hostToPing)) {
                    tracesBuilder.add(trace(host.id(), hostToPing.id(), type));
                }
            });
        }
    });
    return tracesBuilder.build();
}
#method_after
@Override
public List<StaticPacketTrace> pingAll(EtherType type) {
    ImmutableList.Builder<StaticPacketTrace> tracesBuilder = ImmutableList.builder();
    hostService.getHosts().forEach(host -> {
        List<IpAddress> ipAddresses = getIpAddresses(host, type, false);
        if (ipAddresses.size() > 0) {
            // check if the host has only local IPs of that ETH type
            boolean onlyLocalSrc = ipAddresses.size() == 1 && ipAddresses.get(0).isLinkLocal();
            hostService.getHosts().forEach(hostToPing -> {
                List<IpAddress> ipAddressesToPing = getIpAddresses(hostToPing, type, false);
                // check if the other host has only local IPs of that ETH type
                boolean onlyLocalDst = ipAddressesToPing.size() == 1 && ipAddressesToPing.get(0).isLinkLocal();
                boolean sameLocation = Sets.intersection(host.locations(), hostToPing.locations()).size() > 0;
                // or not local and if they are not the same host.
                if (((sameLocation && onlyLocalDst && onlyLocalSrc) || (!onlyLocalSrc && !onlyLocalDst && ipAddressesToPing.size() > 0)) && !host.equals(hostToPing)) {
                    tracesBuilder.add(trace(host.id(), hostToPing.id(), type));
                }
            });
        }
    });
    return tracesBuilder.build();
}
#end_block

#method_before
private void getGroupsFromInstructions(StaticPacketTrace trace, List<Group> groupsForDevice, List<Instruction> instructions, DeviceId deviceId, Builder builder, List<PortNumber> outputPorts, ConnectPoint in) {
    List<Instruction> groupInstructionlist = new ArrayList<>();
    for (Instruction instruction : instructions) {
        log.debug("Considering Instruction {}", instruction);
        // to the possible outputs for this packet
        if (!instruction.type().equals(Instruction.Type.GROUP)) {
            // to the possible outputs for this packet
            if (instruction.type().equals(Instruction.Type.OUTPUT)) {
                buildOutputFromDevice(trace, in, builder, outputPorts, (OutputInstruction) instruction, ImmutableList.copyOf(groupsForDevice));
                // clearing the groups because we start from the top.
                groupsForDevice.clear();
            } else {
                builder = translateInstruction(builder, instruction);
            }
        } else {
            // if the instuction is pointing to a group we need to get the group
            groupInstructionlist.add(instruction);
        }
    }
    // handle all the internal instructions pointing to a group.
    for (Instruction instr : groupInstructionlist) {
        GroupInstruction groupInstruction = (GroupInstruction) instr;
        Group group = Lists.newArrayList(groupService.getGroups(deviceId)).stream().filter(groupInternal -> {
            return groupInternal.id().equals(groupInstruction.groupId());
        }).findAny().orElse(null);
        if (group == null) {
            trace.addResultMessage("Null group for Instruction " + instr);
            break;
        }
        // Cycle in each of the group's buckets and add them to the groups for this Device.
        for (GroupBucket bucket : group.buckets().buckets()) {
            // add the group to the traversed groups
            if (!groupsForDevice.contains(group)) {
                groupsForDevice.add(group);
            }
            getGroupsFromInstructions(trace, groupsForDevice, bucket.treatment().allInstructions(), deviceId, builder, outputPorts, in);
        }
    }
}
#method_after
private void getGroupsFromInstructions(StaticPacketTrace trace, List<Group> groupsForDevice, List<Instruction> instructions, DeviceId deviceId, Builder builder, List<PortNumber> outputPorts, ConnectPoint in) {
    List<Instruction> groupInstructionlist = new ArrayList<>();
    for (Instruction instruction : instructions) {
        log.debug("Considering Instruction {}", instruction);
        // to the possible outputs for this packet
        if (!instruction.type().equals(Instruction.Type.GROUP)) {
            // to the possible outputs for this packet
            if (instruction.type().equals(Instruction.Type.OUTPUT)) {
                buildOutputFromDevice(trace, in, builder, outputPorts, (OutputInstruction) instruction, ImmutableList.copyOf(groupsForDevice));
                // clearing the groups because we start from the top.
                groupsForDevice.clear();
            } else {
                builder = translateInstruction(builder, instruction);
            }
        } else {
            // if the instuction is pointing to a group we need to get the group
            groupInstructionlist.add(instruction);
        }
    }
    // handle all the internal instructions pointing to a group.
    for (Instruction instr : groupInstructionlist) {
        GroupInstruction groupInstruction = (GroupInstruction) instr;
        Group group = Lists.newArrayList(groupService.getGroups(deviceId)).stream().filter(groupInternal -> {
            return groupInternal.id().equals(groupInstruction.groupId());
        }).findAny().orElse(null);
        if (group == null) {
            trace.addResultMessage("Null group for Instruction " + instr);
            break;
        }
        if (group.buckets().buckets().size() == 0) {
            trace.addResultMessage("Group " + group.id() + "has no buckets");
            break;
        }
        // Cycle in each of the group's buckets and add them to the groups for this Device.
        for (GroupBucket bucket : group.buckets().buckets()) {
            // add the group to the traversed groups
            if (!groupsForDevice.contains(group)) {
                groupsForDevice.add(group);
            }
            getGroupsFromInstructions(trace, groupsForDevice, bucket.treatment().allInstructions(), deviceId, builder, outputPorts, in);
        }
    }
}
#end_block

#method_before
private void addBucketToHashGroup(NextObjective nextObjective, List<Deque<GroupKey>> allActiveKeys) {
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    List<GroupBucket> newBuckets;
    createHashBucketChains(nextObjective, allGroupKeys, unsentGroups);
    // now we can create the buckets to add to the outermost L3 ECMP group
    newBuckets = generateNextGroupBuckets(unsentGroups, SELECT);
    // retrieve the original L3 ECMP group
    Group l3ecmpGroup = retrieveTopLevelGroup(allActiveKeys, nextObjective.id());
    if (l3ecmpGroup == null) {
        fail(nextObjective, ObjectiveError.GROUPMISSING);
        return;
    }
    GroupKey l3ecmpGroupKey = l3ecmpGroup.appCookie();
    int l3ecmpGroupId = l3ecmpGroup.id().id();
    // Although GroupDescriptions are not necessary for adding buckets to
    // existing groups, we still use one in the GroupChainElem. When the latter is
    // processed, the info will be extracted for the bucketAdd call to groupService
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, SELECT, new GroupBuckets(newBuckets), l3ecmpGroupKey, l3ecmpGroupId, nextObjective.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, unsentGroups.size(), true, deviceId);
    // update new bucket-chains
    List<Deque<GroupKey>> addedKeys = new ArrayList<>();
    for (Deque<GroupKey> newBucketChain : allGroupKeys) {
        newBucketChain.addFirst(l3ecmpGroupKey);
        addedKeys.add(newBucketChain);
    }
    updatePendingNextObjective(l3ecmpGroupKey, new OfdpaNextGroup(addedKeys, nextObjective));
    log.debug("Adding to L3ECMP: device:{} gid:{} group key:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObjective.id());
    unsentGroups.forEach(groupInfo -> {
        // send the innermost group
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), l3ecmpGce);
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    });
}
#method_after
private void addBucketToHashGroup(NextObjective nextObjective, List<Deque<GroupKey>> allActiveKeys) {
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    List<GroupBucket> newBuckets;
    createHashBucketChains(nextObjective, allGroupKeys, unsentGroups);
    // now we can create the buckets to add to the outermost L3 ECMP group
    newBuckets = generateNextGroupBuckets(unsentGroups, SELECT);
    // retrieve the original L3 ECMP group
    Group l3ecmpGroup = retrieveTopLevelGroup(allActiveKeys, deviceId, groupService, nextObjective.id());
    if (l3ecmpGroup == null) {
        fail(nextObjective, ObjectiveError.GROUPMISSING);
        return;
    }
    GroupKey l3ecmpGroupKey = l3ecmpGroup.appCookie();
    int l3ecmpGroupId = l3ecmpGroup.id().id();
    // Although GroupDescriptions are not necessary for adding buckets to
    // existing groups, we still use one in the GroupChainElem. When the latter is
    // processed, the info will be extracted for the bucketAdd call to groupService
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, SELECT, new GroupBuckets(newBuckets), l3ecmpGroupKey, l3ecmpGroupId, nextObjective.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, unsentGroups.size(), true, deviceId);
    // update new bucket-chains
    List<Deque<GroupKey>> addedKeys = new ArrayList<>();
    for (Deque<GroupKey> newBucketChain : allGroupKeys) {
        newBucketChain.addFirst(l3ecmpGroupKey);
        addedKeys.add(newBucketChain);
    }
    updatePendingNextObjective(l3ecmpGroupKey, new OfdpaNextGroup(addedKeys, nextObjective));
    log.debug("Adding to L3ECMP: device:{} gid:{} group key:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObjective.id());
    unsentGroups.forEach(groupInfo -> {
        // send the innermost group
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), l3ecmpGce);
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    });
}
#end_block

#method_before
private void addBucketToL2FloodGroup(NextObjective nextObj, List<Deque<GroupKey>> allActiveKeys, List<GroupInfo> groupInfos, VlanId assignedVlan) {
    Group l2FloodGroup = retrieveTopLevelGroup(allActiveKeys, nextObj.id());
    if (l2FloodGroup == null) {
        log.warn("Can't find L2 flood group while adding bucket to it. NextObj = {}", nextObj);
        fail(nextObj, ObjectiveError.GROUPMISSING);
        return;
    }
    GroupKey l2floodGroupKey = l2FloodGroup.appCookie();
    int l2floodGroupId = l2FloodGroup.id().id();
    List<GroupBucket> newBuckets = generateNextGroupBuckets(groupInfos, ALL);
    GroupDescription l2FloodGroupDescription = new DefaultGroupDescription(deviceId, ALL, new GroupBuckets(newBuckets), l2floodGroupKey, l2floodGroupId, nextObj.appId());
    GroupChainElem l2FloodGroupChainElement = new GroupChainElem(l2FloodGroupDescription, groupInfos.size(), true, deviceId);
    // ensure assignedVlan applies to the chosen group
    VlanId floodGroupVlan = extractVlanIdFromGroupId(l2floodGroupId);
    if (!floodGroupVlan.equals(assignedVlan)) {
        log.warn("VLAN ID {} does not match Flood group {} to which bucket is " + "being added, for next:{} in dev:{}. Abort.", assignedVlan, Integer.toHexString(l2floodGroupId), nextObj.id(), deviceId);
        fail(nextObj, ObjectiveError.BADPARAMS);
        return;
    }
    List<Deque<GroupKey>> addedKeys = new ArrayList<>();
    groupInfos.forEach(groupInfo -> {
        // update original NextGroup with new bucket-chain
        Deque<GroupKey> newBucketChain = new ArrayDeque<>();
        newBucketChain.addFirst(groupInfo.nextGroupDesc().appCookie());
        newBucketChain.addFirst(l2floodGroupKey);
        addedKeys.add(newBucketChain);
        log.debug("Adding to L2FLOOD: device:{} gid:{} group key:{} nextId:{}", deviceId, Integer.toHexString(l2floodGroupId), l2floodGroupKey, nextObj.id());
        // send the innermost group
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), l2FloodGroupChainElement);
        DeviceId innerMostGroupDevice = groupInfo.innerMostGroupDesc().deviceId();
        GroupKey innerMostGroupKey = groupInfo.innerMostGroupDesc().appCookie();
        Group existsL2IGroup = groupService.getGroup(innerMostGroupDevice, innerMostGroupKey);
        if (existsL2IGroup != null) {
            // group already exist
            processPendingAddGroupsOrNextObjs(innerMostGroupKey, true);
        } else {
            groupService.addGroup(groupInfo.innerMostGroupDesc());
        }
    });
    updatePendingNextObjective(l2floodGroupKey, new OfdpaNextGroup(addedKeys, nextObj));
}
#method_after
private void addBucketToL2FloodGroup(NextObjective nextObj, List<Deque<GroupKey>> allActiveKeys, List<GroupInfo> groupInfos, VlanId assignedVlan) {
    Group l2FloodGroup = retrieveTopLevelGroup(allActiveKeys, deviceId, groupService, nextObj.id());
    if (l2FloodGroup == null) {
        log.warn("Can't find L2 flood group while adding bucket to it. NextObj = {}", nextObj);
        fail(nextObj, ObjectiveError.GROUPMISSING);
        return;
    }
    GroupKey l2floodGroupKey = l2FloodGroup.appCookie();
    int l2floodGroupId = l2FloodGroup.id().id();
    List<GroupBucket> newBuckets = generateNextGroupBuckets(groupInfos, ALL);
    GroupDescription l2FloodGroupDescription = new DefaultGroupDescription(deviceId, ALL, new GroupBuckets(newBuckets), l2floodGroupKey, l2floodGroupId, nextObj.appId());
    GroupChainElem l2FloodGroupChainElement = new GroupChainElem(l2FloodGroupDescription, groupInfos.size(), true, deviceId);
    // ensure assignedVlan applies to the chosen group
    VlanId floodGroupVlan = extractVlanIdFromGroupId(l2floodGroupId);
    if (!floodGroupVlan.equals(assignedVlan)) {
        log.warn("VLAN ID {} does not match Flood group {} to which bucket is " + "being added, for next:{} in dev:{}. Abort.", assignedVlan, Integer.toHexString(l2floodGroupId), nextObj.id(), deviceId);
        fail(nextObj, ObjectiveError.BADPARAMS);
        return;
    }
    List<Deque<GroupKey>> addedKeys = new ArrayList<>();
    groupInfos.forEach(groupInfo -> {
        // update original NextGroup with new bucket-chain
        Deque<GroupKey> newBucketChain = new ArrayDeque<>();
        newBucketChain.addFirst(groupInfo.nextGroupDesc().appCookie());
        newBucketChain.addFirst(l2floodGroupKey);
        addedKeys.add(newBucketChain);
        log.debug("Adding to L2FLOOD: device:{} gid:{} group key:{} nextId:{}", deviceId, Integer.toHexString(l2floodGroupId), l2floodGroupKey, nextObj.id());
        // send the innermost group
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), l2FloodGroupChainElement);
        DeviceId innerMostGroupDevice = groupInfo.innerMostGroupDesc().deviceId();
        GroupKey innerMostGroupKey = groupInfo.innerMostGroupDesc().appCookie();
        Group existsL2IGroup = groupService.getGroup(innerMostGroupDevice, innerMostGroupKey);
        if (existsL2IGroup != null) {
            // group already exist
            processPendingAddGroupsOrNextObjs(innerMostGroupKey, true);
        } else {
            groupService.addGroup(groupInfo.innerMostGroupDesc());
        }
    });
    updatePendingNextObjective(l2floodGroupKey, new OfdpaNextGroup(addedKeys, nextObj));
}
#end_block

#method_before
private void addBucketToL3MulticastGroup(NextObjective nextObj, List<Deque<GroupKey>> allActiveKeys, List<GroupInfo> groupInfos, VlanId assignedVlan) {
    // Create the buckets to add to the outermost L3 Multicast group
    List<GroupBucket> newBuckets = createL3MulticastBucket(groupInfos);
    // get the group being edited
    Group l3mcastGroup = retrieveTopLevelGroup(allActiveKeys, nextObj.id());
    if (l3mcastGroup == null) {
        fail(nextObj, ObjectiveError.GROUPMISSING);
        return;
    }
    GroupKey l3mcastGroupKey = l3mcastGroup.appCookie();
    int l3mcastGroupId = l3mcastGroup.id().id();
    // ensure assignedVlan applies to the chosen group
    VlanId expectedVlan = extractVlanIdFromGroupId(l3mcastGroupId);
    if (!expectedVlan.equals(assignedVlan)) {
        log.warn("VLAN ID {} does not match L3 Mcast group {} to which bucket is " + "being added, for next:{} in dev:{}. Abort.", assignedVlan, Integer.toHexString(l3mcastGroupId), nextObj.id(), deviceId);
        fail(nextObj, ObjectiveError.BADPARAMS);
    }
    GroupDescription l3mcastGroupDescription = new DefaultGroupDescription(deviceId, ALL, new GroupBuckets(newBuckets), l3mcastGroupKey, l3mcastGroupId, nextObj.appId());
    GroupChainElem l3mcastGce = new GroupChainElem(l3mcastGroupDescription, groupInfos.size(), true, deviceId);
    List<Deque<GroupKey>> addedKeys = new ArrayList<>();
    groupInfos.forEach(groupInfo -> {
        // update original NextGroup with new bucket-chain
        Deque<GroupKey> newBucketChain = new ArrayDeque<>();
        newBucketChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
        // Add L3 interface group to the chain if there is one.
        if (!groupInfo.nextGroupDesc().equals(groupInfo.innerMostGroupDesc())) {
            newBucketChain.addFirst(groupInfo.nextGroupDesc().appCookie());
        }
        newBucketChain.addFirst(l3mcastGroupKey);
        addedKeys.add(newBucketChain);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), l3mcastGce);
        // Point next group to inner-most group, if any
        if (!groupInfo.nextGroupDesc().equals(groupInfo.innerMostGroupDesc())) {
            GroupChainElem innerGce = new GroupChainElem(groupInfo.nextGroupDesc(), 1, false, deviceId);
            updatePendingGroups(groupInfo.innerMostGroupDesc().appCookie(), innerGce);
        }
        log.debug("Adding to L3MCAST: device:{} gid:{} group key:{} nextId:{}", deviceId, Integer.toHexString(l3mcastGroupId), l3mcastGroupKey, nextObj.id());
        // send the innermost group
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    });
    updatePendingNextObjective(l3mcastGroupKey, new OfdpaNextGroup(addedKeys, nextObj));
}
#method_after
private void addBucketToL3MulticastGroup(NextObjective nextObj, List<Deque<GroupKey>> allActiveKeys, List<GroupInfo> groupInfos, VlanId assignedVlan) {
    // Create the buckets to add to the outermost L3 Multicast group
    List<GroupBucket> newBuckets = createL3MulticastBucket(groupInfos);
    // get the group being edited
    Group l3mcastGroup = retrieveTopLevelGroup(allActiveKeys, deviceId, groupService, nextObj.id());
    if (l3mcastGroup == null) {
        fail(nextObj, ObjectiveError.GROUPMISSING);
        return;
    }
    GroupKey l3mcastGroupKey = l3mcastGroup.appCookie();
    int l3mcastGroupId = l3mcastGroup.id().id();
    // ensure assignedVlan applies to the chosen group
    VlanId expectedVlan = extractVlanIdFromGroupId(l3mcastGroupId);
    if (!expectedVlan.equals(assignedVlan)) {
        log.warn("VLAN ID {} does not match L3 Mcast group {} to which bucket is " + "being added, for next:{} in dev:{}. Abort.", assignedVlan, Integer.toHexString(l3mcastGroupId), nextObj.id(), deviceId);
        fail(nextObj, ObjectiveError.BADPARAMS);
    }
    GroupDescription l3mcastGroupDescription = new DefaultGroupDescription(deviceId, ALL, new GroupBuckets(newBuckets), l3mcastGroupKey, l3mcastGroupId, nextObj.appId());
    GroupChainElem l3mcastGce = new GroupChainElem(l3mcastGroupDescription, groupInfos.size(), true, deviceId);
    List<Deque<GroupKey>> addedKeys = new ArrayList<>();
    groupInfos.forEach(groupInfo -> {
        // update original NextGroup with new bucket-chain
        Deque<GroupKey> newBucketChain = new ArrayDeque<>();
        newBucketChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
        // Add L3 interface group to the chain if there is one.
        if (!groupInfo.nextGroupDesc().equals(groupInfo.innerMostGroupDesc())) {
            newBucketChain.addFirst(groupInfo.nextGroupDesc().appCookie());
        }
        newBucketChain.addFirst(l3mcastGroupKey);
        addedKeys.add(newBucketChain);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), l3mcastGce);
        // Point next group to inner-most group, if any
        if (!groupInfo.nextGroupDesc().equals(groupInfo.innerMostGroupDesc())) {
            GroupChainElem innerGce = new GroupChainElem(groupInfo.nextGroupDesc(), 1, false, deviceId);
            updatePendingGroups(groupInfo.innerMostGroupDesc().appCookie(), innerGce);
        }
        log.debug("Adding to L3MCAST: device:{} gid:{} group key:{} nextId:{}", deviceId, Integer.toHexString(l3mcastGroupId), l3mcastGroupKey, nextObj.id());
        // send the innermost group
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(groupInfo.innerMostGroupDesc().givenGroupId()), deviceId);
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    });
    updatePendingNextObjective(l3mcastGroupKey, new OfdpaNextGroup(addedKeys, nextObj));
}
#end_block

#method_before
protected void verifyGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("verification not supported for {} group", nextObjective.type());
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    log.debug("Call to verify device:{} nextId:{}", deviceId, nextObjective.id());
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<TrafficTreatment> bucketsToCreate = Lists.newArrayList();
    List<Integer> indicesToRemove = Lists.newArrayList();
    for (TrafficTreatment bkt : nextObjective.next()) {
        PortNumber portNumber = readOutPortFromTreatment(bkt);
        int label = readLabelFromTreatment(bkt);
        if (portNumber == null) {
            log.warn("treatment {} of next objective {} has no outport.. " + "cannot remove bucket from group in dev: {}", bkt, nextObjective.id(), deviceId);
            fail(nextObjective, ObjectiveError.BADPARAMS);
            return;
        }
        List<Integer> existing = existingPortAndLabel(allActiveKeys, groupService, deviceId, portNumber, label);
        if (existing.isEmpty()) {
            // if it doesn't exist, mark this bucket for creation
            bucketsToCreate.add(bkt);
        }
        if (existing.size() > 1) {
            // if it exists but there are duplicates, mark the others for removal
            existing.remove(0);
            indicesToRemove.addAll(existing);
        }
    }
    if (!bucketsToCreate.isEmpty()) {
        log.info("creating {} buckets as part of nextId: {} verification", bucketsToCreate.size(), nextObjective.id());
        // create a nextObjective only with these buckets
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextObjective.id()).withType(NextObjective.Type.HASHED).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
        bucketsToCreate.forEach(bucket -> nextObjBuilder.addTreatment(bucket));
        addBucketToHashGroup(nextObjBuilder.addToExisting(), allActiveKeys);
    }
    if (!indicesToRemove.isEmpty()) {
        log.info("removing {} buckets as part of nextId: {} verification", indicesToRemove.size(), nextObjective.id());
        List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
        indicesToRemove.forEach(index -> chainsToRemove.add(allActiveKeys.get(index)));
        removeBucket(chainsToRemove, nextObjective);
    }
    if (bucketsToCreate.isEmpty() && indicesToRemove.isEmpty()) {
        // flowObjective store record is in-sync with nextObjective passed-in
        // Nevertheless groupStore may not be in sync due to bug in the store
        // - see CORD-1844. XXX When this bug is fixed, the rest of this verify
        // method will not be required.
        GroupKey hashGroupKey = allActiveKeys.get(0).peekFirst();
        Group hashGroup = groupService.getGroup(deviceId, hashGroupKey);
        int actualGroupSize = hashGroup.buckets().buckets().size();
        int objGroupSize = nextObjective.next().size();
        if (actualGroupSize != objGroupSize) {
            log.warn("Mismatch detected in device:{}, nextId:{}, nextObjective-size" + ":{} group-size:{} .. correcting", deviceId, nextObjective.id(), objGroupSize, actualGroupSize);
        }
        if (actualGroupSize > objGroupSize) {
            List<GroupBucket> bucketsToRemove = Lists.newArrayList();
            // check every bucket in the actual group
            for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                // the group pointed to
                GroupId gidToCheck = g.groupId();
                boolean matches = false;
                for (Deque<GroupKey> validChain : allActiveKeys) {
                    if (validChain.size() < 2) {
                        continue;
                    }
                    GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                    Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                    if (pointedGroup != null && gidToCheck.equals(pointedGroup.id())) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Removing bucket pointing to groupId:{}", gidToCheck);
                    bucketsToRemove.add(bucket);
                }
            }
            // remove buckets for which there was no record in the obj store
            if (bucketsToRemove.isEmpty()) {
                log.warn("Mismatch detected but could not determine which" + "buckets to remove");
            } else {
                GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
                groupService.removeBucketsFromGroup(deviceId, hashGroupKey, removeBuckets, hashGroupKey, nextObjective.appId());
            }
        } else if (actualGroupSize < objGroupSize) {
            // should also add buckets not in group-store but in obj-store
            List<GroupBucket> bucketsToAdd = Lists.newArrayList();
            // check every bucket in the obj
            for (Deque<GroupKey> validChain : allActiveKeys) {
                if (validChain.size() < 2) {
                    continue;
                }
                GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                if (pointedGroup == null) {
                    // group should exist, otherwise cannot be added as bucket
                    continue;
                }
                boolean matches = false;
                for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                    GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                    // the group pointed to
                    GroupId gidToCheck = g.groupId();
                    if (pointedGroup.id().equals(gidToCheck)) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Adding bucket pointing to groupId:{}", pointedGroup);
                    TrafficTreatment t = DefaultTrafficTreatment.builder().group(pointedGroup.id()).build();
                    bucketsToAdd.add(DefaultGroupBucket.createSelectGroupBucket(t));
                }
            }
            if (bucketsToAdd.isEmpty()) {
                log.warn("Mismatch detected but could not determine which " + "buckets to add");
            } else {
                GroupBuckets addBuckets = new GroupBuckets(bucketsToAdd);
                groupService.addBucketsToGroup(deviceId, hashGroupKey, addBuckets, hashGroupKey, nextObjective.appId());
            }
        }
    }
    pass(nextObjective);
}
#method_after
protected void verifyGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() == NextObjective.Type.SIMPLE) {
        log.warn("verification not supported for indirect group");
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    log.debug("Call to verify device:{} nextId:{}", deviceId, nextObjective.id());
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<TrafficTreatment> bucketsToCreate = Lists.newArrayList();
    List<Integer> indicesToRemove = Lists.newArrayList();
    // to detect missing buckets and/or duplicate buckets (to be removed)
    for (TrafficTreatment bkt : nextObjective.next()) {
        PortNumber portNumber = readOutPortFromTreatment(bkt);
        int label = readLabelFromTreatment(bkt);
        if (portNumber == null) {
            log.warn("treatment {} of next objective {} has no outport.. " + "cannot remove bucket from group in dev: {}", bkt, nextObjective.id(), deviceId);
            fail(nextObjective, ObjectiveError.BADPARAMS);
            return;
        }
        List<Integer> existing = existingPortAndLabel(allActiveKeys, groupService, deviceId, portNumber, label);
        if (existing.isEmpty()) {
            // if it doesn't exist, mark this bucket for creation
            bucketsToCreate.add(bkt);
        }
        if (existing.size() > 1) {
            // if it exists but there are duplicates, mark the others for removal
            existing.remove(0);
            indicesToRemove.addAll(existing);
        }
    }
    // (not duplicates) respect to the next objective
    if (allActiveKeys.size() > nextObjective.next().size()) {
        log.warn("Mismatch detected between next and flowobjstore for device {}: " + "nextId:{}, nextObjective-size:{} next-size:{} .. correcting", deviceId, nextObjective.id(), nextObjective.next().size(), allActiveKeys.size());
        List<Integer> otherIndices = indicesToRemoveFromNextGroup(allActiveKeys, nextObjective, groupService, deviceId);
        // Filter out the indices not present
        otherIndices = otherIndices.stream().filter(index -> !indicesToRemove.contains(index)).collect(Collectors.toList());
        // Add all to the final list
        indicesToRemove.addAll(otherIndices);
    }
    log.debug("Buckets to create {}", bucketsToCreate);
    log.debug("Indices to remove {}", indicesToRemove);
    if (!bucketsToCreate.isEmpty()) {
        log.info("creating {} buckets as part of nextId: {} verification", bucketsToCreate.size(), nextObjective.id());
        // create a nextObjective only with these buckets
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextObjective.id()).withType(nextObjective.type()).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
        bucketsToCreate.forEach(nextObjBuilder::addTreatment);
        // According to the next type we call the proper add function
        if (nextObjective.type() == NextObjective.Type.HASHED) {
            addBucketToHashGroup(nextObjBuilder.addToExisting(), allActiveKeys);
        } else {
            addBucketToBroadcastGroup(nextObjBuilder.addToExisting(), allActiveKeys);
        }
    }
    if (!indicesToRemove.isEmpty()) {
        log.info("removing {} buckets as part of nextId: {} verification", indicesToRemove.size(), nextObjective.id());
        List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
        indicesToRemove.forEach(index -> chainsToRemove.add(allActiveKeys.get(index)));
        removeBucket(chainsToRemove, nextObjective);
    }
    if (bucketsToCreate.isEmpty() && indicesToRemove.isEmpty()) {
        // flowObjective store record is in-sync with nextObjective passed-in
        // Nevertheless groupStore may not be in sync due to bug in the store
        // - see CORD-1844. XXX When this bug is fixed, the rest of this verify
        // method will not be required.
        GroupKey topGroupKey = allActiveKeys.get(0).peekFirst();
        Group topGroup = groupService.getGroup(deviceId, topGroupKey);
        int actualGroupSize = topGroup.buckets().buckets().size();
        int objGroupSize = nextObjective.next().size();
        if (actualGroupSize != objGroupSize) {
            log.warn("Mismatch detected in device:{}, nextId:{}, nextObjective-size" + ":{} group-size:{} .. correcting", deviceId, nextObjective.id(), objGroupSize, actualGroupSize);
        }
        if (actualGroupSize > objGroupSize) {
            // Group in the device has more chains
            List<GroupBucket> bucketsToRemove = Lists.newArrayList();
            // check every bucket in the actual group
            for (GroupBucket bucket : topGroup.buckets().buckets()) {
                GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                // the group pointed to
                GroupId gidToCheck = g.groupId();
                boolean matches = false;
                for (Deque<GroupKey> validChain : allActiveKeys) {
                    if (validChain.size() < 2) {
                        continue;
                    }
                    GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                    Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                    if (pointedGroup != null && gidToCheck.equals(pointedGroup.id())) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Removing bucket pointing to groupId:{}", gidToCheck);
                    bucketsToRemove.add(bucket);
                }
            }
            // remove buckets for which there was no record in the obj store
            if (bucketsToRemove.isEmpty()) {
                log.warn("Mismatch detected but could not determine which" + "buckets to remove");
            } else {
                GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
                groupService.removeBucketsFromGroup(deviceId, topGroupKey, removeBuckets, topGroupKey, nextObjective.appId());
            }
        } else if (actualGroupSize < objGroupSize) {
            // Group in the device has less chains
            // should also add buckets not in group-store but in obj-store
            List<GroupBucket> bucketsToAdd = Lists.newArrayList();
            // check every bucket in the obj
            for (Deque<GroupKey> validChain : allActiveKeys) {
                if (validChain.size() < 2) {
                    continue;
                }
                GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                if (pointedGroup == null) {
                    // group should exist, otherwise cannot be added as bucket
                    continue;
                }
                boolean matches = false;
                for (GroupBucket bucket : topGroup.buckets().buckets()) {
                    GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                    // the group pointed to
                    GroupId gidToCheck = g.groupId();
                    if (pointedGroup.id().equals(gidToCheck)) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Adding bucket pointing to groupId:{}", pointedGroup);
                    TrafficTreatment t = DefaultTrafficTreatment.builder().group(pointedGroup.id()).build();
                    // Create the proper bucket according to the next type
                    if (nextObjective.type() == NextObjective.Type.HASHED) {
                        bucketsToAdd.add(DefaultGroupBucket.createSelectGroupBucket(t));
                    } else {
                        bucketsToAdd.add(DefaultGroupBucket.createAllGroupBucket(t));
                    }
                }
            }
            if (bucketsToAdd.isEmpty()) {
                log.warn("Mismatch detected but could not determine which " + "buckets to add");
            } else {
                GroupBuckets addBuckets = new GroupBuckets(bucketsToAdd);
                groupService.addBucketsToGroup(deviceId, topGroupKey, addBuckets, topGroupKey, nextObjective.appId());
            }
        }
    }
    pass(nextObjective);
}
#end_block

#method_before
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Integer pseudowireId = PSEUDOWIRE_CODEC.decodeId(pseudowireJson);
    if (pseudowireId == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.info("Deleting pseudowire {} from rest api!", pseudowireId);
    L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
    switch(res) {
        case REMOVAL_ERROR:
            log.error("Pseudowire {} could not be removed, error in configuration," + " please check logs for more details!", pseudowireId);
            return Response.serverError().status(Response.Status.NOT_FOUND).build();
        case SUCCESS:
            log.info("Pseudowire {} was removed succesfully!", pseudowireId);
            return Response.ok().build();
        default:
            return Response.ok().build();
    }
}
#method_after
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
public Response removePseudowire(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode pseudowireJson = (ObjectNode) mapper.readTree(input);
    SegmentRoutingService srService = get(SegmentRoutingService.class);
    Integer pseudowireId = PSEUDOWIRE_CODEC.decodeId(pseudowireJson);
    if (pseudowireId == null) {
        return Response.serverError().status(Response.Status.BAD_REQUEST).build();
    }
    log.info("Deleting pseudowire {} from rest api!", pseudowireId);
    L2TunnelHandler.Result res = srService.removePseudowire(pseudowireId);
    switch(res) {
        case REMOVAL_ERROR:
            log.error("Pseudowire {} could not be removed, error in configuration," + " please check logs for more details!", pseudowireId);
            return Response.noContent().build();
        case SUCCESS:
            log.info("Pseudowire {} was removed succesfully!", pseudowireId);
            return Response.noContent().build();
        default:
            return Response.noContent().build();
    }
}
#end_block

#method_before
@Override
public void init() {
}
#method_after
@Override
public void init() {
// Since we have no pseudowires in netcfg there
// is nothing to do in initialization.
// I leave it here because potentially we might need to
// use it in the future.
}
#end_block

#method_before
@Override
protected void execute() {
    OpenstackNetworkService service = AbstractShellCommand.get(OpenstackNetworkService.class);
    if (service.externalPeerRouters().isEmpty()) {
        print(NO_ELEMENT);
        return;
    } else if (service.externalPeerRouters().stream().noneMatch(router -> router.externalPeerRouterIp().toString().equals(ipAddress))) {
        print(NO_ELEMENT);
        return;
    }
    try {
        service.deleteExternalPeerRouter(ipAddress);
    } catch (IllegalArgumentException e) {
        log.error("Exception occurred because of {}", e.toString());
    }
    print(FORMAT, "Router IP", "Mac Address", "VLAN ID");
    List<ExternalPeerRouter> routers = Lists.newArrayList(service.externalPeerRouters());
    for (ExternalPeerRouter router : routers) {
        print(FORMAT, router.externalPeerRouterIp(), router.externalPeerRouterMac().toString(), router.externalPeerRouterVlanId());
    }
}
#method_after
@Override
protected void execute() {
    OpenstackNetworkService service = AbstractShellCommand.get(OpenstackNetworkService.class);
    if (service.externalPeerRouters().stream().noneMatch(router -> router.externalPeerRouterIp().toString().equals(ipAddress))) {
        print(NO_ELEMENT);
        return;
    }
    try {
        service.deleteExternalPeerRouter(ipAddress);
    } catch (IllegalArgumentException e) {
        log.error("Exception occurred because of {}", e.toString());
    }
    print(FORMAT, "Router IP", "Mac Address", "VLAN ID");
    List<ExternalPeerRouter> routers = Lists.newArrayList(service.externalPeerRouters());
    for (ExternalPeerRouter router : routers) {
        print(FORMAT, router.externalPeerRouterIp(), router.externalPeerRouterMac().toString(), router.externalPeerRouterVlanId());
    }
}
#end_block

#method_before
private void processArpPacket(PacketContext context, Ethernet ethernet) {
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        if (log.isTraceEnabled()) {
            log.trace("ARP request received from {} for {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
        }
        IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
        NetFloatingIP floatingIP = osRouterService.floatingIps().stream().filter(ip -> ip.getFloatingIpAddress().equals(targetIp.toString())).findAny().orElse(null);
        if (floatingIP.getPortId() == null) {
            return;
        }
        MacAddress targetMac = MacAddress.valueOf(osNetworkService.port(floatingIP.getPortId()).getMacAddress());
        if (isExternalGatewaySourceIp(targetIp.getIp4Address())) {
            targetMac = Constants.DEFAULT_GATEWAY_MAC;
        }
        if (targetMac == null) {
            log.trace("Unknown target ARP request for {}, ignore it", targetIp);
            return;
        }
        Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
        packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
        context.block();
    } else if (arp.getOpCode() == ARP.OP_REPLY) {
        PortNumber receivedPortNum = context.inPacket().receivedFrom().port();
        log.debug("ARP reply ip: {}, mac: {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
        try {
            if (receivedPortNum.equals(osNodeService.node(context.inPacket().receivedFrom().deviceId()).uplinkPortNum())) {
                osNetworkService.updateExternalPeerRouterMac(Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
            }
        } catch (Exception e) {
            log.error("Exception occurred because of {}", e.toString());
        }
    }
}
#method_after
private void processArpPacket(PacketContext context, Ethernet ethernet) {
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        if (log.isTraceEnabled()) {
            log.trace("ARP request received from {} for {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
        }
        IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
        MacAddress targetMac = null;
        NetFloatingIP floatingIP = osRouterService.floatingIps().stream().filter(ip -> ip.getFloatingIpAddress().equals(targetIp.toString())).findAny().orElse(null);
        if (floatingIP != null && floatingIP.getPortId() != null) {
            targetMac = MacAddress.valueOf(osNetworkService.port(floatingIP.getPortId()).getMacAddress());
        }
        if (isExternalGatewaySourceIp(targetIp.getIp4Address())) {
            targetMac = Constants.DEFAULT_GATEWAY_MAC;
        }
        if (targetMac == null) {
            log.trace("Unknown target ARP request for {}, ignore it", targetIp);
            return;
        }
        Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
        packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
        context.block();
    } else if (arp.getOpCode() == ARP.OP_REPLY) {
        PortNumber receivedPortNum = context.inPacket().receivedFrom().port();
        log.debug("ARP reply ip: {}, mac: {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
        try {
            if (receivedPortNum.equals(osNodeService.node(context.inPacket().receivedFrom().deviceId()).uplinkPortNum())) {
                osNetworkService.updateExternalPeerRouterMac(Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
            }
        } catch (Exception e) {
            log.error("Exception occurred because of {}", e.toString());
        }
    }
}
#end_block

#method_before
@Override
public List<ControllerInfo> getControllers() {
    List<ControllerInfo> controllers = Lists.newArrayList();
    // Get controller instance
    if (!init()) {
        return controllers;
    }
    DeviceId deviceId = handler.data().deviceId();
    checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    MastershipService mastershipService = handler.get(MastershipService.class);
    checkNotNull(deviceId, Common.MASTERSHIP_NULL);
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("I am not master for {}. " + "Please use master {} to get controllers for this device", deviceId, mastershipService.getMasterFor(deviceId));
        return controllers;
    }
    // Hit the path that provides the server's controllers
    InputStream response = null;
    try {
        response = controller.get(deviceId, CONTROLLERS_CONF_URL, Common.JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to get controllers of device: {}", deviceId);
        return controllers;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to get controllers of device: {}", deviceId);
        return controllers;
    }
    if (jsonMap == null) {
        log.error("Failed to get controllers of device: {}", deviceId);
        return controllers;
    }
    JsonNode ctrlNode = objNode.path(PARAM_CTRL);
    // Fetch controller objects
    for (JsonNode cn : ctrlNode) {
        ObjectNode ctrlObjNode = (ObjectNode) cn;
        // Get the attributes of a controller
        String ctrlIpStr = Common.get(cn, PARAM_CTRL_IP);
        int ctrlPort = ctrlObjNode.path(PARAM_CTRL_PORT).asInt();
        String ctrlType = Common.get(cn, PARAM_CTRL_TYPE);
        // Check data format and range
        IpAddress ctrlIp = null;
        try {
            ctrlIp = IpAddress.valueOf(ctrlIpStr);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(e);
        }
        if ((ctrlPort < 0) || (ctrlPort > TpPort.MAX_PORT)) {
            final String msg = "Invalid controller port: " + ctrlPort;
            throw new IllegalArgumentException(msg);
        }
        controllers.add(new ControllerInfo(ctrlIp, ctrlPort, ctrlType));
    }
    return controllers;
}
#method_after
@Override
public List<ControllerInfo> getControllers() {
    List<ControllerInfo> controllers = Lists.newArrayList();
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    MastershipService mastershipService = getHandler().get(MastershipService.class);
    checkNotNull(deviceId, MASTERSHIP_NULL);
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("I am not master for {}. " + "Please use master {} to get controllers for this device", deviceId, mastershipService.getMasterFor(deviceId));
        return controllers;
    }
    // Hit the path that provides the server's controllers
    InputStream response = null;
    try {
        response = getController().get(deviceId, CONTROLLERS_CONF_URL, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to get controllers of device: {}", deviceId);
        return controllers;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to get controllers of device: {}", deviceId);
        return controllers;
    }
    if (jsonMap == null) {
        log.error("Failed to get controllers of device: {}", deviceId);
        return controllers;
    }
    JsonNode ctrlNode = objNode.path(PARAM_CTRL);
    // Fetch controller objects
    for (JsonNode cn : ctrlNode) {
        ObjectNode ctrlObjNode = (ObjectNode) cn;
        // Get the attributes of a controller
        String ctrlIpStr = get(cn, PARAM_CTRL_IP);
        int ctrlPort = ctrlObjNode.path(PARAM_CTRL_PORT).asInt();
        String ctrlType = get(cn, PARAM_CTRL_TYPE);
        // Check data format and range
        IpAddress ctrlIp = null;
        try {
            ctrlIp = IpAddress.valueOf(ctrlIpStr);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(e);
        }
        if ((ctrlPort < 0) || (ctrlPort > TpPort.MAX_PORT)) {
            final String msg = "Invalid controller port: " + ctrlPort;
            throw new IllegalArgumentException(msg);
        }
        controllers.add(new ControllerInfo(ctrlIp, ctrlPort, ctrlType));
    }
    return controllers;
}
#end_block

#method_before
@Override
public void setControllers(List<ControllerInfo> controllers) {
    // Get controller instance
    if (!init()) {
        return;
    }
    DeviceId deviceId = handler.data().deviceId();
    checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    MastershipService mastershipService = handler.get(MastershipService.class);
    checkNotNull(deviceId, Common.MASTERSHIP_NULL);
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("I am not master for {}. " + "Please use master {} to set controllers for this device", deviceId, mastershipService.getMasterFor(deviceId));
        return;
    }
    ObjectMapper mapper = new ObjectMapper();
    // Create the object node to host the data
    ObjectNode sendObjNode = mapper.createObjectNode();
    // Insert header
    ArrayNode ctrlsArrayNode = sendObjNode.putArray(PARAM_CTRL);
    // Add each controller's information object
    for (ControllerInfo ctrl : controllers) {
        ObjectNode ctrlObjNode = mapper.createObjectNode();
        ctrlObjNode.put(PARAM_CTRL_IP, ctrl.ip().toString());
        ctrlObjNode.put(PARAM_CTRL_PORT, ctrl.port());
        ctrlObjNode.put(PARAM_CTRL_TYPE, ctrl.type());
        ctrlsArrayNode.add(ctrlObjNode);
    }
    // Post the controllers to the device
    boolean response = this.controller.post(deviceId, CONTROLLERS_CONF_URL, new ByteArrayInputStream(sendObjNode.toString().getBytes()), Common.JSON);
    if (!response) {
        log.error("Failed to set controllers on device {}", deviceId);
    }
    return;
}
#method_after
@Override
public void setControllers(List<ControllerInfo> controllers) {
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    MastershipService mastershipService = getHandler().get(MastershipService.class);
    checkNotNull(deviceId, MASTERSHIP_NULL);
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("I am not master for {}. " + "Please use master {} to set controllers for this device", deviceId, mastershipService.getMasterFor(deviceId));
        return;
    }
    ObjectMapper mapper = new ObjectMapper();
    // Create the object node to host the data
    ObjectNode sendObjNode = mapper.createObjectNode();
    // Insert header
    ArrayNode ctrlsArrayNode = sendObjNode.putArray(PARAM_CTRL);
    // Add each controller's information object
    for (ControllerInfo ctrl : controllers) {
        ObjectNode ctrlObjNode = mapper.createObjectNode();
        ctrlObjNode.put(PARAM_CTRL_IP, ctrl.ip().toString());
        ctrlObjNode.put(PARAM_CTRL_PORT, ctrl.port());
        ctrlObjNode.put(PARAM_CTRL_TYPE, ctrl.type());
        ctrlsArrayNode.add(ctrlObjNode);
    }
    // Post the controllers to the device
    int response = getController().post(deviceId, CONTROLLERS_CONF_URL, new ByteArrayInputStream(sendObjNode.toString().getBytes()), JSON);
    if (!checkStatusCode(response)) {
        log.error("Failed to set controllers on device {}", deviceId);
    }
    return;
}
#end_block

#method_before
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    // Get controller instance
    if (!init()) {
        return;
    }
    DeviceId deviceId = handler.data().deviceId();
    checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    MastershipService mastershipService = handler.get(MastershipService.class);
    checkNotNull(deviceId, Common.MASTERSHIP_NULL);
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("I am not master for {}. " + "Please use master {} to remove controllers from this device", deviceId, mastershipService.getMasterFor(deviceId));
        return;
    }
    /**
     * TODO: Explicit removal of the requested controllers.
     */
    /**
     * List of controllers is ignored for now.
     * We just tell the server to remove its
     * current controller information.
     */
    boolean response = this.controller.delete(deviceId, CONTROLLERS_CONF_URL, null, Common.JSON);
    if (!response) {
        log.error("Failed to remove controllers from device {}", deviceId);
    }
    return;
}
#method_after
@Override
public void removeControllers(List<ControllerInfo> controllers) {
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    MastershipService mastershipService = getHandler().get(MastershipService.class);
    checkNotNull(deviceId, MASTERSHIP_NULL);
    if (!mastershipService.isLocalMaster(deviceId)) {
        log.warn("I am not master for {}. " + "Please use master {} to remove controllers from this device", deviceId, mastershipService.getMasterFor(deviceId));
        return;
    }
    /**
     * TODO: Explicit removal of the requested controllers.
     */
    /**
     * List of controllers is ignored for now.
     * We just tell the server to remove its
     * current controller information.
     */
    int response = getController().delete(deviceId, CONTROLLERS_CONF_URL, null, JSON);
    if (!checkStatusCode(response)) {
        log.error("Failed to remove controllers from device {}", deviceId);
    }
    return;
}
#end_block

#method_before
@Override
public InputStream get(DeviceId device, String request, MediaType mediaType) {
    return null;
}
#method_after
@Override
public InputStream get(DeviceId device, String request, MediaType mediaType) {
    /**
     * We fake the HTTP get in order to
     * emulate the expected response.
     */
    ObjectMapper mapper = new ObjectMapper();
    // Create the object node to host the data
    ObjectNode sendObjNode = mapper.createObjectNode();
    // Insert header
    ArrayNode ctrlsArrayNode = sendObjNode.putArray(PARAM_CTRL);
    // Add each controller's information object
    for (ControllerInfo ctrl : controllers) {
        ObjectNode ctrlObjNode = mapper.createObjectNode();
        ctrlObjNode.put(PARAM_CTRL_IP, ctrl.ip().toString());
        ctrlObjNode.put(PARAM_CTRL_PORT, ctrl.port());
        ctrlObjNode.put(PARAM_CTRL_TYPE, ctrl.type());
        ctrlsArrayNode.add(ctrlObjNode);
    }
    return new ByteArrayInputStream(sendObjNode.toString().getBytes());
}
#end_block

#method_before
@Override
public int post(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    return 0;
}
#method_after
@Override
public int post(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    return Response.Status.OK.getStatusCode();
}
#end_block

#method_before
@Override
public int put(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    return 0;
}
#method_after
@Override
public int put(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    return Response.Status.OK.getStatusCode();
}
#end_block

#method_before
@Override
public int patch(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    return 0;
}
#method_after
@Override
public int patch(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    return Response.Status.OK.getStatusCode();
}
#end_block

#method_before
@Override
public int delete(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    return 0;
}
#method_after
@Override
public int delete(DeviceId device, String request, InputStream payload, MediaType mediaType) {
    return Response.Status.OK.getStatusCode();
}
#end_block

#method_before
@Test
public void testSetControllers() {
    // Get device handler
    DriverHandler driverHandler = driverService.createHandler(restDeviceId1);
    // Get mastership service
    mastershipService = driverHandler.get(MastershipService.class);
    assertThat(mastershipService, notNullValue());
    // Get controller config behavior
    ControllerConfig controllerConfig = driverHandler.behaviour(ControllerConfig.class);
    assertThat(controllerConfig, notNullValue());
    assertThat(controllers, notNullValue());
    assertFalse(controllers.isEmpty());
    // Set a list of controllers for this device
    controllerConfig.setControllers(controllers);
}
#method_after
@Test
public void testSetControllers() {
    // Get device handler
    DriverHandler driverHandler = null;
    try {
        driverHandler = driverService.createHandler(restDeviceId1);
    } catch (Exception e) {
        throw e;
    }
    assertThat(driverHandler, notNullValue());
// TODO: Fix this test
}
#end_block

#method_before
@Test
public void testGetControllers() {
    // Get device handler
    DriverHandler driverHandler = driverService.createHandler(restDeviceId1);
    // Get mastership service
    mastershipService = driverHandler.get(MastershipService.class);
    assertThat(mastershipService, notNullValue());
    // Get controller config behavior
    ControllerConfig controllerConfig = driverHandler.behaviour(ControllerConfig.class);
    assertThat(controllerConfig, notNullValue());
    // Ask for the controllers of this device
    List<ControllerInfo> receivedControllers = controllerConfig.getControllers();
    // Verify that we got something
    assertThat(receivedControllers, notNullValue());
    assertFalse(receivedControllers.isEmpty());
    // Verify that we got what we expected
    assertTrue(receivedControllers.size() == controllers.size());
    assertTrue("Incorrect get response", controllers.equals(receivedControllers));
}
#method_after
@Test
public void testGetControllers() {
    // Get device handler
    DriverHandler driverHandler = null;
    try {
        driverHandler = driverService.createHandler(restDeviceId1);
    } catch (Exception e) {
        throw e;
    }
    assertThat(driverHandler, notNullValue());
    // Ask for the controllers of this device
    List<ControllerInfo> receivedControllers = null;
// TODO: Fix this test
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public <T extends Behaviour> T behaviour(Class<T> behaviourClass) {
    // Let's create the behavior
    ControllerConfig controllerConfing = new ServerControllerConfig();
    // Set the handler
    controllerConfing.setHandler(this);
    // Done, return the behavior
    return (T) controllerConfing;
}
#method_after
@Override
@SuppressWarnings("unchecked")
public <T extends Behaviour> T behaviour(Class<T> behaviourClass) {
    // Let's create the behavior
    ControllerConfig controllerConfing = null;
    try {
        controllerConfing = new ServerControllerConfig();
    } catch (Exception e) {
    // Do nothing
    }
    if (controllerConfing == null) {
        return null;
    }
    // Set the handler
    controllerConfing.setHandler(this);
    // Done, return the behavior
    return (T) controllerConfing;
}
#end_block

#method_before
@Override
public Set<DeviceId> deviceIds() {
    // Set of devices to return
    Set<DeviceId> devices = new HashSet<DeviceId>();
    // Get controller instance
    if (!init()) {
        return devices;
    }
    DeviceId deviceId = handler.data().deviceId();
    checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    devices.add(deviceId);
    return devices;
}
#method_after
@Override
public Set<DeviceId> deviceIds() {
    // Set of devices to return
    Set<DeviceId> devices = new HashSet<DeviceId>();
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    devices.add(deviceId);
    return devices;
}
#end_block

#method_before
private DeviceDescription getDeviceDetails(DeviceId deviceId) {
    // Create a description for this server device
    ServerDeviceDescription desc = null;
    // Get controller instance
    if (!init()) {
        return desc;
    }
    // Retrieve the device ID, if null given
    if (deviceId == null) {
        deviceId = handler.data().deviceId();
        checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    }
    // Get the device
    RestSBDevice device = this.controller.getDevice(deviceId);
    checkNotNull(device, Common.DEVICE_NULL);
    // Hit the path that provides the server's resources
    InputStream response = null;
    try {
        response = this.controller.get(deviceId, RESOURCE_DISCOVERY_URL, Common.JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    if (jsonMap == null) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Get all the attributes
    String id = Common.get(jsonNode, PARAM_ID);
    String vendor = Common.get(jsonNode, PARAM_MANUFACTURER);
    String hw = Common.get(jsonNode, PARAM_HW_VENDOR);
    String sw = Common.get(jsonNode, PARAM_SW_VENDOR);
    String serial = Common.get(jsonNode, PARAM_SERIAL);
    // CPUs are composite attributes
    Set<CpuDevice> cpuSet = new HashSet<CpuDevice>();
    JsonNode cpuNode = objNode.path(PARAM_CPUS);
    // Construct CPU objects
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // All the CPU attributes
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        String cpuVendorStr = Common.get(cn, CPU_PARAM_VENDOR);
        long cpuFrequency = cpuObjNode.path(CPU_PARAM_FREQUENCY).asLong();
        // Verify that this is a valid vendor
        CpuVendor cpuVendor = CpuVendor.getByName(cpuVendorStr);
        checkNotNull(cpuVendor, CPU_VENDOR_NULL);
        // Construct a CPU device
        CpuDevice cpu = new DefaultCpuDevice(cpuId, cpuVendor, cpuFrequency);
        // Add it to the set
        cpuSet.add(cpu);
    }
    // NICs are composite attributes too
    Set<NicDevice> nicSet = new HashSet<NicDevice>();
    JsonNode nicNode = objNode.path(PARAM_NICS);
    // Construct NIC objects
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicId = Common.get(nn, NIC_PARAM_ID);
        int port = Integer.parseInt(nicId.replaceAll("\\D+", ""));
        long speed = nicObjNode.path(NIC_PARAM_SPEED).asLong();
        String portTypeStr = Common.get(nn, NIC_PARAM_PORT_TYPE);
        Port.Type portType = PORT_TYPE_MAP.get(portTypeStr);
        if (portType == null) {
            throw new RuntimeException(portTypeStr + " is not a valid port type for NIC " + nicId);
        }
        boolean status = nicObjNode.path(NIC_PARAM_STATUS).asInt() > 0;
        String hwAddr = Common.get(nn, NIC_PARAM_HW_ADDR);
        JsonNode tagNode = nicObjNode.path(NIC_PARAM_RX_FILTER);
        if (tagNode == null) {
            throw new RuntimeException("The Rx filters of NIC " + nicId + " are not reported");
        }
        // Convert the JSON list into an array of strings
        List<String> rxFilters = null;
        try {
            rxFilters = mapper.readValue(tagNode.traverse(), new TypeReference<ArrayList<String>>() {
            });
        } catch (IOException ioEx) {
            continue;
        }
        // Parse the array of strings and create an RxFilter object
        NicRxFilter rxFilterMechanism = new NicRxFilter();
        for (String s : rxFilters) {
            // Verify that this is a valid Rx filter
            RxFilter rf = RxFilter.getByName(s);
            checkNotNull(rf, NIC_RX_FILTER_NULL);
            rxFilterMechanism.addRxFilter(rf);
        }
        // Construct a NIC device for this server
        NicDevice nic = new DefaultNicDevice(nicId, port, portType, speed, status, hwAddr, rxFilterMechanism);
        // Add it to the set
        nicSet.add(nic);
    }
    /**
     * Construct a complete server device object.
     * Lists of NICs and CPUs extend the information
     * already in RestSBDevice (parent class).
     */
    RestServerSBDevice dev = new DefaultRestServerSBDevice(device.ip(), device.port(), device.username(), device.password(), device.protocol(), device.url(), device.isActive(), device.testUrl().toString(), vendor, hw, sw, AuthenticationScheme.BASIC, "", cpuSet, nicSet);
    checkNotNull(dev, Common.DEVICE_NULL);
    // Updates the controller with the complete device information
    this.controller.removeDevice(deviceId);
    this.controller.addDevice((RestSBDevice) dev);
    /**
     * TODO: Create a new Device type
     * Device.Type.COMMODITY_SERVER
     * and add a new icon in the GUI.
     */
    try {
        desc = new DefaultServerDeviceDescription(new URI(id), Device.Type.OTHER, vendor, hw, sw, serial, new ChassisId(), cpuSet, nicSet, DefaultAnnotations.EMPTY);
    } catch (URISyntaxException uEx) {
        log.error("Failed to create a server device description for: {}", deviceId);
        return null;
    }
    log.info("Device's {} details sent to the controller", deviceId);
    return desc;
}
#method_after
private DeviceDescription getDeviceDetails(DeviceId deviceId) {
    // Create a description for this server device
    ServerDeviceDescription desc = null;
    // Retrieve the device ID, if null given
    if (deviceId == null) {
        deviceId = getHandler().data().deviceId();
        checkNotNull(deviceId, DEVICE_ID_NULL);
    }
    // Get the device
    RestSBDevice device = getController().getDevice(deviceId);
    checkNotNull(device, DEVICE_NULL);
    // Hit the path that provides the server's resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, RESOURCE_DISCOVERY_URL, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    if (jsonMap == null) {
        log.error("Failed to discover the device details of: {}", deviceId);
        return desc;
    }
    // Get all the attributes
    String id = get(jsonNode, PARAM_ID);
    String vendor = get(jsonNode, PARAM_MANUFACTURER);
    String hw = get(jsonNode, PARAM_HW_VENDOR);
    String sw = get(jsonNode, PARAM_SW_VENDOR);
    String serial = get(jsonNode, PARAM_SERIAL);
    // CPUs are composite attributes
    Set<CpuDevice> cpuSet = new HashSet<CpuDevice>();
    JsonNode cpuNode = objNode.path(PARAM_CPUS);
    // Construct CPU objects
    for (JsonNode cn : cpuNode) {
        ObjectNode cpuObjNode = (ObjectNode) cn;
        // All the CPU attributes
        int cpuId = cpuObjNode.path(CPU_PARAM_ID).asInt();
        String cpuVendorStr = get(cn, CPU_PARAM_VENDOR);
        long cpuFrequency = cpuObjNode.path(CPU_PARAM_FREQUENCY).asLong();
        // Verify that this is a valid vendor
        CpuVendor cpuVendor = CpuVendor.getByName(cpuVendorStr);
        checkNotNull(cpuVendor, CPU_VENDOR_NULL);
        // Construct a CPU device
        CpuDevice cpu = new DefaultCpuDevice(cpuId, cpuVendor, cpuFrequency);
        // Add it to the set
        cpuSet.add(cpu);
    }
    // NICs are composite attributes too
    Set<NicDevice> nicSet = new HashSet<NicDevice>();
    JsonNode nicNode = objNode.path(PARAM_NICS);
    // Construct NIC objects
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicId = get(nn, NIC_PARAM_ID);
        int port = Integer.parseInt(nicId.replaceAll("\\D+", ""));
        long speed = nicObjNode.path(NIC_PARAM_SPEED).asLong();
        String portTypeStr = get(nn, NIC_PARAM_PORT_TYPE);
        Port.Type portType = PORT_TYPE_MAP.get(portTypeStr);
        if (portType == null) {
            throw new RuntimeException(portTypeStr + " is not a valid port type for NIC " + nicId);
        }
        boolean status = nicObjNode.path(NIC_PARAM_STATUS).asInt() > 0;
        String hwAddr = get(nn, NIC_PARAM_HW_ADDR);
        JsonNode tagNode = nicObjNode.path(NIC_PARAM_RX_FILTER);
        if (tagNode == null) {
            throw new RuntimeException("The Rx filters of NIC " + nicId + " are not reported");
        }
        // Convert the JSON list into an array of strings
        List<String> rxFilters = null;
        try {
            rxFilters = mapper.readValue(tagNode.traverse(), new TypeReference<ArrayList<String>>() {
            });
        } catch (IOException ioEx) {
            continue;
        }
        // Parse the array of strings and create an RxFilter object
        NicRxFilter rxFilterMechanism = new NicRxFilter();
        for (String s : rxFilters) {
            // Verify that this is a valid Rx filter
            RxFilter rf = RxFilter.getByName(s);
            checkNotNull(rf, NIC_RX_FILTER_NULL);
            rxFilterMechanism.addRxFilter(rf);
        }
        // Construct a NIC device for this server
        NicDevice nic = new DefaultNicDevice(nicId, port, portType, speed, status, hwAddr, rxFilterMechanism);
        // Add it to the set
        nicSet.add(nic);
    }
    /**
     * Construct a complete server device object.
     * Lists of NICs and CPUs extend the information
     * already in RestSBDevice (parent class).
     */
    RestServerSBDevice dev = new DefaultRestServerSBDevice(device.ip(), device.port(), device.username(), device.password(), device.protocol(), device.url(), device.isActive(), device.testUrl().toString(), vendor, hw, sw, AuthenticationScheme.BASIC, "", cpuSet, nicSet);
    checkNotNull(dev, DEVICE_NULL);
    // Updates the controller with the complete device information
    getController().removeDevice(deviceId);
    getController().addDevice((RestSBDevice) dev);
    /**
     * TODO: Create a new Device type
     * Device.Type.COMMODITY_SERVER
     * and add a new icon in the GUI.
     */
    try {
        desc = new DefaultServerDeviceDescription(new URI(id), Device.Type.OTHER, vendor, hw, sw, serial, new ChassisId(), cpuSet, nicSet, DefaultAnnotations.EMPTY);
    } catch (URISyntaxException uEx) {
        log.error("Failed to create a server device description for: {}", deviceId);
        return null;
    }
    log.info("Device's {} details sent to the controller", deviceId);
    return desc;
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    // List of port descriptions to return
    List<PortDescription> portDescriptions = Lists.newArrayList();
    // Get controller instance
    if (!init()) {
        return ImmutableList.copyOf(portDescriptions);
    }
    // Retrieve the device ID
    DeviceId deviceId = handler.data().deviceId();
    checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    // .. and object
    RestServerSBDevice device = null;
    /*
         * In case this method is called before discoverDeviceDetails,
         * there is missing information to be gathered.
         */
    short i = 0;
    while ((device == null) && (i < DISCOVERY_RETRIES)) {
        i++;
        try {
            device = (RestServerSBDevice) this.controller.getDevice(deviceId);
        } catch (ClassCastException ccEx) {
            try {
                Thread.sleep(1);
            } catch (InterruptedException intEx) {
            // Just retry
            } finally {
                continue;
            }
        }
        // No device
        if (device == null) {
            // This method will add the device to the RestSBController
            this.getDeviceDetails(deviceId);
        }
    }
    if ((device == null) || (device.nics() == null)) {
        log.error("No ports available on {}", deviceId);
        return ImmutableList.copyOf(portDescriptions);
    }
    // Sorted list of NIC ports
    Set<NicDevice> nics = new TreeSet(device.nics());
    // Iterate through the NICs of this device to populate the list
    long portCounter = 0;
    for (NicDevice nic : nics) {
        // The port number of this NIC
        PortNumber portNumber = PortNumber.portNumber(++portCounter);
        // Include the name of this device as an annotation
        DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, nic.id());
        // Create a port description and add it to the list
        portDescriptions.add(new DefaultPortDescription(portNumber, nic.status(), nic.portType(), nic.speed(), annotations.build()));
        log.info("Port discovery on device {}: NIC {} is {} at {} Mbps", deviceId, nic.port(), nic.status() ? "up" : "down", nic.speed());
    }
    return ImmutableList.copyOf(portDescriptions);
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    // List of port descriptions to return
    List<PortDescription> portDescriptions = Lists.newArrayList();
    // Retrieve the device ID
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // .. and object
    RestServerSBDevice device = null;
    /*
         * In case this method is called before discoverDeviceDetails,
         * there is missing information to be gathered.
         */
    short i = 0;
    while ((device == null) && (i < DISCOVERY_RETRIES)) {
        i++;
        try {
            device = (RestServerSBDevice) getController().getDevice(deviceId);
        } catch (ClassCastException ccEx) {
            try {
                Thread.sleep(1);
            } catch (InterruptedException intEx) {
            // Just retry
            } finally {
                continue;
            }
        }
        // No device
        if (device == null) {
            // This method will add the device to the RestSBController
            this.getDeviceDetails(deviceId);
        }
    }
    if ((device == null) || (device.nics() == null)) {
        log.error("No ports available on {}", deviceId);
        return ImmutableList.copyOf(portDescriptions);
    }
    // Sorted list of NIC ports
    Set<NicDevice> nics = new TreeSet(device.nics());
    // Iterate through the NICs of this device to populate the list
    long portCounter = 0;
    for (NicDevice nic : nics) {
        // The port number of this NIC
        PortNumber portNumber = PortNumber.portNumber(++portCounter);
        // Include the name of this device as an annotation
        DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, nic.id());
        // Create a port description and add it to the list
        portDescriptions.add(new DefaultPortDescription(portNumber, nic.status(), nic.portType(), nic.speed(), annotations.build()));
        log.info("Port discovery on device {}: NIC {} is {} at {} Mbps", deviceId, nic.port(), nic.status() ? "up" : "down", nic.speed());
    }
    return ImmutableList.copyOf(portDescriptions);
}
#end_block

#method_before
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    // Get controller instance
    if (!init()) {
        return Lists.newArrayList();
    }
    // Retrieve the device ID
    DeviceId deviceId = handler.data().deviceId();
    checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    // Get port statistics for this device
    return getPortStatistics(deviceId);
}
#method_after
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    // Retrieve the device ID
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // Get port statistics for this device
    return getPortStatistics(deviceId);
}
#end_block

#method_before
@Override
public Collection<CpuStatistics> discoverCpuStatistics() {
    // Get controller instance
    if (!init()) {
        return Lists.newArrayList();
    }
    // Retrieve the device ID
    DeviceId deviceId = handler.data().deviceId();
    checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    // Get CPU statistics for this device
    return getCpuStatistics(deviceId);
}
#method_after
@Override
public Collection<CpuStatistics> discoverCpuStatistics() {
    // Retrieve the device ID
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // Get CPU statistics for this device
    return getCpuStatistics(deviceId);
}
#end_block

#method_before
@Override
public MonitoringStatistics discoverGlobalMonitoringStatistics() {
    // Get controller instance
    if (!init()) {
        return null;
    }
    // Retrieve the device ID
    DeviceId deviceId = handler.data().deviceId();
    checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    // Get global monitoring statistics for this device
    return getGlobalMonitoringStatistics(deviceId);
}
#method_after
@Override
public MonitoringStatistics discoverGlobalMonitoringStatistics() {
    // Retrieve the device ID
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // Get global monitoring statistics for this device
    return getGlobalMonitoringStatistics(deviceId);
}
#end_block

#method_before
private MonitoringStatistics getGlobalMonitoringStatistics(DeviceId deviceId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) this.controller.getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    checkNotNull(device, Common.DEVICE_NULL);
    // Hit the path that provides the server's global resources
    InputStream response = null;
    try {
        response = this.controller.get(deviceId, GLOBAL_STATS_URL, Common.JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Get high-level CPU statistics
    int busyCpus = objNode.path(CPU_STATS_BUSY_CPUS).asInt();
    int freeCpus = objNode.path(CPU_STATS_FREE_CPUS).asInt();
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get zero timing statistics
    TimingStatistics timinsgStats = getZeroTimingStatistics();
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats).build();
    monStats = statsBuilder.build();
    log.debug("Global monitoring statistics: {}", monStats.toString());
    return monStats;
}
#method_after
private MonitoringStatistics getGlobalMonitoringStatistics(DeviceId deviceId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    checkNotNull(device, DEVICE_NULL);
    // Hit the path that provides the server's global resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, GLOBAL_STATS_URL, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve global monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Get high-level CPU statistics
    int busyCpus = objNode.path(CPU_STATS_BUSY_CPUS).asInt();
    int freeCpus = objNode.path(CPU_STATS_FREE_CPUS).asInt();
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get zero timing statistics
    TimingStatistics timinsgStats = getZeroTimingStatistics();
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats).build();
    monStats = statsBuilder.build();
    log.debug("Global monitoring statistics: {}", monStats.toString());
    return monStats;
}
#end_block

#method_before
@Override
public MonitoringStatistics discoverMonitoringStatistics(URI tcId) {
    // Get controller instance
    if (!init()) {
        return null;
    }
    // Retrieve the device ID
    DeviceId deviceId = handler.data().deviceId();
    checkNotNull(deviceId, Common.DEVICE_ID_NULL);
    // Get resource-specific monitoring statistics for this device
    return getMonitoringStatistics(deviceId, tcId);
}
#method_after
@Override
public MonitoringStatistics discoverMonitoringStatistics(URI tcId) {
    // Retrieve the device ID
    DeviceId deviceId = getHandler().data().deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    // Get resource-specific monitoring statistics for this device
    return getMonitoringStatistics(deviceId, tcId);
}
#end_block

#method_before
private MonitoringStatistics getMonitoringStatistics(DeviceId deviceId, URI tcId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) this.controller.getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    checkNotNull(device, Common.DEVICE_NULL);
    // Create a resource-specific URL
    String scUrl = SERVICE_CHAINS_STATS_URL + "/" + tcId.toString();
    // Hit the path that provides the server's specific resources
    InputStream response = null;
    try {
        response = this.controller.get(deviceId, scUrl, Common.JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Get the ID of the traffic class
    String id = Common.get(jsonNode, PARAM_ID);
    // And verify that this is the traffic class we want to monitor
    if (!id.equals(tcId.toString())) {
        throw new RuntimeException("Failed to retrieve monitoring data for traffic class " + tcId + ". Traffic class ID does not agree.");
    }
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get timing statistics
    TimingStatistics timinsgStats = parseTimingStatistics(objNode);
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats).build();
    monStats = statsBuilder.build();
    log.debug("Monitoring statistics: {}", monStats.toString());
    return monStats;
}
#method_after
private MonitoringStatistics getMonitoringStatistics(DeviceId deviceId, URI tcId) {
    // Monitoring statistics to return
    MonitoringStatistics monStats = null;
    RestServerSBDevice device = null;
    try {
        device = (RestServerSBDevice) getController().getDevice(deviceId);
    } catch (ClassCastException ccEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    checkNotNull(device, DEVICE_NULL);
    // Create a resource-specific URL
    String scUrl = SERVICE_CHAINS_STATS_URL + "/" + tcId.toString();
    // Hit the path that provides the server's specific resources
    InputStream response = null;
    try {
        response = getController().get(deviceId, scUrl, JSON);
    } catch (ProcessingException pEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Load the JSON into objects
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> jsonMap = null;
    JsonNode jsonNode = null;
    ObjectNode objNode = null;
    try {
        jsonMap = mapper.readValue(response, Map.class);
        jsonNode = mapper.convertValue(jsonMap, JsonNode.class);
        objNode = (ObjectNode) jsonNode;
    } catch (IOException ioEx) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    if (jsonMap == null) {
        log.error("Failed to retrieve monitoring statistics from device {}", deviceId);
        return monStats;
    }
    // Get the ID of the traffic class
    String id = get(jsonNode, PARAM_ID);
    // And verify that this is the traffic class we want to monitor
    if (!id.equals(tcId.toString())) {
        throw new RuntimeException("Failed to retrieve monitoring data for traffic class " + tcId + ". Traffic class ID does not agree.");
    }
    // Get a list of CPU statistics per core
    Collection<CpuStatistics> cpuStats = parseCpuStatistics(deviceId, objNode);
    // Get a list of port statistics
    Collection<PortStatistics> nicStats = parseNicStatistics(deviceId, objNode);
    // Get timing statistics
    TimingStatistics timinsgStats = parseTimingStatistics(objNode);
    // Ready to construct the grand object
    DefaultMonitoringStatistics.Builder statsBuilder = DefaultMonitoringStatistics.builder();
    statsBuilder.setDeviceId(deviceId).setTimingStatistics(timinsgStats).setCpuStatistics(cpuStats).setNicStatistics(nicStats).build();
    monStats = statsBuilder.build();
    log.debug("Monitoring statistics: {}", monStats.toString());
    return monStats;
}
#end_block

#method_before
private Collection<PortStatistics> parseNicStatistics(DeviceId deviceId, JsonNode objNode) {
    Collection<PortStatistics> nicStats = Lists.newArrayList();
    if (objNode == null) {
        return nicStats;
    }
    JsonNode nicNode = objNode.path(PARAM_NICS);
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicId = Common.get(nn, NIC_PARAM_ID);
        int port = Integer.parseInt(nicId.replaceAll("\\D+", ""));
        long rxCount = nicObjNode.path(NIC_STATS_RX_COUNT).asLong();
        long rxBytes = nicObjNode.path(NIC_STATS_RX_BYTES).asLong();
        long rxDropped = nicObjNode.path(NIC_STATS_RX_DROPS).asLong();
        long rxErrors = nicObjNode.path(NIC_STATS_RX_ERRORS).asLong();
        long txCount = nicObjNode.path(NIC_STATS_TX_COUNT).asLong();
        long txBytes = nicObjNode.path(NIC_STATS_TX_BYTES).asLong();
        long txDropped = nicObjNode.path(NIC_STATS_TX_DROPS).asLong();
        long txErrors = nicObjNode.path(NIC_STATS_TX_ERRORS).asLong();
        // Incorporate these statistics into an object
        DefaultPortStatistics.Builder nicBuilder = DefaultPortStatistics.builder();
        nicBuilder.setDeviceId(deviceId).setPort(port).setPacketsReceived(rxCount).setPacketsSent(txCount).setBytesReceived(rxBytes).setBytesSent(txBytes).setPacketsRxDropped(rxDropped).setPacketsRxErrors(rxErrors).setPacketsTxDropped(txDropped).setPacketsTxErrors(txErrors).build();
        // We have statistics for this NIC
        nicStats.add(nicBuilder.build());
    }
    return nicStats;
}
#method_after
private Collection<PortStatistics> parseNicStatistics(DeviceId deviceId, JsonNode objNode) {
    Collection<PortStatistics> nicStats = Lists.newArrayList();
    if (objNode == null) {
        return nicStats;
    }
    JsonNode nicNode = objNode.path(PARAM_NICS);
    for (JsonNode nn : nicNode) {
        ObjectNode nicObjNode = (ObjectNode) nn;
        // All the NIC attributes
        String nicId = get(nn, NIC_PARAM_ID);
        int port = Integer.parseInt(nicId.replaceAll("\\D+", ""));
        long rxCount = nicObjNode.path(NIC_STATS_RX_COUNT).asLong();
        long rxBytes = nicObjNode.path(NIC_STATS_RX_BYTES).asLong();
        long rxDropped = nicObjNode.path(NIC_STATS_RX_DROPS).asLong();
        long rxErrors = nicObjNode.path(NIC_STATS_RX_ERRORS).asLong();
        long txCount = nicObjNode.path(NIC_STATS_TX_COUNT).asLong();
        long txBytes = nicObjNode.path(NIC_STATS_TX_BYTES).asLong();
        long txDropped = nicObjNode.path(NIC_STATS_TX_DROPS).asLong();
        long txErrors = nicObjNode.path(NIC_STATS_TX_ERRORS).asLong();
        // Incorporate these statistics into an object
        DefaultPortStatistics.Builder nicBuilder = DefaultPortStatistics.builder();
        nicBuilder.setDeviceId(deviceId).setPort(port).setPacketsReceived(rxCount).setPacketsSent(txCount).setBytesReceived(rxBytes).setBytesSent(txBytes).setPacketsRxDropped(rxDropped).setPacketsRxErrors(rxErrors).setPacketsTxDropped(txDropped).setPacketsTxErrors(txErrors).build();
        // We have statistics for this NIC
        nicStats.add(nicBuilder.build());
    }
    return nicStats;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("pwMode", pwMode()).add("sdTag", sdTag()).add("tunnelId", tunnelId()).add("pwLabel", pwLabel()).add("interCoLabel", interCoLabel()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("pwMode", pwMode()).add("sdTag", sdTag()).add("tunnelId", tunnelId()).add("pwLabel", pwLabel()).add("interCoLabel", interCoLabel()).add("transportVlan", transportVlan()).toString();
}
#end_block

#method_before
private VlanId determineTransportVlan(boolean spinePw) {
    if (!spinePw) {
        log.info("Transport vlan {} for pseudowire!", UNTAGGED_TRANSPORT_VLAN);
        return UNTAGGED_TRANSPORT_VLAN;
    } else {
        for (short i = transportVlanUpper; i > transportVlanLower; i--) {
            if (!vlanStore.contains(i)) {
                vlanStore.add(i);
                log.info("Transport vlan {} for pseudowire!", i);
                return VlanId.vlanId(i);
            }
        }
        log.info("No available transport vlan found, will be using {}!", UNTAGGED_TRANSPORT_VLAN);
        return UNTAGGED_TRANSPORT_VLAN;
    }
}
#method_after
private VlanId determineTransportVlan(boolean spinePw) {
    if (!spinePw) {
        log.info("Untagged transport with internal vlan {} for pseudowire!", UNTAGGED_TRANSPORT_VLAN);
        return UNTAGGED_TRANSPORT_VLAN;
    } else {
        for (short i = transportVlanUpper; i > transportVlanLower; i--) {
            VlanId vlanToUse = VlanId.vlanId((short) i);
            if (!vlanStore.contains(vlanToUse)) {
                vlanStore.add(vlanToUse);
                log.info("Transport vlan {} for pseudowire!", vlanToUse);
                return vlanToUse;
            }
        }
        log.info("No available transport vlan found, pseudowire traffic will be carried untagged " + "with internal vlan {}!", UNTAGGED_TRANSPORT_VLAN);
        return UNTAGGED_TRANSPORT_VLAN;
    }
}
#end_block

#method_before
private Result deployPseudoWireTerm(DefaultL2Tunnel l2Tunnel, ConnectPoint egress, VlanId egressVlan, Direction direction, boolean spinePw) {
    // We create the group relative to the termination.
    NextObjective.Builder nextObjectiveBuilder = createNextObjective(TERMINATION, egress, null, l2Tunnel, egress.deviceId(), spinePw);
    if (nextObjectiveBuilder == null) {
        return INTERNAL_ERROR;
    }
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(egressVlan).build();
    nextObjectiveBuilder.withMeta(metadata);
    int nextId = srManager.flowObjectiveService.allocateNextId();
    if (nextId < 0) {
        log.warn("Not able to allocate a next id for initiation");
        return INTERNAL_ERROR;
    }
    nextObjectiveBuilder.withId(nextId);
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    l2TerminationNextObjStore.put(key, nextObjectiveBuilder.add());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Termination l2 tunnel rule " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "termination l2 tunnel " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    NextObjective nextObjective = nextObjectiveBuilder.add(context);
    srManager.flowObjectiveService.next(egress.deviceId(), nextObjective);
    log.debug("Termination next objective for {} not found. Creating new NextObj with id={}", l2Tunnel.tunnelId(), nextObjective.id());
    // We create the flow relative to the termination.
    ForwardingObjective.Builder fwdBuilder = createTermFwdObjective(l2Tunnel.pwLabel(), l2Tunnel.tunnelId(), egress.port(), nextObjective.id());
    context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for tunnel termination {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate fwdrObj" + " for tunnel termination {}", l2Tunnel.tunnelId(), error));
    srManager.flowObjectiveService.forward(egress.deviceId(), fwdBuilder.add(context));
    log.debug("Creating new FwdObj for termination NextObj with id={} for tunnel {}", nextId, l2Tunnel.tunnelId());
    if (spinePw) {
        // determine the input port at the
        PortNumber inPort;
        if (egress.deviceId().equals(l2Tunnel.pathUsed().get(0).dst().deviceId())) {
            inPort = l2Tunnel.pathUsed().get(0).dst().port();
        } else {
            inPort = l2Tunnel.pathUsed().get(0).src().port();
        }
        MacAddress dstMac;
        try {
            dstMac = srManager.deviceConfiguration().getDeviceMac(egress.deviceId());
        } catch (Exception e) {
            log.info("Device not found in configuration, no programming of MAC address");
            dstMac = null;
        }
        log.info("Populating special filtering objective with vlan {} and port {}!", l2Tunnel.transportVlan(), inPort);
        FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
        context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        filteringObjectiveBuilder.withMeta(treatment.build());
        srManager.flowObjectiveService.filter(egress.deviceId(), filteringObjectiveBuilder.add(context));
        log.debug("Creating new special FiltObj for termination point with tunnel {} for port {}", l2Tunnel.tunnelId(), inPort);
    }
    return SUCCESS;
}
#method_after
private Result deployPseudoWireTerm(DefaultL2Tunnel l2Tunnel, ConnectPoint egress, VlanId egressVlan, Direction direction, boolean spinePw) {
    // We create the group relative to the termination.
    NextObjective.Builder nextObjectiveBuilder = createNextObjective(TERMINATION, egress, null, l2Tunnel, egress.deviceId(), spinePw);
    if (nextObjectiveBuilder == null) {
        return INTERNAL_ERROR;
    }
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(egressVlan).build();
    nextObjectiveBuilder.withMeta(metadata);
    int nextId = srManager.flowObjectiveService.allocateNextId();
    if (nextId < 0) {
        log.warn("Not able to allocate a next id for initiation");
        return INTERNAL_ERROR;
    }
    nextObjectiveBuilder.withId(nextId);
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    l2TerminationNextObjStore.put(key, nextObjectiveBuilder.add());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Termination l2 tunnel rule " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "termination l2 tunnel " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
    NextObjective nextObjective = nextObjectiveBuilder.add(context);
    srManager.flowObjectiveService.next(egress.deviceId(), nextObjective);
    log.debug("Termination next objective for {} not found. Creating new NextObj with id={}", l2Tunnel.tunnelId(), nextObjective.id());
    // We create the flow relative to the termination.
    ForwardingObjective.Builder fwdBuilder = createTermFwdObjective(l2Tunnel.pwLabel(), l2Tunnel.tunnelId(), egress.port(), nextObjective.id());
    context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for tunnel termination {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate fwdrObj" + " for tunnel termination {}", l2Tunnel.tunnelId(), error));
    srManager.flowObjectiveService.forward(egress.deviceId(), fwdBuilder.add(context));
    log.debug("Creating new FwdObj for termination NextObj with id={} for tunnel {}", nextId, l2Tunnel.tunnelId());
    if (spinePw) {
        // determine the input port at the
        PortNumber inPort;
        if (egress.deviceId().equals(l2Tunnel.pathUsed().get(0).dst().deviceId())) {
            inPort = l2Tunnel.pathUsed().get(0).dst().port();
        } else {
            inPort = l2Tunnel.pathUsed().get(0).src().port();
        }
        MacAddress dstMac;
        try {
            dstMac = srManager.deviceConfiguration().getDeviceMac(egress.deviceId());
        } catch (Exception e) {
            log.info("Device not found in configuration, no programming of MAC address");
            dstMac = null;
        }
        log.info("Populating filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {}", l2Tunnel.transportVlan(), inPort, dstMac);
        FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
        context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} populated", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        filteringObjectiveBuilder.withMeta(treatment.build());
        srManager.flowObjectiveService.filter(egress.deviceId(), filteringObjectiveBuilder.add(context));
        log.debug("Creating new special FiltObj for termination point with tunnel {} for port {}", l2Tunnel.tunnelId(), inPort);
    }
    return SUCCESS;
}
#end_block

#method_before
private FilteringObjective.Builder createNormalPipelineFiltObjective(PortNumber inPort, VlanId vlanId, MacAddress dstMac) {
    log.info("Creating special filtering objective for vlans {}", vlanId);
    FilteringObjective.Builder fwdBuilder = DefaultFilteringObjective.builder().withKey(Criteria.matchInPort(inPort)).addCondition(Criteria.matchVlanId(vlanId)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).permit().fromApp(srManager.appId());
    if (dstMac != null) {
        fwdBuilder.addCondition(Criteria.matchEthDst(dstMac));
    }
    return fwdBuilder;
}
#method_after
private FilteringObjective.Builder createNormalPipelineFiltObjective(PortNumber inPort, VlanId vlanId, MacAddress dstMac) {
    log.info("Creating filtering objective for pseudowire transport with vlan={}, port={}, mac={}", vlanId, inPort, dstMac);
    FilteringObjective.Builder fwdBuilder = DefaultFilteringObjective.builder().withKey(Criteria.matchInPort(inPort)).addCondition(Criteria.matchVlanId(vlanId)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY).permit().fromApp(srManager.appId());
    if (dstMac != null) {
        fwdBuilder.addCondition(Criteria.matchEthDst(dstMac));
    }
    return fwdBuilder;
}
#end_block

#method_before
private void tearDownPseudoWireTerm(DefaultL2Tunnel l2Tunnel, ConnectPoint egress, CompletableFuture<ObjectiveError> future, Direction direction) {
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    if (!l2TerminationNextObjStore.containsKey(key)) {
        log.info("Abort delete of {} for {}: next does not exist in the store", TERMINATION, key);
        if (future != null) {
            future.complete(null);
        }
        return;
    }
    NextObjective nextObjective = l2TerminationNextObjStore.get(key).value();
    ForwardingObjective.Builder fwdBuilder = createTermFwdObjective(l2Tunnel.pwLabel(), l2Tunnel.tunnelId(), egress.port(), nextObjective.id());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for {} {}, " + "direction {} removed", TERMINATION, l2Tunnel.tunnelId(), direction), (objective, error) -> log.warn("Failed to remove fwdObj " + "for {} {}" + ", direction {}", TERMINATION, l2Tunnel.tunnelId(), error, direction));
    srManager.flowObjectiveService.forward(egress.deviceId(), fwdBuilder.remove(context));
    // spine-spine pws
    if (!l2Tunnel.transportVlan().equals(UNTAGGED_TRANSPORT_VLAN)) {
        // determine the input port at the
        PortNumber inPort;
        if (egress.deviceId().equals(l2Tunnel.pathUsed().get(0).dst().deviceId())) {
            inPort = l2Tunnel.pathUsed().get(0).dst().port();
        } else {
            inPort = l2Tunnel.pathUsed().get(0).src().port();
        }
        MacAddress dstMac;
        try {
            dstMac = srManager.deviceConfiguration().getDeviceMac(egress.deviceId());
        } catch (Exception e) {
            log.info("Device not found in configuration, no programming of MAC address");
            dstMac = null;
        }
        log.info("Removing special filtering objective with vlan {} and port {}!", l2Tunnel.transportVlan(), inPort);
        FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
        context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} removed", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        filteringObjectiveBuilder.withMeta(treatment.build());
        srManager.flowObjectiveService.filter(egress.deviceId(), filteringObjectiveBuilder.remove(context));
        log.debug("Removing special FiltObj for termination point with tunnel {} for port {}", l2Tunnel.tunnelId(), inPort);
    }
    l2TerminationNextObjStore.remove(key);
    future.complete(null);
}
#method_after
private void tearDownPseudoWireTerm(DefaultL2Tunnel l2Tunnel, ConnectPoint egress, CompletableFuture<ObjectiveError> future, Direction direction) {
    String key = generateKey(l2Tunnel.tunnelId(), direction);
    if (!l2TerminationNextObjStore.containsKey(key)) {
        log.info("Abort delete of {} for {}: next does not exist in the store", TERMINATION, key);
        if (future != null) {
            future.complete(null);
        }
        return;
    }
    NextObjective nextObjective = l2TerminationNextObjStore.get(key).value();
    ForwardingObjective.Builder fwdBuilder = createTermFwdObjective(l2Tunnel.pwLabel(), l2Tunnel.tunnelId(), egress.port(), nextObjective.id());
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("FwdObj for {} {}, " + "direction {} removed", TERMINATION, l2Tunnel.tunnelId(), direction), (objective, error) -> log.warn("Failed to remove fwdObj " + "for {} {}" + ", direction {}", TERMINATION, l2Tunnel.tunnelId(), error, direction));
    srManager.flowObjectiveService.forward(egress.deviceId(), fwdBuilder.remove(context));
    // spine-spine pws
    if (!l2Tunnel.transportVlan().equals(UNTAGGED_TRANSPORT_VLAN)) {
        // determine the input port at the
        PortNumber inPort;
        if (egress.deviceId().equals(l2Tunnel.pathUsed().get(0).dst().deviceId())) {
            inPort = l2Tunnel.pathUsed().get(0).dst().port();
        } else {
            inPort = l2Tunnel.pathUsed().get(0).src().port();
        }
        MacAddress dstMac;
        try {
            dstMac = srManager.deviceConfiguration().getDeviceMac(egress.deviceId());
        } catch (Exception e) {
            log.info("Device not found in configuration, no programming of MAC address");
            dstMac = null;
        }
        log.info("Removing filtering objective for pseudowire transport" + " with vlan = {}, port = {}, mac = {}", l2Tunnel.transportVlan(), inPort, dstMac);
        FilteringObjective.Builder filteringObjectiveBuilder = createNormalPipelineFiltObjective(inPort, l2Tunnel.transportVlan(), dstMac);
        context = new DefaultObjectiveContext((objective) -> log.debug("Special filtObj for  " + "for {} removed", l2Tunnel.tunnelId()), (objective, error) -> log.warn("Failed to populate " + "special filtObj " + "rule for {}: {}", l2Tunnel.tunnelId(), error));
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        filteringObjectiveBuilder.withMeta(treatment.build());
        srManager.flowObjectiveService.filter(egress.deviceId(), filteringObjectiveBuilder.remove(context));
        log.debug("Removing special FiltObj for termination point with tunnel {} for port {}", l2Tunnel.tunnelId(), inPort);
    }
    l2TerminationNextObjStore.remove(key);
    future.complete(null);
}
#end_block

#method_before
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    OpenstackNode sourceNatGateway;
    sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.dataIp() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.vlanPortNum() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        setGatewayIcmpRule(gatewayIp, gNode.intgBridge(), install);
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#method_after
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    OpenstackNode sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.dataIp() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.vlanPortNum() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        setGatewayIcmpRule(gatewayIp, gNode.intgBridge(), install);
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#end_block

#method_before
private void setRulesToGateway(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    OpenstackNode sourceNatGateway;
    sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet.getIp4Prefix()).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    treatment = DefaultTrafficTreatment.builder().extension(buildExtension(deviceService, osNode.intgBridge(), sourceNatGateway.dataIp().getIp4Address()), osNode.intgBridge()).setOutput(osNode.tunnelPortNum()).build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), treatment, PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#method_after
private void setRulesToGateway(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    OpenstackNode sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet.getIp4Prefix()).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    treatment = DefaultTrafficTreatment.builder().extension(buildExtension(deviceService, osNode.intgBridge(), sourceNatGateway.dataIp().getIp4Address()), osNode.intgBridge()).setOutput(osNode.tunnelPortNum()).build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), treatment, PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
@Override
protected void execute() {
    OpenstackNetworkService service = AbstractShellCommand.get(OpenstackNetworkService.class);
    IpAddress externalPeerIpAddress = IpAddress.valueOf(IpAddress.Version.INET, Ip4Address.valueOf(ipAddress).toOctets());
    if (service.externalPeerRouters().isEmpty()) {
        print(NO_ELEMENT);
        return;
    } else if (!service.externalPeerRouters().stream().anyMatch(router -> router.externalPeerRouterIp().toString().equals(ipAddress))) {
        print(NO_ELEMENT);
        return;
    }
    try {
        if (vlanId.equals("None")) {
            service.updateExternalPeerRouterVlan(externalPeerIpAddress, VlanId.NONE);
        } else {
            service.updateExternalPeerRouterVlan(externalPeerIpAddress, VlanId.vlanId(vlanId));
        }
    } catch (IllegalArgumentException e) {
        log.error("Exception occured because of {}", e.toString());
    }
    print(FORMAT, "Router IP", "Mac Address", "VLAN ID");
    List<ExternalPeerRouter> routers = Lists.newArrayList(service.externalPeerRouters());
    for (ExternalPeerRouter router : routers) {
        print(FORMAT, router.externalPeerRouterIp(), router.externalPeerRouterMac().toString(), router.externalPeerRouterVlanId());
    }
}
#method_after
@Override
protected void execute() {
    OpenstackNetworkService service = AbstractShellCommand.get(OpenstackNetworkService.class);
    IpAddress externalPeerIpAddress = IpAddress.valueOf(IpAddress.Version.INET, Ip4Address.valueOf(ipAddress).toOctets());
    if (service.externalPeerRouters().isEmpty()) {
        print(NO_ELEMENT);
        return;
    } else if (service.externalPeerRouters().stream().noneMatch(router -> router.externalPeerRouterIp().toString().equals(ipAddress))) {
        print(NO_ELEMENT);
        return;
    }
    try {
        if (vlanId.equals(NONE)) {
            service.updateExternalPeerRouterVlan(externalPeerIpAddress, VlanId.NONE);
        } else {
            service.updateExternalPeerRouterVlan(externalPeerIpAddress, VlanId.vlanId(vlanId));
        }
    } catch (IllegalArgumentException e) {
        log.error("Exception occurred because of {}", e.toString());
    }
    print(FORMAT, "Router IP", "Mac Address", "VLAN ID");
    List<ExternalPeerRouter> routers = Lists.newArrayList(service.externalPeerRouters());
    for (ExternalPeerRouter router : routers) {
        print(FORMAT, router.externalPeerRouterIp(), router.externalPeerRouterMac().toString(), router.externalPeerRouterVlanId());
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultExternalPeerRouter) {
        DefaultExternalPeerRouter that = (DefaultExternalPeerRouter) obj;
        if (Objects.equals(externalPeerRouterIp, that.externalPeerRouterIp) && Objects.equals(externalPeerRouterMac, that.externalPeerRouterMac) && Objects.equals(externalPeerRouterVlanId, that.externalPeerRouterVlanId)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultExternalPeerRouter) {
        DefaultExternalPeerRouter that = (DefaultExternalPeerRouter) obj;
        return Objects.equals(externalPeerRouterIp, that.externalPeerRouterIp) && Objects.equals(externalPeerRouterMac, that.externalPeerRouterMac) && Objects.equals(externalPeerRouterVlanId, that.externalPeerRouterVlanId);
    }
    return false;
}
#end_block

#method_before
@Override
public Port port(org.onosproject.net.Port port) {
    String portName = port.annotations().value(PORT_NAME);
    if (Strings.isNullOrEmpty(portName)) {
        return null;
    }
    Optional<Port> osPort = osNetworkStore.ports().stream().filter(p -> p.getId().contains(portName.substring(3))).findFirst();
    return osPort.isPresent() ? osPort.get() : null;
}
#method_after
@Override
public Port port(org.onosproject.net.Port port) {
    String portName = port.annotations().value(PORT_NAME);
    if (Strings.isNullOrEmpty(portName)) {
        return null;
    }
    Optional<Port> osPort = osNetworkStore.ports().stream().filter(p -> p.getId().contains(portName.substring(3))).findFirst();
    return osPort.orElse(null);
}
#end_block

#method_before
@Override
public Set<Port> ports() {
    return osNetworkStore.ports();
}
#method_after
@Override
public Set<Port> ports() {
    return ImmutableSet.copyOf(osNetworkStore.ports());
}
#end_block

#method_before
@Override
public ExternalPeerRouter externalPeerRouter(IpAddress ipAddress) {
    if (externalPeerRouterMap.containsKey(ipAddress.toString())) {
        return externalPeerRouterMap.get(ipAddress.toString()).value();
    } else {
        return null;
    }
}
#method_after
@Override
public ExternalPeerRouter externalPeerRouter(IpAddress ipAddress) {
    if (externalPeerRouterMap.containsKey(ipAddress.toString())) {
        return externalPeerRouterMap.get(ipAddress.toString()).value();
    }
    return null;
}
#end_block

#method_before
@Override
public void deriveExternalPeerRouterMac(ExternalGateway externalGateway, Router router) {
    log.info("deriveExternalPeerRouterMac called");
    IpAddress sourceIp = getExternalGatewaySourceIp(externalGateway, router);
    IpAddress targetIp = getExternalPeerRouterIp(externalGateway);
    if (sourceIp == null || targetIp == null) {
        log.warn("Failed to derive external router mac address because source I} {} or target IP {} is null", sourceIp, targetIp);
        return;
    }
    if (externalPeerRouterMap.containsKey(targetIp.toString()) && !externalPeerRouterMap.get(targetIp.toString()).value().externalPeerRouterMac().equals(MacAddress.NONE)) {
        return;
    }
    MacAddress sourceMac = Constants.DEFAULT_GATEWAY_MAC;
    Ethernet ethRequest = ARP.buildArpRequest(sourceMac.toBytes(), sourceIp.toOctets(), targetIp.getIp4Address().toOctets(), VlanId.NO_VID);
    if (osNodeService.completeNodes(OpenstackNode.NodeType.GATEWAY).isEmpty()) {
        log.warn("There's no complete gateway");
        return;
    }
    OpenstackNode gatewayNode = osNodeService.completeNodes(OpenstackNode.NodeType.GATEWAY).stream().findFirst().orElse(null);
    String upLinkPort = gatewayNode.uplinkPort();
    org.onosproject.net.Port port = deviceService.getPorts(gatewayNode.intgBridge()).stream().filter(p -> Objects.equals(p.annotations().value(PORT_NAME), upLinkPort)).findAny().orElse(null);
    if (port == null) {
        log.warn("There's no uplink port for gateway node {}", gatewayNode.toString());
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(port.number()).build();
    packetService.emit(new DefaultOutboundPacket(gatewayNode.intgBridge(), treatment, ByteBuffer.wrap(ethRequest.serialize())));
    externalPeerRouterMap.put(targetIp.toString(), new DefaultExternalPeerRouter(targetIp, MacAddress.NONE, VlanId.NONE));
    log.info("Initializes external peer router map {}", externalPeerRouterMap.get(targetIp.toString()).value().toString());
}
#method_after
@Override
public void deriveExternalPeerRouterMac(ExternalGateway externalGateway, Router router) {
    log.info("deriveExternalPeerRouterMac called");
    IpAddress sourceIp = getExternalGatewaySourceIp(externalGateway, router);
    IpAddress targetIp = getExternalPeerRouterIp(externalGateway);
    if (sourceIp == null || targetIp == null) {
        log.warn("Failed to derive external router mac address because source IP {} or target IP {} is null", sourceIp, targetIp);
        return;
    }
    if (externalPeerRouterMap.containsKey(targetIp.toString()) && !externalPeerRouterMap.get(targetIp.toString()).value().externalPeerRouterMac().equals(MacAddress.NONE)) {
        return;
    }
    MacAddress sourceMac = Constants.DEFAULT_GATEWAY_MAC;
    Ethernet ethRequest = ARP.buildArpRequest(sourceMac.toBytes(), sourceIp.toOctets(), targetIp.toOctets(), VlanId.NO_VID);
    if (osNodeService.completeNodes(OpenstackNode.NodeType.GATEWAY).isEmpty()) {
        log.warn("There's no complete gateway");
        return;
    }
    OpenstackNode gatewayNode = osNodeService.completeNodes(OpenstackNode.NodeType.GATEWAY).stream().findFirst().orElse(null);
    if (gatewayNode == null) {
        return;
    }
    String upLinkPort = gatewayNode.uplinkPort();
    org.onosproject.net.Port port = deviceService.getPorts(gatewayNode.intgBridge()).stream().filter(p -> Objects.equals(p.annotations().value(PORT_NAME), upLinkPort)).findAny().orElse(null);
    if (port == null) {
        log.warn("There's no uplink port for gateway node {}", gatewayNode.toString());
        return;
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(port.number()).build();
    packetService.emit(new DefaultOutboundPacket(gatewayNode.intgBridge(), treatment, ByteBuffer.wrap(ethRequest.serialize())));
    externalPeerRouterMap.put(targetIp.toString(), new DefaultExternalPeerRouter(targetIp, MacAddress.NONE, VlanId.NONE));
    log.info("Initializes external peer router map with peer router IP {}", targetIp.toString());
}
#end_block

#method_before
@Override
public void deleteExternalPeerRouter(ExternalGateway externalGateway) {
    IpAddress targetIp = getExternalPeerRouterIp(externalGateway);
    if (externalPeerRouterMap.containsKey(targetIp.toString())) {
        externalPeerRouterMap.remove(targetIp.toString());
    }
}
#method_after
@Override
public void deleteExternalPeerRouter(ExternalGateway externalGateway) {
    IpAddress targetIp = getExternalPeerRouterIp(externalGateway);
    if (targetIp == null) {
        return;
    }
    if (externalPeerRouterMap.containsKey(targetIp.toString())) {
        externalPeerRouterMap.remove(targetIp.toString());
    }
}
#end_block

#method_before
private IpAddress getExternalGatewaySourceIp(ExternalGateway externalGateway, Router router) {
    Port exGatewayPort = ports(externalGateway.getNetworkId()).stream().filter(port -> Objects.equals(port.getDeviceId(), router.getId())).findAny().orElse(null);
    if (exGatewayPort == null) {
        log.warn("no external gateway port for router({})", router.getName());
        return null;
    }
    return IpAddress.valueOf(exGatewayPort.getFixedIps().stream().findFirst().get().getIpAddress());
}
#method_after
private IpAddress getExternalGatewaySourceIp(ExternalGateway externalGateway, Router router) {
    Port exGatewayPort = ports(externalGateway.getNetworkId()).stream().filter(port -> Objects.equals(port.getDeviceId(), router.getId())).findAny().orElse(null);
    if (exGatewayPort == null) {
        log.warn("no external gateway port for router({})", router.getName());
        return null;
    }
    IP ipAddress = exGatewayPort.getFixedIps().stream().findFirst().orElse(null);
    return ipAddress == null ? null : IpAddress.valueOf(ipAddress.getIpAddress());
}
#end_block

#method_before
@Override
public void updateExternalPeerRouterMac(IpAddress ipAddress, MacAddress macAddress) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> {
            return new DefaultExternalPeerRouter(ipAddress, macAddress, existing.externalPeerRouterVlanId());
        });
    } catch (Exception e) {
        log.error("Exception occured because of {}", e.toString());
    }
    log.info("Updated external peer router map {}", externalPeerRouterMap.get(ipAddress.toString()).value().toString());
}
#method_after
@Override
public void updateExternalPeerRouterMac(IpAddress ipAddress, MacAddress macAddress) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> new DefaultExternalPeerRouter(ipAddress, macAddress, existing.externalPeerRouterVlanId()));
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
    log.info("Updated external peer router map {}", externalPeerRouterMap.get(ipAddress.toString()).value().toString());
}
#end_block

#method_before
@Override
public void updateExternalPeerRouter(IpAddress ipAddress, MacAddress macAddress, VlanId vlanId) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> {
            return new DefaultExternalPeerRouter(ipAddress, macAddress, vlanId);
        });
    } catch (Exception e) {
        log.error("Exception occured because of {}", e.toString());
    }
}
#method_after
@Override
public void updateExternalPeerRouter(IpAddress ipAddress, MacAddress macAddress, VlanId vlanId) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> new DefaultExternalPeerRouter(ipAddress, macAddress, vlanId));
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
}
#end_block

#method_before
@Override
public MacAddress externalPeerRouterMac(ExternalGateway externalGateway) {
    IpAddress ipAddress = getExternalPeerRouterIp(externalGateway);
    if (externalPeerRouterMap.containsKey(ipAddress.toString())) {
        return externalPeerRouterMap.get(ipAddress.toString()).value().externalPeerRouterMac();
    } else {
        throw new NoSuchElementException();
    }
}
#method_after
@Override
public MacAddress externalPeerRouterMac(ExternalGateway externalGateway) {
    IpAddress ipAddress = getExternalPeerRouterIp(externalGateway);
    if (ipAddress == null) {
        return null;
    }
    if (externalPeerRouterMap.containsKey(ipAddress.toString())) {
        return externalPeerRouterMap.get(ipAddress.toString()).value().externalPeerRouterMac();
    } else {
        throw new NoSuchElementException();
    }
}
#end_block

#method_before
@Override
public void updateExternalPeerRouterVlan(IpAddress ipAddress, VlanId vlanId) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> {
            return new DefaultExternalPeerRouter(ipAddress, existing.externalPeerRouterMac(), vlanId);
        });
    } catch (Exception e) {
        log.error("Exception occured because of {}", e.toString());
    }
}
#method_after
@Override
public void updateExternalPeerRouterVlan(IpAddress ipAddress, VlanId vlanId) {
    try {
        externalPeerRouterMap.computeIfPresent(ipAddress.toString(), (id, existing) -> {
            return new DefaultExternalPeerRouter(ipAddress, existing.externalPeerRouterMac(), vlanId);
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}", e.toString());
    }
}
#end_block

#method_before
private void processArpPacket(PacketContext context, Ethernet ethernet) {
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        if (log.isTraceEnabled()) {
            log.trace("ARP request received from {} for {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
        }
        IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
        if (!isServiceIp(targetIp.getIp4Address())) {
            log.trace("Unknown target ARP request for {}, ignore it", targetIp);
            return;
        }
        MacAddress targetMac = Constants.DEFAULT_EXTERNAL_ROUTER_MAC;
        Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
        packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
        context.block();
    } else if (arp.getOpCode() == ARP.OP_REPLY) {
        PortNumber receivedPortNum = context.inPacket().receivedFrom().port();
        log.debug("ARP reply ip: {}, mac: {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
        try {
            if (receivedPortNum.equals(osNodeService.node(context.inPacket().receivedFrom().deviceId()).uplinkPortNum())) {
                osNetworkService.updateExternalPeerRouterMac(Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
            }
        } catch (Exception e) {
            log.error("Exception occured because of {}", e.toString());
        }
    }
}
#method_after
private void processArpPacket(PacketContext context, Ethernet ethernet) {
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() == ARP.OP_REQUEST) {
        if (log.isTraceEnabled()) {
            log.trace("ARP request received from {} for {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
        }
        IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
        if (!isServiceIp(targetIp.getIp4Address())) {
            log.trace("Unknown target ARP request for {}, ignore it", targetIp);
            return;
        }
        MacAddress targetMac = Constants.DEFAULT_EXTERNAL_ROUTER_MAC;
        Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
        packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
        context.block();
    } else if (arp.getOpCode() == ARP.OP_REPLY) {
        PortNumber receivedPortNum = context.inPacket().receivedFrom().port();
        log.debug("ARP reply ip: {}, mac: {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
        try {
            if (receivedPortNum.equals(osNodeService.node(context.inPacket().receivedFrom().deviceId()).uplinkPortNum())) {
                osNetworkService.updateExternalPeerRouterMac(Ip4Address.valueOf(arp.getSenderProtocolAddress()), MacAddress.valueOf(arp.getSenderHardwareAddress()));
            }
        } catch (Exception e) {
            log.error("Exception occurred because of {}", e.toString());
        }
    }
}
#end_block

#method_before
private void processSnatPacket(PacketContext context, Ethernet eth) {
    IPv4 iPacket = (IPv4) eth.getPayload();
    InboundPacket packetIn = context.inPacket();
    int patPort = getPortNum();
    InstancePort srcInstPort = instancePortService.instancePort(eth.getSourceMAC());
    if (srcInstPort == null) {
        log.error(ERR_PACKETIN + "source host(MAC:{}) does not exist", eth.getSourceMAC());
        return;
    }
    IpAddress srcIp = IpAddress.valueOf(iPacket.getSourceAddress());
    Subnet srcSubnet = getSourceSubnet(srcInstPort, srcIp);
    IpAddress externalGatewayIp = getExternalIp(srcSubnet);
    if (externalGatewayIp == null) {
        return;
    }
    MacAddress externalPeerRouterMac = getExternalPeerRouterMac(srcSubnet);
    populateSnatFlowRules(context.inPacket(), srcInstPort, TpPort.tpPort(patPort), externalGatewayIp, externalPeerRouterMac);
    packetOut(eth.duplicate(), packetIn.receivedFrom().deviceId(), patPort, externalGatewayIp, externalPeerRouterMac);
}
#method_after
private void processSnatPacket(PacketContext context, Ethernet eth) {
    IPv4 iPacket = (IPv4) eth.getPayload();
    InboundPacket packetIn = context.inPacket();
    int patPort = getPortNum();
    InstancePort srcInstPort = instancePortService.instancePort(eth.getSourceMAC());
    if (srcInstPort == null) {
        log.error(ERR_PACKETIN + "source host(MAC:{}) does not exist", eth.getSourceMAC());
        return;
    }
    IpAddress srcIp = IpAddress.valueOf(iPacket.getSourceAddress());
    Subnet srcSubnet = getSourceSubnet(srcInstPort, srcIp);
    IpAddress externalGatewayIp = getExternalIp(srcSubnet);
    if (externalGatewayIp == null) {
        return;
    }
    MacAddress externalPeerRouterMac = getExternalPeerRouterMac(srcSubnet);
    if (externalPeerRouterMac == null) {
        return;
    }
    populateSnatFlowRules(context.inPacket(), srcInstPort, TpPort.tpPort(patPort), externalGatewayIp, externalPeerRouterMac);
    packetOut(eth.duplicate(), packetIn.receivedFrom().deviceId(), patPort, externalGatewayIp, externalPeerRouterMac);
}
#end_block

#method_before
private MacAddress getExternalPeerRouterMac(Subnet srcSubnet) {
    RouterInterface osRouterIface = osRouterService.routerInterfaces().stream().filter(i -> Objects.equals(i.getSubnetId(), srcSubnet.getId())).findAny().orElse(null);
    if (osRouterIface == null) {
        // this subnet is not connected to the router
        log.trace(ERR_PACKETIN + "source subnet(ID:{}, CIDR:{}) has no router", srcSubnet.getId(), srcSubnet.getCidr());
        return null;
    }
    Router osRouter = osRouterService.router(osRouterIface.getId());
    if (osRouter.getExternalGatewayInfo() == null) {
        // this router does not have external connectivity
        log.trace(ERR_PACKETIN + "router({}) has no external gateway", osRouter.getName());
        return null;
    }
    ExternalGateway exGatewayInfo = osRouter.getExternalGatewayInfo();
    return osNetworkService.externalPeerRouterMac(exGatewayInfo);
}
#method_after
private MacAddress getExternalPeerRouterMac(Subnet srcSubnet) {
    RouterInterface osRouterIface = osRouterService.routerInterfaces().stream().filter(i -> Objects.equals(i.getSubnetId(), srcSubnet.getId())).findAny().orElse(null);
    if (osRouterIface == null) {
        // this subnet is not connected to the router
        log.trace(ERR_PACKETIN + "source subnet(ID:{}, CIDR:{}) has no router", srcSubnet.getId(), srcSubnet.getCidr());
        return null;
    }
    Router osRouter = osRouterService.router(osRouterIface.getId());
    if (osRouter == null) {
        return null;
    }
    if (osRouter.getExternalGatewayInfo() == null) {
        // this router does not have external connectivity
        log.trace(ERR_PACKETIN + "router({}) has no external gateway", osRouter.getName());
        return null;
    }
    ExternalGateway exGatewayInfo = osRouter.getExternalGatewayInfo();
    return osNetworkService.externalPeerRouterMac(exGatewayInfo);
}
#end_block

#method_before
@Override
protected void execute() {
    OpenstackNetworkService service = AbstractShellCommand.get(OpenstackNetworkService.class);
    IpAddress externalPeerIpAddress = IpAddress.valueOf(IpAddress.Version.INET, Ip4Address.valueOf(ipAddress).toOctets());
    if (service.externalPeerRouters().isEmpty()) {
        print(NO_ELEMENT);
        return;
    } else if (!service.externalPeerRouters().stream().anyMatch(router -> router.externalPeerRouterIp().toString().equals(ipAddress))) {
        print(NO_ELEMENT);
        return;
    }
    try {
        if (vlanId.equals("None")) {
            service.updateExternalPeerRouter(externalPeerIpAddress, MacAddress.valueOf(macAddress), VlanId.NONE);
        } else {
            service.updateExternalPeerRouter(externalPeerIpAddress, MacAddress.valueOf(macAddress), VlanId.vlanId(vlanId));
        }
    } catch (IllegalArgumentException e) {
        log.error("Exception occured because of {}", e.toString());
    }
    print(FORMAT, "Router IP", "Mac Address", "VLAN ID");
    List<ExternalPeerRouter> routers = Lists.newArrayList(service.externalPeerRouters());
    for (ExternalPeerRouter router : routers) {
        print(FORMAT, router.externalPeerRouterIp(), router.externalPeerRouterMac().toString(), router.externalPeerRouterVlanId());
    }
}
#method_after
@Override
protected void execute() {
    OpenstackNetworkService service = AbstractShellCommand.get(OpenstackNetworkService.class);
    IpAddress externalPeerIpAddress = IpAddress.valueOf(IpAddress.Version.INET, Ip4Address.valueOf(ipAddress).toOctets());
    if (service.externalPeerRouters().isEmpty()) {
        print(NO_ELEMENT);
        return;
    } else if (service.externalPeerRouters().stream().noneMatch(router -> router.externalPeerRouterIp().toString().equals(ipAddress))) {
        print(NO_ELEMENT);
        return;
    }
    try {
        if (vlanId.equals(NONE)) {
            service.updateExternalPeerRouter(externalPeerIpAddress, MacAddress.valueOf(macAddress), VlanId.NONE);
        } else {
            service.updateExternalPeerRouter(externalPeerIpAddress, MacAddress.valueOf(macAddress), VlanId.vlanId(vlanId));
        }
    } catch (IllegalArgumentException e) {
        log.error("Exception occurred because of {}", e.toString());
    }
    print(FORMAT, "Router IP", "Mac Address", "VLAN ID");
    List<ExternalPeerRouter> routers = Lists.newArrayList(service.externalPeerRouters());
    for (ExternalPeerRouter router : routers) {
        print(FORMAT, router.externalPeerRouterIp(), router.externalPeerRouterMac().toString(), router.externalPeerRouterVlanId());
    }
}
#end_block

#method_before
private void processRouteRemovedInternal(ConnectPoint source, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        log.debug("Processing route down for group {}", mcastIp);
        // Find out the ingress, transit and egress device of the affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        // Verify mastership on the operation
        if (!isMaster(source)) {
            log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
            return;
        }
        // If there are egress devices, sinks could be only on the ingress
        if (!egressDevices.isEmpty()) {
            egressDevices.forEach(deviceId -> removeGroupFromDevice(deviceId, mcastIp, assignedVlan(null)));
        }
        // Transit could be null
        if (transitDevice != null) {
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // Ingress device should be not null
        if (ingressDevice != null) {
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
        }
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processRouteRemovedInternal(ConnectPoint source, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        log.debug("Processing route down for group {}", mcastIp);
        // Find out the ingress, transit and egress device of the affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        // Verify leadership on the operation
        if (!isLeader(source)) {
            log.debug("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        // If there are egress devices, sinks could be only on the ingress
        if (!egressDevices.isEmpty()) {
            egressDevices.forEach(deviceId -> removeGroupFromDevice(deviceId, mcastIp, assignedVlan(null)));
        }
        // Transit could be null
        if (transitDevice != null) {
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // Ingress device should be not null
        if (ingressDevice != null) {
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
        }
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void processSinkRemovedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Verify mastership on the operation
        if (!isMaster(source)) {
            log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
            return;
        }
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Sink is on the same port of source. Abort");
                return;
            }
            removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            return;
        }
        // Process the egress device
        boolean isLast = removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
        if (isLast) {
            mcastRoleStore.remove(new McastStoreKey(mcastIp, sink.deviceId()));
        }
        // If this is the last sink on the device, also update upstream
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = Lists.newArrayList(mcastPath.get().links());
            Collections.reverse(links);
            for (Link link : links) {
                if (isLast) {
                    isLast = removePortFromDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, link.src().deviceId()));
                }
            }
        }
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processSinkRemovedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Verify leadership on the operation
        if (!isLeader(source)) {
            log.debug("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Skip {} since sink {} is on the same port of source {}. Abort", mcastIp, sink, source);
                return;
            }
            removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            return;
        }
        // Process the egress device
        boolean isLast = removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
        if (isLast) {
            mcastRoleStore.remove(new McastStoreKey(mcastIp, sink.deviceId()));
        }
        // If this is the last sink on the device, also update upstream
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = Lists.newArrayList(mcastPath.get().links());
            Collections.reverse(links);
            for (Link link : links) {
                if (isLast) {
                    isLast = removePortFromDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, link.src().deviceId()));
                }
            }
        }
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void processSinkAddedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Continue only when this instance is the master of source device
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            log.info("Skip {} due to lack of mastership of the source device {}", source.deviceId());
            return;
        }
        // Process the ingress device
        addFilterToDevice(source.deviceId(), source.port(), assignedVlan(source), mcastIp);
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Sink is on the same port of source. Abort");
                return;
            }
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.INGRESS);
            return;
        }
        // Find a path. If present, create/update groups and flows for each hop
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = mcastPath.get().links();
            checkState(links.size() == 2, "Path in leaf-spine topology should always be two hops: ", links);
            links.forEach(link -> {
                addPortToDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                addFilterToDevice(link.dst().deviceId(), link.dst().port(), assignedVlan(null), mcastIp);
            });
            // Process the egress device
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
            // Setup mcast roles
            mcastRoleStore.put(new McastStoreKey(mcastIp, source.deviceId()), McastRole.INGRESS);
            mcastRoleStore.put(new McastStoreKey(mcastIp, links.get(0).dst().deviceId()), McastRole.TRANSIT);
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.EGRESS);
        } else {
            log.warn("Unable to find a path from {} to {}. Abort sinkAdded", source.deviceId(), sink.deviceId());
        }
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processSinkAddedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Continue only when this instance is the master of source device
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            log.debug("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
            return;
        }
        // Process the ingress device
        addFilterToDevice(source.deviceId(), source.port(), assignedVlan(source), mcastIp);
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Skip {} since sink {} is on the same port of source {}. Abort", mcastIp, sink, source);
                return;
            }
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.INGRESS);
            return;
        }
        // Find a path. If present, create/update groups and flows for each hop
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = mcastPath.get().links();
            checkState(links.size() == 2, "Path in leaf-spine topology should always be two hops: ", links);
            links.forEach(link -> {
                addPortToDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                addFilterToDevice(link.dst().deviceId(), link.dst().port(), assignedVlan(null), mcastIp);
            });
            // Process the egress device
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
            // Setup mcast roles
            mcastRoleStore.put(new McastStoreKey(mcastIp, source.deviceId()), McastRole.INGRESS);
            mcastRoleStore.put(new McastStoreKey(mcastIp, links.get(0).dst().deviceId()), McastRole.TRANSIT);
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.EGRESS);
        } else {
            log.warn("Unable to find a path from {} to {}. Abort sinkAdded", source.deviceId(), sink.deviceId());
        }
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
protected void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if any of these info is missing
            if (ingressDevice == null || transitDevice == null || egressDevices == null || source == null) {
                log.warn("Missing ingress {}, transit {}, egress {} devices or source {}", ingressDevice, transitDevice, egressDevices, source);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.info("Skip {} due to lack of mastership of the source device {}", source.deviceId());
                return;
            }
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            // Remove transit-facing port on ingress device
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                mcastRoleStore.remove(new McastStoreKey(mcastIp, transitDevice));
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
protected void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if any of these info is missing
            if (ingressDevice == null || transitDevice == null || egressDevices == null || source == null) {
                log.warn("Missing ingress {}, transit {}, egress {} devices or source {}", ingressDevice, transitDevice, egressDevices, source);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.debug("Skip {} due to lack of mastership of the source device {}", source.deviceId());
                return;
            }
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            // Remove transit-facing port on ingress device
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                mcastRoleStore.remove(new McastStoreKey(mcastIp, transitDevice));
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
protected void processDeviceDown(DeviceId deviceDown) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get the mcast groups affected by the device going down
        getAffectedGroups(deviceDown).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Verify mastership on the operation
            if (!isMaster(source)) {
                log.info("Skip {} due to lack of mastership", mcastIp);
                return;
            }
            // If it exists, we have to remove it in any case
            if (transitDevice != null) {
                // Remove entire transit
                removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            }
            // If the ingress is down
            if (ingressDevice.equals(deviceDown)) {
                // Remove entire ingress
                removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
                // If other sinks different from the ingress exist
                if (!egressDevices.isEmpty()) {
                    // Remove all the remaining egress
                    egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
                }
            } else {
                // Egress or transit could be down at this point
                // Get the ingress-transit port if it exists
                PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
                if (ingressTransitPort != null) {
                    // Remove transit-facing port on ingress device
                    removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                }
                // One of the egress device is down
                if (egressDevices.contains(deviceDown)) {
                    // Remove entire device down
                    removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                    // Remove the device down from egress
                    egressDevices.remove(deviceDown);
                    // If there are no more egress and ingress does not have sinks
                    if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                        // Remove entire ingress
                        mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                        // We have done
                        return;
                    }
                }
                // Construct a new path for each egress device
                egressDevices.forEach(egressDevice -> {
                    Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                    // If there is a new path
                    if (mcastPath.isPresent()) {
                        // Let's install the new mcast path for this egress
                        installPath(mcastIp, source, mcastPath.get());
                    } else {
                        // We were not able to find an alternative path for this egress
                        log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                        removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                    }
                });
            }
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
protected void processDeviceDown(DeviceId deviceDown) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get the mcast groups affected by the device going down
        getAffectedGroups(deviceDown).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Verify leadership on the operation
            if (!isLeader(source)) {
                log.debug("Skip {} due to lack of leadership", mcastIp);
                return;
            }
            // If it exists, we have to remove it in any case
            if (transitDevice != null) {
                // Remove entire transit
                removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            }
            // If the ingress is down
            if (ingressDevice.equals(deviceDown)) {
                // Remove entire ingress
                removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
                // If other sinks different from the ingress exist
                if (!egressDevices.isEmpty()) {
                    // Remove all the remaining egress
                    egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
                }
            } else {
                // Egress or transit could be down at this point
                // Get the ingress-transit port if it exists
                PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
                if (ingressTransitPort != null) {
                    // Remove transit-facing port on ingress device
                    removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                }
                // One of the egress device is down
                if (egressDevices.contains(deviceDown)) {
                    // Remove entire device down
                    removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                    // Remove the device down from egress
                    egressDevices.remove(deviceDown);
                    // If there are no more egress and ingress does not have sinks
                    if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                        // Remove entire ingress
                        mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                        // We have done
                        return;
                    }
                }
                // Construct a new path for each egress device
                egressDevices.forEach(egressDevice -> {
                    Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                    // If there is a new path
                    if (mcastPath.isPresent()) {
                        // Let's install the new mcast path for this egress
                        installPath(mcastIp, source, mcastPath.get());
                    } else {
                        // We were not able to find an alternative path for this egress
                        log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                        removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                    }
                });
            }
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void addPortToDevice(DeviceId deviceId, PortNumber port, IpAddress mcastIp, VlanId assignedVlan) {
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, deviceId);
    ImmutableSet.Builder<PortNumber> portBuilder = ImmutableSet.builder();
    NextObjective newNextObj;
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        // First time someone request this mcast group via this device
        portBuilder.add(port);
        // New nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), null).add();
        // Store the new port
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
    } else {
        // This device already serves some subscribers of this mcast group
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        // Stop if the port is already in the nextobj
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        if (existingPorts.contains(port)) {
            log.info("NextObj for {}/{} already exists. Abort", deviceId, port);
            return;
        }
        // Let's add the port and reuse the previous one
        portBuilder.addAll(existingPorts).add(port).build();
        // Reuse previous nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
        // Store the final next objective and send only the difference to the driver
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
        // Add just the new port
        portBuilder = ImmutableSet.builder();
        portBuilder.add(port);
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
    }
    // Create, store and apply the new nextObj and fwdObj
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add {} on {}/{}, vlan {}", mcastIp, deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add {} on {}/{}, vlan {}: {}", mcastIp, deviceId, port.toLong(), assignedVlan, error));
    ForwardingObjective fwdObj = fwdObjBuilder(mcastIp, assignedVlan, newNextObj.id()).add(context);
    srManager.flowObjectiveService.next(deviceId, newNextObj);
    srManager.flowObjectiveService.forward(deviceId, fwdObj);
}
#method_after
private void addPortToDevice(DeviceId deviceId, PortNumber port, IpAddress mcastIp, VlanId assignedVlan) {
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, deviceId);
    ImmutableSet.Builder<PortNumber> portBuilder = ImmutableSet.builder();
    NextObjective newNextObj;
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        // First time someone request this mcast group via this device
        portBuilder.add(port);
        // New nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), null).add();
        // Store the new port
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
    } else {
        // This device already serves some subscribers of this mcast group
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        // Stop if the port is already in the nextobj
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        if (existingPorts.contains(port)) {
            log.info("NextObj for {}/{} already exists. Abort", deviceId, port);
            return;
        }
        // Let's add the port and reuse the previous one
        portBuilder.addAll(existingPorts).add(port);
        // Reuse previous nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
        // Store the final next objective and send only the difference to the driver
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
        // Add just the new port
        portBuilder = ImmutableSet.builder();
        portBuilder.add(port);
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
    }
    // Create, store and apply the new nextObj and fwdObj
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add {} on {}/{}, vlan {}", mcastIp, deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add {} on {}/{}, vlan {}: {}", mcastIp, deviceId, port.toLong(), assignedVlan, error));
    ForwardingObjective fwdObj = fwdObjBuilder(mcastIp, assignedVlan, newNextObj.id()).add(context);
    srManager.flowObjectiveService.next(deviceId, newNextObj);
    srManager.flowObjectiveService.forward(deviceId, fwdObj);
}
#end_block

#method_before
@Override
public void run() {
    // Verify if the Mcast has been stable for MCAST_STABLITY_THRESHOLD
    if (!isMcastStable()) {
        return;
    }
    // Acquires lock
    mcastLock();
    try {
        // Iterates over the routes and verify the related next objectives
        srManager.multicastRouteService.getRoutes().stream().map(McastRoute::group).forEach(mcastIp -> {
            log.debug("Running mcast buckets corrector for mcast group: {}", mcastIp);
            // For each group we get current information in the store
            // and issue a check of the next objectives in place
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if ingress device or source of this group are missing
            if (ingressDevice == null || source == null) {
                log.warn("Unable to run buckets corrector. " + "Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.info("Unable to run buckets corrector. " + "Skip {} due to lack of mastership " + "of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Create the set of the devices to be processed
            ImmutableSet.Builder<DeviceId> devicesBuilder = ImmutableSet.builder();
            devicesBuilder.add(ingressDevice);
            if (transitDevice != null) {
                devicesBuilder.add(transitDevice);
            }
            if (!egressDevices.isEmpty()) {
                devicesBuilder.addAll(egressDevices);
            }
            Set<DeviceId> devicesToProcess = devicesBuilder.build();
            // Iterate over the devices
            devicesToProcess.forEach(deviceId -> {
                McastStoreKey currentKey = new McastStoreKey(mcastIp, deviceId);
                // If next exists in our store verify related next objective
                if (mcastNextObjStore.containsKey(currentKey)) {
                    NextObjective currentNext = mcastNextObjStore.get(currentKey).value();
                    // Get current ports
                    Set<PortNumber> currentPorts = getPorts(currentNext.next());
                    // Rebuild the next objective
                    currentNext = nextObjBuilder(mcastIp, assignedVlan(deviceId.equals(source.deviceId()) ? source : null), currentPorts, currentNext.id()).verify();
                    // Send to the flowobjective service
                    srManager.flowObjectiveService.next(deviceId, currentNext);
                } else {
                    log.warn("Unable to run buckets corrector." + "Missing next for {} and group {}", deviceId, mcastIp);
                }
            });
        });
    } finally {
        // Finally, it releases the lock
        mcastUnlock();
    }
}
#method_after
@Override
public void run() {
    // Verify if the Mcast has been stable for MCAST_STABLITY_THRESHOLD
    if (!isMcastStable()) {
        return;
    }
    // Acquires lock
    mcastLock();
    try {
        // Iterates over the routes and verify the related next objectives
        srManager.multicastRouteService.getRoutes().stream().map(McastRoute::group).forEach(mcastIp -> {
            log.trace("Running mcast buckets corrector for mcast group: {}", mcastIp);
            // For each group we get current information in the store
            // and issue a check of the next objectives in place
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if ingress device or source of this group are missing
            if (ingressDevice == null || source == null) {
                log.warn("Unable to run buckets corrector. " + "Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.trace("Unable to run buckets corrector. " + "Skip {} due to lack of mastership " + "of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Create the set of the devices to be processed
            ImmutableSet.Builder<DeviceId> devicesBuilder = ImmutableSet.builder();
            devicesBuilder.add(ingressDevice);
            if (transitDevice != null) {
                devicesBuilder.add(transitDevice);
            }
            if (!egressDevices.isEmpty()) {
                devicesBuilder.addAll(egressDevices);
            }
            Set<DeviceId> devicesToProcess = devicesBuilder.build();
            // Iterate over the devices
            devicesToProcess.forEach(deviceId -> {
                McastStoreKey currentKey = new McastStoreKey(mcastIp, deviceId);
                // If next exists in our store verify related next objective
                if (mcastNextObjStore.containsKey(currentKey)) {
                    NextObjective currentNext = mcastNextObjStore.get(currentKey).value();
                    // Get current ports
                    Set<PortNumber> currentPorts = getPorts(currentNext.next());
                    // Rebuild the next objective
                    currentNext = nextObjBuilder(mcastIp, assignedVlan(deviceId.equals(source.deviceId()) ? source : null), currentPorts, currentNext.id()).verify();
                    // Send to the flowobjective service
                    srManager.flowObjectiveService.next(deviceId, currentNext);
                } else {
                    log.warn("Unable to run buckets corrector." + "Missing next for {} and group {}", deviceId, mcastIp);
                }
            });
        });
    } finally {
        // Finally, it releases the lock
        mcastUnlock();
    }
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    l2TunnelHandler.init();
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    l2TunnelHandler.init();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(pwaasConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(pwaasConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void run() {
    try {
        while (true) {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                // Note: do not update seenLinks here, otherwise every
                // link, even one seen for the first time, will be appear
                // to be a previously seen link
                linkHandler.processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                linkHandler.processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#method_after
@Override
public void run() {
    while (true) {
        try {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                linkHandler.processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                linkHandler.processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        } catch (Exception e) {
            log.error("SegmentRouting event handler thread thrown an exception: {}", e.getMessage(), e);
        }
    }
}
#end_block

#method_before
private void processDeviceRemoved(Device device) {
    dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> dsNextObjStore.remove(entry.getKey()));
    vlanNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> vlanNextObjStore.remove(entry.getKey()));
    portNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> portNextObjStore.remove(entry.getKey()));
    linkHandler.processDeviceRemoved(device);
    DefaultGroupHandler gh = groupHandlerMap.remove(device.id());
    if (gh != null) {
        gh.shutdown();
    }
    defaultRoutingHandler.purgeEcmpGraph(device.id());
    // Note that a switch going down is associated with all of its links
    // going down as well, but it is treated as a single switch down event
    // while the link-downs are ignored.
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, null, device.id());
    mcastHandler.processDeviceDown(device.id());
    xConnectHandler.removeDevice(device.id());
}
#method_after
private void processDeviceRemoved(Device device) {
    dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> dsNextObjStore.remove(entry.getKey()));
    vlanNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> vlanNextObjStore.remove(entry.getKey()));
    portNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> portNextObjStore.remove(entry.getKey()));
    linkHandler.processDeviceRemoved(device);
    DefaultGroupHandler gh = groupHandlerMap.remove(device.id());
    if (gh != null) {
        gh.shutdown();
    }
    // Note that a switch going down is associated with all of its links
    // going down as well, but it is treated as a single switch down event
    // while the link-downs are ignored.
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, null, device.id());
    defaultRoutingHandler.purgeEcmpGraph(device.id());
    mcastHandler.processDeviceDown(device.id());
    xConnectHandler.removeDevice(device.id());
}
#end_block

#method_before
private void createOrUpdateDeviceConfiguration() {
    if (deviceConfiguration == null) {
        deviceConfiguration = new DeviceConfiguration(this);
    } else {
        deviceConfiguration.updateConfig();
    }
}
#method_after
private void createOrUpdateDeviceConfiguration() {
    if (deviceConfiguration == null) {
        log.info("Creating new DeviceConfiguration");
        deviceConfiguration = new DeviceConfiguration(this);
    } else {
        log.info("Updating DeviceConfiguration");
        deviceConfiguration.updateConfig();
    }
}
#end_block

#method_before
void configureNetwork() {
    createOrUpdateDeviceConfiguration();
    arpHandler = new ArpHandler(srManager);
    icmpHandler = new IcmpHandler(srManager);
    ipHandler = new IpHandler(srManager);
    routingRulePopulator = new RoutingRulePopulator(srManager);
    defaultRoutingHandler = new DefaultRoutingHandler(srManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    // add a small delay to absorb multiple network config added notifications
    if (!programmingScheduled.get()) {
        programmingScheduled.set(true);
        executorService.schedule(new ConfigChange(), PROGRAM_DELAY, TimeUnit.SECONDS);
    }
    mcastHandler.init();
}
#method_after
void configureNetwork() {
    log.info("Configuring network ...");
    createOrUpdateDeviceConfiguration();
    arpHandler = new ArpHandler(srManager);
    icmpHandler = new IcmpHandler(srManager);
    ipHandler = new IpHandler(srManager);
    routingRulePopulator = new RoutingRulePopulator(srManager);
    defaultRoutingHandler = new DefaultRoutingHandler(srManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    // add a small delay to absorb multiple network config added notifications
    if (!programmingScheduled.get()) {
        log.info("Buffering config calls for {} secs", PROGRAM_DELAY);
        programmingScheduled.set(true);
        executorService.schedule(new ConfigChange(), PROGRAM_DELAY, TimeUnit.SECONDS);
    }
    mcastHandler.init();
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Device Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(InterfaceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Interface Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Interface Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // Following code will be uncommented when [CORD-634] is fully implemented.
                // [CORD-634] Add dynamic config support for interfaces
                updateInterface((InterfaceConfig) event.config().get(), (InterfaceConfig) event.prevConfig().get());
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
        configureNetwork();
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(PwaasConfig.class)) {
        checkState(l2TunnelHandler != null, "L2TunnelHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                l2TunnelHandler.processPwaasConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                l2TunnelHandler.processPwaasConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                l2TunnelHandler.processPwaasConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Device Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(InterfaceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Interface Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Interface Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // Following code will be uncommented when [CORD-634] is fully implemented.
                // [CORD-634] Add dynamic config support for interfaces
                updateInterface((InterfaceConfig) event.config().get(), (InterfaceConfig) event.prevConfig().get());
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
        log.info("App config event .. configuring network");
        configureNetwork();
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(PwaasConfig.class)) {
        checkState(l2TunnelHandler != null, "L2TunnelHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                l2TunnelHandler.processPwaasConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                l2TunnelHandler.processPwaasConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                l2TunnelHandler.processPwaasConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class) || event.configClass().equals(SegmentRoutingAppConfig.class) || event.configClass().equals(InterfaceConfig.class) || event.configClass().equals(XConnectConfig.class) || event.configClass().equals(PwaasConfig.class)) {
        return true;
    }
    log.debug("Ignore irrelevant event class {}", event.configClass().getName());
    return false;
}
#method_after
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.type() == CONFIG_REGISTERED || event.type() == CONFIG_UNREGISTERED) {
        log.debug("Ignore event {} due to type mismatch", event);
        return false;
    }
    if (!event.configClass().equals(SegmentRoutingDeviceConfig.class) && !event.configClass().equals(SegmentRoutingAppConfig.class) && !event.configClass().equals(InterfaceConfig.class) && !event.configClass().equals(XConnectConfig.class) && !event.configClass().equals(PwaasConfig.class)) {
        log.debug("Ignore event {} due to class mismatch", event);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void run() {
    programmingScheduled.set(false);
    for (Device device : deviceService.getDevices()) {
        processDeviceAdded(device);
    }
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
@Override
public void run() {
    programmingScheduled.set(false);
    log.info("Reacting to config changes after buffer delay");
    for (Device device : deviceService.getDevices()) {
        processDeviceAdded(device);
    }
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
private void processSimpleNextObjective(NextObjective nextObj) {
    TrafficTreatment treatment = nextObj.next().iterator().next();
    // determine if plain L2 or L3->L2 or MPLS Swap -> MPLS Interface -> L2
    boolean plainL2 = true;
    boolean mplsSwap = false;
    MplsLabel mplsLabel = null;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            if (l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_DST || l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_SRC) {
                plainL2 = false;
            }
            // a MPLS Swap group before the MPLS Interface Group
            if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                mplsSwap = true;
                mplsLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
            }
        }
    }
    if (plainL2) {
        createL2InterfaceGroup(nextObj);
        return;
    }
    boolean isMpls = false;
    // In order to understand if it is a pseudo wire related
    // next objective we look for the tunnel id in the meta.
    boolean isPw = false;
    if (nextObj.meta() != null) {
        isMpls = isNotMplsBos(nextObj.meta());
        TunnelIdCriterion tunnelIdCriterion = (TunnelIdCriterion) nextObj.meta().getCriterion(TUNNEL_ID);
        if (tunnelIdCriterion != null) {
            isPw = true;
        }
    }
    if (mplsSwap) {
        log.debug("Creating a MPLS Swap - MPLS Interface - L2 Interface group chain.");
        // break up simple next objective to GroupChain objects
        GroupInfo groupInfo = createL2L3Chain(treatment, nextObj.id(), nextObj.appId(), true, nextObj.meta());
        if (groupInfo == null) {
            log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
            fail(nextObj, ObjectiveError.BADPARAMS);
            return;
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
        gkeyChain.addFirst(groupInfo.nextGroupDesc().appCookie());
        // creating the mpls swap group and adding it to the chain
        GroupChainElem groupChainElem;
        GroupKey groupKey;
        GroupDescription groupDescription;
        int nextGid = groupInfo.nextGroupDesc().givenGroupId();
        int index = getNextAvailableIndex();
        groupDescription = createMplsSwap(nextGid, OfdpaMplsGroupSubType.MPLS_SWAP_LABEL, index, mplsLabel, nextObj.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        // create a new List from singletonList that is mutable
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObj);
        updatePendingNextObjective(groupInfo.nextGroupDesc().appCookie(), ofdpaGrp);
        // now we are ready to send the l2 groupDescription (inner), as all the stores
        // that will get async replies have been updated. By waiting to update
        // the stores, we prevent nasty race conditions.
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    } else if (!isPw) {
        // break up simple next objective to GroupChain objects
        GroupInfo groupInfo = createL2L3Chain(treatment, nextObj.id(), nextObj.appId(), isMpls, nextObj.meta());
        if (groupInfo == null) {
            log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
            fail(nextObj, ObjectiveError.BADPARAMS);
            return;
        }
        // create object for local and distributed storage
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
        gkeyChain.addFirst(groupInfo.nextGroupDesc().appCookie());
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObj);
        // store l3groupkey with the ofdpaNextGroup for the nextObjective that depends on it
        updatePendingNextObjective(groupInfo.nextGroupDesc().appCookie(), ofdpaGrp);
        // now we are ready to send the l2 groupDescription (inner), as all the stores
        // that will get async replies have been updated. By waiting to update
        // the stores, we prevent nasty race conditions.
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    } else {
        // We handle the pseudo wire with a different a procedure.
        // This procedure is meant to handle both initiation and
        // termination of the pseudo wire.
        processPwNextObjective(nextObj);
    }
}
#method_after
private void processSimpleNextObjective(NextObjective nextObj) {
    TrafficTreatment treatment = nextObj.next().iterator().next();
    // determine if plain L2 or L3->L2 or MPLS Swap -> MPLS Interface -> L2
    boolean plainL2 = true;
    boolean mplsSwap = false;
    MplsLabel mplsLabel = null;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            if (l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_DST || l2ins.subtype() == L2ModificationInstruction.L2SubType.ETH_SRC) {
                plainL2 = false;
            }
            // a MPLS Swap group before the MPLS Interface Group
            if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                mplsSwap = true;
                mplsLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
            }
        }
    }
    if (plainL2) {
        createL2InterfaceGroup(nextObj);
        return;
    }
    boolean isMpls = false;
    // In order to understand if it is a pseudo wire related
    // next objective we look for the tunnel id in the meta.
    boolean isPw = false;
    if (nextObj.meta() != null) {
        isMpls = isNotMplsBos(nextObj.meta());
        TunnelIdCriterion tunnelIdCriterion = (TunnelIdCriterion) nextObj.meta().getCriterion(TUNNEL_ID);
        if (tunnelIdCriterion != null) {
            isPw = true;
        }
    }
    if (mplsSwap && !isPw) {
        log.debug("Creating a MPLS Swap - MPLS Interface - L2 Interface group chain.");
        // break up simple next objective to GroupChain objects
        GroupInfo groupInfo = createL2L3Chain(treatment, nextObj.id(), nextObj.appId(), true, nextObj.meta());
        if (groupInfo == null) {
            log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
            fail(nextObj, ObjectiveError.BADPARAMS);
            return;
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
        gkeyChain.addFirst(groupInfo.nextGroupDesc().appCookie());
        // creating the mpls swap group and adding it to the chain
        GroupChainElem groupChainElem;
        GroupKey groupKey;
        GroupDescription groupDescription;
        int nextGid = groupInfo.nextGroupDesc().givenGroupId();
        int index = getNextAvailableIndex();
        groupDescription = createMplsSwap(nextGid, OfdpaMplsGroupSubType.MPLS_SWAP_LABEL, index, mplsLabel, nextObj.appId());
        groupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(index));
        groupChainElem = new GroupChainElem(groupDescription, 1, false, deviceId);
        updatePendingGroups(groupInfo.nextGroupDesc().appCookie(), groupChainElem);
        gkeyChain.addFirst(groupKey);
        // create a new List from singletonList that is mutable
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObj);
        updatePendingNextObjective(groupInfo.nextGroupDesc().appCookie(), ofdpaGrp);
        // now we are ready to send the l2 groupDescription (inner), as all the stores
        // that will get async replies have been updated. By waiting to update
        // the stores, we prevent nasty race conditions.
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    } else if (!isPw) {
        // break up simple next objective to GroupChain objects
        GroupInfo groupInfo = createL2L3Chain(treatment, nextObj.id(), nextObj.appId(), isMpls, nextObj.meta());
        if (groupInfo == null) {
            log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
            fail(nextObj, ObjectiveError.BADPARAMS);
            return;
        }
        // create object for local and distributed storage
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
        gkeyChain.addFirst(groupInfo.nextGroupDesc().appCookie());
        OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(Collections.singletonList(gkeyChain), nextObj);
        // store l3groupkey with the ofdpaNextGroup for the nextObjective that depends on it
        updatePendingNextObjective(groupInfo.nextGroupDesc().appCookie(), ofdpaGrp);
        // now we are ready to send the l2 groupDescription (inner), as all the stores
        // that will get async replies have been updated. By waiting to update
        // the stores, we prevent nasty race conditions.
        groupService.addGroup(groupInfo.innerMostGroupDesc());
    } else {
        // We handle the pseudo wire with a different a procedure.
        // This procedure is meant to handle both initiation and
        // termination of the pseudo wire.
        processPwNextObjective(nextObj);
    }
}
#end_block

#method_before
protected void verifyGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() == NextObjective.Type.SIMPLE) {
        log.warn("verification not supported for indirect group");
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    log.debug("Call to verify device:{} nextId:{}", deviceId, nextObjective.id());
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<TrafficTreatment> bucketsToCreate = Lists.newArrayList();
    List<Integer> indicesToRemove = Lists.newArrayList();
    // to detect buckets to create and duplicated buckets (to be removed)
    for (TrafficTreatment bkt : nextObjective.next()) {
        PortNumber portNumber = readOutPortFromTreatment(bkt);
        int label = readLabelFromTreatment(bkt);
        if (portNumber == null) {
            log.warn("treatment {} of next objective {} has no outport.. " + "cannot remove bucket from group in dev: {}", bkt, nextObjective.id(), deviceId);
            fail(nextObjective, ObjectiveError.BADPARAMS);
            return;
        }
        List<Integer> existing = existingPortAndLabel(allActiveKeys, groupService, deviceId, portNumber, label);
        if (existing.isEmpty()) {
            // if it doesn't exist, mark this bucket for creation
            bucketsToCreate.add(bkt);
        }
        if (existing.size() > 1) {
            // if it exists but there are duplicates, mark the others for removal
            existing.remove(0);
            indicesToRemove.addAll(existing);
        }
    }
    // has more buckets (no duplicated) respect to the next objective
    if (allActiveKeys.size() > nextObjective.next().size()) {
        log.warn("Mismatch detected between next and flowobjstore for device {}: " + "nextId:{}, nextObjective-size:{} next-size:{} .. correcting", deviceId, nextObjective.id(), nextObjective.next().size(), allActiveKeys.size());
        List<Integer> otherIndices = indicesToRemoveFromNextGroup(allActiveKeys, nextObjective, groupService, deviceId);
        // Filter out the indices not present
        otherIndices = otherIndices.stream().filter(index -> !indicesToRemove.contains(index)).collect(Collectors.toList());
        // Add all to the final list
        indicesToRemove.addAll(otherIndices);
    }
    log.debug("Buckets to create {}", bucketsToCreate);
    log.debug("Indices to remove {}", indicesToRemove);
    if (!bucketsToCreate.isEmpty()) {
        log.info("creating {} buckets as part of nextId: {} verification", bucketsToCreate.size(), nextObjective.id());
        // create a nextObjective only with these buckets
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextObjective.id()).withType(nextObjective.type()).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
        bucketsToCreate.forEach(nextObjBuilder::addTreatment);
        // According to the next type we call the proper add function
        if (nextObjective.type() == NextObjective.Type.HASHED) {
            addBucketToHashGroup(nextObjBuilder.addToExisting(), allActiveKeys);
        } else {
            addBucketToBroadcastGroup(nextObjBuilder.addToExisting(), allActiveKeys);
        }
    }
    if (!indicesToRemove.isEmpty()) {
        log.info("removing {} buckets as part of nextId: {} verification", indicesToRemove.size(), nextObjective.id());
        List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
        indicesToRemove.forEach(index -> chainsToRemove.add(allActiveKeys.get(index)));
        removeBucket(chainsToRemove, nextObjective);
    }
    if (bucketsToCreate.isEmpty() && indicesToRemove.isEmpty()) {
        // flowObjective store record is in-sync with nextObjective passed-in
        // Nevertheless groupStore may not be in sync due to bug in the store
        // - see CORD-1844. XXX When this bug is fixed, the rest of this verify
        // method will not be required.
        GroupKey topGroupKey = allActiveKeys.get(0).peekFirst();
        Group topGroup = groupService.getGroup(deviceId, topGroupKey);
        int actualGroupSize = topGroup.buckets().buckets().size();
        int objGroupSize = nextObjective.next().size();
        if (actualGroupSize != objGroupSize) {
            log.warn("Mismatch detected in device:{}, nextId:{}, nextObjective-size" + ":{} group-size:{} .. correcting", deviceId, nextObjective.id(), objGroupSize, actualGroupSize);
        }
        // Group in the device has more chains
        if (actualGroupSize > objGroupSize) {
            List<GroupBucket> bucketsToRemove = Lists.newArrayList();
            // check every bucket in the actual group
            for (GroupBucket bucket : topGroup.buckets().buckets()) {
                GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                // the group pointed to
                GroupId gidToCheck = g.groupId();
                boolean matches = false;
                for (Deque<GroupKey> validChain : allActiveKeys) {
                    if (validChain.size() < 2) {
                        continue;
                    }
                    GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                    Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                    if (pointedGroup != null && gidToCheck.equals(pointedGroup.id())) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Removing bucket pointing to groupId:{}", gidToCheck);
                    bucketsToRemove.add(bucket);
                }
            }
            // remove buckets for which there was no record in the obj store
            if (bucketsToRemove.isEmpty()) {
                log.warn("Mismatch detected but could not determine which" + "buckets to remove");
            } else {
                GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
                groupService.removeBucketsFromGroup(deviceId, topGroupKey, removeBuckets, topGroupKey, nextObjective.appId());
            }
        } else if (actualGroupSize < objGroupSize) {
            // Group in the device has less chains
            // should also add buckets not in group-store but in obj-store
            List<GroupBucket> bucketsToAdd = Lists.newArrayList();
            // check every bucket in the obj
            for (Deque<GroupKey> validChain : allActiveKeys) {
                if (validChain.size() < 2) {
                    continue;
                }
                GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                if (pointedGroup == null) {
                    // group should exist, otherwise cannot be added as bucket
                    continue;
                }
                boolean matches = false;
                for (GroupBucket bucket : topGroup.buckets().buckets()) {
                    GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                    // the group pointed to
                    GroupId gidToCheck = g.groupId();
                    if (pointedGroup.id().equals(gidToCheck)) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Adding bucket pointing to groupId:{}", pointedGroup);
                    TrafficTreatment t = DefaultTrafficTreatment.builder().group(pointedGroup.id()).build();
                    // Create the proper bucket according to the next type
                    if (nextObjective.type() == NextObjective.Type.HASHED) {
                        bucketsToAdd.add(DefaultGroupBucket.createSelectGroupBucket(t));
                    } else {
                        bucketsToAdd.add(DefaultGroupBucket.createAllGroupBucket(t));
                    }
                }
            }
            if (bucketsToAdd.isEmpty()) {
                log.warn("Mismatch detected but could not determine which " + "buckets to add");
            } else {
                GroupBuckets addBuckets = new GroupBuckets(bucketsToAdd);
                groupService.addBucketsToGroup(deviceId, topGroupKey, addBuckets, topGroupKey, nextObjective.appId());
            }
        }
    }
    pass(nextObjective);
}
#method_after
protected void verifyGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() == NextObjective.Type.SIMPLE) {
        log.warn("verification not supported for indirect group");
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    log.debug("Call to verify device:{} nextId:{}", deviceId, nextObjective.id());
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<TrafficTreatment> bucketsToCreate = Lists.newArrayList();
    List<Integer> indicesToRemove = Lists.newArrayList();
    // to detect missing buckets and/or duplicate buckets (to be removed)
    for (TrafficTreatment bkt : nextObjective.next()) {
        PortNumber portNumber = readOutPortFromTreatment(bkt);
        int label = readLabelFromTreatment(bkt);
        if (portNumber == null) {
            log.warn("treatment {} of next objective {} has no outport.. " + "cannot remove bucket from group in dev: {}", bkt, nextObjective.id(), deviceId);
            fail(nextObjective, ObjectiveError.BADPARAMS);
            return;
        }
        List<Integer> existing = existingPortAndLabel(allActiveKeys, groupService, deviceId, portNumber, label);
        if (existing.isEmpty()) {
            // if it doesn't exist, mark this bucket for creation
            bucketsToCreate.add(bkt);
        }
        if (existing.size() > 1) {
            // if it exists but there are duplicates, mark the others for removal
            existing.remove(0);
            indicesToRemove.addAll(existing);
        }
    }
    // (not duplicates) respect to the next objective
    if (allActiveKeys.size() > nextObjective.next().size()) {
        log.warn("Mismatch detected between next and flowobjstore for device {}: " + "nextId:{}, nextObjective-size:{} next-size:{} .. correcting", deviceId, nextObjective.id(), nextObjective.next().size(), allActiveKeys.size());
        List<Integer> otherIndices = indicesToRemoveFromNextGroup(allActiveKeys, nextObjective, groupService, deviceId);
        // Filter out the indices not present
        otherIndices = otherIndices.stream().filter(index -> !indicesToRemove.contains(index)).collect(Collectors.toList());
        // Add all to the final list
        indicesToRemove.addAll(otherIndices);
    }
    log.debug("Buckets to create {}", bucketsToCreate);
    log.debug("Indices to remove {}", indicesToRemove);
    if (!bucketsToCreate.isEmpty()) {
        log.info("creating {} buckets as part of nextId: {} verification", bucketsToCreate.size(), nextObjective.id());
        // create a nextObjective only with these buckets
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextObjective.id()).withType(nextObjective.type()).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
        bucketsToCreate.forEach(nextObjBuilder::addTreatment);
        // According to the next type we call the proper add function
        if (nextObjective.type() == NextObjective.Type.HASHED) {
            addBucketToHashGroup(nextObjBuilder.addToExisting(), allActiveKeys);
        } else {
            addBucketToBroadcastGroup(nextObjBuilder.addToExisting(), allActiveKeys);
        }
    }
    if (!indicesToRemove.isEmpty()) {
        log.info("removing {} buckets as part of nextId: {} verification", indicesToRemove.size(), nextObjective.id());
        List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
        indicesToRemove.forEach(index -> chainsToRemove.add(allActiveKeys.get(index)));
        removeBucket(chainsToRemove, nextObjective);
    }
    if (bucketsToCreate.isEmpty() && indicesToRemove.isEmpty()) {
        // flowObjective store record is in-sync with nextObjective passed-in
        // Nevertheless groupStore may not be in sync due to bug in the store
        // - see CORD-1844. XXX When this bug is fixed, the rest of this verify
        // method will not be required.
        GroupKey topGroupKey = allActiveKeys.get(0).peekFirst();
        Group topGroup = groupService.getGroup(deviceId, topGroupKey);
        int actualGroupSize = topGroup.buckets().buckets().size();
        int objGroupSize = nextObjective.next().size();
        if (actualGroupSize != objGroupSize) {
            log.warn("Mismatch detected in device:{}, nextId:{}, nextObjective-size" + ":{} group-size:{} .. correcting", deviceId, nextObjective.id(), objGroupSize, actualGroupSize);
        }
        if (actualGroupSize > objGroupSize) {
            // Group in the device has more chains
            List<GroupBucket> bucketsToRemove = Lists.newArrayList();
            // check every bucket in the actual group
            for (GroupBucket bucket : topGroup.buckets().buckets()) {
                GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                // the group pointed to
                GroupId gidToCheck = g.groupId();
                boolean matches = false;
                for (Deque<GroupKey> validChain : allActiveKeys) {
                    if (validChain.size() < 2) {
                        continue;
                    }
                    GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                    Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                    if (pointedGroup != null && gidToCheck.equals(pointedGroup.id())) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Removing bucket pointing to groupId:{}", gidToCheck);
                    bucketsToRemove.add(bucket);
                }
            }
            // remove buckets for which there was no record in the obj store
            if (bucketsToRemove.isEmpty()) {
                log.warn("Mismatch detected but could not determine which" + "buckets to remove");
            } else {
                GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
                groupService.removeBucketsFromGroup(deviceId, topGroupKey, removeBuckets, topGroupKey, nextObjective.appId());
            }
        } else if (actualGroupSize < objGroupSize) {
            // Group in the device has less chains
            // should also add buckets not in group-store but in obj-store
            List<GroupBucket> bucketsToAdd = Lists.newArrayList();
            // check every bucket in the obj
            for (Deque<GroupKey> validChain : allActiveKeys) {
                if (validChain.size() < 2) {
                    continue;
                }
                GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                if (pointedGroup == null) {
                    // group should exist, otherwise cannot be added as bucket
                    continue;
                }
                boolean matches = false;
                for (GroupBucket bucket : topGroup.buckets().buckets()) {
                    GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                    // the group pointed to
                    GroupId gidToCheck = g.groupId();
                    if (pointedGroup.id().equals(gidToCheck)) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Adding bucket pointing to groupId:{}", pointedGroup);
                    TrafficTreatment t = DefaultTrafficTreatment.builder().group(pointedGroup.id()).build();
                    // Create the proper bucket according to the next type
                    if (nextObjective.type() == NextObjective.Type.HASHED) {
                        bucketsToAdd.add(DefaultGroupBucket.createSelectGroupBucket(t));
                    } else {
                        bucketsToAdd.add(DefaultGroupBucket.createAllGroupBucket(t));
                    }
                }
            }
            if (bucketsToAdd.isEmpty()) {
                log.warn("Mismatch detected but could not determine which " + "buckets to add");
            } else {
                GroupBuckets addBuckets = new GroupBuckets(bucketsToAdd);
                groupService.addBucketsToGroup(deviceId, topGroupKey, addBuckets, topGroupKey, nextObjective.appId());
            }
        }
    }
    pass(nextObjective);
}
#end_block

#method_before
private void processSinkRemovedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Continue only when this instance is the master of source device
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
            return;
        }
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Sink is on the same port of source. Abort");
                return;
            }
            removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            return;
        }
        // Process the egress device
        boolean isLast = removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
        if (isLast) {
            mcastRoleStore.remove(new McastStoreKey(mcastIp, sink.deviceId()));
        }
        // If this is the last sink on the device, also update upstream
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = Lists.newArrayList(mcastPath.get().links());
            Collections.reverse(links);
            for (Link link : links) {
                if (isLast) {
                    isLast = removePortFromDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, link.src().deviceId()));
                }
            }
        }
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processSinkRemovedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Continue only when this instance is the master of source device
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            log.debug("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
            return;
        }
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Skip {} since sink {} is on the same port of source {}. Abort", mcastIp, sink, source);
                return;
            }
            removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            return;
        }
        // Process the egress device
        boolean isLast = removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
        if (isLast) {
            mcastRoleStore.remove(new McastStoreKey(mcastIp, sink.deviceId()));
        }
        // If this is the last sink on the device, also update upstream
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = Lists.newArrayList(mcastPath.get().links());
            Collections.reverse(links);
            for (Link link : links) {
                if (isLast) {
                    isLast = removePortFromDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, link.src().deviceId()));
                }
            }
        }
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void processSinkAddedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Continue only when this instance is the master of source device
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            log.info("Skip {} due to lack of mastership of the source device {}", source.deviceId());
            return;
        }
        // Process the ingress device
        addFilterToDevice(source.deviceId(), source.port(), assignedVlan(source), mcastIp);
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Sink is on the same port of source. Abort");
                return;
            }
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.INGRESS);
            return;
        }
        // Find a path. If present, create/update groups and flows for each hop
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = mcastPath.get().links();
            checkState(links.size() == 2, "Path in leaf-spine topology should always be two hops: ", links);
            links.forEach(link -> {
                addPortToDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                addFilterToDevice(link.dst().deviceId(), link.dst().port(), assignedVlan(null), mcastIp);
            });
            // Process the egress device
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
            // Setup mcast roles
            mcastRoleStore.put(new McastStoreKey(mcastIp, source.deviceId()), McastRole.INGRESS);
            mcastRoleStore.put(new McastStoreKey(mcastIp, links.get(0).dst().deviceId()), McastRole.TRANSIT);
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.EGRESS);
        } else {
            log.warn("Unable to find a path from {} to {}. Abort sinkAdded", source.deviceId(), sink.deviceId());
        }
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processSinkAddedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Continue only when this instance is the master of source device
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            log.debug("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
            return;
        }
        // Process the ingress device
        addFilterToDevice(source.deviceId(), source.port(), assignedVlan(source), mcastIp);
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Skip {} since sink {} is on the same port of source {}. Abort", mcastIp, sink, source);
                return;
            }
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.INGRESS);
            return;
        }
        // Find a path. If present, create/update groups and flows for each hop
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = mcastPath.get().links();
            checkState(links.size() == 2, "Path in leaf-spine topology should always be two hops: ", links);
            links.forEach(link -> {
                addPortToDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                addFilterToDevice(link.dst().deviceId(), link.dst().port(), assignedVlan(null), mcastIp);
            });
            // Process the egress device
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
            // Setup mcast roles
            mcastRoleStore.put(new McastStoreKey(mcastIp, source.deviceId()), McastRole.INGRESS);
            mcastRoleStore.put(new McastStoreKey(mcastIp, links.get(0).dst().deviceId()), McastRole.TRANSIT);
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.EGRESS);
        } else {
            log.warn("Unable to find a path from {} to {}. Abort sinkAdded", source.deviceId(), sink.deviceId());
        }
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
protected void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if any of these info is missing
            if (ingressDevice == null || transitDevice == null || egressDevices == null || source == null) {
                log.warn("Missing ingress {}, transit {}, egress {} devices or source {}", ingressDevice, transitDevice, egressDevices, source);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.info("Skip {} due to lack of mastership of the source device {}", source.deviceId());
                return;
            }
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            // Remove transit-facing port on ingress device
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                mcastRoleStore.remove(new McastStoreKey(mcastIp, transitDevice));
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
protected void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if any of these info is missing
            if (ingressDevice == null || transitDevice == null || egressDevices == null || source == null) {
                log.warn("Missing ingress {}, transit {}, egress {} devices or source {}", ingressDevice, transitDevice, egressDevices, source);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.debug("Skip {} due to lack of mastership of the source device {}", source.deviceId());
                return;
            }
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            // Remove transit-facing port on ingress device
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                mcastRoleStore.remove(new McastStoreKey(mcastIp, transitDevice));
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
protected void processDeviceDown(DeviceId deviceDown) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get the mcast groups affected by the device going down
        getAffectedGroups(deviceDown).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when we have the mastership on the operation
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                // When the source is available we just check the mastership
                if (srManager.deviceService.isAvailable(source.deviceId())) {
                    log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                    return;
                }
                // Fallback with Leadership service
                // source id is used a topic
                NodeId master = srManager.leadershipService.runForLeadership(source.deviceId().toString()).leaderNodeId();
                // Verify if this node is the master
                if (!srManager.clusterService.getLocalNode().id().equals(master)) {
                    log.info("Skip {} due to lack of mastership of the topic {}", mcastIp, source.deviceId());
                    return;
                }
            }
            // If it exists, we have to remove it in any case
            if (transitDevice != null) {
                // Remove entire transit
                removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            }
            // If the ingress is down
            if (ingressDevice.equals(deviceDown)) {
                // Remove entire ingress
                removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
                // If other sinks different from the ingress exist
                if (!egressDevices.isEmpty()) {
                    // Remove all the remaining egress
                    egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
                }
            } else {
                // Egress or transit could be down at this point
                // Get the ingress-transit port if it exists
                PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
                if (ingressTransitPort != null) {
                    // Remove transit-facing port on ingress device
                    removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                }
                // One of the egress device is down
                if (egressDevices.contains(deviceDown)) {
                    // Remove entire device down
                    removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                    // Remove the device down from egress
                    egressDevices.remove(deviceDown);
                    // If there are no more egress and ingress does not have sinks
                    if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                        // Remove entire ingress
                        mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                        // We have done
                        return;
                    }
                }
                // Construct a new path for each egress device
                egressDevices.forEach(egressDevice -> {
                    Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                    // If there is a new path
                    if (mcastPath.isPresent()) {
                        // Let's install the new mcast path for this egress
                        installPath(mcastIp, source, mcastPath.get());
                    } else {
                        // We were not able to find an alternative path for this egress
                        log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                        removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                    }
                });
            }
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
protected void processDeviceDown(DeviceId deviceDown) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get the mcast groups affected by the device going down
        getAffectedGroups(deviceDown).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when we have the mastership on the operation
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                // When the source is available we just check the mastership
                if (srManager.deviceService.isAvailable(source.deviceId())) {
                    log.debug("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                    return;
                }
                // Fallback with Leadership service
                // source id is used a topic
                NodeId leader = srManager.leadershipService.runForLeadership(source.deviceId().toString()).leaderNodeId();
                // Verify if this node is the leader
                if (!srManager.clusterService.getLocalNode().id().equals(leader)) {
                    log.debug("Skip {} due to lack of leadership on the topic {}", mcastIp, source.deviceId());
                    return;
                }
            }
            // If it exists, we have to remove it in any case
            if (transitDevice != null) {
                // Remove entire transit
                removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            }
            // If the ingress is down
            if (ingressDevice.equals(deviceDown)) {
                // Remove entire ingress
                removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
                // If other sinks different from the ingress exist
                if (!egressDevices.isEmpty()) {
                    // Remove all the remaining egress
                    egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
                }
            } else {
                // Egress or transit could be down at this point
                // Get the ingress-transit port if it exists
                PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
                if (ingressTransitPort != null) {
                    // Remove transit-facing port on ingress device
                    removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                }
                // One of the egress device is down
                if (egressDevices.contains(deviceDown)) {
                    // Remove entire device down
                    removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                    // Remove the device down from egress
                    egressDevices.remove(deviceDown);
                    // If there are no more egress and ingress does not have sinks
                    if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                        // Remove entire ingress
                        mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                        // We have done
                        return;
                    }
                }
                // Construct a new path for each egress device
                egressDevices.forEach(egressDevice -> {
                    Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                    // If there is a new path
                    if (mcastPath.isPresent()) {
                        // Let's install the new mcast path for this egress
                        installPath(mcastIp, source, mcastPath.get());
                    } else {
                        // We were not able to find an alternative path for this egress
                        log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                        removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                    }
                });
            }
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void addPortToDevice(DeviceId deviceId, PortNumber port, IpAddress mcastIp, VlanId assignedVlan) {
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, deviceId);
    ImmutableSet.Builder<PortNumber> portBuilder = ImmutableSet.builder();
    NextObjective newNextObj;
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        // First time someone request this mcast group via this device
        portBuilder.add(port);
        // New nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), null).add();
        // Store the new port
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
    } else {
        // This device already serves some subscribers of this mcast group
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        // Stop if the port is already in the nextobj
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        if (existingPorts.contains(port)) {
            log.info("NextObj for {}/{} already exists. Abort", deviceId, port);
            return;
        }
        // Let's add the port and reuse the previous one
        portBuilder.addAll(existingPorts).add(port).build();
        // Reuse previous nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
        // Store the final next objective and send only the difference to the driver
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
        // Add just the new port
        portBuilder = ImmutableSet.builder();
        portBuilder.add(port);
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
    }
    // Create, store and apply the new nextObj and fwdObj
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add {} on {}/{}, vlan {}", mcastIp, deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add {} on {}/{}, vlan {}: {}", mcastIp, deviceId, port.toLong(), assignedVlan, error));
    ForwardingObjective fwdObj = fwdObjBuilder(mcastIp, assignedVlan, newNextObj.id()).add(context);
    srManager.flowObjectiveService.next(deviceId, newNextObj);
    srManager.flowObjectiveService.forward(deviceId, fwdObj);
}
#method_after
private void addPortToDevice(DeviceId deviceId, PortNumber port, IpAddress mcastIp, VlanId assignedVlan) {
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, deviceId);
    ImmutableSet.Builder<PortNumber> portBuilder = ImmutableSet.builder();
    NextObjective newNextObj;
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        // First time someone request this mcast group via this device
        portBuilder.add(port);
        // New nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), null).add();
        // Store the new port
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
    } else {
        // This device already serves some subscribers of this mcast group
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        // Stop if the port is already in the nextobj
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        if (existingPorts.contains(port)) {
            log.info("NextObj for {}/{} already exists. Abort", deviceId, port);
            return;
        }
        // Let's add the port and reuse the previous one
        portBuilder.addAll(existingPorts).add(port);
        // Reuse previous nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
        // Store the final next objective and send only the difference to the driver
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
        // Add just the new port
        portBuilder = ImmutableSet.builder();
        portBuilder.add(port);
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
    }
    // Create, store and apply the new nextObj and fwdObj
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add {} on {}/{}, vlan {}", mcastIp, deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add {} on {}/{}, vlan {}: {}", mcastIp, deviceId, port.toLong(), assignedVlan, error));
    ForwardingObjective fwdObj = fwdObjBuilder(mcastIp, assignedVlan, newNextObj.id()).add(context);
    srManager.flowObjectiveService.next(deviceId, newNextObj);
    srManager.flowObjectiveService.forward(deviceId, fwdObj);
}
#end_block

#method_before
@Override
public void run() {
    // Verify if the Mcast has been stable for MCAST_STABLITY_THRESHOLD
    if (!isMcastStable()) {
        return;
    }
    // Acquires lock
    mcastLock();
    try {
        // Iterates over the routes and verify the related next objectives
        srManager.multicastRouteService.getRoutes().stream().map(McastRoute::group).forEach(mcastIp -> {
            log.debug("Running mcast buckets corrector for mcast group: {}", mcastIp);
            // For each group we get current information in the store
            // and issue a check of the next objectives in place
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if ingress device or source of this group are missing
            if (ingressDevice == null || source == null) {
                log.warn("Unable to run buckets corrector. " + "Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.info("Unable to run buckets corrector. " + "Skip {} due to lack of mastership " + "of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Create the set of the devices to be processed
            ImmutableSet.Builder<DeviceId> devicesBuilder = ImmutableSet.builder();
            devicesBuilder.add(ingressDevice);
            if (transitDevice != null) {
                devicesBuilder.add(transitDevice);
            }
            if (!egressDevices.isEmpty()) {
                devicesBuilder.addAll(egressDevices);
            }
            Set<DeviceId> devicesToProcess = devicesBuilder.build();
            // Iterate over the devices
            devicesToProcess.forEach(deviceId -> {
                McastStoreKey currentKey = new McastStoreKey(mcastIp, deviceId);
                // If next exists in our store verify related next objective
                if (mcastNextObjStore.containsKey(currentKey)) {
                    NextObjective currentNext = mcastNextObjStore.get(currentKey).value();
                    // Get current ports
                    Set<PortNumber> currentPorts = getPorts(currentNext.next());
                    // Rebuild the next objective
                    currentNext = nextObjBuilder(mcastIp, assignedVlan(deviceId.equals(source.deviceId()) ? source : null), currentPorts, currentNext.id()).verify();
                    // Send to the flowobjective service
                    srManager.flowObjectiveService.next(deviceId, currentNext);
                } else {
                    log.warn("Unable to run buckets corrector." + "Missing next for {} and group {}", deviceId, mcastIp);
                }
            });
        });
    } finally {
        // Finally, it releases the lock
        mcastUnlock();
    }
}
#method_after
@Override
public void run() {
    // Verify if the Mcast has been stable for MCAST_STABLITY_THRESHOLD
    if (!isMcastStable()) {
        return;
    }
    // Acquires lock
    mcastLock();
    try {
        // Iterates over the routes and verify the related next objectives
        srManager.multicastRouteService.getRoutes().stream().map(McastRoute::group).forEach(mcastIp -> {
            log.trace("Running mcast buckets corrector for mcast group: {}", mcastIp);
            // For each group we get current information in the store
            // and issue a check of the next objectives in place
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if ingress device or source of this group are missing
            if (ingressDevice == null || source == null) {
                log.warn("Unable to run buckets corrector. " + "Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.trace("Unable to run buckets corrector. " + "Skip {} due to lack of mastership " + "of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Create the set of the devices to be processed
            ImmutableSet.Builder<DeviceId> devicesBuilder = ImmutableSet.builder();
            devicesBuilder.add(ingressDevice);
            if (transitDevice != null) {
                devicesBuilder.add(transitDevice);
            }
            if (!egressDevices.isEmpty()) {
                devicesBuilder.addAll(egressDevices);
            }
            Set<DeviceId> devicesToProcess = devicesBuilder.build();
            // Iterate over the devices
            devicesToProcess.forEach(deviceId -> {
                McastStoreKey currentKey = new McastStoreKey(mcastIp, deviceId);
                // If next exists in our store verify related next objective
                if (mcastNextObjStore.containsKey(currentKey)) {
                    NextObjective currentNext = mcastNextObjStore.get(currentKey).value();
                    // Get current ports
                    Set<PortNumber> currentPorts = getPorts(currentNext.next());
                    // Rebuild the next objective
                    currentNext = nextObjBuilder(mcastIp, assignedVlan(deviceId.equals(source.deviceId()) ? source : null), currentPorts, currentNext.id()).verify();
                    // Send to the flowobjective service
                    srManager.flowObjectiveService.next(deviceId, currentNext);
                } else {
                    log.warn("Unable to run buckets corrector." + "Missing next for {} and group {}", deviceId, mcastIp);
                }
            });
        });
    } finally {
        // Finally, it releases the lock
        mcastUnlock();
    }
}
#end_block

#method_before
protected void verifyGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("verification not supported for {} group", nextObjective.type());
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    log.debug("Call to verify device:{} nextId:{}", deviceId, nextObjective.id());
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<TrafficTreatment> bucketsToCreate = Lists.newArrayList();
    List<Integer> indicesToRemove = Lists.newArrayList();
    // to detect buckets to create and duplicated buckets (to be removed)
    for (TrafficTreatment bkt : nextObjective.next()) {
        PortNumber portNumber = readOutPortFromTreatment(bkt);
        int label = readLabelFromTreatment(bkt);
        if (portNumber == null) {
            log.warn("treatment {} of next objective {} has no outport.. " + "cannot remove bucket from group in dev: {}", bkt, nextObjective.id(), deviceId);
            fail(nextObjective, ObjectiveError.BADPARAMS);
            return;
        }
        List<Integer> existing = existingPortAndLabel(allActiveKeys, groupService, deviceId, portNumber, label);
        if (existing.isEmpty()) {
            // if it doesn't exist, mark this bucket for creation
            bucketsToCreate.add(bkt);
        }
        if (existing.size() > 1) {
            // if it exists but there are duplicates, mark the others for removal
            existing.remove(0);
            indicesToRemove.addAll(existing);
        }
    }
    // has more buckets (no duplicated) respect to the next objective
    if (allActiveKeys.size() > nextObjective.next().size()) {
        log.warn("Mismatch detected between next and flowobjstore for device {}: " + "nextId:{}, nextObjective-size:{} next-size:{} .. correcting", deviceId, nextObjective.id(), nextObjective.next().size(), allActiveKeys.size());
        List<Integer> otherIndices = indicesToRemoveFromNextGroup(allActiveKeys, nextObjective, groupService, deviceId);
        // Filter out the indices not present
        otherIndices = otherIndices.stream().filter(index -> !indicesToRemove.contains(index)).collect(Collectors.toList());
        // Add all to the final list
        indicesToRemove.addAll(otherIndices);
    }
    if (!bucketsToCreate.isEmpty()) {
        log.info("creating {} buckets as part of nextId: {} verification", bucketsToCreate.size(), nextObjective.id());
        // create a nextObjective only with these buckets
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextObjective.id()).withType(NextObjective.Type.HASHED).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
        bucketsToCreate.forEach(bucket -> nextObjBuilder.addTreatment(bucket));
        addBucketToHashGroup(nextObjBuilder.addToExisting(), allActiveKeys);
    }
    if (!indicesToRemove.isEmpty()) {
        log.info("removing {} buckets as part of nextId: {} verification", indicesToRemove.size(), nextObjective.id());
        List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
        indicesToRemove.forEach(index -> chainsToRemove.add(allActiveKeys.get(index)));
        removeBucket(chainsToRemove, nextObjective);
    }
    if (bucketsToCreate.isEmpty() && indicesToRemove.isEmpty()) {
        // flowObjective store record is in-sync with nextObjective passed-in
        // Nevertheless groupStore may not be in sync due to bug in the store
        // - see CORD-1844. XXX When this bug is fixed, the rest of this verify
        // method will not be required.
        GroupKey hashGroupKey = allActiveKeys.get(0).peekFirst();
        Group hashGroup = groupService.getGroup(deviceId, hashGroupKey);
        int actualGroupSize = hashGroup.buckets().buckets().size();
        int objGroupSize = nextObjective.next().size();
        if (actualGroupSize != objGroupSize) {
            log.warn("Mismatch detected in device:{}, nextId:{}, nextObjective-size" + ":{} group-size:{} .. correcting", deviceId, nextObjective.id(), objGroupSize, actualGroupSize);
        }
        if (actualGroupSize > objGroupSize) {
            List<GroupBucket> bucketsToRemove = Lists.newArrayList();
            // check every bucket in the actual group
            for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                // the group pointed to
                GroupId gidToCheck = g.groupId();
                boolean matches = false;
                for (Deque<GroupKey> validChain : allActiveKeys) {
                    if (validChain.size() < 2) {
                        continue;
                    }
                    GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                    Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                    if (pointedGroup != null && gidToCheck.equals(pointedGroup.id())) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Removing bucket pointing to groupId:{}", gidToCheck);
                    bucketsToRemove.add(bucket);
                }
            }
            // remove buckets for which there was no record in the obj store
            if (bucketsToRemove.isEmpty()) {
                log.warn("Mismatch detected but could not determine which" + "buckets to remove");
            } else {
                GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
                groupService.removeBucketsFromGroup(deviceId, hashGroupKey, removeBuckets, hashGroupKey, nextObjective.appId());
            }
        } else if (actualGroupSize < objGroupSize) {
            // should also add buckets not in group-store but in obj-store
            List<GroupBucket> bucketsToAdd = Lists.newArrayList();
            // check every bucket in the obj
            for (Deque<GroupKey> validChain : allActiveKeys) {
                if (validChain.size() < 2) {
                    continue;
                }
                GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                if (pointedGroup == null) {
                    // group should exist, otherwise cannot be added as bucket
                    continue;
                }
                boolean matches = false;
                for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                    GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                    // the group pointed to
                    GroupId gidToCheck = g.groupId();
                    if (pointedGroup.id().equals(gidToCheck)) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Adding bucket pointing to groupId:{}", pointedGroup);
                    TrafficTreatment t = DefaultTrafficTreatment.builder().group(pointedGroup.id()).build();
                    bucketsToAdd.add(DefaultGroupBucket.createSelectGroupBucket(t));
                }
            }
            if (bucketsToAdd.isEmpty()) {
                log.warn("Mismatch detected but could not determine which " + "buckets to add");
            } else {
                GroupBuckets addBuckets = new GroupBuckets(bucketsToAdd);
                groupService.addBucketsToGroup(deviceId, hashGroupKey, addBuckets, hashGroupKey, nextObjective.appId());
            }
        }
    }
    pass(nextObjective);
}
#method_after
protected void verifyGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("verification not supported for {} group", nextObjective.type());
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    log.debug("Call to verify device:{} nextId:{}", deviceId, nextObjective.id());
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<TrafficTreatment> bucketsToCreate = Lists.newArrayList();
    List<Integer> indicesToRemove = Lists.newArrayList();
    // to detect missing buckets and/or duplicate buckets (to be removed)
    for (TrafficTreatment bkt : nextObjective.next()) {
        PortNumber portNumber = readOutPortFromTreatment(bkt);
        int label = readLabelFromTreatment(bkt);
        if (portNumber == null) {
            log.warn("treatment {} of next objective {} has no outport.. " + "cannot remove bucket from group in dev: {}", bkt, nextObjective.id(), deviceId);
            fail(nextObjective, ObjectiveError.BADPARAMS);
            return;
        }
        List<Integer> existing = existingPortAndLabel(allActiveKeys, groupService, deviceId, portNumber, label);
        if (existing.isEmpty()) {
            // if it doesn't exist, mark this bucket for creation
            bucketsToCreate.add(bkt);
        }
        if (existing.size() > 1) {
            // if it exists but there are duplicates, mark the others for removal
            existing.remove(0);
            indicesToRemove.addAll(existing);
        }
    }
    // (not duplicates) respect to the next objective
    if (allActiveKeys.size() > nextObjective.next().size()) {
        log.warn("Mismatch detected between next and flowobjstore for device {}: " + "nextId:{}, nextObjective-size:{} next-size:{} .. correcting", deviceId, nextObjective.id(), nextObjective.next().size(), allActiveKeys.size());
        List<Integer> otherIndices = indicesToRemoveFromNextGroup(allActiveKeys, nextObjective, groupService, deviceId);
        // Filter out the indices not present
        otherIndices = otherIndices.stream().filter(index -> !indicesToRemove.contains(index)).collect(Collectors.toList());
        // Add all to the final list
        indicesToRemove.addAll(otherIndices);
    }
    if (!bucketsToCreate.isEmpty()) {
        log.info("creating {} buckets as part of nextId: {} verification", bucketsToCreate.size(), nextObjective.id());
        // create a nextObjective only with these buckets
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextObjective.id()).withType(NextObjective.Type.HASHED).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
        bucketsToCreate.forEach(bucket -> nextObjBuilder.addTreatment(bucket));
        addBucketToHashGroup(nextObjBuilder.addToExisting(), allActiveKeys);
    }
    if (!indicesToRemove.isEmpty()) {
        log.info("removing {} buckets as part of nextId: {} verification", indicesToRemove.size(), nextObjective.id());
        List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
        indicesToRemove.forEach(index -> chainsToRemove.add(allActiveKeys.get(index)));
        removeBucket(chainsToRemove, nextObjective);
    }
    if (bucketsToCreate.isEmpty() && indicesToRemove.isEmpty()) {
        // flowObjective store record is in-sync with nextObjective passed-in
        // Nevertheless groupStore may not be in sync due to bug in the store
        // - see CORD-1844. XXX When this bug is fixed, the rest of this verify
        // method will not be required.
        GroupKey hashGroupKey = allActiveKeys.get(0).peekFirst();
        Group hashGroup = groupService.getGroup(deviceId, hashGroupKey);
        int actualGroupSize = hashGroup.buckets().buckets().size();
        int objGroupSize = nextObjective.next().size();
        if (actualGroupSize != objGroupSize) {
            log.warn("Mismatch detected in device:{}, nextId:{}, nextObjective-size" + ":{} group-size:{} .. correcting", deviceId, nextObjective.id(), objGroupSize, actualGroupSize);
        }
        if (actualGroupSize > objGroupSize) {
            List<GroupBucket> bucketsToRemove = Lists.newArrayList();
            // check every bucket in the actual group
            for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                // the group pointed to
                GroupId gidToCheck = g.groupId();
                boolean matches = false;
                for (Deque<GroupKey> validChain : allActiveKeys) {
                    if (validChain.size() < 2) {
                        continue;
                    }
                    GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                    Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                    if (pointedGroup != null && gidToCheck.equals(pointedGroup.id())) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Removing bucket pointing to groupId:{}", gidToCheck);
                    bucketsToRemove.add(bucket);
                }
            }
            // remove buckets for which there was no record in the obj store
            if (bucketsToRemove.isEmpty()) {
                log.warn("Mismatch detected but could not determine which" + "buckets to remove");
            } else {
                GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
                groupService.removeBucketsFromGroup(deviceId, hashGroupKey, removeBuckets, hashGroupKey, nextObjective.appId());
            }
        } else if (actualGroupSize < objGroupSize) {
            // should also add buckets not in group-store but in obj-store
            List<GroupBucket> bucketsToAdd = Lists.newArrayList();
            // check every bucket in the obj
            for (Deque<GroupKey> validChain : allActiveKeys) {
                if (validChain.size() < 2) {
                    continue;
                }
                GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                if (pointedGroup == null) {
                    // group should exist, otherwise cannot be added as bucket
                    continue;
                }
                boolean matches = false;
                for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                    GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                    // the group pointed to
                    GroupId gidToCheck = g.groupId();
                    if (pointedGroup.id().equals(gidToCheck)) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Adding bucket pointing to groupId:{}", pointedGroup);
                    TrafficTreatment t = DefaultTrafficTreatment.builder().group(pointedGroup.id()).build();
                    bucketsToAdd.add(DefaultGroupBucket.createSelectGroupBucket(t));
                }
            }
            if (bucketsToAdd.isEmpty()) {
                log.warn("Mismatch detected but could not determine which " + "buckets to add");
            } else {
                GroupBuckets addBuckets = new GroupBuckets(bucketsToAdd);
                groupService.addBucketsToGroup(deviceId, hashGroupKey, addBuckets, hashGroupKey, nextObjective.appId());
            }
        }
    }
    pass(nextObjective);
}
#end_block

#method_before
private void processRouteRemovedInternal(ConnectPoint source, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        log.debug("Processing route down for group {}", mcastIp);
        // Find out the ingress, transit and egress device of the affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        // Verify leadership on the operation
        if (!isLeader(source)) {
            log.info("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        // If there are egress devices, sinks could be only on the ingress
        if (!egressDevices.isEmpty()) {
            egressDevices.forEach(deviceId -> removeGroupFromDevice(deviceId, mcastIp, assignedVlan(null)));
        }
        // Transit could be null
        if (transitDevice != null) {
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // Ingress device should be not null
        if (ingressDevice != null) {
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
        }
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processRouteRemovedInternal(ConnectPoint source, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        log.debug("Processing route down for group {}", mcastIp);
        // Find out the ingress, transit and egress device of the affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        // Verify leadership on the operation
        if (!isLeader(source)) {
            log.debug("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        // If there are egress devices, sinks could be only on the ingress
        if (!egressDevices.isEmpty()) {
            egressDevices.forEach(deviceId -> removeGroupFromDevice(deviceId, mcastIp, assignedVlan(null)));
        }
        // Transit could be null
        if (transitDevice != null) {
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // Ingress device should be not null
        if (ingressDevice != null) {
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
        }
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void processSinkRemovedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Verify leadership on the operation
        if (!isLeader(source)) {
            log.info("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Sink is on the same port of source. Abort");
                return;
            }
            removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            return;
        }
        // Process the egress device
        boolean isLast = removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
        if (isLast) {
            mcastRoleStore.remove(new McastStoreKey(mcastIp, sink.deviceId()));
        }
        // If this is the last sink on the device, also update upstream
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = Lists.newArrayList(mcastPath.get().links());
            Collections.reverse(links);
            for (Link link : links) {
                if (isLast) {
                    isLast = removePortFromDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, link.src().deviceId()));
                }
            }
        }
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processSinkRemovedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Verify leadership on the operation
        if (!isLeader(source)) {
            log.debug("Skip {} due to lack of leadership", mcastIp);
            return;
        }
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Skip {} since sink {} is on the same port of source {}. Abort", mcastIp, sink, source);
                return;
            }
            removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            return;
        }
        // Process the egress device
        boolean isLast = removePortFromDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
        if (isLast) {
            mcastRoleStore.remove(new McastStoreKey(mcastIp, sink.deviceId()));
        }
        // If this is the last sink on the device, also update upstream
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = Lists.newArrayList(mcastPath.get().links());
            Collections.reverse(links);
            for (Link link : links) {
                if (isLast) {
                    isLast = removePortFromDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, link.src().deviceId()));
                }
            }
        }
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void processSinkAddedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Continue only when this instance is the master of source device
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            log.info("Skip {} due to lack of mastership of the source device {}", source.deviceId());
            return;
        }
        // Process the ingress device
        addFilterToDevice(source.deviceId(), source.port(), assignedVlan(source), mcastIp);
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Sink is on the same port of source. Abort");
                return;
            }
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.INGRESS);
            return;
        }
        // Find a path. If present, create/update groups and flows for each hop
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = mcastPath.get().links();
            checkState(links.size() == 2, "Path in leaf-spine topology should always be two hops: ", links);
            links.forEach(link -> {
                addPortToDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                addFilterToDevice(link.dst().deviceId(), link.dst().port(), assignedVlan(null), mcastIp);
            });
            // Process the egress device
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
            // Setup mcast roles
            mcastRoleStore.put(new McastStoreKey(mcastIp, source.deviceId()), McastRole.INGRESS);
            mcastRoleStore.put(new McastStoreKey(mcastIp, links.get(0).dst().deviceId()), McastRole.TRANSIT);
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.EGRESS);
        } else {
            log.warn("Unable to find a path from {} to {}. Abort sinkAdded", source.deviceId(), sink.deviceId());
        }
    } finally {
        mcastUnlock();
    }
}
#method_after
private void processSinkAddedInternal(ConnectPoint source, ConnectPoint sink, IpAddress mcastIp) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Continue only when this instance is the master of source device
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            log.debug("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
            return;
        }
        // Process the ingress device
        addFilterToDevice(source.deviceId(), source.port(), assignedVlan(source), mcastIp);
        // When source and sink are on the same device
        if (source.deviceId().equals(sink.deviceId())) {
            // Source and sink are on even the same port. There must be something wrong.
            if (source.port().equals(sink.port())) {
                log.warn("Skip {} since sink {} is on the same port of source {}. Abort", mcastIp, sink, source);
                return;
            }
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(source));
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.INGRESS);
            return;
        }
        // Find a path. If present, create/update groups and flows for each hop
        Optional<Path> mcastPath = getPath(source.deviceId(), sink.deviceId(), mcastIp);
        if (mcastPath.isPresent()) {
            List<Link> links = mcastPath.get().links();
            checkState(links.size() == 2, "Path in leaf-spine topology should always be two hops: ", links);
            links.forEach(link -> {
                addPortToDevice(link.src().deviceId(), link.src().port(), mcastIp, assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
                addFilterToDevice(link.dst().deviceId(), link.dst().port(), assignedVlan(null), mcastIp);
            });
            // Process the egress device
            addPortToDevice(sink.deviceId(), sink.port(), mcastIp, assignedVlan(null));
            // Setup mcast roles
            mcastRoleStore.put(new McastStoreKey(mcastIp, source.deviceId()), McastRole.INGRESS);
            mcastRoleStore.put(new McastStoreKey(mcastIp, links.get(0).dst().deviceId()), McastRole.TRANSIT);
            mcastRoleStore.put(new McastStoreKey(mcastIp, sink.deviceId()), McastRole.EGRESS);
        } else {
            log.warn("Unable to find a path from {} to {}. Abort sinkAdded", source.deviceId(), sink.deviceId());
        }
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
protected void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if any of these info is missing
            if (ingressDevice == null || transitDevice == null || egressDevices == null || source == null) {
                log.warn("Missing ingress {}, transit {}, egress {} devices or source {}", ingressDevice, transitDevice, egressDevices, source);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.info("Skip {} due to lack of mastership of the source device {}", source.deviceId());
                return;
            }
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            // Remove transit-facing port on ingress device
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                mcastRoleStore.remove(new McastStoreKey(mcastIp, transitDevice));
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
protected void processLinkDown(Link affectedLink) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get groups affected by the link down event
        getAffectedGroups(affectedLink).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing link down {} for group {}", affectedLink, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if any of these info is missing
            if (ingressDevice == null || transitDevice == null || egressDevices == null || source == null) {
                log.warn("Missing ingress {}, transit {}, egress {} devices or source {}", ingressDevice, transitDevice, egressDevices, source);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.debug("Skip {} due to lack of mastership of the source device {}", source.deviceId());
                return;
            }
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            // Remove transit-facing port on ingress device
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                mcastRoleStore.remove(new McastStoreKey(mcastIp, transitDevice));
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                if (mcastPath.isPresent()) {
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    log.warn("Fail to recover egress device {} from link failure {}", egressDevice, affectedLink);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
protected void processDeviceDown(DeviceId deviceDown) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get the mcast groups affected by the device going down
        getAffectedGroups(deviceDown).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Verify leadership on the operation
            if (!isLeader(source)) {
                log.info("Skip {} due to lack of leadership", mcastIp);
                return;
            }
            // If it exists, we have to remove it in any case
            if (transitDevice != null) {
                // Remove entire transit
                removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            }
            // If the ingress is down
            if (ingressDevice.equals(deviceDown)) {
                // Remove entire ingress
                removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
                // If other sinks different from the ingress exist
                if (!egressDevices.isEmpty()) {
                    // Remove all the remaining egress
                    egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
                }
            } else {
                // Egress or transit could be down at this point
                // Get the ingress-transit port if it exists
                PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
                if (ingressTransitPort != null) {
                    // Remove transit-facing port on ingress device
                    removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                }
                // One of the egress device is down
                if (egressDevices.contains(deviceDown)) {
                    // Remove entire device down
                    removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                    // Remove the device down from egress
                    egressDevices.remove(deviceDown);
                    // If there are no more egress and ingress does not have sinks
                    if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                        // Remove entire ingress
                        mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                        // We have done
                        return;
                    }
                }
                // Construct a new path for each egress device
                egressDevices.forEach(egressDevice -> {
                    Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                    // If there is a new path
                    if (mcastPath.isPresent()) {
                        // Let's install the new mcast path for this egress
                        installPath(mcastIp, source, mcastPath.get());
                    } else {
                        // We were not able to find an alternative path for this egress
                        log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                        removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                    }
                });
            }
        });
    } finally {
        mcastUnlock();
    }
}
#method_after
protected void processDeviceDown(DeviceId deviceDown) {
    lastMcastChange = Instant.now();
    mcastLock();
    try {
        // Get the mcast groups affected by the device going down
        getAffectedGroups(deviceDown).forEach(mcastIp -> {
            // TODO Optimize when the group editing is in place
            log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
            // Find out the ingress, transit and egress device of affected group
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // If sinks are in the same leaf, we have just ingress and source
            if (ingressDevice == null || source == null) {
                log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Verify leadership on the operation
            if (!isLeader(source)) {
                log.debug("Skip {} due to lack of leadership", mcastIp);
                return;
            }
            // If it exists, we have to remove it in any case
            if (transitDevice != null) {
                // Remove entire transit
                removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
            }
            // If the ingress is down
            if (ingressDevice.equals(deviceDown)) {
                // Remove entire ingress
                removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
                // If other sinks different from the ingress exist
                if (!egressDevices.isEmpty()) {
                    // Remove all the remaining egress
                    egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
                }
            } else {
                // Egress or transit could be down at this point
                // Get the ingress-transit port if it exists
                PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
                if (ingressTransitPort != null) {
                    // Remove transit-facing port on ingress device
                    removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
                }
                // One of the egress device is down
                if (egressDevices.contains(deviceDown)) {
                    // Remove entire device down
                    removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                    // Remove the device down from egress
                    egressDevices.remove(deviceDown);
                    // If there are no more egress and ingress does not have sinks
                    if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                        // Remove entire ingress
                        mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                        // We have done
                        return;
                    }
                }
                // Construct a new path for each egress device
                egressDevices.forEach(egressDevice -> {
                    Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                    // If there is a new path
                    if (mcastPath.isPresent()) {
                        // Let's install the new mcast path for this egress
                        installPath(mcastIp, source, mcastPath.get());
                    } else {
                        // We were not able to find an alternative path for this egress
                        log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                        removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                    }
                });
            }
        });
    } finally {
        mcastUnlock();
    }
}
#end_block

#method_before
private void addPortToDevice(DeviceId deviceId, PortNumber port, IpAddress mcastIp, VlanId assignedVlan) {
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, deviceId);
    ImmutableSet.Builder<PortNumber> portBuilder = ImmutableSet.builder();
    NextObjective newNextObj;
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        // First time someone request this mcast group via this device
        portBuilder.add(port);
        // New nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), null).add();
        // Store the new port
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
    } else {
        // This device already serves some subscribers of this mcast group
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        // Stop if the port is already in the nextobj
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        if (existingPorts.contains(port)) {
            log.info("NextObj for {}/{} already exists. Abort", deviceId, port);
            return;
        }
        // Let's add the port and reuse the previous one
        portBuilder.addAll(existingPorts).add(port).build();
        // Reuse previous nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
        // Store the final next objective and send only the difference to the driver
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
        // Add just the new port
        portBuilder = ImmutableSet.builder();
        portBuilder.add(port);
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
    }
    // Create, store and apply the new nextObj and fwdObj
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add {} on {}/{}, vlan {}", mcastIp, deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add {} on {}/{}, vlan {}: {}", mcastIp, deviceId, port.toLong(), assignedVlan, error));
    ForwardingObjective fwdObj = fwdObjBuilder(mcastIp, assignedVlan, newNextObj.id()).add(context);
    srManager.flowObjectiveService.next(deviceId, newNextObj);
    srManager.flowObjectiveService.forward(deviceId, fwdObj);
}
#method_after
private void addPortToDevice(DeviceId deviceId, PortNumber port, IpAddress mcastIp, VlanId assignedVlan) {
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, deviceId);
    ImmutableSet.Builder<PortNumber> portBuilder = ImmutableSet.builder();
    NextObjective newNextObj;
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        // First time someone request this mcast group via this device
        portBuilder.add(port);
        // New nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), null).add();
        // Store the new port
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
    } else {
        // This device already serves some subscribers of this mcast group
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        // Stop if the port is already in the nextobj
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        if (existingPorts.contains(port)) {
            log.info("NextObj for {}/{} already exists. Abort", deviceId, port);
            return;
        }
        // Let's add the port and reuse the previous one
        portBuilder.addAll(existingPorts).add(port);
        // Reuse previous nextObj
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
        // Store the final next objective and send only the difference to the driver
        mcastNextObjStore.put(mcastStoreKey, newNextObj);
        // Add just the new port
        portBuilder = ImmutableSet.builder();
        portBuilder.add(port);
        newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build(), nextObj.id()).addToExisting();
    }
    // Create, store and apply the new nextObj and fwdObj
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add {} on {}/{}, vlan {}", mcastIp, deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add {} on {}/{}, vlan {}: {}", mcastIp, deviceId, port.toLong(), assignedVlan, error));
    ForwardingObjective fwdObj = fwdObjBuilder(mcastIp, assignedVlan, newNextObj.id()).add(context);
    srManager.flowObjectiveService.next(deviceId, newNextObj);
    srManager.flowObjectiveService.forward(deviceId, fwdObj);
}
#end_block

#method_before
@Override
public void run() {
    // Verify if the Mcast has been stable for MCAST_STABLITY_THRESHOLD
    if (!isMcastStable()) {
        return;
    }
    // Acquires lock
    mcastLock();
    try {
        // Iterates over the routes and verify the related next objectives
        srManager.multicastRouteService.getRoutes().stream().map(McastRoute::group).forEach(mcastIp -> {
            log.debug("Running mcast buckets corrector for mcast group: {}", mcastIp);
            // For each group we get current information in the store
            // and issue a check of the next objectives in place
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if ingress device or source of this group are missing
            if (ingressDevice == null || source == null) {
                log.warn("Unable to run buckets corrector. " + "Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.info("Unable to run buckets corrector. " + "Skip {} due to lack of mastership " + "of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Create the set of the devices to be processed
            ImmutableSet.Builder<DeviceId> devicesBuilder = ImmutableSet.builder();
            devicesBuilder.add(ingressDevice);
            if (transitDevice != null) {
                devicesBuilder.add(transitDevice);
            }
            if (!egressDevices.isEmpty()) {
                devicesBuilder.addAll(egressDevices);
            }
            Set<DeviceId> devicesToProcess = devicesBuilder.build();
            // Iterate over the devices
            devicesToProcess.forEach(deviceId -> {
                McastStoreKey currentKey = new McastStoreKey(mcastIp, deviceId);
                // If next exists in our store verify related next objective
                if (mcastNextObjStore.containsKey(currentKey)) {
                    NextObjective currentNext = mcastNextObjStore.get(currentKey).value();
                    // Get current ports
                    Set<PortNumber> currentPorts = getPorts(currentNext.next());
                    // Rebuild the next objective
                    currentNext = nextObjBuilder(mcastIp, assignedVlan(deviceId.equals(source.deviceId()) ? source : null), currentPorts, currentNext.id()).verify();
                    // Send to the flowobjective service
                    srManager.flowObjectiveService.next(deviceId, currentNext);
                } else {
                    log.warn("Unable to run buckets corrector." + "Missing next for {} and group {}", deviceId, mcastIp);
                }
            });
        });
    } finally {
        // Finally, it releases the lock
        mcastUnlock();
    }
}
#method_after
@Override
public void run() {
    // Verify if the Mcast has been stable for MCAST_STABLITY_THRESHOLD
    if (!isMcastStable()) {
        return;
    }
    // Acquires lock
    mcastLock();
    try {
        // Iterates over the routes and verify the related next objectives
        srManager.multicastRouteService.getRoutes().stream().map(McastRoute::group).forEach(mcastIp -> {
            log.trace("Running mcast buckets corrector for mcast group: {}", mcastIp);
            // For each group we get current information in the store
            // and issue a check of the next objectives in place
            DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
            DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
            Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
            ConnectPoint source = getSource(mcastIp);
            // Do not proceed if ingress device or source of this group are missing
            if (ingressDevice == null || source == null) {
                log.warn("Unable to run buckets corrector. " + "Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
                return;
            }
            // Continue only when this instance is the master of source device
            if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
                log.trace("Unable to run buckets corrector. " + "Skip {} due to lack of mastership " + "of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Create the set of the devices to be processed
            ImmutableSet.Builder<DeviceId> devicesBuilder = ImmutableSet.builder();
            devicesBuilder.add(ingressDevice);
            if (transitDevice != null) {
                devicesBuilder.add(transitDevice);
            }
            if (!egressDevices.isEmpty()) {
                devicesBuilder.addAll(egressDevices);
            }
            Set<DeviceId> devicesToProcess = devicesBuilder.build();
            // Iterate over the devices
            devicesToProcess.forEach(deviceId -> {
                McastStoreKey currentKey = new McastStoreKey(mcastIp, deviceId);
                // If next exists in our store verify related next objective
                if (mcastNextObjStore.containsKey(currentKey)) {
                    NextObjective currentNext = mcastNextObjStore.get(currentKey).value();
                    // Get current ports
                    Set<PortNumber> currentPorts = getPorts(currentNext.next());
                    // Rebuild the next objective
                    currentNext = nextObjBuilder(mcastIp, assignedVlan(deviceId.equals(source.deviceId()) ? source : null), currentPorts, currentNext.id()).verify();
                    // Send to the flowobjective service
                    srManager.flowObjectiveService.next(deviceId, currentNext);
                } else {
                    log.warn("Unable to run buckets corrector." + "Missing next for {} and group {}", deviceId, mcastIp);
                }
            });
        });
    } finally {
        // Finally, it releases the lock
        mcastUnlock();
    }
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    l2TunnelHandler.init();
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    l2TunnelHandler.init();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(pwaasConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    cfgService.unregisterConfigFactory(pwaasConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.clear();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void run() {
    try {
        while (true) {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                // Note: do not update seenLinks here, otherwise every
                // link, even one seen for the first time, will be appear
                // to be a previously seen link
                linkHandler.processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                linkHandler.processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#method_after
@Override
public void run() {
    while (true) {
        try {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                linkHandler.processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                linkHandler.processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        } catch (Exception e) {
            log.error("SegmentRouting event handler thread thrown an exception: {}", e.getMessage(), e);
        }
    }
}
#end_block

#method_before
private void createOrUpdateDeviceConfiguration() {
    if (deviceConfiguration == null) {
        deviceConfiguration = new DeviceConfiguration(this);
    } else {
        deviceConfiguration.updateConfig();
    }
}
#method_after
private void createOrUpdateDeviceConfiguration() {
    if (deviceConfiguration == null) {
        log.info("Creating new DeviceConfiguration");
        deviceConfiguration = new DeviceConfiguration(this);
    } else {
        log.info("Updating DeviceConfiguration");
        deviceConfiguration.updateConfig();
    }
}
#end_block

#method_before
void configureNetwork() {
    createOrUpdateDeviceConfiguration();
    arpHandler = new ArpHandler(srManager);
    icmpHandler = new IcmpHandler(srManager);
    ipHandler = new IpHandler(srManager);
    routingRulePopulator = new RoutingRulePopulator(srManager);
    defaultRoutingHandler = new DefaultRoutingHandler(srManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    // add a small delay to absorb multiple network config added notifications
    if (!programmingScheduled.get()) {
        programmingScheduled.set(true);
        executorService.schedule(new ConfigChange(), PROGRAM_DELAY, TimeUnit.SECONDS);
    }
    mcastHandler.init();
}
#method_after
void configureNetwork() {
    log.info("Configuring network ...");
    createOrUpdateDeviceConfiguration();
    arpHandler = new ArpHandler(srManager);
    icmpHandler = new IcmpHandler(srManager);
    ipHandler = new IpHandler(srManager);
    routingRulePopulator = new RoutingRulePopulator(srManager);
    defaultRoutingHandler = new DefaultRoutingHandler(srManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    // add a small delay to absorb multiple network config added notifications
    if (!programmingScheduled.get()) {
        log.info("Buffering config calls for {} secs", PROGRAM_DELAY);
        programmingScheduled.set(true);
        executorService.schedule(new ConfigChange(), PROGRAM_DELAY, TimeUnit.SECONDS);
    }
    mcastHandler.init();
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Device Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(InterfaceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Interface Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Interface Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // Following code will be uncommented when [CORD-634] is fully implemented.
                // [CORD-634] Add dynamic config support for interfaces
                updateInterface((InterfaceConfig) event.config().get(), (InterfaceConfig) event.prevConfig().get());
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
        configureNetwork();
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(PwaasConfig.class)) {
        checkState(l2TunnelHandler != null, "L2TunnelHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                l2TunnelHandler.processPwaasConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                l2TunnelHandler.processPwaasConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                l2TunnelHandler.processPwaasConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    // TODO move this part to NetworkConfigEventHandler
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Segment Routing Device Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Segment Routing Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(InterfaceConfig.class)) {
        switch(event.type()) {
            case CONFIG_ADDED:
                log.info("Interface Config added for {}", event.subject());
                configureNetwork();
                break;
            case CONFIG_UPDATED:
                log.info("Interface Config updated for {}", event.subject());
                createOrUpdateDeviceConfiguration();
                // Following code will be uncommented when [CORD-634] is fully implemented.
                // [CORD-634] Add dynamic config support for interfaces
                updateInterface((InterfaceConfig) event.config().get(), (InterfaceConfig) event.prevConfig().get());
                // TODO support dynamic configuration
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(SegmentRoutingAppConfig.class)) {
        checkState(appCfgHandler != null, "NetworkConfigEventHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                appCfgHandler.processAppConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                appCfgHandler.processAppConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                appCfgHandler.processAppConfigRemoved(event);
                break;
            default:
                break;
        }
        log.info("App config event .. configuring network");
        configureNetwork();
    } else if (event.configClass().equals(XConnectConfig.class)) {
        checkState(xConnectHandler != null, "XConnectHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                xConnectHandler.processXConnectConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                xConnectHandler.processXConnectConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                xConnectHandler.processXConnectConfigRemoved(event);
                break;
            default:
                break;
        }
    } else if (event.configClass().equals(PwaasConfig.class)) {
        checkState(l2TunnelHandler != null, "L2TunnelHandler is not initialized");
        switch(event.type()) {
            case CONFIG_ADDED:
                l2TunnelHandler.processPwaasConfigAdded(event);
                break;
            case CONFIG_UPDATED:
                l2TunnelHandler.processPwaasConfigUpdated(event);
                break;
            case CONFIG_REMOVED:
                l2TunnelHandler.processPwaasConfigRemoved(event);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class) || event.configClass().equals(SegmentRoutingAppConfig.class) || event.configClass().equals(InterfaceConfig.class) || event.configClass().equals(XConnectConfig.class) || event.configClass().equals(PwaasConfig.class)) {
        return true;
    }
    log.debug("Ignore irrelevant event class {}", event.configClass().getName());
    return false;
}
#method_after
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.type() == CONFIG_REGISTERED || event.type() == CONFIG_UNREGISTERED) {
        log.debug("Ignore event {} due to type mismatch", event);
        return false;
    }
    if (!event.configClass().equals(SegmentRoutingDeviceConfig.class) && !event.configClass().equals(SegmentRoutingAppConfig.class) && !event.configClass().equals(InterfaceConfig.class) && !event.configClass().equals(XConnectConfig.class) && !event.configClass().equals(PwaasConfig.class)) {
        log.debug("Ignore event {} due to class mismatch", event);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void run() {
    programmingScheduled.set(false);
    for (Device device : deviceService.getDevices()) {
        processDeviceAdded(device);
    }
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
@Override
public void run() {
    programmingScheduled.set(false);
    log.info("Reacting to config changes after buffer delay");
    for (Device device : deviceService.getDevices()) {
        processDeviceAdded(device);
    }
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
@Override
public BridgeDescription build() {
    return new DefaultBridgeDescription(name, controllers, enableLocalController, failMode, datapathId, datapathType, disableInBand, ofProtocols);
}
#method_after
@Override
public BridgeDescription build() {
    return new DefaultBridgeDescription(name, controllers, enableLocalController, failMode, datapathId, datapathType, disableInBand, controlProtocols);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("bridgeName", name).add("failMode", failMode).add("controllers", controllers).add("datapathType", datapathType).add("ofProtocols", ofProtocols).add("otherConfigs", otherConfigs).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("bridgeName", name).add("failMode", failMode).add("controllers", controllers).add("datapathType", datapathType).add("controlProtocols", controlProtocols).add("otherConfigs", otherConfigs).toString();
}
#end_block

#method_before
public OvsdbBridge build() {
    return new OvsdbBridge(name, failMode, controllers, datapathType, ofProtocols, otherConfigs);
}
#method_after
public OvsdbBridge build() {
    return new OvsdbBridge(name, failMode, controllers, datapathType, controlProtocols, otherConfigs);
}
#end_block

#method_before
@Override
public boolean createBridge(OvsdbBridge ovsdbBridge) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    String ovsUuid = getOvsUuid(DATABASENAME);
    if (dbSchema == null || ovsUuid == null) {
        log.error("Can't find database Open_vSwitch");
        return false;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    bridge.setOtherConfig(ovsdbBridge.otherConfigs());
    if (ovsdbBridge.failMode().isPresent()) {
        String failMode = ovsdbBridge.failMode().get().name().toLowerCase();
        bridge.setFailMode(Sets.newHashSet(failMode));
    }
    if (ovsdbBridge.datapathType().isPresent()) {
        String datapathType = ovsdbBridge.datapathType().get();
        bridge.setDatapathType(datapathType);
    }
    if (ovsdbBridge.ofProtocols().isPresent()) {
        String ofProtocols = ovsdbBridge.ofProtocols().get();
        Set<String> protocol = new HashSet<>();
        protocol.add(ofProtocols);
        bridge.setProtocols(protocol);
    }
    String bridgeUuid = getBridgeUuid(ovsdbBridge.name());
    if (bridgeUuid == null) {
        bridge.setName(ovsdbBridge.name());
        bridgeUuid = insertConfig(BRIDGE, UUID, DATABASENAME, BRIDGES, ovsUuid, bridge.getRow());
    } else {
        // update the bridge if it's already existing
        updateConfig(BRIDGE, UUID, bridgeUuid, bridge.getRow());
    }
    if (bridgeUuid == null) {
        log.warn("Failed to create bridge {} on {}", ovsdbBridge.name(), nodeId);
        return false;
    }
    createPort(ovsdbBridge.name(), ovsdbBridge.name());
    setControllersWithUuid(Uuid.uuid(bridgeUuid), ovsdbBridge.controllers());
    log.info("Created bridge {}", ovsdbBridge.name());
    return true;
}
#method_after
@Override
public boolean createBridge(OvsdbBridge ovsdbBridge) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    String ovsUuid = getOvsUuid(DATABASENAME);
    if (dbSchema == null || ovsUuid == null) {
        log.error("Can't find database Open_vSwitch");
        return false;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    bridge.setOtherConfig(ovsdbBridge.otherConfigs());
    if (ovsdbBridge.failMode().isPresent()) {
        String failMode = ovsdbBridge.failMode().get().name().toLowerCase();
        bridge.setFailMode(Sets.newHashSet(failMode));
    }
    if (ovsdbBridge.datapathType().isPresent()) {
        String datapathType = ovsdbBridge.datapathType().get();
        bridge.setDatapathType(datapathType);
    }
    if (ovsdbBridge.controlProtocols().isPresent()) {
        bridge.setProtocols(ovsdbBridge.controlProtocols().get().stream().map(ControlProtocolVersion::toString).collect(Collectors.toCollection(HashSet::new)));
    }
    String bridgeUuid = getBridgeUuid(ovsdbBridge.name());
    if (bridgeUuid == null) {
        bridge.setName(ovsdbBridge.name());
        bridgeUuid = insertConfig(BRIDGE, UUID, DATABASENAME, BRIDGES, ovsUuid, bridge.getRow());
    } else {
        // update the bridge if it's already existing
        updateConfig(BRIDGE, UUID, bridgeUuid, bridge.getRow());
    }
    if (bridgeUuid == null) {
        log.warn("Failed to create bridge {} on {}", ovsdbBridge.name(), nodeId);
        return false;
    }
    createPort(ovsdbBridge.name(), ovsdbBridge.name());
    setControllersWithUuid(Uuid.uuid(bridgeUuid), ovsdbBridge.controllers());
    log.info("Created bridge {}", ovsdbBridge.name());
    return true;
}
#end_block

#method_before
@Override
public OpenstackNode decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String hostname = json.get(HOST_NAME).asText();
    String type = json.get(TYPE).asText();
    String mIp = json.get(MANAGEMENT_IP).asText();
    String iBridge = json.get(INTEGRATION_BRIDGE).asText();
    DefaultOpenstackNode.Builder nodeBuilder = DefaultOpenstackNode.builder().hostname(hostname).type(OpenstackNode.NodeType.valueOf(type)).managementIp(IpAddress.valueOf(mIp)).intgBridge(DeviceId.deviceId(iBridge)).state(NodeState.INIT);
    if (type.equals(GATEWAY)) {
        nodeBuilder.uplinkPort(json.get(UPLINK_PORT).asText());
    }
    if (json.get(VLAN_INTF_NAME) != null) {
        nodeBuilder.vlanIntf(json.get(VLAN_INTF_NAME).asText());
    }
    if (json.get(DATA_IP) != null) {
        nodeBuilder.dataIp(IpAddress.valueOf(json.get(DATA_IP).asText()));
    }
    log.trace("node is {}", nodeBuilder.build().toString());
    return nodeBuilder.build();
}
#method_after
@Override
public OpenstackNode decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String hostname = nullIsIllegal(json.get(HOST_NAME).asText(), HOST_NAME + MISSING_MESSAGE);
    String type = nullIsIllegal(json.get(TYPE).asText(), TYPE + MISSING_MESSAGE);
    String mIp = nullIsIllegal(json.get(MANAGEMENT_IP).asText(), MANAGEMENT_IP + MISSING_MESSAGE);
    String iBridge = nullIsIllegal(json.get(INTEGRATION_BRIDGE).asText(), INTEGRATION_BRIDGE + MISSING_MESSAGE);
    DefaultOpenstackNode.Builder nodeBuilder = DefaultOpenstackNode.builder().hostname(hostname).type(OpenstackNode.NodeType.valueOf(type)).managementIp(IpAddress.valueOf(mIp)).intgBridge(DeviceId.deviceId(iBridge)).state(NodeState.INIT);
    if (type.equals(GATEWAY)) {
        nodeBuilder.uplinkPort(nullIsIllegal(json.get(UPLINK_PORT).asText(), UPLINK_PORT + MISSING_MESSAGE));
    }
    if (json.get(VLAN_INTF_NAME) != null) {
        nodeBuilder.vlanIntf(json.get(VLAN_INTF_NAME).asText());
    }
    if (json.get(DATA_IP) != null) {
        nodeBuilder.dataIp(IpAddress.valueOf(json.get(DATA_IP).asText()));
    }
    log.trace("node is {}", nodeBuilder.build().toString());
    return nodeBuilder.build();
}
#end_block

#method_before
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    deviceLocalStatus.put(deviceId, new LocalStatus(true, Instant.now()));
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    PortDescriptionsConfig portConfig = networkConfigService.getConfig(deviceId, PortDescriptionsConfig.class);
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    // Udate device annotations
    DeviceAnnotationConfig annoConfig = networkConfigService.getConfig(deviceId, DeviceAnnotationConfig.class);
    deviceDescription = deviceAnnotationOp.combine(deviceId, deviceDescription, annoConfig);
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    if (portConfig != null) {
        // updating the ports if configration exists
        List<PortDescription> complete = store.getPortDescriptions(provider().id(), deviceId).collect(Collectors.toList());
        complete.addAll(portConfig.portDescriptions());
        List<PortDescription> portDescriptions = complete.stream().map(e -> applyAllPortOps(deviceId, e)).collect(Collectors.toList());
        store.updatePorts(provider().id(), deviceId, portDescriptions);
    }
    if (deviceDescription.isDefaultAvailable()) {
        log.info("Device {} connected", deviceId);
    } else {
        log.info("Device {} registered", deviceId);
    }
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#method_after
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    deviceLocalStatus.put(deviceId, new LocalStatus(true, Instant.now()));
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    PortDescriptionsConfig portConfig = networkConfigService.getConfig(deviceId, PortDescriptionsConfig.class);
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    DeviceAnnotationConfig annoConfig = networkConfigService.getConfig(deviceId, DeviceAnnotationConfig.class);
    if (annoConfig != null) {
        deviceDescription = deviceAnnotationOp.combine(deviceId, deviceDescription, Optional.of(annoConfig));
    }
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    if (portConfig != null) {
        // updating the ports if configration exists
        List<PortDescription> complete = store.getPortDescriptions(provider().id(), deviceId).collect(Collectors.toList());
        complete.addAll(portConfig.portDescriptions());
        List<PortDescription> portDescriptions = complete.stream().map(e -> applyAllPortOps(deviceId, e)).collect(Collectors.toList());
        store.updatePorts(provider().id(), deviceId, portDescriptions);
    }
    if (deviceDescription.isDefaultAvailable()) {
        log.info("Device {} connected", deviceId);
    } else {
        log.info("Device {} registered", deviceId);
    }
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.configClass().equals(SegmentRoutingDeviceConfig.class) || event.configClass().equals(SegmentRoutingAppConfig.class) || event.configClass().equals(InterfaceConfig.class) || event.configClass().equals(XConnectConfig.class) || event.configClass().equals(PwaasConfig.class)) {
        return true;
    }
    log.debug("Ignore irrelevant event class {}", event.configClass().getName());
    return false;
}
#method_after
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.type() == CONFIG_REGISTERED || event.type() == CONFIG_UNREGISTERED) {
        log.debug("Ignore event {} due to type mismatch", event);
        return false;
    }
    if (!event.configClass().equals(SegmentRoutingDeviceConfig.class) && !event.configClass().equals(SegmentRoutingAppConfig.class) && !event.configClass().equals(InterfaceConfig.class) && !event.configClass().equals(XConnectConfig.class) && !event.configClass().equals(PwaasConfig.class)) {
        log.debug("Ignore event {} due to class mismatch", event);
        return false;
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
<T extends Intent> void registerCompiler(Class<T> cls, IntentCompiler<T> compiler, boolean flowBased) {
    if (flowBased) {
        // FIXME: temporary code for switching old compiler to new compiler
        flowObjectiveBased.compute((Class<Intent>) cls, (clz, compilers) -> {
            if (compilers == null) {
                compilers = Sets.newHashSet();
            }
            compilers.add((IntentCompiler<Intent>) compiler);
            return compilers;
        });
    } else {
        flowRuleBased.put((Class<Intent>) cls, (IntentCompiler<Intent>) compiler);
    }
    if (flowBased == useFlowObjectives) {
        extensionService.registerCompiler(cls, compiler);
    }
}
#method_after
@SuppressWarnings("unchecked")
<T extends Intent> void registerCompiler(Class<T> cls, IntentCompiler<T> compiler, boolean flowBased) {
    if (flowBased) {
        flowObjectiveBased.put((Class<Intent>) cls, (IntentCompiler<Intent>) compiler);
    } else {
        flowRuleBased.put((Class<Intent>) cls, (IntentCompiler<Intent>) compiler);
    }
    if (flowBased == useFlowObjectives) {
        extensionService.registerCompiler(cls, compiler);
    }
}
#end_block

#method_before
private void changeCompilers() {
    if (useFlowObjectives) {
        flowRuleBased.forEach((cls, compiler) -> extensionService.unregisterCompiler(cls));
        // FIXME: temporary code for switching old compiler to new compiler
        flowObjectiveBased.forEach((cls, compilers) -> {
            compilers.forEach(compiler -> {
                extensionService.registerCompiler(cls, compiler);
            });
        });
    } else {
        flowObjectiveBased.forEach((cls, compiler) -> extensionService.unregisterCompiler(cls));
        flowRuleBased.forEach((cls, compiler) -> extensionService.registerCompiler(cls, compiler));
    }
}
#method_after
private void changeCompilers() {
    if (useFlowObjectives) {
        flowRuleBased.forEach((cls, compiler) -> extensionService.unregisterCompiler(cls));
        flowObjectiveBased.forEach((cls, compiler) -> {
            extensionService.registerCompiler(cls, compiler);
        });
    } else {
        flowObjectiveBased.forEach((cls, compiler) -> extensionService.unregisterCompiler(cls));
        flowRuleBased.forEach((cls, compiler) -> extensionService.registerCompiler(cls, compiler));
    }
}
#end_block

#method_before
protected void processDeviceDown(DeviceId deviceDown) {
    // Get the mcast groups affected by the device going down
    getAffectedGroups(deviceDown).forEach(mcastIp -> {
        // TODO Optimize when the group editing is in place
        log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
        // Find out the ingress, transit and egress device of affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        ConnectPoint source = getSource(mcastIp);
        // If sinks are in the same leaf, we have just ingress and source
        if (ingressDevice == null || source == null) {
            log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
            return;
        }
        // Continue only when we have the mastership on the operation
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            // When the source is available we just check the mastership
            if (srManager.deviceService.isAvailable(source.deviceId())) {
                log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Fallback with Leadership service
            // source id is used a topic
            NodeId master = srManager.leadershipService.runForLeadership(source.deviceId().toString()).leaderNodeId();
            // Verify if this node is the master
            if (!srManager.clusterService.getLocalNode().id().equals(master)) {
                log.info("Skip {} due to lack of mastership of the topic {}", mcastIp, source.deviceId());
                return;
            }
        }
        // If it exists, we have to remove it in any case
        if (transitDevice != null) {
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // If the ingress is down
        if (ingressDevice.equals(deviceDown)) {
            // Remove entire ingress
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
            // If other sinks different from the ingress exist
            if (!egressDevices.isEmpty()) {
                // Remove all the remaining egress
                egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
            }
        } else {
            // Egress or transit could be down at this point
            // Get the ingress-transit port if it exists
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                // Remove transit-facing port on ingress device
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
            }
            // One of the egress device is down
            if (egressDevices.contains(deviceDown)) {
                // Remove entire device down
                removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                // Remove the device down from egress
                egressDevices.remove(deviceDown);
                // If there are no more egress and ingress does not have sinks
                if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                    // Remove entire ingress
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                    // We have done
                    return;
                }
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                // If there is a new path
                if (mcastPath.isPresent()) {
                    // Let's install the new mcast path for this egress
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    // We were not able to find an alternative path for this egress
                    log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        }
    });
}
#method_after
protected void processDeviceDown(DeviceId deviceDown) {
    // Get the mcast groups affected by the device going down
    getAffectedGroups(deviceDown).forEach(mcastIp -> {
        // TODO Optimize when the group editing is in place
        log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
        // Find out the ingress, transit and egress device of affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        ConnectPoint source = getSource(mcastIp);
        // If sinks are in the same leaf, we have just ingress and source
        if (ingressDevice == null || source == null) {
            log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
            return;
        }
        // Continue only when we have the mastership on the operation
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            // When the source is available we just check the mastership
            if (srManager.deviceService.isAvailable(source.deviceId())) {
                log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Fallback with Leadership service
            // source id is used a topic
            NodeId leader = srManager.leadershipService.runForLeadership(source.deviceId().toString()).leaderNodeId();
            // Verify if this node is the leader
            if (!srManager.clusterService.getLocalNode().id().equals(leader)) {
                log.info("Skip {} due to lack of leadership on the topic {}", mcastIp, source.deviceId());
                return;
            }
        }
        // If it exists, we have to remove it in any case
        if (transitDevice != null) {
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // If the ingress is down
        if (ingressDevice.equals(deviceDown)) {
            // Remove entire ingress
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
            // If other sinks different from the ingress exist
            if (!egressDevices.isEmpty()) {
                // Remove all the remaining egress
                egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
            }
        } else {
            // Egress or transit could be down at this point
            // Get the ingress-transit port if it exists
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                // Remove transit-facing port on ingress device
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
            }
            // One of the egress device is down
            if (egressDevices.contains(deviceDown)) {
                // Remove entire device down
                removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                // Remove the device down from egress
                egressDevices.remove(deviceDown);
                // If there are no more egress and ingress does not have sinks
                if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                    // Remove entire ingress
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                    // We have done
                    return;
                }
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                // If there is a new path
                if (mcastPath.isPresent()) {
                    // Let's install the new mcast path for this egress
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    // We were not able to find an alternative path for this egress
                    log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        }
    });
}
#end_block

#method_before
private Optional<Path> getPath(DeviceId src, DeviceId dst, IpAddress mcastIp) {
    List<Path> allPaths = Lists.newArrayList(topologyService.getPaths(topologyService.currentTopology(), src, dst));
    log.debug("{} path(s) found from {} to {}", allPaths.size(), src, dst);
    if (allPaths.isEmpty()) {
        return Optional.empty();
    }
    // If one of the available paths has been used before, use the same path
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, src);
    if (mcastNextObjStore.containsKey(mcastStoreKey)) {
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        PortNumber srcPort;
        // Get the output ports on the source
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        // Create eligible paths list
        List<Path> eligiblePaths = Lists.newArrayList();
        // Iterate over paths looking for eligible paths
        for (Path path : allPaths) {
            // Consider only leaf-spine-leaf paths
            if (path.links().size() != 2) {
                continue;
            }
            // Take paths sharing the src port of the first hop
            // with the existing output ports on the source
            srcPort = path.links().get(0).src().port();
            if (existingPorts.contains(srcPort)) {
                // Take paths which first hop destination is in the internal store
                McastStoreKey dstKey = new McastStoreKey(mcastIp, path.links().get(0).dst().deviceId());
                if (mcastNextObjStore.containsKey(dstKey)) {
                    eligiblePaths.add(path);
                }
            }
        }
        log.debug("{} eligiblePath(s) found from {} to {}", eligiblePaths.size(), src, dst);
        // Iterate over the eligible paths looking for a good candidate
        for (Path eligiblePath : eligiblePaths) {
            // Take the src port on the second hop
            srcPort = eligiblePath.links().get(1).src().port();
            // Retrieve the associated next
            mcastStoreKey = new McastStoreKey(mcastIp, eligiblePath.links().get(1).src().deviceId());
            nextObj = mcastNextObjStore.get(mcastStoreKey).value();
            // Get the output port (already existing) on this device
            existingPorts = getPorts(nextObj.next());
            // If the path shares also the src port on the second hop
            if (existingPorts.contains(srcPort)) {
                // We have done
                log.debug("Found {} from {} to {}", eligiblePath, src, dst);
                return Optional.of(eligiblePath);
            }
        }
        // mcast tree. Really useful for bigger l-s topologies.
        if (!eligiblePaths.isEmpty()) {
            // Randomly pick a path
            Collections.shuffle(eligiblePaths);
            return eligiblePaths.stream().findFirst();
        }
    }
    // Otherwise, randomly pick a path
    Collections.shuffle(allPaths);
    return allPaths.stream().findFirst();
}
#method_after
private Optional<Path> getPath(DeviceId src, DeviceId dst, IpAddress mcastIp) {
    List<Path> allPaths = Lists.newArrayList(topologyService.getPaths(topologyService.currentTopology(), src, dst));
    log.debug("{} path(s) found from {} to {}", allPaths.size(), src, dst);
    if (allPaths.isEmpty()) {
        return Optional.empty();
    }
    // Create a map index of suitablity-to-list of paths. For example
    // a path in the list associated to the index 1 shares only the
    // first hop and it is less suitable of a path belonging to the index
    // 2 that shares leaf-spine.
    Map<Integer, List<Path>> eligiblePaths = Maps.newHashMap();
    // Some init steps
    int nhop;
    McastStoreKey mcastStoreKey;
    Link hop;
    PortNumber srcPort;
    Set<PortNumber> existingPorts;
    NextObjective nextObj;
    // Iterate over paths looking for eligible paths
    for (Path path : allPaths) {
        // Unlikely, it will happen...
        if (!src.equals(path.links().get(0).src().deviceId())) {
            continue;
        }
        nhop = 0;
        // Iterate over the links
        while (nhop < path.links().size()) {
            // Get the link and verify if a next related
            // to the src device exist in the store
            hop = path.links().get(nhop);
            mcastStoreKey = new McastStoreKey(mcastIp, hop.src().deviceId());
            // It does not exist in the store, exit
            if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
                break;
            }
            // Get the output ports on the next
            nextObj = mcastNextObjStore.get(mcastStoreKey).value();
            existingPorts = getPorts(nextObj.next());
            // And the src port on the link
            srcPort = hop.src().port();
            // the src port is not used as output, exit
            if (!existingPorts.contains(srcPort)) {
                break;
            }
            nhop++;
        }
        // n_hop defines the index
        if (nhop > 0) {
            eligiblePaths.compute(nhop, (index, paths) -> {
                paths = paths == null ? Lists.newArrayList() : paths;
                paths.add(path);
                return paths;
            });
        }
    }
    // No suitable paths
    if (eligiblePaths.isEmpty()) {
        log.debug("No eligiblePath(s) found from {} to {}", src, dst);
        // Otherwise, randomly pick a path
        Collections.shuffle(allPaths);
        return allPaths.stream().findFirst();
    }
    // Let's take the best ones
    Integer bestIndex = eligiblePaths.keySet().stream().sorted(Comparator.reverseOrder()).findFirst().orElse(null);
    List<Path> bestPaths = eligiblePaths.get(bestIndex);
    log.debug("{} eligiblePath(s) found from {} to {}", bestPaths.size(), src, dst);
    // randomly pick a path on the highest index
    Collections.shuffle(bestPaths);
    return bestPaths.stream().findFirst();
}
#end_block

#method_before
protected void processDeviceDown(DeviceId deviceDown) {
    // Get the mcast groups affected by the device going down
    getAffectedGroups(deviceDown).forEach(mcastIp -> {
        // TODO Optimize when the group editing is in place
        log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
        // Find out the ingress, transit and egress device of affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        ConnectPoint source = getSource(mcastIp);
        // If sinks are in the same leaf, we have just ingress and source
        if (ingressDevice == null || source == null) {
            log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
            return;
        }
        // Continue only when we have the mastership on the operation
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            // When the source is available we just check the mastership
            if (srManager.deviceService.isAvailable(source.deviceId())) {
                log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Fallback with Leadership service
            // source id is used a topic
            NodeId master = srManager.leadershipService.runForLeadership(source.deviceId().toString()).leaderNodeId();
            // Verify if this node is the master
            if (!srManager.clusterService.getLocalNode().id().equals(master)) {
                log.info("Skip {} due to lack of mastership of the topic {}", mcastIp, source.deviceId());
                return;
            }
        }
        // If it exists, we have to remove it in any case
        if (transitDevice != null) {
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // If the ingress is down
        if (ingressDevice.equals(deviceDown)) {
            // Remove entire ingress
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
            // If other sinks different from the ingress exist
            if (!egressDevices.isEmpty()) {
                // Remove all the remaining egress
                egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
            }
        } else {
            // Egress or transit could be down at this point
            // Get the ingress-transit port if it exists
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                // Remove transit-facing port on ingress device
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
            }
            // One of the egress device is down
            if (egressDevices.contains(deviceDown)) {
                // Remove entire device down
                removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                // Remove the device down from egress
                egressDevices.remove(deviceDown);
                // If there are no more egress and ingress does not have sinks
                if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                    // Remove entire ingress
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                    // We have done
                    return;
                }
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                // If there is a new path
                if (mcastPath.isPresent()) {
                    // Let's install the new mcast path for this egress
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    // We were not able to find an alternative path for this egress
                    log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        }
    });
}
#method_after
protected void processDeviceDown(DeviceId deviceDown) {
    // Get the mcast groups affected by the device going down
    getAffectedGroups(deviceDown).forEach(mcastIp -> {
        // TODO Optimize when the group editing is in place
        log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
        // Find out the ingress, transit and egress device of affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        ConnectPoint source = getSource(mcastIp);
        // If sinks are in the same leaf, we have just ingress and source
        if (ingressDevice == null || source == null) {
            log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
            return;
        }
        // Continue only when we have the mastership on the operation
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            // When the source is available we just check the mastership
            if (srManager.deviceService.isAvailable(source.deviceId())) {
                log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Fallback with Leadership service
            // source id is used a topic
            NodeId leader = srManager.leadershipService.runForLeadership(source.deviceId().toString()).leaderNodeId();
            // Verify if this node is the leader
            if (!srManager.clusterService.getLocalNode().id().equals(leader)) {
                log.info("Skip {} due to lack of leadership on the topic {}", mcastIp, source.deviceId());
                return;
            }
        }
        // If it exists, we have to remove it in any case
        if (transitDevice != null) {
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // If the ingress is down
        if (ingressDevice.equals(deviceDown)) {
            // Remove entire ingress
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
            // If other sinks different from the ingress exist
            if (!egressDevices.isEmpty()) {
                // Remove all the remaining egress
                egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
            }
        } else {
            // Egress or transit could be down at this point
            // Get the ingress-transit port if it exists
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                // Remove transit-facing port on ingress device
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
            }
            // One of the egress device is down
            if (egressDevices.contains(deviceDown)) {
                // Remove entire device down
                removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                // Remove the device down from egress
                egressDevices.remove(deviceDown);
                // If there are no more egress and ingress does not have sinks
                if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                    // Remove entire ingress
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                    // We have done
                    return;
                }
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                // If there is a new path
                if (mcastPath.isPresent()) {
                    // Let's install the new mcast path for this egress
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    // We were not able to find an alternative path for this egress
                    log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        }
    });
}
#end_block

#method_before
private Optional<Path> getPath(DeviceId src, DeviceId dst, IpAddress mcastIp) {
    List<Path> allPaths = Lists.newArrayList(topologyService.getPaths(topologyService.currentTopology(), src, dst));
    log.debug("{} path(s) found from {} to {}", allPaths.size(), src, dst);
    if (allPaths.isEmpty()) {
        return Optional.empty();
    }
    // If one of the available paths has been used before, use the same path
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, src);
    if (mcastNextObjStore.containsKey(mcastStoreKey)) {
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        PortNumber srcPort;
        // Get the output ports on the source
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        // Create eligible paths list
        List<Path> eligiblePaths = Lists.newArrayList();
        // Iterate over paths looking for eligible paths
        for (Path path : allPaths) {
            // Consider only leaf-spine-leaf paths
            if (path.links().size() != 2) {
                continue;
            }
            // Take paths sharing the src port of the first hop
            // with the existing output ports on the source
            srcPort = path.links().get(0).src().port();
            if (existingPorts.contains(srcPort)) {
                // Take paths which first hop destination is in the internal store
                McastStoreKey dstKey = new McastStoreKey(mcastIp, path.links().get(0).dst().deviceId());
                if (mcastNextObjStore.containsKey(dstKey)) {
                    eligiblePaths.add(path);
                }
            }
        }
        log.debug("{} eligiblePath(s) found from {} to {}", eligiblePaths.size(), src, dst);
        // Iterate over the eligible paths looking for a good candidate
        for (Path eligiblePath : eligiblePaths) {
            // Take the src port on the second hop
            srcPort = eligiblePath.links().get(1).src().port();
            // Retrieve the associated next
            mcastStoreKey = new McastStoreKey(mcastIp, eligiblePath.links().get(1).src().deviceId());
            nextObj = mcastNextObjStore.get(mcastStoreKey).value();
            // Get the output port (already existing) on this device
            existingPorts = getPorts(nextObj.next());
            // If the path shares also the src port on the second hop
            if (existingPorts.contains(srcPort)) {
                // We have done
                log.debug("Found {} from {} to {}", eligiblePath, src, dst);
                return Optional.of(eligiblePath);
            }
        }
        // mcast tree. Really useful for bigger l-s topologies.
        if (!eligiblePaths.isEmpty()) {
            // Randomly pick a path
            Collections.shuffle(eligiblePaths);
            return eligiblePaths.stream().findFirst();
        }
    }
    // Otherwise, randomly pick a path
    Collections.shuffle(allPaths);
    return allPaths.stream().findFirst();
}
#method_after
private Optional<Path> getPath(DeviceId src, DeviceId dst, IpAddress mcastIp) {
    List<Path> allPaths = Lists.newArrayList(topologyService.getPaths(topologyService.currentTopology(), src, dst));
    log.debug("{} path(s) found from {} to {}", allPaths.size(), src, dst);
    if (allPaths.isEmpty()) {
        return Optional.empty();
    }
    // Create a map index of suitablity-to-list of paths. For example
    // a path in the list associated to the index 1 shares only the
    // first hop and it is less suitable of a path belonging to the index
    // 2 that shares leaf-spine.
    Map<Integer, List<Path>> eligiblePaths = Maps.newHashMap();
    // Some init steps
    int nhop;
    McastStoreKey mcastStoreKey;
    Link hop;
    PortNumber srcPort;
    Set<PortNumber> existingPorts;
    NextObjective nextObj;
    // Iterate over paths looking for eligible paths
    for (Path path : allPaths) {
        // Unlikely, it will happen...
        if (!src.equals(path.links().get(0).src().deviceId())) {
            continue;
        }
        nhop = 0;
        // Iterate over the links
        while (nhop < path.links().size()) {
            // Get the link and verify if a next related
            // to the src device exist in the store
            hop = path.links().get(nhop);
            mcastStoreKey = new McastStoreKey(mcastIp, hop.src().deviceId());
            // It does not exist in the store, exit
            if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
                break;
            }
            // Get the output ports on the next
            nextObj = mcastNextObjStore.get(mcastStoreKey).value();
            existingPorts = getPorts(nextObj.next());
            // And the src port on the link
            srcPort = hop.src().port();
            // the src port is not used as output, exit
            if (!existingPorts.contains(srcPort)) {
                break;
            }
            nhop++;
        }
        // n_hop defines the index
        if (nhop > 0) {
            eligiblePaths.compute(nhop, (index, paths) -> {
                paths = paths == null ? Lists.newArrayList() : paths;
                paths.add(path);
                return paths;
            });
        }
    }
    // No suitable paths
    if (eligiblePaths.isEmpty()) {
        log.debug("No eligiblePath(s) found from {} to {}", src, dst);
        // Otherwise, randomly pick a path
        Collections.shuffle(allPaths);
        return allPaths.stream().findFirst();
    }
    // Let's take the best ones
    Integer bestIndex = eligiblePaths.keySet().stream().sorted(Comparator.reverseOrder()).findFirst().orElse(null);
    List<Path> bestPaths = eligiblePaths.get(bestIndex);
    log.debug("{} eligiblePath(s) found from {} to {}", bestPaths.size(), src, dst);
    // randomly pick a path on the highest index
    Collections.shuffle(bestPaths);
    return bestPaths.stream().findFirst();
}
#end_block

#method_before
protected void processDeviceDown(DeviceId deviceDown) {
    getAffectedGroups(deviceDown).forEach(mcastIp -> {
        // TODO Optimize when the group editing is in place
        log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
        // Find out the ingress, transit and egress device of affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        ConnectPoint source = getSource(mcastIp);
        // If sinks are in the same leaf, we have just ingress and source
        if (ingressDevice == null || source == null) {
            log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
            return;
        }
        // Continue only when we have the mastership on the operation
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            // When the source is available we just check the mastership
            if (srManager.deviceService.isAvailable(source.deviceId())) {
                log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Fallback with Leadership service
            // source id is used a topic
            NodeId master = srManager.leadershipService.runForLeadership(source.deviceId().toString()).leaderNodeId();
            // Verify if this node is the master
            if (!srManager.clusterService.getLocalNode().id().equals(master)) {
                log.info("Skip {} due to lack of mastership of the topic {}", mcastIp, source.deviceId());
                return;
            }
        }
        // If it exists, we have to remove it in any case
        if (transitDevice != null) {
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // If the ingress is down
        if (ingressDevice.equals(deviceDown)) {
            // Remove entire ingress
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
            // If other sinks different from the ingress exist
            if (!egressDevices.isEmpty()) {
                // Remove all the remaining egress
                egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
            }
        } else {
            // Egress or transit could be down at this point
            // Get the ingress-transit port if it exists
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                // Remove transit-facing port on ingress device
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
            }
            // One of the egress device is down
            if (egressDevices.contains(deviceDown)) {
                // Remove entire device down
                removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                // Remove the device down from egress
                egressDevices.remove(deviceDown);
                // If there are no more egress and ingress does not have sinks
                if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                    // Remove entire ingress
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                    // We have done
                    return;
                }
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                // If there is a new path
                if (mcastPath.isPresent()) {
                    // Let's install the new mcast path for this egress
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    // We were not able to find an alternative path for this egress
                    log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        }
    });
}
#method_after
protected void processDeviceDown(DeviceId deviceDown) {
    // Get the mcast groups affected by the device going down
    getAffectedGroups(deviceDown).forEach(mcastIp -> {
        // TODO Optimize when the group editing is in place
        log.debug("Processing device down {} for group {}", deviceDown, mcastIp);
        // Find out the ingress, transit and egress device of affected group
        DeviceId ingressDevice = getDevice(mcastIp, McastRole.INGRESS).stream().findAny().orElse(null);
        DeviceId transitDevice = getDevice(mcastIp, McastRole.TRANSIT).stream().findAny().orElse(null);
        Set<DeviceId> egressDevices = getDevice(mcastIp, McastRole.EGRESS);
        ConnectPoint source = getSource(mcastIp);
        // If sinks are in the same leaf, we have just ingress and source
        if (ingressDevice == null || source == null) {
            log.warn("Missing ingress {} or source {} for group {}", ingressDevice, source, mcastIp);
            return;
        }
        // Continue only when we have the mastership on the operation
        if (!srManager.mastershipService.isLocalMaster(source.deviceId())) {
            // When the source is available we just check the mastership
            if (srManager.deviceService.isAvailable(source.deviceId())) {
                log.info("Skip {} due to lack of mastership of the source device {}", mcastIp, source.deviceId());
                return;
            }
            // Fallback with Leadership service
            // source id is used a topic
            NodeId leader = srManager.leadershipService.runForLeadership(source.deviceId().toString()).leaderNodeId();
            // Verify if this node is the leader
            if (!srManager.clusterService.getLocalNode().id().equals(leader)) {
                log.info("Skip {} due to lack of leadership on the topic {}", mcastIp, source.deviceId());
                return;
            }
        }
        // If it exists, we have to remove it in any case
        if (transitDevice != null) {
            // Remove entire transit
            removeGroupFromDevice(transitDevice, mcastIp, assignedVlan(null));
        }
        // If the ingress is down
        if (ingressDevice.equals(deviceDown)) {
            // Remove entire ingress
            removeGroupFromDevice(ingressDevice, mcastIp, assignedVlan(source));
            // If other sinks different from the ingress exist
            if (!egressDevices.isEmpty()) {
                // Remove all the remaining egress
                egressDevices.forEach(egressDevice -> removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null)));
            }
        } else {
            // Egress or transit could be down at this point
            // Get the ingress-transit port if it exists
            PortNumber ingressTransitPort = ingressTransitPort(mcastIp);
            if (ingressTransitPort != null) {
                // Remove transit-facing port on ingress device
                removePortFromDevice(ingressDevice, ingressTransitPort, mcastIp, assignedVlan(source));
            }
            // One of the egress device is down
            if (egressDevices.contains(deviceDown)) {
                // Remove entire device down
                removeGroupFromDevice(deviceDown, mcastIp, assignedVlan(null));
                // Remove the device down from egress
                egressDevices.remove(deviceDown);
                // If there are no more egress and ingress does not have sinks
                if (egressDevices.isEmpty() && !hasSinks(ingressDevice, mcastIp)) {
                    // Remove entire ingress
                    mcastRoleStore.remove(new McastStoreKey(mcastIp, ingressDevice));
                    // We have done
                    return;
                }
            }
            // Construct a new path for each egress device
            egressDevices.forEach(egressDevice -> {
                Optional<Path> mcastPath = getPath(ingressDevice, egressDevice, mcastIp);
                // If there is a new path
                if (mcastPath.isPresent()) {
                    // Let's install the new mcast path for this egress
                    installPath(mcastIp, source, mcastPath.get());
                } else {
                    // We were not able to find an alternative path for this egress
                    log.warn("Fail to recover egress device {} from device down {}", egressDevice, deviceDown);
                    removeGroupFromDevice(egressDevice, mcastIp, assignedVlan(null));
                }
            });
        }
    });
}
#end_block

#method_before
private void addPortToDevice(DeviceId deviceId, PortNumber port, IpAddress mcastIp, VlanId assignedVlan) {
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, deviceId);
    ImmutableSet.Builder<PortNumber> portBuilder = ImmutableSet.builder();
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        // First time someone request this mcast group via this device
        portBuilder.add(port);
    } else {
        // This device already serves some subscribers of this mcast group
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        // Stop if the port is already in the nextobj
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        if (existingPorts.contains(port)) {
            log.info("NextObj for {}/{} already exists. Abort", deviceId, port);
            return;
        }
        portBuilder.addAll(existingPorts).add(port).build();
    }
    // Create, store and apply the new nextObj and fwdObj
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add {} on {}/{}, vlan {}", mcastIp, deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add {} on {}/{}, vlan {}: {}", mcastIp, deviceId, port.toLong(), assignedVlan, error));
    NextObjective newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build()).add();
    ForwardingObjective fwdObj = fwdObjBuilder(mcastIp, assignedVlan, newNextObj.id()).add(context);
    mcastNextObjStore.put(mcastStoreKey, newNextObj);
    srManager.flowObjectiveService.next(deviceId, newNextObj);
    srManager.flowObjectiveService.forward(deviceId, fwdObj);
}
#method_after
private void addPortToDevice(DeviceId deviceId, PortNumber port, IpAddress mcastIp, VlanId assignedVlan) {
    McastStoreKey mcastStoreKey = new McastStoreKey(mcastIp, deviceId);
    ImmutableSet.Builder<PortNumber> portBuilder = ImmutableSet.builder();
    if (!mcastNextObjStore.containsKey(mcastStoreKey)) {
        // First time someone request this mcast group via this device
        portBuilder.add(port);
    } else {
        // This device already serves some subscribers of this mcast group
        NextObjective nextObj = mcastNextObjStore.get(mcastStoreKey).value();
        // Stop if the port is already in the nextobj
        Set<PortNumber> existingPorts = getPorts(nextObj.next());
        if (existingPorts.contains(port)) {
            log.info("NextObj for {}/{} already exists. Abort", deviceId, port);
            return;
        }
        portBuilder.addAll(existingPorts).add(port);
    }
    // Create, store and apply the new nextObj and fwdObj
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Successfully add {} on {}/{}, vlan {}", mcastIp, deviceId, port.toLong(), assignedVlan), (objective, error) -> log.warn("Failed to add {} on {}/{}, vlan {}: {}", mcastIp, deviceId, port.toLong(), assignedVlan, error));
    NextObjective newNextObj = nextObjBuilder(mcastIp, assignedVlan, portBuilder.build()).add();
    ForwardingObjective fwdObj = fwdObjBuilder(mcastIp, assignedVlan, newNextObj.id()).add(context);
    mcastNextObjStore.put(mcastStoreKey, newNextObj);
    srManager.flowObjectiveService.next(deviceId, newNextObj);
    srManager.flowObjectiveService.forward(deviceId, fwdObj);
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    l2TunnelHandler.init();
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    l2TunnelHandler.init();
    log.info("Started");
}
#end_block

#method_before
private KryoNamespace.Builder createSerializer() {
    return new KryoNamespace.Builder().register(KryoNamespaces.API).register(DestinationSetNextObjectiveStoreKey.class, VlanNextObjectiveStoreKey.class, DestinationSet.class, NextNeighbors.class, Tunnel.class, DefaultTunnel.class, Policy.class, TunnelPolicy.class, Policy.Type.class, PortNextObjectiveStoreKey.class, XConnectStoreKey.class, DefaultL2Tunnel.class, DefaultL2TunnelPolicy.class);
}
#method_after
KryoNamespace.Builder createSerializer() {
    return new KryoNamespace.Builder().register(KryoNamespaces.API).register(DestinationSetNextObjectiveStoreKey.class, VlanNextObjectiveStoreKey.class, DestinationSet.class, NextNeighbors.class, Tunnel.class, DefaultTunnel.class, Policy.class, TunnelPolicy.class, Policy.Type.class, PortNextObjectiveStoreKey.class, XConnectStoreKey.class, DefaultL2Tunnel.class, DefaultL2TunnelPolicy.class);
}
#end_block

#method_before
@Override
public void run() {
    try {
        while (true) {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                // Note: do not update seenLinks here, otherwise every
                // link, even one seen for the first time, will be appear
                // to be a previously seen link
                processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                Link linkRemoved = (Link) event.subject();
                if (linkRemoved.type() == Link.Type.DIRECT) {
                    updateSeenLink(linkRemoved, false);
                }
                // comes back.
                if (linkRemoved.src().elementId() instanceof DeviceId && !deviceService.isAvailable(linkRemoved.src().deviceId())) {
                    purgeSeenLink(linkRemoved);
                    continue;
                }
                if (linkRemoved.dst().elementId() instanceof DeviceId && !deviceService.isAvailable(linkRemoved.dst().deviceId())) {
                    purgeSeenLink(linkRemoved);
                    continue;
                }
                processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#method_after
@Override
public void run() {
    try {
        while (true) {
            @SuppressWarnings("rawtypes")
            Event event;
            synchronized (THREAD_SCHED_LOCK) {
                if (!eventQueue.isEmpty()) {
                    event = eventQueue.poll();
                    numOfEventsExecuted++;
                } else {
                    numOfHandlerExecution++;
                    log.debug("numOfHandlerExecution {} numOfEventsExecuted {}", numOfHandlerExecution, numOfEventsExecuted);
                    break;
                }
            }
            if (event.type() == LinkEvent.Type.LINK_ADDED || event.type() == LinkEvent.Type.LINK_UPDATED) {
                // Note: do not update seenLinks here, otherwise every
                // link, even one seen for the first time, will be appear
                // to be a previously seen link
                linkHandler.processLinkAdded((Link) event.subject());
            } else if (event.type() == LinkEvent.Type.LINK_REMOVED) {
                linkHandler.processLinkRemoved((Link) event.subject());
            } else if (event.type() == DeviceEvent.Type.DEVICE_ADDED || event.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED || event.type() == DeviceEvent.Type.DEVICE_UPDATED) {
                DeviceId deviceId = ((Device) event.subject()).id();
                if (deviceService.isAvailable(deviceId)) {
                    log.info("Processing device event {} for available device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceAdded((Device) event.subject());
                } else {
                    log.info("Processing device event {} for unavailable device {}", event.type(), ((Device) event.subject()).id());
                    processDeviceRemoved((Device) event.subject());
                }
            } else if (event.type() == DeviceEvent.Type.PORT_ADDED) {
                // typically these calls come when device is added first time
                // so port filtering rules are handled at the device_added event.
                // port added calls represent all ports on the device,
                // enabled or not.
                log.trace("** PORT ADDED {}/{} -> {}", ((DeviceEvent) event).subject().id(), ((DeviceEvent) event).port().number(), event.type());
            } else if (event.type() == DeviceEvent.Type.PORT_UPDATED) {
                // these calls happen for every subsequent event
                // ports enabled, disabled, switch goes away, comes back
                log.info("** PORT UPDATED {}/{} -> {}", event.subject(), ((DeviceEvent) event).port(), event.type());
                processPortUpdated(((Device) event.subject()), ((DeviceEvent) event).port());
            } else {
                log.warn("Unhandled event type: {}", event.type());
            }
        }
    } catch (Exception e) {
        log.error("SegmentRouting event handler " + "thread thrown an exception: {}", e);
    }
}
#end_block

#method_before
private void processDeviceAdded(Device device) {
    log.info("** DEVICE ADDED with ID {}", device.id());
    // NOTE: Punt ARP/NDP even when the device is not configured.
    // Host learning without network config is required for CORD config generator.
    routingRulePopulator.populateIpPunts(device.id());
    routingRulePopulator.populateArpNdpPunts(device.id());
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(device.id())) {
        log.warn("Device configuration unavailable. Device {} will be " + "processed after configuration.", device.id());
        return;
    }
    processDeviceAddedInternal(device.id());
}
#method_after
void processDeviceAdded(Device device) {
    log.info("** DEVICE ADDED with ID {}", device.id());
    // NOTE: Punt ARP/NDP even when the device is not configured.
    // Host learning without network config is required for CORD config generator.
    routingRulePopulator.populateIpPunts(device.id());
    routingRulePopulator.populateArpNdpPunts(device.id());
    if (deviceConfiguration == null || !deviceConfiguration.isConfigured(device.id())) {
        log.warn("Device configuration unavailable. Device {} will be " + "processed after configuration.", device.id());
        return;
    }
    processDeviceAddedInternal(device.id());
}
#end_block

#method_before
private void processDeviceRemoved(Device device) {
    dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> dsNextObjStore.remove(entry.getKey()));
    vlanNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> vlanNextObjStore.remove(entry.getKey()));
    portNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> portNextObjStore.remove(entry.getKey()));
    seenLinks.keySet().removeIf(key -> key.src().deviceId().equals(device.id()) || key.dst().deviceId().equals(device.id()));
    DefaultGroupHandler gh = groupHandlerMap.remove(device.id());
    if (gh != null) {
        gh.shutdown();
    }
    defaultRoutingHandler.purgeEcmpGraph(device.id());
    // Note that a switch going down is associated with all of its links
    // going down as well, but it is treated as a single switch down event
    // while the link-downs are ignored.
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, null, device.id());
    mcastHandler.processDeviceDown(device.id());
    xConnectHandler.removeDevice(device.id());
}
#method_after
private void processDeviceRemoved(Device device) {
    dsNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> dsNextObjStore.remove(entry.getKey()));
    vlanNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> vlanNextObjStore.remove(entry.getKey()));
    portNextObjStore.entrySet().stream().filter(entry -> entry.getKey().deviceId().equals(device.id())).forEach(entry -> portNextObjStore.remove(entry.getKey()));
    linkHandler.processDeviceRemoved(device);
    DefaultGroupHandler gh = groupHandlerMap.remove(device.id());
    if (gh != null) {
        gh.shutdown();
    }
    // Note that a switch going down is associated with all of its links
    // going down as well, but it is treated as a single switch down event
    // while the link-downs are ignored.
    defaultRoutingHandler.populateRoutingRulesForLinkStatusChange(null, null, device.id());
    defaultRoutingHandler.purgeEcmpGraph(device.id());
    mcastHandler.processDeviceDown(device.id());
    xConnectHandler.removeDevice(device.id());
}
#end_block

#method_before
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    Set<OchSignal> signals = Collections.emptySet();
    for (OFPortDesc pd : getPortDescs()) {
        if (pd.getPortNo().getPortNumber() == port.toLong()) {
            for (OFPortDescProp prop : pd.getProperties()) {
                if (prop instanceof OFPortDescPropOptical) {
                    OFPortDescPropOptical oprop = (OFPortDescPropOptical) prop;
                    long txMin = oprop.getTxMinFreqLmda();
                    long txMax = oprop.getTxMaxFreqLmda();
                    long txGrid = oprop.getTxGridFreqLmda();
                    signals.addAll(signals(txMin, txMax, txGrid));
                    long rxMin = oprop.getRxMinFreqLmda();
                    long rxMax = oprop.getRxMaxFreqLmda();
                    long rxGrid = oprop.getRxGridFreqLmda();
                    signals.addAll(signals(rxMin, rxMax, rxGrid));
                }
            }
        }
    }
    return signals;
}
#method_after
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    Set<OchSignal> signals = new LinkedHashSet<>();
    for (OFPortDesc pd : getPortDescs()) {
        if (pd.getPortNo().getPortNumber() == port.toLong()) {
            for (OFPortDescProp prop : pd.getProperties()) {
                if (prop instanceof OFPortDescPropOptical) {
                    OFPortDescPropOptical oprop = (OFPortDescPropOptical) prop;
                    long txMin = oprop.getTxMinFreqLmda();
                    long txMax = oprop.getTxMaxFreqLmda();
                    long txGrid = oprop.getTxGridFreqLmda();
                    signals.addAll(signals(txMin, txMax, txGrid));
                    long rxMin = oprop.getRxMinFreqLmda();
                    long rxMax = oprop.getRxMaxFreqLmda();
                    long rxGrid = oprop.getRxGridFreqLmda();
                    signals.addAll(signals(rxMin, rxMax, rxGrid));
                }
            }
        }
    }
    return signals;
}
#end_block

#method_before
private Set<OchSignal> signals(long min, long max, long grid) {
    if (Spectrum.O_BAND_MIN.asMHz() > min) {
        log.warn("Out of range frequency (below the O-band minimum)");
    }
    if (Spectrum.U_BAND_MAX.asMHz() < max) {
        log.warn("Out of range frequency (above the U-band maximum)");
    }
    double centerFrequencyMHz = Spectrum.CENTER_FREQUENCY.asMHz();
    long startSpacingMultiplier = (long) (min - centerFrequencyMHz) / grid;
    long stopSpacingMultiplier = (long) (max - centerFrequencyMHz) / grid;
    if (grid == ChannelSpacing.CHL_100GHZ.frequency().asMHz()) {
        return IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(i -> new OchSignal(GridType.DWDM, ChannelSpacing.CHL_100GHZ, i, 8)).collect(GuavaCollectors.toImmutableSet());
    } else if (grid == ChannelSpacing.CHL_50GHZ.frequency().asMHz()) {
        return IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(i -> new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ, i, 4)).collect(GuavaCollectors.toImmutableSet());
    } else if (grid == ChannelSpacing.CHL_25GHZ.frequency().asMHz()) {
        return IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(i -> new OchSignal(GridType.DWDM, ChannelSpacing.CHL_25GHZ, i, 2)).collect(GuavaCollectors.toImmutableSet());
    } else if (grid == ChannelSpacing.CHL_12P5GHZ.frequency().asMHz()) {
        return IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(i -> new OchSignal(GridType.DWDM, ChannelSpacing.CHL_6P25GHZ, i, 1)).collect(GuavaCollectors.toImmutableSet());
    } else if (grid == ChannelSpacing.CHL_6P25GHZ.frequency().asMHz()) {
        // Only consider odd values for the multiplier (for easy mapping to fixed grid)
        return IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).filter(i -> i % 2 == 1).mapToObj(i -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_6P25GHZ, i, 1)).collect(GuavaCollectors.toImmutableSet());
    } else {
        log.warn("Unsupported channel spacing");
    }
    return Collections.emptySet();
}
#method_after
private Set<OchSignal> signals(long min, long max, long grid) {
    if (Spectrum.O_BAND_MIN.asMHz() > min) {
        log.warn("Out of range frequency (below the O-band minimum)");
    }
    if (Spectrum.U_BAND_MAX.asMHz() < max) {
        log.warn("Out of range frequency (above the U-band maximum)");
    }
    double centerFrequencyMHz = Spectrum.CENTER_FREQUENCY.asMHz();
    long startSpacingMultiplier = (long) (min - centerFrequencyMHz) / grid;
    long stopSpacingMultiplier = (long) (max - centerFrequencyMHz) / grid;
    Set<OchSignal> signals = new LinkedHashSet<>();
    if (grid == ChannelSpacing.CHL_100GHZ.frequency().asMHz()) {
        signals = IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(i -> new OchSignal(GridType.DWDM, ChannelSpacing.CHL_100GHZ, i, 8)).collect(GuavaCollectors.toImmutableSet());
    } else if (grid == ChannelSpacing.CHL_50GHZ.frequency().asMHz()) {
        signals = IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(i -> new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ, i, 4)).collect(GuavaCollectors.toImmutableSet());
    } else if (grid == ChannelSpacing.CHL_25GHZ.frequency().asMHz()) {
        signals = IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(i -> new OchSignal(GridType.DWDM, ChannelSpacing.CHL_25GHZ, i, 2)).collect(GuavaCollectors.toImmutableSet());
    } else if (grid == ChannelSpacing.CHL_12P5GHZ.frequency().asMHz()) {
        signals = IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).mapToObj(i -> new OchSignal(GridType.DWDM, ChannelSpacing.CHL_6P25GHZ, i, 1)).collect(GuavaCollectors.toImmutableSet());
    } else if (grid == ChannelSpacing.CHL_6P25GHZ.frequency().asMHz()) {
        // Only consider odd values for the multiplier (for easy mapping to fixed grid)
        signals = IntStream.rangeClosed((int) startSpacingMultiplier, (int) stopSpacingMultiplier).filter(i -> i % 2 == 1).mapToObj(i -> new OchSignal(GridType.FLEX, ChannelSpacing.CHL_6P25GHZ, i, 1)).collect(GuavaCollectors.toImmutableSet());
    } else {
        log.warn("Unsupported channel spacing");
    }
    return signals;
}
#end_block

#method_before
Path reverse(Path path) {
    List<Link> revLinks = Lists.reverse(transform(path.links(), this::reverse));
    return new DefaultPath(path.providerId(), revLinks, ScalarWeight.toWeight(path.cost()), path.annotations());
}
#method_after
Path reverse(Path path) {
    List<Link> revLinks = Lists.reverse(transform(path.links(), this::reverse));
    return new DefaultPath(path.providerId(), revLinks, path.weight(), path.annotations());
}
#end_block

#method_before
@Deprecated
private List<Intent> createUnprotectedIntent(ConnectPoint ingressPoint, ConnectPoint egressPoint, PointToPointIntent intent) {
    List<Link> links = new ArrayList<>();
    Path path = getPathOrException(intent, ingressPoint.deviceId(), egressPoint.deviceId());
    links.add(createEdgeLink(ingressPoint, true));
    links.addAll(path.links());
    links.add(createEdgeLink(egressPoint, false));
    return asList(createPathIntent(new DefaultPath(PID, links, ScalarWeight.toWeight(path.cost()), path.annotations()), intent, PathIntent.ProtectionType.PRIMARY));
}
#method_after
@Deprecated
private List<Intent> createUnprotectedIntent(ConnectPoint ingressPoint, ConnectPoint egressPoint, PointToPointIntent intent) {
    List<Link> links = new ArrayList<>();
    Path path = getPathOrException(intent, ingressPoint.deviceId(), egressPoint.deviceId());
    links.add(createEdgeLink(ingressPoint, true));
    links.addAll(path.links());
    links.add(createEdgeLink(egressPoint, false));
    return asList(createPathIntent(new DefaultPath(PID, links, path.weight(), path.annotations()), intent, PathIntent.ProtectionType.PRIMARY));
}
#end_block

#method_before
private List<Intent> createProtectedIntent(ConnectPoint ingressPoint, ConnectPoint egressPoint, PointToPointIntent intent, List<Intent> installable) {
    log.trace("createProtectedIntent");
    DisjointPath path = getDisjointPath(intent, ingressPoint.deviceId(), egressPoint.deviceId());
    List<Intent> reusableIntents = null;
    if (installable != null) {
        reusableIntents = filterInvalidSubIntents(installable, intent);
        if (reusableIntents.size() == installable.size()) {
            // all old paths are still viable
            return installable;
        }
    }
    List<Intent> intentList = new ArrayList<>();
    // primary path intent
    List<Link> links = new ArrayList<>();
    links.addAll(path.links());
    links.add(createEdgeLink(egressPoint, false));
    // backup path intent
    List<Link> backupLinks = new ArrayList<>();
    backupLinks.addAll(path.backup().links());
    backupLinks.add(createEdgeLink(egressPoint, false));
    /*
         * One of the old paths is still entirely intact. This old path has
         * already been made primary, so we must add a backup path intent
         * and modify the failover group treatment accordingly.
         */
    if (reusableIntents != null && reusableIntents.size() > 1) {
        /*
             * Ensures that the egress port on source device is different than
             * that of existing path so that failover group will be useful
             * (would not be useful if both output ports in group bucket were
             * the same). Does not necessarily ensure that the new backup path
             * is entirely disjoint from the old path.
             */
        PortNumber primaryPort = getPrimaryPort(intent);
        if (primaryPort != null && !links.get(0).src().port().equals(primaryPort)) {
            reusableIntents.add(createPathIntent(new DefaultPath(PID, links, ScalarWeight.toWeight(path.cost()), path.annotations()), intent, PathIntent.ProtectionType.BACKUP));
            updateFailoverGroup(intent, links);
            return reusableIntents;
        } else {
            reusableIntents.add(createPathIntent(new DefaultPath(PID, backupLinks, ScalarWeight.toWeight(path.backup().cost()), path.backup().annotations()), intent, PathIntent.ProtectionType.BACKUP));
            updateFailoverGroup(intent, backupLinks);
            return reusableIntents;
        }
    }
    intentList.add(createPathIntent(new DefaultPath(PID, links, ScalarWeight.toWeight(path.cost()), path.annotations()), intent, PathIntent.ProtectionType.PRIMARY));
    intentList.add(createPathIntent(new DefaultPath(PID, backupLinks, ScalarWeight.toWeight(path.backup().cost()), path.backup().annotations()), intent, PathIntent.ProtectionType.BACKUP));
    // add contents appropriately.
    if (groupService.getGroup(ingressPoint.deviceId(), makeGroupKey(intent.id())) == null) {
        // manufactured fast failover flow rule intent
        createFailoverTreatmentGroup(path.links(), path.backup().links(), intent);
        FlowRuleIntent frIntent = new FlowRuleIntent(intent.appId(), intent.key(), createFailoverFlowRules(intent), asList(ingressPoint.deviceId()), PathIntent.ProtectionType.FAILOVER, intent.resourceGroup());
        intentList.add(frIntent);
    } else {
        updateFailoverGroup(intent, links);
        updateFailoverGroup(intent, backupLinks);
    }
    return intentList;
}
#method_after
private List<Intent> createProtectedIntent(ConnectPoint ingressPoint, ConnectPoint egressPoint, PointToPointIntent intent, List<Intent> installable) {
    log.trace("createProtectedIntent");
    DisjointPath path = getDisjointPath(intent, ingressPoint.deviceId(), egressPoint.deviceId());
    List<Intent> reusableIntents = null;
    if (installable != null) {
        reusableIntents = filterInvalidSubIntents(installable, intent);
        if (reusableIntents.size() == installable.size()) {
            // all old paths are still viable
            return installable;
        }
    }
    List<Intent> intentList = new ArrayList<>();
    // primary path intent
    List<Link> links = new ArrayList<>();
    links.addAll(path.links());
    links.add(createEdgeLink(egressPoint, false));
    // backup path intent
    List<Link> backupLinks = new ArrayList<>();
    backupLinks.addAll(path.backup().links());
    backupLinks.add(createEdgeLink(egressPoint, false));
    /*
         * One of the old paths is still entirely intact. This old path has
         * already been made primary, so we must add a backup path intent
         * and modify the failover group treatment accordingly.
         */
    if (reusableIntents != null && reusableIntents.size() > 1) {
        /*
             * Ensures that the egress port on source device is different than
             * that of existing path so that failover group will be useful
             * (would not be useful if both output ports in group bucket were
             * the same). Does not necessarily ensure that the new backup path
             * is entirely disjoint from the old path.
             */
        PortNumber primaryPort = getPrimaryPort(intent);
        if (primaryPort != null && !links.get(0).src().port().equals(primaryPort)) {
            reusableIntents.add(createPathIntent(new DefaultPath(PID, links, path.weight(), path.annotations()), intent, PathIntent.ProtectionType.BACKUP));
            updateFailoverGroup(intent, links);
            return reusableIntents;
        } else {
            reusableIntents.add(createPathIntent(new DefaultPath(PID, backupLinks, path.backup().weight(), path.backup().annotations()), intent, PathIntent.ProtectionType.BACKUP));
            updateFailoverGroup(intent, backupLinks);
            return reusableIntents;
        }
    }
    intentList.add(createPathIntent(new DefaultPath(PID, links, path.weight(), path.annotations()), intent, PathIntent.ProtectionType.PRIMARY));
    intentList.add(createPathIntent(new DefaultPath(PID, backupLinks, path.backup().weight(), path.backup().annotations()), intent, PathIntent.ProtectionType.BACKUP));
    // add contents appropriately.
    if (groupService.getGroup(ingressPoint.deviceId(), makeGroupKey(intent.id())) == null) {
        // manufactured fast failover flow rule intent
        createFailoverTreatmentGroup(path.links(), path.backup().links(), intent);
        FlowRuleIntent frIntent = new FlowRuleIntent(intent.appId(), intent.key(), createFailoverFlowRules(intent), asList(ingressPoint.deviceId()), PathIntent.ProtectionType.FAILOVER, intent.resourceGroup());
        intentList.add(frIntent);
    } else {
        updateFailoverGroup(intent, links);
        updateFailoverGroup(intent, backupLinks);
    }
    return intentList;
}
#end_block

#method_before
private List<Intent> createSinglePathIntent(ConnectPoint ingressPoint, ConnectPoint egressPoint, PointToPointIntent intent, List<Intent> installable) {
    List<Link> links = new ArrayList<>();
    Path onlyPath = getPathOrException(intent, ingressPoint.deviceId(), egressPoint.deviceId());
    List<Intent> reusableIntents = null;
    if (installable != null) {
        reusableIntents = filterInvalidSubIntents(installable, intent);
        if (reusableIntents.size() == installable.size()) {
            // all old paths are still viable
            return installable;
        }
    }
    // return the intents that comprise it.
    if (reusableIntents != null && reusableIntents.size() > 1) {
        return reusableIntents;
    } else {
        // Allocate bandwidth if a bandwidth constraint is set
        ConnectPoint ingressCP = intent.filteredIngressPoint().connectPoint();
        ConnectPoint egressCP = intent.filteredEgressPoint().connectPoint();
        List<ConnectPoint> pathCPs = onlyPath.links().stream().flatMap(l -> Stream.of(l.src(), l.dst())).collect(Collectors.toList());
        pathCPs.add(ingressCP);
        pathCPs.add(egressCP);
        // Allocate bandwidth if a bandwidth constraint is set
        allocateBandwidth(intent, pathCPs);
        links.add(createEdgeLink(ingressPoint, true));
        links.addAll(onlyPath.links());
        links.add(createEdgeLink(egressPoint, false));
        return asList(createPathIntent(new DefaultPath(PID, links, ScalarWeight.toWeight(onlyPath.cost()), onlyPath.annotations()), intent, PathIntent.ProtectionType.PRIMARY));
    }
}
#method_after
private List<Intent> createSinglePathIntent(ConnectPoint ingressPoint, ConnectPoint egressPoint, PointToPointIntent intent, List<Intent> installable) {
    List<Link> links = new ArrayList<>();
    Path onlyPath = getPathOrException(intent, ingressPoint.deviceId(), egressPoint.deviceId());
    List<Intent> reusableIntents = null;
    if (installable != null) {
        reusableIntents = filterInvalidSubIntents(installable, intent);
        if (reusableIntents.size() == installable.size()) {
            // all old paths are still viable
            return installable;
        }
    }
    // return the intents that comprise it.
    if (reusableIntents != null && reusableIntents.size() > 1) {
        return reusableIntents;
    } else {
        // Allocate bandwidth if a bandwidth constraint is set
        ConnectPoint ingressCP = intent.filteredIngressPoint().connectPoint();
        ConnectPoint egressCP = intent.filteredEgressPoint().connectPoint();
        List<ConnectPoint> pathCPs = onlyPath.links().stream().flatMap(l -> Stream.of(l.src(), l.dst())).collect(Collectors.toList());
        pathCPs.add(ingressCP);
        pathCPs.add(egressCP);
        // Allocate bandwidth if a bandwidth constraint is set
        allocateBandwidth(intent, pathCPs);
        links.add(createEdgeLink(ingressPoint, true));
        links.addAll(onlyPath.links());
        links.add(createEdgeLink(egressPoint, false));
        return asList(createPathIntent(new DefaultPath(PID, links, onlyPath.weight(), onlyPath.annotations()), intent, PathIntent.ProtectionType.PRIMARY));
    }
}
#end_block

#method_before
// Inverts the specified path. This makes an assumption that each link in
// the path has a reverse link available. Under most circumstances, this
private Path invertPath(Path path) {
    List<Link> reverseLinks = new ArrayList<>(path.links().size());
    for (Link link : path.links()) {
        reverseLinks.add(0, reverseLink(link));
    }
    return new DefaultPath(path.providerId(), reverseLinks, ScalarWeight.toWeight(path.cost()));
}
#method_after
// Inverts the specified path. This makes an assumption that each link in
// the path has a reverse link available. Under most circumstances, this
private Path invertPath(Path path) {
    List<Link> reverseLinks = new ArrayList<>(path.links().size());
    for (Link link : path.links()) {
        reverseLinks.add(0, reverseLink(link));
    }
    return new DefaultPath(path.providerId(), reverseLinks, path.weight());
}
#end_block

#method_before
@GET
@Path("{user}/{pref}")
@Produces(MediaType.APPLICATION_JSON)
public Response download(@PathParam("user") String user, @PathParam("pref") String pref) {
    UiPreferencesService service = get(UiPreferencesService.class);
    return ok(service.getPreference(user, pref)).build();
}
#method_after
@GET
@Path("{user}/{pref}")
@Produces(MediaType.APPLICATION_JSON)
public Response download(@PathParam("user") String user, @PathParam("pref") String pref) {
    UiPreferencesService service = get(UiPreferencesService.class);
    return ok(nullIsNotFound(service.getPreference(user, pref), "No such preference")).build();
}
#end_block

#method_before
private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {
    return CompletableFuture.supplyAsync(() -> {
        // TODO: explore a more relaxed locking strategy.
        writeLock.lock();
        try {
            return supplier.get();
        } catch (Throwable ex) {
            if (ex instanceof StatusRuntimeException) {
                String statusString = ((StatusRuntimeException) ex).getStatus().getDescription();
                try {
                    com.google.rpc.Status status = com.google.rpc.Status.parseFrom(statusString.getBytes());
                    log.warn("Unable to execute {} on {}: {}", opDescription, deviceId, status.toString());
                } catch (InvalidProtocolBufferException e) {
                    log.warn("Unable to execute {} on {}: {}", opDescription, deviceId, statusString);
                } catch (NullPointerException e) {
                    log.warn("Unable to execute {} on {}: no error detail", opDescription, deviceId);
                }
            } else {
                log.error("Exception in client of {}, executing {}", deviceId, opDescription, ex);
            }
            throw ex;
        } finally {
            writeLock.unlock();
        }
    }, contextExecutor);
}
#method_after
private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {
    return CompletableFuture.supplyAsync(() -> {
        // TODO: explore a more relaxed locking strategy.
        writeLock.lock();
        try {
            return supplier.get();
        } catch (StatusRuntimeException ex) {
            logP4RuntimeErrorStatus(ex, opDescription);
            throw ex;
        } catch (Throwable ex) {
            log.error("Exception in client of {}, executing {}", deviceId, opDescription, ex);
            throw ex;
        } finally {
            writeLock.unlock();
        }
    }, contextExecutor);
}
#end_block

#method_before
/* Blocking method implementations below */
private boolean doArbitrationUpdate() {
    CompletableFuture<Boolean> result = new CompletableFuture<>();
    // TODO: currently we use 64-bit Long type for election id, should
    // we use 128-bit ?
    long nextElectId = controller.getNewMasterElectionId();
    Uint128 newElectionId = Uint128.newBuilder().setLow(nextElectId).build();
    MasterArbitrationUpdate arbitrationUpdate = MasterArbitrationUpdate.newBuilder().setDeviceId(p4DeviceId).setElectionId(newElectionId).build();
    StreamMessageRequest requestMsg = StreamMessageRequest.newBuilder().setArbitration(arbitrationUpdate).build();
    log.debug("Sending arbitration update to {} with election id {}...", deviceId, newElectionId);
    arbitrationUpdateMap.put(newElectionId, result);
    try {
        streamRequestObserver.onNext(requestMsg);
        return result.get();
    } catch (InterruptedException | ExecutionException | StatusRuntimeException e) {
        log.warn("Arbitration update failed for {} due to {}", deviceId, e);
        arbitrationUpdateMap.remove(newElectionId);
        return false;
    }
}
#method_after
/* Blocking method implementations below */
private boolean doArbitrationUpdate() {
    CompletableFuture<Boolean> result = new CompletableFuture<>();
    // TODO: currently we use 64-bit Long type for election id, should
    // we use 128-bit ?
    long nextElectId = controller.getNewMasterElectionId();
    Uint128 newElectionId = Uint128.newBuilder().setLow(nextElectId).build();
    MasterArbitrationUpdate arbitrationUpdate = MasterArbitrationUpdate.newBuilder().setDeviceId(p4DeviceId).setElectionId(newElectionId).build();
    StreamMessageRequest requestMsg = StreamMessageRequest.newBuilder().setArbitration(arbitrationUpdate).build();
    log.debug("Sending arbitration update to {} with election id {}...", deviceId, newElectionId);
    arbitrationUpdateMap.put(newElectionId, result);
    try {
        streamRequestObserver.onNext(requestMsg);
        return result.get();
    } catch (StatusRuntimeException e) {
        logP4RuntimeErrorStatus(e, "Arbitration update");
        arbitrationUpdateMap.remove(newElectionId);
        return false;
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Arbitration update failed for {} due to {}", deviceId, e);
        arbitrationUpdateMap.remove(newElectionId);
        return false;
    }
}
#end_block

#method_before
private boolean doSetPipelineConfig(PiPipeconf pipeconf, ByteBuffer deviceData) {
    log.info("Setting pipeline config for {} to {}...", deviceId, pipeconf.id());
    checkNotNull(deviceData, "deviceData cannot be null");
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return false;
    }
    P4Config.P4DeviceConfig p4DeviceConfigMsg = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.copyFrom(deviceData)).build();
    ForwardingPipelineConfig pipelineConfig = ForwardingPipelineConfig.newBuilder().setP4Info(p4Info).setP4DeviceConfig(p4DeviceConfigMsg.toByteString()).build();
    SetForwardingPipelineConfigRequest request = SetForwardingPipelineConfigRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).setAction(VERIFY_AND_COMMIT).setConfig(pipelineConfig).build();
    try {
        this.blockingStub.setForwardingPipelineConfig(request);
        return true;
    } catch (StatusRuntimeException ex) {
        log.warn("Unable to set pipeline config for {}: {}", deviceId, ex.getMessage());
        return false;
    }
}
#method_after
private boolean doSetPipelineConfig(PiPipeconf pipeconf, ByteBuffer deviceData) {
    log.info("Setting pipeline config for {} to {}...", deviceId, pipeconf.id());
    checkNotNull(deviceData, "deviceData cannot be null");
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return false;
    }
    P4Config.P4DeviceConfig p4DeviceConfigMsg = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.copyFrom(deviceData)).build();
    ForwardingPipelineConfig pipelineConfig = ForwardingPipelineConfig.newBuilder().setP4Info(p4Info).setP4DeviceConfig(p4DeviceConfigMsg.toByteString()).build();
    SetForwardingPipelineConfigRequest request = SetForwardingPipelineConfigRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).setAction(VERIFY_AND_COMMIT).setConfig(pipelineConfig).build();
    try {
        this.blockingStub.setForwardingPipelineConfig(request);
        return true;
    } catch (StatusRuntimeException ex) {
        logP4RuntimeErrorStatus(ex, "Set pipeline config");
        return false;
    }
}
#end_block

#method_before
private boolean doWriteTableEntries(Collection<PiTableEntry> piTableEntries, WriteOperationType opType, PiPipeconf pipeconf) {
    WriteRequest.Builder writeRequestBuilder = WriteRequest.newBuilder();
    Collection<Update> updateMsgs = TableEntryEncoder.encode(piTableEntries, pipeconf).stream().map(tableEntryMsg -> Update.newBuilder().setEntity(Entity.newBuilder().setTableEntry(tableEntryMsg).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        return true;
    }
    writeRequestBuilder.setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestBuilder.build());
        return true;
    } catch (StatusRuntimeException e) {
        log.warn("Unable to write table entries ({}): {}", opType, e.getMessage());
        return false;
    }
}
#method_after
private boolean doWriteTableEntries(Collection<PiTableEntry> piTableEntries, WriteOperationType opType, PiPipeconf pipeconf) {
    WriteRequest.Builder writeRequestBuilder = WriteRequest.newBuilder();
    Collection<Update> updateMsgs = TableEntryEncoder.encode(piTableEntries, pipeconf).stream().map(tableEntryMsg -> Update.newBuilder().setEntity(Entity.newBuilder().setTableEntry(tableEntryMsg).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        return true;
    }
    writeRequestBuilder.setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestBuilder.build());
        return true;
    } catch (StatusRuntimeException e) {
        logP4RuntimeErrorStatus(e, "Write table entries");
        return false;
    }
}
#end_block

#method_before
private Collection<PiTableEntry> doDumpTable(PiTableId piTableId, PiPipeconf pipeconf) {
    log.debug("Dumping table {} from {} (pipeconf {})...", piTableId, deviceId, pipeconf.id());
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    int tableId;
    try {
        tableId = browser.tables().getByName(piTableId.id()).getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    ReadRequest requestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setTableEntry(TableEntry.newBuilder().setTableId(tableId).build()).build()).build();
    Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    Iterable<ReadResponse> responseIterable = () -> responses;
    List<TableEntry> tableEntryMsgs = StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == TABLE_ENTRY).map(Entity::getTableEntry).collect(Collectors.toList());
    log.debug("Retrieved {} entries from table {} on {}...", tableEntryMsgs.size(), piTableId, deviceId);
    return TableEntryEncoder.decode(tableEntryMsgs, pipeconf);
}
#method_after
private Collection<PiTableEntry> doDumpTable(PiTableId piTableId, PiPipeconf pipeconf) {
    log.debug("Dumping table {} from {} (pipeconf {})...", piTableId, deviceId, pipeconf.id());
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    int tableId;
    try {
        tableId = browser.tables().getByName(piTableId.id()).getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    ReadRequest requestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setTableEntry(TableEntry.newBuilder().setTableId(tableId).build()).build()).build();
    Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestMsg);
    } catch (StatusRuntimeException e) {
        logP4RuntimeErrorStatus(e, "Dump table");
        return Collections.emptyList();
    }
    Iterable<ReadResponse> responseIterable = () -> responses;
    List<TableEntry> tableEntryMsgs = StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == TABLE_ENTRY).map(Entity::getTableEntry).collect(Collectors.toList());
    log.debug("Retrieved {} entries from table {} on {}...", tableEntryMsgs.size(), piTableId, deviceId);
    return TableEntryEncoder.decode(tableEntryMsgs, pipeconf);
}
#end_block

#method_before
private Collection<PiCounterCellData> doReadCounterCells(Collection<PiCounterCellId> cellIds, PiPipeconf pipeconf) {
    // We use this map to remember the original PI counter IDs of the returned response.
    final Map<Integer, PiCounterId> counterIdMap = Maps.newHashMap();
    final ReadRequest request = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addAllEntities(CounterEntryCodec.encodePiCounterCellIds(cellIds, counterIdMap, pipeconf)).build();
    if (request.getEntitiesList().size() == 0) {
        return Collections.emptyList();
    }
    final Iterable<ReadResponse> responses;
    try {
        responses = () -> blockingStub.read(request);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read counters: {}", e.getMessage());
        return Collections.emptyList();
    }
    List<Entity> entities = StreamSupport.stream(responses.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).collect(Collectors.toList());
    return CounterEntryCodec.decodeCounterEntities(entities, counterIdMap, pipeconf);
}
#method_after
private Collection<PiCounterCellData> doReadCounterCells(Collection<PiCounterCellId> cellIds, PiPipeconf pipeconf) {
    // We use this map to remember the original PI counter IDs of the returned response.
    final Map<Integer, PiCounterId> counterIdMap = Maps.newHashMap();
    final ReadRequest request = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addAllEntities(CounterEntryCodec.encodePiCounterCellIds(cellIds, counterIdMap, pipeconf)).build();
    if (request.getEntitiesList().size() == 0) {
        return Collections.emptyList();
    }
    final Iterable<ReadResponse> responses;
    try {
        responses = () -> blockingStub.read(request);
    } catch (StatusRuntimeException e) {
        logP4RuntimeErrorStatus(e, "Read counter");
        return Collections.emptyList();
    }
    List<Entity> entities = StreamSupport.stream(responses.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).collect(Collectors.toList());
    return CounterEntryCodec.decodeCounterEntities(entities, counterIdMap, pipeconf);
}
#end_block

#method_before
private boolean doWriteActionGroupMembers(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    final Collection<ActionProfileMember> actionProfileMembers = Lists.newArrayList();
    try {
        for (PiActionGroupMember member : group.members()) {
            actionProfileMembers.add(ActionProfileMemberEncoder.encode(group, member, pipeconf));
        }
    } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to write ({}) group members: {}", opType, e.getMessage());
        return false;
    }
    final Collection<Update> updateMsgs = actionProfileMembers.stream().map(actionProfileMember -> Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileMember(actionProfileMember).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        // Nothing to update.
        return true;
    }
    WriteRequest writeRequestMsg = WriteRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestMsg);
        return true;
    } catch (StatusRuntimeException e) {
        log.warn("Unable to write ({}) group members: {}", opType, e.getMessage());
        return false;
    }
}
#method_after
private boolean doWriteActionGroupMembers(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    final Collection<ActionProfileMember> actionProfileMembers = Lists.newArrayList();
    try {
        for (PiActionGroupMember member : group.members()) {
            actionProfileMembers.add(ActionProfileMemberEncoder.encode(group, member, pipeconf));
        }
    } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to write ({}) group members: {}", opType, e.getMessage());
        return false;
    }
    final Collection<Update> updateMsgs = actionProfileMembers.stream().map(actionProfileMember -> Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileMember(actionProfileMember).build()).setType(UPDATE_TYPES.get(opType)).build()).collect(Collectors.toList());
    if (updateMsgs.size() == 0) {
        // Nothing to update.
        return true;
    }
    WriteRequest writeRequestMsg = WriteRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addAllUpdates(updateMsgs).build();
    try {
        blockingStub.write(writeRequestMsg);
        return true;
    } catch (StatusRuntimeException e) {
        logP4RuntimeErrorStatus(e, String.format("%s group members", opType));
        return false;
    }
}
#end_block

#method_before
private Collection<PiActionGroup> doDumpGroups(PiActionProfileId piActionProfileId, PiPipeconf pipeconf) {
    log.debug("Dumping groups from action profile {} from {} (pipeconf {})...", piActionProfileId.id(), deviceId, pipeconf.id());
    final P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    if (browser == null) {
        log.warn("Unable to get a P4Info browser for pipeconf {}, aborting dump action profile", pipeconf);
        return Collections.emptySet();
    }
    final int actionProfileId;
    try {
        actionProfileId = browser.actionProfiles().getByName(piActionProfileId.id()).getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to dump groups: {}", e.getMessage());
        return Collections.emptySet();
    }
    // Prepare read request to read all groups from the given action profile.
    final ReadRequest groupRequestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setActionProfileGroup(ActionProfileGroup.newBuilder().setActionProfileId(actionProfileId).build()).build()).build();
    // Read groups.
    final Iterator<ReadResponse> groupResponses;
    try {
        groupResponses = blockingStub.read(groupRequestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable dump groups from action profile '{}': {}", piActionProfileId.id(), e.getMessage());
        return Collections.emptySet();
    }
    final List<ActionProfileGroup> groupMsgs = Tools.stream(() -> groupResponses).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == ACTION_PROFILE_GROUP).map(Entity::getActionProfileGroup).collect(Collectors.toList());
    log.debug("Retrieved {} groups from action profile {} on {}...", groupMsgs.size(), piActionProfileId.id(), deviceId);
    // Returned groups contain only a minimal description of their members.
    // We need to issue a new request to get the full description of each member.
    // Keep a map of all member IDs for each group ID, will need it later.
    final Multimap<Integer, Integer> groupIdToMemberIdsMap = HashMultimap.create();
    groupMsgs.forEach(g -> groupIdToMemberIdsMap.putAll(g.getGroupId(), g.getMembersList().stream().map(ActionProfileGroup.Member::getMemberId).collect(Collectors.toList())));
    // Prepare one big read request to read all members in one shot.
    final Set<Entity> entityMsgs = groupMsgs.stream().flatMap(g -> g.getMembersList().stream()).map(ActionProfileGroup.Member::getMemberId).distinct().map(id -> ActionProfileMember.newBuilder().setActionProfileId(actionProfileId).setMemberId(id).build()).map(m -> Entity.newBuilder().setActionProfileMember(m).build()).collect(Collectors.toSet());
    final ReadRequest memberRequestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addAllEntities(entityMsgs).build();
    // Read members.
    final Iterator<ReadResponse> memberResponses;
    try {
        memberResponses = blockingStub.read(memberRequestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read members from action profile {}: {}", piActionProfileId, e.getMessage());
        return Collections.emptyList();
    }
    final Multimap<Integer, ActionProfileMember> groupIdToMembersMap = HashMultimap.create();
    Tools.stream(() -> memberResponses).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(e -> e.getEntityCase() == ACTION_PROFILE_MEMBER).map(Entity::getActionProfileMember).forEach(member -> groupIdToMemberIdsMap.asMap().entrySet().stream().filter(entry -> entry.getValue().contains(member.getMemberId())).map(Map.Entry::getKey).forEach(gid -> groupIdToMembersMap.put(gid, member)));
    log.debug("Retrieved {} group members from action profile {} on {}...", groupIdToMembersMap.size(), piActionProfileId.id(), deviceId);
    return groupMsgs.stream().map(groupMsg -> {
        try {
            return ActionProfileGroupEncoder.decode(groupMsg, groupIdToMembersMap.get(groupMsg.getGroupId()), pipeconf);
        } catch (P4InfoBrowser.NotFoundException | EncodeException e) {
            log.warn("Unable to decode group: {}\n {}", e.getMessage(), groupMsg);
            return null;
        }
    }).filter(Objects::nonNull).collect(Collectors.toList());
}
#method_after
private Collection<PiActionGroup> doDumpGroups(PiActionProfileId piActionProfileId, PiPipeconf pipeconf) {
    log.debug("Dumping groups from action profile {} from {} (pipeconf {})...", piActionProfileId.id(), deviceId, pipeconf.id());
    final P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    if (browser == null) {
        log.warn("Unable to get a P4Info browser for pipeconf {}, aborting dump action profile", pipeconf);
        return Collections.emptySet();
    }
    final int actionProfileId;
    try {
        actionProfileId = browser.actionProfiles().getByName(piActionProfileId.id()).getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to dump groups: {}", e.getMessage());
        return Collections.emptySet();
    }
    // Prepare read request to read all groups from the given action profile.
    final ReadRequest groupRequestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setActionProfileGroup(ActionProfileGroup.newBuilder().setActionProfileId(actionProfileId).build()).build()).build();
    // Read groups.
    final Iterator<ReadResponse> groupResponses;
    try {
        groupResponses = blockingStub.read(groupRequestMsg);
    } catch (StatusRuntimeException e) {
        logP4RuntimeErrorStatus(e, String.format("Dump group from action profile %s", piActionProfileId.id()));
        return Collections.emptySet();
    }
    final List<ActionProfileGroup> groupMsgs = Tools.stream(() -> groupResponses).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == ACTION_PROFILE_GROUP).map(Entity::getActionProfileGroup).collect(Collectors.toList());
    log.debug("Retrieved {} groups from action profile {} on {}...", groupMsgs.size(), piActionProfileId.id(), deviceId);
    // Returned groups contain only a minimal description of their members.
    // We need to issue a new request to get the full description of each member.
    // Keep a map of all member IDs for each group ID, will need it later.
    final Multimap<Integer, Integer> groupIdToMemberIdsMap = HashMultimap.create();
    groupMsgs.forEach(g -> groupIdToMemberIdsMap.putAll(g.getGroupId(), g.getMembersList().stream().map(ActionProfileGroup.Member::getMemberId).collect(Collectors.toList())));
    // Prepare one big read request to read all members in one shot.
    final Set<Entity> entityMsgs = groupMsgs.stream().flatMap(g -> g.getMembersList().stream()).map(ActionProfileGroup.Member::getMemberId).distinct().map(id -> ActionProfileMember.newBuilder().setActionProfileId(actionProfileId).setMemberId(id).build()).map(m -> Entity.newBuilder().setActionProfileMember(m).build()).collect(Collectors.toSet());
    final ReadRequest memberRequestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addAllEntities(entityMsgs).build();
    // Read members.
    final Iterator<ReadResponse> memberResponses;
    try {
        memberResponses = blockingStub.read(memberRequestMsg);
    } catch (StatusRuntimeException e) {
        logP4RuntimeErrorStatus(e, String.format("Read members from action profile %s", piActionProfileId.id()));
        return Collections.emptyList();
    }
    final Multimap<Integer, ActionProfileMember> groupIdToMembersMap = HashMultimap.create();
    Tools.stream(() -> memberResponses).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(e -> e.getEntityCase() == ACTION_PROFILE_MEMBER).map(Entity::getActionProfileMember).forEach(member -> groupIdToMemberIdsMap.asMap().entrySet().stream().filter(entry -> entry.getValue().contains(member.getMemberId())).map(Map.Entry::getKey).forEach(gid -> groupIdToMembersMap.put(gid, member)));
    log.debug("Retrieved {} group members from action profile {} on {}...", groupIdToMembersMap.size(), piActionProfileId.id(), deviceId);
    return groupMsgs.stream().map(groupMsg -> {
        try {
            return ActionProfileGroupEncoder.decode(groupMsg, groupIdToMembersMap.get(groupMsg.getGroupId()), pipeconf);
        } catch (P4InfoBrowser.NotFoundException | EncodeException e) {
            log.warn("Unable to decode group: {}\n {}", e.getMessage(), groupMsg);
            return null;
        }
    }).filter(Objects::nonNull).collect(Collectors.toList());
}
#end_block

#method_before
private boolean doWriteActionGroup(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    final ActionProfileGroup actionProfileGroup;
    try {
        actionProfileGroup = ActionProfileGroupEncoder.encode(group, pipeconf);
    } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to encode group: {}", e.getMessage());
        return false;
    }
    final WriteRequest writeRequestMsg = WriteRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addUpdates(Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileGroup(actionProfileGroup).build()).setType(UPDATE_TYPES.get(opType)).build()).build();
    try {
        blockingStub.write(writeRequestMsg);
        return true;
    } catch (StatusRuntimeException e) {
        log.warn("Unable to write groups ({}): {}", opType, e.getMessage());
        return false;
    }
}
#method_after
private boolean doWriteActionGroup(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf) {
    final ActionProfileGroup actionProfileGroup;
    try {
        actionProfileGroup = ActionProfileGroupEncoder.encode(group, pipeconf);
    } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to encode group: {}", e.getMessage());
        return false;
    }
    final WriteRequest writeRequestMsg = WriteRequest.newBuilder().setDeviceId(p4DeviceId).setElectionId(p4RuntimeElectionId).addUpdates(Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileGroup(actionProfileGroup).build()).setType(UPDATE_TYPES.get(opType)).build()).build();
    try {
        blockingStub.write(writeRequestMsg);
        return true;
    } catch (StatusRuntimeException e) {
        logP4RuntimeErrorStatus(e, String.format("%s group", opType));
        return false;
    }
}
#end_block

#method_before
@Override
public MseaCfm getMepIds(Optional<MdId> mdIdOptional, Optional<MaIdShort> maIdOptional, NetconfSession session, DatastoreId targetDs) throws NetconfException {
    ModelObjectData.Builder moQueryBldr = DefaultModelObjectData.builder();
    ArrayList annotations = new ArrayList<AnnotatedNodeInfo>();
    String xmlQueryStr = encodeMoToXmlStr(moQueryBldr.build(), annotations);
    log.debug("Sending <get> for full MEP" + " query on NETCONF session " + session.getSessionId() + ":\n" + xmlQueryStr);
    String xmlResult = session.get(xmlQueryStr, null);
    xmlResult = removeRpcReplyData(xmlResult);
    xmlResult = removeEmptyActiveDefects(xmlResult);
    DefaultCompositeStream resultDcs = new DefaultCompositeStream(null, new ByteArrayInputStream(xmlResult.getBytes()));
    CompositeData compositeData = xSer.decode(resultDcs, yCtx);
    ModelObjectData mod = ((ModelConverter) yangModelRegistry).createModel(compositeData.resourceData());
    MseaCfmOpParam mseaCfm = new MseaCfmOpParam();
    for (ModelObject mo : mod.modelObjects()) {
        if (mo instanceof DefaultMefCfm) {
            mseaCfm.mefCfm((DefaultMefCfm) mo);
        }
    }
    return mseaCfm;
}
#method_after
@Override
public MseaCfm getMepIds(Optional<MdId> mdIdOptional, Optional<MaIdShort> maIdOptional, NetconfSession session, DatastoreId targetDs) throws NetconfException {
    ModelObjectData.Builder moQueryBldr = DefaultModelObjectData.builder();
    ArrayList<AnnotatedNodeInfo> annotations = new ArrayList<>();
    String xmlQueryStr = encodeMoToXmlStr(moQueryBldr.build(), annotations);
    log.debug("Sending <get> for full MEP" + " query on NETCONF session " + session.getSessionId() + ":\n" + xmlQueryStr);
    String xmlResult = session.get(xmlQueryStr, null);
    xmlResult = removeRpcReplyData(xmlResult);
    xmlResult = removeEmptyActiveDefects(xmlResult);
    DefaultCompositeStream resultDcs = new DefaultCompositeStream(null, new ByteArrayInputStream(xmlResult.getBytes()));
    CompositeData compositeData = xSer.decode(resultDcs, yCtx);
    ModelObjectData mod = ((ModelConverter) yangModelRegistry).createModel(compositeData.resourceData());
    MseaCfmOpParam mseaCfm = new MseaCfmOpParam();
    for (ModelObject mo : mod.modelObjects()) {
        if (mo instanceof DefaultMefCfm) {
            mseaCfm.mefCfm((DefaultMefCfm) mo);
        }
    }
    return mseaCfm;
}
#end_block

#method_before
@Override
public boolean deleteMseaCfmDm(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    ModelObjectData mseCfmDmList = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaCfm).build();
    ArrayList anis = new ArrayList<AnnotatedNodeInfo>();
    if (mseaCfm != null && mseaCfm.mefCfm() != null) {
        for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
            if (md.id() == 0) {
                throw new CfmConfigException("An MD numeric ID must be given");
            }
            for (MaintenanceAssociation ma : md.maintenanceAssociation()) {
                if (ma.id() == 0) {
                    throw new CfmConfigException("An MA numeric ID must be given");
                }
                for (MaintenanceAssociationEndPoint mep : ma.maintenanceAssociationEndPoint()) {
                    AugmentedMseaCfmMaintenanceAssociationEndPoint mepAugment = mep.augmentation(DefaultAugmentedMseaCfmMaintenanceAssociationEndPoint.class);
                    if (mepAugment != null && mepAugment.delayMeasurements() != null) {
                        for (DelayMeasurement dms : mepAugment.delayMeasurements().delayMeasurement()) {
                            ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, ma.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION_END_POINT, MSEA_CFM_NS).addKeyLeaf(MEP_ID, MSEA_CFM_NS, mep.mepIdentifier()).addBranchPointSchema(DELAY_MEASUREMENTS, MSEA_CFM_PM_NS).addBranchPointSchema(DELAY_MEASUREMENT, MSEA_CFM_PM_NS).addKeyLeaf(DM_ID, MSEA_CFM_PM_NS, mep.mepIdentifier());
                            AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
                            anis.add(ani);
                        }
                    }
                }
            }
        }
    }
    return setNetconfObject(mseCfmDmList, session, targetDs, anis);
}
#method_after
@Override
public boolean deleteMseaCfmDm(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    if (mseaCfm.mefCfm() == null) {
        throw new CfmConfigException("mefCfm object must be present before Meps can be added");
    }
    ModelObjectData mseCfmDmList = DefaultModelObjectData.builder().addModelObject(mseaCfm).build();
    ArrayList<AnnotatedNodeInfo> anis = new ArrayList<>();
    for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
        if (md.id() == 0) {
            throw new CfmConfigException("An MD numeric ID must be given");
        }
        for (MaintenanceAssociation ma : md.maintenanceAssociation()) {
            if (ma.id() == 0) {
                throw new CfmConfigException("An MA numeric ID must be given");
            }
            for (MaintenanceAssociationEndPoint mep : ma.maintenanceAssociationEndPoint()) {
                AugmentedMseaCfmMaintenanceAssociationEndPoint mepAugment = mep.augmentation(DefaultAugmentedMseaCfmMaintenanceAssociationEndPoint.class);
                if (mepAugment != null && mepAugment.delayMeasurements() != null) {
                    for (DelayMeasurement dm : mepAugment.delayMeasurements().delayMeasurement()) {
                        ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, ma.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION_END_POINT, MSEA_CFM_NS).addKeyLeaf(MEP_ID, MSEA_CFM_NS, mep.mepIdentifier()).addBranchPointSchema(DELAY_MEASUREMENTS, MSEA_CFM_PM_NS).addBranchPointSchema(DELAY_MEASUREMENT, MSEA_CFM_PM_NS).addKeyLeaf(DM_ID, MSEA_CFM_PM_NS, dm.dmId());
                        AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
                        anis.add(ani);
                    }
                }
            }
        }
    }
    return setNetconfObject(mseCfmDmList, session, targetDs, anis);
}
#end_block

#method_before
@Override
public boolean deleteMseaMep(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    ModelObjectData mseCfmMepList = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaCfm.mefCfm()).build();
    ArrayList anis = new ArrayList<AnnotatedNodeInfo>();
    if (mseaCfm.mefCfm() != null) {
        for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
            if (md.id() == 0) {
                throw new CfmConfigException("An MD numeric ID must be given");
            }
            for (MaintenanceAssociation ma : md.maintenanceAssociation()) {
                if (ma.id() == 0) {
                    throw new CfmConfigException("An MA numeric ID must be given");
                }
                for (MaintenanceAssociationEndPoint mep : ma.maintenanceAssociationEndPoint()) {
                    ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, ma.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION_END_POINT, MSEA_CFM_NS).addKeyLeaf(MEP_IDENTIFIER, MSEA_CFM_NS, mep.mepIdentifier().uint16());
                    AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
                    anis.add(ani);
                }
            }
        }
    }
    return setNetconfObject(mseCfmMepList, session, targetDs, anis);
}
#method_after
@Override
public boolean deleteMseaMep(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    if (mseaCfm.mefCfm() == null) {
        throw new CfmConfigException("mefCfm object must be present before Meps can be added");
    }
    ModelObjectData mseCfmMepList = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaCfm.mefCfm()).build();
    ArrayList<AnnotatedNodeInfo> anis = new ArrayList<>();
    for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
        if (md.id() == 0) {
            throw new CfmConfigException("An MD numeric ID must be given");
        }
        for (MaintenanceAssociation ma : md.maintenanceAssociation()) {
            if (ma.id() == 0) {
                throw new CfmConfigException("An MA numeric ID must be given");
            }
            for (MaintenanceAssociationEndPoint mep : ma.maintenanceAssociationEndPoint()) {
                ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, ma.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION_END_POINT, MSEA_CFM_NS).addKeyLeaf(MEP_IDENTIFIER, MSEA_CFM_NS, mep.mepIdentifier().uint16());
                AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
                anis.add(ani);
            }
        }
    }
    return setNetconfObject(mseCfmMepList, session, targetDs, anis);
}
#end_block

#method_before
@Override
public boolean deleteMseaMa(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    ModelObjectData mseCfmMepList = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaCfm.mefCfm()).build();
    ArrayList anis = new ArrayList<AnnotatedNodeInfo>();
    if (mseaCfm.mefCfm() != null) {
        for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
            if (md.id() == 0) {
                throw new CfmConfigException("An MD numeric ID must be given");
            }
            for (MaintenanceAssociation ma : md.maintenanceAssociation()) {
                if (ma.id() == 0) {
                    throw new CfmConfigException("An MA numeric ID must be given");
                }
                ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, ma.id());
                AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
                anis.add(ani);
            }
        }
    }
    return setNetconfObject(mseCfmMepList, session, targetDs, anis);
}
#method_after
@Override
public boolean deleteMseaMa(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    if (mseaCfm.mefCfm() == null) {
        throw new CfmConfigException("mefCfm object must be present before Meps can be added");
    }
    ModelObjectData mseCfmMepList = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaCfm.mefCfm()).build();
    ArrayList<AnnotatedNodeInfo> anis = new ArrayList<>();
    for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
        if (md.id() == 0) {
            throw new CfmConfigException("An MD numeric ID must be given");
        }
        for (MaintenanceAssociation ma : md.maintenanceAssociation()) {
            if (ma.id() == 0) {
                throw new CfmConfigException("An MA numeric ID must be given");
            }
            ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, ma.id());
            AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
            anis.add(ani);
        }
    }
    return setNetconfObject(mseCfmMepList, session, targetDs, anis);
}
#end_block

#method_before
@Override
public boolean deleteMseaMaRMep(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    ModelObjectData mseCfmMepList = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaCfm.mefCfm()).build();
    ArrayList anis = new ArrayList<AnnotatedNodeInfo>();
    if (mseaCfm.mefCfm() != null) {
        for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
            if (md.id() == 0) {
                throw new CfmConfigException("An MD numeric ID must be given");
            }
            for (MaintenanceAssociation ma : md.maintenanceAssociation()) {
                if (ma.id() == 0) {
                    throw new CfmConfigException("An MA numeric ID must be given");
                }
                for (MepIdType rmep : ma.remoteMeps()) {
                    ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, ma.id()).addLeafListBranchPoint(REMOTE_MEPS, MSEA_CFM_NS, Integer.valueOf(rmep.uint16()));
                    AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
                    anis.add(ani);
                }
            }
        }
    }
    return setNetconfObject(mseCfmMepList, session, targetDs, anis);
}
#method_after
@Override
public boolean deleteMseaMaRMep(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    if (mseaCfm.mefCfm() == null) {
        throw new CfmConfigException("mefCfm object must be present before Meps can be added");
    }
    ModelObjectData mseCfmMepList = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaCfm.mefCfm()).build();
    ArrayList<AnnotatedNodeInfo> anis = new ArrayList<>();
    for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
        if (md.id() == 0) {
            throw new CfmConfigException("An MD numeric ID must be given");
        }
        for (MaintenanceAssociation ma : md.maintenanceAssociation()) {
            if (ma.id() == 0) {
                throw new CfmConfigException("An MA numeric ID must be given");
            }
            for (MepIdType rmep : ma.remoteMeps()) {
                ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id()).addBranchPointSchema(MAINTENANCE_ASSOCIATION, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, ma.id()).addLeafListBranchPoint(REMOTE_MEPS, MSEA_CFM_NS, rmep.uint16());
                AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
                anis.add(ani);
            }
        }
    }
    return setNetconfObject(mseCfmMepList, session, targetDs, anis);
}
#end_block

#method_before
@Override
public boolean deleteMseaMd(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    ModelObjectData mseCfmMepList = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaCfm.mefCfm()).build();
    ArrayList anis = new ArrayList<AnnotatedNodeInfo>();
    if (mseaCfm.mefCfm() != null) {
        for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
            if (md.id() == 0) {
                throw new CfmConfigException("An MD numeric ID must be given");
            }
            ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id());
            AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
            anis.add(ani);
        }
    }
    return setNetconfObject(mseCfmMepList, session, targetDs, anis);
}
#method_after
@Override
public boolean deleteMseaMd(MseaCfmOpParam mseaCfm, NetconfSession session, DatastoreId targetDs) throws NetconfException, CfmConfigException {
    if (mseaCfm.mefCfm() == null) {
        throw new CfmConfigException("mefCfm object must be present before Meps can be added");
    }
    ModelObjectData mseCfmMepList = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaCfm.mefCfm()).build();
    ArrayList<AnnotatedNodeInfo> anis = new ArrayList<>();
    for (MaintenanceDomain md : mseaCfm.mefCfm().maintenanceDomain()) {
        if (md.id() == 0) {
            throw new CfmConfigException("An MD numeric ID must be given");
        }
        ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema(MEF_CFM, MSEA_CFM_NS).addBranchPointSchema(MAINTENANCE_DOMAIN, MSEA_CFM_NS).addKeyLeaf(ID, MSEA_CFM_NS, md.id());
        AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
        anis.add(ani);
    }
    return setNetconfObject(mseCfmMepList, session, targetDs, anis);
}
#end_block

#method_before
// Replace this with a ModelObject defintion
@Deprecated
private String buildMepEssentialsQueryString(MdId mdId, MaIdShort maId, MepId mepId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + mdId.mdName() + "</name>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + maId.maName() + "</name>\n");
    rpc.append("<ccm-interval>10ms</ccm-interval>\n");
    rpc.append("<remote-meps/>\n");
    rpc.append("<component-list/>\n");
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>" + mepId.id() + "</mep-identifier>\n");
    rpc.append("<mac-address/>\n");
    rpc.append("<remote-mep-database>\n");
    rpc.append("<remote-mep>\n");
    rpc.append("<remote-mep-id/>\n");
    rpc.append("</remote-mep>\n");
    rpc.append("</remote-mep-database>\n");
    rpc.append("<msea-soam-pm:delay-measurements>\n");
    rpc.append("<msea-soam-pm:delay-measurement>\n");
    rpc.append("<msea-soam-pm:dm-id/>\n");
    rpc.append("</msea-soam-pm:delay-measurement>\n");
    rpc.append("</msea-soam-pm:delay-measurements>\n");
    rpc.append("<msea-soam-pm:loss-measurements>\n");
    rpc.append("<msea-soam-pm:loss-measurement>\n");
    rpc.append("<msea-soam-pm:lm-id/>\n");
    rpc.append("</msea-soam-pm:loss-measurement>\n");
    rpc.append("</msea-soam-pm:loss-measurements>\n");
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#method_after
// Replace this with a ModelObject defintion
@Deprecated
private String buildMepEssentialsQueryString(MdId mdId, MaIdShort maId, MepId mepId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>");
    rpc.append(mdId.mdName());
    rpc.append("</name>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>");
    rpc.append(maId.maName());
    rpc.append("</name>\n");
    rpc.append("<ccm-interval>10ms</ccm-interval>\n");
    rpc.append("<remote-meps/>\n");
    rpc.append("<component-list/>\n");
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>");
    rpc.append(mepId.id());
    rpc.append("</mep-identifier>\n");
    rpc.append("<mac-address/>\n");
    rpc.append("<remote-mep-database>\n");
    rpc.append("<remote-mep>\n");
    rpc.append("<remote-mep-id/>\n");
    rpc.append("</remote-mep>\n");
    rpc.append("</remote-mep-database>\n");
    rpc.append("<msea-soam-pm:delay-measurements>\n");
    rpc.append("<msea-soam-pm:delay-measurement>\n");
    rpc.append("<msea-soam-pm:dm-id/>\n");
    rpc.append("</msea-soam-pm:delay-measurement>\n");
    rpc.append("</msea-soam-pm:delay-measurements>\n");
    rpc.append("<msea-soam-pm:loss-measurements>\n");
    rpc.append("<msea-soam-pm:loss-measurement>\n");
    rpc.append("<msea-soam-pm:lm-id/>\n");
    rpc.append("</msea-soam-pm:loss-measurement>\n");
    rpc.append("</msea-soam-pm:loss-measurements>\n");
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#end_block

#method_before
// Replace this with a ModelObject defintion
@Deprecated
private String buildMepFullQueryString(MdId mdId, MaIdShort maId, MepId mepId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + mdId.mdName() + "</name>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + maId.maName() + "</name>\n");
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>" + mepId.id() + "</mep-identifier>\n");
    rpc.append("<interface/>\n");
    // Direction will always be DOWN for EA1000
    rpc.append("<primary-vid/>\n");
    rpc.append("<administrative-state/>\n");
    rpc.append("<mac-address/>\n");
    rpc.append("<ccm-ltm-priority/>\n");
    // Container
    rpc.append("<continuity-check/>\n");
    // Container
    rpc.append("<loopback/>\n");
    // Container
    rpc.append("<linktrace/>\n");
    // Container
    rpc.append("<remote-mep-database/>\n");
    rpc.append("<msea-soam-fm:operational-state/>\n");
    rpc.append("<msea-soam-fm:connectivity-status/>\n");
    rpc.append("<msea-soam-fm:port-status/>\n");
    rpc.append("<msea-soam-fm:interface-status/>\n");
    rpc.append("<msea-soam-fm:last-defect-sent/>\n");
    rpc.append("<msea-soam-fm:rdi-transmit-status/>\n");
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#method_after
// Replace this with a ModelObject defintion
@Deprecated
private String buildMepFullQueryString(MdId mdId, MaIdShort maId, MepId mepId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>");
    rpc.append(mdId.mdName());
    rpc.append("</name>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>");
    rpc.append(maId.maName());
    rpc.append("</name>\n");
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>");
    rpc.append(mepId.id());
    rpc.append("</mep-identifier>\n");
    rpc.append("<interface/>\n");
    // Direction will always be DOWN for EA1000
    rpc.append("<primary-vid/>\n");
    rpc.append("<administrative-state/>\n");
    rpc.append("<mac-address/>\n");
    rpc.append("<ccm-ltm-priority/>\n");
    // Container
    rpc.append("<continuity-check/>\n");
    // Container
    rpc.append("<loopback/>\n");
    // Container
    rpc.append("<linktrace/>\n");
    // Container
    rpc.append("<remote-mep-database/>\n");
    rpc.append("<msea-soam-fm:operational-state/>\n");
    rpc.append("<msea-soam-fm:connectivity-status/>\n");
    rpc.append("<msea-soam-fm:port-status/>\n");
    rpc.append("<msea-soam-fm:interface-status/>\n");
    rpc.append("<msea-soam-fm:last-defect-sent/>\n");
    rpc.append("<msea-soam-fm:rdi-transmit-status/>\n");
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#end_block

#method_before
// Replace this with a ModelObject defintion
@Deprecated
private String buildDmQueryString(MdId mdId, MaIdShort maId, MepId mepId, SoamId dmId, DmEntryParts parts) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + mdId.mdName() + "</name>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + maId.maName() + "</name>\n");
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>" + mepId.id() + "</mep-identifier>\n");
    if (dmId != null) {
        rpc.append("<msea-soam-pm:delay-measurements>");
        rpc.append("<msea-soam-pm:delay-measurement>\n");
        rpc.append("<msea-soam-pm:dm-id>" + dmId.id() + "</msea-soam-pm:dm-id>\n");
        rpc.append("<msea-soam-pm:mep-id/>");
        rpc.append("<msea-soam-pm:mac-address/>");
        rpc.append("<msea-soam-pm:administrative-state/>\n");
        rpc.append("<msea-soam-pm:measurement-enable/>\n");
        rpc.append("<msea-soam-pm:message-period/>\n");
        rpc.append("<msea-soam-pm:priority/>\n");
        rpc.append("<msea-soam-pm:frame-size/>\n");
        rpc.append("<msea-soam-pm:measurement-interval/>\n");
        rpc.append("<msea-soam-pm:number-intervals-stored/>\n");
        rpc.append("<msea-soam-pm:session-status/>\n");
        rpc.append("<msea-soam-pm:frame-delay-two-way/>\n");
        rpc.append("<msea-soam-pm:inter-frame-delay-variation-two-way/>\n");
        if (parts != null && (parts.equals(DmEntryParts.CURRENT_ONLY) || parts.equals(DmEntryParts.ALL_PARTS))) {
            rpc.append("<msea-soam-pm:current-stats/>\n");
        }
        if (parts != null && (parts.equals(DmEntryParts.HISTORY_ONLY) || parts.equals(DmEntryParts.ALL_PARTS))) {
            rpc.append("<msea-soam-pm:history-stats/>\n");
        }
        rpc.append("</msea-soam-pm:delay-measurement>\n");
        rpc.append("</msea-soam-pm:delay-measurements>");
    } else {
        rpc.append("<msea-soam-pm:delay-measurements/>");
    }
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#method_after
// Replace this with a ModelObject defintion
@Deprecated
private String buildDmQueryString(MdId mdId, MaIdShort maId, MepId mepId, SoamId dmId, DmEntryParts parts) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>");
    rpc.append(mdId.mdName());
    rpc.append("</name>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>");
    rpc.append(maId.maName());
    rpc.append("</name>\n");
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>");
    rpc.append(mepId.id());
    rpc.append("</mep-identifier>\n");
    if (dmId != null) {
        rpc.append("<msea-soam-pm:delay-measurements>");
        rpc.append("<msea-soam-pm:delay-measurement>\n");
        rpc.append("<msea-soam-pm:dm-id>");
        rpc.append(dmId.id());
        rpc.append("</msea-soam-pm:dm-id>\n");
        rpc.append("<msea-soam-pm:mep-id/>");
        rpc.append("<msea-soam-pm:mac-address/>");
        rpc.append("<msea-soam-pm:administrative-state/>\n");
        rpc.append("<msea-soam-pm:measurement-enable/>\n");
        rpc.append("<msea-soam-pm:message-period/>\n");
        rpc.append("<msea-soam-pm:priority/>\n");
        rpc.append("<msea-soam-pm:frame-size/>\n");
        rpc.append("<msea-soam-pm:measurement-interval/>\n");
        rpc.append("<msea-soam-pm:number-intervals-stored/>\n");
        rpc.append("<msea-soam-pm:session-status/>\n");
        rpc.append("<msea-soam-pm:frame-delay-two-way/>\n");
        rpc.append("<msea-soam-pm:inter-frame-delay-variation-two-way/>\n");
        if (parts != null && (parts.equals(DmEntryParts.CURRENT_ONLY) || parts.equals(DmEntryParts.ALL_PARTS))) {
            rpc.append("<msea-soam-pm:current-stats/>\n");
        }
        if (parts != null && (parts.equals(DmEntryParts.HISTORY_ONLY) || parts.equals(DmEntryParts.ALL_PARTS))) {
            rpc.append("<msea-soam-pm:history-stats/>\n");
        }
        rpc.append("</msea-soam-pm:delay-measurement>\n");
        rpc.append("</msea-soam-pm:delay-measurements>");
    } else {
        rpc.append("<msea-soam-pm:delay-measurements/>");
    }
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#end_block

#method_before
// Replace this with a ModelObject defintion
@Deprecated
private String buildAbortLoopbackQueryString(Short mdId, Short maId, Short mepId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<abort-loopback xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\">");
    rpc.append("<maintenance-domain>" + mdId + "</maintenance-domain>");
    rpc.append("<maintenance-association>" + maId + "</maintenance-association>");
    rpc.append("<maintenance-association-end-point>" + mepId + "</maintenance-association-end-point>");
    rpc.append("</abort-loopback>");
    return rpc.toString();
}
#method_after
// Replace this with a ModelObject defintion
@Deprecated
private String buildAbortLoopbackQueryString(Short mdId, Short maId, Short mepId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<abort-loopback xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\">");
    rpc.append("<maintenance-domain>");
    rpc.append(mdId);
    rpc.append("</maintenance-domain>");
    rpc.append("<maintenance-association>");
    rpc.append(maId);
    rpc.append("</maintenance-association>");
    rpc.append("<maintenance-association-end-point>");
    rpc.append(mepId);
    rpc.append("</maintenance-association-end-point>");
    rpc.append("</abort-loopback>");
    return rpc.toString();
}
#end_block

#method_before
@Override
public ObjectNode runGetOperationOnDataResource(URI uri) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    // TODO: define Filter (if there is any requirement).
    Filter filter = Filter.builder().build();
    DataNode dataNode;
    try {
        if (!dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            return null;
        }
        dataNode = dynamicConfigService.readNode(rl.ridForDynConfig(), filter);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR);
    }
    ObjectNode rootNode = convertDataNodeToJson(rl.ridForYangRuntime(), dataNode);
    return rootNode;
}
#method_after
@Override
public ObjectNode runGetOperationOnDataResource(URI uri) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    // TODO: define Filter (if there is any requirement).
    Filter filter = Filter.builder().build();
    DataNode dataNode;
    try {
        if (!dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            return null;
        }
        dataNode = dynamicConfigService.readNode(rl.ridForDynConfig(), filter);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
    }
    ObjectNode rootNode = convertDataNodeToJson(rl.ridForYangRuntime(), dataNode);
    return rootNode;
}
#end_block

#method_before
@Override
public void runPostOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rl.uriForYangRuntime(), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.createNode(rl.ridForDynConfig(), dataNode);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void runPostOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rl.uriForYangRuntime(), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.createNode(rl.ridForDynConfig(), dataNode);
    } catch (FailedException e) {
        if (e.getMessage().startsWith("Requested node already present")) {
            throw new RestconfException("Already exists", e, RestconfError.ErrorTag.DATA_EXISTS, CONFLICT, Optional.of(uri.getPath()));
        } else {
            log.error("ERROR: DynamicConfigService: ", e);
            throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
        }
    }
}
#end_block

#method_before
@Override
public void runPutOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    try {
        /*
             * If the data node already exists, then replace it.
             * Otherwise, create it.
             */
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.replaceNode(parentOf(rl.ridForDynConfig()), dataNode);
        } else {
            dynamicConfigService.createNode(parentOf(rl.ridForDynConfig()), dataNode);
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void runPutOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    try {
        /*
             * If the data node already exists, then replace it.
             * Otherwise, create it.
             */
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.replaceNode(parentOf(rl.ridForDynConfig()), dataNode);
        } else {
            dynamicConfigService.createNode(parentOf(rl.ridForDynConfig()), dataNode);
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
    }
}
#end_block

#method_before
@Override
public void runDeleteOperationOnDataResource(URI uri) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    try {
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.deleteNode(rl.ridForDynConfig());
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void runDeleteOperationOnDataResource(URI uri) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    try {
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.deleteNode(rl.ridForDynConfig());
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
    }
}
#end_block

#method_before
@Override
public void runPatchOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.updateNode(parentOf(rl.ridForDynConfig()), dataNode);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void runPatchOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.updateNode(parentOf(rl.ridForDynConfig()), dataNode);
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
    }
}
#end_block

#method_before
@Override
public void subscribeEventStream(String streamId, String clientIpAddr, ChunkedOutput<String> output) throws RestconfException {
// TODO: to be completed
}
#method_after
@Override
public void subscribeEventStream(String streamId, String clientIpAddr, ChunkedOutput<String> output) throws RestconfException {
    // TODO: to be completed
    throw new RestconfException("Not implemented", RestconfError.ErrorTag.OPERATION_NOT_SUPPORTED, Response.Status.NOT_IMPLEMENTED, Optional.empty(), Optional.of("subscribeEventStream not yet implemented"));
}
#end_block

#method_before
private RestconfRpcOutput executeRpc(URI uri, ObjectNode input, String clientIpAddress) {
    ResourceData rpcInputNode = convertJsonToDataNode(uri, input);
    ResourceId resourceId = rpcInputNode.resourceId();
    List<DataNode> inputDataNodeList = rpcInputNode.dataNodes();
    DataNode inputDataNode = inputDataNodeList.get(0);
    RpcInput rpcInput = new RpcInput(inputDataNode);
    RestconfRpcOutput restconfOutput = null;
    try {
        CompletableFuture<RpcOutput> rpcFuture = dynamicConfigService.invokeRpc(resourceId, rpcInput);
        RpcOutput rpcOutput = rpcFuture.get();
        restconfOutput = RestconfUtils.convertRpcOutput(resourceId, rpcOutput);
    } catch (InterruptedException e) {
        log.error("ERROR: computeResultQ.take() has been interrupted.");
        log.debug("executeRpc Exception:", e);
        RestconfError error = RestconfError.builder(RestconfError.ErrorType.RPC, RestconfError.ErrorTag.OPERATION_FAILED).errorMessage("RPC execution has been interrupted").build();
        restconfOutput = new RestconfRpcOutput(INTERNAL_SERVER_ERROR, RestconfError.wrapErrorAsJson(Arrays.asList(error)));
        restconfOutput.reason("RPC execution has been interrupted");
    } catch (Exception e) {
        log.error("ERROR: executeRpc: {}", e.getMessage());
        log.debug("executeRpc Exception:", e);
        RestconfError error = RestconfError.builder(RestconfError.ErrorType.RPC, RestconfError.ErrorTag.OPERATION_FAILED).errorMessage(e.getMessage()).build();
        restconfOutput = new RestconfRpcOutput(INTERNAL_SERVER_ERROR, RestconfError.wrapErrorAsJson(Arrays.asList(error)));
        restconfOutput.reason(e.getMessage());
    }
    return restconfOutput;
}
#method_after
private RestconfRpcOutput executeRpc(URI uri, ObjectNode input, String clientIpAddress) {
    ResourceData rpcInputNode = convertJsonToDataNode(uri, input);
    ResourceId resourceId = rpcInputNode.resourceId();
    List<DataNode> inputDataNodeList = rpcInputNode.dataNodes();
    DataNode inputDataNode = inputDataNodeList.get(0);
    RpcInput rpcInput = new RpcInput(inputDataNode);
    RestconfRpcOutput restconfOutput = null;
    try {
        CompletableFuture<RpcOutput> rpcFuture = dynamicConfigService.invokeRpc(resourceId, rpcInput);
        RpcOutput rpcOutput = rpcFuture.get();
        restconfOutput = RestconfUtils.convertRpcOutput(resourceId, rpcOutput);
    } catch (InterruptedException e) {
        log.error("ERROR: computeResultQ.take() has been interrupted.");
        log.debug("executeRpc Exception:", e);
        RestconfError error = RestconfError.builder(RestconfError.ErrorType.RPC, RestconfError.ErrorTag.OPERATION_FAILED).errorMessage("RPC execution has been interrupted").errorPath(uri.getPath()).build();
        restconfOutput = new RestconfRpcOutput(INTERNAL_SERVER_ERROR, RestconfError.wrapErrorAsJson(Arrays.asList(error)));
        restconfOutput.reason("RPC execution has been interrupted");
    } catch (Exception e) {
        log.error("ERROR: executeRpc: {}", e.getMessage());
        log.debug("executeRpc Exception:", e);
        RestconfError error = RestconfError.builder(RestconfError.ErrorType.RPC, RestconfError.ErrorTag.OPERATION_FAILED).errorMessage(e.getMessage()).errorPath(uri.getPath()).build();
        restconfOutput = new RestconfRpcOutput(INTERNAL_SERVER_ERROR, RestconfError.wrapErrorAsJson(Arrays.asList(error)));
        restconfOutput.reason(e.getMessage());
    }
    return restconfOutput;
}
#end_block

#method_before
public static ObjectNode convertInputStreamToObjectNode(InputStream inputStream) {
    ObjectNode rootNode;
    ObjectMapper mapper = new ObjectMapper();
    try {
        rootNode = (ObjectNode) mapper.readTree(inputStream);
    } catch (IOException e) {
        throw new RestconfException("ERROR: InputStream failed to parse", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR);
    }
    return rootNode;
}
#method_after
public static ObjectNode convertInputStreamToObjectNode(InputStream inputStream) {
    ObjectNode rootNode;
    ObjectMapper mapper = new ObjectMapper();
    try {
        rootNode = (ObjectNode) mapper.readTree(inputStream);
    } catch (IOException e) {
        throw new RestconfException("ERROR: InputStream failed to parse", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.empty());
    }
    return rootNode;
}
#end_block

#method_before
public static InputStream convertObjectNodeToInputStream(ObjectNode rootNode) {
    String json = rootNode.toString();
    InputStream inputStream;
    try {
        inputStream = IOUtils.toInputStream(json);
    } catch (Exception e) {
        throw new RestconfException("ERROR: Json Node failed to parse", e, RestconfError.ErrorTag.MALFORMED_MESSAGE, BAD_REQUEST);
    }
    return inputStream;
}
#method_after
public static InputStream convertObjectNodeToInputStream(ObjectNode rootNode) {
    String json = rootNode.toString();
    InputStream inputStream;
    try {
        inputStream = IOUtils.toInputStream(json);
    } catch (Exception e) {
        throw new RestconfException("ERROR: Json Node failed to parse", e, RestconfError.ErrorTag.MALFORMED_MESSAGE, BAD_REQUEST, Optional.empty());
    }
    return inputStream;
}
#end_block

#method_before
public static ResourceData convertJsonToDataNode(URI uri, ObjectNode rootNode) {
    RuntimeContext.Builder runtimeContextBuilder = new DefaultRuntimeContext.Builder();
    runtimeContextBuilder.setDataFormat(JSON_FORMAT);
    RuntimeContext context = runtimeContextBuilder.build();
    ResourceData resourceData = null;
    InputStream jsonData = null;
    try {
        if (rootNode != null) {
            jsonData = convertObjectNodeToInputStream(rootNode);
        }
        String uriString = getRawUriPath(uri);
        CompositeStream compositeStream = new DefaultCompositeStream(uriString, jsonData);
        // CompositeStream --- YangRuntimeService ---> CompositeData.
        CompositeData compositeData = YANG_RUNTIME.decode(compositeStream, context);
        resourceData = compositeData.resourceData();
    } catch (RestconfException ex) {
        throw ex;
    } catch (Exception ex) {
        log.error("convertJsonToDataNode failure: {}", ex.getMessage());
        log.debug("convertJsonToDataNode failure", ex);
        throw new RestconfException("ERROR: JSON cannot be converted to DataNode", ex, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR);
    }
    if (resourceData == null) {
        throw new RestconfException("ERROR: JSON cannot be converted to DataNode", null, RestconfError.ErrorTag.DATA_MISSING, CONFLICT);
    }
    return resourceData;
}
#method_after
public static ResourceData convertJsonToDataNode(URI uri, ObjectNode rootNode) {
    RuntimeContext.Builder runtimeContextBuilder = new DefaultRuntimeContext.Builder();
    runtimeContextBuilder.setDataFormat(JSON_FORMAT);
    RuntimeContext context = runtimeContextBuilder.build();
    ResourceData resourceData = null;
    InputStream jsonData = null;
    try {
        if (rootNode != null) {
            jsonData = convertObjectNodeToInputStream(rootNode);
        }
        String uriString = getRawUriPath(uri);
        CompositeStream compositeStream = new DefaultCompositeStream(uriString, jsonData);
        // CompositeStream --- YangRuntimeService ---> CompositeData.
        CompositeData compositeData = YANG_RUNTIME.decode(compositeStream, context);
        resourceData = compositeData.resourceData();
    } catch (RestconfException ex) {
        throw ex;
    } catch (Exception ex) {
        log.error("convertJsonToDataNode failure: {}", ex.getMessage());
        log.debug("convertJsonToDataNode failure", ex);
        throw new RestconfException("ERROR: JSON cannot be converted to DataNode", ex, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
    }
    if (resourceData == null) {
        throw new RestconfException("ERROR: JSON cannot be converted to DataNode", RestconfError.ErrorTag.DATA_MISSING, CONFLICT, Optional.of(uri.getPath()), Optional.empty());
    }
    return resourceData;
}
#end_block

#method_before
public static ObjectNode convertDataNodeToJson(ResourceId rid, DataNode dataNode) {
    RuntimeContext.Builder runtimeContextBuilder = DefaultRuntimeContext.builder();
    runtimeContextBuilder.setDataFormat(JSON_FORMAT);
    RuntimeContext context = runtimeContextBuilder.build();
    DefaultResourceData.Builder resourceDataBuilder = DefaultResourceData.builder();
    resourceDataBuilder.addDataNode(dataNode);
    resourceDataBuilder.resourceId(rid);
    ResourceData resourceData = resourceDataBuilder.build();
    DefaultCompositeData.Builder compositeDataBuilder = DefaultCompositeData.builder();
    compositeDataBuilder.resourceData(resourceData);
    CompositeData compositeData = compositeDataBuilder.build();
    ObjectNode rootNode = null;
    try {
        // CompositeData --- YangRuntimeService ---> CompositeStream.
        CompositeStream compositeStream = YANG_RUNTIME.encode(compositeData, context);
        InputStream inputStream = compositeStream.resourceData();
        rootNode = convertInputStreamToObjectNode(inputStream);
    } catch (Exception ex) {
        log.error("convertInputStreamToObjectNode failure: {}", ex.getMessage());
        log.debug("convertInputStreamToObjectNode failure", ex);
    }
    if (rootNode == null) {
        throw new RestconfException("ERROR: InputStream can not be convert to ObjectNode", null, RestconfError.ErrorTag.DATA_MISSING, CONFLICT);
    }
    return rootNode;
}
#method_after
public static ObjectNode convertDataNodeToJson(ResourceId rid, DataNode dataNode) {
    RuntimeContext.Builder runtimeContextBuilder = DefaultRuntimeContext.builder();
    runtimeContextBuilder.setDataFormat(JSON_FORMAT);
    RuntimeContext context = runtimeContextBuilder.build();
    DefaultResourceData.Builder resourceDataBuilder = DefaultResourceData.builder();
    resourceDataBuilder.addDataNode(dataNode);
    resourceDataBuilder.resourceId(rid);
    ResourceData resourceData = resourceDataBuilder.build();
    DefaultCompositeData.Builder compositeDataBuilder = DefaultCompositeData.builder();
    compositeDataBuilder.resourceData(resourceData);
    CompositeData compositeData = compositeDataBuilder.build();
    ObjectNode rootNode = null;
    try {
        // CompositeData --- YangRuntimeService ---> CompositeStream.
        CompositeStream compositeStream = YANG_RUNTIME.encode(compositeData, context);
        InputStream inputStream = compositeStream.resourceData();
        rootNode = convertInputStreamToObjectNode(inputStream);
    } catch (Exception ex) {
        log.error("convertInputStreamToObjectNode failure: {}", ex.getMessage());
        log.debug("convertInputStreamToObjectNode failure", ex);
    }
    if (rootNode == null) {
        throw new RestconfException("ERROR: InputStream can not be convert to ObjectNode", null, RestconfError.ErrorTag.DATA_MISSING, CONFLICT, Optional.empty());
    }
    return rootNode;
}
#end_block

#method_before
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Path("data/{identifier : .+}")
public Response handleDeleteRequest(@PathParam("identifier") String uriString) {
    log.debug("handleDeleteRequest: {}", uriString);
    URI uri = uriInfo.getRequestUri();
    try {
        service.runDeleteOperationOnDataResource(uri);
        return Response.ok().build();
    } catch (RestconfException e) {
        log.error("ERROR: handleDeleteRequest: {}", e.getMessage());
        log.debug("Exception in handleDeleteRequest:", e);
        return Response.status(e.getResponse().getStatus()).entity(e.toRestconfErrorJson()).build();
    }
}
#method_after
@DELETE
@Produces(MediaType.APPLICATION_JSON)
@Path("data/{identifier : .+}")
public Response handleDeleteRequest(@PathParam("identifier") String uriString) {
    log.debug("handleDeleteRequest: {}", uriString);
    URI uri = uriInfo.getRequestUri();
    try {
        service.runDeleteOperationOnDataResource(uri);
        return Response.ok().build();
    } catch (RestconfException e) {
        log.error("ERROR: handleDeleteRequest: {}", e.getMessage());
        log.debug("Exception in handleDeleteRequest:", e);
        return Response.status(e.getResponse().getStatus()).entity(e.toRestconfErrorJson()).build();
    }
}
#end_block

#method_before
@Test
public void testHandleGetRequestRestconfException() {
    expect(restconfService.runGetOperationOnDataResource(URI.create(getBaseUri() + DATA_IETF_SYSTEM_SYSTEM))).andThrow(new RestconfException("Suitable error message", null, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR)).anyTimes();
    replay(restconfService);
    WebTarget wt = target();
    try {
        String response = wt.path("/" + DATA_IETF_SYSTEM_SYSTEM).request().get(String.class);
        fail("Expecting fail as response is RestconfException");
    } catch (InternalServerErrorException e) {
        assertNotNull(e.getResponse());
        assertRestconfErrorJson(e.getResponse());
    }
}
#method_after
@Test
public void testHandleGetRequestRestconfException() {
    expect(restconfService.runGetOperationOnDataResource(URI.create(getBaseUri() + DATA_IETF_SYSTEM_SYSTEM))).andThrow(new RestconfException("Suitable error message", RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of("/" + DATA_IETF_SYSTEM_SYSTEM), Optional.of("More info about the error"))).anyTimes();
    replay(restconfService);
    WebTarget wt = target();
    try {
        String response = wt.path("/" + DATA_IETF_SYSTEM_SYSTEM).request().get(String.class);
        fail("Expecting fail as response is RestconfException");
    } catch (InternalServerErrorException e) {
        assertNotNull(e.getResponse());
        assertRestconfErrorJson(e.getResponse());
    }
}
#end_block

#method_before
@Override
public void event(MapEvent<ApplicationId, InternalApplicationHolder> event) {
    if (delegate == null) {
        return;
    }
    ApplicationId appId = event.key();
    InternalApplicationHolder newApp = event.newValue() == null ? null : event.newValue().value();
    InternalApplicationHolder oldApp = event.oldValue() == null ? null : event.oldValue().value();
    if (event.type() == MapEvent.Type.INSERT || event.type() == MapEvent.Type.UPDATE) {
        if (event.type() == MapEvent.Type.UPDATE && newApp.state() == oldApp.state()) {
            return;
        }
        setupApplicationAndNotify(appId, newApp.app(), newApp.state());
    } else if (event.type() == MapEvent.Type.REMOVE) {
        notifyDelegate(new ApplicationEvent(APP_UNINSTALLED, oldApp.app()));
        purgeApplication(appId.name());
    }
}
#method_after
@Override
public void event(MapEvent<ApplicationId, InternalApplicationHolder> event) {
    if (delegate == null) {
        return;
    }
    ApplicationId appId = event.key();
    InternalApplicationHolder newApp = event.newValue() == null ? null : event.newValue().value();
    InternalApplicationHolder oldApp = event.oldValue() == null ? null : event.oldValue().value();
    if (event.type() == MapEvent.Type.UPDATE && (newApp == null || oldApp == null || newApp.state() == oldApp.state())) {
        log.warn("Can't update the application {}", event.key());
        return;
    }
    if ((event.type() == MapEvent.Type.INSERT || event.type() == MapEvent.Type.UPDATE) && newApp != null) {
        setupApplicationAndNotify(appId, newApp.app(), newApp.state());
    } else if (event.type() == MapEvent.Type.REMOVE && oldApp != null) {
        notifyDelegate(new ApplicationEvent(APP_UNINSTALLED, oldApp.app()));
        purgeApplication(appId.name());
    } else {
        log.warn("Can't perform {} on application {}", event.type(), event.key());
    }
}
#end_block

