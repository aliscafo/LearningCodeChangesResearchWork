546
#method_before
static private MethodHandle methodHandleForVarHandleAccessor(VarHandle.AccessMode accessMode, MethodType type, boolean isExactInvoker) {
    Class<?> refc = VarHandle.class;
    Method method;
    try {
        method = refc.getDeclaredMethod(accessMode.methodName(), Object[].class);
    } catch (NoSuchMethodException e) {
        throw new IllegalStateException("No method for AccessMode " + accessMode, e);
    }
    MethodType methodType = type.insertParameterTypes(0, VarHandle.class);
    int kind = isExactInvoker ? MethodHandle.INVOKE_VAR_HANDLE_EXACT : MethodHandle.INVOKE_VAR_HANDLE;
    return new MethodHandleImpl(method.getArtMethod(), kind, methodType);
}
#method_after
static private MethodHandle methodHandleForVarHandleAccessor(VarHandle.AccessMode accessMode, MethodType type, boolean isExactInvoker) {
    Class<?> refc = VarHandle.class;
    Method method;
    try {
        method = refc.getDeclaredMethod(accessMode.methodName(), Object[].class);
    } catch (NoSuchMethodException e) {
        throw new InternalError("No method for AccessMode " + accessMode, e);
    }
    MethodType methodType = type.insertParameterTypes(0, VarHandle.class);
    int kind = isExactInvoker ? MethodHandle.INVOKE_VAR_HANDLE_EXACT : MethodHandle.INVOKE_VAR_HANDLE;
    return new MethodHandleImpl(method.getArtMethod(), kind, methodType);
}
#end_block

#method_before
// END: Android-added: resolver for VarHandle accessor methods.
static public MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {
    return methodHandleForVarHandleAccessor(accessMode, type, true);
}
#method_after
// END Android-added: resolver for VarHandle accessor methods.
static public MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {
    return methodHandleForVarHandleAccessor(accessMode, type, true);
}
#end_block

#method_before
private static void failAssertEquals(Object expected, Object actual) throws Throwable {
    StringBuilder sb = new StringBuilder();
    sb.append(expected);
    sb.append(" != ");
    sb.append(actual);
    fail(sb.toString());
}
#method_after
private static void failAssertEquals(Object expected, Object actual) {
    StringBuilder sb = new StringBuilder();
    sb.append(expected);
    sb.append(" != ");
    sb.append(actual);
    failAssertion(sb.toString());
}
#end_block

#method_before
private static void assertEquals(int expected, int actual) throws Throwable {
    if (expected != actual) {
        failAssertEquals(expected, actual);
    }
}
#method_after
private static void assertEquals(int expected, int actual) {
    if (expected != actual) {
        failAssertEquals(expected, actual);
    }
}
#end_block

#method_before
private static void assertEquals(float expected, float actual) throws Throwable {
    if (expected != actual) {
        failAssertEquals(expected, actual);
    }
}
#method_after
private static void assertEquals(float expected, float actual) {
    if (expected != actual) {
        failAssertEquals(expected, actual);
    }
}
#end_block

#method_before
private static void assertEquals(double expected, double actual) throws Throwable {
    if (expected != actual) {
        failAssertEquals(expected, actual);
    }
}
#method_after
private static void assertEquals(double expected, double actual) {
    if (expected != actual) {
        failAssertEquals(expected, actual);
    }
}
#end_block

#method_before
void run() throws Throwable {
    System.out.println("fieldVarHandleExactInvokerTest");
    MethodHandle mhField = MethodHandles.varHandleExactInvoker(VarHandle.AccessMode.GET_AND_SET, MethodType.methodType(int.class, FieldVarHandleExactInvokerTest.class, int.class));
    field = 3;
    assertEquals(3, (int) mhField.invokeExact(vhField, this, 4));
    assertEquals(4, field);
    // 
    try {
        // Check for unboxing
        int dummy = (int) mhField.invokeExact(vhField, this, Integer.valueOf(3));
        fail("Unreachable");
    } catch (WrongMethodTypeException e) {
        assertEquals(4, field);
    }
    try {
        // Check for widening conversion
        int dummy = (int) mhField.invokeExact(vhField, this, (short) 3);
        fail("Unreachable");
    } catch (WrongMethodTypeException e) {
        assertEquals(4, field);
    }
    try {
        // Check for acceptance of void return type
        mhField.invokeExact(vhField, this, 77);
        fail("Unreachable");
    } catch (WrongMethodTypeException e) {
        assertEquals(4, field);
    }
    try {
        // Check for wider return type
        long dummy = (long) mhField.invokeExact(vhField, this, 77);
        fail("Unreachable");
    } catch (WrongMethodTypeException e) {
        assertEquals(4, field);
    }
    try {
        VarHandle vhNull = null;
        int x = (int) mhField.invokeExact(vhNull, this, 777);
        fail("Unreachable");
    } catch (NullPointerException e) {
        assertEquals(4, field);
    }
    // 
    try {
        // Check for unboxing
        int dummy = (int) mhField.invoke(vhField, this, Integer.valueOf(3));
        assertEquals(3, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        // Check for unboxing
        int dummy = (int) mhField.invoke(vhField, this, Short.valueOf((short) 4));
        assertEquals(4, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        // Check for widening conversion
        int dummy = (int) mhField.invoke(vhField, this, (short) 23);
        assertEquals(23, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        // Check for acceptance of void return type
        mhField.invoke(vhField, this, 77);
        assertEquals(77, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        // Check for wider return type
        long dummy = (long) mhField.invoke(vhField, this, 88);
        assertEquals(88, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        VarHandle vhNull = null;
        int x = (int) mhField.invoke(vhNull, this, 888);
        fail("Unreachable");
    } catch (NullPointerException e) {
        assertEquals(88, field);
    }
}
#method_after
void run() throws Throwable {
    System.out.println("fieldVarHandleExactInvokerTest");
    MethodHandle invokerMethodHandle = MethodHandles.varHandleExactInvoker(VarHandle.AccessMode.GET_AND_SET, MethodType.methodType(int.class, FieldVarHandleExactInvokerTest.class, int.class));
    field = 3;
    assertEquals(3, (int) invokerMethodHandle.invokeExact(fieldVarHandle, this, 4));
    assertEquals(4, field);
    // 
    try {
        // Check for unboxing
        int i = (int) invokerMethodHandle.invokeExact(fieldVarHandle, this, Integer.valueOf(3));
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
        assertEquals(4, field);
    }
    try {
        // Check for widening conversion
        int i = (int) invokerMethodHandle.invokeExact(fieldVarHandle, this, (short) 3);
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
        assertEquals(4, field);
    }
    try {
        // Check for acceptance of void return type
        invokerMethodHandle.invokeExact(fieldVarHandle, this, 77);
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
        assertEquals(4, field);
    }
    try {
        // Check for wider return type
        long l = (long) invokerMethodHandle.invokeExact(fieldVarHandle, this, 77);
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
        assertEquals(4, field);
    }
    try {
        // Check null VarHandle instance fails
        VarHandle vhNull = null;
        int i = (int) invokerMethodHandle.invokeExact(vhNull, this, 777);
        assertUnreachable();
    } catch (NullPointerException expected) {
        assertEquals(4, field);
    }
    // 
    // Check invocations with MethodHandle.invoke()
    // 
    // Check for unboxing
    int i = (int) invokerMethodHandle.invoke(fieldVarHandle, this, Integer.valueOf(3));
    assertEquals(3, field);
    // Check for unboxing
    i = (int) invokerMethodHandle.invoke(fieldVarHandle, this, Short.valueOf((short) 4));
    assertEquals(4, field);
    // Check for widening conversion
    i = (int) invokerMethodHandle.invoke(fieldVarHandle, this, (short) 23);
    assertEquals(23, field);
    // Check for acceptance of void return type
    invokerMethodHandle.invoke(fieldVarHandle, this, 77);
    assertEquals(77, field);
    // Check for wider return type
    long l = (long) invokerMethodHandle.invoke(fieldVarHandle, this, 88);
    assertEquals(88, field);
    try {
        // Check null VarHandle instance fails
        VarHandle vhNull = null;
        i = (int) invokerMethodHandle.invoke(vhNull, this, 888);
        assertUnreachable();
    } catch (NullPointerException expected) {
        assertEquals(88, field);
    }
}
#end_block

#method_before
void run() throws Throwable {
    System.out.println("fieldVarHandleInvokerTest");
    MethodHandle mhField = MethodHandles.varHandleInvoker(VarHandle.AccessMode.GET_AND_SET, MethodType.methodType(int.class, FieldVarHandleInvokerTest.class, int.class));
    field = 3;
    int oldField = (int) mhField.invoke(vhField, this, 4);
    assertEquals(3, oldField);
    assertEquals(4, field);
    // 
    try {
        // Check for unboxing
        int dummy = (int) mhField.invoke(vhField, this, Integer.valueOf(3));
        assertEquals(3, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        // Check for widening conversion
        int dummy = (int) mhField.invoke(vhField, this, (short) 33);
        assertEquals(33, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        // Check for widening conversion
        int dummy = (int) mhField.invoke(vhField, this, Byte.valueOf((byte) 34));
        assertEquals(34, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        // Check for acceptance of void return type
        mhField.invoke(vhField, this, 77);
        assertEquals(77, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        // Check for wider return type
        long dummy = (long) mhField.invoke(vhField, this, 88);
        assertEquals(88, field);
    } catch (WrongMethodTypeException e) {
        fail("Unreachable");
    }
    try {
        VarHandle vhNull = null;
        int x = (int) mhField.invoke(vhNull, this, 888);
        fail("Unreachable");
    } catch (NullPointerException e) {
        assertEquals(88, field);
    }
    // 
    // Check invocations with MethodHandle.invokeExact()
    // 
    field = -1;
    try {
        // Check for unboxing
        int dummy = (int) mhField.invokeExact(vhField, this, Integer.valueOf(3));
        fail("Unreachable");
    } catch (WrongMethodTypeException e) {
        assertEquals(-1, field);
    }
    try {
        // Check for widening conversion
        int dummy = (int) mhField.invokeExact(vhField, this, (short) 33);
        fail("Unreachable");
    } catch (WrongMethodTypeException e) {
        assertEquals(-1, field);
    }
    try {
        // Check for acceptance of void return type
        mhField.invokeExact(vhField, this, 77);
        fail("Unreachable");
    } catch (WrongMethodTypeException e) {
        assertEquals(-1, field);
    }
    try {
        // Check for wider return type
        long dummy = (long) mhField.invokeExact(vhField, this, 78);
        fail("Unreachable");
    } catch (WrongMethodTypeException e) {
        assertEquals(-1, field);
    }
    try {
        VarHandle vhNull = null;
        int x = (int) mhField.invokeExact(vhNull, this, 888);
        fail("Unreachable");
    } catch (NullPointerException e) {
        assertEquals(-1, field);
    }
}
#method_after
void run() throws Throwable {
    System.out.println("fieldVarHandleInvokerTest");
    MethodHandle invokerMethodHandle = MethodHandles.varHandleInvoker(VarHandle.AccessMode.GET_AND_SET, MethodType.methodType(int.class, FieldVarHandleInvokerTest.class, int.class));
    field = 3;
    int oldField = (int) invokerMethodHandle.invoke(fieldVarHandle, this, 4);
    assertEquals(3, oldField);
    assertEquals(4, field);
    // 
    // Check invocations with MethodHandle.invoke()
    // 
    // Check for unboxing
    int i = (int) invokerMethodHandle.invoke(fieldVarHandle, this, Integer.valueOf(3));
    assertEquals(3, field);
    // Check for widening conversion
    i = (int) invokerMethodHandle.invoke(fieldVarHandle, this, (short) 33);
    assertEquals(33, field);
    // Check for widening conversion
    i = (int) invokerMethodHandle.invoke(fieldVarHandle, this, Byte.valueOf((byte) 34));
    assertEquals(34, field);
    // Check for acceptance of void return type
    invokerMethodHandle.invoke(fieldVarHandle, this, 77);
    assertEquals(77, field);
    // Check for wider return type
    long l = (long) invokerMethodHandle.invoke(fieldVarHandle, this, 88);
    assertEquals(88, field);
    try {
        // Check narrowing conversion fails
        i = (int) invokerMethodHandle.invoke(fieldVarHandle, this, 3.0);
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
    }
    try {
        // Check reference type fails
        i = (int) invokerMethodHandle.invoke(fieldVarHandle, this, "Bad");
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
    }
    try {
        // Check null VarHandle instance fails
        VarHandle vhNull = null;
        i = (int) invokerMethodHandle.invoke(vhNull, this, 888);
        assertUnreachable();
    } catch (NullPointerException expected) {
        assertEquals(88, field);
    }
    // 
    // Check invocations with MethodHandle.invokeExact()
    // 
    field = -1;
    try {
        // Check for unboxing
        i = (int) invokerMethodHandle.invokeExact(fieldVarHandle, this, Integer.valueOf(3));
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
        assertEquals(-1, field);
    }
    try {
        // Check for widening conversion
        i = (int) invokerMethodHandle.invokeExact(fieldVarHandle, this, (short) 33);
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
        assertEquals(-1, field);
    }
    try {
        // Check for acceptance of void return type
        invokerMethodHandle.invokeExact(fieldVarHandle, this, 77);
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
        assertEquals(-1, field);
    }
    try {
        // Check for wider return type
        l = (long) invokerMethodHandle.invokeExact(fieldVarHandle, this, 78);
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
        assertEquals(-1, field);
    }
    try {
        // Check narrowing conversion fails
        i = (int) invokerMethodHandle.invokeExact(fieldVarHandle, this, 3.0);
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
    }
    try {
        // Check reference type fails
        i = (int) invokerMethodHandle.invokeExact(fieldVarHandle, this, "Bad");
        assertUnreachable();
    } catch (WrongMethodTypeException expected) {
    }
    try {
        // Check null VarHandle instance fails
        VarHandle vhNull = null;
        i = (int) invokerMethodHandle.invokeExact(vhNull, this, 888);
        assertUnreachable();
    } catch (NullPointerException expected) {
        assertEquals(-1, field);
    }
}
#end_block

#method_before
public static void main(String[] args) throws Throwable {
    new FieldVarHandleExactInvokerTest().run();
    new FieldVarHandleInvokerTest().run();
    new DivergenceInexactTest().run();
    new DivergenceExactTest().run();
}
#method_after
public static void main(String[] args) throws Throwable {
    new FieldVarHandleExactInvokerTest().run();
    new FieldVarHandleInvokerTest().run();
    new DivergenceExactInvokerTest().run();
    new DivergenceInvokerTest().run();
}
#end_block

#method_before
@Override
public void init(ServletConfig cfg) throws ServletException {
    super.init(cfg);
    keyFileInputStream = this.getServletContext().getResourceAsStream("/WEB-INF/keys/vtslab-gcs-277026dcab45.json");
    try {
        storage = StorageOptions.newBuilder().setProjectId("vtslab-gcs").setCredentials(ServiceAccountCredentials.fromStream(keyFileInputStream)).build().getService();
    } catch (IOException e) {
        logger.log(Level.SEVERE, "Error on creating storage instance!");
    }
}
#method_after
@Override
public void init(ServletConfig cfg) throws ServletException {
    super.init(cfg);
    keyFileInputStream = this.getServletContext().getResourceAsStream("/WEB-INF/keys/" + GCS_KEY_FILE);
    try {
        storage = StorageOptions.newBuilder().setProjectId(GCS_PROJECT_ID).setCredentials(ServiceAccountCredentials.fromStream(keyFileInputStream)).build().getService();
    } catch (IOException e) {
        logger.log(Level.SEVERE, "Error on creating storage instance!");
    }
}
#end_block

#method_before
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String path = request.getParameter("path") == null ? "" : request.getParameter("path");
    Bucket vtsReportBucket = storage.get("vts-report");
    String bucketName = "vts-report";
    List<String> dirList = new ArrayList<>();
    List<String> fileList = new ArrayList<>();
    if (path.endsWith(".zip")) {
        Blob blobFile = vtsReportBucket.get(path);
    } else {
        path = path.endsWith("/") ? path : path.concat("/");
        Path pathInfo = Paths.get(path);
        logger.log(Level.INFO, "path info => " + pathInfo);
        logger.log(Level.INFO, "path name count => " + pathInfo.getNameCount());
        BlobListOption[] listOptions;
        if (pathInfo.getNameCount() == 0) {
            listOptions = new BlobListOption[] { BlobListOption.currentDirectory() };
        } else {
            if (pathInfo.getNameCount() == 1) {
                dirList.add(pathInfo.toString());
            } else {
                dirList.add(pathInfo.getParent().toString());
            }
            listOptions = new BlobListOption[] { BlobListOption.currentDirectory(), BlobListOption.prefix(pathInfo.toString() + "/") };
        }
        for (Blob blob : vtsReportBucket.list(listOptions).iterateAll()) {
            if (blob == null) {
            } else {
                logger.log(Level.INFO, "blob name => " + blob);
                if (blob.isDirectory()) {
                    logger.log(Level.INFO, "directory name => " + blob.getName());
                    dirList.add(blob.getName());
                } else {
                    logger.log(Level.INFO, "file name => " + blob.getName());
                    fileList.add(blob.getName());
                }
            }
        }
    }
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("dirList", dirList);
    request.setAttribute("fileList", fileList);
    request.setAttribute("path", path);
    RequestDispatcher dispatcher = request.getRequestDispatcher(GCS_LOG_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
    }
}
#method_after
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String path = request.getParameter("path") == null ? "" : request.getParameter("path");
    Path pathInfo = Paths.get(path);
    Bucket vtsReportBucket = storage.get(GCS_BUCKET_NAME);
    List<String> dirList = new ArrayList<>();
    List<String> fileList = new ArrayList<>();
    if (pathInfo.endsWith(".zip")) {
        Blob blobFile = vtsReportBucket.get(path);
    } else {
        logger.log(Level.INFO, "path info => " + pathInfo);
        logger.log(Level.INFO, "path name count => " + pathInfo.getNameCount());
        BlobListOption[] listOptions;
        if (pathInfo.getNameCount() == 0) {
            listOptions = new BlobListOption[] { BlobListOption.currentDirectory() };
        } else {
            if (pathInfo.getNameCount() <= 1) {
                dirList.add("/");
            } else {
                dirList.add(pathInfo.getParent().toString());
            }
            listOptions = new BlobListOption[] { BlobListOption.currentDirectory(), BlobListOption.prefix(pathInfo.toString() + "/") };
        }
        Iterator<Blob> blobIterator = vtsReportBucket.list(listOptions).iterateAll();
        while (blobIterator.hasNext()) {
            Blob blob = blobIterator.next();
            logger.log(Level.INFO, "blob name => " + blob);
            if (blob.isDirectory()) {
                logger.log(Level.INFO, "directory name => " + blob.getName());
                dirList.add(blob.getName());
            } else {
                logger.log(Level.INFO, "file name => " + blob.getName());
                fileList.add(blob.getName());
            }
        }
    }
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("dirList", dirList);
    request.setAttribute("fileList", fileList);
    request.setAttribute("path", path);
    RequestDispatcher dispatcher = request.getRequestDispatcher(GCS_LOG_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
    }
}
#end_block

#method_before
private void processDisconnect(final ServiceConnection connection) {
    synchronized (mLock) {
        // crashes and fall back to default if it continues to misbehave.
        if (connection == mWallpaper.connection) {
            final ComponentName wpService = mWallpaper.wallpaperComponent;
            if (!mWallpaper.wallpaperUpdating && mWallpaper.userId == mCurrentUserId && !Objects.equals(mDefaultWallpaperComponent, wpService) && !Objects.equals(mImageWallpaper, wpService)) {
                // during {@link #MIN_WALLPAPER_CRASH_TIME} millis.
                if (mWallpaper.lastDiedTime != 0 && mWallpaper.lastDiedTime + MIN_WALLPAPER_CRASH_TIME > SystemClock.uptimeMillis()) {
                    Slog.w(TAG, "Reverting to built-in wallpaper!");
                    clearWallpaperLocked(true, FLAG_SYSTEM, mWallpaper.userId, null);
                } else {
                    mWallpaper.lastDiedTime = SystemClock.uptimeMillis();
                    clearWallpaperComponentLocked(mWallpaper);
                    bindWallpaperComponentLocked(wpService, false, false, mWallpaper, null);
                    if (mWallpaper.connection != null) {
                        mWallpaper.connection.scheduleTimeoutLocked();
                    }
                }
                final String flattened = wpService.flattenToString();
                EventLog.writeEvent(EventLogTags.WP_WALLPAPER_CRASHED, flattened.substring(0, Math.min(flattened.length(), MAX_WALLPAPER_COMPONENT_LOG_LENGTH)));
            }
        } else {
            if (DEBUG_LIVE) {
                Slog.i(TAG, "Wallpaper changed during disconnect tracking; ignoring");
            }
        }
    }
}
#method_after
private void processDisconnect(final ServiceConnection connection) {
    synchronized (mLock) {
        // crashes and fall back to default if it continues to misbehave.
        if (connection == mWallpaper.connection) {
            final ComponentName wpService = mWallpaper.wallpaperComponent;
            if (!mWallpaper.wallpaperUpdating && mWallpaper.userId == mCurrentUserId && !Objects.equals(mDefaultWallpaperComponent, wpService) && !Objects.equals(mImageWallpaper, wpService)) {
                // during {@link #MIN_WALLPAPER_CRASH_TIME} millis.
                if (mWallpaper.lastDiedTime != 0 && mWallpaper.lastDiedTime + MIN_WALLPAPER_CRASH_TIME > SystemClock.uptimeMillis()) {
                    Slog.w(TAG, "Reverting to built-in wallpaper!");
                    clearWallpaperLocked(true, FLAG_SYSTEM, mWallpaper.userId, null);
                } else {
                    mWallpaper.lastDiedTime = SystemClock.uptimeMillis();
                    clearWallpaperComponentLocked(mWallpaper);
                    if (bindWallpaperComponentLocked(wpService, false, false, mWallpaper, null)) {
                        mWallpaper.connection.scheduleTimeoutLocked();
                    } else {
                        Slog.w(TAG, "Reverting to built-in wallpaper!");
                        clearWallpaperLocked(true, FLAG_SYSTEM, mWallpaper.userId, null);
                    }
                }
                final String flattened = wpService.flattenToString();
                EventLog.writeEvent(EventLogTags.WP_WALLPAPER_CRASHED, flattened.substring(0, Math.min(flattened.length(), MAX_WALLPAPER_COMPONENT_LOG_LENGTH)));
            }
        } else {
            if (DEBUG_LIVE) {
                Slog.i(TAG, "Wallpaper changed during disconnect tracking; ignoring");
            }
        }
    }
}
#end_block

#method_before
public static ZygoteProcess getProcess() {
    synchronized (sLock) {
        if (sZygote != null)
            return sZygote.zygote;
        connectToZygoteIfNeededLocked();
        return sZygote.zygote;
    }
}
#method_after
public static ZygoteProcess getProcess() {
    synchronized (sLock) {
        if (sZygote != null)
            return sZygote;
        connectToZygoteIfNeededLocked();
        return sZygote;
    }
}
#end_block

#method_before
public static void onWebViewProviderChanged(PackageInfo packageInfo, String cacheKey) {
    synchronized (sLock) {
        sPackage = packageInfo;
        sPackageCacheKey = cacheKey;
        // If multi-process is not enabled, then do not start the zygote service.
        if (!sMultiprocessEnabled) {
            return;
        }
        stopZygoteLocked();
    }
}
#method_after
public static void onWebViewProviderChanged(PackageInfo packageInfo, ApplicationInfo originalAppInfo) {
    synchronized (sLock) {
        sPackage = packageInfo;
        sPackageOriginalAppInfo = originalAppInfo;
        // If multi-process is not enabled, then do not start the zygote service.
        if (!sMultiprocessEnabled) {
            return;
        }
        stopZygoteLocked();
    }
}
#end_block

#method_before
@GuardedBy("sLock")
private static void stopZygoteLocked() {
    if (sZygote != null) {
        sZygote.zygote.close();
        Process.killProcess(sZygote.startResult.pid);
        sZygote = null;
    }
}
#method_after
@GuardedBy("sLock")
private static void stopZygoteLocked() {
    if (sZygote != null) {
        // Close the connection and kill the zygote process. This will not cause
        // child processes to be killed by itself. But if this is called in response to
        // setMultiprocessEnabled() or onWebViewProviderChanged(), the WebViewUpdater
        // will kill all processes that depend on the WebView package.
        sZygote.close();
        Process.killProcess(sZygote.getPid());
        sZygote = null;
    }
}
#end_block

#method_before
@GuardedBy("sLock")
private static void connectToZygoteIfNeededLocked() {
    if (sZygote != null) {
        return;
    }
    if (sPackage == null) {
        Log.e(LOGTAG, "Cannot connect to zygote, no package specified");
        return;
    }
    try {
        sZygote = Process.zygoteProcess.startChildZygote("com.android.internal.os.WebViewZygoteInit", "webview_zygote", Process.WEBVIEW_ZYGOTE_UID, Process.WEBVIEW_ZYGOTE_UID, // gids
        null, // runtimeFlags
        0, // targetSdkVersion
        0, // seInfo
        "webview_zygote", // abi
        sPackage.applicationInfo.primaryCpuAbi, // instructionSet
        null, // invokeWith
        null);
        // All the work below is usually done by LoadedApk, but the zygote can't talk to
        // PackageManager or construct a LoadedApk since it's single-threaded pre-fork, so
        // doesn't have an ActivityThread and can't use Binder.
        // Instead, figure out the paths here, in the system server where we have access to
        // the package manager. Reuse the logic from LoadedApk to determine the correct
        // paths and pass them to the zygote as strings.
        final List<String> zipPaths = new ArrayList<>(10);
        final List<String> libPaths = new ArrayList<>(10);
        LoadedApk.makePaths(null, false, sPackage.applicationInfo, zipPaths, libPaths);
        final String librarySearchPath = TextUtils.join(File.pathSeparator, libPaths);
        final String zip = (zipPaths.size() == 1) ? zipPaths.get(0) : TextUtils.join(File.pathSeparator, zipPaths);
        ZygoteProcess.waitForConnectionToZygote(sZygote.zygote.getPrimarySocketAddress());
        Log.d(LOGTAG, "Preloading package " + zip + " " + librarySearchPath);
        sZygote.zygote.preloadPackageForAbi(zip, librarySearchPath, sPackageCacheKey, Build.SUPPORTED_ABIS[0]);
    } catch (Exception e) {
        Log.e(LOGTAG, "Error connecting to webview zygote", e);
        stopZygoteLocked();
    }
}
#method_after
@GuardedBy("sLock")
private static void connectToZygoteIfNeededLocked() {
    if (sZygote != null) {
        return;
    }
    if (sPackage == null) {
        Log.e(LOGTAG, "Cannot connect to zygote, no package specified");
        return;
    }
    try {
        sZygote = Process.zygoteProcess.startChildZygote("com.android.internal.os.WebViewZygoteInit", "webview_zygote", Process.WEBVIEW_ZYGOTE_UID, Process.WEBVIEW_ZYGOTE_UID, // gids
        null, // runtimeFlags
        0, // seInfo
        "webview_zygote", // abi
        sPackage.applicationInfo.primaryCpuAbi, // instructionSet
        null);
        // All the work below is usually done by LoadedApk, but the zygote can't talk to
        // PackageManager or construct a LoadedApk since it's single-threaded pre-fork, so
        // doesn't have an ActivityThread and can't use Binder.
        // Instead, figure out the paths here, in the system server where we have access to
        // the package manager. Reuse the logic from LoadedApk to determine the correct
        // paths and pass them to the zygote as strings.
        final List<String> zipPaths = new ArrayList<>(10);
        final List<String> libPaths = new ArrayList<>(10);
        LoadedApk.makePaths(null, false, sPackage.applicationInfo, zipPaths, libPaths);
        final String librarySearchPath = TextUtils.join(File.pathSeparator, libPaths);
        final String zip = (zipPaths.size() == 1) ? zipPaths.get(0) : TextUtils.join(File.pathSeparator, zipPaths);
        // In the case where the ApplicationInfo has been modified by the stub WebView,
        // we need to use the original ApplicationInfo to determine what the original classpath
        // would have been to use as a cache key.
        LoadedApk.makePaths(null, false, sPackageOriginalAppInfo, zipPaths, null);
        final String cacheKey = (zipPaths.size() == 1) ? zipPaths.get(0) : TextUtils.join(File.pathSeparator, zipPaths);
        ZygoteProcess.waitForConnectionToZygote(sZygote.getPrimarySocketAddress());
        Log.d(LOGTAG, "Preloading package " + zip + " " + librarySearchPath);
        sZygote.preloadPackageForAbi(zip, librarySearchPath, cacheKey, Build.SUPPORTED_ABIS[0]);
    } catch (Exception e) {
        Log.e(LOGTAG, "Error connecting to webview zygote", e);
        stopZygoteLocked();
    }
}
#end_block

#method_before
public static void main(String[] argv) {
    Log.i(TAG, "Starting WebViewZygoteInit");
    String socketName = null;
    for (String arg : argv) {
        Log.i(TAG, arg);
        if (arg.startsWith(Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG)) {
            socketName = arg.substring(Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG.length());
        }
    }
    if (socketName == null) {
        throw new RuntimeException("No " + Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG + " specified");
    }
    try {
        Os.prctl(OsConstants.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException("Failed to set PR_SET_NO_NEW_PRIVS", ex);
    }
    sServer = new WebViewZygoteServer();
    final Runnable caller;
    try {
        try {
            sServer.setServerSocket(new LocalServerSocket(socketName));
        } catch (IOException ex) {
            throw new RuntimeException("Failed to bind local socket", ex);
        }
        Zygote.nativeAllowFileAcrossFork("ABSTRACT/" + socketName);
        // The select loop returns early in the child process after a fork and
        // loops forever in the zygote.
        caller = sServer.runSelectLoop(TextUtils.join(",", Build.SUPPORTED_ABIS));
    } catch (RuntimeException e) {
        Log.e(TAG, "Fatal exception:", e);
        throw e;
    } finally {
        sServer.closeServerSocket();
    }
    // command.
    if (caller != null) {
        caller.run();
    }
}
#method_after
public static void main(String[] argv) {
    Log.i(TAG, "Starting WebViewZygoteInit");
    String socketName = null;
    for (String arg : argv) {
        Log.i(TAG, arg);
        if (arg.startsWith(Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG)) {
            socketName = arg.substring(Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG.length());
        }
    }
    if (socketName == null) {
        throw new RuntimeException("No " + Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG + " specified");
    }
    try {
        Os.prctl(OsConstants.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException("Failed to set PR_SET_NO_NEW_PRIVS", ex);
    }
    sServer = new WebViewZygoteServer();
    final Runnable caller;
    try {
        sServer.registerServerSocketAtAbstractName(socketName);
        // Add the abstract socket to the FD whitelist so that the native zygote code
        // can properly detach it after forking.
        Zygote.nativeAllowFileAcrossFork("ABSTRACT/" + socketName);
        // The select loop returns early in the child process after a fork and
        // loops forever in the zygote.
        caller = sServer.runSelectLoop(TextUtils.join(",", Build.SUPPORTED_ABIS));
    } catch (RuntimeException e) {
        Log.e(TAG, "Fatal exception:", e);
        throw e;
    } finally {
        sServer.closeServerSocket();
    }
    // command.
    if (caller != null) {
        caller.run();
    }
}
#end_block

#method_before
@Before
public void setUp() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    Assert.assertNotNull(Looper.myLooper());
    MockitoAnnotations.initMocks(this);
    mProfiles = Config.getSupportedProfiles();
    Method method = AdapterService.class.getDeclaredMethod("setAdapterService", AdapterService.class);
    method.setAccessible(true);
    method.invoke(null, mMockAdapterService);
    Assert.assertNotNull(AdapterService.getAdapterService());
}
#method_after
@Before
public void setUp() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    Assert.assertNotNull(Looper.myLooper());
    MockitoAnnotations.initMocks(this);
    mProfiles = Config.getSupportedProfiles();
    mMockAdapterService.initNative();
    TestUtils.setAdapterService(mMockAdapterService);
    Assert.assertNotNull(AdapterService.getAdapterService());
}
#end_block

#method_before
@After
public void tearDown() {
    mMockAdapterService = null;
    mProfiles = null;
}
#method_after
@After
public void tearDown() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
    mMockAdapterService.cleanupNative();
    TestUtils.clearAdapterService(mMockAdapterService);
    mMockAdapterService = null;
    mProfiles = null;
}
#end_block

#method_before
@Test
public void testRepeatedEnableDisableSingly() throws TimeoutException {
    for (Class profile : mProfiles) {
        for (int i = 0; i < 5; i++) {
            setProfileState(profile, BluetoothAdapter.STATE_ON);
            ArgumentCaptor<ProfileService> start = ArgumentCaptor.forClass(ProfileService.class);
            verify(mMockAdapterService, timeout(PROFILE_START_MILLIS).times(i + 1)).onProfileServiceStateChanged(start.capture(), eq(BluetoothAdapter.STATE_ON));
            setProfileState(profile, BluetoothAdapter.STATE_OFF);
            ArgumentCaptor<ProfileService> stop = ArgumentCaptor.forClass(ProfileService.class);
            verify(mMockAdapterService, timeout(PROFILE_START_MILLIS).times(2 * (i + 1))).onProfileServiceStateChanged(stop.capture(), eq(BluetoothAdapter.STATE_OFF));
            Assert.assertEquals(start.getValue(), stop.getValue());
        }
    }
}
#method_after
@Test
public void testRepeatedEnableDisableSingly() throws TimeoutException {
    int profileNumber = 0;
    for (Class profile : mProfiles) {
        for (int i = 0; i < NUM_REPEATS; i++) {
            setProfileState(profile, BluetoothAdapter.STATE_ON);
            ArgumentCaptor<ProfileService> start = ArgumentCaptor.forClass(ProfileService.class);
            verify(mMockAdapterService, timeout(PROFILE_START_MILLIS).times(NUM_REPEATS * profileNumber + i + 1)).onProfileServiceStateChanged(start.capture(), eq(BluetoothAdapter.STATE_ON));
            setProfileState(profile, BluetoothAdapter.STATE_OFF);
            ArgumentCaptor<ProfileService> stop = ArgumentCaptor.forClass(ProfileService.class);
            verify(mMockAdapterService, timeout(PROFILE_START_MILLIS).times(NUM_REPEATS * profileNumber + i + 1)).onProfileServiceStateChanged(stop.capture(), eq(BluetoothAdapter.STATE_OFF));
            Assert.assertEquals(start.getValue(), stop.getValue());
        }
        profileNumber += 1;
    }
}
#end_block

#method_before
@After
public void tearDown() {
    mAdapterService.cleanup();
}
#method_after
@After
public void tearDown() {
    mAdapterService.cleanup();
    Config.init(InstrumentationRegistry.getTargetContext());
}
#end_block

#method_before
@Override
public void onCreate() {
    if (DBG) {
        log("onCreate");
    }
    super.onCreate();
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    mBinder = initBinder();
    create();
}
#method_after
@Override
public void onCreate() {
    if (DBG) {
        Log.d(mName, "onCreate");
    }
    super.onCreate();
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    mBinder = initBinder();
    create();
}
#end_block

#method_before
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (DBG) {
        log("onStartCommand()");
    }
    if (checkCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM) != PackageManager.PERMISSION_GRANTED) {
        Log.e(mName, "Permission denied!");
        return PROFILE_SERVICE_MODE;
    }
    if (intent == null) {
        Log.d(mName, "onStartCommand ignoring null intent.");
        return PROFILE_SERVICE_MODE;
    }
    String action = intent.getStringExtra(AdapterService.EXTRA_ACTION);
    if (AdapterService.ACTION_SERVICE_STATE_CHANGED.equals(action)) {
        int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
        if (state == BluetoothAdapter.STATE_OFF) {
            doStop();
        } else if (state == BluetoothAdapter.STATE_ON) {
            doStart();
        }
    }
    return PROFILE_SERVICE_MODE;
}
#method_after
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (DBG) {
        Log.d(mName, "onStartCommand()");
    }
    if (checkCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM) != PackageManager.PERMISSION_GRANTED) {
        Log.e(mName, "Permission denied!");
        return PROFILE_SERVICE_MODE;
    }
    if (intent == null) {
        Log.d(mName, "onStartCommand ignoring null intent.");
        return PROFILE_SERVICE_MODE;
    }
    String action = intent.getStringExtra(AdapterService.EXTRA_ACTION);
    if (AdapterService.ACTION_SERVICE_STATE_CHANGED.equals(action)) {
        int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
        if (state == BluetoothAdapter.STATE_OFF) {
            doStop();
        } else if (state == BluetoothAdapter.STATE_ON) {
            doStart();
        }
    }
    return PROFILE_SERVICE_MODE;
}
#end_block

#method_before
@Override
public IBinder onBind(Intent intent) {
    if (DBG) {
        log("onBind");
    }
    if (mAdapter != null && mBinder == null) {
        // initBinder returned null, you can't bind
        throw new UnsupportedOperationException("Cannot bind to " + mName);
    }
    return mBinder;
}
#method_after
@Override
public IBinder onBind(Intent intent) {
    if (DBG) {
        Log.d(mName, "onBind");
    }
    if (mAdapter != null && mBinder == null) {
        // initBinder returned null, you can't bind
        throw new UnsupportedOperationException("Cannot bind to " + mName);
    }
    return mBinder;
}
#end_block

#method_before
@Override
public boolean onUnbind(Intent intent) {
    if (DBG) {
        log("onUnbind");
    }
    return super.onUnbind(intent);
}
#method_after
@Override
public boolean onUnbind(Intent intent) {
    if (DBG) {
        Log.d(mName, "onUnbind");
    }
    return super.onUnbind(intent);
}
#end_block

#method_before
public void addProfile(ProfileService profile) {
    Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);
    m.obj = profile;
    m.arg1 = MESSAGE_PROFILE_REGISTERED;
    mHandler.sendMessage(m);
}
#method_after
public void addProfile(ProfileService profile) {
    Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile);
    mHandler.sendMessage(m);
}
#end_block

#method_before
public void removeProfile(ProfileService profile) {
    Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);
    m.obj = profile;
    m.arg1 = MESSAGE_PROFILE_UNREGISTERED;
    mHandler.sendMessage(m);
}
#method_after
public void removeProfile(ProfileService profile) {
    Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile);
    mHandler.sendMessage(m);
}
#end_block

#method_before
public void onProfileServiceStateChanged(ProfileService profile, int state) {
    if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {
        Log.e(TAG, "onProfileServiceStateChanged: Unhandled " + BluetoothAdapter.nameForState(state));
        return;
    }
    Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);
    m.obj = profile;
    m.arg1 = state;
    mHandler.sendMessage(m);
}
#method_after
public void onProfileServiceStateChanged(ProfileService profile, int state) {
    if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {
        throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));
    }
    Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);
    m.obj = profile;
    m.arg1 = state;
    mHandler.sendMessage(m);
}
#end_block

#method_before
void stopProfileServices() {
    Class[] supportedProfileServices = Config.getSupportedProfiles();
    if (mRunningProfiles.size() > 0) {
        setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);
    }
    debugLog("stopProfileServices() - No profiles services to stop or already stopped.");
}
#method_after
void stopProfileServices() {
    Class[] supportedProfileServices = Config.getSupportedProfiles();
    if (mRunningProfiles.size() == 0) {
        debugLog("stopProfileServices() - No profiles services to stop or already stopped.");
        return;
    }
    setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);
}
#end_block

#method_before
void updateAdapterState(int prevState, int newState) {
    if (mCallbacks != null) {
        int n = mCallbacks.beginBroadcast();
        debugLog("updateAdapterState() - Broadcasting state to " + n + " receivers.");
        for (int i = 0; i < n; i++) {
            try {
                mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);
            } catch (RemoteException e) {
                debugLog("updateAdapterState() - Callback #" + i + " failed (" + e + ")");
            }
        }
        mCallbacks.finishBroadcast();
    }
}
#method_after
void updateAdapterState(int prevState, int newState) {
    if (mCallbacks != null) {
        int n = mCallbacks.beginBroadcast();
        debugLog("updateAdapterState() - Broadcasting state " + BluetoothAdapter.nameForState(newState) + " to " + n + " receivers.");
        for (int i = 0; i < n; i++) {
            try {
                mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);
            } catch (RemoteException e) {
                debugLog("updateAdapterState() - Callback #" + i + " failed (" + e + ")");
            }
        }
        mCallbacks.finishBroadcast();
    }
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    if (args.length == 0) {
        writer.println("Skipping dump in APP SERVICES, see bluetooth_manager section.");
        writer.println("Use --print argument for dumpsys direct from AdapterService.");
        return;
    }
    verboseLog("dumpsys arguments, check for protobuf output: " + TextUtils.join(" ", args));
    if (args[0].startsWith("--proto")) {
        if (args[0].equals("--proto-bin")) {
            dumpMetrics(fd);
        } else if (args[0].equals("--proto-java-bin")) {
            // TODO: Remove once --proto-java-bin is no longer used
            BluetoothProto.BluetoothLog metrics = new BluetoothProto.BluetoothLog();
            byte[] metricsBytes = Base64.encode(metrics.toByteArray(), Base64.DEFAULT);
            Log.w(TAG, "proto-java-bin dump, empty metrics size is " + metricsBytes.length);
            try (FileOutputStream protoOut = new FileOutputStream(fd)) {
                protoOut.write(metricsBytes);
            } catch (IOException e) {
                errorLog("Unable to write Java protobuf to file descriptor.");
            }
        }
        return;
    }
    writer.println("Bonded devices:");
    for (BluetoothDevice device : getBondedDevices()) {
        writer.println("  " + device.getAddress() + " [" + DEVICE_TYPE_NAMES[device.getType()] + "] " + device.getName());
    }
    StringBuilder sb = new StringBuilder();
    for (ProfileService profile : mRegisteredProfiles) {
        profile.dump(sb);
    }
    writer.write(sb.toString());
    writer.flush();
    dumpNative(fd, args);
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    if (args.length == 0) {
        writer.println("Skipping dump in APP SERVICES, see bluetooth_manager section.");
        writer.println("Use --print argument for dumpsys direct from AdapterService.");
        return;
    }
    verboseLog("dumpsys arguments, check for protobuf output: " + TextUtils.join(" ", args));
    if (args[0].equals("--proto-bin")) {
        dumpMetrics(fd);
        return;
    }
    writer.println("Bonded devices:");
    for (BluetoothDevice device : getBondedDevices()) {
        writer.println("  " + device.getAddress() + " [" + DEVICE_TYPE_NAMES[device.getType()] + "] " + device.getName());
    }
    StringBuilder sb = new StringBuilder();
    for (ProfileService profile : mRegisteredProfiles) {
        profile.dump(sb);
    }
    writer.write(sb.toString());
    writer.flush();
    dumpNative(fd, args);
}
#end_block

#method_before
private void dumpMetrics(FileDescriptor fd) {
    BluetoothProto.BluetoothLog metrics = new BluetoothProto.BluetoothLog();
    metrics.setNumBondedDevices(getBondedDevices().length);
    for (ProfileService profile : mProfiles) {
        profile.dumpProto(metrics);
    }
    byte[] nativeMetricsBytes = dumpMetricsNative();
    debugLog("dumpMetrics: native metrics size is " + nativeMetricsBytes.length);
    if (nativeMetricsBytes.length > 0) {
        try {
            metrics.mergeFrom(nativeMetricsBytes);
        } catch (InvalidProtocolBufferMicroException ex) {
            Log.w(TAG, "dumpMetrics: problem parsing metrics protobuf, " + ex.getMessage());
            return;
        }
    }
    byte[] metricsBytes = Base64.encode(metrics.toByteArray(), Base64.DEFAULT);
    debugLog("dumpMetrics: combined metrics size is " + metricsBytes.length);
    try (FileOutputStream protoOut = new FileOutputStream(fd)) {
        protoOut.write(metricsBytes);
    } catch (IOException e) {
        errorLog("dumpMetrics: error writing combined protobuf to fd, " + e.getMessage());
    }
}
#method_after
private void dumpMetrics(FileDescriptor fd) {
    BluetoothProto.BluetoothLog metrics = new BluetoothProto.BluetoothLog();
    metrics.setNumBondedDevices(getBondedDevices().length);
    for (ProfileService profile : mRegisteredProfiles) {
        profile.dumpProto(metrics);
    }
    byte[] nativeMetricsBytes = dumpMetricsNative();
    debugLog("dumpMetrics: native metrics size is " + nativeMetricsBytes.length);
    if (nativeMetricsBytes.length > 0) {
        try {
            metrics.mergeFrom(nativeMetricsBytes);
        } catch (InvalidProtocolBufferMicroException ex) {
            Log.w(TAG, "dumpMetrics: problem parsing metrics protobuf, " + ex.getMessage());
            return;
        }
    }
    byte[] metricsBytes = Base64.encode(metrics.toByteArray(), Base64.DEFAULT);
    debugLog("dumpMetrics: combined metrics size is " + metricsBytes.length);
    try (FileOutputStream protoOut = new FileOutputStream(fd)) {
        protoOut.write(metricsBytes);
    } catch (IOException e) {
        errorLog("dumpMetrics: error writing combined protobuf to fd, " + e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void log(String msg) {
    Rlog.d(LOG_TAG, "[GsmCdmaCallTracker][" + mPhone.getPhoneId() + "] " + msg);
}
#method_after
@Override
protected void log(String msg) {
    Rlog.d(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + msg);
}
#end_block

#method_before
private void initOnce(CommandsInterface ci) {
    if (ci instanceof SimulatedRadioControl) {
        mSimulatedRadioControl = (SimulatedRadioControl) ci;
    }
    mCT = mTelephonyComponentFactory.makeGsmCdmaCallTracker(this);
    mIccPhoneBookIntManager = mTelephonyComponentFactory.makeIccPhoneBookInterfaceManager(this);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
    mIccSmsInterfaceManager = mTelephonyComponentFactory.makeIccSmsInterfaceManager(this);
    mIccCardProxy = mTelephonyComponentFactory.makeIccCardProxy(mContext, mCi, mPhoneId);
    mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
    mCi.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mCi.registerForOn(this, EVENT_RADIO_ON, null);
    mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
    // GSM
    mCi.setOnUSSD(this, EVENT_USSD, null);
    mCi.setOnSs(this, EVENT_SS, null);
    // CDMA
    mCdmaSSM = mTelephonyComponentFactory.getCdmaSubscriptionSourceManagerInstance(mContext, mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
    mEriManager = mTelephonyComponentFactory.makeEriManager(this, mContext, EriManager.ERI_FROM_XML);
    mCi.setEmergencyCallbackMode(this, EVENT_EMERGENCY_CALLBACK_MODE_ENTER, null);
    mCi.registerForExitEmergencyCallbackMode(this, EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE, null);
    mCi.registerForModemReset(this, EVENT_MODEM_RESET, null);
    // get the string that specifies the carrier OTA Sp number
    mCarrierOtaSpNumSchema = TelephonyManager.from(mContext).getOtaSpNumberSchemaForPhone(getPhoneId(), "");
    mResetModemOnRadioTechnologyChange = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RESET_ON_RADIO_TECH_CHANGE, false);
    mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
    mCi.registerForVoiceRadioTechChanged(this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
    mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED));
}
#method_after
private void initOnce(CommandsInterface ci) {
    if (ci instanceof SimulatedRadioControl) {
        mSimulatedRadioControl = (SimulatedRadioControl) ci;
    }
    mCT = mTelephonyComponentFactory.makeGsmCdmaCallTracker(this);
    mIccPhoneBookIntManager = mTelephonyComponentFactory.makeIccPhoneBookInterfaceManager(this);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
    mIccSmsInterfaceManager = mTelephonyComponentFactory.makeIccSmsInterfaceManager(this);
    mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
    mCi.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mCi.registerForOn(this, EVENT_RADIO_ON, null);
    mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
    // GSM
    mCi.setOnUSSD(this, EVENT_USSD, null);
    mCi.setOnSs(this, EVENT_SS, null);
    // CDMA
    mCdmaSSM = mTelephonyComponentFactory.getCdmaSubscriptionSourceManagerInstance(mContext, mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
    mEriManager = mTelephonyComponentFactory.makeEriManager(this, mContext, EriManager.ERI_FROM_XML);
    mCi.setEmergencyCallbackMode(this, EVENT_EMERGENCY_CALLBACK_MODE_ENTER, null);
    mCi.registerForExitEmergencyCallbackMode(this, EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE, null);
    mCi.registerForModemReset(this, EVENT_MODEM_RESET, null);
    // get the string that specifies the carrier OTA Sp number
    mCarrierOtaSpNumSchema = TelephonyManager.from(mContext).getOtaSpNumberSchemaForPhone(getPhoneId(), "");
    mResetModemOnRadioTechnologyChange = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RESET_ON_RADIO_TECH_CHANGE, false);
    mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
    mCi.registerForVoiceRadioTechChanged(this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
    mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED));
    mCDM = new CarrierKeyDownloadManager(this);
}
#end_block

#method_before
private void initRatSpecific(int precisePhoneType) {
    mPendingMMIs.clear();
    mIccPhoneBookIntManager.updateIccRecords(null);
    mEsn = null;
    mMeid = null;
    mPrecisePhoneType = precisePhoneType;
    TelephonyManager tm = TelephonyManager.from(mContext);
    if (isPhoneTypeGsm()) {
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_GSM);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_GSM);
        mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else {
        mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
        // This is needed to handle phone process crashes
        mIsPhoneInEcmState = getInEcmMode();
        if (mIsPhoneInEcmState) {
            // Send a message which will invoke handleExitEmergencyCallbackMode
            mCi.exitEmergencyCallbackMode(obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
        }
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_CDMA);
        mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT);
        // Sets operator properties by retrieving from build-time system property
        String operatorAlpha = SystemProperties.get("ro.cdma.home.operator.alpha");
        String operatorNumeric = SystemProperties.get(PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
        logd("init: operatorAlpha='" + operatorAlpha + "' operatorNumeric='" + operatorNumeric + "'");
        if (mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP) == null || isPhoneTypeCdmaLte()) {
            if (!TextUtils.isEmpty(operatorAlpha)) {
                logd("init: set 'gsm.sim.operator.alpha' to operator='" + operatorAlpha + "'");
                tm.setSimOperatorNameForPhone(mPhoneId, operatorAlpha);
            }
            if (!TextUtils.isEmpty(operatorNumeric)) {
                logd("init: set 'gsm.sim.operator.numeric' to operator='" + operatorNumeric + "'");
                logd("update icc_operator_numeric=" + operatorNumeric);
                tm.setSimOperatorNumericForPhone(mPhoneId, operatorNumeric);
                SubscriptionController.getInstance().setMccMnc(operatorNumeric, getSubId());
                // Sets iso country property by retrieving from build-time system property
                setIsoCountryProperty(operatorNumeric);
                // Updates MCC MNC device configuration information
                logd("update mccmnc=" + operatorNumeric);
                MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
            }
        }
        // Sets current entry in the telephony carrier table
        updateCurrentCarrierInProvider(operatorNumeric);
    }
}
#method_after
private void initRatSpecific(int precisePhoneType) {
    mPendingMMIs.clear();
    mIccPhoneBookIntManager.updateIccRecords(null);
    mEsn = null;
    mMeid = null;
    mPrecisePhoneType = precisePhoneType;
    logd("Precise phone type " + mPrecisePhoneType);
    TelephonyManager tm = TelephonyManager.from(mContext);
    UiccProfile uiccProfile = getUiccProfile();
    if (isPhoneTypeGsm()) {
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_GSM);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_GSM);
        if (uiccProfile != null) {
            uiccProfile.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
        }
    } else {
        mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
        // This is needed to handle phone process crashes
        mIsPhoneInEcmState = getInEcmMode();
        if (mIsPhoneInEcmState) {
            // Send a message which will invoke handleExitEmergencyCallbackMode
            mCi.exitEmergencyCallbackMode(obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
        }
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_CDMA);
        if (uiccProfile != null) {
            uiccProfile.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT);
        }
        // Sets operator properties by retrieving from build-time system property
        String operatorAlpha = SystemProperties.get("ro.cdma.home.operator.alpha");
        String operatorNumeric = SystemProperties.get(PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
        logd("init: operatorAlpha='" + operatorAlpha + "' operatorNumeric='" + operatorNumeric + "'");
        if (!TextUtils.isEmpty(operatorAlpha)) {
            logd("init: set 'gsm.sim.operator.alpha' to operator='" + operatorAlpha + "'");
            tm.setSimOperatorNameForPhone(mPhoneId, operatorAlpha);
        }
        if (!TextUtils.isEmpty(operatorNumeric)) {
            logd("init: set 'gsm.sim.operator.numeric' to operator='" + operatorNumeric + "'");
            logd("update icc_operator_numeric=" + operatorNumeric);
            tm.setSimOperatorNumericForPhone(mPhoneId, operatorNumeric);
            SubscriptionController.getInstance().setMccMnc(operatorNumeric, getSubId());
            // Sets iso country property by retrieving from build-time system property
            setIsoCountryProperty(operatorNumeric);
            // Updates MCC MNC device configuration information
            logd("update mccmnc=" + operatorNumeric);
            MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
        }
        // Sets current entry in the telephony carrier table
        updateCurrentCarrierInProvider(operatorNumeric);
    }
}
#end_block

#method_before
@Override
public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    if (!isPhoneTypeGsm() && uusInfo != null) {
        throw new CallStateException("Sending UUS information NOT supported in CDMA!");
    }
    boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(getSubId(), dialString);
    Phone imsPhone = mImsPhone;
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    boolean alwaysTryImsForEmergencyCarrierConfig = configManager.getConfigForSubId(getSubId()).getBoolean(CarrierConfigManager.KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL);
    boolean useImsForCall = isImsUseEnabled() && imsPhone != null && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() || (imsPhone.isVideoEnabled() && VideoProfile.isVideo(videoState))) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
    boolean useImsForEmergency = imsPhone != null && isEmergency && alwaysTryImsForEmergencyCarrierConfig && ImsManager.isNonTtyOrTtyOnVolteEnabled(mContext) && imsPhone.isImsAvailable();
    String dialPart = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.stripSeparators(dialString));
    boolean isUt = (dialPart.startsWith("*") || dialPart.startsWith("#")) && dialPart.endsWith("#");
    boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
    if (DBG) {
        logd("useImsForCall=" + useImsForCall + ", useImsForEmergency=" + useImsForEmergency + ", useImsForUt=" + useImsForUt + ", isUt=" + isUt + ", imsPhone=" + imsPhone + ", imsPhone.isVolteEnabled()=" + ((imsPhone != null) ? imsPhone.isVolteEnabled() : "N/A") + ", imsPhone.isVowifiEnabled()=" + ((imsPhone != null) ? imsPhone.isWifiCallingEnabled() : "N/A") + ", imsPhone.isVideoEnabled()=" + ((imsPhone != null) ? imsPhone.isVideoEnabled() : "N/A") + ", imsPhone.getServiceState().getState()=" + ((imsPhone != null) ? imsPhone.getServiceState().getState() : "N/A"));
    }
    Phone.checkWfcWifiOnlyModeBeforeDial(mImsPhone, mContext);
    if ((useImsForCall && !isUt) || (isUt && useImsForUt) || useImsForEmergency) {
        try {
            if (DBG)
                logd("Trying IMS PS call");
            return imsPhone.dial(dialString, uusInfo, videoState, intentExtras);
        } catch (CallStateException e) {
            if (DBG)
                logd("IMS PS call exception " + e + "useImsForCall =" + useImsForCall + ", imsPhone =" + imsPhone);
            // for emergency calls and MMI codes.
            if (Phone.CS_FALLBACK.equals(e.getMessage()) || isEmergency) {
                logi("IMS call failed with Exception: " + e.getMessage() + ". Falling back " + "to CS.");
            } else {
                CallStateException ce = new CallStateException(e.getMessage());
                ce.setStackTrace(e.getStackTrace());
                throw ce;
            }
        }
    }
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && mSST.mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && !isEmergency) {
        throw new CallStateException("cannot dial in current state");
    }
    // Check non-emergency voice CS call - shouldn't dial when POWER_OFF
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_POWER_OFF && /* CS POWER_OFF */
    !VideoProfile.isVideo(videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_POWER_OFF, "cannot dial voice call in airplane mode");
    }
    // Allow dial only if either CS is camped on any RAT (or) PS is in LTE service.
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && /* CS out of service */
    !(mSST.mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ServiceState.isLte(mSST.mSS.getRilDataRadioTechnology())) && /* PS not in LTE */
    !VideoProfile.isVideo(videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_OUT_OF_SERVICE, "cannot dial voice call in out of service");
    }
    if (DBG)
        logd("Trying (non-IMS) CS call");
    if (isPhoneTypeGsm()) {
        return dialInternal(dialString, null, VideoProfile.STATE_AUDIO_ONLY, intentExtras);
    } else {
        return dialInternal(dialString, null, videoState, intentExtras);
    }
}
#method_after
@Override
public Connection dial(String dialString, @NonNull DialArgs dialArgs) throws CallStateException {
    if (!isPhoneTypeGsm() && dialArgs.uusInfo != null) {
        throw new CallStateException("Sending UUS information NOT supported in CDMA!");
    }
    boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(getSubId(), dialString);
    Phone imsPhone = mImsPhone;
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    boolean alwaysTryImsForEmergencyCarrierConfig = configManager.getConfigForSubId(getSubId()).getBoolean(CarrierConfigManager.KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL);
    boolean useImsForCall = isImsUseEnabled() && imsPhone != null && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() || (imsPhone.isVideoEnabled() && VideoProfile.isVideo(dialArgs.videoState))) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
    boolean useImsForEmergency = imsPhone != null && isEmergency && alwaysTryImsForEmergencyCarrierConfig && ImsManager.getInstance(mContext, mPhoneId).isNonTtyOrTtyOnVolteEnabled() && imsPhone.isImsAvailable();
    String dialPart = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.stripSeparators(dialString));
    boolean isUt = (dialPart.startsWith("*") || dialPart.startsWith("#")) && dialPart.endsWith("#");
    boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
    if (DBG) {
        logd("useImsForCall=" + useImsForCall + ", useImsForEmergency=" + useImsForEmergency + ", useImsForUt=" + useImsForUt + ", isUt=" + isUt + ", imsPhone=" + imsPhone + ", imsPhone.isVolteEnabled()=" + ((imsPhone != null) ? imsPhone.isVolteEnabled() : "N/A") + ", imsPhone.isVowifiEnabled()=" + ((imsPhone != null) ? imsPhone.isWifiCallingEnabled() : "N/A") + ", imsPhone.isVideoEnabled()=" + ((imsPhone != null) ? imsPhone.isVideoEnabled() : "N/A") + ", imsPhone.getServiceState().getState()=" + ((imsPhone != null) ? imsPhone.getServiceState().getState() : "N/A"));
    }
    Phone.checkWfcWifiOnlyModeBeforeDial(mImsPhone, mPhoneId, mContext);
    if ((useImsForCall && !isUt) || (isUt && useImsForUt) || useImsForEmergency) {
        try {
            if (DBG)
                logd("Trying IMS PS call");
            return imsPhone.dial(dialString, dialArgs);
        } catch (CallStateException e) {
            if (DBG)
                logd("IMS PS call exception " + e + "useImsForCall =" + useImsForCall + ", imsPhone =" + imsPhone);
            // for emergency calls and MMI codes.
            if (Phone.CS_FALLBACK.equals(e.getMessage()) || isEmergency) {
                logi("IMS call failed with Exception: " + e.getMessage() + ". Falling back " + "to CS.");
            } else {
                CallStateException ce = new CallStateException(e.getMessage());
                ce.setStackTrace(e.getStackTrace());
                throw ce;
            }
        }
    }
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && mSST.mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && !isEmergency) {
        throw new CallStateException("cannot dial in current state");
    }
    // Check non-emergency voice CS call - shouldn't dial when POWER_OFF
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_POWER_OFF && /* CS POWER_OFF */
    !VideoProfile.isVideo(dialArgs.videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_POWER_OFF, "cannot dial voice call in airplane mode");
    }
    // Allow dial only if either CS is camped on any RAT (or) PS is in LTE service.
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && /* CS out of service */
    !(mSST.mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ServiceState.isLte(mSST.mSS.getRilDataRadioTechnology())) && /* PS not in LTE */
    !VideoProfile.isVideo(dialArgs.videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_OUT_OF_SERVICE, "cannot dial voice call in out of service");
    }
    if (DBG)
        logd("Trying (non-IMS) CS call");
    if (isPhoneTypeGsm()) {
        return dialInternal(dialString, new DialArgs.Builder<>().setIntentExtras(dialArgs.intentExtras).build());
    } else {
        return dialInternal(dialString, dialArgs);
    }
}
#end_block

#method_before
protected Connection dialInternal(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras, ResultReceiver wrappedCallback) throws CallStateException {
    // Need to make sure dialString gets parsed properly
    String newDialString = PhoneNumberUtils.stripSeparators(dialString);
    if (isPhoneTypeGsm()) {
        // handle in-call MMI first if applicable
        if (handleInCallMmiCommands(newDialString)) {
            return null;
        }
        // Only look at the Network portion for mmi
        String networkPortion = PhoneNumberUtils.extractNetworkPortionAlt(newDialString);
        GsmMmiCode mmi = GsmMmiCode.newFromDialString(networkPortion, this, mUiccApplication.get(), wrappedCallback);
        if (DBG)
            logd("dialInternal: dialing w/ mmi '" + mmi + "'...");
        if (mmi == null) {
            return mCT.dial(newDialString, uusInfo, intentExtras);
        } else if (mmi.isTemporaryModeCLIR()) {
            return mCT.dial(mmi.mDialingNumber, mmi.getCLIRMode(), uusInfo, intentExtras);
        } else {
            mPendingMMIs.add(mmi);
            mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
            mmi.processCode();
            return null;
        }
    } else {
        return mCT.dial(newDialString);
    }
}
#method_after
@Override
protected Connection dialInternal(String dialString, DialArgs dialArgs) throws CallStateException {
    return dialInternal(dialString, dialArgs, null);
}
#end_block

#method_before
@Override
public boolean handleUssdRequest(String ussdRequest, ResultReceiver wrappedCallback) {
    if (!isPhoneTypeGsm() || mPendingMMIs.size() > 0) {
        // todo: replace the generic failure with specific error code.
        sendUssdResponse(ussdRequest, null, TelephonyManager.USSD_RETURN_FAILURE, wrappedCallback);
        return true;
    }
    // Try over IMS if possible.
    Phone imsPhone = mImsPhone;
    if ((imsPhone != null) && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) || imsPhone.isUtEnabled())) {
        try {
            logd("handleUssdRequest: attempting over IMS");
            return imsPhone.handleUssdRequest(ussdRequest, wrappedCallback);
        } catch (CallStateException cse) {
            if (!CS_FALLBACK.equals(cse.getMessage())) {
                return false;
            }
            // At this point we've tried over IMS but have been informed we need to handover
            // back to GSM.
            logd("handleUssdRequest: fallback to CS required");
        }
    }
    // Try USSD over GSM.
    try {
        dialInternal(ussdRequest, null, VideoProfile.STATE_AUDIO_ONLY, null, wrappedCallback);
    } catch (Exception e) {
        logd("handleUssdRequest: exception" + e);
        return false;
    }
    return true;
}
#method_after
@Override
public boolean handleUssdRequest(String ussdRequest, ResultReceiver wrappedCallback) {
    if (!isPhoneTypeGsm() || mPendingMMIs.size() > 0) {
        // todo: replace the generic failure with specific error code.
        sendUssdResponse(ussdRequest, null, TelephonyManager.USSD_RETURN_FAILURE, wrappedCallback);
        return true;
    }
    // Try over IMS if possible.
    Phone imsPhone = mImsPhone;
    if ((imsPhone != null) && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) || imsPhone.isUtEnabled())) {
        try {
            logd("handleUssdRequest: attempting over IMS");
            return imsPhone.handleUssdRequest(ussdRequest, wrappedCallback);
        } catch (CallStateException cse) {
            if (!CS_FALLBACK.equals(cse.getMessage())) {
                return false;
            }
            // At this point we've tried over IMS but have been informed we need to handover
            // back to GSM.
            logd("handleUssdRequest: fallback to CS required");
        }
    }
    // Try USSD over GSM.
    try {
        dialInternal(ussdRequest, new DialArgs.Builder<>().build(), wrappedCallback);
    } catch (Exception e) {
        logd("handleUssdRequest: exception" + e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public String getVoiceMailNumber() {
    String number = null;
    if (isPhoneTypeGsm()) {
        // Read from the SIM. If its null, try reading from the shared preference area.
        IccRecords r = mIccRecords.get();
        number = (r != null) ? r.getVoiceMailNumber() : "";
        if (TextUtils.isEmpty(number)) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
            number = sp.getString(VM_NUMBER + getPhoneId(), null);
        }
    } else {
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        number = sp.getString(VM_NUMBER_CDMA + getPhoneId(), null);
    }
    if (TextUtils.isEmpty(number)) {
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null) {
            String defaultVmNumber = b.getString(CarrierConfigManager.KEY_DEFAULT_VM_NUMBER_STRING);
            if (!TextUtils.isEmpty(defaultVmNumber)) {
                number = defaultVmNumber;
            }
        }
    }
    if (!isPhoneTypeGsm() && TextUtils.isEmpty(number)) {
        // Read platform settings for dynamic voicemail number
        if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_telephony_use_own_number_for_voicemail)) {
            number = getLine1Number();
        } else {
            number = "*86";
        }
    }
    return number;
}
#method_after
@Override
public String getVoiceMailNumber() {
    String number = null;
    if (isPhoneTypeGsm()) {
        // Read from the SIM. If its null, try reading from the shared preference area.
        IccRecords r = mIccRecords.get();
        number = (r != null) ? r.getVoiceMailNumber() : "";
        if (TextUtils.isEmpty(number)) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
            number = sp.getString(VM_NUMBER + getPhoneId(), null);
        }
    } else {
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        number = sp.getString(VM_NUMBER_CDMA + getPhoneId(), null);
    }
    if (TextUtils.isEmpty(number)) {
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null) {
            String defaultVmNumber = b.getString(CarrierConfigManager.KEY_DEFAULT_VM_NUMBER_STRING);
            if (!TextUtils.isEmpty(defaultVmNumber)) {
                number = defaultVmNumber;
            }
        }
    }
    if (!isPhoneTypeGsm() && TextUtils.isEmpty(number)) {
        // Read platform settings for dynamic voicemail number
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null && b.getBoolean(CarrierConfigManager.KEY_CONFIG_TELEPHONY_USE_OWN_NUMBER_FOR_VOICEMAIL_BOOL)) {
            number = getLine1Number();
        } else {
            number = "*86";
        }
    }
    return number;
}
#end_block

#method_before
@Override
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    return CarrierInfoManager.getCarrierInfoForImsiEncryption(keyType);
}
#method_after
@Override
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    return CarrierInfoManager.getCarrierInfoForImsiEncryption(keyType, mContext);
}
#end_block

#method_before
@Override
public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
    CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo);
}
#method_after
@Override
public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
    CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, mContext);
}
#end_block

#method_before
@Override
public String getSystemProperty(String property, String defValue) {
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        if (getUnitTestMode()) {
            return null;
        }
        return TelephonyManager.getTelephonyProperty(mPhoneId, property, defValue);
    } else {
        return super.getSystemProperty(property, defValue);
    }
}
#method_after
@Override
public String getSystemProperty(String property, String defValue) {
    if (getUnitTestMode()) {
        return null;
    }
    return TelephonyManager.getTelephonyProperty(mPhoneId, property, defValue);
}
#end_block

#method_before
@Override
public void getOutgoingCallerIdDisplay(Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
            imsPhone.getOutgoingCallerIdDisplay(onComplete);
            return;
        }
        mCi.getCLIR(onComplete);
    } else {
        loge("getOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#method_after
@Override
public void getOutgoingCallerIdDisplay(Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) || imsPhone.isUtEnabled())) {
            imsPhone.getOutgoingCallerIdDisplay(onComplete);
            return;
        }
        mCi.getCLIR(onComplete);
    } else {
        loge("getOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#end_block

#method_before
@Override
public void setOutgoingCallerIdDisplay(int commandInterfaceCLIRMode, Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
            imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, onComplete);
            return;
        }
        // Packing CLIR value in the message. This will be required for
        // SharedPreference caching, if the message comes back as part of
        // a success response.
        mCi.setCLIR(commandInterfaceCLIRMode, obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode, 0, onComplete));
    } else {
        loge("setOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#method_after
@Override
public void setOutgoingCallerIdDisplay(int commandInterfaceCLIRMode, Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) || imsPhone.isUtEnabled())) {
            imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, onComplete);
            return;
        }
        // Packing CLIR value in the message. This will be required for
        // SharedPreference caching, if the message comes back as part of
        // a success response.
        mCi.setCLIR(commandInterfaceCLIRMode, obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode, 0, onComplete));
    } else {
        loge("setOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_MODEM_RESET:
            {
                logd("Event EVENT_MODEM_RESET Received" + " isInEcm = " + isInEcm() + " isPhoneTypeGsm = " + isPhoneTypeGsm() + " mImsPhone = " + mImsPhone);
                if (isInEcm()) {
                    if (isPhoneTypeGsm()) {
                        if (mImsPhone != null) {
                            mImsPhone.handleExitEmergencyCallbackMode();
                        }
                    } else {
                        handleExitEmergencyCallbackMode(msg);
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service
            ImsManager.updateImsServiceConfig(mContext, mPhoneId, true);
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            if (!isPhoneTypeGsm()) {
                mSST.pollState();
            }
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_MODEM_RESET:
            {
                logd("Event EVENT_MODEM_RESET Received" + " isInEcm = " + isInEcm() + " isPhoneTypeGsm = " + isPhoneTypeGsm() + " mImsPhone = " + mImsPhone);
                if (isInEcm()) {
                    if (isPhoneTypeGsm()) {
                        if (mImsPhone != null) {
                            mImsPhone.handleExitEmergencyCallbackMode();
                        }
                    } else {
                        handleExitEmergencyCallbackMode(msg);
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service if it is available, if it isn't the config will be
            // updated when ImsPhoneCallTracker opens a connection.
            ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
            if (imsManager.isServiceAvailable()) {
                imsManager.updateImsServiceConfig(true);
            } else {
                logd("ImsManager is not available to update CarrierConfig.");
            }
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            if (!isPhoneTypeGsm()) {
                mSST.pollState();
            }
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#end_block

#method_before
@Override
protected void onUpdateIccAvailability() {
    if (mUiccController == null) {
        return;
    }
    UiccCardApplication newUiccApplication = null;
    // Update mIsimUiccRecords
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_IMS);
        IsimUiccRecords newIsimUiccRecords = null;
        if (newUiccApplication != null) {
            newIsimUiccRecords = (IsimUiccRecords) newUiccApplication.getIccRecords();
            if (DBG)
                logd("New ISIM application found");
        }
        mIsimUiccRecords = newIsimUiccRecords;
    }
    // Update mSimRecords
    if (mSimRecords != null) {
        mSimRecords.unregisterForRecordsLoaded(this);
    }
    if (isPhoneTypeCdmaLte()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
        SIMRecords newSimRecords = null;
        if (newUiccApplication != null) {
            newSimRecords = (SIMRecords) newUiccApplication.getIccRecords();
        }
        mSimRecords = newSimRecords;
        if (mSimRecords != null) {
            mSimRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
    } else {
        mSimRecords = null;
    }
    // Update mIccRecords, mUiccApplication, mIccPhoneBookIntManager
    newUiccApplication = getUiccCardApplication();
    if (!isPhoneTypeGsm() && newUiccApplication == null) {
        logd("can't find 3GPP2 application; trying APP_FAM_3GPP");
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
    }
    UiccCardApplication app = mUiccApplication.get();
    if (app != newUiccApplication) {
        if (app != null) {
            if (DBG)
                logd("Removing stale icc objects.");
            if (mIccRecords.get() != null) {
                unregisterForIccRecordEvents();
                mIccPhoneBookIntManager.updateIccRecords(null);
            }
            mIccRecords.set(null);
            mUiccApplication.set(null);
        }
        if (newUiccApplication != null) {
            if (DBG) {
                logd("New Uicc application found. type = " + newUiccApplication.getType());
            }
            mUiccApplication.set(newUiccApplication);
            mIccRecords.set(newUiccApplication.getIccRecords());
            registerForIccRecordEvents();
            mIccPhoneBookIntManager.updateIccRecords(mIccRecords.get());
        }
    }
}
#method_after
// todo: check if ICC availability needs to be handled here. mSimRecords should not be needed
// now because APIs can be called directly on UiccProfile, and that should handle the requests
@Override
protected void onUpdateIccAvailability() {
    if (mUiccController == null) {
        return;
    }
    UiccCardApplication newUiccApplication = null;
    // Update mIsimUiccRecords
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_IMS);
        IsimUiccRecords newIsimUiccRecords = null;
        if (newUiccApplication != null) {
            newIsimUiccRecords = (IsimUiccRecords) newUiccApplication.getIccRecords();
            if (DBG)
                logd("New ISIM application found");
        }
        mIsimUiccRecords = newIsimUiccRecords;
    }
    // Update mSimRecords
    if (mSimRecords != null) {
        mSimRecords.unregisterForRecordsLoaded(this);
    }
    if (isPhoneTypeCdmaLte() || isPhoneTypeCdma()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
        SIMRecords newSimRecords = null;
        if (newUiccApplication != null) {
            newSimRecords = (SIMRecords) newUiccApplication.getIccRecords();
        }
        mSimRecords = newSimRecords;
        if (mSimRecords != null) {
            mSimRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
    } else {
        mSimRecords = null;
    }
    // Update mIccRecords, mUiccApplication, mIccPhoneBookIntManager
    newUiccApplication = getUiccCardApplication();
    if (!isPhoneTypeGsm() && newUiccApplication == null) {
        logd("can't find 3GPP2 application; trying APP_FAM_3GPP");
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
    }
    UiccCardApplication app = mUiccApplication.get();
    if (app != newUiccApplication) {
        if (app != null) {
            if (DBG)
                logd("Removing stale icc objects.");
            if (mIccRecords.get() != null) {
                unregisterForIccRecordEvents();
                mIccPhoneBookIntManager.updateIccRecords(null);
            }
            mIccRecords.set(null);
            mUiccApplication.set(null);
        }
        if (newUiccApplication != null) {
            if (DBG) {
                logd("New Uicc application found. type = " + newUiccApplication.getType());
            }
            mUiccApplication.set(newUiccApplication);
            mIccRecords.set(newUiccApplication.getIccRecords());
            registerForIccRecordEvents();
            mIccPhoneBookIntManager.updateIccRecords(mIccRecords.get());
        }
    }
}
#end_block

#method_before
@Override
public boolean updateCurrentCarrierInProvider() {
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        long currentDds = SubscriptionManager.getDefaultDataSubscriptionId();
        String operatorNumeric = getOperatorNumeric();
        logd("updateCurrentCarrierInProvider: mSubId = " + getSubId() + " currentDds = " + currentDds + " operatorNumeric = " + operatorNumeric);
        if (!TextUtils.isEmpty(operatorNumeric) && (getSubId() == currentDds)) {
            try {
                Uri uri = Uri.withAppendedPath(Telephony.Carriers.CONTENT_URI, "current");
                ContentValues map = new ContentValues();
                map.put(Telephony.Carriers.NUMERIC, operatorNumeric);
                mContext.getContentResolver().insert(uri, map);
                return true;
            } catch (SQLException e) {
                Rlog.e(LOG_TAG, "Can't store current operator", e);
            }
        }
        return false;
    } else {
        return true;
    }
}
#method_after
@Override
public boolean updateCurrentCarrierInProvider() {
    long currentDds = SubscriptionManager.getDefaultDataSubscriptionId();
    String operatorNumeric = getOperatorNumeric();
    logd("updateCurrentCarrierInProvider: mSubId = " + getSubId() + " currentDds = " + currentDds + " operatorNumeric = " + operatorNumeric);
    if (!TextUtils.isEmpty(operatorNumeric) && (getSubId() == currentDds)) {
        try {
            Uri uri = Uri.withAppendedPath(Telephony.Carriers.CONTENT_URI, "current");
            ContentValues map = new ContentValues();
            map.put(Telephony.Carriers.NUMERIC, operatorNumeric);
            mContext.getContentResolver().insert(uri, map);
            return true;
        } catch (SQLException e) {
            Rlog.e(LOG_TAG, "Can't store current operator", e);
        }
    }
    return false;
}
#end_block

#method_before
private void phoneObjectUpdater(int newVoiceRadioTech) {
    logd("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech);
    // Check for a voice over lte replacement
    if (ServiceState.isLte(newVoiceRadioTech) || (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
        CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configMgr.getConfigForSubId(getSubId());
        if (b != null) {
            int volteReplacementRat = b.getInt(CarrierConfigManager.KEY_VOLTE_REPLACEMENT_RAT_INT);
            logd("phoneObjectUpdater: volteReplacementRat=" + volteReplacementRat);
            if (volteReplacementRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
                newVoiceRadioTech = volteReplacementRat;
            }
        } else {
            loge("phoneObjectUpdater: didn't get volteReplacementRat from carrier config");
        }
    }
    if (mRilVersion == 6 && getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
        /*
             * On v6 RIL, when LTE_ON_CDMA is TRUE, always create CDMALTEPhone
             * irrespective of the voice radio tech reported.
             */
        if (getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
            logd("phoneObjectUpdater: LTE ON CDMA property is set. Use CDMA Phone" + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            return;
        } else {
            logd("phoneObjectUpdater: LTE ON CDMA property is set. Switch to CDMALTEPhone" + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            newVoiceRadioTech = ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT;
        }
    } else {
        // which might send unnecessary attach request to the modem.
        if (isShuttingDown()) {
            logd("Device is shutting down. No need to switch phone now.");
            return;
        }
        boolean matchCdma = ServiceState.isCdma(newVoiceRadioTech);
        boolean matchGsm = ServiceState.isGsm(newVoiceRadioTech);
        if ((matchCdma && getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) || (matchGsm && getPhoneType() == PhoneConstants.PHONE_TYPE_GSM)) {
            // Nothing changed. Keep phone as it is.
            logd("phoneObjectUpdater: No change ignore," + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            return;
        }
        if (!matchCdma && !matchGsm) {
            loge("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech + " doesn't match either CDMA or GSM - error! No phone change");
            return;
        }
    }
    if (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
        // We need some voice phone object to be active always, so never
        // delete the phone without anything to replace it with!
        logd("phoneObjectUpdater: Unknown rat ignore, " + " newVoiceRadioTech=Unknown. mActivePhone=" + getPhoneName());
        return;
    }
    // old power state to off
    boolean oldPowerState = false;
    if (mResetModemOnRadioTechnologyChange) {
        if (mCi.getRadioState().isOn()) {
            oldPowerState = true;
            logd("phoneObjectUpdater: Setting Radio Power to Off");
            mCi.setRadioPower(false, null);
        }
    }
    switchVoiceRadioTech(newVoiceRadioTech);
    if (mResetModemOnRadioTechnologyChange && oldPowerState) {
        // restore power state
        logd("phoneObjectUpdater: Resetting Radio");
        mCi.setRadioPower(oldPowerState, null);
    }
    // update voice radio tech in icc card proxy
    mIccCardProxy.setVoiceRadioTech(newVoiceRadioTech);
    // Send an Intent to the PhoneApp that we had a radio technology change
    Intent intent = new Intent(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED);
    intent.putExtra(PhoneConstants.PHONE_NAME_KEY, getPhoneName());
    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhoneId);
    ActivityManager.broadcastStickyIntent(intent, UserHandle.USER_ALL);
}
#method_after
private void phoneObjectUpdater(int newVoiceRadioTech) {
    logd("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech);
    // Check for a voice over lte replacement
    if (ServiceState.isLte(newVoiceRadioTech) || (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
        CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configMgr.getConfigForSubId(getSubId());
        if (b != null) {
            int volteReplacementRat = b.getInt(CarrierConfigManager.KEY_VOLTE_REPLACEMENT_RAT_INT);
            logd("phoneObjectUpdater: volteReplacementRat=" + volteReplacementRat);
            if (volteReplacementRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
                newVoiceRadioTech = volteReplacementRat;
            }
        } else {
            loge("phoneObjectUpdater: didn't get volteReplacementRat from carrier config");
        }
    }
    if (mRilVersion == 6 && getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
        /*
             * On v6 RIL, when LTE_ON_CDMA is TRUE, always create CDMALTEPhone
             * irrespective of the voice radio tech reported.
             */
        if (getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
            logd("phoneObjectUpdater: LTE ON CDMA property is set. Use CDMA Phone" + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            return;
        } else {
            logd("phoneObjectUpdater: LTE ON CDMA property is set. Switch to CDMALTEPhone" + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            newVoiceRadioTech = ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT;
        }
    } else {
        // which might send unnecessary attach request to the modem.
        if (isShuttingDown()) {
            logd("Device is shutting down. No need to switch phone now.");
            return;
        }
        boolean matchCdma = ServiceState.isCdma(newVoiceRadioTech);
        boolean matchGsm = ServiceState.isGsm(newVoiceRadioTech);
        if ((matchCdma && getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) || (matchGsm && getPhoneType() == PhoneConstants.PHONE_TYPE_GSM)) {
            // Nothing changed. Keep phone as it is.
            logd("phoneObjectUpdater: No change ignore," + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            return;
        }
        if (!matchCdma && !matchGsm) {
            loge("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech + " doesn't match either CDMA or GSM - error! No phone change");
            return;
        }
    }
    if (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
        // We need some voice phone object to be active always, so never
        // delete the phone without anything to replace it with!
        logd("phoneObjectUpdater: Unknown rat ignore, " + " newVoiceRadioTech=Unknown. mActivePhone=" + getPhoneName());
        return;
    }
    // old power state to off
    boolean oldPowerState = false;
    if (mResetModemOnRadioTechnologyChange) {
        if (mCi.getRadioState().isOn()) {
            oldPowerState = true;
            logd("phoneObjectUpdater: Setting Radio Power to Off");
            mCi.setRadioPower(false, null);
        }
    }
    switchVoiceRadioTech(newVoiceRadioTech);
    if (mResetModemOnRadioTechnologyChange && oldPowerState) {
        // restore power state
        logd("phoneObjectUpdater: Resetting Radio");
        mCi.setRadioPower(oldPowerState, null);
    }
    // update voice radio tech in UiccProfile
    UiccProfile uiccProfile = getUiccProfile();
    if (uiccProfile != null) {
        uiccProfile.setVoiceRadioTech(newVoiceRadioTech);
    }
    // Send an Intent to the PhoneApp that we had a radio technology change
    Intent intent = new Intent(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED);
    intent.putExtra(PhoneConstants.PHONE_NAME_KEY, getPhoneName());
    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhoneId);
    ActivityManager.broadcastStickyIntent(intent, UserHandle.USER_ALL);
}
#end_block

#method_before
private void switchVoiceRadioTech(int newVoiceRadioTech) {
    String outgoingPhoneName = getPhoneName();
    logd("Switching Voice Phone : " + outgoingPhoneName + " >>> " + (ServiceState.isGsm(newVoiceRadioTech) ? "GSM" : "CDMA"));
    if (ServiceState.isCdma(newVoiceRadioTech)) {
        switchPhoneType(PhoneConstants.PHONE_TYPE_CDMA_LTE);
    } else if (ServiceState.isGsm(newVoiceRadioTech)) {
        switchPhoneType(PhoneConstants.PHONE_TYPE_GSM);
    } else {
        loge("deleteAndCreatePhone: newVoiceRadioTech=" + newVoiceRadioTech + " is not CDMA or GSM (error) - aborting!");
        return;
    }
}
#method_after
private void switchVoiceRadioTech(int newVoiceRadioTech) {
    String outgoingPhoneName = getPhoneName();
    logd("Switching Voice Phone : " + outgoingPhoneName + " >>> " + (ServiceState.isGsm(newVoiceRadioTech) ? "GSM" : "CDMA"));
    if (ServiceState.isCdma(newVoiceRadioTech)) {
        UiccCardApplication cdmaApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP2);
        if (cdmaApplication != null && cdmaApplication.getType() == AppType.APPTYPE_RUIM) {
            switchPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
        } else {
            switchPhoneType(PhoneConstants.PHONE_TYPE_CDMA_LTE);
        }
    } else if (ServiceState.isGsm(newVoiceRadioTech)) {
        switchPhoneType(PhoneConstants.PHONE_TYPE_GSM);
    } else {
        loge("deleteAndCreatePhone: newVoiceRadioTech=" + newVoiceRadioTech + " is not CDMA or GSM (error) - aborting!");
        return;
    }
}
#end_block

#method_before
@Override
public boolean getIccRecordsLoaded() {
    return mIccCardProxy.getIccRecordsLoaded();
}
#method_after
@Override
public boolean getIccRecordsLoaded() {
    UiccProfile uiccProfile = getUiccProfile();
    return uiccProfile != null && uiccProfile.getIccRecordsLoaded();
}
#end_block

#method_before
@Override
public IccCard getIccCard() {
    return mIccCardProxy;
}
#method_after
@Override
public IccCard getIccCard() {
    return UiccController.getInstance().getUiccProfileForPhone(mPhoneId);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("GsmCdmaPhone extends:");
    super.dump(fd, pw, args);
    pw.println(" mPrecisePhoneType=" + mPrecisePhoneType);
    pw.println(" mCT=" + mCT);
    pw.println(" mSST=" + mSST);
    pw.println(" mPendingMMIs=" + mPendingMMIs);
    pw.println(" mIccPhoneBookIntManager=" + mIccPhoneBookIntManager);
    if (VDBG)
        pw.println(" mImei=" + mImei);
    if (VDBG)
        pw.println(" mImeiSv=" + mImeiSv);
    if (VDBG)
        pw.println(" mVmNumber=" + mVmNumber);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mCdmaSubscriptionSource=" + mCdmaSubscriptionSource);
    pw.println(" mEriManager=" + mEriManager);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" isInEcm()=" + isInEcm());
    if (VDBG)
        pw.println(" mEsn=" + mEsn);
    if (VDBG)
        pw.println(" mMeid=" + mMeid);
    pw.println(" mCarrierOtaSpNumSchema=" + mCarrierOtaSpNumSchema);
    if (!isPhoneTypeGsm()) {
        pw.println(" getCdmaEriIconIndex()=" + getCdmaEriIconIndex());
        pw.println(" getCdmaEriIconMode()=" + getCdmaEriIconMode());
        pw.println(" getCdmaEriText()=" + getCdmaEriText());
        pw.println(" isMinInfoReady()=" + isMinInfoReady());
    }
    pw.println(" isCspPlmnEnabled()=" + isCspPlmnEnabled());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    try {
        mIccCardProxy.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("DeviceStateMonitor:");
    mDeviceStateMonitor.dump(fd, pw, args);
    pw.println("++++++++++++++++++++++++++++++++");
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("GsmCdmaPhone extends:");
    super.dump(fd, pw, args);
    pw.println(" mPrecisePhoneType=" + mPrecisePhoneType);
    pw.println(" mCT=" + mCT);
    pw.println(" mSST=" + mSST);
    pw.println(" mPendingMMIs=" + mPendingMMIs);
    pw.println(" mIccPhoneBookIntManager=" + mIccPhoneBookIntManager);
    if (VDBG)
        pw.println(" mImei=" + mImei);
    if (VDBG)
        pw.println(" mImeiSv=" + mImeiSv);
    if (VDBG)
        pw.println(" mVmNumber=" + mVmNumber);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mCdmaSubscriptionSource=" + mCdmaSubscriptionSource);
    pw.println(" mEriManager=" + mEriManager);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" isInEcm()=" + isInEcm());
    if (VDBG)
        pw.println(" mEsn=" + mEsn);
    if (VDBG)
        pw.println(" mMeid=" + mMeid);
    pw.println(" mCarrierOtaSpNumSchema=" + mCarrierOtaSpNumSchema);
    if (!isPhoneTypeGsm()) {
        pw.println(" getCdmaEriIconIndex()=" + getCdmaEriIconIndex());
        pw.println(" getCdmaEriIconMode()=" + getCdmaEriIconMode());
        pw.println(" getCdmaEriText()=" + getCdmaEriText());
        pw.println(" isMinInfoReady()=" + isMinInfoReady());
    }
    pw.println(" isCspPlmnEnabled()=" + isCspPlmnEnabled());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("DeviceStateMonitor:");
    mDeviceStateMonitor.dump(fd, pw, args);
    pw.println("++++++++++++++++++++++++++++++++");
}
#end_block

#method_before
private String getOperatorNumeric() {
    String operatorNumeric = null;
    if (isPhoneTypeGsm()) {
        IccRecords r = mIccRecords.get();
        if (r != null) {
            operatorNumeric = r.getOperatorNumeric();
        }
    } else {
        // isPhoneTypeCdmaLte()
        IccRecords curIccRecords = null;
        if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_NV) {
            operatorNumeric = SystemProperties.get("ro.cdma.home.operator.numeric");
        } else if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_RUIM_SIM) {
            curIccRecords = mSimRecords;
            if (curIccRecords != null) {
                operatorNumeric = curIccRecords.getOperatorNumeric();
            } else {
                curIccRecords = mIccRecords.get();
                if (curIccRecords != null && (curIccRecords instanceof RuimRecords)) {
                    RuimRecords csim = (RuimRecords) curIccRecords;
                    operatorNumeric = csim.getRUIMOperatorNumeric();
                }
            }
        }
        if (operatorNumeric == null) {
            loge("getOperatorNumeric: Cannot retrieve operatorNumeric:" + " mCdmaSubscriptionSource = " + mCdmaSubscriptionSource + " mIccRecords = " + ((curIccRecords != null) ? curIccRecords.getRecordsLoaded() : null));
        }
        logd("getOperatorNumeric: mCdmaSubscriptionSource = " + mCdmaSubscriptionSource + " operatorNumeric = " + operatorNumeric);
    }
    return operatorNumeric;
}
#method_after
private String getOperatorNumeric() {
    String operatorNumeric = null;
    if (isPhoneTypeGsm()) {
        IccRecords r = mIccRecords.get();
        if (r != null) {
            operatorNumeric = r.getOperatorNumeric();
        }
    } else {
        // isPhoneTypeCdmaLte()
        IccRecords curIccRecords = null;
        if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_NV) {
            operatorNumeric = SystemProperties.get("ro.cdma.home.operator.numeric");
        } else if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_RUIM_SIM) {
            UiccCardApplication uiccCardApplication = mUiccApplication.get();
            if (uiccCardApplication != null && uiccCardApplication.getType() == AppType.APPTYPE_RUIM) {
                logd("Legacy RUIM app present");
                curIccRecords = mIccRecords.get();
            } else {
                // Use sim-records for SimApp, USimApp, CSimApp and ISimApp.
                curIccRecords = mSimRecords;
            }
            if (curIccRecords != null && curIccRecords == mSimRecords) {
                operatorNumeric = curIccRecords.getOperatorNumeric();
            } else {
                curIccRecords = mIccRecords.get();
                if (curIccRecords != null && (curIccRecords instanceof RuimRecords)) {
                    RuimRecords csim = (RuimRecords) curIccRecords;
                    operatorNumeric = csim.getRUIMOperatorNumeric();
                }
            }
        }
        if (operatorNumeric == null) {
            loge("getOperatorNumeric: Cannot retrieve operatorNumeric:" + " mCdmaSubscriptionSource = " + mCdmaSubscriptionSource + " mIccRecords = " + ((curIccRecords != null) ? curIccRecords.getRecordsLoaded() : null));
        }
        logd("getOperatorNumeric: mCdmaSubscriptionSource = " + mCdmaSubscriptionSource + " operatorNumeric = " + operatorNumeric);
    }
    return operatorNumeric;
}
#end_block

#method_before
private void logd(String s) {
    Rlog.d(LOG_TAG, "[GsmCdmaPhone][" + getPhoneId() + "] " + s);
}
#method_after
private void logd(String s) {
    Rlog.d(LOG_TAG, "[" + mPhoneId + "] " + s);
}
#end_block

#method_before
private void logi(String s) {
    Rlog.i(LOG_TAG, "[GsmCdmaPhone][" + getPhoneId() + "] " + s);
}
#method_after
private void logi(String s) {
    Rlog.i(LOG_TAG, "[" + mPhoneId + "] " + s);
}
#end_block

#method_before
private void loge(String s) {
    Rlog.e(LOG_TAG, "[GsmCdmaPhone][" + getPhoneId() + "] " + s);
}
#method_after
private void loge(String s) {
    Rlog.e(LOG_TAG, "[" + mPhoneId + "] " + s);
}
#end_block

#method_before
@Override
public boolean handleUssdRequest(String ussdRequest, ResultReceiver wrappedCallback) throws CallStateException {
    if (mPendingMMIs.size() > 0) {
        // There are MMI codes in progress; fail attempt now.
        logi("handleUssdRequest: queue full: " + Rlog.pii(LOG_TAG, ussdRequest));
        sendUssdResponse(ussdRequest, null, TelephonyManager.USSD_RETURN_FAILURE, wrappedCallback);
        return true;
    }
    try {
        dialInternal(ussdRequest, VideoProfile.STATE_AUDIO_ONLY, null, wrappedCallback);
    } catch (CallStateException cse) {
        if (CS_FALLBACK.equals(cse.getMessage())) {
            throw cse;
        } else {
            Rlog.w(LOG_TAG, "Could not execute USSD " + cse);
            sendUssdResponse(ussdRequest, null, TelephonyManager.USSD_RETURN_FAILURE, wrappedCallback);
        }
    } catch (Exception e) {
        Rlog.w(LOG_TAG, "Could not execute USSD " + e);
        sendUssdResponse(ussdRequest, null, TelephonyManager.USSD_RETURN_FAILURE, wrappedCallback);
        return false;
    }
    return true;
}
#method_after
@Override
public boolean handleUssdRequest(String ussdRequest, ResultReceiver wrappedCallback) throws CallStateException {
    if (mPendingMMIs.size() > 0) {
        // There are MMI codes in progress; fail attempt now.
        logi("handleUssdRequest: queue full: " + Rlog.pii(LOG_TAG, ussdRequest));
        sendUssdResponse(ussdRequest, null, TelephonyManager.USSD_RETURN_FAILURE, wrappedCallback);
        return true;
    }
    try {
        dialInternal(ussdRequest, new ImsDialArgs.Builder().build(), wrappedCallback);
    } catch (CallStateException cse) {
        if (CS_FALLBACK.equals(cse.getMessage())) {
            throw cse;
        } else {
            Rlog.w(LOG_TAG, "Could not execute USSD " + cse);
            sendUssdResponse(ussdRequest, null, TelephonyManager.USSD_RETURN_FAILURE, wrappedCallback);
        }
    } catch (Exception e) {
        Rlog.w(LOG_TAG, "Could not execute USSD " + e);
        sendUssdResponse(ussdRequest, null, TelephonyManager.USSD_RETURN_FAILURE, wrappedCallback);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    // ignore UUSInfo
    return dialInternal(dialString, videoState, intentExtras, null);
}
#method_after
@Override
public Connection dial(String dialString, DialArgs dialArgs) throws CallStateException {
    return dialInternal(dialString, dialArgs, null);
}
#end_block

#method_before
private Connection dialInternal(String dialString, int videoState, Bundle intentExtras, ResultReceiver wrappedCallback) throws CallStateException {
    // Need to make sure dialString gets parsed properly
    String newDialString = PhoneNumberUtils.stripSeparators(dialString);
    // handle in-call MMI first if applicable
    if (handleInCallMmiCommands(newDialString)) {
        return null;
    }
    if (mDefaultPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
        return mCT.dial(dialString, videoState, intentExtras);
    }
    // Only look at the Network portion for mmi
    String networkPortion = PhoneNumberUtils.extractNetworkPortionAlt(newDialString);
    ImsPhoneMmiCode mmi = ImsPhoneMmiCode.newFromDialString(networkPortion, this, wrappedCallback);
    if (DBG)
        logd("dialInternal: dialing w/ mmi '" + mmi + "'...");
    if (mmi == null) {
        return mCT.dial(dialString, videoState, intentExtras);
    } else if (mmi.isTemporaryModeCLIR()) {
        return mCT.dial(mmi.getDialingNumber(), mmi.getCLIRMode(), videoState, intentExtras);
    } else if (!mmi.isSupportedOverImsPhone()) {
        // If the mmi is not supported by IMS service,
        // try to initiate dialing with default phone
        // Note: This code is never reached; there is a bug in isSupportedOverImsPhone which
        // causes it to return true even though the "processCode" method ultimately throws the
        // exception.
        logi("dialInternal: USSD not supported by IMS; fallback to CS.");
        throw new CallStateException(CS_FALLBACK);
    } else {
        mPendingMMIs.add(mmi);
        mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
        try {
            mmi.processCode();
        } catch (CallStateException cse) {
            if (CS_FALLBACK.equals(cse.getMessage())) {
                logi("dialInternal: fallback to GSM required.");
                // Make sure we remove from the list of pending MMIs since it will handover to
                // GSM.
                mPendingMMIs.remove(mmi);
                throw cse;
            }
        }
        return null;
    }
}
#method_after
private Connection dialInternal(String dialString, DialArgs dialArgs, ResultReceiver wrappedCallback) throws CallStateException {
    // Need to make sure dialString gets parsed properly
    String newDialString = PhoneNumberUtils.stripSeparators(dialString);
    // handle in-call MMI first if applicable
    if (handleInCallMmiCommands(newDialString)) {
        return null;
    }
    ImsDialArgs.Builder imsDialArgsBuilder;
    // Get the CLIR info if needed
    if (!(dialArgs instanceof ImsDialArgs)) {
        imsDialArgsBuilder = ImsDialArgs.Builder.from(dialArgs);
    } else {
        imsDialArgsBuilder = ImsDialArgs.Builder.from((ImsDialArgs) dialArgs);
    }
    imsDialArgsBuilder.setClirMode(mCT.getClirMode());
    if (mDefaultPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
        return mCT.dial(dialString, imsDialArgsBuilder.build());
    }
    // Only look at the Network portion for mmi
    String networkPortion = PhoneNumberUtils.extractNetworkPortionAlt(newDialString);
    ImsPhoneMmiCode mmi = ImsPhoneMmiCode.newFromDialString(networkPortion, this, wrappedCallback);
    if (DBG)
        logd("dialInternal: dialing w/ mmi '" + mmi + "'...");
    if (mmi == null) {
        return mCT.dial(dialString, imsDialArgsBuilder.build());
    } else if (mmi.isTemporaryModeCLIR()) {
        imsDialArgsBuilder.setClirMode(mmi.getCLIRMode());
        return mCT.dial(dialString, imsDialArgsBuilder.build());
    } else if (!mmi.isSupportedOverImsPhone()) {
        // If the mmi is not supported by IMS service,
        // try to initiate dialing with default phone
        // Note: This code is never reached; there is a bug in isSupportedOverImsPhone which
        // causes it to return true even though the "processCode" method ultimately throws the
        // exception.
        logi("dialInternal: USSD not supported by IMS; fallback to CS.");
        throw new CallStateException(CS_FALLBACK);
    } else {
        mPendingMMIs.add(mmi);
        mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
        try {
            mmi.processCode();
        } catch (CallStateException cse) {
            if (CS_FALLBACK.equals(cse.getMessage())) {
                logi("dialInternal: fallback to GSM required.");
                // Make sure we remove from the list of pending MMIs since it will handover to
                // GSM.
                mPendingMMIs.remove(mmi);
                throw cse;
            }
        }
        return null;
    }
}
#end_block

#method_before
public void getCallBarring(String facility, Message onComplete) {
    if (DBG)
        logd("getCallBarring facility=" + facility);
    Message resp;
    resp = obtainMessage(EVENT_GET_CALL_BARRING_DONE, onComplete);
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        ut.queryCallBarring(getCBTypeFromFacility(facility), resp);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
public void getCallBarring(String facility, Message onComplete) {
    getCallBarring(facility, onComplete, CommandsInterface.SERVICE_CLASS_NONE);
}
#end_block

#method_before
public void getCallBarring(String facility, Message onComplete) {
    if (DBG)
        logd("getCallBarring facility=" + facility);
    Message resp;
    resp = obtainMessage(EVENT_GET_CALL_BARRING_DONE, onComplete);
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        ut.queryCallBarring(getCBTypeFromFacility(facility), resp);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
public void getCallBarring(String facility, Message onComplete, int serviceClass) {
    getCallBarring(facility, "", onComplete, serviceClass);
}
#end_block

#method_before
public void setCallBarring(String facility, boolean lockState, String password, Message onComplete) {
    if (DBG)
        logd("setCallBarring facility=" + facility + ", lockState=" + lockState);
    Message resp;
    resp = obtainMessage(EVENT_SET_CALL_BARRING_DONE, onComplete);
    int action;
    if (lockState) {
        action = CommandsInterface.CF_ACTION_ENABLE;
    } else {
        action = CommandsInterface.CF_ACTION_DISABLE;
    }
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        // password is not required with Ut interface
        ut.updateCallBarring(getCBTypeFromFacility(facility), action, resp, null);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
public void setCallBarring(String facility, boolean lockState, String password, Message onComplete) {
    setCallBarring(facility, lockState, password, onComplete, CommandsInterface.SERVICE_CLASS_NONE);
}
#end_block

#method_before
public void setCallBarring(String facility, boolean lockState, String password, Message onComplete) {
    if (DBG)
        logd("setCallBarring facility=" + facility + ", lockState=" + lockState);
    Message resp;
    resp = obtainMessage(EVENT_SET_CALL_BARRING_DONE, onComplete);
    int action;
    if (lockState) {
        action = CommandsInterface.CF_ACTION_ENABLE;
    } else {
        action = CommandsInterface.CF_ACTION_DISABLE;
    }
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        // password is not required with Ut interface
        ut.updateCallBarring(getCBTypeFromFacility(facility), action, resp, null);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#method_after
@Override
public void setCallBarring(String facility, boolean lockState, String password, Message onComplete, int serviceClass) {
    if (DBG) {
        logd("setCallBarring facility=" + facility + ", lockState=" + lockState + ", serviceClass = " + serviceClass);
    }
    Message resp;
    resp = obtainMessage(EVENT_SET_CALL_BARRING_DONE, onComplete);
    int action;
    if (lockState) {
        action = CommandsInterface.CF_ACTION_ENABLE;
    } else {
        action = CommandsInterface.CF_ACTION_DISABLE;
    }
    try {
        ImsUtInterface ut = mCT.getUtInterface();
        // password is not required with Ut interface
        ut.updateCallBarring(getCBTypeFromFacility(facility), action, resp, null, serviceClass);
    } catch (ImsException e) {
        sendErrorResponse(onComplete, e);
    }
}
#end_block

#method_before
private CommandException getCommandException(int code, String errorString) {
    logd("getCommandException code= " + code + ", errorString= " + errorString);
    CommandException.Error error = CommandException.Error.GENERIC_FAILURE;
    switch(code) {
        case ImsReasonInfo.CODE_UT_NOT_SUPPORTED:
            error = CommandException.Error.REQUEST_NOT_SUPPORTED;
            break;
        case ImsReasonInfo.CODE_UT_CB_PASSWORD_MISMATCH:
            error = CommandException.Error.PASSWORD_INCORRECT;
            break;
        case ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE:
            error = CommandException.Error.RADIO_NOT_AVAILABLE;
            break;
        case ImsReasonInfo.CODE_FDN_BLOCKED:
            error = CommandException.Error.FDN_CHECK_FAILURE;
        default:
            break;
    }
    return new CommandException(error, errorString);
}
#method_after
private CommandException getCommandException(int code, String errorString) {
    logd("getCommandException code= " + code + ", errorString= " + errorString);
    CommandException.Error error = CommandException.Error.GENERIC_FAILURE;
    switch(code) {
        case ImsReasonInfo.CODE_UT_NOT_SUPPORTED:
            error = CommandException.Error.REQUEST_NOT_SUPPORTED;
            break;
        case ImsReasonInfo.CODE_UT_CB_PASSWORD_MISMATCH:
            error = CommandException.Error.PASSWORD_INCORRECT;
            break;
        case ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE:
            error = CommandException.Error.RADIO_NOT_AVAILABLE;
            break;
        case ImsReasonInfo.CODE_FDN_BLOCKED:
            error = CommandException.Error.FDN_CHECK_FAILURE;
            break;
        case ImsReasonInfo.CODE_UT_SS_MODIFIED_TO_DIAL:
            error = CommandException.Error.SS_MODIFIED_TO_DIAL;
            break;
        case ImsReasonInfo.CODE_UT_SS_MODIFIED_TO_USSD:
            error = CommandException.Error.SS_MODIFIED_TO_USSD;
            break;
        case ImsReasonInfo.CODE_UT_SS_MODIFIED_TO_SS:
            error = CommandException.Error.SS_MODIFIED_TO_SS;
            break;
        case ImsReasonInfo.CODE_UT_SS_MODIFIED_TO_DIAL_VIDEO:
            error = CommandException.Error.SS_MODIFIED_TO_DIAL_VIDEO;
            break;
        default:
            break;
    }
    return new CommandException(error, errorString);
}
#end_block

#method_before
public void onMMIDone(ImsPhoneMmiCode mmi) {
    /* Only notify complete if it's on the pending list.
         * Otherwise, it's already been handled (eg, previously canceled).
         * The exception is cancellation of an incoming USSD-REQUEST, which is
         * not on the list.
         */
    logd("onMMIDone: mmi=" + mmi);
    if (mPendingMMIs.remove(mmi) || mmi.isUssdRequest()) {
        ResultReceiver receiverCallback = mmi.getUssdCallbackReceiver();
        if (receiverCallback != null) {
            int returnCode = (mmi.getState() == MmiCode.State.COMPLETE) ? TelephonyManager.USSD_RETURN_SUCCESS : TelephonyManager.USSD_RETURN_FAILURE;
            sendUssdResponse(mmi.getDialString(), mmi.getMessage(), returnCode, receiverCallback);
        } else {
            logv("onMMIDone: notifyRegistrants");
            mMmiCompleteRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
        }
    }
}
#method_after
public void onMMIDone(ImsPhoneMmiCode mmi) {
    /* Only notify complete if it's on the pending list.
         * Otherwise, it's already been handled (eg, previously canceled).
         * The exception is cancellation of an incoming USSD-REQUEST, which is
         * not on the list.
         */
    logd("onMMIDone: mmi=" + mmi);
    if (mPendingMMIs.remove(mmi) || mmi.isUssdRequest() || mmi.isSsInfo()) {
        ResultReceiver receiverCallback = mmi.getUssdCallbackReceiver();
        if (receiverCallback != null) {
            int returnCode = (mmi.getState() == MmiCode.State.COMPLETE) ? TelephonyManager.USSD_RETURN_SUCCESS : TelephonyManager.USSD_RETURN_FAILURE;
            sendUssdResponse(mmi.getDialString(), mmi.getMessage(), returnCode, receiverCallback);
        } else {
            logv("onMMIDone: notifyRegistrants");
            mMmiCompleteRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
        }
    }
}
#end_block

#method_before
private CallForwardInfo[] handleCfQueryResult(ImsCallForwardInfo[] infos) {
    CallForwardInfo[] cfInfos = null;
    if (infos != null && infos.length != 0) {
        cfInfos = new CallForwardInfo[infos.length];
    }
    IccRecords r = mDefaultPhone.getIccRecords();
    if (infos == null || infos.length == 0) {
        if (r != null) {
            // Assume the default is not active
            // Set unconditional CFF in SIM to false
            setVoiceCallForwardingFlag(r, 1, false, null);
        }
    } else {
        for (int i = 0, s = infos.length; i < s; i++) {
            if (infos[i].mCondition == ImsUtInterface.CDIV_CF_UNCONDITIONAL) {
                if (r != null) {
                    setVoiceCallForwardingFlag(r, 1, (infos[i].mStatus == 1), infos[i].mNumber);
                }
            }
            cfInfos[i] = getCallForwardInfo(infos[i]);
        }
    }
    return cfInfos;
}
#method_after
public CallForwardInfo[] handleCfQueryResult(ImsCallForwardInfo[] infos) {
    CallForwardInfo[] cfInfos = null;
    if (infos != null && infos.length != 0) {
        cfInfos = new CallForwardInfo[infos.length];
    }
    IccRecords r = mDefaultPhone.getIccRecords();
    if (infos == null || infos.length == 0) {
        if (r != null) {
            // Assume the default is not active
            // Set unconditional CFF in SIM to false
            setVoiceCallForwardingFlag(r, 1, false, null);
        }
    } else {
        for (int i = 0, s = infos.length; i < s; i++) {
            if (infos[i].mCondition == ImsUtInterface.CDIV_CF_UNCONDITIONAL) {
                if (r != null) {
                    setVoiceCallForwardingFlag(r, 1, (infos[i].mStatus == 1), infos[i].mNumber);
                }
            }
            cfInfos[i] = getCallForwardInfo(infos[i]);
        }
    }
    return cfInfos;
}
#end_block

#method_before
public void processDisconnectReason(ImsReasonInfo imsReasonInfo) {
    if (imsReasonInfo.mCode == imsReasonInfo.CODE_REGISTRATION_ERROR && imsReasonInfo.mExtraMessage != null) {
        // Suppress WFC Registration notifications if WFC is not enabled by the user.
        if (ImsManager.isWfcEnabledByUser(mContext)) {
            processWfcDisconnectForNotification(imsReasonInfo);
        }
    }
}
#method_after
public void processDisconnectReason(ImsReasonInfo imsReasonInfo) {
    if (imsReasonInfo.mCode == imsReasonInfo.CODE_REGISTRATION_ERROR && imsReasonInfo.mExtraMessage != null) {
        // Suppress WFC Registration notifications if WFC is not enabled by the user.
        if (ImsManager.getInstance(mContext, mPhoneId).isWfcEnabledByUser()) {
            processWfcDisconnectForNotification(imsReasonInfo);
        }
    }
}
#end_block

#method_before
// Processes an IMS disconnect cause for possible WFC registration errors and optionally
private void processWfcDisconnectForNotification(ImsReasonInfo imsReasonInfo) {
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        loge("processDisconnectReason: CarrierConfigManager is not ready");
        return;
    }
    PersistableBundle pb = configManager.getConfigForSubId(getSubId());
    if (pb == null) {
        loge("processDisconnectReason: no config for subId " + getSubId());
        return;
    }
    final String[] wfcOperatorErrorCodes = pb.getStringArray(CarrierConfigManager.KEY_WFC_OPERATOR_ERROR_CODES_STRING_ARRAY);
    if (wfcOperatorErrorCodes == null) {
        // no operator-specific error codes
        return;
    }
    final String[] wfcOperatorErrorAlertMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorAlertMessages);
    final String[] wfcOperatorErrorNotificationMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorNotificationMessages);
    for (int i = 0; i < wfcOperatorErrorCodes.length; i++) {
        String[] codes = wfcOperatorErrorCodes[i].split("\\|");
        if (codes.length != 2) {
            loge("Invalid carrier config: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        // Match error code.
        if (!imsReasonInfo.mExtraMessage.startsWith(codes[0])) {
            continue;
        }
        // If there is no delimiter at the end of error code string
        // then we need to verify that we are not matching partial code.
        // EXAMPLE: "REG9" must not match "REG99".
        // NOTE: Error code must not be empty.
        int codeStringLength = codes[0].length();
        char lastChar = codes[0].charAt(codeStringLength - 1);
        if (Character.isLetterOrDigit(lastChar)) {
            if (imsReasonInfo.mExtraMessage.length() > codeStringLength) {
                char nextChar = imsReasonInfo.mExtraMessage.charAt(codeStringLength);
                if (Character.isLetterOrDigit(nextChar)) {
                    continue;
                }
            }
        }
        final CharSequence title = mContext.getText(com.android.internal.R.string.wfcRegErrorTitle);
        int idx = Integer.parseInt(codes[1]);
        if (idx < 0 || idx >= wfcOperatorErrorAlertMessages.length || idx >= wfcOperatorErrorNotificationMessages.length) {
            loge("Invalid index: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        String messageAlert = imsReasonInfo.mExtraMessage;
        String messageNotification = imsReasonInfo.mExtraMessage;
        if (!wfcOperatorErrorAlertMessages[idx].isEmpty()) {
            messageAlert = String.format(wfcOperatorErrorAlertMessages[idx], // Fill IMS error code into alert message
            imsReasonInfo.mExtraMessage);
        }
        if (!wfcOperatorErrorNotificationMessages[idx].isEmpty()) {
            messageNotification = String.format(wfcOperatorErrorNotificationMessages[idx], // Fill IMS error code into notification
            imsReasonInfo.mExtraMessage);
        }
        // UX requirement is to disable WFC in case of "permanent" registration failures.
        ImsManager.setWfcSetting(mContext, false);
        // If WfcSettings are active then alert will be shown
        // otherwise notification will be added.
        Intent intent = new Intent(ImsManager.ACTION_IMS_REGISTRATION_ERROR);
        intent.putExtra(EXTRA_KEY_ALERT_TITLE, title);
        intent.putExtra(EXTRA_KEY_ALERT_MESSAGE, messageAlert);
        intent.putExtra(EXTRA_KEY_NOTIFICATION_MESSAGE, messageNotification);
        mContext.sendOrderedBroadcast(intent, null, mResultReceiver, null, Activity.RESULT_OK, null, null);
        // so should break the loop after a successful match.
        break;
    }
}
#method_after
// Processes an IMS disconnect cause for possible WFC registration errors and optionally
private void processWfcDisconnectForNotification(ImsReasonInfo imsReasonInfo) {
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        loge("processDisconnectReason: CarrierConfigManager is not ready");
        return;
    }
    PersistableBundle pb = configManager.getConfigForSubId(getSubId());
    if (pb == null) {
        loge("processDisconnectReason: no config for subId " + getSubId());
        return;
    }
    final String[] wfcOperatorErrorCodes = pb.getStringArray(CarrierConfigManager.KEY_WFC_OPERATOR_ERROR_CODES_STRING_ARRAY);
    if (wfcOperatorErrorCodes == null) {
        // no operator-specific error codes
        return;
    }
    final String[] wfcOperatorErrorAlertMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorAlertMessages);
    final String[] wfcOperatorErrorNotificationMessages = mContext.getResources().getStringArray(com.android.internal.R.array.wfcOperatorErrorNotificationMessages);
    for (int i = 0; i < wfcOperatorErrorCodes.length; i++) {
        String[] codes = wfcOperatorErrorCodes[i].split("\\|");
        if (codes.length != 2) {
            loge("Invalid carrier config: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        // Match error code.
        if (!imsReasonInfo.mExtraMessage.startsWith(codes[0])) {
            continue;
        }
        // If there is no delimiter at the end of error code string
        // then we need to verify that we are not matching partial code.
        // EXAMPLE: "REG9" must not match "REG99".
        // NOTE: Error code must not be empty.
        int codeStringLength = codes[0].length();
        char lastChar = codes[0].charAt(codeStringLength - 1);
        if (Character.isLetterOrDigit(lastChar)) {
            if (imsReasonInfo.mExtraMessage.length() > codeStringLength) {
                char nextChar = imsReasonInfo.mExtraMessage.charAt(codeStringLength);
                if (Character.isLetterOrDigit(nextChar)) {
                    continue;
                }
            }
        }
        final CharSequence title = mContext.getText(com.android.internal.R.string.wfcRegErrorTitle);
        int idx = Integer.parseInt(codes[1]);
        if (idx < 0 || idx >= wfcOperatorErrorAlertMessages.length || idx >= wfcOperatorErrorNotificationMessages.length) {
            loge("Invalid index: " + wfcOperatorErrorCodes[i]);
            continue;
        }
        String messageAlert = imsReasonInfo.mExtraMessage;
        String messageNotification = imsReasonInfo.mExtraMessage;
        if (!wfcOperatorErrorAlertMessages[idx].isEmpty()) {
            messageAlert = String.format(wfcOperatorErrorAlertMessages[idx], // Fill IMS error code into alert message
            imsReasonInfo.mExtraMessage);
        }
        if (!wfcOperatorErrorNotificationMessages[idx].isEmpty()) {
            messageNotification = String.format(wfcOperatorErrorNotificationMessages[idx], // Fill IMS error code into notification
            imsReasonInfo.mExtraMessage);
        }
        // UX requirement is to disable WFC in case of "permanent" registration failures.
        ImsManager.getInstance(mContext, mPhoneId).setWfcSetting(false);
        // If WfcSettings are active then alert will be shown
        // otherwise notification will be added.
        Intent intent = new Intent(ImsManager.ACTION_IMS_REGISTRATION_ERROR);
        intent.putExtra(EXTRA_KEY_ALERT_TITLE, title);
        intent.putExtra(EXTRA_KEY_ALERT_MESSAGE, messageAlert);
        intent.putExtra(EXTRA_KEY_NOTIFICATION_MESSAGE, messageNotification);
        mContext.sendOrderedBroadcast(intent, null, mResultReceiver, null, Activity.RESULT_OK, null, null);
        // so should break the loop after a successful match.
        break;
    }
}
#end_block

#method_before
private void updateRoamingState(boolean newRoaming) {
    if (mCT.getState() == PhoneConstants.State.IDLE) {
        if (DBG)
            logd("updateRoamingState now: " + newRoaming);
        mRoaming = newRoaming;
        ImsManager.setWfcMode(mContext, ImsManager.getWfcMode(mContext, newRoaming), newRoaming);
    } else {
        if (DBG)
            logd("updateRoamingState postponed: " + newRoaming);
        mCT.registerForVoiceCallEnded(this, EVENT_VOICE_CALL_ENDED, null);
    }
}
#method_after
private void updateRoamingState(boolean newRoaming) {
    if (mCT.getState() == PhoneConstants.State.IDLE) {
        if (DBG)
            logd("updateRoamingState now: " + newRoaming);
        mRoaming = newRoaming;
        ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
        imsManager.setWfcMode(imsManager.getWfcMode(newRoaming), newRoaming);
    } else {
        if (DBG)
            logd("updateRoamingState postponed: " + newRoaming);
        mCT.registerForVoiceCallEnded(this, EVENT_VOICE_CALL_ENDED, null);
    }
}
#end_block

#method_before
private void logi(String s) {
    Rlog.i(LOG_TAG, "[ImsPhone][" + getPhoneId() + "] " + s);
}
#method_after
private void logi(String s) {
    Rlog.i(LOG_TAG, "[" + mPhoneId + "] " + s);
}
#end_block

#method_before
private void logv(String s) {
    Rlog.v(LOG_TAG, "[ImsPhone][" + getPhoneId() + "] " + s);
}
#method_after
private void logv(String s) {
    Rlog.v(LOG_TAG, "[" + mPhoneId + "] " + s);
}
#end_block

#method_before
private void logd(String s) {
    Rlog.d(LOG_TAG, "[ImsPhone][" + getPhoneId() + "] " + s);
}
#method_after
private void logd(String s) {
    Rlog.d(LOG_TAG, "[" + mPhoneId + "] " + s);
}
#end_block

#method_before
private void loge(String s) {
    Rlog.e(LOG_TAG, "[ImsPhone][" + getPhoneId() + "] " + s);
}
#method_after
private void loge(String s) {
    Rlog.e(LOG_TAG, "[" + mPhoneId + "] " + s);
}
#end_block

#method_before
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
    } else {
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#method_after
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzState.handleNetworkUnavailable();
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
    } else {
        mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#end_block

#method_before
private void processCellLocationInfo(CellLocation cellLocation, VoiceRegStateResult voiceRegStateResult) {
    if (mPhone.isPhoneTypeGsm()) {
        int psc = -1;
        int cid = -1;
        int lac = -1;
        switch(voiceRegStateResult.cellIdentity.cellInfoType) {
            case CellInfoType.GSM:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityGsm.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityGsm cellIdentityGsm = voiceRegStateResult.cellIdentity.cellIdentityGsm.get(0);
                        cid = cellIdentityGsm.cid;
                        lac = cellIdentityGsm.lac;
                    }
                    break;
                }
            case CellInfoType.WCDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityWcdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityWcdma cellIdentityWcdma = voiceRegStateResult.cellIdentity.cellIdentityWcdma.get(0);
                        cid = cellIdentityWcdma.cid;
                        lac = cellIdentityWcdma.lac;
                        psc = cellIdentityWcdma.psc;
                    }
                    break;
                }
            case CellInfoType.TD_SCDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityTdscdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityTdscdma cellIdentityTdscdma = voiceRegStateResult.cellIdentity.cellIdentityTdscdma.get(0);
                        cid = cellIdentityTdscdma.cid;
                        lac = cellIdentityTdscdma.lac;
                    }
                    break;
                }
            case CellInfoType.LTE:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityLte.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityLte cellIdentityLte = voiceRegStateResult.cellIdentity.cellIdentityLte.get(0);
                        cid = cellIdentityLte.ci;
                        /* Continuing the historical behaviour of using tac as lac. */
                        lac = cellIdentityLte.tac;
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
        // LAC and CID are -1 if not avail
        ((GsmCellLocation) cellLocation).setLacAndCid(lac, cid);
        ((GsmCellLocation) cellLocation).setPsc(psc);
    } else {
        int baseStationId = -1;
        int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
        int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        int systemId = 0;
        int networkId = 0;
        switch(voiceRegStateResult.cellIdentity.cellInfoType) {
            case CellInfoType.CDMA:
                {
                    if (voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        baseStationId = cellIdentityCdma.baseStationId;
                        baseStationLatitude = cellIdentityCdma.latitude;
                        baseStationLongitude = cellIdentityCdma.longitude;
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
        // Some carriers only return lat-lngs of 0,0
        if (baseStationLatitude == 0 && baseStationLongitude == 0) {
            baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
            baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        }
        // Values are -1 if not available.
        ((CdmaCellLocation) cellLocation).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
    }
}
#method_after
private void processCellLocationInfo(CellLocation cellLocation, CellIdentity cellIdentity) {
    if (mPhone.isPhoneTypeGsm()) {
        int psc = -1;
        int cid = -1;
        int lac = -1;
        if (cellIdentity != null) {
            switch(cellIdentity.getType()) {
                case CellInfoType.GSM:
                    {
                        cid = ((CellIdentityGsm) cellIdentity).getCid();
                        lac = ((CellIdentityGsm) cellIdentity).getLac();
                        break;
                    }
                case CellInfoType.WCDMA:
                    {
                        cid = ((CellIdentityWcdma) cellIdentity).getCid();
                        lac = ((CellIdentityWcdma) cellIdentity).getLac();
                        psc = ((CellIdentityWcdma) cellIdentity).getPsc();
                        break;
                    }
                case CellInfoType.TD_SCDMA:
                    {
                        cid = ((CellIdentityTdscdma) cellIdentity).getCid();
                        lac = ((CellIdentityTdscdma) cellIdentity).getLac();
                        break;
                    }
                case CellInfoType.LTE:
                    {
                        cid = ((CellIdentityLte) cellIdentity).getCi();
                        lac = ((CellIdentityLte) cellIdentity).getTac();
                        break;
                    }
                default:
                    {
                        break;
                    }
            }
        }
        // LAC and CID are -1 if not avail
        ((GsmCellLocation) cellLocation).setLacAndCid(lac, cid);
        ((GsmCellLocation) cellLocation).setPsc(psc);
    } else {
        int baseStationId = -1;
        int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
        int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        int systemId = 0;
        int networkId = 0;
        if (cellIdentity != null) {
            switch(cellIdentity.getType()) {
                case CellInfoType.CDMA:
                    {
                        baseStationId = ((CellIdentityCdma) cellIdentity).getBasestationId();
                        baseStationLatitude = ((CellIdentityCdma) cellIdentity).getLatitude();
                        baseStationLongitude = ((CellIdentityCdma) cellIdentity).getLongitude();
                        systemId = ((CellIdentityCdma) cellIdentity).getSystemId();
                        networkId = ((CellIdentityCdma) cellIdentity).getNetworkId();
                        break;
                    }
                default:
                    {
                        break;
                    }
            }
        }
        // Some carriers only return lat-lngs of 0,0
        if (baseStationLatitude == 0 && baseStationLongitude == 0) {
            baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
            baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
        }
        // Values are -1 if not available.
        ((CdmaCellLocation) cellLocation).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
    }
}
#end_block

#method_before
private int getLteEarfcn(DataRegStateResult dataRegStateResult) {
    int lteEarfcn = INVALID_LTE_EARFCN;
    switch(dataRegStateResult.cellIdentity.cellInfoType) {
        case CellInfoType.LTE:
            {
                if (dataRegStateResult.cellIdentity.cellIdentityLte.size() == 1) {
                    android.hardware.radio.V1_0.CellIdentityLte cellIdentityLte = dataRegStateResult.cellIdentity.cellIdentityLte.get(0);
                    lteEarfcn = cellIdentityLte.earfcn;
                }
                break;
            }
        default:
            {
                break;
            }
    }
    return lteEarfcn;
}
#method_after
private int getLteEarfcn(CellIdentity cellIdentity) {
    int lteEarfcn = INVALID_LTE_EARFCN;
    if (cellIdentity != null) {
        switch(cellIdentity.getType()) {
            case CellInfoType.LTE:
                {
                    lteEarfcn = ((CellIdentityLte) cellIdentity).getEarfcn();
                    break;
                }
            default:
                {
                    break;
                }
        }
    }
    return lteEarfcn;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        case EVENT_RADIO_POWER_OFF_DONE:
            if (DBG)
                log("EVENT_RADIO_POWER_OFF_DONE");
            if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
                // during shutdown the modem may not send radio state changed event
                // as a result of radio power request
                // Hence, issuing shut down regardless of radio power response
                mCi.requestShutdown(null);
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                processCellLocationInfo(mCellLoc, (VoiceRegStateResult) ar.result);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_SIM_NOT_INSERTED:
            if (DBG)
                log("EVENT_SIM_NOT_INSERTED, cancelling notifications.");
            cancelAllNotifications();
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        case EVENT_IMS_SERVICE_STATE_CHANGED:
            if (DBG)
                log("EVENT_IMS_SERVICE_STATE_CHANGED");
            // GsmCdma phone is not STATE_IN_SERVICE.
            if (mSS.getState() != ServiceState.STATE_IN_SERVICE) {
                mPhone.notifyServiceStateChanged(mPhone.getServiceState());
            }
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        case EVENT_RADIO_POWER_OFF_DONE:
            if (DBG)
                log("EVENT_RADIO_POWER_OFF_DONE");
            if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
                // during shutdown the modem may not send radio state changed event
                // as a result of radio power request
                // Hence, issuing shut down regardless of radio power response
                mCi.requestShutdown(null);
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                CellIdentity cellIdentity = ((NetworkRegistrationState) ar.result).getCellIdentity();
                processCellLocationInfo(mCellLoc, cellIdentity);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mRegStateManagers.get(AccessNetworkConstants.TransportType.WWAN).getNetworkRegistrationState(NetworkRegistrationState.DOMAIN_CS, obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_SIM_NOT_INSERTED:
            if (DBG)
                log("EVENT_SIM_NOT_INSERTED");
            cancelAllNotifications();
            mMdn = null;
            mMin = null;
            mIsMinInfoReady = false;
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        case EVENT_IMS_SERVICE_STATE_CHANGED:
            if (DBG)
                log("EVENT_IMS_SERVICE_STATE_CHANGED");
            // GsmCdma phone is not STATE_IN_SERVICE.
            if (mSS.getState() != ServiceState.STATE_IN_SERVICE) {
                mPhone.notifyServiceStateChanged(mPhone.getServiceState());
            }
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setCssIndicator(cssIndicator);
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(mDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (mPhone.shouldForceAutoNetworkSelect())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#method_after
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                NetworkRegistrationState networkRegState = (NetworkRegistrationState) ar.result;
                VoiceSpecificRegistrationStates voiceSpecificStates = networkRegState.getVoiceSpecificStates();
                int registrationState = networkRegState.getRegState();
                int cssIndicator = voiceSpecificStates.cssSupported ? 1 : 0;
                int newVoiceRat = ServiceState.networkTypeToRilRadioTechnology(networkRegState.getAccessNetworkTechnology());
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setCssIndicator(cssIndicator);
                mNewSS.setRilVoiceRadioTechnology(newVoiceRat);
                mNewSS.addNetworkRegistrationState(networkRegState);
                // Denial reason if registrationState = 3
                int reasonForDenial = networkRegState.getReasonForDenial();
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    mEmergencyOnly = networkRegState.isEmergencyEnabled();
                } else {
                    int roamingIndicator = voiceSpecificStates.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceSpecificStates.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceSpecificStates.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    CellIdentity cellIdentity = networkRegState.getCellIdentity();
                    if (cellIdentity != null && cellIdentity.getType() == CellInfoType.CDMA) {
                        systemId = ((CellIdentityCdma) cellIdentity).getSystemId();
                        networkId = ((CellIdentityCdma) cellIdentity).getNetworkId();
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, networkRegState.getCellIdentity());
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + newVoiceRat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                NetworkRegistrationState networkRegState = (NetworkRegistrationState) ar.result;
                DataSpecificRegistrationStates dataSpecificStates = networkRegState.getDataSpecificStates();
                int registrationState = networkRegState.getRegState();
                int serviceState = regCodeToServiceState(registrationState);
                int newDataRat = ServiceState.networkTypeToRilRadioTechnology(networkRegState.getAccessNetworkTechnology());
                mNewSS.setDataRegState(serviceState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                mNewSS.addNetworkRegistrationState(networkRegState);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = networkRegState.getReasonForDenial();
                    mNewMaxDataCalls = dataSpecificStates.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(registrationState);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(mDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST dataServiceState=" + serviceState + " regState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    boolean isDataRoaming = regCodeIsRoaming(registrationState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma dataServiceState=" + serviceState + " regState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    boolean isDataRoaming = regCodeIsRoaming(registrationState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST dataServiceState=" + serviceState + " registrationState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(networkRegState.getCellIdentity()));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (mPhone.shouldForceAutoNetworkSelect())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#end_block

#method_before
protected void log(String s) {
    Rlog.d(LOG_TAG, "[ServiceStateTracker][" + mPhone.getPhoneId() + "] " + s);
}
#method_after
protected final void log(String s) {
    Rlog.d(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + s);
}
#end_block

#method_before
protected void loge(String s) {
    Rlog.e(LOG_TAG, "[ServiceStateTracker][" + mPhone.getPhoneId() + "] " + s);
}
#method_after
protected final void loge(String s) {
    Rlog.e(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + s);
}
#end_block

#method_before
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#method_after
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            // TODO: Add WLAN support.
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mRegStateManagers.get(AccessNetworkConstants.TransportType.WWAN).getNetworkRegistrationState(NetworkRegistrationState.DOMAIN_PS, obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mRegStateManagers.get(AccessNetworkConstants.TransportType.WWAN).getNetworkRegistrationState(NetworkRegistrationState.DOMAIN_CS, obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update time zone, ISO, and IDD.
            // 
            // If the device is on IWLAN, modems manufacture a ServiceState with the MCC/MNC of
            // the SIM as if we were talking to towers. Telephony code then uses that with
            // mccTable to suggest a timezone. We shouldn't do that if the MCC/MNC is from IWLAN
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                updateTimeZoneByNetworkCountryCode(iso);
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // ratchet the new tech up through it's rat family but don't drop back down
    // until cell change or device is OOS
    boolean isDataInService = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    if (!hasLocationChanged && isDataInService) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkAvailable();
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkUnavailable();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String prevCountryIsoCode = tm.getNetworkCountryIso(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mNitzState.handleNetworkUnavailable();
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update IDD.
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            // Update ISO.
            String countryIsoCode = "";
            try {
                String mcc = operatorNumeric.substring(0, 3);
                countryIsoCode = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), countryIsoCode);
            // Update Time Zone.
            boolean iccCardExists = iccCardExists();
            boolean networkIsoChanged = networkCountryIsoChanged(countryIsoCode, prevCountryIsoCode);
            // Determine countryChanged: networkIso is only reliable if there's an ICC card.
            boolean countryChanged = iccCardExists && networkIsoChanged;
            if (DBG) {
                long ctm = System.currentTimeMillis();
                log("Before handleNetworkCountryCodeKnown:" + " countryChanged=" + countryChanged + " iccCardExist=" + iccCardExists + " countryIsoChanged=" + networkIsoChanged + " operatorNumeric=" + operatorNumeric + " prevOperatorNumeric=" + prevOperatorNumeric + " countryIsoCode=" + countryIsoCode + " prevCountryIsoCode=" + prevCountryIsoCode + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            mNitzState.handleNetworkCountryCodeSet(countryChanged);
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name))) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && getCombinedRegState() == ServiceState.STATE_IN_SERVICE && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#method_after
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name)) && (!mIsSubscriptionFromRuim)) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && getCombinedRegState() == ServiceState.STATE_IN_SERVICE && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#end_block

#method_before
protected void setOperatorIdd(String operatorNumeric) {
    // Retrieve the current country information
    // with the MCC got from opeatorNumeric.
    String idd = mHbpcdUtils.getIddByMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
    if (idd != null && !idd.isEmpty()) {
        mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, idd);
    } else {
        // use default "+", since we don't know the current IDP
        mPhone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, "+");
    }
}
#method_after
protected void setOperatorIdd(String operatorNumeric) {
    // Retrieve the current country information
    // with the MCC got from opeatorNumeric.
    String idd = mHbpcdUtils.getIddByMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
    if (idd != null && !idd.isEmpty()) {
        mPhone.setGlobalSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, idd);
    } else {
        // use default "+", since we don't know the current IDP
        mPhone.setGlobalSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, "+");
    }
}
#end_block

#method_before
protected boolean isInvalidOperatorNumeric(String operatorNumeric) {
    return operatorNumeric == null || operatorNumeric.length() < 5 || operatorNumeric.startsWith(INVALID_MCC);
}
#method_after
private boolean isInvalidOperatorNumeric(String operatorNumeric) {
    return operatorNumeric == null || operatorNumeric.length() < 5 || operatorNumeric.startsWith(INVALID_MCC);
}
#end_block

#method_before
protected String fixUnknownMcc(String operatorNumeric, int sid) {
    if (sid <= 0) {
        // no cdma information is available, do nothing
        return operatorNumeric;
    }
    // resolve the mcc from sid;
    // if mSavedTimeZone is null, TimeZone would get the default timeZone,
    // and the fixTimeZone couldn't help, because it depends on operator Numeric;
    // if the sid is conflict and timezone is unavailable, the mcc may be not right.
    boolean isNitzTimeZone = false;
    int timeZone = 0;
    TimeZone tzone = null;
    if (mSavedTimeZone != null) {
        timeZone = TimeZone.getTimeZone(mSavedTimeZone).getRawOffset() / MS_PER_HOUR;
        isNitzTimeZone = true;
    } else {
        tzone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
        if (tzone != null)
            timeZone = tzone.getRawOffset() / MS_PER_HOUR;
    }
    int mcc = mHbpcdUtils.getMcc(sid, timeZone, (mZoneDst ? 1 : 0), isNitzTimeZone);
    if (mcc > 0) {
        operatorNumeric = Integer.toString(mcc) + DEFAULT_MNC;
    }
    return operatorNumeric;
}
#method_after
private String fixUnknownMcc(String operatorNumeric, int sid) {
    if (sid <= 0) {
        // no cdma information is available, do nothing
        return operatorNumeric;
    }
    // resolve the mcc from sid;
    // if mNitzState.getSavedTimeZoneId() is null, TimeZone would get the default timeZone,
    // and the mNitzState.fixTimeZone() couldn't help, because it depends on operator Numeric;
    // if the sid is conflict and timezone is unavailable, the mcc may be not right.
    boolean isNitzTimeZone;
    TimeZone tzone;
    if (mNitzState.getSavedTimeZoneId() != null) {
        tzone = TimeZone.getTimeZone(mNitzState.getSavedTimeZoneId());
        isNitzTimeZone = true;
    } else {
        NitzData lastNitzData = mNitzState.getCachedNitzData();
        if (lastNitzData == null) {
            tzone = null;
        } else {
            tzone = TimeZoneLookupHelper.guessZoneByNitzStatic(lastNitzData);
            if (ServiceStateTracker.DBG) {
                log("fixUnknownMcc(): guessNitzTimeZone returned " + (tzone == null ? tzone : tzone.getID()));
            }
        }
        isNitzTimeZone = false;
    }
    int utcOffsetHours = 0;
    if (tzone != null) {
        utcOffsetHours = tzone.getRawOffset() / MS_PER_HOUR;
    }
    NitzData nitzData = mNitzState.getCachedNitzData();
    boolean isDst = nitzData != null && nitzData.isDst();
    int mcc = mHbpcdUtils.getMcc(sid, utcOffsetHours, (isDst ? 1 : 0), isNitzTimeZone);
    if (mcc > 0) {
        operatorNumeric = Integer.toString(mcc) + DEFAULT_MNC;
    }
    return operatorNumeric;
}
#end_block

#method_before
private int regCodeToServiceState(int code) {
    switch(code) {
        case ServiceState.RIL_REG_STATE_HOME:
        case ServiceState.RIL_REG_STATE_ROAMING:
            return ServiceState.STATE_IN_SERVICE;
        default:
            return ServiceState.STATE_OUT_OF_SERVICE;
    }
}
#method_after
private int regCodeToServiceState(int code) {
    switch(code) {
        case NetworkRegistrationState.REG_STATE_HOME:
        case NetworkRegistrationState.REG_STATE_ROAMING:
            return ServiceState.STATE_IN_SERVICE;
        default:
            return ServiceState.STATE_OUT_OF_SERVICE;
    }
}
#end_block

#method_before
private boolean regCodeIsRoaming(int code) {
    return ServiceState.RIL_REG_STATE_ROAMING == code;
}
#method_after
private boolean regCodeIsRoaming(int code) {
    return NetworkRegistrationState.REG_STATE_ROAMING == code;
}
#end_block

#method_before
private void setTimeFromNITZString(String nitz, long nitzReceiveTime) {
    // "yy/mm/dd,hh:mm:ss(+/-)tz"
    // tz is in number of quarter-hours
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        log("NITZ: " + nitz + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    try {
        /* NITZ time (hour:min:sec) will be in UTC but it supplies the timezone
             * offset as well (which we won't worry about until later) */
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.clear();
        c.set(Calendar.DST_OFFSET, 0);
        String[] nitzSubs = nitz.split("[/:,+-]");
        int year = 2000 + Integer.parseInt(nitzSubs[0]);
        if (year > MAX_NITZ_YEAR) {
            if (DBG)
                loge("NITZ year: " + year + " exceeds limit, skip NITZ time update");
            return;
        }
        c.set(Calendar.YEAR, year);
        // month is 0 based!
        int month = Integer.parseInt(nitzSubs[1]) - 1;
        c.set(Calendar.MONTH, month);
        int date = Integer.parseInt(nitzSubs[2]);
        c.set(Calendar.DATE, date);
        int hour = Integer.parseInt(nitzSubs[3]);
        c.set(Calendar.HOUR, hour);
        int minute = Integer.parseInt(nitzSubs[4]);
        c.set(Calendar.MINUTE, minute);
        int second = Integer.parseInt(nitzSubs[5]);
        c.set(Calendar.SECOND, second);
        boolean sign = (nitz.indexOf('-') == -1);
        int tzOffset = Integer.parseInt(nitzSubs[6]);
        int dst = (nitzSubs.length >= 8) ? Integer.parseInt(nitzSubs[7]) : 0;
        // The zone offset received from NITZ is for current local time,
        // so DST correction is already applied.  Don't add it again.
        // 
        // tzOffset += dst * 4;
        // 
        // We could unapply it if we wanted the raw offset.
        tzOffset = (sign ? 1 : -1) * tzOffset * 15 * 60 * 1000;
        TimeZone zone = null;
        // so we need to convert the ! into /
        if (nitzSubs.length >= 9) {
            String tzname = nitzSubs[8].replace('!', '/');
            zone = TimeZone.getTimeZone(tzname);
        }
        String iso = ((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getNetworkCountryIsoForPhone(mPhone.getPhoneId());
        if (zone == null) {
            if (mGotCountryCode) {
                if (iso != null && iso.length() > 0) {
                    zone = TimeUtils.getTimeZone(tzOffset, dst != 0, c.getTimeInMillis(), iso);
                } else {
                    // We don't have a valid iso country code.  This is
                    // most likely because we're on a test network that's
                    // using a bogus MCC (eg, "001"), so get a TimeZone
                    // based only on the NITZ parameters.
                    zone = getNitzTimeZone(tzOffset, (dst != 0), c.getTimeInMillis());
                }
            }
        }
        if ((zone == null) || (mZoneOffset != tzOffset) || (mZoneDst != (dst != 0))) {
            // We got the time before the country or the zone has changed
            // so we don't know how to identify the DST rules yet.  Save
            // the information and hope to fix it up later.
            mNeedFixZoneAfterNitz = true;
            mZoneOffset = tzOffset;
            mZoneDst = dst != 0;
            mZoneTime = c.getTimeInMillis();
        }
        String tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " tzOffset=" + tzOffset + " dst=" + dst + " zone=" + (zone != null ? zone.getID() : "NULL") + " iso=" + iso + " mGotCountryCode=" + mGotCountryCode + " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz + " getAutoTimeZone()=" + getAutoTimeZone();
        if (DBG) {
            log(tmpLog);
        }
        mTimeZoneLog.log(tmpLog);
        if (zone != null) {
            if (getAutoTimeZone()) {
                setAndBroadcastNetworkSetTimeZone(zone.getID());
            }
            saveNitzTimeZone(zone.getID());
        }
        String ignore = SystemProperties.get("gsm.ignore-nitz");
        if (ignore != null && ignore.equals("yes")) {
            log("NITZ: Not setting clock because gsm.ignore-nitz is set");
            return;
        }
        try {
            mWakeLock.acquire();
            if (!mPhone.isPhoneTypeGsm() || getAutoTime()) {
                long millisSinceNitzReceived = SystemClock.elapsedRealtime() - nitzReceiveTime;
                if (millisSinceNitzReceived < 0) {
                    // Sanity check: something is wrong
                    if (DBG) {
                        log("NITZ: not setting time, clock has rolled " + "backwards since NITZ time was received, " + nitz);
                    }
                    return;
                }
                if (millisSinceNitzReceived > Integer.MAX_VALUE) {
                    // If the time is this far off, something is wrong > 24 days!
                    if (DBG) {
                        log("NITZ: not setting time, processing has taken " + (millisSinceNitzReceived / (1000 * 60 * 60 * 24)) + " days");
                    }
                    return;
                }
                // Note: with range checks above, cast to int is safe
                c.add(Calendar.MILLISECOND, (int) millisSinceNitzReceived);
                tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " Setting time of day to " + c.getTime() + " NITZ receive delay(ms): " + millisSinceNitzReceived + " gained(ms): " + (c.getTimeInMillis() - System.currentTimeMillis()) + " from " + nitz;
                if (DBG) {
                    log(tmpLog);
                }
                mTimeLog.log(tmpLog);
                if (mPhone.isPhoneTypeGsm()) {
                    setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                    Rlog.i(LOG_TAG, "NITZ: after Setting time of day");
                } else {
                    if (getAutoTime()) {
                        /**
                         * Update system time automatically
                         */
                        long gained = c.getTimeInMillis() - System.currentTimeMillis();
                        long timeSinceLastUpdate = SystemClock.elapsedRealtime() - mSavedAtTime;
                        int nitzUpdateSpacing = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_SPACING, mNitzUpdateSpacing);
                        int nitzUpdateDiff = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_DIFF, mNitzUpdateDiff);
                        if ((mSavedAtTime == 0) || (timeSinceLastUpdate > nitzUpdateSpacing) || (Math.abs(gained) > nitzUpdateDiff)) {
                            if (DBG) {
                                log("NITZ: Auto updating time of day to " + c.getTime() + " NITZ receive delay=" + millisSinceNitzReceived + "ms gained=" + gained + "ms from " + nitz);
                            }
                            setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                        } else {
                            if (DBG) {
                                log("NITZ: ignore, a previous update was " + timeSinceLastUpdate + "ms ago and gained=" + gained + "ms");
                            }
                            return;
                        }
                    }
                }
            }
            SystemProperties.set("gsm.nitz.time", String.valueOf(c.getTimeInMillis()));
            saveNitzTime(c.getTimeInMillis());
            mNitzUpdatedTime = true;
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                log("NITZ: end=" + end + " dur=" + (end - start));
            }
            mWakeLock.release();
        }
    } catch (RuntimeException ex) {
        loge("NITZ: Parsing NITZ time " + nitz + " ex=" + ex);
    }
}
#method_after
private void setTimeFromNITZString(String nitzString, long nitzReceiveTime) {
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        Rlog.d(LOG_TAG, "NITZ: " + nitzString + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    NitzData newNitzData = NitzData.parse(nitzString);
    if (newNitzData != null) {
        try {
            TimeStampedValue<NitzData> nitzSignal = new TimeStampedValue<>(newNitzData, nitzReceiveTime);
            mNitzState.handleNitzReceived(nitzSignal);
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                Rlog.d(LOG_TAG, "NITZ: end=" + end + " dur=" + (end - start));
            }
        }
    }
}
#end_block

#method_before
private void cancelAllNotifications() {
    NotificationManager notificationManager = (NotificationManager) mPhone.getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.cancelAll();
}
#method_after
private void cancelAllNotifications() {
    if (DBG)
        log("setNotification: cancelAllNotifications");
    NotificationManager notificationManager = (NotificationManager) mPhone.getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.cancel(PS_NOTIFICATION);
    notificationManager.cancel(CS_NOTIFICATION);
    notificationManager.cancel(CS_REJECT_CAUSE_NOTIFICATION);
}
#end_block

#method_before
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                loge("setNotification: mRejectCode=" + mRejectCode + " is not handled.");
                return;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#method_after
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                loge("setNotification: mRejectCode=" + mRejectCode + " is not handled.");
                return;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setStyle(new Notification.BigTextStyle().bigText(details)).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#end_block

#method_before
public void powerOffRadioSafely(DcTracker dcTracker) {
    synchronized (this) {
        if (!mPendingRadioPowerOffAfterDataOff) {
            if (mPhone.isPhoneTypeGsm() || mPhone.isPhoneTypeCdmaLte()) {
                int dds = SubscriptionManager.getDefaultDataSubscriptionId();
                // both if else paths instead of before this isDisconnected test.
                if (dcTracker.isDisconnected() && (dds == mPhone.getSubId() || (dds != mPhone.getSubId() && ProxyController.getInstance().isDataDisconnected(dds)))) {
                    // To minimize race conditions we do this after isDisconnected
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    if (DBG)
                        log("Data disconnected, turn off radio right away.");
                    hangupAndPowerOff();
                } else {
                    // hang up all active voice calls first
                    if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
                        mPhone.mCT.mRingingCall.hangupIfAlive();
                        mPhone.mCT.mBackgroundCall.hangupIfAlive();
                        mPhone.mCT.mForegroundCall.hangupIfAlive();
                    }
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    if (dds != mPhone.getSubId() && !ProxyController.getInstance().isDataDisconnected(dds)) {
                        if (DBG)
                            log("Data is active on DDS.  Wait for all data disconnect");
                        // Data is not disconnected on DDS. Wait for the data disconnect complete
                        // before sending the RADIO_POWER off.
                        ProxyController.getInstance().registerForAllDataDisconnected(dds, this, EVENT_ALL_DATA_DISCONNECTED, null);
                        mPendingRadioPowerOffAfterDataOff = true;
                    }
                    Message msg = Message.obtain(this);
                    msg.what = EVENT_SET_RADIO_POWER_OFF;
                    msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
                    if (sendMessageDelayed(msg, 30000)) {
                        if (DBG)
                            log("Wait upto 30s for data to disconnect, then turn off radio.");
                        mPendingRadioPowerOffAfterDataOff = true;
                    } else {
                        log("Cannot send delayed Msg, turn off radio right away.");
                        hangupAndPowerOff();
                        mPendingRadioPowerOffAfterDataOff = false;
                    }
                }
            } else {
                // In some network, deactivate PDP connection cause releasing of RRC connection,
                // which MM/IMSI detaching request needs. Without this detaching, network can
                // not release the network resources previously attached.
                // So we are avoiding data detaching on these networks.
                String[] networkNotClearData = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.networks_not_clear_data);
                String currentNetwork = mSS.getOperatorNumeric();
                if ((networkNotClearData != null) && (currentNetwork != null)) {
                    for (int i = 0; i < networkNotClearData.length; i++) {
                        if (currentNetwork.equals(networkNotClearData[i])) {
                            // Don't clear data connection for this carrier
                            if (DBG)
                                log("Not disconnecting data for " + currentNetwork);
                            hangupAndPowerOff();
                            return;
                        }
                    }
                }
                // both if else paths instead of before this isDisconnected test.
                if (dcTracker.isDisconnected()) {
                    // To minimize race conditions we do this after isDisconnected
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    if (DBG)
                        log("Data disconnected, turn off radio right away.");
                    hangupAndPowerOff();
                } else {
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    Message msg = Message.obtain(this);
                    msg.what = EVENT_SET_RADIO_POWER_OFF;
                    msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
                    if (sendMessageDelayed(msg, 30000)) {
                        if (DBG)
                            log("Wait upto 30s for data to disconnect, then turn off radio.");
                        mPendingRadioPowerOffAfterDataOff = true;
                    } else {
                        log("Cannot send delayed Msg, turn off radio right away.");
                        hangupAndPowerOff();
                    }
                }
            }
        }
    }
}
#method_after
public void powerOffRadioSafely(DcTracker dcTracker) {
    synchronized (this) {
        if (!mPendingRadioPowerOffAfterDataOff) {
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            // both if else paths instead of before this isDisconnected test.
            if (dcTracker.isDisconnected() && (dds == mPhone.getSubId() || (dds != mPhone.getSubId() && ProxyController.getInstance().isDataDisconnected(dds)))) {
                // To minimize race conditions we do this after isDisconnected
                dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                if (DBG)
                    log("Data disconnected, turn off radio right away.");
                hangupAndPowerOff();
            } else {
                // hang up all active voice calls first
                if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
                    mPhone.mCT.mRingingCall.hangupIfAlive();
                    mPhone.mCT.mBackgroundCall.hangupIfAlive();
                    mPhone.mCT.mForegroundCall.hangupIfAlive();
                }
                dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                if (dds != mPhone.getSubId() && !ProxyController.getInstance().isDataDisconnected(dds)) {
                    if (DBG)
                        log("Data is active on DDS.  Wait for all data disconnect");
                    // Data is not disconnected on DDS. Wait for the data disconnect complete
                    // before sending the RADIO_POWER off.
                    ProxyController.getInstance().registerForAllDataDisconnected(dds, this, EVENT_ALL_DATA_DISCONNECTED, null);
                    mPendingRadioPowerOffAfterDataOff = true;
                }
                Message msg = Message.obtain(this);
                msg.what = EVENT_SET_RADIO_POWER_OFF;
                msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
                if (sendMessageDelayed(msg, 30000)) {
                    if (DBG)
                        log("Wait upto 30s for data to disconnect, then turn off radio.");
                    mPendingRadioPowerOffAfterDataOff = true;
                } else {
                    log("Cannot send delayed Msg, turn off radio right away.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                }
            }
        }
    }
}
#end_block

#method_before
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && voiceRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
            mSignalStrength.fixType();
        } else {
            mSignalStrength.setGsm(isGsm);
        }
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
        mSignalStrength.setUseOnlyRsrpForLteLevel(isUseOnlyRsrpForLteLevel());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#method_after
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && voiceRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
            mSignalStrength.fixType();
        } else {
            mSignalStrength.setGsm(isGsm);
        }
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
        mSignalStrength.setUseOnlyRsrpForLteLevel(isUseOnlyRsrpForLteLevel());
        mSignalStrength.setLteRsrpThresholds(getLteRsrpThresholds());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + Rlog.pii(VDBG, mCellLoc));
    pw.println(" mNewCellLoc=" + Rlog.pii(VDBG, mNewCellLoc));
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    ipw.println(" Time Logs:");
    ipw.increaseIndent();
    mTimeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time zone Logs:");
    ipw.increaseIndent();
    mTimeZoneLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + Rlog.pii(VDBG, mCellLoc));
    pw.println(" mNewCellLoc=" + Rlog.pii(VDBG, mNewCellLoc));
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.flush();
    mNitzState.dumpState(pw);
    pw.flush();
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    mNitzState.dumpLogs(fd, ipw, args);
}
#end_block

#method_before
private boolean isUseOnlyRsrpForLteLevel() {
    CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        // If an invalid subId is used, this bundle will contain default values.
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            return config.getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL);
        }
    }
    // Return static default defined in CarrierConfigManager.
    return CarrierConfigManager.getDefaultConfig().getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL);
}
#method_after
private boolean isUseOnlyRsrpForLteLevel() {
    return getCarrierConfig().getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL);
}
#end_block

#method_before
private void getImsService() throws ImsException {
    if (DBG)
        log("getImsService");
    mImsManager = ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId());
    // Adding to set, will be safe adding multiple times. If the ImsService is not active yet,
    // this method will throw an ImsException.
    mImsManager.addNotifyStatusChangedCallbackIfAvailable(mNotifyStatusChangedCallback);
    // Wait for ImsService.STATE_READY to start listening for calls.
    // Call the callback right away for compatibility with older devices that do not use states.
    mNotifyStatusChangedCallback.notifyStatusChanged();
}
#method_after
private void getImsService() throws ImsException {
    if (DBG)
        log("getImsService");
    mImsManager = ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId());
    // Adding to set, will be safe adding multiple times. If the ImsService is not active yet,
    // this method will throw an ImsException.
    mImsManager.addNotifyStatusChangedCallbackIfAvailable(mNotifyStatusChangedCallback);
    // Wait for ImsService.STATE_READY to start listening for calls.
    // Call the callback right away for compatibility with older devices that do not use states.
    mNotifyStatusChangedCallback.notifyStateChanged();
}
#end_block

#method_before
private void startListeningForCalls() throws ImsException {
    mImsServiceRetryCount = 0;
    mServiceId = mImsManager.open(ImsServiceClass.MMTEL, createIncomingCallPendingIntent(), mImsConnectionStateListener);
    mImsManager.setImsConfigListener(mImsConfigListener);
    // Get the ECBM interface and set IMSPhone's listener object for notifications
    getEcbmInterface().setEcbmStateListener(mPhone.getImsEcbmStateListener());
    if (mPhone.isInEcm()) {
        // Call exit ECBM which will invoke onECBMExited
        mPhone.exitEmergencyCallbackMode();
    }
    int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
    mImsManager.setUiTTYMode(mPhone.getContext(), mPreferredTtyMode, null);
    ImsMultiEndpoint multiEndpoint = getMultiEndpointInterface();
    if (multiEndpoint != null) {
        multiEndpoint.setExternalCallStateListener(mPhone.getExternalCallTracker().getExternalCallStateListener());
    }
    if (mCarrierConfigLoaded) {
        ImsManager.updateImsServiceConfig(mPhone.getContext(), mPhone.getPhoneId(), true);
    }
}
#method_after
private void startListeningForCalls() throws ImsException {
    mImsServiceRetryCount = 0;
    mImsManager.open(mMmTelFeatureListener);
    mImsManager.addRegistrationCallback(mImsRegistrationCallback);
    mImsManager.addCapabilitiesCallback(mImsCapabilityCallback);
    mImsManager.setConfigListener(mImsConfigListener);
    mImsManager.getConfigInterface().addConfigCallback(mConfigCallback);
    // Get the ECBM interface and set IMSPhone's listener object for notifications
    getEcbmInterface().setEcbmStateListener(mPhone.getImsEcbmStateListener());
    if (mPhone.isInEcm()) {
        // Call exit ECBM which will invoke onECBMExited
        mPhone.exitEmergencyCallbackMode();
    }
    int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
    mImsManager.setUiTTYMode(mPhone.getContext(), mPreferredTtyMode, null);
    ImsMultiEndpoint multiEndpoint = getMultiEndpointInterface();
    if (multiEndpoint != null) {
        multiEndpoint.setExternalCallStateListener(mPhone.getExternalCallTracker().getExternalCallStateListener());
    }
    // Set UT interface listener to receive UT indications.
    mUtInterface = getUtInterface();
    if (mUtInterface != null) {
        mUtInterface.registerForSuppServiceIndication(this, EVENT_SUPP_SERVICE_INDICATION, null);
    }
    if (mCarrierConfigLoaded) {
        mImsManager.updateImsServiceConfig(true);
    }
}
#end_block

#method_before
private void stopListeningForCalls() {
    try {
        resetImsCapabilities();
        // Only close on valid session.
        if (mImsManager != null && mServiceId > 0) {
            mImsManager.close(mServiceId);
            mServiceId = -1;
        }
    } catch (ImsException e) {
    // If the binder is unavailable, then the ImsService doesn't need to close.
    }
}
#method_after
private void stopListeningForCalls() {
    resetImsCapabilities();
    // Only close on valid session.
    if (mImsManager != null) {
        try {
            mImsManager.getConfigInterface().removeConfigCallback(mConfigCallback);
        } catch (ImsException e) {
            Log.w(LOG_TAG, "stopListeningForCalls: unable to remove config callback.");
        }
        mImsManager.close();
    }
}
#end_block

#method_before
public void dispose() {
    if (DBG)
        log("dispose");
    mRingingCall.dispose();
    mBackgroundCall.dispose();
    mForegroundCall.dispose();
    mHandoverCall.dispose();
    clearDisconnected();
    mPhone.getContext().unregisterReceiver(mReceiver);
    mPhone.getDefaultPhone().unregisterForDataEnabledChanged(this);
    removeMessages(EVENT_GET_IMS_SERVICE);
}
#method_after
public void dispose() {
    if (DBG)
        log("dispose");
    mRingingCall.dispose();
    mBackgroundCall.dispose();
    mForegroundCall.dispose();
    mHandoverCall.dispose();
    clearDisconnected();
    if (mUtInterface != null) {
        mUtInterface.unregisterForSuppServiceIndication(this);
    }
    mPhone.getContext().unregisterReceiver(mReceiver);
    mPhone.getDefaultPhone().unregisterForDataEnabledChanged(this);
    removeMessages(EVENT_GET_IMS_SERVICE);
}
#end_block

#method_before
public Connection dial(String dialString, int videoState, Bundle intentExtras) throws CallStateException {
    int oirMode;
    if (mSharedPreferenceProxy != null && mPhone.getDefaultPhone() != null) {
        SharedPreferences sp = mSharedPreferenceProxy.getDefaultSharedPreferences(mPhone.getContext());
        oirMode = sp.getInt(Phone.CLIR_KEY + mPhone.getDefaultPhone().getPhoneId(), CommandsInterface.CLIR_DEFAULT);
    } else {
        loge("dial; could not get default CLIR mode.");
        oirMode = CommandsInterface.CLIR_DEFAULT;
    }
    return dial(dialString, oirMode, videoState, intentExtras);
}
#method_after
public Connection dial(String dialString, int videoState, Bundle intentExtras) throws CallStateException {
    ImsPhone.ImsDialArgs dialArgs = new ImsPhone.ImsDialArgs.Builder().setIntentExtras(intentExtras).setVideoState(videoState).setClirMode(getClirMode()).build();
    return dial(dialString, dialArgs);
}
#end_block

#method_before
synchronized Connection dial(String dialString, int clirMode, int videoState, Bundle intentExtras) throws CallStateException {
    boolean isPhoneInEcmMode = isPhoneInEcbMode();
    boolean isEmergencyNumber = PhoneNumberUtils.isEmergencyNumber(dialString);
    if (DBG)
        log("dial clirMode=" + clirMode);
    // note that this triggers call state changed notif
    clearDisconnected();
    if (mImsManager == null) {
        throw new CallStateException("service not available");
    }
    if (!canDial()) {
        throw new CallStateException("cannot dial in current state");
    }
    if (isPhoneInEcmMode && isEmergencyNumber) {
        handleEcmTimer(ImsPhone.CANCEL_ECM_TIMER);
    }
    // calls, dial as an audio-only call.
    if (isEmergencyNumber && VideoProfile.isVideo(videoState) && !mAllowEmergencyVideoCalls) {
        loge("dial: carrier does not support video emergency calls; downgrade to audio-only");
        videoState = VideoProfile.STATE_AUDIO_ONLY;
    }
    boolean holdBeforeDial = false;
    // there on hold
    if (mForegroundCall.getState() == ImsPhoneCall.State.ACTIVE) {
        if (mBackgroundCall.getState() != ImsPhoneCall.State.IDLE) {
            // we should have failed in !canDial() above before we get here
            throw new CallStateException("cannot dial in current state");
        }
        // foreground call is empty for the newly dialed connection
        holdBeforeDial = true;
        // Cache the video state for pending MO call.
        mPendingCallVideoState = videoState;
        mPendingIntentExtras = intentExtras;
        switchWaitingOrHoldingAndActive();
    }
    ImsPhoneCall.State fgState = ImsPhoneCall.State.IDLE;
    ImsPhoneCall.State bgState = ImsPhoneCall.State.IDLE;
    mClirMode = clirMode;
    synchronized (mSyncHold) {
        if (holdBeforeDial) {
            fgState = mForegroundCall.getState();
            bgState = mBackgroundCall.getState();
            // holding foreground call failed
            if (fgState == ImsPhoneCall.State.ACTIVE) {
                throw new CallStateException("cannot dial in current state");
            }
            // holding foreground call succeeded
            if (bgState == ImsPhoneCall.State.HOLDING) {
                holdBeforeDial = false;
            }
        }
        mPendingMO = new ImsPhoneConnection(mPhone, checkForTestEmergencyNumber(dialString), this, mForegroundCall, isEmergencyNumber);
        mPendingMO.setVideoState(videoState);
    }
    addConnection(mPendingMO);
    if (!holdBeforeDial) {
        if ((!isPhoneInEcmMode) || (isPhoneInEcmMode && isEmergencyNumber)) {
            dialInternal(mPendingMO, clirMode, videoState, intentExtras);
        } else {
            try {
                getEcbmInterface().exitEmergencyCallbackMode();
            } catch (ImsException e) {
                e.printStackTrace();
                throw new CallStateException("service not available");
            }
            mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
            pendingCallClirMode = clirMode;
            mPendingCallVideoState = videoState;
            pendingCallInEcm = true;
        }
    }
    updatePhoneState();
    mPhone.notifyPreciseCallStateChanged();
    return mPendingMO;
}
#method_after
public synchronized Connection dial(String dialString, ImsPhone.ImsDialArgs dialArgs) throws CallStateException {
    boolean isPhoneInEcmMode = isPhoneInEcbMode();
    boolean isEmergencyNumber = mPhoneNumberUtilsProxy.isEmergencyNumber(dialString);
    int clirMode = dialArgs.clirMode;
    int videoState = dialArgs.videoState;
    if (DBG)
        log("dial clirMode=" + clirMode);
    if (isEmergencyNumber) {
        clirMode = CommandsInterface.CLIR_SUPPRESSION;
        if (DBG)
            log("dial emergency call, set clirModIe=" + clirMode);
    }
    // note that this triggers call state changed notif
    clearDisconnected();
    if (mImsManager == null) {
        throw new CallStateException("service not available");
    }
    if (!canDial()) {
        throw new CallStateException("cannot dial in current state");
    }
    if (isPhoneInEcmMode && isEmergencyNumber) {
        handleEcmTimer(ImsPhone.CANCEL_ECM_TIMER);
    }
    // calls, dial as an audio-only call.
    if (isEmergencyNumber && VideoProfile.isVideo(videoState) && !mAllowEmergencyVideoCalls) {
        loge("dial: carrier does not support video emergency calls; downgrade to audio-only");
        videoState = VideoProfile.STATE_AUDIO_ONLY;
    }
    boolean holdBeforeDial = false;
    // there on hold
    if (mForegroundCall.getState() == ImsPhoneCall.State.ACTIVE) {
        if (mBackgroundCall.getState() != ImsPhoneCall.State.IDLE) {
            // we should have failed in !canDial() above before we get here
            throw new CallStateException("cannot dial in current state");
        }
        // foreground call is empty for the newly dialed connection
        holdBeforeDial = true;
        // Cache the video state for pending MO call.
        mPendingCallVideoState = videoState;
        mPendingIntentExtras = dialArgs.intentExtras;
        switchWaitingOrHoldingAndActive();
    }
    ImsPhoneCall.State fgState = ImsPhoneCall.State.IDLE;
    ImsPhoneCall.State bgState = ImsPhoneCall.State.IDLE;
    mClirMode = clirMode;
    synchronized (mSyncHold) {
        if (holdBeforeDial) {
            fgState = mForegroundCall.getState();
            bgState = mBackgroundCall.getState();
            // holding foreground call failed
            if (fgState == ImsPhoneCall.State.ACTIVE) {
                throw new CallStateException("cannot dial in current state");
            }
            // holding foreground call succeeded
            if (bgState == ImsPhoneCall.State.HOLDING) {
                holdBeforeDial = false;
            }
        }
        mPendingMO = new ImsPhoneConnection(mPhone, checkForTestEmergencyNumber(dialString), this, mForegroundCall, isEmergencyNumber);
        mPendingMO.setVideoState(videoState);
        if (dialArgs.rttTextStream != null) {
            log("dial: setting RTT stream on mPendingMO");
            mPendingMO.setCurrentRttTextStream(dialArgs.rttTextStream);
        }
    }
    addConnection(mPendingMO);
    if (!holdBeforeDial) {
        if ((!isPhoneInEcmMode) || (isPhoneInEcmMode && isEmergencyNumber)) {
            dialInternal(mPendingMO, clirMode, videoState, dialArgs.intentExtras);
        } else {
            try {
                getEcbmInterface().exitEmergencyCallbackMode();
            } catch (ImsException e) {
                e.printStackTrace();
                throw new CallStateException("service not available");
            }
            mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
            pendingCallClirMode = clirMode;
            mPendingCallVideoState = videoState;
            pendingCallInEcm = true;
        }
    }
    updatePhoneState();
    mPhone.notifyPreciseCallStateChanged();
    return mPendingMO;
}
#end_block

#method_before
private void cacheCarrierConfiguration(int subId) {
    CarrierConfigManager carrierConfigManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (carrierConfigManager == null) {
        loge("cacheCarrierConfiguration: No carrier config service found.");
        return;
    }
    PersistableBundle carrierConfig = carrierConfigManager.getConfigForSubId(subId);
    if (carrierConfig == null) {
        loge("cacheCarrierConfiguration: Empty carrier config.");
        return;
    }
    mAllowEmergencyVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALLOW_EMERGENCY_VIDEO_CALLS_BOOL);
    mTreatDowngradedVideoCallsAsVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_TREAT_DOWNGRADED_VIDEO_CALLS_AS_VIDEO_CALLS_BOOL);
    mDropVideoCallWhenAnsweringAudioCall = carrierConfig.getBoolean(CarrierConfigManager.KEY_DROP_VIDEO_CALL_WHEN_ANSWERING_AUDIO_CALL_BOOL);
    mAllowAddCallDuringVideoCall = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALLOW_ADD_CALL_DURING_VIDEO_CALL_BOOL);
    mNotifyVtHandoverToWifiFail = carrierConfig.getBoolean(CarrierConfigManager.KEY_NOTIFY_VT_HANDOVER_TO_WIFI_FAILURE_BOOL);
    mSupportDowngradeVtToAudio = carrierConfig.getBoolean(CarrierConfigManager.KEY_SUPPORT_DOWNGRADE_VT_TO_AUDIO_BOOL);
    mNotifyHandoverVideoFromWifiToLTE = carrierConfig.getBoolean(CarrierConfigManager.KEY_NOTIFY_HANDOVER_VIDEO_FROM_WIFI_TO_LTE_BOOL);
    mIgnoreDataEnabledChangedForVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
    mIsViLteDataMetered = carrierConfig.getBoolean(CarrierConfigManager.KEY_VILTE_DATA_IS_METERED_BOOL);
    mSupportPauseVideo = carrierConfig.getBoolean(CarrierConfigManager.KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL);
    String[] mappings = carrierConfig.getStringArray(CarrierConfigManager.KEY_IMS_REASONINFO_MAPPING_STRING_ARRAY);
    if (mappings != null && mappings.length > 0) {
        for (String mapping : mappings) {
            String[] values = mapping.split(Pattern.quote("|"));
            if (values.length != 3) {
                continue;
            }
            try {
                Integer fromCode;
                if (values[0].equals("*")) {
                    fromCode = null;
                } else {
                    fromCode = Integer.parseInt(values[0]);
                }
                String message = values[1];
                int toCode = Integer.parseInt(values[2]);
                addReasonCodeRemapping(fromCode, message, toCode);
                log("Loaded ImsReasonInfo mapping : fromCode = " + fromCode == null ? "any" : fromCode + " ; message = " + message + " ; toCode = " + toCode);
            } catch (NumberFormatException nfe) {
                loge("Invalid ImsReasonInfo mapping found: " + mapping);
            }
        }
    } else {
        log("No carrier ImsReasonInfo mappings defined.");
    }
}
#method_after
private void cacheCarrierConfiguration(int subId) {
    CarrierConfigManager carrierConfigManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (carrierConfigManager == null || !SubscriptionController.getInstance().isActiveSubId(subId)) {
        loge("cacheCarrierConfiguration: No carrier config service found" + " " + "or not active subId = " + subId);
        mCarrierConfigLoaded = false;
        return;
    }
    PersistableBundle carrierConfig = carrierConfigManager.getConfigForSubId(subId);
    if (carrierConfig == null) {
        loge("cacheCarrierConfiguration: Empty carrier config.");
        mCarrierConfigLoaded = false;
        return;
    }
    mCarrierConfigLoaded = true;
    mAllowEmergencyVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALLOW_EMERGENCY_VIDEO_CALLS_BOOL);
    mTreatDowngradedVideoCallsAsVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_TREAT_DOWNGRADED_VIDEO_CALLS_AS_VIDEO_CALLS_BOOL);
    mDropVideoCallWhenAnsweringAudioCall = carrierConfig.getBoolean(CarrierConfigManager.KEY_DROP_VIDEO_CALL_WHEN_ANSWERING_AUDIO_CALL_BOOL);
    mAllowAddCallDuringVideoCall = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALLOW_ADD_CALL_DURING_VIDEO_CALL_BOOL);
    mNotifyVtHandoverToWifiFail = carrierConfig.getBoolean(CarrierConfigManager.KEY_NOTIFY_VT_HANDOVER_TO_WIFI_FAILURE_BOOL);
    mSupportDowngradeVtToAudio = carrierConfig.getBoolean(CarrierConfigManager.KEY_SUPPORT_DOWNGRADE_VT_TO_AUDIO_BOOL);
    mNotifyHandoverVideoFromWifiToLTE = carrierConfig.getBoolean(CarrierConfigManager.KEY_NOTIFY_HANDOVER_VIDEO_FROM_WIFI_TO_LTE_BOOL);
    mIgnoreDataEnabledChangedForVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
    mIsViLteDataMetered = carrierConfig.getBoolean(CarrierConfigManager.KEY_VILTE_DATA_IS_METERED_BOOL);
    mSupportPauseVideo = carrierConfig.getBoolean(CarrierConfigManager.KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL);
    mAlwaysPlayRemoteHoldTone = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALWAYS_PLAY_REMOTE_HOLD_TONE_BOOL);
    String[] mappings = carrierConfig.getStringArray(CarrierConfigManager.KEY_IMS_REASONINFO_MAPPING_STRING_ARRAY);
    if (mappings != null && mappings.length > 0) {
        for (String mapping : mappings) {
            String[] values = mapping.split(Pattern.quote("|"));
            if (values.length != 3) {
                continue;
            }
            try {
                Integer fromCode;
                if (values[0].equals("*")) {
                    fromCode = null;
                } else {
                    fromCode = Integer.parseInt(values[0]);
                }
                String message = values[1];
                int toCode = Integer.parseInt(values[2]);
                addReasonCodeRemapping(fromCode, message, toCode);
                log("Loaded ImsReasonInfo mapping : fromCode = " + fromCode == null ? "any" : fromCode + " ; message = " + message + " ; toCode = " + toCode);
            } catch (NumberFormatException nfe) {
                loge("Invalid ImsReasonInfo mapping found: " + mapping);
            }
        }
    } else {
        log("No carrier ImsReasonInfo mappings defined.");
    }
}
#end_block

#method_before
private void dialInternal(ImsPhoneConnection conn, int clirMode, int videoState, Bundle intentExtras) {
    if (conn == null) {
        return;
    }
    if (conn.getAddress() == null || conn.getAddress().length() == 0 || conn.getAddress().indexOf(PhoneNumberUtils.WILD) >= 0) {
        // Phone number is invalid
        conn.setDisconnectCause(DisconnectCause.INVALID_NUMBER);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        return;
    }
    // Always unmute when initiating a new call
    setMute(false);
    int serviceType = PhoneNumberUtils.isEmergencyNumber(conn.getAddress()) ? ImsCallProfile.SERVICE_TYPE_EMERGENCY : ImsCallProfile.SERVICE_TYPE_NORMAL;
    int callType = ImsCallProfile.getCallTypeFromVideoState(videoState);
    // TODO(vt): Is this sufficient?  At what point do we know the video state of the call?
    conn.setVideoState(videoState);
    try {
        String[] callees = new String[] { conn.getAddress() };
        ImsCallProfile profile = mImsManager.createCallProfile(mServiceId, serviceType, callType);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_OIR, clirMode);
        // ImsCallProfile key.
        if (intentExtras != null) {
            if (intentExtras.containsKey(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)) {
                intentExtras.putString(ImsCallProfile.EXTRA_DISPLAY_TEXT, cleanseInstantLetteringMessage(intentExtras.getString(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)));
            }
            if (intentExtras.containsKey(ImsCallProfile.EXTRA_IS_CALL_PULL)) {
                profile.mCallExtras.putBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL, intentExtras.getBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL));
                int dialogId = intentExtras.getInt(ImsExternalCallTracker.EXTRA_IMS_EXTERNAL_CALL_ID);
                conn.setIsPulledCall(true);
                conn.setPulledDialogId(dialogId);
            }
            // Pack the OEM-specific call extras.
            profile.mCallExtras.putBundle(ImsCallProfile.EXTRA_OEM_EXTRAS, intentExtras);
        // NOTE: Extras to be sent over the network are packed into the
        // intentExtras individually, with uniquely defined keys.
        // These key-value pairs are processed by IMS Service before
        // being sent to the lower layers/to the network.
        }
        ImsCall imsCall = mImsManager.makeCall(mServiceId, profile, callees, mImsCallListener);
        conn.setImsCall(imsCall);
        mMetrics.writeOnImsCallStart(mPhone.getPhoneId(), imsCall.getSession());
        setVideoCallProvider(conn, imsCall);
        conn.setAllowAddCallDuringVideoCall(mAllowAddCallDuringVideoCall);
    } catch (ImsException e) {
        loge("dialInternal : " + e);
        conn.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        retryGetImsService();
    } catch (RemoteException e) {
    }
}
#method_after
private void dialInternal(ImsPhoneConnection conn, int clirMode, int videoState, Bundle intentExtras) {
    if (conn == null) {
        return;
    }
    if (conn.getAddress() == null || conn.getAddress().length() == 0 || conn.getAddress().indexOf(PhoneNumberUtils.WILD) >= 0) {
        // Phone number is invalid
        conn.setDisconnectCause(DisconnectCause.INVALID_NUMBER);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        return;
    }
    // Always unmute when initiating a new call
    setMute(false);
    int serviceType = mPhoneNumberUtilsProxy.isEmergencyNumber(conn.getAddress()) ? ImsCallProfile.SERVICE_TYPE_EMERGENCY : ImsCallProfile.SERVICE_TYPE_NORMAL;
    int callType = ImsCallProfile.getCallTypeFromVideoState(videoState);
    // TODO(vt): Is this sufficient?  At what point do we know the video state of the call?
    conn.setVideoState(videoState);
    try {
        String[] callees = new String[] { conn.getAddress() };
        ImsCallProfile profile = mImsManager.createCallProfile(serviceType, callType);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_OIR, clirMode);
        // ImsCallProfile key.
        if (intentExtras != null) {
            if (intentExtras.containsKey(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)) {
                intentExtras.putString(ImsCallProfile.EXTRA_DISPLAY_TEXT, cleanseInstantLetteringMessage(intentExtras.getString(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)));
            }
            if (conn.hasRttTextStream()) {
                profile.mMediaProfile.mRttMode = ImsStreamMediaProfile.RTT_MODE_FULL;
            }
            if (intentExtras.containsKey(ImsCallProfile.EXTRA_IS_CALL_PULL)) {
                profile.mCallExtras.putBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL, intentExtras.getBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL));
                int dialogId = intentExtras.getInt(ImsExternalCallTracker.EXTRA_IMS_EXTERNAL_CALL_ID);
                conn.setIsPulledCall(true);
                conn.setPulledDialogId(dialogId);
            }
            // Pack the OEM-specific call extras.
            profile.mCallExtras.putBundle(ImsCallProfile.EXTRA_OEM_EXTRAS, intentExtras);
        // NOTE: Extras to be sent over the network are packed into the
        // intentExtras individually, with uniquely defined keys.
        // These key-value pairs are processed by IMS Service before
        // being sent to the lower layers/to the network.
        }
        ImsCall imsCall = mImsManager.makeCall(profile, callees, mImsCallListener);
        conn.setImsCall(imsCall);
        mMetrics.writeOnImsCallStart(mPhone.getPhoneId(), imsCall.getSession());
        setVideoCallProvider(conn, imsCall);
        conn.setAllowAddCallDuringVideoCall(mAllowAddCallDuringVideoCall);
    } catch (ImsException e) {
        loge("dialInternal : " + e);
        conn.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        retryGetImsService();
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
public void sendUSSD(String ussdString, Message response) {
    if (DBG)
        log("sendUSSD");
    try {
        if (mUssdSession != null) {
            mUssdSession.sendUssd(ussdString);
            AsyncResult.forMessage(response, null, null);
            response.sendToTarget();
            return;
        }
        if (mImsManager == null) {
            mPhone.sendErrorResponse(response, getImsManagerIsNullException());
            return;
        }
        String[] callees = new String[] { ussdString };
        ImsCallProfile profile = mImsManager.createCallProfile(mServiceId, ImsCallProfile.SERVICE_TYPE_NORMAL, ImsCallProfile.CALL_TYPE_VOICE);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_DIALSTRING, ImsCallProfile.DIALSTRING_USSD);
        mUssdSession = mImsManager.makeCall(mServiceId, profile, callees, mImsUssdListener);
    } catch (ImsException e) {
        loge("sendUSSD : " + e);
        mPhone.sendErrorResponse(response, e);
        retryGetImsService();
    }
}
#method_after
public void sendUSSD(String ussdString, Message response) {
    if (DBG)
        log("sendUSSD");
    try {
        if (mUssdSession != null) {
            mUssdSession.sendUssd(ussdString);
            AsyncResult.forMessage(response, null, null);
            response.sendToTarget();
            return;
        }
        if (mImsManager == null) {
            mPhone.sendErrorResponse(response, getImsManagerIsNullException());
            return;
        }
        String[] callees = new String[] { ussdString };
        ImsCallProfile profile = mImsManager.createCallProfile(ImsCallProfile.SERVICE_TYPE_NORMAL, ImsCallProfile.CALL_TYPE_VOICE);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_DIALSTRING, ImsCallProfile.DIALSTRING_USSD);
        mUssdSession = mImsManager.makeCall(profile, callees, mImsUssdListener);
    } catch (ImsException e) {
        loge("sendUSSD : " + e);
        mPhone.sendErrorResponse(response, e);
        retryGetImsService();
    }
}
#end_block

#method_before
@VisibleForTesting
public int getDisconnectCauseFromReasonInfo(ImsReasonInfo reasonInfo, Call.State callState) {
    int cause = DisconnectCause.ERROR_UNSPECIFIED;
    int code = maybeRemapReasonCode(reasonInfo);
    switch(code) {
        case ImsReasonInfo.CODE_SIP_BAD_ADDRESS:
        case ImsReasonInfo.CODE_SIP_NOT_REACHABLE:
            return DisconnectCause.NUMBER_UNREACHABLE;
        case ImsReasonInfo.CODE_SIP_BUSY:
            return DisconnectCause.BUSY;
        case ImsReasonInfo.CODE_USER_TERMINATED:
            return DisconnectCause.LOCAL;
        case ImsReasonInfo.CODE_LOCAL_ENDED_BY_CONFERENCE_MERGE:
            return DisconnectCause.IMS_MERGED_SUCCESSFULLY;
        case ImsReasonInfo.CODE_LOCAL_CALL_DECLINE:
        case ImsReasonInfo.CODE_REMOTE_CALL_DECLINE:
            // another device using multiendpoint functionality), mark it as rejected.
            return DisconnectCause.INCOMING_REJECTED;
        case ImsReasonInfo.CODE_USER_TERMINATED_BY_REMOTE:
            return DisconnectCause.NORMAL;
        case ImsReasonInfo.CODE_SIP_FORBIDDEN:
            return DisconnectCause.SERVER_ERROR;
        case ImsReasonInfo.CODE_SIP_REDIRECTED:
        case ImsReasonInfo.CODE_SIP_BAD_REQUEST:
        case ImsReasonInfo.CODE_SIP_NOT_ACCEPTABLE:
        case ImsReasonInfo.CODE_SIP_USER_REJECTED:
        case ImsReasonInfo.CODE_SIP_GLOBAL_ERROR:
            return DisconnectCause.SERVER_ERROR;
        case ImsReasonInfo.CODE_SIP_SERVICE_UNAVAILABLE:
        case ImsReasonInfo.CODE_SIP_NOT_FOUND:
        case ImsReasonInfo.CODE_SIP_SERVER_ERROR:
            return DisconnectCause.SERVER_UNREACHABLE;
        case ImsReasonInfo.CODE_LOCAL_NETWORK_ROAMING:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_IP_CHANGED:
        case ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN:
        case ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE:
        case ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_NO_LTE_COVERAGE:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_NO_SERVICE:
        case ImsReasonInfo.CODE_LOCAL_CALL_VCC_ON_PROGRESSING:
            return DisconnectCause.OUT_OF_SERVICE;
        case ImsReasonInfo.CODE_SIP_REQUEST_TIMEOUT:
        case ImsReasonInfo.CODE_TIMEOUT_1XX_WAITING:
        case ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER:
        case ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER_CALL_UPDATE:
            return DisconnectCause.TIMED_OUT;
        case ImsReasonInfo.CODE_LOCAL_POWER_OFF:
            return DisconnectCause.POWER_OFF;
        case ImsReasonInfo.CODE_LOCAL_LOW_BATTERY:
        case ImsReasonInfo.CODE_LOW_BATTERY:
            {
                if (callState == Call.State.DIALING) {
                    return DisconnectCause.DIAL_LOW_BATTERY;
                } else {
                    return DisconnectCause.LOW_BATTERY;
                }
            }
        case ImsReasonInfo.CODE_FDN_BLOCKED:
            return DisconnectCause.FDN_BLOCKED;
        case ImsReasonInfo.CODE_IMEI_NOT_ACCEPTED:
            return DisconnectCause.IMEI_NOT_ACCEPTED;
        case ImsReasonInfo.CODE_ANSWERED_ELSEWHERE:
            return DisconnectCause.ANSWERED_ELSEWHERE;
        case ImsReasonInfo.CODE_CALL_END_CAUSE_CALL_PULL:
            return DisconnectCause.CALL_PULLED;
        case ImsReasonInfo.CODE_MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return DisconnectCause.MAXIMUM_NUMBER_OF_CALLS_REACHED;
        case ImsReasonInfo.CODE_DATA_DISABLED:
            return DisconnectCause.DATA_DISABLED;
        case ImsReasonInfo.CODE_DATA_LIMIT_REACHED:
            return DisconnectCause.DATA_LIMIT_REACHED;
        case ImsReasonInfo.CODE_WIFI_LOST:
            return DisconnectCause.WIFI_LOST;
        case ImsReasonInfo.CODE_ACCESS_CLASS_BLOCKED:
            return DisconnectCause.IMS_ACCESS_BLOCKED;
        case ImsReasonInfo.CODE_EMERGENCY_TEMP_FAILURE:
            return DisconnectCause.EMERGENCY_TEMP_FAILURE;
        case ImsReasonInfo.CODE_EMERGENCY_PERM_FAILURE:
            return DisconnectCause.EMERGENCY_PERM_FAILURE;
        default:
    }
    return cause;
}
#method_after
@VisibleForTesting
public int getDisconnectCauseFromReasonInfo(ImsReasonInfo reasonInfo, Call.State callState) {
    int cause = DisconnectCause.ERROR_UNSPECIFIED;
    int code = maybeRemapReasonCode(reasonInfo);
    switch(code) {
        case ImsReasonInfo.CODE_SIP_ALTERNATE_EMERGENCY_CALL:
            return DisconnectCause.IMS_SIP_ALTERNATE_EMERGENCY_CALL;
        case ImsReasonInfo.CODE_SIP_BAD_ADDRESS:
        case ImsReasonInfo.CODE_SIP_NOT_REACHABLE:
            return DisconnectCause.NUMBER_UNREACHABLE;
        case ImsReasonInfo.CODE_SIP_BUSY:
            return DisconnectCause.BUSY;
        case ImsReasonInfo.CODE_USER_TERMINATED:
            return DisconnectCause.LOCAL;
        case ImsReasonInfo.CODE_LOCAL_ENDED_BY_CONFERENCE_MERGE:
            return DisconnectCause.IMS_MERGED_SUCCESSFULLY;
        case ImsReasonInfo.CODE_LOCAL_CALL_DECLINE:
        case ImsReasonInfo.CODE_REMOTE_CALL_DECLINE:
            // another device using multiendpoint functionality), mark it as rejected.
            return DisconnectCause.INCOMING_REJECTED;
        case ImsReasonInfo.CODE_USER_TERMINATED_BY_REMOTE:
            return DisconnectCause.NORMAL;
        case ImsReasonInfo.CODE_SIP_FORBIDDEN:
            return DisconnectCause.SERVER_ERROR;
        case ImsReasonInfo.CODE_SIP_REDIRECTED:
        case ImsReasonInfo.CODE_SIP_BAD_REQUEST:
        case ImsReasonInfo.CODE_SIP_NOT_ACCEPTABLE:
        case ImsReasonInfo.CODE_SIP_USER_REJECTED:
        case ImsReasonInfo.CODE_SIP_GLOBAL_ERROR:
            return DisconnectCause.SERVER_ERROR;
        case ImsReasonInfo.CODE_SIP_SERVICE_UNAVAILABLE:
        case ImsReasonInfo.CODE_SIP_NOT_FOUND:
        case ImsReasonInfo.CODE_SIP_SERVER_ERROR:
            return DisconnectCause.SERVER_UNREACHABLE;
        case ImsReasonInfo.CODE_LOCAL_NETWORK_ROAMING:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_IP_CHANGED:
        case ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN:
        case ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE:
        case ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_NO_LTE_COVERAGE:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_NO_SERVICE:
        case ImsReasonInfo.CODE_LOCAL_CALL_VCC_ON_PROGRESSING:
            return DisconnectCause.OUT_OF_SERVICE;
        case ImsReasonInfo.CODE_SIP_REQUEST_TIMEOUT:
        case ImsReasonInfo.CODE_TIMEOUT_1XX_WAITING:
        case ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER:
        case ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER_CALL_UPDATE:
            return DisconnectCause.TIMED_OUT;
        case ImsReasonInfo.CODE_LOCAL_POWER_OFF:
            return DisconnectCause.POWER_OFF;
        case ImsReasonInfo.CODE_LOCAL_LOW_BATTERY:
        case ImsReasonInfo.CODE_LOW_BATTERY:
            {
                if (callState == Call.State.DIALING) {
                    return DisconnectCause.DIAL_LOW_BATTERY;
                } else {
                    return DisconnectCause.LOW_BATTERY;
                }
            }
        case ImsReasonInfo.CODE_CALL_BARRED:
            return DisconnectCause.CALL_BARRED;
        case ImsReasonInfo.CODE_FDN_BLOCKED:
            return DisconnectCause.FDN_BLOCKED;
        case ImsReasonInfo.CODE_IMEI_NOT_ACCEPTED:
            return DisconnectCause.IMEI_NOT_ACCEPTED;
        case ImsReasonInfo.CODE_ANSWERED_ELSEWHERE:
            return DisconnectCause.ANSWERED_ELSEWHERE;
        case ImsReasonInfo.CODE_CALL_END_CAUSE_CALL_PULL:
            return DisconnectCause.CALL_PULLED;
        case ImsReasonInfo.CODE_MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return DisconnectCause.MAXIMUM_NUMBER_OF_CALLS_REACHED;
        case ImsReasonInfo.CODE_DATA_DISABLED:
            return DisconnectCause.DATA_DISABLED;
        case ImsReasonInfo.CODE_DATA_LIMIT_REACHED:
            return DisconnectCause.DATA_LIMIT_REACHED;
        case ImsReasonInfo.CODE_WIFI_LOST:
            return DisconnectCause.WIFI_LOST;
        case ImsReasonInfo.CODE_ACCESS_CLASS_BLOCKED:
            return DisconnectCause.IMS_ACCESS_BLOCKED;
        case ImsReasonInfo.CODE_EMERGENCY_TEMP_FAILURE:
            return DisconnectCause.EMERGENCY_TEMP_FAILURE;
        case ImsReasonInfo.CODE_EMERGENCY_PERM_FAILURE:
            return DisconnectCause.EMERGENCY_PERM_FAILURE;
        case ImsReasonInfo.CODE_DIAL_MODIFIED_TO_USSD:
            return DisconnectCause.DIAL_MODIFIED_TO_USSD;
        case ImsReasonInfo.CODE_DIAL_MODIFIED_TO_SS:
            return DisconnectCause.DIAL_MODIFIED_TO_SS;
        case ImsReasonInfo.CODE_DIAL_MODIFIED_TO_DIAL:
            return DisconnectCause.DIAL_MODIFIED_TO_DIAL;
        case ImsReasonInfo.CODE_DIAL_MODIFIED_TO_DIAL_VIDEO:
            return DisconnectCause.DIAL_MODIFIED_TO_DIAL_VIDEO;
        case ImsReasonInfo.CODE_DIAL_VIDEO_MODIFIED_TO_DIAL:
            return DisconnectCause.DIAL_VIDEO_MODIFIED_TO_DIAL;
        case ImsReasonInfo.CODE_DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
            return DisconnectCause.DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO;
        case ImsReasonInfo.CODE_DIAL_VIDEO_MODIFIED_TO_SS:
            return DisconnectCause.DIAL_VIDEO_MODIFIED_TO_SS;
        case ImsReasonInfo.CODE_DIAL_VIDEO_MODIFIED_TO_USSD:
            return DisconnectCause.DIAL_VIDEO_MODIFIED_TO_USSD;
        default:
    }
    return cause;
}
#end_block

#method_before
private boolean isPhoneInEcbMode() {
    return mPhone.isInEcm();
}
#method_after
private boolean isPhoneInEcbMode() {
    return mPhone != null && mPhone.isInEcm();
}
#end_block

#method_before
// ****** Overridden from Handler
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    if (DBG)
        log("handleMessage what=" + msg.what);
    switch(msg.what) {
        case EVENT_HANGUP_PENDINGMO:
            if (mPendingMO != null) {
                mPendingMO.onDisconnect();
                removeConnection(mPendingMO);
                mPendingMO = null;
            }
            mPendingIntentExtras = null;
            updatePhoneState();
            mPhone.notifyPreciseCallStateChanged();
            break;
        case EVENT_RESUME_BACKGROUND:
            try {
                resumeWaitingOrHolding();
            } catch (CallStateException e) {
                if (Phone.DEBUG_PHONE) {
                    loge("handleMessage EVENT_RESUME_BACKGROUND exception=" + e);
                }
            }
            break;
        case EVENT_DIAL_PENDINGMO:
            dialInternal(mPendingMO, mClirMode, mPendingCallVideoState, mPendingIntentExtras);
            mPendingIntentExtras = null;
            break;
        case EVENT_EXIT_ECBM_BEFORE_PENDINGMO:
            if (mPendingMO != null) {
                // Send ECBM exit request
                try {
                    getEcbmInterface().exitEmergencyCallbackMode();
                    mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
                    pendingCallClirMode = mClirMode;
                    pendingCallInEcm = true;
                } catch (ImsException e) {
                    e.printStackTrace();
                    mPendingMO.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
                    sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
                }
            }
            break;
        case EVENT_EXIT_ECM_RESPONSE_CDMA:
            // no matter the result, we still do the same here
            if (pendingCallInEcm) {
                dialInternal(mPendingMO, pendingCallClirMode, mPendingCallVideoState, mPendingIntentExtras);
                mPendingIntentExtras = null;
                pendingCallInEcm = false;
            }
            mPhone.unsetOnEcbModeExitResponse(this);
            break;
        case EVENT_VT_DATA_USAGE_UPDATE:
            ar = (AsyncResult) msg.obj;
            ImsCall call = (ImsCall) ar.userObj;
            Long usage = (long) ar.result;
            log("VT data usage update. usage = " + usage + ", imsCall = " + call);
            if (usage > 0) {
                updateVtDataUsage(call, usage);
            }
            break;
        case EVENT_DATA_ENABLED_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.result instanceof Pair) {
                Pair<Boolean, Integer> p = (Pair<Boolean, Integer>) ar.result;
                onDataEnabledChanged(p.first, p.second);
            }
            break;
        case EVENT_GET_IMS_SERVICE:
            try {
                getImsService();
            } catch (ImsException e) {
                loge("getImsService: " + e);
                retryGetImsService();
            }
            break;
        case EVENT_CHECK_FOR_WIFI_HANDOVER:
            if (msg.obj instanceof ImsCall) {
                ImsCall imsCall = (ImsCall) msg.obj;
                if (!imsCall.isWifiCall()) {
                    // Call did not handover to wifi, notify of handover failure.
                    ImsPhoneConnection conn = findConnection(imsCall);
                    if (conn != null) {
                        conn.onHandoverToWifiFailed();
                    }
                }
            }
            break;
        case EVENT_ON_FEATURE_CAPABILITY_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    int serviceClass = args.argi1;
                    int[] enabledFeatures = (int[]) args.arg1;
                    int[] disabledFeatures = (int[]) args.arg2;
                    handleFeatureCapabilityChanged(serviceClass, enabledFeatures, disabledFeatures);
                } finally {
                    args.recycle();
                }
                break;
            }
    }
}
#method_after
// ****** Overridden from Handler
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    if (DBG)
        log("handleMessage what=" + msg.what);
    switch(msg.what) {
        case EVENT_HANGUP_PENDINGMO:
            if (mPendingMO != null) {
                mPendingMO.onDisconnect();
                removeConnection(mPendingMO);
                mPendingMO = null;
            }
            mPendingIntentExtras = null;
            updatePhoneState();
            mPhone.notifyPreciseCallStateChanged();
            break;
        case EVENT_RESUME_BACKGROUND:
            try {
                resumeWaitingOrHolding();
            } catch (CallStateException e) {
                if (Phone.DEBUG_PHONE) {
                    loge("handleMessage EVENT_RESUME_BACKGROUND exception=" + e);
                }
            }
            break;
        case EVENT_DIAL_PENDINGMO:
            dialInternal(mPendingMO, mClirMode, mPendingCallVideoState, mPendingIntentExtras);
            mPendingIntentExtras = null;
            break;
        case EVENT_EXIT_ECBM_BEFORE_PENDINGMO:
            if (mPendingMO != null) {
                // Send ECBM exit request
                try {
                    getEcbmInterface().exitEmergencyCallbackMode();
                    mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
                    pendingCallClirMode = mClirMode;
                    pendingCallInEcm = true;
                } catch (ImsException e) {
                    e.printStackTrace();
                    mPendingMO.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
                    sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
                }
            }
            break;
        case EVENT_EXIT_ECM_RESPONSE_CDMA:
            // no matter the result, we still do the same here
            if (pendingCallInEcm) {
                dialInternal(mPendingMO, pendingCallClirMode, mPendingCallVideoState, mPendingIntentExtras);
                mPendingIntentExtras = null;
                pendingCallInEcm = false;
            }
            mPhone.unsetOnEcbModeExitResponse(this);
            break;
        case EVENT_VT_DATA_USAGE_UPDATE:
            ar = (AsyncResult) msg.obj;
            ImsCall call = (ImsCall) ar.userObj;
            Long usage = (long) ar.result;
            log("VT data usage update. usage = " + usage + ", imsCall = " + call);
            if (usage > 0) {
                updateVtDataUsage(call, usage);
            }
            break;
        case EVENT_DATA_ENABLED_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.result instanceof Pair) {
                Pair<Boolean, Integer> p = (Pair<Boolean, Integer>) ar.result;
                onDataEnabledChanged(p.first, p.second);
            }
            break;
        case EVENT_GET_IMS_SERVICE:
            try {
                getImsService();
            } catch (ImsException e) {
                loge("getImsService: " + e);
                retryGetImsService();
            }
            break;
        case EVENT_CHECK_FOR_WIFI_HANDOVER:
            if (msg.obj instanceof ImsCall) {
                ImsCall imsCall = (ImsCall) msg.obj;
                if (!imsCall.isWifiCall()) {
                    // Call did not handover to wifi, notify of handover failure.
                    ImsPhoneConnection conn = findConnection(imsCall);
                    if (conn != null) {
                        conn.onHandoverToWifiFailed();
                    }
                }
            }
            break;
        case EVENT_ON_FEATURE_CAPABILITY_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    ImsFeature.Capabilities capabilities = (ImsFeature.Capabilities) args.arg1;
                    handleFeatureCapabilityChanged(capabilities);
                } finally {
                    args.recycle();
                }
                break;
            }
        case EVENT_SUPP_SERVICE_INDICATION:
            {
                ar = (AsyncResult) msg.obj;
                ImsPhoneMmiCode mmiCode = new ImsPhoneMmiCode(mPhone);
                try {
                    mmiCode.setIsSsInfo(true);
                    mmiCode.processImsSsData(ar);
                } catch (ImsException e) {
                    Rlog.e(LOG_TAG, "Exception in parsing SS Data: " + e);
                }
                break;
            }
    }
}
#end_block

#method_before
private void updateVtDataUsage(ImsCall call, long dataUsage) {
    long oldUsage = 0L;
    if (mVtDataUsageMap.containsKey(call.uniqueId)) {
        oldUsage = mVtDataUsageMap.get(call.uniqueId);
    }
    long delta = dataUsage - oldUsage;
    mVtDataUsageMap.put(call.uniqueId, dataUsage);
    log("updateVtDataUsage: call=" + call + ", delta=" + delta);
    long currentTime = SystemClock.elapsedRealtime();
    int isRoaming = mPhone.getServiceState().getDataRoaming() ? 1 : 0;
    // Create the snapshot of total video call data usage.
    NetworkStats vtDataUsageSnapshot = new NetworkStats(currentTime, 1);
    vtDataUsageSnapshot.combineAllValues(mVtDataUsageSnapshot);
    // Since the modem only reports the total vt data usage rather than rx/tx separately,
    // the only thing we can do here is splitting the usage into half rx and half tx.
    // Uid -1 indicates this is for the overall device data usage.
    vtDataUsageSnapshot.combineValues(new NetworkStats.Entry(NetworkStatsService.VT_INTERFACE, -1, NetworkStats.SET_FOREGROUND, NetworkStats.TAG_NONE, 1, isRoaming, delta / 2, 0, delta / 2, 0, 0));
    mVtDataUsageSnapshot = vtDataUsageSnapshot;
    // Create the snapshot of video call data usage per dialer. combineValues will create
    // a separate entry if uid is different from the previous snapshot.
    NetworkStats vtDataUsageUidSnapshot = new NetworkStats(currentTime, 1);
    vtDataUsageUidSnapshot.combineAllValues(mVtDataUsageUidSnapshot);
    // default dialer uid is really not available.
    if (mDefaultDialerUid.get() == NetworkStats.UID_ALL) {
        final TelecomManager telecomManager = (TelecomManager) mPhone.getContext().getSystemService(Context.TELECOM_SERVICE);
        mDefaultDialerUid.set(getPackageUid(mPhone.getContext(), telecomManager.getDefaultDialerPackage()));
    }
    // Since the modem only reports the total vt data usage rather than rx/tx separately,
    // the only thing we can do here is splitting the usage into half rx and half tx.
    vtDataUsageUidSnapshot.combineValues(new NetworkStats.Entry(NetworkStatsService.VT_INTERFACE, mDefaultDialerUid.get(), NetworkStats.SET_FOREGROUND, NetworkStats.TAG_NONE, 1, isRoaming, delta / 2, 0, delta / 2, 0, 0));
    mVtDataUsageUidSnapshot = vtDataUsageUidSnapshot;
}
#method_after
private void updateVtDataUsage(ImsCall call, long dataUsage) {
    long oldUsage = 0L;
    if (mVtDataUsageMap.containsKey(call.uniqueId)) {
        oldUsage = mVtDataUsageMap.get(call.uniqueId);
    }
    long delta = dataUsage - oldUsage;
    mVtDataUsageMap.put(call.uniqueId, dataUsage);
    log("updateVtDataUsage: call=" + call + ", delta=" + delta);
    long currentTime = SystemClock.elapsedRealtime();
    int isRoaming = mPhone.getServiceState().getDataRoaming() ? 1 : 0;
    // Create the snapshot of total video call data usage.
    NetworkStats vtDataUsageSnapshot = new NetworkStats(currentTime, 1);
    vtDataUsageSnapshot.combineAllValues(mVtDataUsageSnapshot);
    // Since the modem only reports the total vt data usage rather than rx/tx separately,
    // the only thing we can do here is splitting the usage into half rx and half tx.
    // Uid -1 indicates this is for the overall device data usage.
    vtDataUsageSnapshot.combineValues(new NetworkStats.Entry(NetworkStatsService.VT_INTERFACE, -1, NetworkStats.SET_FOREGROUND, NetworkStats.TAG_NONE, NetworkStats.METERED_YES, isRoaming, NetworkStats.DEFAULT_NETWORK_YES, delta / 2, 0, delta / 2, 0, 0));
    mVtDataUsageSnapshot = vtDataUsageSnapshot;
    // Create the snapshot of video call data usage per dialer. combineValues will create
    // a separate entry if uid is different from the previous snapshot.
    NetworkStats vtDataUsageUidSnapshot = new NetworkStats(currentTime, 1);
    vtDataUsageUidSnapshot.combineAllValues(mVtDataUsageUidSnapshot);
    // default dialer uid is really not available.
    if (mDefaultDialerUid.get() == NetworkStats.UID_ALL) {
        final TelecomManager telecomManager = (TelecomManager) mPhone.getContext().getSystemService(Context.TELECOM_SERVICE);
        mDefaultDialerUid.set(getPackageUid(mPhone.getContext(), telecomManager.getDefaultDialerPackage()));
    }
    // Since the modem only reports the total vt data usage rather than rx/tx separately,
    // the only thing we can do here is splitting the usage into half rx and half tx.
    vtDataUsageUidSnapshot.combineValues(new NetworkStats.Entry(NetworkStatsService.VT_INTERFACE, mDefaultDialerUid.get(), NetworkStats.SET_FOREGROUND, NetworkStats.TAG_NONE, NetworkStats.METERED_YES, isRoaming, NetworkStats.DEFAULT_NETWORK_YES, delta / 2, 0, delta / 2, 0, 0));
    mVtDataUsageUidSnapshot = vtDataUsageUidSnapshot;
}
#end_block

#method_before
@Override
protected void log(String msg) {
    Rlog.d(LOG_TAG, "[ImsPhoneCallTracker][" + mPhone.getPhoneId() + "] " + msg);
}
#method_after
@Override
protected void log(String msg) {
    Rlog.d(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + msg);
}
#end_block

#method_before
protected void loge(String msg) {
    Rlog.e(LOG_TAG, "[ImsPhoneCallTracker][" + mPhone.getPhoneId() + "] " + msg);
}
#method_after
protected void loge(String msg) {
    Rlog.e(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + msg);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ImsPhoneCallTracker extends:");
    super.dump(fd, pw, args);
    pw.println(" mVoiceCallEndedRegistrants=" + mVoiceCallEndedRegistrants);
    pw.println(" mVoiceCallStartedRegistrants=" + mVoiceCallStartedRegistrants);
    pw.println(" mRingingCall=" + mRingingCall);
    pw.println(" mForegroundCall=" + mForegroundCall);
    pw.println(" mBackgroundCall=" + mBackgroundCall);
    pw.println(" mHandoverCall=" + mHandoverCall);
    pw.println(" mPendingMO=" + mPendingMO);
    // pw.println(" mHangupPendingMO=" + mHangupPendingMO);
    pw.println(" mPhone=" + mPhone);
    pw.println(" mDesiredMute=" + mDesiredMute);
    pw.println(" mState=" + mState);
    for (int i = 0; i < mImsFeatureEnabled.length; i++) {
        pw.println(" " + mImsFeatureStrings[i] + ": " + ((mImsFeatureEnabled[i]) ? "enabled" : "disabled"));
    }
    pw.println(" mDefaultDialerUid=" + mDefaultDialerUid.get());
    pw.println(" mVtDataUsageSnapshot=" + mVtDataUsageSnapshot);
    pw.println(" mVtDataUsageUidSnapshot=" + mVtDataUsageUidSnapshot);
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    try {
        if (mImsManager != null) {
            mImsManager.dump(fd, pw, args);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    if (mConnections != null && mConnections.size() > 0) {
        pw.println("mConnections:");
        for (int i = 0; i < mConnections.size(); i++) {
            pw.println("  [" + i + "]: " + mConnections.get(i));
        }
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ImsPhoneCallTracker extends:");
    super.dump(fd, pw, args);
    pw.println(" mVoiceCallEndedRegistrants=" + mVoiceCallEndedRegistrants);
    pw.println(" mVoiceCallStartedRegistrants=" + mVoiceCallStartedRegistrants);
    pw.println(" mRingingCall=" + mRingingCall);
    pw.println(" mForegroundCall=" + mForegroundCall);
    pw.println(" mBackgroundCall=" + mBackgroundCall);
    pw.println(" mHandoverCall=" + mHandoverCall);
    pw.println(" mPendingMO=" + mPendingMO);
    // pw.println(" mHangupPendingMO=" + mHangupPendingMO);
    pw.println(" mPhone=" + mPhone);
    pw.println(" mDesiredMute=" + mDesiredMute);
    pw.println(" mState=" + mState);
    pw.println(" mMmTelCapabilities=" + mMmTelCapabilities);
    pw.println(" mDefaultDialerUid=" + mDefaultDialerUid.get());
    pw.println(" mVtDataUsageSnapshot=" + mVtDataUsageSnapshot);
    pw.println(" mVtDataUsageUidSnapshot=" + mVtDataUsageUidSnapshot);
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    try {
        if (mImsManager != null) {
            mImsManager.dump(fd, pw, args);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    if (mConnections != null && mConnections.size() > 0) {
        pw.println("mConnections:");
        for (int i = 0; i < mConnections.size(); i++) {
            pw.println("  [" + i + "]: " + mConnections.get(i));
        }
    }
}
#end_block

#method_before
ImsEcbm getEcbmInterface() throws ImsException {
    if (mImsManager == null) {
        throw getImsManagerIsNullException();
    }
    ImsEcbm ecbm = mImsManager.getEcbmInterface(mServiceId);
    return ecbm;
}
#method_after
ImsEcbm getEcbmInterface() throws ImsException {
    if (mImsManager == null) {
        throw getImsManagerIsNullException();
    }
    ImsEcbm ecbm = mImsManager.getEcbmInterface();
    return ecbm;
}
#end_block

#method_before
ImsMultiEndpoint getMultiEndpointInterface() throws ImsException {
    if (mImsManager == null) {
        throw getImsManagerIsNullException();
    }
    try {
        return mImsManager.getMultiEndpointInterface(mServiceId);
    } catch (ImsException e) {
        if (e.getCode() == ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED) {
            return null;
        } else {
            throw e;
        }
    }
}
#method_after
ImsMultiEndpoint getMultiEndpointInterface() throws ImsException {
    if (mImsManager == null) {
        throw getImsManagerIsNullException();
    }
    try {
        return mImsManager.getMultiEndpointInterface();
    } catch (ImsException e) {
        if (e.getCode() == ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED) {
            return null;
        } else {
            throw e;
        }
    }
}
#end_block

#method_before
public boolean isVolteEnabled() {
    return mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE];
}
#method_after
public boolean isVolteEnabled() {
    boolean isRadioTechLte = getImsRegistrationTech() == ImsRegistrationImplBase.REGISTRATION_TECH_LTE;
    return isRadioTechLte && mMmTelCapabilities.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
}
#end_block

#method_before
public boolean isVowifiEnabled() {
    return mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI];
}
#method_after
public boolean isVowifiEnabled() {
    boolean isRadioTechIwlan = getImsRegistrationTech() == ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN;
    return isRadioTechIwlan && mMmTelCapabilities.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
}
#end_block

#method_before
public boolean isVideoCallEnabled() {
    return (mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE] || mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_WIFI]);
}
#method_after
public boolean isVideoCallEnabled() {
    return mMmTelCapabilities.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
}
#end_block

#method_before
private void retryGetImsService() {
    // The binder connection is already up. Do not try to get it again.
    if (mImsManager.isServiceAvailable()) {
        return;
    }
    // Leave mImsManager as null, then CallStateException will be thrown when dialing
    mImsManager = null;
    // Exponential backoff during retry, limited to 32 seconds.
    loge("getImsService: Retrying getting ImsService...");
    removeMessages(EVENT_GET_IMS_SERVICE);
    sendEmptyMessageDelayed(EVENT_GET_IMS_SERVICE, mRetryTimeout.get());
}
#method_after
private void retryGetImsService() {
    // The binder connection is already up. Do not try to get it again.
    if (mImsManager.isServiceAvailable()) {
        return;
    }
    // remove callback so we do not receive updates from old ImsServiceProxy when switching
    // between ImsServices.
    mImsManager.removeNotifyStatusChangedCallback(mNotifyStatusChangedCallback);
    // Leave mImsManager as null, then CallStateException will be thrown when dialing
    mImsManager = null;
    // Exponential backoff during retry, limited to 32 seconds.
    loge("getImsService: Retrying getting ImsService...");
    removeMessages(EVENT_GET_IMS_SERVICE);
    sendEmptyMessageDelayed(EVENT_GET_IMS_SERVICE, mRetryTimeout.get());
}
#end_block

#method_before
public boolean isUtEnabled() {
    return (mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_UT_OVER_LTE] || mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_UT_OVER_WIFI]);
}
#method_after
public boolean isUtEnabled() {
    return mMmTelCapabilities.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT);
}
#end_block

#method_before
private boolean shouldDisconnectActiveCallOnAnswer(ImsCall activeCall, ImsCall incomingCall) {
    if (activeCall == null || incomingCall == null) {
        return false;
    }
    if (!mDropVideoCallWhenAnsweringAudioCall) {
        return false;
    }
    boolean isActiveCallVideo = activeCall.isVideoCall() || (mTreatDowngradedVideoCallsAsVideoCalls && activeCall.wasVideoCall());
    boolean isActiveCallOnWifi = activeCall.isWifiCall();
    boolean isVoWifiEnabled = mImsManager.isWfcEnabledByPlatform(mPhone.getContext()) && mImsManager.isWfcEnabledByUser(mPhone.getContext());
    boolean isIncomingCallAudio = !incomingCall.isVideoCall();
    log("shouldDisconnectActiveCallOnAnswer : isActiveCallVideo=" + isActiveCallVideo + " isActiveCallOnWifi=" + isActiveCallOnWifi + " isIncomingCallAudio=" + isIncomingCallAudio + " isVowifiEnabled=" + isVoWifiEnabled);
    return isActiveCallVideo && isActiveCallOnWifi && isIncomingCallAudio && !isVoWifiEnabled;
}
#method_after
private boolean shouldDisconnectActiveCallOnAnswer(ImsCall activeCall, ImsCall incomingCall) {
    if (activeCall == null || incomingCall == null) {
        return false;
    }
    if (!mDropVideoCallWhenAnsweringAudioCall) {
        return false;
    }
    boolean isActiveCallVideo = activeCall.isVideoCall() || (mTreatDowngradedVideoCallsAsVideoCalls && activeCall.wasVideoCall());
    boolean isActiveCallOnWifi = activeCall.isWifiCall();
    boolean isVoWifiEnabled = mImsManager.isWfcEnabledByPlatform() && mImsManager.isWfcEnabledByUser();
    boolean isIncomingCallAudio = !incomingCall.isVideoCall();
    log("shouldDisconnectActiveCallOnAnswer : isActiveCallVideo=" + isActiveCallVideo + " isActiveCallOnWifi=" + isActiveCallOnWifi + " isIncomingCallAudio=" + isIncomingCallAudio + " isVowifiEnabled=" + isVoWifiEnabled);
    return isActiveCallVideo && isActiveCallOnWifi && isIncomingCallAudio && !isVoWifiEnabled;
}
#end_block

#method_before
private void onDataEnabledChanged(boolean enabled, int reason) {
    log("onDataEnabledChanged: enabled=" + enabled + ", reason=" + reason);
    ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId()).setDataEnabled(enabled);
    mIsDataEnabled = enabled;
    if (!mIsViLteDataMetered) {
        log("Ignore data " + ((enabled) ? "enabled" : "disabled") + " - carrier policy " + "indicates that data is not metered for ViLTE calls.");
        return;
    }
    // if this is an LTE call.
    for (ImsPhoneConnection conn : mConnections) {
        conn.handleDataEnabledChange(enabled);
    }
    int reasonCode;
    if (reason == DataEnabledSettings.REASON_POLICY_DATA_ENABLED) {
        reasonCode = ImsReasonInfo.CODE_DATA_LIMIT_REACHED;
    } else if (reason == DataEnabledSettings.REASON_USER_DATA_ENABLED) {
        reasonCode = ImsReasonInfo.CODE_DATA_DISABLED;
    } else {
        // Unexpected code, default to data disabled.
        reasonCode = ImsReasonInfo.CODE_DATA_DISABLED;
    }
    // Potentially send connection events so the InCall UI knows that video calls are being
    // downgraded due to data being enabled/disabled.
    maybeNotifyDataDisabled(enabled, reasonCode);
    // Handle video state changes required as a result of data being enabled/disabled.
    handleDataEnabledChange(enabled, reasonCode);
    // the carrier config has loaded and will deregister IMS.
    if (!mShouldUpdateImsConfigOnDisconnect && reason != DataEnabledSettings.REASON_REGISTERED) {
        // This will call into updateVideoCallFeatureValue and eventually all clients will be
        // asynchronously notified that the availability of VT over LTE has changed.
        ImsManager.updateImsServiceConfig(mPhone.getContext(), mPhone.getPhoneId(), true);
    }
}
#method_after
private void onDataEnabledChanged(boolean enabled, int reason) {
    log("onDataEnabledChanged: enabled=" + enabled + ", reason=" + reason);
    mIsDataEnabled = enabled;
    if (!mIsViLteDataMetered) {
        log("Ignore data " + ((enabled) ? "enabled" : "disabled") + " - carrier policy " + "indicates that data is not metered for ViLTE calls.");
        return;
    }
    // if this is an LTE call.
    for (ImsPhoneConnection conn : mConnections) {
        conn.handleDataEnabledChange(enabled);
    }
    int reasonCode;
    if (reason == DataEnabledSettings.REASON_POLICY_DATA_ENABLED) {
        reasonCode = ImsReasonInfo.CODE_DATA_LIMIT_REACHED;
    } else if (reason == DataEnabledSettings.REASON_USER_DATA_ENABLED) {
        reasonCode = ImsReasonInfo.CODE_DATA_DISABLED;
    } else {
        // Unexpected code, default to data disabled.
        reasonCode = ImsReasonInfo.CODE_DATA_DISABLED;
    }
    // Potentially send connection events so the InCall UI knows that video calls are being
    // downgraded due to data being enabled/disabled.
    maybeNotifyDataDisabled(enabled, reasonCode);
    // Handle video state changes required as a result of data being enabled/disabled.
    handleDataEnabledChange(enabled, reasonCode);
    // the carrier config has loaded and will deregister IMS.
    if (!mShouldUpdateImsConfigOnDisconnect && reason != DataEnabledSettings.REASON_REGISTERED && mCarrierConfigLoaded) {
        // asynchronously notified that the availability of VT over LTE has changed.
        if (mImsManager != null) {
            mImsManager.updateImsServiceConfig(true);
        }
    }
}
#end_block

#method_before
private void resetImsCapabilities() {
    log("Resetting Capabilities...");
    for (int i = 0; i < mImsFeatureEnabled.length; i++) {
        mImsFeatureEnabled[i] = false;
    }
}
#method_after
private void resetImsCapabilities() {
    log("Resetting Capabilities...");
    mMmTelCapabilities = new MmTelFeature.MmTelCapabilities();
}
#end_block

#method_before
private void handleFeatureCapabilityChanged(int serviceClass, int[] enabledFeatures, int[] disabledFeatures) {
    if (serviceClass == ImsServiceClass.MMTEL) {
        boolean tmpIsVideoCallEnabled = isVideoCallEnabled();
        // Check enabledFeatures to determine capabilities. We ignore disabledFeatures.
        StringBuilder sb;
        if (DBG) {
            sb = new StringBuilder(120);
            sb.append("handleFeatureCapabilityChanged: ");
        }
        for (int i = ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE; i <= ImsConfig.FeatureConstants.FEATURE_TYPE_UT_OVER_WIFI && i < enabledFeatures.length; i++) {
            if (enabledFeatures[i] == i) {
                // If the feature is set to its own integer value it is enabled.
                if (DBG) {
                    sb.append(mImsFeatureStrings[i]);
                    sb.append(":true ");
                }
                mImsFeatureEnabled[i] = true;
            } else if (enabledFeatures[i] == ImsConfig.FeatureConstants.FEATURE_TYPE_UNKNOWN) {
                // FEATURE_TYPE_UNKNOWN indicates that a feature is disabled.
                if (DBG) {
                    sb.append(mImsFeatureStrings[i]);
                    sb.append(":false ");
                }
                mImsFeatureEnabled[i] = false;
            } else {
                // Feature has unknown state; it is not its own value or -1.
                if (DBG) {
                    loge("handleFeatureCapabilityChanged(" + i + ", " + mImsFeatureStrings[i] + "): unexpectedValue=" + enabledFeatures[i]);
                }
            }
        }
        boolean isVideoEnabled = isVideoCallEnabled();
        boolean isVideoEnabledStatechanged = tmpIsVideoCallEnabled != isVideoEnabled;
        if (DBG) {
            sb.append(" isVideoEnabledStateChanged=");
            sb.append(isVideoEnabledStatechanged);
        }
        if (isVideoEnabledStatechanged) {
            log("handleFeatureCapabilityChanged - notifyForVideoCapabilityChanged=" + isVideoEnabled);
            mPhone.notifyForVideoCapabilityChanged(isVideoEnabled);
        }
        if (DBG) {
            log(sb.toString());
        }
        if (DBG)
            log("handleFeatureCapabilityChanged: isVolteEnabled=" + isVolteEnabled() + ", isVideoCallEnabled=" + isVideoCallEnabled() + ", isVowifiEnabled=" + isVowifiEnabled() + ", isUtEnabled=" + isUtEnabled());
        mPhone.onFeatureCapabilityChanged();
        mMetrics.writeOnImsCapabilities(mPhone.getPhoneId(), mImsFeatureEnabled);
    }
}
#method_after
private void handleFeatureCapabilityChanged(ImsFeature.Capabilities capabilities) {
    boolean tmpIsVideoCallEnabled = isVideoCallEnabled();
    // Check enabledFeatures to determine capabilities. We ignore disabledFeatures.
    StringBuilder sb;
    if (DBG) {
        sb = new StringBuilder(120);
        sb.append("handleFeatureCapabilityChanged: ");
    }
    sb.append(capabilities);
    mMmTelCapabilities = new MmTelFeature.MmTelCapabilities(capabilities);
    boolean isVideoEnabled = isVideoCallEnabled();
    boolean isVideoEnabledStatechanged = tmpIsVideoCallEnabled != isVideoEnabled;
    if (DBG) {
        sb.append(" isVideoEnabledStateChanged=");
        sb.append(isVideoEnabledStatechanged);
    }
    if (isVideoEnabledStatechanged) {
        log("handleFeatureCapabilityChanged - notifyForVideoCapabilityChanged=" + isVideoEnabled);
        mPhone.notifyForVideoCapabilityChanged(isVideoEnabled);
    }
    if (DBG)
        log(sb.toString());
    if (DBG) {
        log("handleFeatureCapabilityChanged: isVolteEnabled=" + isVolteEnabled() + ", isVideoCallEnabled=" + isVideoCallEnabled() + ", isVowifiEnabled=" + isVowifiEnabled() + ", isUtEnabled=" + isUtEnabled());
    }
    mPhone.onFeatureCapabilityChanged();
    mMetrics.writeOnImsCapabilities(mPhone.getPhoneId(), getImsRegistrationTech(), mMmTelCapabilities);
}
#end_block

#method_before
public void waitForIdle(int timeoutMsAsInt) {
    long timeoutMs = timeoutMsAsInt;
    waitForIdleHandler(mService.mHandlerThread, timeoutMs);
    waitForIdle(mCellNetworkAgent, timeoutMs);
    waitForIdle(mWiFiNetworkAgent, timeoutMs);
    waitForIdle(mEthernetNetworkAgent, timeoutMs);
    waitForIdleHandler(mService.mHandlerThread, timeoutMs);
}
#method_after
public void waitForIdle(int timeoutMsAsInt) {
    long timeoutMs = timeoutMsAsInt;
    waitForIdleHandler(mService.mHandlerThread, timeoutMs);
    waitForIdle(mCellNetworkAgent, timeoutMs);
    waitForIdle(mWiFiNetworkAgent, timeoutMs);
    waitForIdle(mEthernetNetworkAgent, timeoutMs);
    waitForIdleHandler(mService.mHandlerThread, timeoutMs);
    waitForIdleLooper(ConnectivityThread.getInstanceLooper(), timeoutMs);
}
#end_block

#method_before
@Test
public void testNetworkGoesIntoBackgroundAfterLinger() {
    setMobileDataAlwaysOn(true);
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    // Wifi comes up and cell lingers.
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableDoubleValidatedCallbacks(mWiFiNetworkAgent);
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // File a request for cellular, then release it.
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacksValidated(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    mCm.unregisterNetworkCallback(defaultCallback);
    mCm.unregisterNetworkCallback(callback);
}
#method_after
@Test
public void testNetworkGoesIntoBackgroundAfterLinger() {
    setMobileDataAlwaysOn(true);
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    // Wifi comes up and cell lingers.
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableDoubleValidatedCallbacks(mWiFiNetworkAgent);
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // File a request for cellular, then release it.
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mCm.unregisterNetworkCallback(defaultCallback);
    mCm.unregisterNetworkCallback(callback);
}
#end_block

#method_before
@Test
public void testNetworkGoesIntoBackgroundAfterLinger() {
    setMobileDataAlwaysOn(true);
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    // Wifi comes up and cell lingers.
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableDoubleValidatedCallbacks(mWiFiNetworkAgent);
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // File a request for cellular, then release it.
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    // TODO : the callback should be delayed by the linger delay. Fix this.
    // callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCapabilitiesWith(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent);
    defaultCallback.expectAvailableCallbacksValidated(mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    mCm.unregisterNetworkCallback(defaultCallback);
    mCm.unregisterNetworkCallback(callback);
}
#method_after
@Test
public void testNetworkGoesIntoBackgroundAfterLinger() {
    setMobileDataAlwaysOn(true);
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    defaultCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    // Wifi comes up and cell lingers.
    mWiFiNetworkAgent.connect(true);
    defaultCallback.expectAvailableDoubleValidatedCallbacks(mWiFiNetworkAgent);
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    // File a request for cellular, then release it.
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    // TODO : the callback should be delayed by the linger delay. Fix this.
    // callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCapabilitiesWithout(NET_CAPABILITY_FOREGROUND, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mCm.unregisterNetworkCallback(defaultCallback);
    mCm.unregisterNetworkCallback(callback);
}
#end_block

#method_before
Runnable runSelectLoop(String abiList) {
    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();
    fds.add(mServerSocket.getFileDescriptor());
    peers.add(null);
    while (true) {
        StructPollfd[] pollFds = new StructPollfd[fds.size()];
        for (int i = 0; i < pollFds.length; ++i) {
            pollFds[i] = new StructPollfd();
            pollFds[i].fd = fds.get(i);
            pollFds[i].events = (short) POLLIN;
        }
        try {
            Os.poll(pollFds, -1);
        } catch (ErrnoException ex) {
            throw new RuntimeException("poll failed", ex);
        }
        for (int i = pollFds.length - 1; i >= 0; --i) {
            if ((pollFds[i].revents & POLLIN) == 0) {
                continue;
            }
            if (i == 0) {
                ZygoteConnection newPeer = acceptCommandPeer(abiList);
                peers.add(newPeer);
                fds.add(newPeer.getFileDesciptor());
            } else {
                try {
                    ZygoteConnection connection = peers.get(i);
                    final Runnable command = connection.processOneCommand(this);
                    if (mIsForkChild) {
                        // stage if processOneCommand hasn't called "exec".
                        if (command == null) {
                            throw new IllegalStateException("command == null");
                        }
                        return command;
                    } else {
                        // We're in the server - we should never have any commands to run.
                        if (command != null) {
                            throw new IllegalStateException("command != null");
                        }
                        // a regular POLLIN event in our regular processing loop.
                        if (connection.isClosedByPeer()) {
                            connection.closeSocket();
                            peers.remove(i);
                            fds.remove(i);
                        }
                    }
                } catch (Exception e) {
                    if (!mIsForkChild) {
                        // We're in the server so any exception here is one that has taken place
                        // pre-fork while processing commands or reading / writing from the
                        // control socket. Make a loud noise about any such exceptions so that
                        // we know exactly what failed and why.
                        Slog.e(TAG, "Exception executing zygote command: ", e);
                        // Make sure the socket is closed so that the other end knows immediately
                        // that something has gone wrong and doesn't time out waiting for a
                        // response.
                        ZygoteConnection conn = peers.remove(i);
                        conn.closeSocket();
                        fds.remove(i);
                    } else {
                        // We're in the child so any exception caught here has happened post
                        // fork and before we execute ActivityThread.main (or any other main()
                        // method). Log the details of the exception and bring down the process.
                        Log.e(TAG, "Caught post-fork exception in child process.", e);
                        throw e;
                    }
                }
            }
        }
    }
}
#method_after
Runnable runSelectLoop(String abiList) {
    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();
    fds.add(mServerSocket.getFileDescriptor());
    peers.add(null);
    while (true) {
        StructPollfd[] pollFds = new StructPollfd[fds.size()];
        for (int i = 0; i < pollFds.length; ++i) {
            pollFds[i] = new StructPollfd();
            pollFds[i].fd = fds.get(i);
            pollFds[i].events = (short) POLLIN;
        }
        try {
            Os.poll(pollFds, -1);
        } catch (ErrnoException ex) {
            throw new RuntimeException("poll failed", ex);
        }
        for (int i = pollFds.length - 1; i >= 0; --i) {
            if ((pollFds[i].revents & POLLIN) == 0) {
                continue;
            }
            if (i == 0) {
                ZygoteConnection newPeer = acceptCommandPeer(abiList);
                peers.add(newPeer);
                fds.add(newPeer.getFileDesciptor());
            } else {
                try {
                    ZygoteConnection connection = peers.get(i);
                    final Runnable command = connection.processOneCommand(this);
                    if (mIsForkChild) {
                        // stage if processOneCommand hasn't called "exec".
                        if (command == null) {
                            throw new IllegalStateException("command == null");
                        }
                        return command;
                    } else {
                        // We're in the server - we should never have any commands to run.
                        if (command != null) {
                            throw new IllegalStateException("command != null");
                        }
                        // a regular POLLIN event in our regular processing loop.
                        if (connection.isClosedByPeer()) {
                            connection.closeSocket();
                            peers.remove(i);
                            fds.remove(i);
                        }
                    }
                } catch (Exception e) {
                    if (!mIsForkChild) {
                        // We're in the server so any exception here is one that has taken place
                        // pre-fork while processing commands or reading / writing from the
                        // control socket. Make a loud noise about any such exceptions so that
                        // we know exactly what failed and why.
                        Slog.e(TAG, "Exception executing zygote command: ", e);
                        // Make sure the socket is closed so that the other end knows immediately
                        // that something has gone wrong and doesn't time out waiting for a
                        // response.
                        ZygoteConnection conn = peers.remove(i);
                        conn.closeSocket();
                        fds.remove(i);
                    } else {
                        // We're in the child so any exception caught here has happened post
                        // fork and before we execute ActivityThread.main (or any other main()
                        // method). Log the details of the exception and bring down the process.
                        Log.e(TAG, "Caught post-fork exception in child process.", e);
                        throw e;
                    }
                } finally {
                    // Reset the child flag, in the event that the child process is a child-
                    // zygote. The flag will not be consulted this loop pass after the Runnable
                    // is returned.
                    mIsForkChild = false;
                }
            }
        }
    }
}
#end_block

#method_before
public ChildZygoteProcess startChildZygote(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int targetSdkVersion, String seInfo, String abi, String instructionSet, String invokeWith) {
    // Create an unguessable address in the global abstract namespace.
    final LocalSocketAddress serverAddress = new LocalSocketAddress(processClass + "/" + UUID.randomUUID().toString());
    final String[] extraArgs = { Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG + serverAddress.getName() };
    Process.ProcessStartResult result;
    try {
        result = startViaZygote(processClass, niceName, uid, gid, gids, runtimeFlags, 0, /* mountExternal */
        targetSdkVersion, seInfo, abi, instructionSet, null, /* appDataDir */
        invokeWith, true, /* startChildZygote */
        extraArgs);
    } catch (ZygoteStartFailedEx ex) {
        throw new RuntimeException("Starting child-zygote through Zygote failed", ex);
    }
    ZygoteProcess zp = new ZygoteProcess(serverAddress, null);
    return new ChildZygoteProcess(zp, result);
}
#method_after
public ChildZygoteProcess startChildZygote(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, String seInfo, String abi, String instructionSet) {
    // Create an unguessable address in the global abstract namespace.
    final LocalSocketAddress serverAddress = new LocalSocketAddress(processClass + "/" + UUID.randomUUID().toString());
    final String[] extraArgs = { Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG + serverAddress.getName() };
    Process.ProcessStartResult result;
    try {
        result = startViaZygote(processClass, niceName, uid, gid, gids, runtimeFlags, 0, /* mountExternal */
        0, /* targetSdkVersion */
        seInfo, abi, instructionSet, null, /* appDataDir */
        null, /* invokeWith */
        true, /* startChildZygote */
        extraArgs);
    } catch (ZygoteStartFailedEx ex) {
        throw new RuntimeException("Starting child-zygote through Zygote failed", ex);
    }
    return new ChildZygoteProcess(serverAddress, result.pid);
}
#end_block

#method_before
public static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
    // SystemServer is always allowed to use hidden APIs.
    runtimeFlags |= DISABLE_HIDDEN_API_CHECKS;
    VM_HOOKS.preFork();
    // Resets nice priority for zygote process.
    resetNicePriority();
    int pid = nativeForkSystemServer(uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities);
    // Enable tracing as soon as we enter the system_server.
    if (pid == 0) {
        Trace.setTracingEnabled(true, runtimeFlags);
    }
    VM_HOOKS.postForkCommon();
    return pid;
}
#method_after
public static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
    VM_HOOKS.preFork();
    // Resets nice priority for zygote process.
    resetNicePriority();
    int pid = nativeForkSystemServer(uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities);
    // Enable tracing as soon as we enter the system_server.
    if (pid == 0) {
        Trace.setTracingEnabled(true, runtimeFlags);
    }
    VM_HOOKS.postForkCommon();
    return pid;
}
#end_block

#method_before
private void parseArgs(String[] args) throws IllegalArgumentException {
    int curArg = 0;
    boolean seenRuntimeArgs = false;
    for (; /* curArg */
    curArg < args.length; curArg++) {
        String arg = args[curArg];
        if (arg.equals("--")) {
            curArg++;
            break;
        } else if (arg.startsWith("--setuid=")) {
            if (uidSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            uidSpecified = true;
            uid = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--setgid=")) {
            if (gidSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            gidSpecified = true;
            gid = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--target-sdk-version=")) {
            if (targetSdkVersionSpecified) {
                throw new IllegalArgumentException("Duplicate target-sdk-version specified");
            }
            targetSdkVersionSpecified = true;
            targetSdkVersion = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.equals("--runtime-args")) {
            seenRuntimeArgs = true;
        } else if (arg.startsWith("--runtime-flags=")) {
            runtimeFlags = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--seinfo=")) {
            if (seInfoSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            seInfoSpecified = true;
            seInfo = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.startsWith("--capabilities=")) {
            if (capabilitiesSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            capabilitiesSpecified = true;
            String capString = arg.substring(arg.indexOf('=') + 1);
            String[] capStrings = capString.split(",", 2);
            if (capStrings.length == 1) {
                effectiveCapabilities = Long.decode(capStrings[0]);
                permittedCapabilities = effectiveCapabilities;
            } else {
                permittedCapabilities = Long.decode(capStrings[0]);
                effectiveCapabilities = Long.decode(capStrings[1]);
            }
        } else if (arg.startsWith("--rlimit=")) {
            // Duplicate --rlimit arguments are specifically allowed.
            String[] limitStrings = arg.substring(arg.indexOf('=') + 1).split(",");
            if (limitStrings.length != 3) {
                throw new IllegalArgumentException("--rlimit= should have 3 comma-delimited ints");
            }
            int[] rlimitTuple = new int[limitStrings.length];
            for (int i = 0; i < limitStrings.length; i++) {
                rlimitTuple[i] = Integer.parseInt(limitStrings[i]);
            }
            if (rlimits == null) {
                rlimits = new ArrayList();
            }
            rlimits.add(rlimitTuple);
        } else if (arg.startsWith("--setgroups=")) {
            if (gids != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            String[] params = arg.substring(arg.indexOf('=') + 1).split(",");
            gids = new int[params.length];
            for (int i = params.length - 1; i >= 0; i--) {
                gids[i] = Integer.parseInt(params[i]);
            }
        } else if (arg.equals("--invoke-with")) {
            if (invokeWith != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            try {
                invokeWith = args[++curArg];
            } catch (IndexOutOfBoundsException ex) {
                throw new IllegalArgumentException("--invoke-with requires argument");
            }
        } else if (arg.startsWith("--nice-name=")) {
            if (niceName != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            niceName = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.equals("--mount-external-default")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_DEFAULT;
        } else if (arg.equals("--mount-external-read")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_READ;
        } else if (arg.equals("--mount-external-write")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_WRITE;
        } else if (arg.equals("--query-abi-list")) {
            abiListQuery = true;
        } else if (arg.startsWith("--instruction-set=")) {
            instructionSet = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.startsWith("--app-data-dir=")) {
            appDataDir = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.equals("--preload-package")) {
            preloadPackage = args[++curArg];
            preloadPackageLibs = args[++curArg];
            preloadPackageCacheKey = args[++curArg];
        } else if (arg.equals("--preload-default")) {
            preloadDefault = true;
        } else if (arg.equals("--start-child-zygote")) {
            startChildZygote = true;
        } else {
            break;
        }
    }
    if (abiListQuery) {
        if (args.length - curArg > 0) {
            throw new IllegalArgumentException("Unexpected arguments after --query-abi-list.");
        }
    } else if (preloadPackage != null) {
        if (args.length - curArg > 0) {
            throw new IllegalArgumentException("Unexpected arguments after --preload-package.");
        }
    } else if (!preloadDefault) {
        if (!seenRuntimeArgs) {
            throw new IllegalArgumentException("Unexpected argument : " + args[curArg]);
        }
        remainingArgs = new String[args.length - curArg];
        System.arraycopy(args, curArg, remainingArgs, 0, remainingArgs.length);
    }
}
#method_after
private void parseArgs(String[] args) throws IllegalArgumentException {
    int curArg = 0;
    boolean seenRuntimeArgs = false;
    for (; /* curArg */
    curArg < args.length; curArg++) {
        String arg = args[curArg];
        if (arg.equals("--")) {
            curArg++;
            break;
        } else if (arg.startsWith("--setuid=")) {
            if (uidSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            uidSpecified = true;
            uid = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--setgid=")) {
            if (gidSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            gidSpecified = true;
            gid = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--target-sdk-version=")) {
            if (targetSdkVersionSpecified) {
                throw new IllegalArgumentException("Duplicate target-sdk-version specified");
            }
            targetSdkVersionSpecified = true;
            targetSdkVersion = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.equals("--runtime-args")) {
            seenRuntimeArgs = true;
        } else if (arg.startsWith("--runtime-flags=")) {
            runtimeFlags = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--seinfo=")) {
            if (seInfoSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            seInfoSpecified = true;
            seInfo = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.startsWith("--capabilities=")) {
            if (capabilitiesSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            capabilitiesSpecified = true;
            String capString = arg.substring(arg.indexOf('=') + 1);
            String[] capStrings = capString.split(",", 2);
            if (capStrings.length == 1) {
                effectiveCapabilities = Long.decode(capStrings[0]);
                permittedCapabilities = effectiveCapabilities;
            } else {
                permittedCapabilities = Long.decode(capStrings[0]);
                effectiveCapabilities = Long.decode(capStrings[1]);
            }
        } else if (arg.startsWith("--rlimit=")) {
            // Duplicate --rlimit arguments are specifically allowed.
            String[] limitStrings = arg.substring(arg.indexOf('=') + 1).split(",");
            if (limitStrings.length != 3) {
                throw new IllegalArgumentException("--rlimit= should have 3 comma-delimited ints");
            }
            int[] rlimitTuple = new int[limitStrings.length];
            for (int i = 0; i < limitStrings.length; i++) {
                rlimitTuple[i] = Integer.parseInt(limitStrings[i]);
            }
            if (rlimits == null) {
                rlimits = new ArrayList();
            }
            rlimits.add(rlimitTuple);
        } else if (arg.startsWith("--setgroups=")) {
            if (gids != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            String[] params = arg.substring(arg.indexOf('=') + 1).split(",");
            gids = new int[params.length];
            for (int i = params.length - 1; i >= 0; i--) {
                gids[i] = Integer.parseInt(params[i]);
            }
        } else if (arg.equals("--invoke-with")) {
            if (invokeWith != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            try {
                invokeWith = args[++curArg];
            } catch (IndexOutOfBoundsException ex) {
                throw new IllegalArgumentException("--invoke-with requires argument");
            }
        } else if (arg.startsWith("--nice-name=")) {
            if (niceName != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            niceName = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.equals("--mount-external-default")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_DEFAULT;
        } else if (arg.equals("--mount-external-read")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_READ;
        } else if (arg.equals("--mount-external-write")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_WRITE;
        } else if (arg.equals("--query-abi-list")) {
            abiListQuery = true;
        } else if (arg.startsWith("--instruction-set=")) {
            instructionSet = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.startsWith("--app-data-dir=")) {
            appDataDir = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.equals("--preload-package")) {
            preloadPackage = args[++curArg];
            preloadPackageLibs = args[++curArg];
            preloadPackageCacheKey = args[++curArg];
        } else if (arg.equals("--preload-default")) {
            preloadDefault = true;
        } else if (arg.equals("--start-child-zygote")) {
            startChildZygote = true;
        } else {
            break;
        }
    }
    if (abiListQuery) {
        if (args.length - curArg > 0) {
            throw new IllegalArgumentException("Unexpected arguments after --query-abi-list.");
        }
    } else if (preloadPackage != null) {
        if (args.length - curArg > 0) {
            throw new IllegalArgumentException("Unexpected arguments after --preload-package.");
        }
    } else if (!preloadDefault) {
        if (!seenRuntimeArgs) {
            throw new IllegalArgumentException("Unexpected argument : " + args[curArg]);
        }
        remainingArgs = new String[args.length - curArg];
        System.arraycopy(args, curArg, remainingArgs, 0, remainingArgs.length);
    }
    if (startChildZygote) {
        boolean seenChildSocketArg = false;
        for (String arg : remainingArgs) {
            if (arg.startsWith(Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG)) {
                seenChildSocketArg = true;
                break;
            }
        }
        if (!seenChildSocketArg) {
            throw new IllegalArgumentException("--start-child-zygote specified " + "without " + Zygote.CHILD_ZYGOTE_SOCKET_NAME_ARG);
        }
    }
}
#end_block

#method_before
private static void performSystemServerDexOpt(String classPath) {
    final String[] classPathElements = classPath.split(":");
    final IInstalld installd = IInstalld.Stub.asInterface(ServiceManager.getService("installd"));
    final String instructionSet = VMRuntime.getRuntime().vmInstructionSet();
    String classPathForElement = "";
    for (String classPathElement : classPathElements) {
        // System server is fully AOTed and never profiled
        // for profile guided compilation.
        String systemServerFilter = SystemProperties.get("dalvik.vm.systemservercompilerfilter", "speed");
        int dexoptNeeded;
        try {
            dexoptNeeded = DexFile.getDexOptNeeded(classPathElement, instructionSet, systemServerFilter, null, /* classLoaderContext */
            false, /* newProfile */
            false);
        } catch (FileNotFoundException ignored) {
            // Do not add to the classpath.
            Log.w(TAG, "Missing classpath element for system server: " + classPathElement);
            continue;
        } catch (IOException e) {
            // Not fully clear what to do here as we don't know the cause of the
            // IO exception. Add to the classpath to be conservative, but don't
            // attempt to compile it.
            Log.w(TAG, "Error checking classpath element for system server: " + classPathElement, e);
            dexoptNeeded = DexFile.NO_DEXOPT_NEEDED;
        }
        if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
            final String packageName = "*";
            final String outputPath = null;
            // Dexopt with a flag which lifts restrictions on hidden API usage.
            // Offending methods would otherwise be re-verified at runtime and
            // we want to avoid the performance overhead of that.
            final int dexFlags = DEXOPT_DISABLE_HIDDEN_API_CHECKS;
            final String compilerFilter = systemServerFilter;
            final String uuid = StorageManager.UUID_PRIVATE_INTERNAL;
            final String seInfo = null;
            final String classLoaderContext = getSystemServerClassLoaderContext(classPathForElement);
            // SystemServer targets the system's SDK version
            final int targetSdkVersion = 0;
            try {
                installd.dexopt(classPathElement, Process.SYSTEM_UID, packageName, instructionSet, dexoptNeeded, outputPath, dexFlags, compilerFilter, uuid, classLoaderContext, seInfo, false, /* downgrade */
                targetSdkVersion);
            } catch (RemoteException | ServiceSpecificException e) {
                // Ignore (but log), we need this on the classpath for fallback mode.
                Log.w(TAG, "Failed compiling classpath element for system server: " + classPathElement, e);
            }
        }
        classPathForElement = encodeSystemServerClassPath(classPathForElement, classPathElement);
    }
}
#method_after
private static void performSystemServerDexOpt(String classPath) {
    final String[] classPathElements = classPath.split(":");
    final IInstalld installd = IInstalld.Stub.asInterface(ServiceManager.getService("installd"));
    final String instructionSet = VMRuntime.getRuntime().vmInstructionSet();
    String classPathForElement = "";
    for (String classPathElement : classPathElements) {
        // System server is fully AOTed and never profiled
        // for profile guided compilation.
        String systemServerFilter = SystemProperties.get("dalvik.vm.systemservercompilerfilter", "speed");
        int dexoptNeeded;
        try {
            dexoptNeeded = DexFile.getDexOptNeeded(classPathElement, instructionSet, systemServerFilter, null, /* classLoaderContext */
            false, /* newProfile */
            false);
        } catch (FileNotFoundException ignored) {
            // Do not add to the classpath.
            Log.w(TAG, "Missing classpath element for system server: " + classPathElement);
            continue;
        } catch (IOException e) {
            // Not fully clear what to do here as we don't know the cause of the
            // IO exception. Add to the classpath to be conservative, but don't
            // attempt to compile it.
            Log.w(TAG, "Error checking classpath element for system server: " + classPathElement, e);
            dexoptNeeded = DexFile.NO_DEXOPT_NEEDED;
        }
        if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
            final String packageName = "*";
            final String outputPath = null;
            final int dexFlags = 0;
            final String compilerFilter = systemServerFilter;
            final String uuid = StorageManager.UUID_PRIVATE_INTERNAL;
            final String seInfo = null;
            final String classLoaderContext = getSystemServerClassLoaderContext(classPathForElement);
            // SystemServer targets the system's SDK version
            final int targetSdkVersion = 0;
            try {
                installd.dexopt(classPathElement, Process.SYSTEM_UID, packageName, instructionSet, dexoptNeeded, outputPath, dexFlags, compilerFilter, uuid, classLoaderContext, seInfo, false, /* downgrade */
                targetSdkVersion);
            } catch (RemoteException | ServiceSpecificException e) {
                // Ignore (but log), we need this on the classpath for fallback mode.
                Log.w(TAG, "Failed compiling classpath element for system server: " + classPathElement, e);
            }
        }
        classPathForElement = encodeSystemServerClassPath(classPathForElement, classPathElement);
    }
}
#end_block

#method_before
public static void main(String[] argv) {
    ZygoteServer zygoteServer = new ZygoteServer();
    // Mark zygote start. This ensures that thread creation will throw
    // an error.
    ZygoteHooks.startZygoteNoThreadCreation();
    // Zygote goes into its own process group.
    try {
        Os.setpgid(0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException("Failed to setpgid(0,0)", ex);
    }
    final Runnable caller;
    try {
        // Report Zygote start time to tron unless it is a runtime restart
        if (!"1".equals(SystemProperties.get("sys.boot_completed"))) {
            MetricsLogger.histogram(null, "boot_zygote_init", (int) SystemClock.elapsedRealtime());
        }
        String bootTimeTag = Process.is64Bit() ? "Zygote64Timing" : "Zygote32Timing";
        TimingsTraceLog bootTimingsTraceLog = new TimingsTraceLog(bootTimeTag, Trace.TRACE_TAG_DALVIK);
        bootTimingsTraceLog.traceBegin("ZygoteInit");
        RuntimeInit.enableDdms();
        boolean startSystemServer = false;
        String socketName = "zygote";
        String abiList = null;
        boolean enableLazyPreload = false;
        for (int i = 1; i < argv.length; i++) {
            if ("start-system-server".equals(argv[i])) {
                startSystemServer = true;
            } else if ("--enable-lazy-preload".equals(argv[i])) {
                enableLazyPreload = true;
            } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                abiList = argv[i].substring(ABI_LIST_ARG.length());
            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                socketName = argv[i].substring(SOCKET_NAME_ARG.length());
            } else {
                throw new RuntimeException("Unknown command line argument: " + argv[i]);
            }
        }
        if (abiList == null) {
            throw new RuntimeException("No ABI list supplied.");
        }
        zygoteServer.registerServerSocket(socketName);
        // In such cases, we will preload things prior to our first fork.
        if (!enableLazyPreload) {
            bootTimingsTraceLog.traceBegin("ZygotePreload");
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis());
            preload(bootTimingsTraceLog);
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis());
            // ZygotePreload
            bootTimingsTraceLog.traceEnd();
        } else {
            Zygote.resetNicePriority();
        }
        // Do an initial gc to clean up after startup
        bootTimingsTraceLog.traceBegin("PostZygoteInitGC");
        gcAndFinalize();
        // PostZygoteInitGC
        bootTimingsTraceLog.traceEnd();
        // ZygoteInit
        bootTimingsTraceLog.traceEnd();
        // Disable tracing so that forked processes do not inherit stale tracing tags from
        // Zygote.
        Trace.setTracingEnabled(false, 0);
        Zygote.nativeSecurityInit();
        // Zygote process unmounts root storage spaces.
        Zygote.nativeUnmountStorageOnInit();
        ZygoteHooks.stopZygoteNoThreadCreation();
        if (startSystemServer) {
            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);
            // child (system_server) process.
            if (r != null) {
                r.run();
                return;
            }
        }
        Log.i(TAG, "Accepting command socket connections");
        // The select loop returns early in the child process after a fork and
        // loops forever in the zygote.
        caller = zygoteServer.runSelectLoop(abiList);
    } catch (Throwable ex) {
        Log.e(TAG, "System zygote died with exception", ex);
        throw ex;
    } finally {
        zygoteServer.closeServerSocket();
    }
    // command.
    if (caller != null) {
        caller.run();
    }
}
#method_after
public static void main(String[] argv) {
    ZygoteServer zygoteServer = new ZygoteServer();
    // Mark zygote start. This ensures that thread creation will throw
    // an error.
    ZygoteHooks.startZygoteNoThreadCreation();
    // Zygote goes into its own process group.
    try {
        Os.setpgid(0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException("Failed to setpgid(0,0)", ex);
    }
    final Runnable caller;
    try {
        // Report Zygote start time to tron unless it is a runtime restart
        if (!"1".equals(SystemProperties.get("sys.boot_completed"))) {
            MetricsLogger.histogram(null, "boot_zygote_init", (int) SystemClock.elapsedRealtime());
        }
        String bootTimeTag = Process.is64Bit() ? "Zygote64Timing" : "Zygote32Timing";
        TimingsTraceLog bootTimingsTraceLog = new TimingsTraceLog(bootTimeTag, Trace.TRACE_TAG_DALVIK);
        bootTimingsTraceLog.traceBegin("ZygoteInit");
        RuntimeInit.enableDdms();
        boolean startSystemServer = false;
        String socketName = "zygote";
        String abiList = null;
        boolean enableLazyPreload = false;
        for (int i = 1; i < argv.length; i++) {
            if ("start-system-server".equals(argv[i])) {
                startSystemServer = true;
            } else if ("--enable-lazy-preload".equals(argv[i])) {
                enableLazyPreload = true;
            } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                abiList = argv[i].substring(ABI_LIST_ARG.length());
            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                socketName = argv[i].substring(SOCKET_NAME_ARG.length());
            } else {
                throw new RuntimeException("Unknown command line argument: " + argv[i]);
            }
        }
        if (abiList == null) {
            throw new RuntimeException("No ABI list supplied.");
        }
        zygoteServer.registerServerSocketFromEnv(socketName);
        // In such cases, we will preload things prior to our first fork.
        if (!enableLazyPreload) {
            bootTimingsTraceLog.traceBegin("ZygotePreload");
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis());
            preload(bootTimingsTraceLog);
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis());
            // ZygotePreload
            bootTimingsTraceLog.traceEnd();
        } else {
            Zygote.resetNicePriority();
        }
        // Do an initial gc to clean up after startup
        bootTimingsTraceLog.traceBegin("PostZygoteInitGC");
        gcAndFinalize();
        // PostZygoteInitGC
        bootTimingsTraceLog.traceEnd();
        // ZygoteInit
        bootTimingsTraceLog.traceEnd();
        // Disable tracing so that forked processes do not inherit stale tracing tags from
        // Zygote.
        Trace.setTracingEnabled(false, 0);
        Zygote.nativeSecurityInit();
        // Zygote process unmounts root storage spaces.
        Zygote.nativeUnmountStorageOnInit();
        ZygoteHooks.stopZygoteNoThreadCreation();
        if (startSystemServer) {
            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);
            // child (system_server) process.
            if (r != null) {
                r.run();
                return;
            }
        }
        Log.i(TAG, "Accepting command socket connections");
        // The select loop returns early in the child process after a fork and
        // loops forever in the zygote.
        caller = zygoteServer.runSelectLoop(abiList);
    } catch (Throwable ex) {
        Log.e(TAG, "System zygote died with exception", ex);
        throw ex;
    } finally {
        zygoteServer.closeServerSocket();
    }
    // command.
    if (caller != null) {
        caller.run();
    }
}
#end_block

#method_before
public static final Runnable childZygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {
    final RuntimeInit.Arguments args = new RuntimeInit.Arguments(argv);
    return RuntimeInit.findStaticMain(args.startClass, args.startArgs, classLoader);
}
#method_after
static final Runnable childZygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {
    RuntimeInit.Arguments args = new RuntimeInit.Arguments(argv);
    return RuntimeInit.findStaticMain(args.startClass, args.startArgs, classLoader);
}
#end_block

#method_before
public void test_getPrimitiveType_invalid() throws Throwable {
    try {
        getPrimitiveType(null);
        fail();
    } catch (NullPointerException expected) {
        assertNull(expected.getMessage());
    }
    for (String name : new String[] { "", "Boolean", "java.lang.Object", "invalid" }) {
        try {
            getPrimitiveType(name);
            fail("Invalid type should be rejected: " + name);
        } catch (ClassNotFoundException expected) {
            assertEquals(name, expected.getMessage());
        }
    }
}
#method_after
public void test_getPrimitiveType_invalid() throws Throwable {
    List<String> invalidNames = Arrays.asList("", "java.lang.Object", "invalid", "Boolean", "java.lang.Boolean", "java/lang/Boolean", "Ljava/lang/Boolean;");
    for (String name : invalidNames) {
        try {
            getPrimitiveType(name);
            fail("Invalid type should be rejected: " + name);
        } catch (ClassNotFoundException expected) {
            assertEquals(name, expected.getMessage());
        }
    }
}
#end_block

#method_before
private static void dumpProtoGlobalSettingsLocked(@NonNull SettingsState s, @NonNull ProtoOutputStream p) {
    dumpSetting(s, p, Settings.Global.ADD_USERS_WHEN_LOCKED, GlobalSettingsProto.ADD_USERS_WHEN_LOCKED);
    dumpSetting(s, p, Settings.Global.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED, GlobalSettingsProto.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED);
    dumpSetting(s, p, Settings.Global.AIRPLANE_MODE_ON, GlobalSettingsProto.AIRPLANE_MODE_ON);
    dumpSetting(s, p, Settings.Global.THEATER_MODE_ON, GlobalSettingsProto.THEATER_MODE_ON);
    dumpSetting(s, p, Settings.Global.RADIO_BLUETOOTH, GlobalSettingsProto.RADIO_BLUETOOTH);
    dumpSetting(s, p, Settings.Global.RADIO_WIFI, GlobalSettingsProto.RADIO_WIFI);
    dumpSetting(s, p, Settings.Global.RADIO_WIMAX, GlobalSettingsProto.RADIO_WIMAX);
    dumpSetting(s, p, Settings.Global.RADIO_CELL, GlobalSettingsProto.RADIO_CELL);
    dumpSetting(s, p, Settings.Global.RADIO_NFC, GlobalSettingsProto.RADIO_NFC);
    dumpSetting(s, p, Settings.Global.AIRPLANE_MODE_RADIOS, GlobalSettingsProto.AIRPLANE_MODE_RADIOS);
    dumpSetting(s, p, Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS, GlobalSettingsProto.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_DISABLED_PROFILES, GlobalSettingsProto.BLUETOOTH_DISABLED_PROFILES);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_INTEROPERABILITY_LIST, GlobalSettingsProto.BLUETOOTH_INTEROPERABILITY_LIST);
    dumpSetting(s, p, Settings.Global.WIFI_SLEEP_POLICY, GlobalSettingsProto.WIFI_SLEEP_POLICY);
    dumpSetting(s, p, Settings.Global.AUTO_TIME, GlobalSettingsProto.AUTO_TIME);
    dumpSetting(s, p, Settings.Global.AUTO_TIME_ZONE, GlobalSettingsProto.AUTO_TIME_ZONE);
    dumpSetting(s, p, Settings.Global.CAR_DOCK_SOUND, GlobalSettingsProto.CAR_DOCK_SOUND);
    dumpSetting(s, p, Settings.Global.CAR_UNDOCK_SOUND, GlobalSettingsProto.CAR_UNDOCK_SOUND);
    dumpSetting(s, p, Settings.Global.DESK_DOCK_SOUND, GlobalSettingsProto.DESK_DOCK_SOUND);
    dumpSetting(s, p, Settings.Global.DESK_UNDOCK_SOUND, GlobalSettingsProto.DESK_UNDOCK_SOUND);
    dumpSetting(s, p, Settings.Global.DOCK_SOUNDS_ENABLED, GlobalSettingsProto.DOCK_SOUNDS_ENABLED);
    dumpSetting(s, p, Settings.Global.DOCK_SOUNDS_ENABLED_WHEN_ACCESSIBILITY, GlobalSettingsProto.DOCK_SOUNDS_ENABLED_WHEN_ACCESSIBILITY);
    dumpSetting(s, p, Settings.Global.LOCK_SOUND, GlobalSettingsProto.LOCK_SOUND);
    dumpSetting(s, p, Settings.Global.UNLOCK_SOUND, GlobalSettingsProto.UNLOCK_SOUND);
    dumpSetting(s, p, Settings.Global.TRUSTED_SOUND, GlobalSettingsProto.TRUSTED_SOUND);
    dumpSetting(s, p, Settings.Global.LOW_BATTERY_SOUND, GlobalSettingsProto.LOW_BATTERY_SOUND);
    dumpSetting(s, p, Settings.Global.POWER_SOUNDS_ENABLED, GlobalSettingsProto.POWER_SOUNDS_ENABLED);
    dumpSetting(s, p, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND, GlobalSettingsProto.WIRELESS_CHARGING_STARTED_SOUND);
    dumpSetting(s, p, Settings.Global.CHARGING_SOUNDS_ENABLED, GlobalSettingsProto.CHARGING_SOUNDS_ENABLED);
    dumpSetting(s, p, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, GlobalSettingsProto.STAY_ON_WHILE_PLUGGED_IN);
    dumpSetting(s, p, Settings.Global.BUGREPORT_IN_POWER_MENU, GlobalSettingsProto.BUGREPORT_IN_POWER_MENU);
    dumpSetting(s, p, Settings.Global.ADB_ENABLED, GlobalSettingsProto.ADB_ENABLED);
    dumpSetting(s, p, Settings.Global.DEBUG_VIEW_ATTRIBUTES, GlobalSettingsProto.DEBUG_VIEW_ATTRIBUTES);
    dumpSetting(s, p, Settings.Global.ASSISTED_GPS_ENABLED, GlobalSettingsProto.ASSISTED_GPS_ENABLED);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_ON, GlobalSettingsProto.BLUETOOTH_ON);
    dumpSetting(s, p, Settings.Global.CDMA_CELL_BROADCAST_SMS, GlobalSettingsProto.CDMA_CELL_BROADCAST_SMS);
    dumpSetting(s, p, Settings.Global.CDMA_ROAMING_MODE, GlobalSettingsProto.CDMA_ROAMING_MODE);
    dumpSetting(s, p, Settings.Global.CDMA_SUBSCRIPTION_MODE, GlobalSettingsProto.CDMA_SUBSCRIPTION_MODE);
    dumpSetting(s, p, Settings.Global.DATA_ACTIVITY_TIMEOUT_MOBILE, GlobalSettingsProto.DATA_ACTIVITY_TIMEOUT_MOBILE);
    dumpSetting(s, p, Settings.Global.DATA_ACTIVITY_TIMEOUT_WIFI, GlobalSettingsProto.DATA_ACTIVITY_TIMEOUT_WIFI);
    dumpSetting(s, p, Settings.Global.DATA_ROAMING, GlobalSettingsProto.DATA_ROAMING);
    dumpSetting(s, p, Settings.Global.MDC_INITIAL_MAX_RETRY, GlobalSettingsProto.MDC_INITIAL_MAX_RETRY);
    dumpSetting(s, p, Settings.Global.FORCE_ALLOW_ON_EXTERNAL, GlobalSettingsProto.FORCE_ALLOW_ON_EXTERNAL);
    dumpSetting(s, p, Settings.Global.DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, GlobalSettingsProto.DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES);
    dumpSetting(s, p, Settings.Global.DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, GlobalSettingsProto.DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT);
    dumpSetting(s, p, Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, GlobalSettingsProto.DEVELOPMENT_SETTINGS_ENABLED);
    dumpSetting(s, p, Settings.Global.DEVICE_PROVISIONED, GlobalSettingsProto.DEVICE_PROVISIONED);
    dumpSetting(s, p, Settings.Global.DEVICE_PROVISIONING_MOBILE_DATA_ENABLED, GlobalSettingsProto.DEVICE_PROVISIONING_MOBILE_DATA_ENABLED);
    dumpSetting(s, p, Settings.Global.DISPLAY_SIZE_FORCED, GlobalSettingsProto.DISPLAY_SIZE_FORCED);
    dumpSetting(s, p, Settings.Global.DISPLAY_SCALING_FORCE, GlobalSettingsProto.DISPLAY_SCALING_FORCE);
    dumpSetting(s, p, Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE, GlobalSettingsProto.DOWNLOAD_MAX_BYTES_OVER_MOBILE);
    dumpSetting(s, p, Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE, GlobalSettingsProto.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE);
    dumpSetting(s, p, Settings.Global.HDMI_CONTROL_ENABLED, GlobalSettingsProto.HDMI_CONTROL_ENABLED);
    dumpSetting(s, p, Settings.Global.HDMI_SYSTEM_AUDIO_CONTROL_ENABLED, GlobalSettingsProto.HDMI_SYSTEM_AUDIO_CONTROL_ENABLED);
    dumpSetting(s, p, Settings.Global.HDMI_CONTROL_AUTO_WAKEUP_ENABLED, GlobalSettingsProto.HDMI_CONTROL_AUTO_WAKEUP_ENABLED);
    dumpSetting(s, p, Settings.Global.HDMI_CONTROL_AUTO_DEVICE_OFF_ENABLED, GlobalSettingsProto.HDMI_CONTROL_AUTO_DEVICE_OFF_ENABLED);
    dumpSetting(s, p, Settings.Global.MHL_INPUT_SWITCHING_ENABLED, GlobalSettingsProto.MHL_INPUT_SWITCHING_ENABLED);
    dumpSetting(s, p, Settings.Global.MHL_POWER_CHARGE_ENABLED, GlobalSettingsProto.MHL_POWER_CHARGE_ENABLED);
    dumpSetting(s, p, Settings.Global.MOBILE_DATA, GlobalSettingsProto.MOBILE_DATA);
    dumpSetting(s, p, Settings.Global.MOBILE_DATA_ALWAYS_ON, GlobalSettingsProto.MOBILE_DATA_ALWAYS_ON);
    dumpSetting(s, p, Settings.Global.CONNECTIVITY_METRICS_BUFFER_SIZE, GlobalSettingsProto.CONNECTIVITY_METRICS_BUFFER_SIZE);
    dumpSetting(s, p, Settings.Global.NETSTATS_ENABLED, GlobalSettingsProto.NETSTATS_ENABLED);
    dumpSetting(s, p, Settings.Global.NETSTATS_POLL_INTERVAL, GlobalSettingsProto.NETSTATS_POLL_INTERVAL);
    dumpSetting(s, p, Settings.Global.NETSTATS_TIME_CACHE_MAX_AGE, GlobalSettingsProto.NETSTATS_TIME_CACHE_MAX_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_GLOBAL_ALERT_BYTES, GlobalSettingsProto.NETSTATS_GLOBAL_ALERT_BYTES);
    dumpSetting(s, p, Settings.Global.NETSTATS_SAMPLE_ENABLED, GlobalSettingsProto.NETSTATS_SAMPLE_ENABLED);
    dumpSetting(s, p, Settings.Global.NETSTATS_DEV_BUCKET_DURATION, GlobalSettingsProto.NETSTATS_DEV_BUCKET_DURATION);
    dumpSetting(s, p, Settings.Global.NETSTATS_DEV_PERSIST_BYTES, GlobalSettingsProto.NETSTATS_DEV_PERSIST_BYTES);
    dumpSetting(s, p, Settings.Global.NETSTATS_DEV_ROTATE_AGE, GlobalSettingsProto.NETSTATS_DEV_ROTATE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_DEV_DELETE_AGE, GlobalSettingsProto.NETSTATS_DEV_DELETE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_BUCKET_DURATION, GlobalSettingsProto.NETSTATS_UID_BUCKET_DURATION);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_PERSIST_BYTES, GlobalSettingsProto.NETSTATS_UID_PERSIST_BYTES);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_ROTATE_AGE, GlobalSettingsProto.NETSTATS_UID_ROTATE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_DELETE_AGE, GlobalSettingsProto.NETSTATS_UID_DELETE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_TAG_BUCKET_DURATION, GlobalSettingsProto.NETSTATS_UID_TAG_BUCKET_DURATION);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_TAG_PERSIST_BYTES, GlobalSettingsProto.NETSTATS_UID_TAG_PERSIST_BYTES);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_TAG_ROTATE_AGE, GlobalSettingsProto.NETSTATS_UID_TAG_ROTATE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_TAG_DELETE_AGE, GlobalSettingsProto.NETSTATS_UID_TAG_DELETE_AGE);
    dumpSetting(s, p, Settings.Global.NETWORK_PREFERENCE, GlobalSettingsProto.NETWORK_PREFERENCE);
    dumpSetting(s, p, Settings.Global.NETWORK_SCORER_APP, GlobalSettingsProto.NETWORK_SCORER_APP);
    dumpSetting(s, p, Settings.Global.NITZ_UPDATE_DIFF, GlobalSettingsProto.NITZ_UPDATE_DIFF);
    dumpSetting(s, p, Settings.Global.NITZ_UPDATE_SPACING, GlobalSettingsProto.NITZ_UPDATE_SPACING);
    dumpSetting(s, p, Settings.Global.NTP_SERVER, GlobalSettingsProto.NTP_SERVER);
    dumpSetting(s, p, Settings.Global.NTP_TIMEOUT, GlobalSettingsProto.NTP_TIMEOUT);
    dumpSetting(s, p, Settings.Global.STORAGE_BENCHMARK_INTERVAL, GlobalSettingsProto.STORAGE_BENCHMARK_INTERVAL);
    dumpSetting(s, p, Settings.Global.DNS_RESOLVER_SAMPLE_VALIDITY_SECONDS, GlobalSettingsProto.DNS_RESOLVER_SAMPLE_VALIDITY_SECONDS);
    dumpSetting(s, p, Settings.Global.DNS_RESOLVER_SUCCESS_THRESHOLD_PERCENT, GlobalSettingsProto.DNS_RESOLVER_SUCCESS_THRESHOLD_PERCENT);
    dumpSetting(s, p, Settings.Global.DNS_RESOLVER_MIN_SAMPLES, GlobalSettingsProto.DNS_RESOLVER_MIN_SAMPLES);
    dumpSetting(s, p, Settings.Global.DNS_RESOLVER_MAX_SAMPLES, GlobalSettingsProto.DNS_RESOLVER_MAX_SAMPLES);
    dumpSetting(s, p, Settings.Global.OTA_DISABLE_AUTOMATIC_UPDATE, GlobalSettingsProto.OTA_DISABLE_AUTOMATIC_UPDATE);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_ENABLE, GlobalSettingsProto.PACKAGE_VERIFIER_ENABLE);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_TIMEOUT, GlobalSettingsProto.PACKAGE_VERIFIER_TIMEOUT);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_DEFAULT_RESPONSE, GlobalSettingsProto.PACKAGE_VERIFIER_DEFAULT_RESPONSE);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_SETTING_VISIBLE, GlobalSettingsProto.PACKAGE_VERIFIER_SETTING_VISIBLE);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB, GlobalSettingsProto.PACKAGE_VERIFIER_INCLUDE_ADB);
    dumpSetting(s, p, Settings.Global.FSTRIM_MANDATORY_INTERVAL, GlobalSettingsProto.FSTRIM_MANDATORY_INTERVAL);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_POLL_INTERVAL_MS, GlobalSettingsProto.PDP_WATCHDOG_POLL_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_LONG_POLL_INTERVAL_MS, GlobalSettingsProto.PDP_WATCHDOG_LONG_POLL_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS, GlobalSettingsProto.PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_TRIGGER_PACKET_COUNT, GlobalSettingsProto.PDP_WATCHDOG_TRIGGER_PACKET_COUNT);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_ERROR_POLL_COUNT, GlobalSettingsProto.PDP_WATCHDOG_ERROR_POLL_COUNT);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_MAX_PDP_RESET_FAIL_COUNT, GlobalSettingsProto.PDP_WATCHDOG_MAX_PDP_RESET_FAIL_COUNT);
    dumpSetting(s, p, Settings.Global.SAMPLING_PROFILER_MS, GlobalSettingsProto.SAMPLING_PROFILER_MS);
    dumpSetting(s, p, Settings.Global.SETUP_PREPAID_DATA_SERVICE_URL, GlobalSettingsProto.SETUP_PREPAID_DATA_SERVICE_URL);
    dumpSetting(s, p, Settings.Global.SETUP_PREPAID_DETECTION_TARGET_URL, GlobalSettingsProto.SETUP_PREPAID_DETECTION_TARGET_URL);
    dumpSetting(s, p, Settings.Global.SETUP_PREPAID_DETECTION_REDIR_HOST, GlobalSettingsProto.SETUP_PREPAID_DETECTION_REDIR_HOST);
    dumpSetting(s, p, Settings.Global.SMS_OUTGOING_CHECK_INTERVAL_MS, GlobalSettingsProto.SMS_OUTGOING_CHECK_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.SMS_OUTGOING_CHECK_MAX_COUNT, GlobalSettingsProto.SMS_OUTGOING_CHECK_MAX_COUNT);
    dumpSetting(s, p, Settings.Global.SMS_SHORT_CODE_CONFIRMATION, GlobalSettingsProto.SMS_SHORT_CODE_CONFIRMATION);
    dumpSetting(s, p, Settings.Global.SMS_SHORT_CODE_RULE, GlobalSettingsProto.SMS_SHORT_CODE_RULE);
    dumpSetting(s, p, Settings.Global.TCP_DEFAULT_INIT_RWND, GlobalSettingsProto.TCP_DEFAULT_INIT_RWND);
    dumpSetting(s, p, Settings.Global.TETHER_SUPPORTED, GlobalSettingsProto.TETHER_SUPPORTED);
    dumpSetting(s, p, Settings.Global.TETHER_DUN_REQUIRED, GlobalSettingsProto.TETHER_DUN_REQUIRED);
    dumpSetting(s, p, Settings.Global.TETHER_DUN_APN, GlobalSettingsProto.TETHER_DUN_APN);
    dumpSetting(s, p, Settings.Global.CARRIER_APP_WHITELIST, GlobalSettingsProto.CARRIER_APP_WHITELIST);
    dumpSetting(s, p, Settings.Global.USB_MASS_STORAGE_ENABLED, GlobalSettingsProto.USB_MASS_STORAGE_ENABLED);
    dumpSetting(s, p, Settings.Global.USE_GOOGLE_MAIL, GlobalSettingsProto.USE_GOOGLE_MAIL);
    dumpSetting(s, p, Settings.Global.WEBVIEW_DATA_REDUCTION_PROXY_KEY, GlobalSettingsProto.WEBVIEW_DATA_REDUCTION_PROXY_KEY);
    dumpSetting(s, p, Settings.Global.WEBVIEW_FALLBACK_LOGIC_ENABLED, GlobalSettingsProto.WEBVIEW_FALLBACK_LOGIC_ENABLED);
    dumpSetting(s, p, Settings.Global.WEBVIEW_PROVIDER, GlobalSettingsProto.WEBVIEW_PROVIDER);
    dumpSetting(s, p, Settings.Global.WEBVIEW_MULTIPROCESS, GlobalSettingsProto.WEBVIEW_MULTIPROCESS);
    dumpSetting(s, p, Settings.Global.NETWORK_SWITCH_NOTIFICATION_DAILY_LIMIT, GlobalSettingsProto.NETWORK_SWITCH_NOTIFICATION_DAILY_LIMIT);
    dumpSetting(s, p, Settings.Global.NETWORK_SWITCH_NOTIFICATION_RATE_LIMIT_MILLIS, GlobalSettingsProto.NETWORK_SWITCH_NOTIFICATION_RATE_LIMIT_MILLIS);
    dumpSetting(s, p, Settings.Global.NETWORK_AVOID_BAD_WIFI, GlobalSettingsProto.NETWORK_AVOID_BAD_WIFI);
    dumpSetting(s, p, Settings.Global.WIFI_DISPLAY_ON, GlobalSettingsProto.WIFI_DISPLAY_ON);
    dumpSetting(s, p, Settings.Global.WIFI_DISPLAY_CERTIFICATION_ON, GlobalSettingsProto.WIFI_DISPLAY_CERTIFICATION_ON);
    dumpSetting(s, p, Settings.Global.WIFI_DISPLAY_WPS_CONFIG, GlobalSettingsProto.WIFI_DISPLAY_WPS_CONFIG);
    dumpSetting(s, p, Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON, GlobalSettingsProto.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON);
    dumpSetting(s, p, Settings.Global.WIMAX_NETWORKS_AVAILABLE_NOTIFICATION_ON, GlobalSettingsProto.WIMAX_NETWORKS_AVAILABLE_NOTIFICATION_ON);
    dumpSetting(s, p, Settings.Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY, GlobalSettingsProto.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY);
    dumpSetting(s, p, Settings.Global.WIFI_COUNTRY_CODE, GlobalSettingsProto.WIFI_COUNTRY_CODE);
    dumpSetting(s, p, Settings.Global.WIFI_FRAMEWORK_SCAN_INTERVAL_MS, GlobalSettingsProto.WIFI_FRAMEWORK_SCAN_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.WIFI_IDLE_MS, GlobalSettingsProto.WIFI_IDLE_MS);
    dumpSetting(s, p, Settings.Global.WIFI_NUM_OPEN_NETWORKS_KEPT, GlobalSettingsProto.WIFI_NUM_OPEN_NETWORKS_KEPT);
    dumpSetting(s, p, Settings.Global.WIFI_ON, GlobalSettingsProto.WIFI_ON);
    dumpSetting(s, p, Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, GlobalSettingsProto.WIFI_SCAN_ALWAYS_AVAILABLE);
    dumpSetting(s, p, Settings.Global.WIFI_WAKEUP_ENABLED, GlobalSettingsProto.WIFI_WAKEUP_ENABLED);
    dumpSetting(s, p, Settings.Global.NETWORK_RECOMMENDATIONS_ENABLED, GlobalSettingsProto.NETWORK_RECOMMENDATIONS_ENABLED);
    dumpSetting(s, p, Settings.Global.NETWORK_RECOMMENDATIONS_PACKAGE, GlobalSettingsProto.NETWORK_RECOMMENDATIONS_PACKAGE);
    dumpSetting(s, p, Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, GlobalSettingsProto.BLE_SCAN_ALWAYS_AVAILABLE);
    dumpSetting(s, p, Settings.Global.WIFI_SAVED_STATE, GlobalSettingsProto.WIFI_SAVED_STATE);
    dumpSetting(s, p, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, GlobalSettingsProto.WIFI_SUPPLICANT_SCAN_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.WIFI_ENHANCED_AUTO_JOIN, GlobalSettingsProto.WIFI_ENHANCED_AUTO_JOIN);
    dumpSetting(s, p, Settings.Global.WIFI_NETWORK_SHOW_RSSI, GlobalSettingsProto.WIFI_NETWORK_SHOW_RSSI);
    dumpSetting(s, p, Settings.Global.WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS, GlobalSettingsProto.WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS);
    dumpSetting(s, p, Settings.Global.WIFI_WATCHDOG_ON, GlobalSettingsProto.WIFI_WATCHDOG_ON);
    dumpSetting(s, p, Settings.Global.WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED, GlobalSettingsProto.WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED);
    dumpSetting(s, p, Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED, GlobalSettingsProto.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED);
    dumpSetting(s, p, Settings.Global.WIFI_VERBOSE_LOGGING_ENABLED, GlobalSettingsProto.WIFI_VERBOSE_LOGGING_ENABLED);
    dumpSetting(s, p, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, GlobalSettingsProto.WIFI_MAX_DHCP_RETRY_COUNT);
    dumpSetting(s, p, Settings.Global.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS, GlobalSettingsProto.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS);
    dumpSetting(s, p, Settings.Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN, GlobalSettingsProto.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN);
    dumpSetting(s, p, Settings.Global.WIFI_FREQUENCY_BAND, GlobalSettingsProto.WIFI_FREQUENCY_BAND);
    dumpSetting(s, p, Settings.Global.WIFI_P2P_DEVICE_NAME, GlobalSettingsProto.WIFI_P2P_DEVICE_NAME);
    dumpSetting(s, p, Settings.Global.WIFI_REENABLE_DELAY_MS, GlobalSettingsProto.WIFI_REENABLE_DELAY_MS);
    dumpSetting(s, p, Settings.Global.WIFI_EPHEMERAL_OUT_OF_RANGE_TIMEOUT_MS, GlobalSettingsProto.WIFI_EPHEMERAL_OUT_OF_RANGE_TIMEOUT_MS);
    dumpSetting(s, p, Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS, GlobalSettingsProto.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS);
    dumpSetting(s, p, Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS, GlobalSettingsProto.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS);
    dumpSetting(s, p, Settings.Global.PROVISIONING_APN_ALARM_DELAY_IN_MS, GlobalSettingsProto.PROVISIONING_APN_ALARM_DELAY_IN_MS);
    dumpSetting(s, p, Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, GlobalSettingsProto.GPRS_REGISTER_CHECK_PERIOD_MS);
    dumpSetting(s, p, Settings.Global.WTF_IS_FATAL, GlobalSettingsProto.WTF_IS_FATAL);
    dumpSetting(s, p, Settings.Global.MODE_RINGER, GlobalSettingsProto.MODE_RINGER);
    dumpSetting(s, p, Settings.Global.OVERLAY_DISPLAY_DEVICES, GlobalSettingsProto.OVERLAY_DISPLAY_DEVICES);
    dumpSetting(s, p, Settings.Global.BATTERY_DISCHARGE_DURATION_THRESHOLD, GlobalSettingsProto.BATTERY_DISCHARGE_DURATION_THRESHOLD);
    dumpSetting(s, p, Settings.Global.BATTERY_DISCHARGE_THRESHOLD, GlobalSettingsProto.BATTERY_DISCHARGE_THRESHOLD);
    dumpSetting(s, p, Settings.Global.SEND_ACTION_APP_ERROR, GlobalSettingsProto.SEND_ACTION_APP_ERROR);
    dumpSetting(s, p, Settings.Global.DROPBOX_AGE_SECONDS, GlobalSettingsProto.DROPBOX_AGE_SECONDS);
    dumpSetting(s, p, Settings.Global.DROPBOX_MAX_FILES, GlobalSettingsProto.DROPBOX_MAX_FILES);
    dumpSetting(s, p, Settings.Global.DROPBOX_QUOTA_KB, GlobalSettingsProto.DROPBOX_QUOTA_KB);
    dumpSetting(s, p, Settings.Global.DROPBOX_QUOTA_PERCENT, GlobalSettingsProto.DROPBOX_QUOTA_PERCENT);
    dumpSetting(s, p, Settings.Global.DROPBOX_RESERVE_PERCENT, GlobalSettingsProto.DROPBOX_RESERVE_PERCENT);
    dumpSetting(s, p, Settings.Global.DROPBOX_TAG_PREFIX, GlobalSettingsProto.DROPBOX_TAG_PREFIX);
    dumpSetting(s, p, Settings.Global.ERROR_LOGCAT_PREFIX, GlobalSettingsProto.ERROR_LOGCAT_PREFIX);
    dumpSetting(s, p, Settings.Global.SYS_FREE_STORAGE_LOG_INTERVAL, GlobalSettingsProto.SYS_FREE_STORAGE_LOG_INTERVAL);
    dumpSetting(s, p, Settings.Global.DISK_FREE_CHANGE_REPORTING_THRESHOLD, GlobalSettingsProto.DISK_FREE_CHANGE_REPORTING_THRESHOLD);
    dumpSetting(s, p, Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE, GlobalSettingsProto.SYS_STORAGE_THRESHOLD_PERCENTAGE);
    dumpSetting(s, p, Settings.Global.SYS_STORAGE_THRESHOLD_MAX_BYTES, GlobalSettingsProto.SYS_STORAGE_THRESHOLD_MAX_BYTES);
    dumpSetting(s, p, Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES, GlobalSettingsProto.SYS_STORAGE_FULL_THRESHOLD_BYTES);
    dumpSetting(s, p, Settings.Global.SYNC_MAX_RETRY_DELAY_IN_SECONDS, GlobalSettingsProto.SYNC_MAX_RETRY_DELAY_IN_SECONDS);
    dumpSetting(s, p, Settings.Global.CONNECTIVITY_CHANGE_DELAY, GlobalSettingsProto.CONNECTIVITY_CHANGE_DELAY);
    dumpSetting(s, p, Settings.Global.CONNECTIVITY_SAMPLING_INTERVAL_IN_SECONDS, GlobalSettingsProto.CONNECTIVITY_SAMPLING_INTERVAL_IN_SECONDS);
    dumpSetting(s, p, Settings.Global.PAC_CHANGE_DELAY, GlobalSettingsProto.PAC_CHANGE_DELAY);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_MODE, GlobalSettingsProto.CAPTIVE_PORTAL_MODE);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_SERVER, GlobalSettingsProto.CAPTIVE_PORTAL_SERVER);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_HTTPS_URL, GlobalSettingsProto.CAPTIVE_PORTAL_HTTPS_URL);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_HTTP_URL, GlobalSettingsProto.CAPTIVE_PORTAL_HTTP_URL);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_FALLBACK_URL, GlobalSettingsProto.CAPTIVE_PORTAL_FALLBACK_URL);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_USE_HTTPS, GlobalSettingsProto.CAPTIVE_PORTAL_USE_HTTPS);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_USER_AGENT, GlobalSettingsProto.CAPTIVE_PORTAL_USER_AGENT);
    dumpSetting(s, p, Settings.Global.NSD_ON, GlobalSettingsProto.NSD_ON);
    dumpSetting(s, p, Settings.Global.SET_INSTALL_LOCATION, GlobalSettingsProto.SET_INSTALL_LOCATION);
    dumpSetting(s, p, Settings.Global.DEFAULT_INSTALL_LOCATION, GlobalSettingsProto.DEFAULT_INSTALL_LOCATION);
    dumpSetting(s, p, Settings.Global.INET_CONDITION_DEBOUNCE_UP_DELAY, GlobalSettingsProto.INET_CONDITION_DEBOUNCE_UP_DELAY);
    dumpSetting(s, p, Settings.Global.INET_CONDITION_DEBOUNCE_DOWN_DELAY, GlobalSettingsProto.INET_CONDITION_DEBOUNCE_DOWN_DELAY);
    dumpSetting(s, p, Settings.Global.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT, GlobalSettingsProto.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT);
    dumpSetting(s, p, Settings.Global.HTTP_PROXY, GlobalSettingsProto.HTTP_PROXY);
    dumpSetting(s, p, Settings.Global.GLOBAL_HTTP_PROXY_HOST, GlobalSettingsProto.GLOBAL_HTTP_PROXY_HOST);
    dumpSetting(s, p, Settings.Global.GLOBAL_HTTP_PROXY_PORT, GlobalSettingsProto.GLOBAL_HTTP_PROXY_PORT);
    dumpSetting(s, p, Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST, GlobalSettingsProto.GLOBAL_HTTP_PROXY_EXCLUSION_LIST);
    dumpSetting(s, p, Settings.Global.GLOBAL_HTTP_PROXY_PAC, GlobalSettingsProto.GLOBAL_HTTP_PROXY_PAC);
    dumpSetting(s, p, Settings.Global.SET_GLOBAL_HTTP_PROXY, GlobalSettingsProto.SET_GLOBAL_HTTP_PROXY);
    dumpSetting(s, p, Settings.Global.DEFAULT_DNS_SERVER, GlobalSettingsProto.DEFAULT_DNS_SERVER);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_HEADSET_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_HEADSET_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_A2DP_SRC_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_A2DP_SRC_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_A2DP_SUPPORTS_OPTIONAL_CODECS_PREFIX, GlobalSettingsProto.BLUETOOTH_A2DP_SUPPORTS_OPTIONAL_CODECS_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_A2DP_OPTIONAL_CODECS_ENABLED_PREFIX, GlobalSettingsProto.BLUETOOTH_A2DP_OPTIONAL_CODECS_ENABLED_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_MAP_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_MAP_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_MAP_CLIENT_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_MAP_CLIENT_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_PBAP_CLIENT_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_PBAP_CLIENT_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_SAP_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_SAP_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_PAN_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_PAN_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_HEARING_AID_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_HEARING_AID_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.DEVICE_IDLE_CONSTANTS, GlobalSettingsProto.DEVICE_IDLE_CONSTANTS);
    dumpSetting(s, p, Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH, GlobalSettingsProto.DEVICE_IDLE_CONSTANTS_WATCH);
    dumpSetting(s, p, Settings.Global.APP_IDLE_CONSTANTS, GlobalSettingsProto.APP_IDLE_CONSTANTS);
    dumpSetting(s, p, Settings.Global.ALARM_MANAGER_CONSTANTS, GlobalSettingsProto.ALARM_MANAGER_CONSTANTS);
    dumpSetting(s, p, Settings.Global.JOB_SCHEDULER_CONSTANTS, GlobalSettingsProto.JOB_SCHEDULER_CONSTANTS);
    dumpSetting(s, p, Settings.Global.SHORTCUT_MANAGER_CONSTANTS, GlobalSettingsProto.SHORTCUT_MANAGER_CONSTANTS);
    dumpSetting(s, p, Settings.Global.WINDOW_ANIMATION_SCALE, GlobalSettingsProto.WINDOW_ANIMATION_SCALE);
    dumpSetting(s, p, Settings.Global.TRANSITION_ANIMATION_SCALE, GlobalSettingsProto.TRANSITION_ANIMATION_SCALE);
    dumpSetting(s, p, Settings.Global.ANIMATOR_DURATION_SCALE, GlobalSettingsProto.ANIMATOR_DURATION_SCALE);
    dumpSetting(s, p, Settings.Global.FANCY_IME_ANIMATIONS, GlobalSettingsProto.FANCY_IME_ANIMATIONS);
    dumpSetting(s, p, Settings.Global.COMPATIBILITY_MODE, GlobalSettingsProto.COMPATIBILITY_MODE);
    dumpSetting(s, p, Settings.Global.EMERGENCY_TONE, GlobalSettingsProto.EMERGENCY_TONE);
    dumpSetting(s, p, Settings.Global.CALL_AUTO_RETRY, GlobalSettingsProto.CALL_AUTO_RETRY);
    dumpSetting(s, p, Settings.Global.EMERGENCY_AFFORDANCE_NEEDED, GlobalSettingsProto.EMERGENCY_AFFORDANCE_NEEDED);
    dumpSetting(s, p, Settings.Global.PREFERRED_NETWORK_MODE, GlobalSettingsProto.PREFERRED_NETWORK_MODE);
    dumpSetting(s, p, Settings.Global.DEBUG_APP, GlobalSettingsProto.DEBUG_APP);
    dumpSetting(s, p, Settings.Global.WAIT_FOR_DEBUGGER, GlobalSettingsProto.WAIT_FOR_DEBUGGER);
    dumpSetting(s, p, Settings.Global.LOW_POWER_MODE, GlobalSettingsProto.LOW_POWER_MODE);
    dumpSetting(s, p, Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL, GlobalSettingsProto.LOW_POWER_MODE_TRIGGER_LEVEL);
    dumpSetting(s, p, Settings.Global.ALWAYS_FINISH_ACTIVITIES, GlobalSettingsProto.ALWAYS_FINISH_ACTIVITIES);
    dumpSetting(s, p, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED, GlobalSettingsProto.DOCK_AUDIO_MEDIA_ENABLED);
    dumpSetting(s, p, Settings.Global.ENCODED_SURROUND_OUTPUT, GlobalSettingsProto.ENCODED_SURROUND_OUTPUT);
    dumpSetting(s, p, Settings.Global.AUDIO_SAFE_VOLUME_STATE, GlobalSettingsProto.AUDIO_SAFE_VOLUME_STATE);
    dumpSetting(s, p, Settings.Global.TZINFO_UPDATE_CONTENT_URL, GlobalSettingsProto.TZINFO_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.TZINFO_UPDATE_METADATA_URL, GlobalSettingsProto.TZINFO_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.SELINUX_UPDATE_CONTENT_URL, GlobalSettingsProto.SELINUX_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.SELINUX_UPDATE_METADATA_URL, GlobalSettingsProto.SELINUX_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.SMS_SHORT_CODES_UPDATE_CONTENT_URL, GlobalSettingsProto.SMS_SHORT_CODES_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.SMS_SHORT_CODES_UPDATE_METADATA_URL, GlobalSettingsProto.SMS_SHORT_CODES_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.APN_DB_UPDATE_CONTENT_URL, GlobalSettingsProto.APN_DB_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.APN_DB_UPDATE_METADATA_URL, GlobalSettingsProto.APN_DB_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.CERT_PIN_UPDATE_CONTENT_URL, GlobalSettingsProto.CERT_PIN_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.CERT_PIN_UPDATE_METADATA_URL, GlobalSettingsProto.CERT_PIN_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.INTENT_FIREWALL_UPDATE_CONTENT_URL, GlobalSettingsProto.INTENT_FIREWALL_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.INTENT_FIREWALL_UPDATE_METADATA_URL, GlobalSettingsProto.INTENT_FIREWALL_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.SELINUX_STATUS, GlobalSettingsProto.SELINUX_STATUS);
    dumpSetting(s, p, Settings.Global.DEVELOPMENT_FORCE_RTL, GlobalSettingsProto.DEVELOPMENT_FORCE_RTL);
    dumpSetting(s, p, Settings.Global.LOW_BATTERY_SOUND_TIMEOUT, GlobalSettingsProto.LOW_BATTERY_SOUND_TIMEOUT);
    dumpSetting(s, p, Settings.Global.WIFI_BOUNCE_DELAY_OVERRIDE_MS, GlobalSettingsProto.WIFI_BOUNCE_DELAY_OVERRIDE_MS);
    dumpSetting(s, p, Settings.Global.POLICY_CONTROL, GlobalSettingsProto.POLICY_CONTROL);
    dumpSetting(s, p, Settings.Global.ZEN_MODE, GlobalSettingsProto.ZEN_MODE);
    dumpSetting(s, p, Settings.Global.ZEN_MODE_RINGER_LEVEL, GlobalSettingsProto.ZEN_MODE_RINGER_LEVEL);
    dumpSetting(s, p, Settings.Global.ZEN_MODE_CONFIG_ETAG, GlobalSettingsProto.ZEN_MODE_CONFIG_ETAG);
    dumpSetting(s, p, Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED, GlobalSettingsProto.HEADS_UP_NOTIFICATIONS_ENABLED);
    dumpSetting(s, p, Settings.Global.DEVICE_NAME, GlobalSettingsProto.DEVICE_NAME);
    dumpSetting(s, p, Settings.Global.NETWORK_SCORING_PROVISIONED, GlobalSettingsProto.NETWORK_SCORING_PROVISIONED);
    dumpSetting(s, p, Settings.Global.REQUIRE_PASSWORD_TO_DECRYPT, GlobalSettingsProto.REQUIRE_PASSWORD_TO_DECRYPT);
    dumpSetting(s, p, Settings.Global.ENHANCED_4G_MODE_ENABLED, GlobalSettingsProto.ENHANCED_4G_MODE_ENABLED);
    dumpSetting(s, p, Settings.Global.VT_IMS_ENABLED, GlobalSettingsProto.VT_IMS_ENABLED);
    dumpSetting(s, p, Settings.Global.WFC_IMS_ENABLED, GlobalSettingsProto.WFC_IMS_ENABLED);
    dumpSetting(s, p, Settings.Global.WFC_IMS_MODE, GlobalSettingsProto.WFC_IMS_MODE);
    dumpSetting(s, p, Settings.Global.WFC_IMS_ROAMING_MODE, GlobalSettingsProto.WFC_IMS_ROAMING_MODE);
    dumpSetting(s, p, Settings.Global.WFC_IMS_ROAMING_ENABLED, GlobalSettingsProto.WFC_IMS_ROAMING_ENABLED);
    dumpSetting(s, p, Settings.Global.LTE_SERVICE_FORCED, GlobalSettingsProto.LTE_SERVICE_FORCED);
    dumpSetting(s, p, Settings.Global.EPHEMERAL_COOKIE_MAX_SIZE_BYTES, GlobalSettingsProto.EPHEMERAL_COOKIE_MAX_SIZE_BYTES);
    dumpSetting(s, p, Settings.Global.ENABLE_EPHEMERAL_FEATURE, GlobalSettingsProto.ENABLE_EPHEMERAL_FEATURE);
    dumpSetting(s, p, Settings.Global.UNINSTALLED_INSTANT_APP_MIN_CACHE_PERIOD, GlobalSettingsProto.UNINSTALLED_INSTANT_APP_MIN_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.UNINSTALLED_INSTANT_APP_MAX_CACHE_PERIOD, GlobalSettingsProto.UNINSTALLED_INSTANT_APP_MAX_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD, GlobalSettingsProto.INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.INSTALLED_INSTANT_APP_MAX_CACHE_PERIOD, GlobalSettingsProto.INSTALLED_INSTANT_APP_MAX_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD, GlobalSettingsProto.UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.ALLOW_USER_SWITCHING_WHEN_SYSTEM_USER_LOCKED, GlobalSettingsProto.ALLOW_USER_SWITCHING_WHEN_SYSTEM_USER_LOCKED);
    dumpSetting(s, p, Settings.Global.BOOT_COUNT, GlobalSettingsProto.BOOT_COUNT);
    dumpSetting(s, p, Settings.Global.SAFE_BOOT_DISALLOWED, GlobalSettingsProto.SAFE_BOOT_DISALLOWED);
    dumpSetting(s, p, Settings.Global.DEVICE_DEMO_MODE, GlobalSettingsProto.DEVICE_DEMO_MODE);
    dumpSetting(s, p, Settings.Global.DATABASE_DOWNGRADE_REASON, GlobalSettingsProto.DATABASE_DOWNGRADE_REASON);
    dumpSetting(s, p, Settings.Global.CONTACTS_DATABASE_WAL_ENABLED, GlobalSettingsProto.CONTACTS_DATABASE_WAL_ENABLED);
    dumpSetting(s, p, Global.HIDDEN_API_BLACKLIST_EXEMPTIONS, GlobalSettingsProto.HIDDEN_API_BLACKLIST_EXEMPTIONS);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_VOICE_CALL_SUBSCRIPTION, GlobalSettingsProto.MULTI_SIM_VOICE_CALL_SUBSCRIPTION);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_VOICE_PROMPT, GlobalSettingsProto.MULTI_SIM_VOICE_PROMPT);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION, GlobalSettingsProto.MULTI_SIM_DATA_CALL_SUBSCRIPTION);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_SMS_SUBSCRIPTION, GlobalSettingsProto.MULTI_SIM_SMS_SUBSCRIPTION);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_SMS_PROMPT, GlobalSettingsProto.MULTI_SIM_SMS_PROMPT);
    dumpSetting(s, p, Settings.Global.NEW_CONTACT_AGGREGATOR, GlobalSettingsProto.NEW_CONTACT_AGGREGATOR);
    dumpSetting(s, p, Settings.Global.CONTACT_METADATA_SYNC_ENABLED, GlobalSettingsProto.CONTACT_METADATA_SYNC_ENABLED);
    dumpSetting(s, p, Settings.Global.ENABLE_CELLULAR_ON_BOOT, GlobalSettingsProto.ENABLE_CELLULAR_ON_BOOT);
    dumpSetting(s, p, Settings.Global.MAX_NOTIFICATION_ENQUEUE_RATE, GlobalSettingsProto.MAX_NOTIFICATION_ENQUEUE_RATE);
    dumpSetting(s, p, Settings.Global.CELL_ON, GlobalSettingsProto.CELL_ON);
}
#method_after
private static void dumpProtoGlobalSettingsLocked(@NonNull SettingsState s, @NonNull ProtoOutputStream p) {
    dumpSetting(s, p, Settings.Global.ADD_USERS_WHEN_LOCKED, GlobalSettingsProto.ADD_USERS_WHEN_LOCKED);
    dumpSetting(s, p, Settings.Global.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED, GlobalSettingsProto.ENABLE_ACCESSIBILITY_GLOBAL_GESTURE_ENABLED);
    dumpSetting(s, p, Settings.Global.AIRPLANE_MODE_ON, GlobalSettingsProto.AIRPLANE_MODE_ON);
    dumpSetting(s, p, Settings.Global.THEATER_MODE_ON, GlobalSettingsProto.THEATER_MODE_ON);
    dumpSetting(s, p, Settings.Global.RADIO_BLUETOOTH, GlobalSettingsProto.RADIO_BLUETOOTH);
    dumpSetting(s, p, Settings.Global.RADIO_WIFI, GlobalSettingsProto.RADIO_WIFI);
    dumpSetting(s, p, Settings.Global.RADIO_WIMAX, GlobalSettingsProto.RADIO_WIMAX);
    dumpSetting(s, p, Settings.Global.RADIO_CELL, GlobalSettingsProto.RADIO_CELL);
    dumpSetting(s, p, Settings.Global.RADIO_NFC, GlobalSettingsProto.RADIO_NFC);
    dumpSetting(s, p, Settings.Global.AIRPLANE_MODE_RADIOS, GlobalSettingsProto.AIRPLANE_MODE_RADIOS);
    dumpSetting(s, p, Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS, GlobalSettingsProto.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_DISABLED_PROFILES, GlobalSettingsProto.BLUETOOTH_DISABLED_PROFILES);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_INTEROPERABILITY_LIST, GlobalSettingsProto.BLUETOOTH_INTEROPERABILITY_LIST);
    dumpSetting(s, p, Settings.Global.WIFI_SLEEP_POLICY, GlobalSettingsProto.WIFI_SLEEP_POLICY);
    dumpSetting(s, p, Settings.Global.AUTO_TIME, GlobalSettingsProto.AUTO_TIME);
    dumpSetting(s, p, Settings.Global.AUTO_TIME_ZONE, GlobalSettingsProto.AUTO_TIME_ZONE);
    dumpSetting(s, p, Settings.Global.CAR_DOCK_SOUND, GlobalSettingsProto.CAR_DOCK_SOUND);
    dumpSetting(s, p, Settings.Global.CAR_UNDOCK_SOUND, GlobalSettingsProto.CAR_UNDOCK_SOUND);
    dumpSetting(s, p, Settings.Global.DESK_DOCK_SOUND, GlobalSettingsProto.DESK_DOCK_SOUND);
    dumpSetting(s, p, Settings.Global.DESK_UNDOCK_SOUND, GlobalSettingsProto.DESK_UNDOCK_SOUND);
    dumpSetting(s, p, Settings.Global.DOCK_SOUNDS_ENABLED, GlobalSettingsProto.DOCK_SOUNDS_ENABLED);
    dumpSetting(s, p, Settings.Global.DOCK_SOUNDS_ENABLED_WHEN_ACCESSIBILITY, GlobalSettingsProto.DOCK_SOUNDS_ENABLED_WHEN_ACCESSIBILITY);
    dumpSetting(s, p, Settings.Global.LOCK_SOUND, GlobalSettingsProto.LOCK_SOUND);
    dumpSetting(s, p, Settings.Global.UNLOCK_SOUND, GlobalSettingsProto.UNLOCK_SOUND);
    dumpSetting(s, p, Settings.Global.TRUSTED_SOUND, GlobalSettingsProto.TRUSTED_SOUND);
    dumpSetting(s, p, Settings.Global.LOW_BATTERY_SOUND, GlobalSettingsProto.LOW_BATTERY_SOUND);
    dumpSetting(s, p, Settings.Global.POWER_SOUNDS_ENABLED, GlobalSettingsProto.POWER_SOUNDS_ENABLED);
    dumpSetting(s, p, Settings.Global.WIRELESS_CHARGING_STARTED_SOUND, GlobalSettingsProto.WIRELESS_CHARGING_STARTED_SOUND);
    dumpSetting(s, p, Settings.Global.CHARGING_SOUNDS_ENABLED, GlobalSettingsProto.CHARGING_SOUNDS_ENABLED);
    dumpSetting(s, p, Settings.Global.STAY_ON_WHILE_PLUGGED_IN, GlobalSettingsProto.STAY_ON_WHILE_PLUGGED_IN);
    dumpSetting(s, p, Settings.Global.BUGREPORT_IN_POWER_MENU, GlobalSettingsProto.BUGREPORT_IN_POWER_MENU);
    dumpSetting(s, p, Settings.Global.ADB_ENABLED, GlobalSettingsProto.ADB_ENABLED);
    dumpSetting(s, p, Settings.Global.DEBUG_VIEW_ATTRIBUTES, GlobalSettingsProto.DEBUG_VIEW_ATTRIBUTES);
    dumpSetting(s, p, Settings.Global.ASSISTED_GPS_ENABLED, GlobalSettingsProto.ASSISTED_GPS_ENABLED);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_ON, GlobalSettingsProto.BLUETOOTH_ON);
    dumpSetting(s, p, Settings.Global.CDMA_CELL_BROADCAST_SMS, GlobalSettingsProto.CDMA_CELL_BROADCAST_SMS);
    dumpSetting(s, p, Settings.Global.CDMA_ROAMING_MODE, GlobalSettingsProto.CDMA_ROAMING_MODE);
    dumpSetting(s, p, Settings.Global.CDMA_SUBSCRIPTION_MODE, GlobalSettingsProto.CDMA_SUBSCRIPTION_MODE);
    dumpSetting(s, p, Settings.Global.DATA_ACTIVITY_TIMEOUT_MOBILE, GlobalSettingsProto.DATA_ACTIVITY_TIMEOUT_MOBILE);
    dumpSetting(s, p, Settings.Global.DATA_ACTIVITY_TIMEOUT_WIFI, GlobalSettingsProto.DATA_ACTIVITY_TIMEOUT_WIFI);
    dumpSetting(s, p, Settings.Global.DATA_ROAMING, GlobalSettingsProto.DATA_ROAMING);
    dumpSetting(s, p, Settings.Global.MDC_INITIAL_MAX_RETRY, GlobalSettingsProto.MDC_INITIAL_MAX_RETRY);
    dumpSetting(s, p, Settings.Global.FORCE_ALLOW_ON_EXTERNAL, GlobalSettingsProto.FORCE_ALLOW_ON_EXTERNAL);
    dumpSetting(s, p, Settings.Global.DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, GlobalSettingsProto.DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES);
    dumpSetting(s, p, Settings.Global.DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, GlobalSettingsProto.DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT);
    dumpSetting(s, p, Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, GlobalSettingsProto.DEVELOPMENT_SETTINGS_ENABLED);
    dumpSetting(s, p, Settings.Global.DEVICE_PROVISIONED, GlobalSettingsProto.DEVICE_PROVISIONED);
    dumpSetting(s, p, Settings.Global.DEVICE_PROVISIONING_MOBILE_DATA_ENABLED, GlobalSettingsProto.DEVICE_PROVISIONING_MOBILE_DATA_ENABLED);
    dumpSetting(s, p, Settings.Global.DISPLAY_SIZE_FORCED, GlobalSettingsProto.DISPLAY_SIZE_FORCED);
    dumpSetting(s, p, Settings.Global.DISPLAY_SCALING_FORCE, GlobalSettingsProto.DISPLAY_SCALING_FORCE);
    dumpSetting(s, p, Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE, GlobalSettingsProto.DOWNLOAD_MAX_BYTES_OVER_MOBILE);
    dumpSetting(s, p, Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE, GlobalSettingsProto.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE);
    dumpSetting(s, p, Settings.Global.HDMI_CONTROL_ENABLED, GlobalSettingsProto.HDMI_CONTROL_ENABLED);
    dumpSetting(s, p, Settings.Global.HDMI_SYSTEM_AUDIO_CONTROL_ENABLED, GlobalSettingsProto.HDMI_SYSTEM_AUDIO_CONTROL_ENABLED);
    dumpSetting(s, p, Settings.Global.HDMI_CONTROL_AUTO_WAKEUP_ENABLED, GlobalSettingsProto.HDMI_CONTROL_AUTO_WAKEUP_ENABLED);
    dumpSetting(s, p, Settings.Global.HDMI_CONTROL_AUTO_DEVICE_OFF_ENABLED, GlobalSettingsProto.HDMI_CONTROL_AUTO_DEVICE_OFF_ENABLED);
    dumpSetting(s, p, Settings.Global.MHL_INPUT_SWITCHING_ENABLED, GlobalSettingsProto.MHL_INPUT_SWITCHING_ENABLED);
    dumpSetting(s, p, Settings.Global.MHL_POWER_CHARGE_ENABLED, GlobalSettingsProto.MHL_POWER_CHARGE_ENABLED);
    dumpSetting(s, p, Settings.Global.MOBILE_DATA, GlobalSettingsProto.MOBILE_DATA);
    dumpSetting(s, p, Settings.Global.MOBILE_DATA_ALWAYS_ON, GlobalSettingsProto.MOBILE_DATA_ALWAYS_ON);
    dumpSetting(s, p, Settings.Global.CONNECTIVITY_METRICS_BUFFER_SIZE, GlobalSettingsProto.CONNECTIVITY_METRICS_BUFFER_SIZE);
    dumpSetting(s, p, Settings.Global.NETSTATS_ENABLED, GlobalSettingsProto.NETSTATS_ENABLED);
    dumpSetting(s, p, Settings.Global.NETSTATS_POLL_INTERVAL, GlobalSettingsProto.NETSTATS_POLL_INTERVAL);
    dumpSetting(s, p, Settings.Global.NETSTATS_TIME_CACHE_MAX_AGE, GlobalSettingsProto.NETSTATS_TIME_CACHE_MAX_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_GLOBAL_ALERT_BYTES, GlobalSettingsProto.NETSTATS_GLOBAL_ALERT_BYTES);
    dumpSetting(s, p, Settings.Global.NETSTATS_SAMPLE_ENABLED, GlobalSettingsProto.NETSTATS_SAMPLE_ENABLED);
    dumpSetting(s, p, Settings.Global.NETSTATS_DEV_BUCKET_DURATION, GlobalSettingsProto.NETSTATS_DEV_BUCKET_DURATION);
    dumpSetting(s, p, Settings.Global.NETSTATS_DEV_PERSIST_BYTES, GlobalSettingsProto.NETSTATS_DEV_PERSIST_BYTES);
    dumpSetting(s, p, Settings.Global.NETSTATS_DEV_ROTATE_AGE, GlobalSettingsProto.NETSTATS_DEV_ROTATE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_DEV_DELETE_AGE, GlobalSettingsProto.NETSTATS_DEV_DELETE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_BUCKET_DURATION, GlobalSettingsProto.NETSTATS_UID_BUCKET_DURATION);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_PERSIST_BYTES, GlobalSettingsProto.NETSTATS_UID_PERSIST_BYTES);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_ROTATE_AGE, GlobalSettingsProto.NETSTATS_UID_ROTATE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_DELETE_AGE, GlobalSettingsProto.NETSTATS_UID_DELETE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_TAG_BUCKET_DURATION, GlobalSettingsProto.NETSTATS_UID_TAG_BUCKET_DURATION);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_TAG_PERSIST_BYTES, GlobalSettingsProto.NETSTATS_UID_TAG_PERSIST_BYTES);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_TAG_ROTATE_AGE, GlobalSettingsProto.NETSTATS_UID_TAG_ROTATE_AGE);
    dumpSetting(s, p, Settings.Global.NETSTATS_UID_TAG_DELETE_AGE, GlobalSettingsProto.NETSTATS_UID_TAG_DELETE_AGE);
    dumpSetting(s, p, Settings.Global.NETWORK_PREFERENCE, GlobalSettingsProto.NETWORK_PREFERENCE);
    dumpSetting(s, p, Settings.Global.NETWORK_SCORER_APP, GlobalSettingsProto.NETWORK_SCORER_APP);
    dumpSetting(s, p, Settings.Global.NITZ_UPDATE_DIFF, GlobalSettingsProto.NITZ_UPDATE_DIFF);
    dumpSetting(s, p, Settings.Global.NITZ_UPDATE_SPACING, GlobalSettingsProto.NITZ_UPDATE_SPACING);
    dumpSetting(s, p, Settings.Global.NTP_SERVER, GlobalSettingsProto.NTP_SERVER);
    dumpSetting(s, p, Settings.Global.NTP_TIMEOUT, GlobalSettingsProto.NTP_TIMEOUT);
    dumpSetting(s, p, Settings.Global.STORAGE_BENCHMARK_INTERVAL, GlobalSettingsProto.STORAGE_BENCHMARK_INTERVAL);
    dumpSetting(s, p, Settings.Global.DNS_RESOLVER_SAMPLE_VALIDITY_SECONDS, GlobalSettingsProto.DNS_RESOLVER_SAMPLE_VALIDITY_SECONDS);
    dumpSetting(s, p, Settings.Global.DNS_RESOLVER_SUCCESS_THRESHOLD_PERCENT, GlobalSettingsProto.DNS_RESOLVER_SUCCESS_THRESHOLD_PERCENT);
    dumpSetting(s, p, Settings.Global.DNS_RESOLVER_MIN_SAMPLES, GlobalSettingsProto.DNS_RESOLVER_MIN_SAMPLES);
    dumpSetting(s, p, Settings.Global.DNS_RESOLVER_MAX_SAMPLES, GlobalSettingsProto.DNS_RESOLVER_MAX_SAMPLES);
    dumpSetting(s, p, Settings.Global.OTA_DISABLE_AUTOMATIC_UPDATE, GlobalSettingsProto.OTA_DISABLE_AUTOMATIC_UPDATE);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_ENABLE, GlobalSettingsProto.PACKAGE_VERIFIER_ENABLE);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_TIMEOUT, GlobalSettingsProto.PACKAGE_VERIFIER_TIMEOUT);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_DEFAULT_RESPONSE, GlobalSettingsProto.PACKAGE_VERIFIER_DEFAULT_RESPONSE);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_SETTING_VISIBLE, GlobalSettingsProto.PACKAGE_VERIFIER_SETTING_VISIBLE);
    dumpSetting(s, p, Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB, GlobalSettingsProto.PACKAGE_VERIFIER_INCLUDE_ADB);
    dumpSetting(s, p, Settings.Global.FSTRIM_MANDATORY_INTERVAL, GlobalSettingsProto.FSTRIM_MANDATORY_INTERVAL);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_POLL_INTERVAL_MS, GlobalSettingsProto.PDP_WATCHDOG_POLL_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_LONG_POLL_INTERVAL_MS, GlobalSettingsProto.PDP_WATCHDOG_LONG_POLL_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS, GlobalSettingsProto.PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_TRIGGER_PACKET_COUNT, GlobalSettingsProto.PDP_WATCHDOG_TRIGGER_PACKET_COUNT);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_ERROR_POLL_COUNT, GlobalSettingsProto.PDP_WATCHDOG_ERROR_POLL_COUNT);
    dumpSetting(s, p, Settings.Global.PDP_WATCHDOG_MAX_PDP_RESET_FAIL_COUNT, GlobalSettingsProto.PDP_WATCHDOG_MAX_PDP_RESET_FAIL_COUNT);
    dumpSetting(s, p, Settings.Global.SAMPLING_PROFILER_MS, GlobalSettingsProto.SAMPLING_PROFILER_MS);
    dumpSetting(s, p, Settings.Global.SETUP_PREPAID_DATA_SERVICE_URL, GlobalSettingsProto.SETUP_PREPAID_DATA_SERVICE_URL);
    dumpSetting(s, p, Settings.Global.SETUP_PREPAID_DETECTION_TARGET_URL, GlobalSettingsProto.SETUP_PREPAID_DETECTION_TARGET_URL);
    dumpSetting(s, p, Settings.Global.SETUP_PREPAID_DETECTION_REDIR_HOST, GlobalSettingsProto.SETUP_PREPAID_DETECTION_REDIR_HOST);
    dumpSetting(s, p, Settings.Global.SMS_OUTGOING_CHECK_INTERVAL_MS, GlobalSettingsProto.SMS_OUTGOING_CHECK_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.SMS_OUTGOING_CHECK_MAX_COUNT, GlobalSettingsProto.SMS_OUTGOING_CHECK_MAX_COUNT);
    dumpSetting(s, p, Settings.Global.SMS_SHORT_CODE_CONFIRMATION, GlobalSettingsProto.SMS_SHORT_CODE_CONFIRMATION);
    dumpSetting(s, p, Settings.Global.SMS_SHORT_CODE_RULE, GlobalSettingsProto.SMS_SHORT_CODE_RULE);
    dumpSetting(s, p, Settings.Global.TCP_DEFAULT_INIT_RWND, GlobalSettingsProto.TCP_DEFAULT_INIT_RWND);
    dumpSetting(s, p, Settings.Global.TETHER_SUPPORTED, GlobalSettingsProto.TETHER_SUPPORTED);
    dumpSetting(s, p, Settings.Global.TETHER_DUN_REQUIRED, GlobalSettingsProto.TETHER_DUN_REQUIRED);
    dumpSetting(s, p, Settings.Global.TETHER_DUN_APN, GlobalSettingsProto.TETHER_DUN_APN);
    dumpSetting(s, p, Settings.Global.CARRIER_APP_WHITELIST, GlobalSettingsProto.CARRIER_APP_WHITELIST);
    dumpSetting(s, p, Settings.Global.USB_MASS_STORAGE_ENABLED, GlobalSettingsProto.USB_MASS_STORAGE_ENABLED);
    dumpSetting(s, p, Settings.Global.USE_GOOGLE_MAIL, GlobalSettingsProto.USE_GOOGLE_MAIL);
    dumpSetting(s, p, Settings.Global.WEBVIEW_DATA_REDUCTION_PROXY_KEY, GlobalSettingsProto.WEBVIEW_DATA_REDUCTION_PROXY_KEY);
    dumpSetting(s, p, Settings.Global.WEBVIEW_FALLBACK_LOGIC_ENABLED, GlobalSettingsProto.WEBVIEW_FALLBACK_LOGIC_ENABLED);
    dumpSetting(s, p, Settings.Global.WEBVIEW_PROVIDER, GlobalSettingsProto.WEBVIEW_PROVIDER);
    dumpSetting(s, p, Settings.Global.WEBVIEW_MULTIPROCESS, GlobalSettingsProto.WEBVIEW_MULTIPROCESS);
    dumpSetting(s, p, Settings.Global.NETWORK_SWITCH_NOTIFICATION_DAILY_LIMIT, GlobalSettingsProto.NETWORK_SWITCH_NOTIFICATION_DAILY_LIMIT);
    dumpSetting(s, p, Settings.Global.NETWORK_SWITCH_NOTIFICATION_RATE_LIMIT_MILLIS, GlobalSettingsProto.NETWORK_SWITCH_NOTIFICATION_RATE_LIMIT_MILLIS);
    dumpSetting(s, p, Settings.Global.NETWORK_AVOID_BAD_WIFI, GlobalSettingsProto.NETWORK_AVOID_BAD_WIFI);
    dumpSetting(s, p, Settings.Global.WIFI_DISPLAY_ON, GlobalSettingsProto.WIFI_DISPLAY_ON);
    dumpSetting(s, p, Settings.Global.WIFI_DISPLAY_CERTIFICATION_ON, GlobalSettingsProto.WIFI_DISPLAY_CERTIFICATION_ON);
    dumpSetting(s, p, Settings.Global.WIFI_DISPLAY_WPS_CONFIG, GlobalSettingsProto.WIFI_DISPLAY_WPS_CONFIG);
    dumpSetting(s, p, Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON, GlobalSettingsProto.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON);
    dumpSetting(s, p, Settings.Global.WIMAX_NETWORKS_AVAILABLE_NOTIFICATION_ON, GlobalSettingsProto.WIMAX_NETWORKS_AVAILABLE_NOTIFICATION_ON);
    dumpSetting(s, p, Settings.Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY, GlobalSettingsProto.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY);
    dumpSetting(s, p, Settings.Global.WIFI_COUNTRY_CODE, GlobalSettingsProto.WIFI_COUNTRY_CODE);
    dumpSetting(s, p, Settings.Global.WIFI_FRAMEWORK_SCAN_INTERVAL_MS, GlobalSettingsProto.WIFI_FRAMEWORK_SCAN_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.WIFI_IDLE_MS, GlobalSettingsProto.WIFI_IDLE_MS);
    dumpSetting(s, p, Settings.Global.WIFI_NUM_OPEN_NETWORKS_KEPT, GlobalSettingsProto.WIFI_NUM_OPEN_NETWORKS_KEPT);
    dumpSetting(s, p, Settings.Global.WIFI_ON, GlobalSettingsProto.WIFI_ON);
    dumpSetting(s, p, Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, GlobalSettingsProto.WIFI_SCAN_ALWAYS_AVAILABLE);
    dumpSetting(s, p, Settings.Global.WIFI_WAKEUP_ENABLED, GlobalSettingsProto.WIFI_WAKEUP_ENABLED);
    dumpSetting(s, p, Settings.Global.NETWORK_RECOMMENDATIONS_ENABLED, GlobalSettingsProto.NETWORK_RECOMMENDATIONS_ENABLED);
    dumpSetting(s, p, Settings.Global.NETWORK_RECOMMENDATIONS_PACKAGE, GlobalSettingsProto.NETWORK_RECOMMENDATIONS_PACKAGE);
    dumpSetting(s, p, Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, GlobalSettingsProto.BLE_SCAN_ALWAYS_AVAILABLE);
    dumpSetting(s, p, Settings.Global.WIFI_SAVED_STATE, GlobalSettingsProto.WIFI_SAVED_STATE);
    dumpSetting(s, p, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, GlobalSettingsProto.WIFI_SUPPLICANT_SCAN_INTERVAL_MS);
    dumpSetting(s, p, Settings.Global.WIFI_ENHANCED_AUTO_JOIN, GlobalSettingsProto.WIFI_ENHANCED_AUTO_JOIN);
    dumpSetting(s, p, Settings.Global.WIFI_NETWORK_SHOW_RSSI, GlobalSettingsProto.WIFI_NETWORK_SHOW_RSSI);
    dumpSetting(s, p, Settings.Global.WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS, GlobalSettingsProto.WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS);
    dumpSetting(s, p, Settings.Global.WIFI_WATCHDOG_ON, GlobalSettingsProto.WIFI_WATCHDOG_ON);
    dumpSetting(s, p, Settings.Global.WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED, GlobalSettingsProto.WIFI_WATCHDOG_POOR_NETWORK_TEST_ENABLED);
    dumpSetting(s, p, Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED, GlobalSettingsProto.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED);
    dumpSetting(s, p, Settings.Global.WIFI_VERBOSE_LOGGING_ENABLED, GlobalSettingsProto.WIFI_VERBOSE_LOGGING_ENABLED);
    dumpSetting(s, p, Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT, GlobalSettingsProto.WIFI_MAX_DHCP_RETRY_COUNT);
    dumpSetting(s, p, Settings.Global.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS, GlobalSettingsProto.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS);
    dumpSetting(s, p, Settings.Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN, GlobalSettingsProto.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN);
    dumpSetting(s, p, Settings.Global.WIFI_FREQUENCY_BAND, GlobalSettingsProto.WIFI_FREQUENCY_BAND);
    dumpSetting(s, p, Settings.Global.WIFI_P2P_DEVICE_NAME, GlobalSettingsProto.WIFI_P2P_DEVICE_NAME);
    dumpSetting(s, p, Settings.Global.WIFI_REENABLE_DELAY_MS, GlobalSettingsProto.WIFI_REENABLE_DELAY_MS);
    dumpSetting(s, p, Settings.Global.WIFI_EPHEMERAL_OUT_OF_RANGE_TIMEOUT_MS, GlobalSettingsProto.WIFI_EPHEMERAL_OUT_OF_RANGE_TIMEOUT_MS);
    dumpSetting(s, p, Settings.Global.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS, GlobalSettingsProto.DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS);
    dumpSetting(s, p, Settings.Global.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS, GlobalSettingsProto.DATA_STALL_ALARM_AGGRESSIVE_DELAY_IN_MS);
    dumpSetting(s, p, Settings.Global.PROVISIONING_APN_ALARM_DELAY_IN_MS, GlobalSettingsProto.PROVISIONING_APN_ALARM_DELAY_IN_MS);
    dumpSetting(s, p, Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, GlobalSettingsProto.GPRS_REGISTER_CHECK_PERIOD_MS);
    dumpSetting(s, p, Settings.Global.WTF_IS_FATAL, GlobalSettingsProto.WTF_IS_FATAL);
    dumpSetting(s, p, Settings.Global.MODE_RINGER, GlobalSettingsProto.MODE_RINGER);
    dumpSetting(s, p, Settings.Global.OVERLAY_DISPLAY_DEVICES, GlobalSettingsProto.OVERLAY_DISPLAY_DEVICES);
    dumpSetting(s, p, Settings.Global.BATTERY_DISCHARGE_DURATION_THRESHOLD, GlobalSettingsProto.BATTERY_DISCHARGE_DURATION_THRESHOLD);
    dumpSetting(s, p, Settings.Global.BATTERY_DISCHARGE_THRESHOLD, GlobalSettingsProto.BATTERY_DISCHARGE_THRESHOLD);
    dumpSetting(s, p, Settings.Global.SEND_ACTION_APP_ERROR, GlobalSettingsProto.SEND_ACTION_APP_ERROR);
    dumpSetting(s, p, Settings.Global.DROPBOX_AGE_SECONDS, GlobalSettingsProto.DROPBOX_AGE_SECONDS);
    dumpSetting(s, p, Settings.Global.DROPBOX_MAX_FILES, GlobalSettingsProto.DROPBOX_MAX_FILES);
    dumpSetting(s, p, Settings.Global.DROPBOX_QUOTA_KB, GlobalSettingsProto.DROPBOX_QUOTA_KB);
    dumpSetting(s, p, Settings.Global.DROPBOX_QUOTA_PERCENT, GlobalSettingsProto.DROPBOX_QUOTA_PERCENT);
    dumpSetting(s, p, Settings.Global.DROPBOX_RESERVE_PERCENT, GlobalSettingsProto.DROPBOX_RESERVE_PERCENT);
    dumpSetting(s, p, Settings.Global.DROPBOX_TAG_PREFIX, GlobalSettingsProto.DROPBOX_TAG_PREFIX);
    dumpSetting(s, p, Settings.Global.ERROR_LOGCAT_PREFIX, GlobalSettingsProto.ERROR_LOGCAT_PREFIX);
    dumpSetting(s, p, Settings.Global.SYS_FREE_STORAGE_LOG_INTERVAL, GlobalSettingsProto.SYS_FREE_STORAGE_LOG_INTERVAL);
    dumpSetting(s, p, Settings.Global.DISK_FREE_CHANGE_REPORTING_THRESHOLD, GlobalSettingsProto.DISK_FREE_CHANGE_REPORTING_THRESHOLD);
    dumpSetting(s, p, Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE, GlobalSettingsProto.SYS_STORAGE_THRESHOLD_PERCENTAGE);
    dumpSetting(s, p, Settings.Global.SYS_STORAGE_THRESHOLD_MAX_BYTES, GlobalSettingsProto.SYS_STORAGE_THRESHOLD_MAX_BYTES);
    dumpSetting(s, p, Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES, GlobalSettingsProto.SYS_STORAGE_FULL_THRESHOLD_BYTES);
    dumpSetting(s, p, Settings.Global.SYNC_MAX_RETRY_DELAY_IN_SECONDS, GlobalSettingsProto.SYNC_MAX_RETRY_DELAY_IN_SECONDS);
    dumpSetting(s, p, Settings.Global.CONNECTIVITY_CHANGE_DELAY, GlobalSettingsProto.CONNECTIVITY_CHANGE_DELAY);
    dumpSetting(s, p, Settings.Global.CONNECTIVITY_SAMPLING_INTERVAL_IN_SECONDS, GlobalSettingsProto.CONNECTIVITY_SAMPLING_INTERVAL_IN_SECONDS);
    dumpSetting(s, p, Settings.Global.PAC_CHANGE_DELAY, GlobalSettingsProto.PAC_CHANGE_DELAY);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_MODE, GlobalSettingsProto.CAPTIVE_PORTAL_MODE);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_SERVER, GlobalSettingsProto.CAPTIVE_PORTAL_SERVER);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_HTTPS_URL, GlobalSettingsProto.CAPTIVE_PORTAL_HTTPS_URL);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_HTTP_URL, GlobalSettingsProto.CAPTIVE_PORTAL_HTTP_URL);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_FALLBACK_URL, GlobalSettingsProto.CAPTIVE_PORTAL_FALLBACK_URL);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_USE_HTTPS, GlobalSettingsProto.CAPTIVE_PORTAL_USE_HTTPS);
    dumpSetting(s, p, Settings.Global.CAPTIVE_PORTAL_USER_AGENT, GlobalSettingsProto.CAPTIVE_PORTAL_USER_AGENT);
    dumpSetting(s, p, Settings.Global.NSD_ON, GlobalSettingsProto.NSD_ON);
    dumpSetting(s, p, Settings.Global.SET_INSTALL_LOCATION, GlobalSettingsProto.SET_INSTALL_LOCATION);
    dumpSetting(s, p, Settings.Global.DEFAULT_INSTALL_LOCATION, GlobalSettingsProto.DEFAULT_INSTALL_LOCATION);
    dumpSetting(s, p, Settings.Global.INET_CONDITION_DEBOUNCE_UP_DELAY, GlobalSettingsProto.INET_CONDITION_DEBOUNCE_UP_DELAY);
    dumpSetting(s, p, Settings.Global.INET_CONDITION_DEBOUNCE_DOWN_DELAY, GlobalSettingsProto.INET_CONDITION_DEBOUNCE_DOWN_DELAY);
    dumpSetting(s, p, Settings.Global.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT, GlobalSettingsProto.READ_EXTERNAL_STORAGE_ENFORCED_DEFAULT);
    dumpSetting(s, p, Settings.Global.HTTP_PROXY, GlobalSettingsProto.HTTP_PROXY);
    dumpSetting(s, p, Settings.Global.GLOBAL_HTTP_PROXY_HOST, GlobalSettingsProto.GLOBAL_HTTP_PROXY_HOST);
    dumpSetting(s, p, Settings.Global.GLOBAL_HTTP_PROXY_PORT, GlobalSettingsProto.GLOBAL_HTTP_PROXY_PORT);
    dumpSetting(s, p, Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST, GlobalSettingsProto.GLOBAL_HTTP_PROXY_EXCLUSION_LIST);
    dumpSetting(s, p, Settings.Global.GLOBAL_HTTP_PROXY_PAC, GlobalSettingsProto.GLOBAL_HTTP_PROXY_PAC);
    dumpSetting(s, p, Settings.Global.SET_GLOBAL_HTTP_PROXY, GlobalSettingsProto.SET_GLOBAL_HTTP_PROXY);
    dumpSetting(s, p, Settings.Global.DEFAULT_DNS_SERVER, GlobalSettingsProto.DEFAULT_DNS_SERVER);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_HEADSET_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_HEADSET_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_A2DP_SRC_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_A2DP_SRC_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_A2DP_SUPPORTS_OPTIONAL_CODECS_PREFIX, GlobalSettingsProto.BLUETOOTH_A2DP_SUPPORTS_OPTIONAL_CODECS_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_A2DP_OPTIONAL_CODECS_ENABLED_PREFIX, GlobalSettingsProto.BLUETOOTH_A2DP_OPTIONAL_CODECS_ENABLED_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_MAP_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_MAP_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_MAP_CLIENT_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_MAP_CLIENT_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_PBAP_CLIENT_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_PBAP_CLIENT_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_SAP_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_SAP_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_PAN_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_PAN_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.BLUETOOTH_HEARING_AID_PRIORITY_PREFIX, GlobalSettingsProto.BLUETOOTH_HEARING_AID_PRIORITY_PREFIX);
    dumpSetting(s, p, Settings.Global.DEVICE_IDLE_CONSTANTS, GlobalSettingsProto.DEVICE_IDLE_CONSTANTS);
    dumpSetting(s, p, Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH, GlobalSettingsProto.DEVICE_IDLE_CONSTANTS_WATCH);
    dumpSetting(s, p, Settings.Global.APP_IDLE_CONSTANTS, GlobalSettingsProto.APP_IDLE_CONSTANTS);
    dumpSetting(s, p, Settings.Global.ALARM_MANAGER_CONSTANTS, GlobalSettingsProto.ALARM_MANAGER_CONSTANTS);
    dumpSetting(s, p, Settings.Global.JOB_SCHEDULER_CONSTANTS, GlobalSettingsProto.JOB_SCHEDULER_CONSTANTS);
    dumpSetting(s, p, Settings.Global.SHORTCUT_MANAGER_CONSTANTS, GlobalSettingsProto.SHORTCUT_MANAGER_CONSTANTS);
    dumpSetting(s, p, Settings.Global.WINDOW_ANIMATION_SCALE, GlobalSettingsProto.WINDOW_ANIMATION_SCALE);
    dumpSetting(s, p, Settings.Global.TRANSITION_ANIMATION_SCALE, GlobalSettingsProto.TRANSITION_ANIMATION_SCALE);
    dumpSetting(s, p, Settings.Global.ANIMATOR_DURATION_SCALE, GlobalSettingsProto.ANIMATOR_DURATION_SCALE);
    dumpSetting(s, p, Settings.Global.FANCY_IME_ANIMATIONS, GlobalSettingsProto.FANCY_IME_ANIMATIONS);
    dumpSetting(s, p, Settings.Global.COMPATIBILITY_MODE, GlobalSettingsProto.COMPATIBILITY_MODE);
    dumpSetting(s, p, Settings.Global.EMERGENCY_TONE, GlobalSettingsProto.EMERGENCY_TONE);
    dumpSetting(s, p, Settings.Global.CALL_AUTO_RETRY, GlobalSettingsProto.CALL_AUTO_RETRY);
    dumpSetting(s, p, Settings.Global.EMERGENCY_AFFORDANCE_NEEDED, GlobalSettingsProto.EMERGENCY_AFFORDANCE_NEEDED);
    dumpSetting(s, p, Settings.Global.PREFERRED_NETWORK_MODE, GlobalSettingsProto.PREFERRED_NETWORK_MODE);
    dumpSetting(s, p, Settings.Global.DEBUG_APP, GlobalSettingsProto.DEBUG_APP);
    dumpSetting(s, p, Settings.Global.WAIT_FOR_DEBUGGER, GlobalSettingsProto.WAIT_FOR_DEBUGGER);
    dumpSetting(s, p, Settings.Global.LOW_POWER_MODE, GlobalSettingsProto.LOW_POWER_MODE);
    dumpSetting(s, p, Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL, GlobalSettingsProto.LOW_POWER_MODE_TRIGGER_LEVEL);
    dumpSetting(s, p, Settings.Global.ALWAYS_FINISH_ACTIVITIES, GlobalSettingsProto.ALWAYS_FINISH_ACTIVITIES);
    dumpSetting(s, p, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED, GlobalSettingsProto.DOCK_AUDIO_MEDIA_ENABLED);
    dumpSetting(s, p, Settings.Global.ENCODED_SURROUND_OUTPUT, GlobalSettingsProto.ENCODED_SURROUND_OUTPUT);
    dumpSetting(s, p, Settings.Global.AUDIO_SAFE_VOLUME_STATE, GlobalSettingsProto.AUDIO_SAFE_VOLUME_STATE);
    dumpSetting(s, p, Settings.Global.TZINFO_UPDATE_CONTENT_URL, GlobalSettingsProto.TZINFO_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.TZINFO_UPDATE_METADATA_URL, GlobalSettingsProto.TZINFO_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.SELINUX_UPDATE_CONTENT_URL, GlobalSettingsProto.SELINUX_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.SELINUX_UPDATE_METADATA_URL, GlobalSettingsProto.SELINUX_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.SMS_SHORT_CODES_UPDATE_CONTENT_URL, GlobalSettingsProto.SMS_SHORT_CODES_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.SMS_SHORT_CODES_UPDATE_METADATA_URL, GlobalSettingsProto.SMS_SHORT_CODES_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.APN_DB_UPDATE_CONTENT_URL, GlobalSettingsProto.APN_DB_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.APN_DB_UPDATE_METADATA_URL, GlobalSettingsProto.APN_DB_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.CERT_PIN_UPDATE_CONTENT_URL, GlobalSettingsProto.CERT_PIN_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.CERT_PIN_UPDATE_METADATA_URL, GlobalSettingsProto.CERT_PIN_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.INTENT_FIREWALL_UPDATE_CONTENT_URL, GlobalSettingsProto.INTENT_FIREWALL_UPDATE_CONTENT_URL);
    dumpSetting(s, p, Settings.Global.INTENT_FIREWALL_UPDATE_METADATA_URL, GlobalSettingsProto.INTENT_FIREWALL_UPDATE_METADATA_URL);
    dumpSetting(s, p, Settings.Global.SELINUX_STATUS, GlobalSettingsProto.SELINUX_STATUS);
    dumpSetting(s, p, Settings.Global.DEVELOPMENT_FORCE_RTL, GlobalSettingsProto.DEVELOPMENT_FORCE_RTL);
    dumpSetting(s, p, Settings.Global.LOW_BATTERY_SOUND_TIMEOUT, GlobalSettingsProto.LOW_BATTERY_SOUND_TIMEOUT);
    dumpSetting(s, p, Settings.Global.WIFI_BOUNCE_DELAY_OVERRIDE_MS, GlobalSettingsProto.WIFI_BOUNCE_DELAY_OVERRIDE_MS);
    dumpSetting(s, p, Settings.Global.POLICY_CONTROL, GlobalSettingsProto.POLICY_CONTROL);
    dumpSetting(s, p, Settings.Global.ZEN_MODE, GlobalSettingsProto.ZEN_MODE);
    dumpSetting(s, p, Settings.Global.ZEN_MODE_RINGER_LEVEL, GlobalSettingsProto.ZEN_MODE_RINGER_LEVEL);
    dumpSetting(s, p, Settings.Global.ZEN_MODE_CONFIG_ETAG, GlobalSettingsProto.ZEN_MODE_CONFIG_ETAG);
    dumpSetting(s, p, Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED, GlobalSettingsProto.HEADS_UP_NOTIFICATIONS_ENABLED);
    dumpSetting(s, p, Settings.Global.DEVICE_NAME, GlobalSettingsProto.DEVICE_NAME);
    dumpSetting(s, p, Settings.Global.NETWORK_SCORING_PROVISIONED, GlobalSettingsProto.NETWORK_SCORING_PROVISIONED);
    dumpSetting(s, p, Settings.Global.REQUIRE_PASSWORD_TO_DECRYPT, GlobalSettingsProto.REQUIRE_PASSWORD_TO_DECRYPT);
    dumpSetting(s, p, Settings.Global.ENHANCED_4G_MODE_ENABLED, GlobalSettingsProto.ENHANCED_4G_MODE_ENABLED);
    dumpSetting(s, p, Settings.Global.VT_IMS_ENABLED, GlobalSettingsProto.VT_IMS_ENABLED);
    dumpSetting(s, p, Settings.Global.WFC_IMS_ENABLED, GlobalSettingsProto.WFC_IMS_ENABLED);
    dumpSetting(s, p, Settings.Global.WFC_IMS_MODE, GlobalSettingsProto.WFC_IMS_MODE);
    dumpSetting(s, p, Settings.Global.WFC_IMS_ROAMING_MODE, GlobalSettingsProto.WFC_IMS_ROAMING_MODE);
    dumpSetting(s, p, Settings.Global.WFC_IMS_ROAMING_ENABLED, GlobalSettingsProto.WFC_IMS_ROAMING_ENABLED);
    dumpSetting(s, p, Settings.Global.LTE_SERVICE_FORCED, GlobalSettingsProto.LTE_SERVICE_FORCED);
    dumpSetting(s, p, Settings.Global.EPHEMERAL_COOKIE_MAX_SIZE_BYTES, GlobalSettingsProto.EPHEMERAL_COOKIE_MAX_SIZE_BYTES);
    dumpSetting(s, p, Settings.Global.ENABLE_EPHEMERAL_FEATURE, GlobalSettingsProto.ENABLE_EPHEMERAL_FEATURE);
    dumpSetting(s, p, Settings.Global.UNINSTALLED_INSTANT_APP_MIN_CACHE_PERIOD, GlobalSettingsProto.UNINSTALLED_INSTANT_APP_MIN_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.UNINSTALLED_INSTANT_APP_MAX_CACHE_PERIOD, GlobalSettingsProto.UNINSTALLED_INSTANT_APP_MAX_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD, GlobalSettingsProto.INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.INSTALLED_INSTANT_APP_MAX_CACHE_PERIOD, GlobalSettingsProto.INSTALLED_INSTANT_APP_MAX_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD, GlobalSettingsProto.UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD);
    dumpSetting(s, p, Settings.Global.ALLOW_USER_SWITCHING_WHEN_SYSTEM_USER_LOCKED, GlobalSettingsProto.ALLOW_USER_SWITCHING_WHEN_SYSTEM_USER_LOCKED);
    dumpSetting(s, p, Settings.Global.BOOT_COUNT, GlobalSettingsProto.BOOT_COUNT);
    dumpSetting(s, p, Settings.Global.SAFE_BOOT_DISALLOWED, GlobalSettingsProto.SAFE_BOOT_DISALLOWED);
    dumpSetting(s, p, Settings.Global.DEVICE_DEMO_MODE, GlobalSettingsProto.DEVICE_DEMO_MODE);
    dumpSetting(s, p, Settings.Global.DATABASE_DOWNGRADE_REASON, GlobalSettingsProto.DATABASE_DOWNGRADE_REASON);
    dumpSetting(s, p, Settings.Global.CONTACTS_DATABASE_WAL_ENABLED, GlobalSettingsProto.CONTACTS_DATABASE_WAL_ENABLED);
    dumpSetting(s, p, Settings.Global.HIDDEN_API_BLACKLIST_EXEMPTIONS, GlobalSettingsProto.HIDDEN_API_BLACKLIST_EXEMPTIONS);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_VOICE_CALL_SUBSCRIPTION, GlobalSettingsProto.MULTI_SIM_VOICE_CALL_SUBSCRIPTION);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_VOICE_PROMPT, GlobalSettingsProto.MULTI_SIM_VOICE_PROMPT);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_DATA_CALL_SUBSCRIPTION, GlobalSettingsProto.MULTI_SIM_DATA_CALL_SUBSCRIPTION);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_SMS_SUBSCRIPTION, GlobalSettingsProto.MULTI_SIM_SMS_SUBSCRIPTION);
    dumpSetting(s, p, Settings.Global.MULTI_SIM_SMS_PROMPT, GlobalSettingsProto.MULTI_SIM_SMS_PROMPT);
    dumpSetting(s, p, Settings.Global.NEW_CONTACT_AGGREGATOR, GlobalSettingsProto.NEW_CONTACT_AGGREGATOR);
    dumpSetting(s, p, Settings.Global.CONTACT_METADATA_SYNC_ENABLED, GlobalSettingsProto.CONTACT_METADATA_SYNC_ENABLED);
    dumpSetting(s, p, Settings.Global.ENABLE_CELLULAR_ON_BOOT, GlobalSettingsProto.ENABLE_CELLULAR_ON_BOOT);
    dumpSetting(s, p, Settings.Global.MAX_NOTIFICATION_ENQUEUE_RATE, GlobalSettingsProto.MAX_NOTIFICATION_ENQUEUE_RATE);
    dumpSetting(s, p, Settings.Global.CELL_ON, GlobalSettingsProto.CELL_ON);
}
#end_block

#method_before
@ServiceThreadOnly
void startQueuedActions() {
    assertRunOnServiceThread();
    for (HdmiCecFeatureAction action : new ArrayList<>(mActions)) {
        if (!action.started()) {
            Slog.i(TAG, "Starting queued action:" + action);
            action.start();
        }
    }
}
#method_after
@ServiceThreadOnly
void startQueuedActions() {
    assertRunOnServiceThread();
    // Use copied action list in that start() may remove itself.
    for (HdmiCecFeatureAction action : new ArrayList<>(mActions)) {
        if (!action.started()) {
            Slog.i(TAG, "Starting queued action:" + action);
            action.start();
        }
    }
}
#end_block

#method_before
private boolean isSupportedApplication(UiccCardApplication app) {
    if (app.getType() != AppType.APPTYPE_USIM && app.getType() != AppType.APPTYPE_CSIM && app.getType() != AppType.APPTYPE_SIM && app.getType() != AppType.APPTYPE_RUIM) {
        return false;
    }
    return true;
}
#method_after
private boolean isSupportedApplication(UiccCardApplication app) {
    // ISIM also (currently ISIM is considered as not supported in this function)
    if (app.getType() != AppType.APPTYPE_USIM && app.getType() != AppType.APPTYPE_CSIM && app.getType() != AppType.APPTYPE_SIM && app.getType() != AppType.APPTYPE_RUIM) {
        return false;
    }
    return true;
}
#end_block

#method_before
public void addNetworkRegistrationState(NetworkRegistrationState regStates) {
    if (regStates == null)
        return;
    synchronized (mNetworkRegistrationStates) {
        for (int i = 0; i < mNetworkRegistrationStates.size(); i++) {
            NetworkRegistrationState curRegStates = mNetworkRegistrationStates.get(i);
            if (curRegStates.getTransportType() == regStates.getTransportType() && curRegStates.getDomain() == regStates.getDomain()) {
                mNetworkRegistrationStates.remove(i);
                break;
            }
        }
        mNetworkRegistrationStates.add(regStates);
    }
}
#method_after
public void addNetworkRegistrationState(NetworkRegistrationState regState) {
    if (regState == null)
        return;
    synchronized (mNetworkRegistrationStates) {
        for (int i = 0; i < mNetworkRegistrationStates.size(); i++) {
            NetworkRegistrationState curRegState = mNetworkRegistrationStates.get(i);
            if (curRegState.getTransportType() == regState.getTransportType() && curRegState.getDomain() == regState.getDomain()) {
                mNetworkRegistrationStates.remove(i);
                break;
            }
        }
        mNetworkRegistrationStates.add(regState);
    }
}
#end_block

#method_before
final void performStart() {
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException("Activity " + mComponent.toShortString() + " did not call through to super.onStart()");
    }
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
    boolean isAppDebuggable = (mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    // This property is set for all non-user builds except final release
    boolean isDlwarningEnabled = SystemProperties.getInt("ro.bionic.ld.warning", 0) == 1;
    if (isAppDebuggable || isDlwarningEnabled) {
        String dlwarning = getDlWarning();
        if (dlwarning != null) {
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = "Detected problems with app native libraries\n" + "(please consult log for detail):\n" + dlwarning;
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + "\n" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    // This property is set for all non-user builds except final release
    boolean isApiWarningEnabled = SystemProperties.getInt("ro.art.hiddenapi.warning", 0) == 1;
    if (isAppDebuggable || isApiWarningEnabled) {
        if (!mMainThread.mHiddenApiWarningShown && VMRuntime.getRuntime().hasUsedHiddenApi()) {
            // Only show the warning once per process.
            mMainThread.mHiddenApiWarningShown = true;
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = "Detected problems with API compatibility\n" + "(go to g.co/dev/appcompat for more info)";
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + "\n" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    mActivityTransitionState.enterReady(this);
}
#method_after
final void performStart() {
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException("Activity " + mComponent.toShortString() + " did not call through to super.onStart()");
    }
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
    boolean isAppDebuggable = (mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    // This property is set for all non-user builds except final release
    boolean isDlwarningEnabled = SystemProperties.getInt("ro.bionic.ld.warning", 0) == 1;
    if (isAppDebuggable || isDlwarningEnabled) {
        String dlwarning = getDlWarning();
        if (dlwarning != null) {
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = "Detected problems with app native libraries\n" + "(please consult log for detail):\n" + dlwarning;
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + "\n" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    // This property is set for all non-user builds except final release
    boolean isApiWarningEnabled = SystemProperties.getInt("ro.art.hiddenapi.warning", 0) == 1;
    if (isAppDebuggable || isApiWarningEnabled) {
        if (!mMainThread.mHiddenApiWarningShown && VMRuntime.getRuntime().hasUsedHiddenApi()) {
            // Only show the warning once per process.
            mMainThread.mHiddenApiWarningShown = true;
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = "Detected problems with API compatibility\n" + "(visit g.co/dev/appcompat for more info)";
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + "\n" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    mActivityTransitionState.enterReady(this);
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "IsInstanceOfClass" })
public Object[] toArray() {
    Object[] source = s.toArray();
    /*
                 * Ensure that we don't get an ArrayStoreException even if
                 * s.toArray returns an array of something other than Object
                 */
    Object[] dest = (CheckedEntry.class.isInstance(source.getClass().getComponentType()) ? source : new Object[source.length]);
    for (int i = 0; i < source.length; i++) dest[i] = checkedEntry((Map.Entry<K, V>) source[i], valueType);
    return dest;
}
#method_after
// Android-changed: Ignore IsInstanceOfClass warning. b/73288967, b/73344263.
@SuppressWarnings({ "unchecked", "IsInstanceOfClass" })
public Object[] toArray() {
    Object[] source = s.toArray();
    /*
                 * Ensure that we don't get an ArrayStoreException even if
                 * s.toArray returns an array of something other than Object
                 */
    Object[] dest = (CheckedEntry.class.isInstance(source.getClass().getComponentType()) ? source : new Object[source.length]);
    for (int i = 0; i < source.length; i++) dest[i] = checkedEntry((Map.Entry<K, V>) source[i], valueType);
    return dest;
}
#end_block

#method_before
@Override
public void run() {
    logWriter.println("--> Debuggee: EnableCollectionDebuggee: START");
    checkedObject = new EnableCollectionObject001_01();
    patternObject = new EnableCollectionObject001_02();
    marker = new GcMarker();
    marker.add(checkedObject);
    marker.add(patternObject);
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    String messageFromTest = synchronizer.receiveMessage();
    if (messageFromTest.equals("TO_FINISH")) {
        logWriter.println("--> Debuggee: EnableCollectionDebuggee: FINISH");
        return;
    }
    int numberOfExpectedFinalizations = 2;
    logWriter.println("--> Debuggee: BEFORE System.gc():");
    logWriter.println("--> Debuggee: checkedObject = " + checkedObject);
    logWriter.println("--> Debuggee: checkedObject_UNLOADed = " + checkedObject_Finalized);
    logWriter.println("--> Debuggee: patternObject = " + patternObject);
    logWriter.println("--> Debuggee: patternObject_UNLOADed = " + patternObject_Finalized);
    checkedObject = null;
    patternObject = null;
    long[][] longArray;
    int i = 0;
    try {
        longArray = new long[1000000][];
        // max - longArray.length
        int arraysNumberLimit = 7;
        logWriter.println("--> Debuggee: memory depletion - creating 'long[1000000]' arrays (" + arraysNumberLimit + ")...");
        for (; i < arraysNumberLimit; i++) {
            longArray[i] = new long[1000000];
        }
    } catch (OutOfMemoryError outOfMem) {
        logWriter.println("--> Debuggee: OutOfMemoryError!!!");
    }
    longArray = null;
    marker.waitForGc(numberOfExpectedFinalizations);
    logWriter.println("--> Debuggee: AFTER System.gc():");
    logWriter.println("--> Debuggee: checkedObject = " + checkedObject);
    logWriter.println("--> Debuggee: checkedObject_UNLOADed = " + checkedObject_Finalized);
    logWriter.println("--> Debuggee: patternObject = " + patternObject);
    logWriter.println("--> Debuggee: patternObject_UNLOADed = " + patternObject_Finalized);
    String messageForTest = null;
    if (checkedObject_Finalized) {
        if (patternObject_Finalized) {
            messageForTest = "Checked Object is UNLOADed; Pattern Object is UNLOADed;";
        } else {
            messageForTest = "Checked Object is UNLOADed; Pattern Object is NOT UNLOADed;";
        }
    } else {
        if (patternObject_Finalized) {
            messageForTest = "Checked Object is NOT UNLOADed; Pattern Object is UNLOADed;";
        } else {
            messageForTest = "Checked Object is NOT UNLOADed; Pattern Object is NOT UNLOADed;";
        }
    }
    logWriter.println("--> Debuggee: Send to test message: \"" + messageForTest + "\"");
    synchronizer.sendMessage(messageForTest);
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("--> Debuggee: EnableCollectionDebuggee: FINISH");
}
#method_after
@Override
public void run() {
    logWriter.println("--> Debuggee: EnableCollectionDebuggee: START");
    checkedObject = new EnableCollectionObject001_01();
    patternObject = new EnableCollectionObject001_02();
    marker = new GcMarker();
    marker.add(checkedObject);
    marker.add(patternObject);
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    String messageFromTest = synchronizer.receiveMessage();
    if (messageFromTest.equals("TO_FINISH")) {
        logWriter.println("--> Debuggee: EnableCollectionDebuggee: FINISH");
        return;
    }
    int numberOfExpectedFinalizations = 2;
    if (!messageFromTest.equals(JPDADebuggeeSynchronizer.SGNL_CONTINUE)) {
        logWriter.println("--> Unexpected message: \"" + messageFromTest + "\"");
        return;
    }
    logWriter.println("--> Debuggee: BEFORE System.gc():");
    logWriter.println("--> Debuggee: checkedObject = " + checkedObject);
    logWriter.println("--> Debuggee: checkedObject_UNLOADed = " + checkedObject_Finalized);
    logWriter.println("--> Debuggee: patternObject = " + patternObject);
    logWriter.println("--> Debuggee: patternObject_UNLOADed = " + patternObject_Finalized);
    checkedObject = null;
    patternObject = null;
    long[][] longArray;
    int i = 0;
    try {
        longArray = new long[1000000][];
        // max - longArray.length
        int arraysNumberLimit = 7;
        logWriter.println("--> Debuggee: memory depletion - creating 'long[1000000]' arrays (" + arraysNumberLimit + ")...");
        for (; i < arraysNumberLimit; i++) {
            longArray[i] = new long[1000000];
        }
    } catch (OutOfMemoryError outOfMem) {
        logWriter.println("--> Debuggee: OutOfMemoryError!!!");
    }
    longArray = null;
    marker.waitForGc(numberOfExpectedFinalizations);
    logWriter.println("--> Debuggee: AFTER System.gc():");
    logWriter.println("--> Debuggee: checkedObject = " + checkedObject);
    logWriter.println("--> Debuggee: checkedObject_UNLOADed = " + checkedObject_Finalized);
    logWriter.println("--> Debuggee: patternObject = " + patternObject);
    logWriter.println("--> Debuggee: patternObject_UNLOADed = " + patternObject_Finalized);
    String messageForTest = null;
    if (checkedObject_Finalized) {
        if (patternObject_Finalized) {
            messageForTest = "Checked Object is UNLOADed; Pattern Object is UNLOADed;";
        } else {
            messageForTest = "Checked Object is UNLOADed; Pattern Object is NOT UNLOADed;";
        }
    } else {
        if (patternObject_Finalized) {
            messageForTest = "Checked Object is NOT UNLOADed; Pattern Object is UNLOADed;";
        } else {
            messageForTest = "Checked Object is NOT UNLOADed; Pattern Object is NOT UNLOADed;";
        }
    }
    logWriter.println("--> Debuggee: Send to test message: \"" + messageForTest + "\"");
    synchronizer.sendMessage(messageForTest);
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("--> Debuggee: EnableCollectionDebuggee: FINISH");
}
#end_block

#method_before
@Override
public void run() {
    logWriter.println("--> Debuggee: EnableCollectionDebuggee: START");
    // Allocates test objects to be sure there is no local reference
    // to them.
    allocateTestObjects();
    marker = new GcMarker();
    marker.add(checkedObject);
    marker.add(patternObject);
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    String messageFromTest = synchronizer.receiveMessage();
    if (messageFromTest.equals("TO_FINISH")) {
        logWriter.println("--> Debuggee: EnableCollectionDebuggee: FINISH");
        return;
    }
    int numberOfExpectedFinalizations = 2;
    if (messageFromTest.equals(JPDADebuggeeSynchronizer.SGNL_CONTINUE + "1")) {
        numberOfExpectedFinalizations = 1;
    }
    // Releases test objects so there is no more reference to them. We do it in a
    // separate method to avoid having any local reference to them.
    releaseTestObjects();
    // Allocates many objects to increase the heap.
    causeMemoryDepletion();
    marker.waitForGc(numberOfExpectedFinalizations);
    logWriter.println("--> Debuggee: AFTER System.gc():");
    logWriter.println("--> Debuggee: checkedObject = " + checkedObject);
    logWriter.println("--> Debuggee: checkedObject_UNLOADed = " + checkedObject_Finalized);
    logWriter.println("--> Debuggee: patternObject = " + patternObject);
    logWriter.println("--> Debuggee: patternObject_UNLOADed = " + patternObject_Finalized);
    String messageForTest = buildMessage();
    logWriter.println("--> Debuggee: Send to test message: \"" + messageForTest + "\"");
    synchronizer.sendMessage(messageForTest);
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("--> Debuggee: EnableCollectionDebuggee: FINISH");
}
#method_after
@Override
public void run() {
    logWriter.println("--> Debuggee: EnableCollectionDebuggee: START");
    // Allocates test objects to be sure there is no local reference
    // to them.
    allocateTestObjects();
    marker = new GcMarker();
    marker.add(checkedObject);
    marker.add(patternObject);
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    String messageFromTest = synchronizer.receiveMessage();
    if (messageFromTest.equals("TO_FINISH")) {
        logWriter.println("--> Debuggee: EnableCollectionDebuggee: FINISH");
        return;
    }
    int numberOfExpectedFinalizations = 2;
    if (messageFromTest.equals(JPDADebuggeeSynchronizer.SGNL_CONTINUE + "1")) {
        numberOfExpectedFinalizations = 1;
    } else if (!messageFromTest.equals(JPDADebuggeeSynchronizer.SGNL_CONTINUE)) {
        logWriter.println("--> Unexpected message: \"" + messageFromTest + "\"");
        return;
    }
    // Releases test objects so there is no more reference to them. We do it in a
    // separate method to avoid having any local reference to them.
    releaseTestObjects();
    // Allocates many objects to increase the heap.
    causeMemoryDepletion();
    marker.waitForGc(numberOfExpectedFinalizations);
    logWriter.println("--> Debuggee: AFTER System.gc():");
    logWriter.println("--> Debuggee: checkedObject = " + checkedObject);
    logWriter.println("--> Debuggee: checkedObject_UNLOADed = " + checkedObject_Finalized);
    logWriter.println("--> Debuggee: patternObject = " + patternObject);
    logWriter.println("--> Debuggee: patternObject_UNLOADed = " + patternObject_Finalized);
    String messageForTest = buildMessage();
    logWriter.println("--> Debuggee: Send to test message: \"" + messageForTest + "\"");
    synchronizer.sendMessage(messageForTest);
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("--> Debuggee: EnableCollectionDebuggee: FINISH");
}
#end_block

#method_before
public void waitForGc(int numberOfExpectedFinalizations) {
    if (numberOfExpectedFinalizations > mList.size()) {
        throw new IllegalArgumentException("wait condition will never be met");
    }
    // Repeat until all weak references on our list have been enqueued.
    do {
        System.runFinalization();
        Runtime.getRuntime().gc();
        try {
            Thread.sleep(10);
        } catch (Exception e) {
        }
    } while (isLive(numberOfExpectedFinalizations));
    // to break the objects' "phantom reachability".
    try {
        while (mQueue.poll() != null) ;
    } catch (Exception e) {
    }
    mList.clear();
}
#method_after
public void waitForGc(int numberOfExpectedFinalizations) {
    if (numberOfExpectedFinalizations > mList.size()) {
        throw new IllegalArgumentException("wait condition will never be met");
    }
    // Repeat until reference queue reaches expected size.
    do {
        System.runFinalization();
        Runtime.getRuntime().gc();
        try {
            Thread.sleep(10);
        } catch (Exception e) {
        }
    } while (isLive(numberOfExpectedFinalizations));
}
#end_block

#method_before
@Override
public void run() {
    logWriter.println("--> Debuggee: IsCollectedDebuggee: START");
    checkedObject_01 = new IsCollectedObject001_01();
    checkedObject_02 = new IsCollectedObject001_02();
    checkedObject_03 = new IsCollectedObject001_03();
    marker = new GcMarker();
    marker.add(checkedObject_01);
    marker.add(checkedObject_02);
    marker.add(checkedObject_03);
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    String messageFromTest = synchronizer.receiveMessage();
    if (messageFromTest.equals("TO_FINISH")) {
        logWriter.println("--> Debuggee: IsCollectedDebuggee: FINISH");
        return;
    }
    int numberOfExpectedFinalizations = 3;
    if (messageFromTest.equals(JPDADebuggeeSynchronizer.SGNL_CONTINUE + "2")) {
        numberOfExpectedFinalizations = 2;
    }
    checkedObject_01 = null;
    checkedObject_02 = null;
    checkedObject_03 = null;
    long[][] longArray;
    int i = 0;
    try {
        longArray = new long[1000000][];
        // max - longArray.length
        int arraysNumberLimit = 7;
        logWriter.println("--> Debuggee: memory depletion - creating 'long[1000000]' arrays (" + arraysNumberLimit + ")...");
        for (; i < arraysNumberLimit; i++) {
            longArray[i] = new long[1000000];
        }
    } catch (OutOfMemoryError outOfMem) {
        logWriter.println("--> Debuggee: OutOfMemoryError!!!");
    // logWriter.println("--> Debuggee: i = " + i);
    }
    longArray = null;
    marker.waitForGc(numberOfExpectedFinalizations);
    logWriter.println("--> Debuggee: AFTER System.gc():");
    logWriter.println("--> Debuggee: checkedObject_01 = " + checkedObject_01);
    logWriter.println("--> Debuggee: checkedObject_01_UNLOADed = " + checkedObject_01_Finalized);
    logWriter.println("--> Debuggee: checkedObject_02 = " + checkedObject_02);
    logWriter.println("--> Debuggee: checkedObject_02_UNLOADed = " + checkedObject_02_Finalized);
    logWriter.println("--> Debuggee: checkedObject_03 = " + checkedObject_03);
    logWriter.println("--> Debuggee: checkedObject_03_UNLOADed = " + checkedObject_03_Finalized);
    String messageForTest = null;
    if (checkedObject_01_Finalized) {
        if (checkedObject_02_Finalized) {
            messageForTest = "checkedObject_01 is UNLOADed; checkedObject_02 is UNLOADed;";
        } else {
            messageForTest = "checkedObject_01 is UNLOADed; checkedObject_02 is NOT UNLOADed;";
        }
    } else {
        if (checkedObject_02_Finalized) {
            messageForTest = "checkedObject_01 is NOT UNLOADed; checkedObject_02 is UNLOADed;";
        } else {
            messageForTest = "checkedObject_01 is NOT UNLOADed; checkedObject_02 is NOT UNLOADed;";
        }
    }
    logWriter.println("--> Debuggee: Send to test message: \"" + messageForTest + "\"");
    synchronizer.sendMessage(messageForTest);
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("--> Debuggee: IsCollectedDebuggee: FINISH");
}
#method_after
@Override
public void run() {
    logWriter.println("--> Debuggee: IsCollectedDebuggee: START");
    checkedObject_01 = new IsCollectedObject001_01();
    checkedObject_02 = new IsCollectedObject001_02();
    checkedObject_03 = new IsCollectedObject001_03();
    marker = new GcMarker();
    marker.add(checkedObject_01);
    marker.add(checkedObject_02);
    marker.add(checkedObject_03);
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    String messageFromTest = synchronizer.receiveMessage();
    if (messageFromTest.equals("TO_FINISH")) {
        logWriter.println("--> Debuggee: IsCollectedDebuggee: FINISH");
        return;
    }
    int numberOfExpectedFinalizations = 3;
    if (messageFromTest.equals(JPDADebuggeeSynchronizer.SGNL_CONTINUE + "2")) {
        numberOfExpectedFinalizations = 2;
    } else if (!messageFromTest.equals(JPDADebuggeeSynchronizer.SGNL_CONTINUE)) {
        logWriter.println("--> Unexpected message: \"" + messageFromTest + "\"");
        return;
    }
    checkedObject_01 = null;
    checkedObject_02 = null;
    checkedObject_03 = null;
    long[][] longArray;
    int i = 0;
    try {
        longArray = new long[1000000][];
        // max - longArray.length
        int arraysNumberLimit = 7;
        logWriter.println("--> Debuggee: memory depletion - creating 'long[1000000]' arrays (" + arraysNumberLimit + ")...");
        for (; i < arraysNumberLimit; i++) {
            longArray[i] = new long[1000000];
        }
    } catch (OutOfMemoryError outOfMem) {
        logWriter.println("--> Debuggee: OutOfMemoryError!!!");
    // logWriter.println("--> Debuggee: i = " + i);
    }
    longArray = null;
    marker.waitForGc(numberOfExpectedFinalizations);
    logWriter.println("--> Debuggee: AFTER System.gc():");
    logWriter.println("--> Debuggee: checkedObject_01 = " + checkedObject_01);
    logWriter.println("--> Debuggee: checkedObject_01_UNLOADed = " + checkedObject_01_Finalized);
    logWriter.println("--> Debuggee: checkedObject_02 = " + checkedObject_02);
    logWriter.println("--> Debuggee: checkedObject_02_UNLOADed = " + checkedObject_02_Finalized);
    logWriter.println("--> Debuggee: checkedObject_03 = " + checkedObject_03);
    logWriter.println("--> Debuggee: checkedObject_03_UNLOADed = " + checkedObject_03_Finalized);
    String messageForTest = null;
    if (checkedObject_01_Finalized) {
        if (checkedObject_02_Finalized) {
            messageForTest = "checkedObject_01 is UNLOADed; checkedObject_02 is UNLOADed;";
        } else {
            messageForTest = "checkedObject_01 is UNLOADed; checkedObject_02 is NOT UNLOADed;";
        }
    } else {
        if (checkedObject_02_Finalized) {
            messageForTest = "checkedObject_01 is NOT UNLOADed; checkedObject_02 is UNLOADed;";
        } else {
            messageForTest = "checkedObject_01 is NOT UNLOADed; checkedObject_02 is NOT UNLOADed;";
        }
    }
    logWriter.println("--> Debuggee: Send to test message: \"" + messageForTest + "\"");
    synchronizer.sendMessage(messageForTest);
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("--> Debuggee: IsCollectedDebuggee: FINISH");
}
#end_block

#method_before
public void testNetworkBlocked() throws Exception {
    // After the vpn app being force-stop, expect that always-on package stays the same
    assertEquals(VPN_PACKAGE, mDevicePolicyManager.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    for (int i = 0; i < MAX_NUMBER_OF_ATTEMPT && VpnTestHelper.isNetworkVpn(mContext); ++i) {
        // sleep 1 second
        Thread.sleep(1000);
    }
    assertFalse(VpnTestHelper.isNetworkVpn(mContext));
    // Expect the network is still locked down after the vpn app process is killed
    try {
        VpnTestHelper.tryPosixConnect(TEST_ADDRESS);
        fail("sendIcmpMessage doesn't throw Exception during network lockdown");
    } catch (ErrnoException e) {
        // Os.connect returns ENETUNREACH or EACCES errno after the vpn app process is killed
        assertTrue((e.errno == OsConstants.ENETUNREACH) || (e.errno == OsConstants.EACCES));
    }
}
#method_after
public void testNetworkBlocked() throws Exception {
    // After the vpn app being force-stop, expect that always-on package stays the same
    assertEquals(VPN_PACKAGE, mDevicePolicyManager.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    for (int i = 0; i < MAX_NUMBER_OF_ATTEMPTS && VpnTestHelper.isNetworkVpn(mContext); ++i) {
        Thread.sleep(TimeUnit.SECONDS.toMillis(1));
    }
    assertFalse(VpnTestHelper.isNetworkVpn(mContext));
    // Expect the network is still locked down after the vpn app process is killed
    try {
        VpnTestHelper.tryPosixConnect(TEST_ADDRESS);
        fail("sendIcmpMessage doesn't throw Exception during network lockdown");
    } catch (ErrnoException e) {
        // Os.connect returns ENETUNREACH or EACCES errno after the vpn app process is killed
        assertTrue((e.errno == OsConstants.ENETUNREACH) || (e.errno == OsConstants.EACCES));
    }
}
#end_block

#method_before
public int getSimState() {
    int slotIndex = getSlotIndex();
    // sim state
    if (slotIndex < 0) {
        // return unknown
        for (int i = 0; i < getPhoneCount(); i++) {
            int simState = getSimState(i);
            if (simState != SIM_STATE_ABSENT) {
                Rlog.d(TAG, "getSimState: default sim:" + slotIndex + ", sim state for " + "slotIndex=" + i + " is " + simState + ", return state as unknown");
                return SIM_STATE_UNKNOWN;
            }
        }
        Rlog.d(TAG, "getSimState: default sim:" + slotIndex + ", all SIMs absent, return " + "state as absent");
        return SIM_STATE_ABSENT;
    }
    return getSimState(slotIndex);
}
#method_after
public int getSimState() {
    int simState = getSimStateIncludingLoaded();
    if (simState == SIM_STATE_LOADED) {
        simState = SIM_STATE_READY;
    }
    return simState;
}
#end_block

#method_before
public int getSimState(int slotIndex) {
    int simState = SubscriptionManager.getSimStateForSlotIndex(slotIndex);
    return simState;
}
#method_after
public int getSimState(int slotIndex) {
    int simState = SubscriptionManager.getSimStateForSlotIndex(slotIndex);
    if (simState == SIM_STATE_LOADED) {
        simState = SIM_STATE_READY;
    }
    return simState;
}
#end_block

#method_before
public String iccTransmitApduBasicChannel(int subId, int cla, int instruction, int p1, int p2, int p3, String data) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccTransmitApduBasicChannel(subId, cla, instruction, p1, p2, p3, data);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#method_after
public String iccTransmitApduBasicChannel(int subId, int cla, int instruction, int p1, int p2, int p3, String data) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccTransmitApduBasicChannel(subId, getOpPackageName(), cla, instruction, p1, p2, p3, data);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#end_block

#method_before
public static String getTelephonyProperty(int phoneId, String property, String defaultVal) {
    String propVal = null;
    String prop = SystemProperties.get(property);
    if ((prop != null) && (prop.length() > 0)) {
        String[] values = prop.split(",");
        if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
            propVal = values[phoneId];
        }
    }
    return propVal == null ? defaultVal : propVal;
}
#method_after
public static String getTelephonyProperty(String property, String defaultVal) {
    String propVal = SystemProperties.get(property);
    return propVal == null ? defaultVal : propVal;
}
#end_block

#method_before
public void setNetworkSelectionModeAutomatic(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setNetworkSelectionModeAutomatic(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic NPE", ex);
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setNetworkSelectionModeAutomatic() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            telephony.setNetworkSelectionModeAutomatic(getSubId());
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic NPE", ex);
    }
}
#end_block

#method_before
public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback) {
    synchronized (this) {
        if (mTelephonyScanManager == null) {
            mTelephonyScanManager = new TelephonyScanManager();
        }
    }
    return mTelephonyScanManager.requestNetworkScan(getSubId(), request, callback);
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback) {
    synchronized (this) {
        if (mTelephonyScanManager == null) {
            mTelephonyScanManager = new TelephonyScanManager();
        }
    }
    return mTelephonyScanManager.requestNetworkScan(getSubId(), request, callback);
}
#end_block

#method_before
public boolean setNetworkSelectionModeManual(int subId, OperatorInfo operator, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setNetworkSelectionModeManual(subId, operator, persistSelection);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setNetworkSelectionModeManual(getSubId(), operatorNumeric, persistSelection);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#end_block

#method_before
public boolean setPreferredNetworkType(int subId, int networkType) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setPreferredNetworkType(subId, networkType);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setPreferredNetworkType RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setPreferredNetworkType NPE", ex);
    }
    return false;
}
#method_after
public boolean setPreferredNetworkType(int subId, int networkType) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setPreferredNetworkType(subId, networkType);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setPreferredNetworkType RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setPreferredNetworkType NPE", ex);
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataEnabled(boolean enable) {
    setDataEnabled(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()), enable);
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataEnabled(boolean enable) {
    setUserMobileDataEnabled(enable);
}
#end_block

#method_before
@SystemApi
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataEnabled(int subId, boolean enable) {
    try {
        Log.d(TAG, "setDataEnabled: enabled=" + enable);
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setDataEnabled(subId, enable);
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#setDataEnabled", e);
    }
}
#method_after
@SystemApi
@Deprecated
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataEnabled(int subId, boolean enable) {
    setUserMobileDataEnabled(subId, enable);
}
#end_block

#method_before
@SystemApi
@Deprecated
public boolean getDataEnabled() {
    return isDataEnabled();
}
#method_after
@SystemApi
@Deprecated
public boolean getDataEnabled() {
    return isUserMobileDataEnabled();
}
#end_block

#method_before
@SuppressWarnings("deprecation")
public boolean isDataEnabled() {
    return getDataEnabled(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
}
#method_after
@Deprecated
public boolean isDataEnabled() {
    return isUserMobileDataEnabled();
}
#end_block

#method_before
@SystemApi
public boolean getDataEnabled(int subId) {
    boolean retVal = false;
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            retVal = telephony.getDataEnabled(subId);
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getDataEnabled", e);
    } catch (NullPointerException e) {
    }
    return retVal;
}
#method_after
@Deprecated
@SystemApi
public boolean getDataEnabled(int subId) {
    return isUserMobileDataEnabled(subId);
}
#end_block

#method_before
@Override
public void onSubscriptionsChanged() {
    if (DBG)
        log("SubscriptionListener.onSubscriptionInfoChanged");
    // Set the network type, in case the radio does not restore it.
    int subId = mPhone.getSubId();
    if (mPreviousSubId.getAndSet(subId) != subId) {
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            Context context = mPhone.getContext();
            mPhone.notifyPhoneStateChanged();
            mPhone.notifyCallForwardingIndicator();
            boolean restoreSelection = !context.getResources().getBoolean(com.android.internal.R.bool.skip_restoring_network_selection);
            mPhone.sendSubscriptionSettings(restoreSelection);
            mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(mSS.getRilDataRadioTechnology()));
            if (mSpnUpdatePending) {
                mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), mCurShowPlmn, mCurPlmn, mCurShowSpn, mCurSpn);
                mSpnUpdatePending = false;
            }
            // Remove old network selection sharedPreferences since SP key names are now
            // changed to include subId. This will be done only once when upgrading from an
            // older build that did not include subId in the names.
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
            String oldNetworkSelection = sp.getString(Phone.NETWORK_SELECTION_KEY, "");
            String oldNetworkSelectionName = sp.getString(Phone.NETWORK_SELECTION_NAME_KEY, "");
            String oldNetworkSelectionShort = sp.getString(Phone.NETWORK_SELECTION_SHORT_KEY, "");
            if (!TextUtils.isEmpty(oldNetworkSelection) || !TextUtils.isEmpty(oldNetworkSelectionName) || !TextUtils.isEmpty(oldNetworkSelectionShort)) {
                SharedPreferences.Editor editor = sp.edit();
                editor.putString(Phone.NETWORK_SELECTION_KEY + subId, oldNetworkSelection);
                editor.putString(Phone.NETWORK_SELECTION_NAME_KEY + subId, oldNetworkSelectionName);
                editor.putString(Phone.NETWORK_SELECTION_SHORT_KEY + subId, oldNetworkSelectionShort);
                editor.remove(Phone.NETWORK_SELECTION_KEY);
                editor.remove(Phone.NETWORK_SELECTION_NAME_KEY);
                editor.remove(Phone.NETWORK_SELECTION_SHORT_KEY);
                editor.commit();
            }
            // Once sub id becomes valid, we need to update the service provider name
            // displayed on the UI again. The old SPN update intents sent to
            // MobileSignalController earlier were actually ignored due to invalid sub id.
            updateSpnDisplay();
        }
        // update voicemail count and notify message waiting changed
        mPhone.updateVoiceMail();
    }
}
#method_after
@Override
public void onSubscriptionsChanged() {
    if (DBG)
        log("SubscriptionListener.onSubscriptionInfoChanged");
    // Set the network type, in case the radio does not restore it.
    int subId = mPhone.getSubId();
    if (mPreviousSubId.getAndSet(subId) != subId) {
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            Context context = mPhone.getContext();
            mPhone.notifyPhoneStateChanged();
            mPhone.notifyCallForwardingIndicator();
            boolean restoreSelection = !context.getResources().getBoolean(com.android.internal.R.bool.skip_restoring_network_selection);
            mPhone.sendSubscriptionSettings(restoreSelection);
            mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(mSS.getRilDataRadioTechnology()));
            if (mSpnUpdatePending) {
                mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), mCurShowPlmn, mCurPlmn, mCurShowSpn, mCurSpn);
                mSpnUpdatePending = false;
            }
            // Remove old network selection sharedPreferences since SP key names are now
            // changed to include subId. This will be done only once when upgrading from an
            // older build that did not include subId in the names.
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
            String oldNetworkSelection = sp.getString(Phone.NETWORK_SELECTION_KEY, "");
            String oldNetworkSelectionName = sp.getString(Phone.NETWORK_SELECTION_NAME_KEY, "");
            String oldNetworkSelectionShort = sp.getString(Phone.NETWORK_SELECTION_SHORT_KEY, "");
            if (!TextUtils.isEmpty(oldNetworkSelection) || !TextUtils.isEmpty(oldNetworkSelectionName) || !TextUtils.isEmpty(oldNetworkSelectionShort)) {
                SharedPreferences.Editor editor = sp.edit();
                editor.putString(Phone.NETWORK_SELECTION_KEY + subId, oldNetworkSelection);
                editor.putString(Phone.NETWORK_SELECTION_NAME_KEY + subId, oldNetworkSelectionName);
                editor.putString(Phone.NETWORK_SELECTION_SHORT_KEY + subId, oldNetworkSelectionShort);
                editor.remove(Phone.NETWORK_SELECTION_KEY);
                editor.remove(Phone.NETWORK_SELECTION_NAME_KEY);
                editor.remove(Phone.NETWORK_SELECTION_SHORT_KEY);
                editor.commit();
            }
            // Once sub id becomes valid, we need to update the service provider name
            // displayed on the UI again. The old SPN update intents sent to
            // MobileSignalController earlier were actually ignored due to invalid sub id.
            updateSpnDisplay();
        }
        // update voicemail count and notify message waiting changed
        mPhone.updateVoiceMail();
        // the SIM is first detected and then subsequently on SIM removals)
        if (mSubscriptionController.getSlotIndex(subId) == SubscriptionManager.SIM_NOT_INSERTED) {
            // this is handled on the main thread to mitigate racing with setNotification().
            sendMessage(obtainMessage(EVENT_SIM_NOT_INSERTED));
        }
    }
}
#end_block

#method_before
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mRestrictedState = new RestrictedState();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
        mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
        mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
    } else {
        // clear GSM regsitrations first
        mCi.unregisterForAvailable(this);
        mCi.unSetOnRestrictedStateChanged(this);
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#method_after
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzState.handleNetworkUnavailable();
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
    } else {
        mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#end_block

#method_before
protected boolean notifySignalStrength() {
    boolean notified = false;
    if (!mSignalStrength.equals(mLastSignalStrength)) {
        try {
            mPhone.notifySignalStrength();
            notified = true;
        } catch (NullPointerException ex) {
            loge("updateSignalStrength() Phone already destroyed: " + ex + "SignalStrength not notified");
        }
    }
    return notified;
}
#method_after
protected boolean notifySignalStrength() {
    boolean notified = false;
    if (!mSignalStrength.equals(mLastSignalStrength)) {
        try {
            mPhone.notifySignalStrength();
            notified = true;
            mLastSignalStrength = mSignalStrength;
        } catch (NullPointerException ex) {
            loge("updateSignalStrength() Phone already destroyed: " + ex + "SignalStrength not notified");
        }
    }
    return notified;
}
#end_block

#method_before
public void registerForDataRoamingOff(Handler h, int what, Object obj) {
    Registrant r = new Registrant(h, what, obj);
    mDataRoamingOffRegistrants.add(r);
    if (!mSS.getDataRoaming()) {
        r.notifyRegistrant();
    }
}
#method_after
public void registerForDataRoamingOff(Handler h, int what, Object obj, boolean notifyNow) {
    Registrant r = new Registrant(h, what, obj);
    mDataRoamingOffRegistrants.add(r);
    if (notifyNow && !mSS.getDataRoaming()) {
        r.notifyRegistrant();
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        // GSM
        case EVENT_RADIO_AVAILABLE:
            // setPowerStateToDesired();
            break;
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                processCellLocationInfo(mCellLoc, (VoiceRegStateResult) ar.result);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        case EVENT_RADIO_POWER_OFF_DONE:
            if (DBG)
                log("EVENT_RADIO_POWER_OFF_DONE");
            if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
                // during shutdown the modem may not send radio state changed event
                // as a result of radio power request
                // Hence, issuing shut down regardless of radio power response
                mCi.requestShutdown(null);
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                processCellLocationInfo(mCellLoc, (VoiceRegStateResult) ar.result);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_SIM_NOT_INSERTED:
            if (DBG)
                log("EVENT_SIM_NOT_INSERTED");
            cancelAllNotifications();
            mMdn = null;
            mMin = null;
            mIsMinInfoReady = false;
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        case EVENT_IMS_SERVICE_STATE_CHANGED:
            if (DBG)
                log("EVENT_IMS_SERVICE_STATE_CHANGED");
            // GsmCdma phone is not STATE_IN_SERVICE.
            if (mSS.getState() != ServiceState.STATE_IN_SERVICE) {
                mPhone.notifyServiceStateChanged(mPhone.getServiceState());
            }
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                mNewSS.setVoiceRoaming(isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS));
            }
            /**
             * For CDMA, voice and data should have the same roaming status.
             * If voice is not in service, use TSB58 roaming indicator to set
             * data roaming status. If TSB58 roaming indicator is not in the
             * carrier-specified list of ERIs for home system then set roaming.
             */
            final int dataRat = mNewSS.getRilDataRadioTechnology();
            if (ServiceState.isCdma(dataRat)) {
                final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
                if (isVoiceInService) {
                    mNewSS.setDataRoaming(mNewSS.getVoiceRoaming());
                } else {
                    /**
                     * As per VoiceRegStateResult from radio types.hal the TSB58
                     * Roaming Indicator shall be sent if device is registered
                     * on a CDMA or EVDO system.
                     */
                    mNewSS.setDataRoaming(!isRoamIndForHomeSystem(Integer.toString(mRoamingIndicator)));
                }
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#method_after
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                boolean isRoamingBetweenOperators = isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS);
                if (isRoamingBetweenOperators != mNewSS.getVoiceRoaming()) {
                    log("isRoamingBetweenOperators=" + isRoamingBetweenOperators + ". Override CDMA voice roaming to " + isRoamingBetweenOperators);
                    mNewSS.setVoiceRoaming(isRoamingBetweenOperators);
                }
            }
            /**
             * For CDMA, voice and data should have the same roaming status.
             * If voice is not in service, use TSB58 roaming indicator to set
             * data roaming status. If TSB58 roaming indicator is not in the
             * carrier-specified list of ERIs for home system then set roaming.
             */
            final int dataRat = mNewSS.getRilDataRadioTechnology();
            if (ServiceState.isCdma(dataRat)) {
                final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
                if (isVoiceInService) {
                    boolean isVoiceRoaming = mNewSS.getVoiceRoaming();
                    if (mNewSS.getDataRoaming() != isVoiceRoaming) {
                        log("Data roaming != Voice roaming. Override data roaming to " + isVoiceRoaming);
                        mNewSS.setDataRoaming(isVoiceRoaming);
                    }
                } else {
                    /**
                     * As per VoiceRegStateResult from radio types.hal the TSB58
                     * Roaming Indicator shall be sent if device is registered
                     * on a CDMA or EVDO system.
                     */
                    boolean isRoamIndForHomeSystem = isRoamIndForHomeSystem(Integer.toString(mRoamingIndicator));
                    if (mNewSS.getDataRoaming() == isRoamIndForHomeSystem) {
                        log("isRoamIndForHomeSystem=" + isRoamIndForHomeSystem + ", override data roaming to " + !isRoamIndForHomeSystem);
                        mNewSS.setDataRoaming(!isRoamIndForHomeSystem);
                    }
                }
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#end_block

#method_before
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    // init with 0, because it is treated as a boolean
                    int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mNewSS.setCssIndicator(cssIndicator);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#method_after
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setCssIndicator(cssIndicator);
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(mDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (mPhone.shouldForceAutoNetworkSelect())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#end_block

#method_before
private boolean isRoamIndForHomeSystem(String roamInd) {
    // retrieve the carrier-specified list of ERIs for home system
    log("isRoamIndForHomeSystem: " + mPhone.getContext().getResources().getConfiguration().toString());
    String[] homeRoamIndicators = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.config_cdma_home_system);
    if (homeRoamIndicators != null) {
        // return true if one is found.
        for (String homeRoamInd : homeRoamIndicators) {
            if (homeRoamInd.equals(roamInd)) {
                return true;
            }
        }
        // no matches found against the list!
        log("isRoamIndForHomeSystem: No match found against list for roamInd=" + roamInd);
        return false;
    }
    // no system property found for the roaming indicators for home system
    log("isRoamIndForHomeSystem: No list found");
    return false;
}
#method_after
private boolean isRoamIndForHomeSystem(String roamInd) {
    // retrieve the carrier-specified list of ERIs for home system
    String[] homeRoamIndicators = Resources.getSystem().getStringArray(com.android.internal.R.array.config_cdma_home_system);
    log("isRoamIndForHomeSystem: homeRoamIndicators=" + Arrays.toString(homeRoamIndicators));
    if (homeRoamIndicators != null) {
        // return true if one is found.
        for (String homeRoamInd : homeRoamIndicators) {
            if (homeRoamInd.equals(roamInd)) {
                return true;
            }
        }
        // no matches found against the list!
        log("isRoamIndForHomeSystem: No match found against list for roamInd=" + roamInd);
        return false;
    }
    // no system property found for the roaming indicators for home system
    log("isRoamIndForHomeSystem: No list found");
    return false;
}
#end_block

#method_before
protected void updateRoamingState() {
    if (mPhone.isPhoneTypeGsm()) {
        /**
         * Since the roaming state of gsm service (from +CREG) and
         * data service (from +CGREG) could be different, the new SS
         * is set to roaming when either is true.
         *
         * There are exceptions for the above rule.
         * The new SS is not set as roaming while gsm service reports
         * roaming but indeed it is same operator.
         * And the operator is considered non roaming.
         *
         * The test for the operators is to handle special roaming
         * agreements and MVNO's.
         */
        boolean roaming = (mGsmRoaming || mDataRoaming);
        if (mGsmRoaming && !isOperatorConsideredRoaming(mNewSS) && (isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS))) {
            roaming = false;
        }
        // Save the roaming state before carrier config possibly overrides it.
        mNewSS.setDataRoamingFromRegistration(roaming);
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    roaming = false;
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set non roaming:" + mNewSS.getOperatorNumeric());
                    roaming = false;
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric());
                    roaming = true;
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        mNewSS.setVoiceRoaming(roaming);
        mNewSS.setDataRoaming(roaming);
    } else {
        // Save the roaming state before carrier config possibly overrides it.
        mNewSS.setDataRoamingFromRegistration(mNewSS.getDataRoaming());
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                String systemId = Integer.toString(mNewSS.getSystemId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    setRoamingOff();
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isNonRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set non-roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOff();
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOn();
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
            mNewSS.setVoiceRoaming(true);
            mNewSS.setDataRoaming(true);
        }
    }
}
#method_after
protected void updateRoamingState() {
    if (mPhone.isPhoneTypeGsm()) {
        /**
         * Since the roaming state of gsm service (from +CREG) and
         * data service (from +CGREG) could be different, the new SS
         * is set to roaming when either is true.
         *
         * There are exceptions for the above rule.
         * The new SS is not set as roaming while gsm service reports
         * roaming but indeed it is same operator.
         * And the operator is considered non roaming.
         *
         * The test for the operators is to handle special roaming
         * agreements and MVNO's.
         */
        boolean roaming = (mGsmRoaming || mDataRoaming);
        if (mGsmRoaming && !isOperatorConsideredRoaming(mNewSS) && (isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS))) {
            log("updateRoamingState: resource override set non roaming.isSameNamedOperators=" + isSameNamedOperators(mNewSS) + ",isOperatorConsideredNonRoaming=" + isOperatorConsideredNonRoaming(mNewSS));
            roaming = false;
        }
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    roaming = false;
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set non roaming:" + mNewSS.getOperatorNumeric());
                    roaming = false;
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric());
                    roaming = true;
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        mNewSS.setVoiceRoaming(roaming);
        mNewSS.setDataRoaming(roaming);
    } else {
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                String systemId = Integer.toString(mNewSS.getSystemId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    setRoamingOff();
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isNonRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set non-roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOff();
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOn();
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
            mNewSS.setVoiceRoaming(true);
            mNewSS.setDataRoaming(true);
        }
    }
}
#end_block

#method_before
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    int combinedRegState = getCombinedRegState();
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            if (mEmergencyOnly) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlphaLong contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    int combinedRegState = getCombinedRegState();
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled() && (combinedRegState == ServiceState.STATE_IN_SERVICE)) {
        // In Wi-Fi Calling mode show SPN or PLMN + WiFi Calling
        // 
        // 1) Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
        // is satisfied or SPN override is enabled for this carrier
        // 
        // 2) Show PLMN + Wi-Fi Calling if there is no valid SPN in case 1
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
            // is satisfied or SPN override is enabled for this carrier.
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // Show PLMN + Wi-Fi Calling if there is no valid SPN in the above case
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
protected void log(String s) {
    Rlog.d(LOG_TAG, s);
}
#method_after
protected final void log(String s) {
    Rlog.d(LOG_TAG, s);
}
#end_block

#method_before
protected void loge(String s) {
    Rlog.e(LOG_TAG, s);
}
#method_after
protected final void loge(String s) {
    Rlog.e(LOG_TAG, s);
}
#end_block

#method_before
public boolean isConcurrentVoiceAndDataAllowed() {
    if (mPhone.isPhoneTypeGsm()) {
        return (mSS.getRilVoiceRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else if (mPhone.isPhoneTypeCdma()) {
        // For the time-being, the return value will be false.
        return false;
    } else {
        // Using the Conncurrent Service Supported flag for CdmaLte devices.
        return mSS.getCssIndicator() == 1;
    }
}
#method_after
public boolean isConcurrentVoiceAndDataAllowed() {
    if (mSS.getCssIndicator() == 1) {
        // Checking the Concurrent Service Supported flag first for all phone types.
        return true;
    } else if (mPhone.isPhoneTypeGsm()) {
        return (mSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else {
        return false;
    }
}
#end_block

#method_before
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#method_after
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(mRejectCode == 0 ? CS_REJECT_CAUSE_DISABLED : CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                List<String> uniqueZoneIds = TimeUtils.getTimeZoneIdsWithUniqueOffsets(iso);
                if ((uniqueZoneIds.size() == 1) || testOneUniqueOffsetPath) {
                    String zoneId = uniqueZoneIds.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zoneId + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    mTimeZoneLog.log("pollStateDone: set time zone=" + zoneId + " mcc=" + mcc + " iso=" + iso);
                    setAndBroadcastNetworkSetTimeZone(zoneId);
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZoneIds.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify using PhoneStateListener and the legacy intent ACTION_SERVICE_STATE_CHANGED
        mPhone.notifyServiceStateChanged(mSS);
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // ratchet the new tech up through it's rat family but don't drop back down
    // until cell change or device is OOS
    boolean isDataInService = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    if (!hasLocationChanged && isDataInService) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkAvailable();
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkUnavailable();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String prevCountryIsoCode = tm.getNetworkCountryIso(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mNitzState.handleNetworkUnavailable();
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update IDD.
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            // Update ISO.
            String countryIsoCode = "";
            try {
                String mcc = operatorNumeric.substring(0, 3);
                countryIsoCode = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), countryIsoCode);
            // Update Time Zone.
            boolean iccCardExists = iccCardExists();
            boolean networkIsoChanged = networkCountryIsoChanged(countryIsoCode, prevCountryIsoCode);
            // Determine countryChanged: networkIso is only reliable if there's an ICC card.
            boolean countryChanged = iccCardExists && networkIsoChanged;
            if (DBG) {
                long ctm = System.currentTimeMillis();
                log("Before handleNetworkCountryCodeKnown:" + " countryChanged=" + countryChanged + " iccCardExist=" + iccCardExists + " countryIsoChanged=" + networkIsoChanged + " operatorNumeric=" + operatorNumeric + " prevOperatorNumeric=" + prevOperatorNumeric + " countryIsoCode=" + countryIsoCode + " prevCountryIsoCode=" + prevCountryIsoCode + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            mNitzState.handleNetworkCountryCodeSet(countryChanged);
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name))) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && getCombinedRegState() == ServiceState.STATE_IN_SERVICE && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#method_after
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name)) && (!mIsSubscriptionFromRuim)) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && getCombinedRegState() == ServiceState.STATE_IN_SERVICE && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#end_block

#method_before
protected void setOperatorIdd(String operatorNumeric) {
    // Retrieve the current country information
    // with the MCC got from opeatorNumeric.
    String idd = mHbpcdUtils.getIddByMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
    if (idd != null && !idd.isEmpty()) {
        SystemProperties.set(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, idd);
    } else {
        // use default "+", since we don't know the current IDP
        SystemProperties.set(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, "+");
    }
}
#method_after
protected void setOperatorIdd(String operatorNumeric) {
    // Retrieve the current country information
    // with the MCC got from opeatorNumeric.
    String idd = mHbpcdUtils.getIddByMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
    if (idd != null && !idd.isEmpty()) {
        mPhone.setGlobalSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, idd);
    } else {
        // use default "+", since we don't know the current IDP
        mPhone.setGlobalSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_IDP_STRING, "+");
    }
}
#end_block

#method_before
protected boolean isInvalidOperatorNumeric(String operatorNumeric) {
    return operatorNumeric == null || operatorNumeric.length() < 5 || operatorNumeric.startsWith(INVALID_MCC);
}
#method_after
private boolean isInvalidOperatorNumeric(String operatorNumeric) {
    return operatorNumeric == null || operatorNumeric.length() < 5 || operatorNumeric.startsWith(INVALID_MCC);
}
#end_block

#method_before
protected String fixUnknownMcc(String operatorNumeric, int sid) {
    if (sid <= 0) {
        // no cdma information is available, do nothing
        return operatorNumeric;
    }
    // resolve the mcc from sid;
    // if mSavedTimeZone is null, TimeZone would get the default timeZone,
    // and the fixTimeZone couldn't help, because it depends on operator Numeric;
    // if the sid is conflict and timezone is unavailable, the mcc may be not right.
    boolean isNitzTimeZone = false;
    int timeZone = 0;
    TimeZone tzone = null;
    if (mSavedTimeZone != null) {
        timeZone = TimeZone.getTimeZone(mSavedTimeZone).getRawOffset() / MS_PER_HOUR;
        isNitzTimeZone = true;
    } else {
        tzone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
        if (tzone != null)
            timeZone = tzone.getRawOffset() / MS_PER_HOUR;
    }
    int mcc = mHbpcdUtils.getMcc(sid, timeZone, (mZoneDst ? 1 : 0), isNitzTimeZone);
    if (mcc > 0) {
        operatorNumeric = Integer.toString(mcc) + DEFAULT_MNC;
    }
    return operatorNumeric;
}
#method_after
private String fixUnknownMcc(String operatorNumeric, int sid) {
    if (sid <= 0) {
        // no cdma information is available, do nothing
        return operatorNumeric;
    }
    // resolve the mcc from sid;
    // if mNitzState.getSavedTimeZoneId() is null, TimeZone would get the default timeZone,
    // and the mNitzState.fixTimeZone() couldn't help, because it depends on operator Numeric;
    // if the sid is conflict and timezone is unavailable, the mcc may be not right.
    boolean isNitzTimeZone;
    TimeZone tzone;
    if (mNitzState.getSavedTimeZoneId() != null) {
        tzone = TimeZone.getTimeZone(mNitzState.getSavedTimeZoneId());
        isNitzTimeZone = true;
    } else {
        NitzData lastNitzData = mNitzState.getCachedNitzData();
        if (lastNitzData == null) {
            tzone = null;
        } else {
            tzone = TimeZoneLookupHelper.guessZoneByNitzStatic(lastNitzData);
            if (ServiceStateTracker.DBG) {
                log("fixUnknownMcc(): guessNitzTimeZone returned " + (tzone == null ? tzone : tzone.getID()));
            }
        }
        isNitzTimeZone = false;
    }
    int utcOffsetHours = 0;
    if (tzone != null) {
        utcOffsetHours = tzone.getRawOffset() / MS_PER_HOUR;
    }
    NitzData nitzData = mNitzState.getCachedNitzData();
    boolean isDst = nitzData != null && nitzData.isDst();
    int mcc = mHbpcdUtils.getMcc(sid, utcOffsetHours, (isDst ? 1 : 0), isNitzTimeZone);
    if (mcc > 0) {
        operatorNumeric = Integer.toString(mcc) + DEFAULT_MNC;
    }
    return operatorNumeric;
}
#end_block

#method_before
private boolean isOperatorConsideredNonRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    final CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    String[] numericArray = null;
    if (configManager != null) {
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            numericArray = config.getStringArray(CarrierConfigManager.KEY_NON_ROAMING_OPERATOR_STRING_ARRAY);
        }
    }
    if (ArrayUtils.isEmpty(numericArray) || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isOperatorConsideredNonRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    final CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    String[] numericArray = null;
    if (configManager != null) {
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            numericArray = config.getStringArray(CarrierConfigManager.KEY_NON_ROAMING_OPERATOR_STRING_ARRAY);
        }
    }
    if (ArrayUtils.isEmpty(numericArray) || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (!TextUtils.isEmpty(numeric) && operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private boolean isOperatorConsideredRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    final CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    String[] numericArray = null;
    if (configManager != null) {
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            numericArray = config.getStringArray(CarrierConfigManager.KEY_ROAMING_OPERATOR_STRING_ARRAY);
        }
    }
    if (ArrayUtils.isEmpty(numericArray) || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isOperatorConsideredRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    final CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    String[] numericArray = null;
    if (configManager != null) {
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            numericArray = config.getStringArray(CarrierConfigManager.KEY_ROAMING_OPERATOR_STRING_ARRAY);
        }
    }
    if (ArrayUtils.isEmpty(numericArray) || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (!TextUtils.isEmpty(numeric) && operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public CellLocation getCellLocation(WorkSource workSource) {
    if (((GsmCellLocation) mCellLoc).getLac() >= 0 && ((GsmCellLocation) mCellLoc).getCid() >= 0) {
        if (DBG)
            log("getCellLocation(): X good mCellLoc=" + mCellLoc);
        return mCellLoc;
    } else {
        List<CellInfo> result = getAllCellInfo(workSource);
        if (result != null) {
            // A hack to allow tunneling of LTE information via GsmCellLocation
            // so that older Network Location Providers can return some information
            // on LTE only networks, see bug 9228974.
            // 
            // We'll search the return CellInfo array preferring GSM/WCDMA
            // data, but if there is none we'll tunnel the first LTE information
            // in the list.
            // 
            // The tunnel'd LTE information is returned as follows:
            // LAC = TAC field
            // CID = CI field
            // PSC = 0.
            GsmCellLocation cellLocOther = new GsmCellLocation();
            for (CellInfo ci : result) {
                if (ci instanceof CellInfoGsm) {
                    CellInfoGsm cellInfoGsm = (CellInfoGsm) ci;
                    CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityGsm.getLac(), cellIdentityGsm.getCid());
                    cellLocOther.setPsc(cellIdentityGsm.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret GSM info=" + cellLocOther);
                    return cellLocOther;
                } else if (ci instanceof CellInfoWcdma) {
                    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ci;
                    CellIdentityWcdma cellIdentityWcdma = cellInfoWcdma.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityWcdma.getLac(), cellIdentityWcdma.getCid());
                    cellLocOther.setPsc(cellIdentityWcdma.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret WCDMA info=" + cellLocOther);
                    return cellLocOther;
                } else if ((ci instanceof CellInfoLte) && ((cellLocOther.getLac() < 0) || (cellLocOther.getCid() < 0))) {
                    // We'll return the first good LTE info we get if there is no better answer
                    CellInfoLte cellInfoLte = (CellInfoLte) ci;
                    CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
                    if ((cellIdentityLte.getTac() != Integer.MAX_VALUE) && (cellIdentityLte.getCi() != Integer.MAX_VALUE)) {
                        cellLocOther.setLacAndCid(cellIdentityLte.getTac(), cellIdentityLte.getCi());
                        cellLocOther.setPsc(0);
                        if (DBG) {
                            log("getCellLocation(): possible LTE cellLocOther=" + cellLocOther);
                        }
                    }
                }
            }
            if (DBG) {
                log("getCellLocation(): X ret best answer cellLocOther=" + cellLocOther);
            }
            return cellLocOther;
        } else {
            if (DBG) {
                log("getCellLocation(): X empty mCellLoc and CellInfo mCellLoc=" + mCellLoc);
            }
            return mCellLoc;
        }
    }
}
#method_after
public CellLocation getCellLocation(WorkSource workSource) {
    if (((GsmCellLocation) mCellLoc).getLac() >= 0 && ((GsmCellLocation) mCellLoc).getCid() >= 0) {
        if (VDBG)
            log("getCellLocation(): X good mCellLoc=" + mCellLoc);
        return mCellLoc;
    } else {
        List<CellInfo> result = getAllCellInfo(workSource);
        if (result != null) {
            // A hack to allow tunneling of LTE information via GsmCellLocation
            // so that older Network Location Providers can return some information
            // on LTE only networks, see bug 9228974.
            // 
            // We'll search the return CellInfo array preferring GSM/WCDMA
            // data, but if there is none we'll tunnel the first LTE information
            // in the list.
            // 
            // The tunnel'd LTE information is returned as follows:
            // LAC = TAC field
            // CID = CI field
            // PSC = 0.
            GsmCellLocation cellLocOther = new GsmCellLocation();
            for (CellInfo ci : result) {
                if (ci instanceof CellInfoGsm) {
                    CellInfoGsm cellInfoGsm = (CellInfoGsm) ci;
                    CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityGsm.getLac(), cellIdentityGsm.getCid());
                    cellLocOther.setPsc(cellIdentityGsm.getPsc());
                    if (VDBG)
                        log("getCellLocation(): X ret GSM info=" + cellLocOther);
                    return cellLocOther;
                } else if (ci instanceof CellInfoWcdma) {
                    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ci;
                    CellIdentityWcdma cellIdentityWcdma = cellInfoWcdma.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityWcdma.getLac(), cellIdentityWcdma.getCid());
                    cellLocOther.setPsc(cellIdentityWcdma.getPsc());
                    if (VDBG)
                        log("getCellLocation(): X ret WCDMA info=" + cellLocOther);
                    return cellLocOther;
                } else if ((ci instanceof CellInfoLte) && ((cellLocOther.getLac() < 0) || (cellLocOther.getCid() < 0))) {
                    // We'll return the first good LTE info we get if there is no better answer
                    CellInfoLte cellInfoLte = (CellInfoLte) ci;
                    CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
                    if ((cellIdentityLte.getTac() != Integer.MAX_VALUE) && (cellIdentityLte.getCi() != Integer.MAX_VALUE)) {
                        cellLocOther.setLacAndCid(cellIdentityLte.getTac(), cellIdentityLte.getCi());
                        cellLocOther.setPsc(0);
                        if (VDBG) {
                            log("getCellLocation(): possible LTE cellLocOther=" + cellLocOther);
                        }
                    }
                }
            }
            if (VDBG) {
                log("getCellLocation(): X ret best answer cellLocOther=" + cellLocOther);
            }
            return cellLocOther;
        } else {
            if (VDBG) {
                log("getCellLocation(): X empty mCellLoc and CellInfo mCellLoc=" + mCellLoc);
            }
            return mCellLoc;
        }
    }
}
#end_block

#method_before
private void setTimeFromNITZString(String nitz, long nitzReceiveTime) {
    // "yy/mm/dd,hh:mm:ss(+/-)tz"
    // tz is in number of quarter-hours
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        log("NITZ: " + nitz + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    try {
        /* NITZ time (hour:min:sec) will be in UTC but it supplies the timezone
             * offset as well (which we won't worry about until later) */
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.clear();
        c.set(Calendar.DST_OFFSET, 0);
        String[] nitzSubs = nitz.split("[/:,+-]");
        int year = 2000 + Integer.parseInt(nitzSubs[0]);
        if (year > MAX_NITZ_YEAR) {
            if (DBG)
                loge("NITZ year: " + year + " exceeds limit, skip NITZ time update");
            return;
        }
        c.set(Calendar.YEAR, year);
        // month is 0 based!
        int month = Integer.parseInt(nitzSubs[1]) - 1;
        c.set(Calendar.MONTH, month);
        int date = Integer.parseInt(nitzSubs[2]);
        c.set(Calendar.DATE, date);
        int hour = Integer.parseInt(nitzSubs[3]);
        c.set(Calendar.HOUR, hour);
        int minute = Integer.parseInt(nitzSubs[4]);
        c.set(Calendar.MINUTE, minute);
        int second = Integer.parseInt(nitzSubs[5]);
        c.set(Calendar.SECOND, second);
        boolean sign = (nitz.indexOf('-') == -1);
        int tzOffset = Integer.parseInt(nitzSubs[6]);
        int dst = (nitzSubs.length >= 8) ? Integer.parseInt(nitzSubs[7]) : 0;
        // The zone offset received from NITZ is for current local time,
        // so DST correction is already applied.  Don't add it again.
        // 
        // tzOffset += dst * 4;
        // 
        // We could unapply it if we wanted the raw offset.
        tzOffset = (sign ? 1 : -1) * tzOffset * 15 * 60 * 1000;
        TimeZone zone = null;
        // so we need to convert the ! into /
        if (nitzSubs.length >= 9) {
            String tzname = nitzSubs[8].replace('!', '/');
            zone = TimeZone.getTimeZone(tzname);
        }
        String iso = ((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getNetworkCountryIsoForPhone(mPhone.getPhoneId());
        if (zone == null) {
            if (mGotCountryCode) {
                if (iso != null && iso.length() > 0) {
                    zone = TimeUtils.getTimeZone(tzOffset, dst != 0, c.getTimeInMillis(), iso);
                } else {
                    // We don't have a valid iso country code.  This is
                    // most likely because we're on a test network that's
                    // using a bogus MCC (eg, "001"), so get a TimeZone
                    // based only on the NITZ parameters.
                    zone = getNitzTimeZone(tzOffset, (dst != 0), c.getTimeInMillis());
                }
            }
        }
        if ((zone == null) || (mZoneOffset != tzOffset) || (mZoneDst != (dst != 0))) {
            // We got the time before the country or the zone has changed
            // so we don't know how to identify the DST rules yet.  Save
            // the information and hope to fix it up later.
            mNeedFixZoneAfterNitz = true;
            mZoneOffset = tzOffset;
            mZoneDst = dst != 0;
            mZoneTime = c.getTimeInMillis();
        }
        String tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " tzOffset=" + tzOffset + " dst=" + dst + " zone=" + (zone != null ? zone.getID() : "NULL") + " iso=" + iso + " mGotCountryCode=" + mGotCountryCode + " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz + " getAutoTimeZone()=" + getAutoTimeZone();
        if (DBG) {
            log(tmpLog);
        }
        mTimeZoneLog.log(tmpLog);
        if (zone != null) {
            if (getAutoTimeZone()) {
                setAndBroadcastNetworkSetTimeZone(zone.getID());
            }
            saveNitzTimeZone(zone.getID());
        }
        String ignore = SystemProperties.get("gsm.ignore-nitz");
        if (ignore != null && ignore.equals("yes")) {
            log("NITZ: Not setting clock because gsm.ignore-nitz is set");
            return;
        }
        try {
            mWakeLock.acquire();
            if (!mPhone.isPhoneTypeGsm() || getAutoTime()) {
                long millisSinceNitzReceived = SystemClock.elapsedRealtime() - nitzReceiveTime;
                if (millisSinceNitzReceived < 0) {
                    // Sanity check: something is wrong
                    if (DBG) {
                        log("NITZ: not setting time, clock has rolled " + "backwards since NITZ time was received, " + nitz);
                    }
                    return;
                }
                if (millisSinceNitzReceived > Integer.MAX_VALUE) {
                    // If the time is this far off, something is wrong > 24 days!
                    if (DBG) {
                        log("NITZ: not setting time, processing has taken " + (millisSinceNitzReceived / (1000 * 60 * 60 * 24)) + " days");
                    }
                    return;
                }
                // Note: with range checks above, cast to int is safe
                c.add(Calendar.MILLISECOND, (int) millisSinceNitzReceived);
                tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " Setting time of day to " + c.getTime() + " NITZ receive delay(ms): " + millisSinceNitzReceived + " gained(ms): " + (c.getTimeInMillis() - System.currentTimeMillis()) + " from " + nitz;
                if (DBG) {
                    log(tmpLog);
                }
                mTimeLog.log(tmpLog);
                if (mPhone.isPhoneTypeGsm()) {
                    setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                    Rlog.i(LOG_TAG, "NITZ: after Setting time of day");
                } else {
                    if (getAutoTime()) {
                        /**
                         * Update system time automatically
                         */
                        long gained = c.getTimeInMillis() - System.currentTimeMillis();
                        long timeSinceLastUpdate = SystemClock.elapsedRealtime() - mSavedAtTime;
                        int nitzUpdateSpacing = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_SPACING, mNitzUpdateSpacing);
                        int nitzUpdateDiff = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_DIFF, mNitzUpdateDiff);
                        if ((mSavedAtTime == 0) || (timeSinceLastUpdate > nitzUpdateSpacing) || (Math.abs(gained) > nitzUpdateDiff)) {
                            if (DBG) {
                                log("NITZ: Auto updating time of day to " + c.getTime() + " NITZ receive delay=" + millisSinceNitzReceived + "ms gained=" + gained + "ms from " + nitz);
                            }
                            setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                        } else {
                            if (DBG) {
                                log("NITZ: ignore, a previous update was " + timeSinceLastUpdate + "ms ago and gained=" + gained + "ms");
                            }
                            return;
                        }
                    }
                }
            }
            SystemProperties.set("gsm.nitz.time", String.valueOf(c.getTimeInMillis()));
            saveNitzTime(c.getTimeInMillis());
            mNitzUpdatedTime = true;
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                log("NITZ: end=" + end + " dur=" + (end - start));
            }
            mWakeLock.release();
        }
    } catch (RuntimeException ex) {
        loge("NITZ: Parsing NITZ time " + nitz + " ex=" + ex);
    }
}
#method_after
private void setTimeFromNITZString(String nitzString, long nitzReceiveTime) {
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        Rlog.d(LOG_TAG, "NITZ: " + nitzString + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    NitzData newNitzData = NitzData.parse(nitzString);
    if (newNitzData != null) {
        try {
            TimeStampedValue<NitzData> nitzSignal = new TimeStampedValue<>(newNitzData, nitzReceiveTime);
            mNitzState.handleNitzReceived(nitzSignal);
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                Rlog.d(LOG_TAG, "NITZ: end=" + end + " dur=" + (end - start));
            }
        }
    }
}
#end_block

#method_before
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnDataContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnNormalContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnEmergencyContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                // cancel notification because current reject code is not handled.
                notifyType = CS_REJECT_CAUSE_DISABLED;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
        case CS_REJECT_CAUSE_DISABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED || notifyType == CS_REJECT_CAUSE_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#method_after
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                loge("setNotification: mRejectCode=" + mRejectCode + " is not handled.");
                return;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setStyle(new Notification.BigTextStyle().bigText(details)).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#end_block

#method_before
public void powerOffRadioSafely(DcTracker dcTracker) {
    synchronized (this) {
        if (!mPendingRadioPowerOffAfterDataOff) {
            if (mPhone.isPhoneTypeGsm() || mPhone.isPhoneTypeCdmaLte()) {
                int dds = SubscriptionManager.getDefaultDataSubscriptionId();
                // both if else paths instead of before this isDisconnected test.
                if (dcTracker.isDisconnected() && (dds == mPhone.getSubId() || (dds != mPhone.getSubId() && ProxyController.getInstance().isDataDisconnected(dds)))) {
                    // To minimize race conditions we do this after isDisconnected
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    if (DBG)
                        log("Data disconnected, turn off radio right away.");
                    hangupAndPowerOff();
                } else {
                    // hang up all active voice calls first
                    if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
                        mPhone.mCT.mRingingCall.hangupIfAlive();
                        mPhone.mCT.mBackgroundCall.hangupIfAlive();
                        mPhone.mCT.mForegroundCall.hangupIfAlive();
                    }
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    if (dds != mPhone.getSubId() && !ProxyController.getInstance().isDataDisconnected(dds)) {
                        if (DBG)
                            log("Data is active on DDS.  Wait for all data disconnect");
                        // Data is not disconnected on DDS. Wait for the data disconnect complete
                        // before sending the RADIO_POWER off.
                        ProxyController.getInstance().registerForAllDataDisconnected(dds, this, EVENT_ALL_DATA_DISCONNECTED, null);
                        mPendingRadioPowerOffAfterDataOff = true;
                    }
                    Message msg = Message.obtain(this);
                    msg.what = EVENT_SET_RADIO_POWER_OFF;
                    msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
                    if (sendMessageDelayed(msg, 30000)) {
                        if (DBG)
                            log("Wait upto 30s for data to disconnect, then turn off radio.");
                        mPendingRadioPowerOffAfterDataOff = true;
                    } else {
                        log("Cannot send delayed Msg, turn off radio right away.");
                        hangupAndPowerOff();
                        mPendingRadioPowerOffAfterDataOff = false;
                    }
                }
            } else {
                // In some network, deactivate PDP connection cause releasing of RRC connection,
                // which MM/IMSI detaching request needs. Without this detaching, network can
                // not release the network resources previously attached.
                // So we are avoiding data detaching on these networks.
                String[] networkNotClearData = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.networks_not_clear_data);
                String currentNetwork = mSS.getOperatorNumeric();
                if ((networkNotClearData != null) && (currentNetwork != null)) {
                    for (int i = 0; i < networkNotClearData.length; i++) {
                        if (currentNetwork.equals(networkNotClearData[i])) {
                            // Don't clear data connection for this carrier
                            if (DBG)
                                log("Not disconnecting data for " + currentNetwork);
                            hangupAndPowerOff();
                            return;
                        }
                    }
                }
                // both if else paths instead of before this isDisconnected test.
                if (dcTracker.isDisconnected()) {
                    // To minimize race conditions we do this after isDisconnected
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    if (DBG)
                        log("Data disconnected, turn off radio right away.");
                    hangupAndPowerOff();
                } else {
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    Message msg = Message.obtain(this);
                    msg.what = EVENT_SET_RADIO_POWER_OFF;
                    msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
                    if (sendMessageDelayed(msg, 30000)) {
                        if (DBG)
                            log("Wait upto 30s for data to disconnect, then turn off radio.");
                        mPendingRadioPowerOffAfterDataOff = true;
                    } else {
                        log("Cannot send delayed Msg, turn off radio right away.");
                        hangupAndPowerOff();
                    }
                }
            }
        }
    }
}
#method_after
public void powerOffRadioSafely(DcTracker dcTracker) {
    synchronized (this) {
        if (!mPendingRadioPowerOffAfterDataOff) {
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            // both if else paths instead of before this isDisconnected test.
            if (dcTracker.isDisconnected() && (dds == mPhone.getSubId() || (dds != mPhone.getSubId() && ProxyController.getInstance().isDataDisconnected(dds)))) {
                // To minimize race conditions we do this after isDisconnected
                dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                if (DBG)
                    log("Data disconnected, turn off radio right away.");
                hangupAndPowerOff();
            } else {
                // hang up all active voice calls first
                if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
                    mPhone.mCT.mRingingCall.hangupIfAlive();
                    mPhone.mCT.mBackgroundCall.hangupIfAlive();
                    mPhone.mCT.mForegroundCall.hangupIfAlive();
                }
                dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                if (dds != mPhone.getSubId() && !ProxyController.getInstance().isDataDisconnected(dds)) {
                    if (DBG)
                        log("Data is active on DDS.  Wait for all data disconnect");
                    // Data is not disconnected on DDS. Wait for the data disconnect complete
                    // before sending the RADIO_POWER off.
                    ProxyController.getInstance().registerForAllDataDisconnected(dds, this, EVENT_ALL_DATA_DISCONNECTED, null);
                    mPendingRadioPowerOffAfterDataOff = true;
                }
                Message msg = Message.obtain(this);
                msg.what = EVENT_SET_RADIO_POWER_OFF;
                msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
                if (sendMessageDelayed(msg, 30000)) {
                    if (DBG)
                        log("Wait upto 30s for data to disconnect, then turn off radio.");
                    mPendingRadioPowerOffAfterDataOff = true;
                } else {
                    log("Cannot send delayed Msg, turn off radio right away.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                }
            }
        }
    }
}
#end_block

#method_before
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        mSignalStrength.setGsm(isGsm);
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#method_after
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && voiceRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
            mSignalStrength.fixType();
        } else {
            mSignalStrength.setGsm(isGsm);
        }
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
        mSignalStrength.setUseOnlyRsrpForLteLevel(isUseOnlyRsrpForLteLevel());
        mSignalStrength.setLteRsrpThresholds(getLteRsrpThresholds());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#end_block

#method_before
protected void hangupAndPowerOff() {
    // hang up all active voice calls
    if (!mPhone.isPhoneTypeGsm() || mPhone.isInCall()) {
        mPhone.mCT.mRingingCall.hangupIfAlive();
        mPhone.mCT.mBackgroundCall.hangupIfAlive();
        mPhone.mCT.mForegroundCall.hangupIfAlive();
    }
    mCi.setRadioPower(false, null);
}
#method_after
protected void hangupAndPowerOff() {
    // hang up all active voice calls
    if (!mPhone.isPhoneTypeGsm() || mPhone.isInCall()) {
        mPhone.mCT.mRingingCall.hangupIfAlive();
        mPhone.mCT.mBackgroundCall.hangupIfAlive();
        mPhone.mCT.mForegroundCall.hangupIfAlive();
    }
    mCi.setRadioPower(false, obtainMessage(EVENT_RADIO_POWER_OFF_DONE));
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + mCellLoc);
    pw.println(" mNewCellLoc=" + mNewCellLoc);
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time Logs:");
    ipw.increaseIndent();
    mTimeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time zone Logs:");
    ipw.increaseIndent();
    mTimeZoneLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + Rlog.pii(VDBG, mCellLoc));
    pw.println(" mNewCellLoc=" + Rlog.pii(VDBG, mNewCellLoc));
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.flush();
    mNitzState.dumpState(pw);
    pw.flush();
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    mNitzState.dumpLogs(fd, ipw, args);
}
#end_block

#method_before
protected int getCombinedRegState() {
    int regState = mSS.getVoiceRegState();
    int dataRegState = mSS.getDataRegState();
    if ((regState == ServiceState.STATE_OUT_OF_SERVICE) && (dataRegState == ServiceState.STATE_IN_SERVICE)) {
        log("getCombinedRegState: return STATE_IN_SERVICE as Data is in service");
        regState = dataRegState;
    }
    return regState;
}
#method_after
protected int getCombinedRegState() {
    int regState = mSS.getVoiceRegState();
    int dataRegState = mSS.getDataRegState();
    if ((regState == ServiceState.STATE_OUT_OF_SERVICE || regState == ServiceState.STATE_POWER_OFF) && (dataRegState == ServiceState.STATE_IN_SERVICE)) {
        log("getCombinedRegState: return STATE_IN_SERVICE as Data is in service");
        regState = dataRegState;
    }
    return regState;
}
#end_block

#method_before
public void waitForGc() {
    allowCollection();
    // Requests GC and finalization of objects.
    do {
        try {
            Thread.sleep(10);
        } catch (Exception e) {
        }
        System.gc();
        System.runFinalization();
        System.gc();
    } while (isLive());
    try {
        mQueue.remove();
    } catch (Exception e) {
    }
    reset();
}
#method_after
public void waitForGc() {
    // Start with a full collection to discourage minor collections in the middle of this.
    // Minor collections could cause us to collect the Sentinel but not older objects.
    Runtime.getRuntime().gc();
    // Release the sentinel.
    allowCollection();
    // Another collection.
    Runtime.getRuntime().gc();
    // Request finalization of objects, and subsequent reference enqueueing.
    do {
        System.runFinalization();
        Runtime.getRuntime().gc();
        try {
            Thread.sleep(10);
        } catch (Exception e) {
        }
    } while (isLive());
    // sentinel's "phantom reachability".
    try {
        mQueue.remove();
    } catch (Exception e) {
    }
    markerRef = null;
    // Prepare for the next waitForGc().
    reset();
}
#end_block

#method_before
private static String filterHashes(String t) {
    // We're looking for "<0x%08x>".
    for (; ; ) {
        int index = t.indexOf("<0x");
        if (index < 0) {
            break;
        }
        int endIndex = t.indexOf(">", index);
        if (endIndex < 0) {
            break;
        }
        t = t.substring(0, index + 1) + "HASH" + t.substring(endIndex);
    }
    return t;
}
#method_after
private static String filterHashes(String t) {
    return t.replaceAll("<0x[0-9a-f]{8}>", "<HASH>");
}
#end_block

#method_before
private int getPid(Path proc) throws IOException {
    try {
        return Integer.valueOf(new String(Files.readAllBytes(proc.resolve("stat"))).split(" ")[0]);
    } catch (IOException e) {
        return -1;
    }
}
#method_after
private int getPid(Path proc) throws IOException {
    try {
        // these is the PID.
        return Integer.valueOf(new String(Files.readAllBytes(proc.resolve("stat"))).split(" ")[0]);
    } catch (IOException e) {
        return -1;
    }
}
#end_block

#method_before
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    Map<String, List<String>> paramInfoMap = new HashMap<String, List<String>>() {

        {
            put("master", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
            put("oc-mr1", Arrays.asList("sailfish-userdebug", "marlin-userdebug", "taimen-userdebug", "walleye-userdebug", "aosp_arm_a-userdebug"));
            put("oc", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
        }
    };
    String testPlan = request.getParameter("plan");
    Map<String, List<DeviceBuildInfo>> baseParamMap = getBasicParamMap(paramInfoMap);
    baseParamMap.forEach((branchKey, deviceBuildInfoList) -> {
        List<List<String>> allPassIdLists = new ArrayList<>();
        Map<String, List<TestPlanRunEntity>> allTestPlanRunEntityMap = new HashMap<>();
        deviceBuildInfoList.forEach(deviceBuildInfo -> {
            Map<String, Object> paramMap = new HashMap<String, Object>() {

                {
                    put("branch", new String[] { branchKey });
                    put("device", new String[] { deviceBuildInfo.getDeviceBuildTarget() });
                }
            };
            Calendar cal = Calendar.getInstance();
            cal.add(Calendar.DATE, -7);
            Long startTime = cal.getTime().getTime() * 1000;
            Long endTime = Calendar.getInstance().getTime().getTime() * 1000;
            SortDirection dir = SortDirection.DESCENDING;
            boolean unfiltered = false;
            boolean showPresubmit = false;
            boolean showPostsubmit = true;
            Filter typeFilter = FilterUtil.getTestTypeFilter(showPresubmit, showPostsubmit, unfiltered);
            Key testPlanKey = KeyFactory.createKey(TestPlanEntity.KIND, testPlan);
            Filter testPlanRunFilter = FilterUtil.getTimeFilter(testPlanKey, TestPlanRunEntity.KIND, startTime, endTime, typeFilter);
            List<Filter> userTestFilters = FilterUtil.getUserTestFilters(paramMap);
            userTestFilters.add(0, testPlanRunFilter);
            Filter userDeviceFilter = FilterUtil.getUserDeviceFilter(paramMap);
            List<Key> matchingKeyList = FilterUtil.getMatchingKeys(testPlanKey, TestPlanRunEntity.KIND, userTestFilters, userDeviceFilter, dir, MAX_RUNS_PER_PAGE);
            logger.log(Level.INFO, "the number of matching key => " + matchingKeyList.size());
            if (matchingKeyList.size() > 0) {
                Map<Key, Entity> entityMap = datastore.get(matchingKeyList);
                List<TestPlanRunEntity> testPlanRunEntityList = entityMap.values().stream().map(entity -> TestPlanRunEntity.fromEntity(entity)).collect(Collectors.toList());
                allTestPlanRunEntityMap.put(branchKey + "-" + deviceBuildInfo.getDeviceBuildTarget(), testPlanRunEntityList);
                // The logic for candidate build ID is starting from here
                Comparator<TestPlanRunEntity> byPassing = Comparator.comparingLong(elemFirst -> elemFirst.passCount);
                Comparator<TestPlanRunEntity> byNonPassing = Comparator.comparingLong(elemFirst -> elemFirst.failCount);
                // This will get the TestPlanRunEntity having maximum number of
                // passing and
                // minimum number of fail
                Optional<TestPlanRunEntity> testPlanRunEntity = testPlanRunEntityList.stream().sorted(byPassing.reversed().thenComparing(byNonPassing)).findFirst();
                String buildId = testPlanRunEntity.map(entity -> entity.testBuildId).orElse("");
                deviceBuildInfo.setCandidateBuildId(buildId);
                Long buildIdTimestamp = testPlanRunEntity.map(entity -> {
                    return entity.startTimestamp;
                }).orElse(0L);
                deviceBuildInfo.setCandidateBuildIdTimestamp(buildIdTimestamp);
                // The passBuildIdList containing all passed buildId List for
                // device
                List<String> passBuildIdList = testPlanRunEntityList.stream().filter(entity -> entity.failCount == 0L).map(entity -> entity.testBuildId).collect(Collectors.toList());
                allPassIdLists.add(passBuildIdList);
                logger.log(Level.INFO, "passBuildIdList => " + passBuildIdList);
            } else {
                allPassIdLists.add(new ArrayList<>());
                deviceBuildInfo.setCandidateBuildId("No Test Results");
            }
        });
        Set<String> greenBuildIdList = FilterUtil.getCommonElements(allPassIdLists);
        if (greenBuildIdList.size() > 0) {
            String greenBuildId = greenBuildIdList.iterator().next();
            deviceBuildInfoList.forEach(deviceBuildInfo -> {
                // This is to get the timestamp for greenBuildId
                Optional<TestPlanRunEntity> testPlanRunEntity = allTestPlanRunEntityMap.get(branchKey + "-" + deviceBuildInfo.getDeviceBuildTarget()).stream().filter(entity -> entity.testBuildId.equalsIgnoreCase(greenBuildId)).findFirst();
                // Setting the greenBuildId value and timestamp to
                // deviceBuildInfo object
                deviceBuildInfo.setGreenBuildId(greenBuildId);
                Long buildIdTimestamp = testPlanRunEntity.map(entity -> entity.startTimestamp).orElse(0L);
                deviceBuildInfo.setGreenBuildIdTimestamp(buildIdTimestamp);
            });
        }
    });
    request.setAttribute("plan", request.getParameter("plan"));
    request.setAttribute("greenBuildInfo", baseParamMap);
    response.setStatus(HttpServletResponse.SC_OK);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Exception caught : ", e);
    }
}
#method_after
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    Map<String, List<String>> paramInfoMap = new HashMap<String, List<String>>() {

        {
            put("master", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
            put("oc-mr1", Arrays.asList("sailfish-userdebug", "marlin-userdebug", "taimen-userdebug", "walleye-userdebug", "aosp_arm_a-userdebug"));
            put("oc", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
        }
    };
    String testPlan = request.getParameter("plan");
    Map<String, List<DeviceBuildInfo>> baseParamMap = getBasicParamMap(paramInfoMap);
    baseParamMap.forEach((branchKey, deviceBuildInfoList) -> {
        List<List<String>> allPassIdLists = new ArrayList<>();
        Map<String, List<TestPlanRunEntity>> allTestPlanRunEntityMap = new HashMap<>();
        deviceBuildInfoList.forEach(deviceBuildInfo -> {
            Map<String, Object> paramMap = new HashMap<String, Object>() {

                {
                    put("branch", new String[] { branchKey });
                    put("device", new String[] { deviceBuildInfo.getDeviceBuildTarget() });
                }
            };
            Calendar cal = Calendar.getInstance();
            cal.add(Calendar.DATE, -7);
            Long startTime = cal.getTime().getTime() * 1000;
            Long endTime = Calendar.getInstance().getTime().getTime() * 1000;
            SortDirection dir = SortDirection.DESCENDING;
            boolean unfiltered = false;
            boolean showPresubmit = false;
            boolean showPostsubmit = true;
            Filter typeFilter = FilterUtil.getTestTypeFilter(showPresubmit, showPostsubmit, unfiltered);
            Key testPlanKey = KeyFactory.createKey(TestPlanEntity.KIND, testPlan);
            Filter testPlanRunFilter = FilterUtil.getTimeFilter(testPlanKey, TestPlanRunEntity.KIND, startTime, endTime, typeFilter);
            List<Filter> userTestFilters = FilterUtil.getUserTestFilters(paramMap);
            userTestFilters.add(0, testPlanRunFilter);
            Filter userDeviceFilter = FilterUtil.getUserDeviceFilter(paramMap);
            List<Key> matchingKeyList = FilterUtil.getMatchingKeys(testPlanKey, TestPlanRunEntity.KIND, userTestFilters, userDeviceFilter, dir, MAX_RUNS_PER_PAGE);
            logger.log(Level.INFO, "the number of matching key => " + matchingKeyList.size());
            if (matchingKeyList.size() > 0) {
                Map<Key, Entity> entityMap = datastore.get(matchingKeyList);
                List<TestPlanRunEntity> testPlanRunEntityList = entityMap.values().stream().map(entity -> TestPlanRunEntity.fromEntity(entity)).collect(Collectors.toList());
                allTestPlanRunEntityMap.put(branchKey + "-" + deviceBuildInfo.getDeviceBuildTarget(), testPlanRunEntityList);
                // The passBuildIdList containing all passed buildId List for device
                List<String> passBuildIdList = testPlanRunEntityList.stream().filter(entity -> entity.failCount == 0L).map(entity -> entity.testBuildId).collect(Collectors.toList());
                allPassIdLists.add(passBuildIdList);
                logger.log(Level.INFO, "passBuildIdList => " + passBuildIdList);
                // The logic for candidate build ID is starting from here
                Comparator<TestPlanRunEntity> byPassing = Comparator.comparingLong(elemFirst -> elemFirst.passCount);
                Comparator<TestPlanRunEntity> byNonPassing = Comparator.comparingLong(elemFirst -> elemFirst.failCount);
                // This will get the TestPlanRunEntity having maximum number of
                // passing and minimum number of fail
                Optional<TestPlanRunEntity> testPlanRunEntity = testPlanRunEntityList.stream().sorted(byPassing.reversed().thenComparing(byNonPassing)).findFirst();
                String buildId = testPlanRunEntity.map(entity -> entity.testBuildId).orElse("");
                deviceBuildInfo.setCandidateBuildId(buildId);
                Long buildIdTimestamp = testPlanRunEntity.map(entity -> {
                    return entity.startTimestamp;
                }).orElse(0L);
                deviceBuildInfo.setCandidateBuildIdTimestamp(buildIdTimestamp);
            } else {
                allPassIdLists.add(new ArrayList<>());
                deviceBuildInfo.setCandidateBuildId("No Test Results");
            }
        });
        Set<String> greenBuildIdList = FilterUtil.getCommonElements(allPassIdLists);
        if (greenBuildIdList.size() > 0) {
            String greenBuildId = greenBuildIdList.iterator().next();
            deviceBuildInfoList.forEach(deviceBuildInfo -> {
                // This is to get the timestamp for greenBuildId
                Optional<TestPlanRunEntity> testPlanRunEntity = allTestPlanRunEntityMap.get(branchKey + "-" + deviceBuildInfo.getDeviceBuildTarget()).stream().filter(entity -> entity.testBuildId.equalsIgnoreCase(greenBuildId)).findFirst();
                // Setting the greenBuildId value and timestamp to
                // deviceBuildInfo object
                deviceBuildInfo.setGreenBuildId(greenBuildId);
                Long buildIdTimestamp = testPlanRunEntity.map(entity -> entity.startTimestamp).orElse(0L);
                deviceBuildInfo.setGreenBuildIdTimestamp(buildIdTimestamp);
            });
        }
    });
    request.setAttribute("plan", request.getParameter("plan"));
    request.setAttribute("greenBuildInfo", baseParamMap);
    response.setStatus(HttpServletResponse.SC_OK);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Exception caught : ", e);
    }
}
#end_block

#method_before
public static void insertTestReport(TestReportMessage report) {
    List<Entity> testEntityList = new ArrayList<>();
    List<Entity> branchEntityList = new ArrayList<>();
    List<Entity> buildTargetEntityList = new ArrayList<>();
    List<Entity> coverageEntityList = new ArrayList<>();
    List<Entity> profilingPointRunEntityList = new ArrayList<>();
    if (!report.hasStartTimestamp() || !report.hasEndTimestamp() || !report.hasTest() || !report.hasHostInfo() || !report.hasBuildInfo()) {
        // missing information
        return;
    }
    long startTimestamp = report.getStartTimestamp();
    long endTimestamp = report.getEndTimestamp();
    String testName = report.getTest().toStringUtf8();
    String testBuildId = report.getBuildInfo().getId().toStringUtf8();
    String hostName = report.getHostInfo().getHostname().toStringUtf8();
    TestEntity testEntity = new TestEntity(testName);
    Key testRunKey = KeyFactory.createKey(testEntity.key, TestRunEntity.KIND, report.getStartTimestamp());
    long passCount = 0;
    long failCount = 0;
    long coveredLineCount = 0;
    long totalLineCount = 0;
    Set<Key> buildTargetKeys = new HashSet<>();
    Set<Key> branchKeys = new HashSet<>();
    List<TestCaseRunEntity> testCases = new ArrayList<>();
    List<Key> profilingPointKeys = new ArrayList<>();
    List<String> links = new ArrayList<>();
    // Process test cases
    for (TestCaseReportMessage testCase : report.getTestCaseList()) {
        String testCaseName = testCase.getName().toStringUtf8();
        TestCaseResult result = testCase.getTestResult();
        // Track global pass/fail counts
        if (result == TestCaseResult.TEST_CASE_RESULT_PASS) {
            ++passCount;
        } else if (result != TestCaseResult.TEST_CASE_RESULT_SKIP) {
            ++failCount;
        }
        if (testCase.getSystraceCount() > 0 && testCase.getSystraceList().get(0).getUrlCount() > 0) {
            String systraceLink = testCase.getSystraceList().get(0).getUrl(0).toStringUtf8();
            links.add(systraceLink);
        }
        // Process coverage data for test case
        for (CoverageReportMessage coverage : testCase.getCoverageList()) {
            CoverageEntity coverageEntity = CoverageEntity.fromCoverageReport(testRunKey, testCaseName, coverage);
            if (coverageEntity == null) {
                logger.log(Level.WARNING, "Invalid coverage report in test run " + testRunKey);
            } else {
                coveredLineCount += coverageEntity.coveredLineCount;
                totalLineCount += coverageEntity.totalLineCount;
                coverageEntityList.add(coverageEntity.toEntity());
            }
        }
        // Process profiling data for test case
        for (ProfilingReportMessage profiling : testCase.getProfilingList()) {
            ProfilingPointRunEntity profilingPointRunEntity = ProfilingPointRunEntity.fromProfilingReport(testRunKey, profiling);
            if (profilingPointRunEntity == null) {
                logger.log(Level.WARNING, "Invalid profiling report in test run " + testRunKey);
            } else {
                profilingPointRunEntityList.add(profilingPointRunEntity.toEntity());
                profilingPointKeys.add(profilingPointRunEntity.key);
                testEntity.setHasProfilingData(true);
            }
        }
        int lastIndex = testCases.size() - 1;
        if (lastIndex < 0 || testCases.get(lastIndex).isFull()) {
            testCases.add(new TestCaseRunEntity());
            ++lastIndex;
        }
        TestCaseRunEntity testCaseEntity = testCases.get(lastIndex);
        testCaseEntity.addTestCase(testCaseName, result.getNumber());
    }
    List<Entity> testCasePuts = new ArrayList<>();
    for (TestCaseRunEntity testCaseEntity : testCases) {
        testCasePuts.add(testCaseEntity.toEntity());
    }
    List<Key> testCaseKeys = datastore.put(testCasePuts);
    List<Long> testCaseIds = new ArrayList<>();
    for (Key key : testCaseKeys) {
        testCaseIds.add(key.getId());
    }
    // Process device information
    TestRunType testRunType = null;
    for (AndroidDeviceInfoMessage device : report.getDeviceInfoList()) {
        DeviceInfoEntity deviceInfoEntity = DeviceInfoEntity.fromDeviceInfoMessage(testRunKey, device);
        if (deviceInfoEntity == null) {
            logger.log(Level.WARNING, "Invalid device info in test run " + testRunKey);
        } else {
            // Run type on devices must be the same, else set to OTHER
            TestRunType runType = TestRunType.fromBuildId(deviceInfoEntity.buildId);
            if (testRunType == null) {
                testRunType = runType;
            } else if (runType != testRunType) {
                testRunType = TestRunType.OTHER;
            }
            testEntityList.add(deviceInfoEntity.toEntity());
            BuildTargetEntity target = new BuildTargetEntity(deviceInfoEntity.buildFlavor);
            if (buildTargetKeys.add(target.key)) {
                buildTargetEntityList.add(target.toEntity());
            }
            BranchEntity branch = new BranchEntity(deviceInfoEntity.branch);
            if (branchKeys.add(branch.key)) {
                branchEntityList.add(branch.toEntity());
            }
        }
    }
    // Overall run type should be determined by the device builds unless test build is OTHER
    if (testRunType == null) {
        testRunType = TestRunType.fromBuildId(testBuildId);
    } else if (TestRunType.fromBuildId(testBuildId) == TestRunType.OTHER) {
        testRunType = TestRunType.OTHER;
    }
    // Process global coverage data
    for (CoverageReportMessage coverage : report.getCoverageList()) {
        CoverageEntity coverageEntity = CoverageEntity.fromCoverageReport(testRunKey, new String(), coverage);
        if (coverageEntity == null) {
            logger.log(Level.WARNING, "Invalid coverage report in test run " + testRunKey);
        } else {
            coveredLineCount += coverageEntity.coveredLineCount;
            totalLineCount += coverageEntity.totalLineCount;
            coverageEntityList.add(coverageEntity.toEntity());
        }
    }
    // Process global profiling data
    for (ProfilingReportMessage profiling : report.getProfilingList()) {
        ProfilingPointRunEntity profilingPointRunEntity = ProfilingPointRunEntity.fromProfilingReport(testRunKey, profiling);
        if (profilingPointRunEntity == null) {
            logger.log(Level.WARNING, "Invalid profiling report in test run " + testRunKey);
        } else {
            profilingPointRunEntityList.add(profilingPointRunEntity.toEntity());
            profilingPointKeys.add(profilingPointRunEntity.key);
            testEntity.setHasProfilingData(true);
        }
    }
    // Process log data
    for (LogMessage log : report.getLogList()) {
        if (log.hasUrl())
            links.add(log.getUrl().toStringUtf8());
    }
    // Process url resource
    for (UrlResourceMessage resource : report.getLinkResourceList()) {
        if (resource.hasUrl())
            links.add(resource.getUrl().toStringUtf8());
    }
    TestRunEntity testRunEntity = new TestRunEntity(testEntity.key, testRunType, startTimestamp, endTimestamp, testBuildId, hostName, passCount, failCount, testCaseIds, links, coveredLineCount, totalLineCount);
    testEntityList.add(testRunEntity.toEntity());
    Entity test = testEntity.toEntity();
    if (datastoreTransactionalRetry(test, testEntityList)) {
        List<List<Entity>> auxiliaryEntityList = Arrays.asList(profilingPointRunEntityList, coverageEntityList, branchEntityList, buildTargetEntityList);
        int indexCount = 0;
        for (List<Entity> entityList : auxiliaryEntityList) {
            switch(indexCount) {
                case 0:
                case 1:
                    if (entityList.size() > MAX_ENTITY_SIZE_PER_TRANSACTION) {
                        List<List<Entity>> partitionedList = Lists.partition(entityList, MAX_ENTITY_SIZE_PER_TRANSACTION);
                        partitionedList.forEach(subEntityList -> {
                            datastoreTransactionalRetry(new Entity(NULL_ENTITY_KIND), subEntityList);
                        });
                    } else {
                        datastoreTransactionalRetry(new Entity(NULL_ENTITY_KIND), entityList);
                    }
                    break;
                case 2:
                case 3:
                    datastoreTransactionalRetryWithXG(new Entity(NULL_ENTITY_KIND), entityList, true);
                    break;
                default:
                    break;
            }
            indexCount++;
        }
        if (testRunEntity.type == TestRunType.POSTSUBMIT) {
            VtsAlertJobServlet.addTask(testRunKey);
            if (testRunEntity.hasCoverage) {
                VtsCoverageAlertJobServlet.addTask(testRunKey);
            }
            if (profilingPointKeys.size() > 0) {
                VtsProfilingStatsJobServlet.addTasks(profilingPointKeys);
            }
        } else {
            logger.log(Level.WARNING, "The alert email was not sent as testRunEntity type is not POSTSUBMIT!");
            logger.log(Level.WARNING, "testRunEntity type => " + testRunEntity.type);
        }
    }
}
#method_after
public static void insertTestReport(TestReportMessage report) {
    List<Entity> testEntityList = new ArrayList<>();
    List<Entity> branchEntityList = new ArrayList<>();
    List<Entity> buildTargetEntityList = new ArrayList<>();
    List<Entity> coverageEntityList = new ArrayList<>();
    List<Entity> profilingPointRunEntityList = new ArrayList<>();
    if (!report.hasStartTimestamp() || !report.hasEndTimestamp() || !report.hasTest() || !report.hasHostInfo() || !report.hasBuildInfo()) {
        // missing information
        return;
    }
    long startTimestamp = report.getStartTimestamp();
    long endTimestamp = report.getEndTimestamp();
    String testName = report.getTest().toStringUtf8();
    String testBuildId = report.getBuildInfo().getId().toStringUtf8();
    String hostName = report.getHostInfo().getHostname().toStringUtf8();
    TestEntity testEntity = new TestEntity(testName);
    Key testRunKey = KeyFactory.createKey(testEntity.key, TestRunEntity.KIND, report.getStartTimestamp());
    long passCount = 0;
    long failCount = 0;
    long coveredLineCount = 0;
    long totalLineCount = 0;
    Set<Key> buildTargetKeys = new HashSet<>();
    Set<Key> branchKeys = new HashSet<>();
    List<TestCaseRunEntity> testCases = new ArrayList<>();
    List<Key> profilingPointKeys = new ArrayList<>();
    List<String> links = new ArrayList<>();
    // Process test cases
    for (TestCaseReportMessage testCase : report.getTestCaseList()) {
        String testCaseName = testCase.getName().toStringUtf8();
        TestCaseResult result = testCase.getTestResult();
        // Track global pass/fail counts
        if (result == TestCaseResult.TEST_CASE_RESULT_PASS) {
            ++passCount;
        } else if (result != TestCaseResult.TEST_CASE_RESULT_SKIP) {
            ++failCount;
        }
        if (testCase.getSystraceCount() > 0 && testCase.getSystraceList().get(0).getUrlCount() > 0) {
            String systraceLink = testCase.getSystraceList().get(0).getUrl(0).toStringUtf8();
            links.add(systraceLink);
        }
        // Process coverage data for test case
        for (CoverageReportMessage coverage : testCase.getCoverageList()) {
            CoverageEntity coverageEntity = CoverageEntity.fromCoverageReport(testRunKey, testCaseName, coverage);
            if (coverageEntity == null) {
                logger.log(Level.WARNING, "Invalid coverage report in test run " + testRunKey);
            } else {
                coveredLineCount += coverageEntity.coveredLineCount;
                totalLineCount += coverageEntity.totalLineCount;
                coverageEntityList.add(coverageEntity.toEntity());
            }
        }
        // Process profiling data for test case
        for (ProfilingReportMessage profiling : testCase.getProfilingList()) {
            ProfilingPointRunEntity profilingPointRunEntity = ProfilingPointRunEntity.fromProfilingReport(testRunKey, profiling);
            if (profilingPointRunEntity == null) {
                logger.log(Level.WARNING, "Invalid profiling report in test run " + testRunKey);
            } else {
                profilingPointRunEntityList.add(profilingPointRunEntity.toEntity());
                profilingPointKeys.add(profilingPointRunEntity.key);
                testEntity.setHasProfilingData(true);
            }
        }
        int lastIndex = testCases.size() - 1;
        if (lastIndex < 0 || testCases.get(lastIndex).isFull()) {
            testCases.add(new TestCaseRunEntity());
            ++lastIndex;
        }
        TestCaseRunEntity testCaseEntity = testCases.get(lastIndex);
        testCaseEntity.addTestCase(testCaseName, result.getNumber());
    }
    List<Entity> testCasePuts = new ArrayList<>();
    for (TestCaseRunEntity testCaseEntity : testCases) {
        testCasePuts.add(testCaseEntity.toEntity());
    }
    List<Key> testCaseKeys = datastore.put(testCasePuts);
    List<Long> testCaseIds = new ArrayList<>();
    for (Key key : testCaseKeys) {
        testCaseIds.add(key.getId());
    }
    // Process device information
    TestRunType testRunType = null;
    for (AndroidDeviceInfoMessage device : report.getDeviceInfoList()) {
        DeviceInfoEntity deviceInfoEntity = DeviceInfoEntity.fromDeviceInfoMessage(testRunKey, device);
        if (deviceInfoEntity == null) {
            logger.log(Level.WARNING, "Invalid device info in test run " + testRunKey);
        } else {
            // Run type on devices must be the same, else set to OTHER
            TestRunType runType = TestRunType.fromBuildId(deviceInfoEntity.buildId);
            if (testRunType == null) {
                testRunType = runType;
            } else if (runType != testRunType) {
                testRunType = TestRunType.OTHER;
            }
            testEntityList.add(deviceInfoEntity.toEntity());
            BuildTargetEntity target = new BuildTargetEntity(deviceInfoEntity.buildFlavor);
            if (buildTargetKeys.add(target.key)) {
                buildTargetEntityList.add(target.toEntity());
            }
            BranchEntity branch = new BranchEntity(deviceInfoEntity.branch);
            if (branchKeys.add(branch.key)) {
                branchEntityList.add(branch.toEntity());
            }
        }
    }
    // Overall run type should be determined by the device builds unless test build is OTHER
    if (testRunType == null) {
        testRunType = TestRunType.fromBuildId(testBuildId);
    } else if (TestRunType.fromBuildId(testBuildId) == TestRunType.OTHER) {
        testRunType = TestRunType.OTHER;
    }
    // Process global coverage data
    for (CoverageReportMessage coverage : report.getCoverageList()) {
        CoverageEntity coverageEntity = CoverageEntity.fromCoverageReport(testRunKey, new String(), coverage);
        if (coverageEntity == null) {
            logger.log(Level.WARNING, "Invalid coverage report in test run " + testRunKey);
        } else {
            coveredLineCount += coverageEntity.coveredLineCount;
            totalLineCount += coverageEntity.totalLineCount;
            coverageEntityList.add(coverageEntity.toEntity());
        }
    }
    // Process global profiling data
    for (ProfilingReportMessage profiling : report.getProfilingList()) {
        ProfilingPointRunEntity profilingPointRunEntity = ProfilingPointRunEntity.fromProfilingReport(testRunKey, profiling);
        if (profilingPointRunEntity == null) {
            logger.log(Level.WARNING, "Invalid profiling report in test run " + testRunKey);
        } else {
            profilingPointRunEntityList.add(profilingPointRunEntity.toEntity());
            profilingPointKeys.add(profilingPointRunEntity.key);
            testEntity.setHasProfilingData(true);
        }
    }
    // Process log data
    for (LogMessage log : report.getLogList()) {
        if (log.hasUrl())
            links.add(log.getUrl().toStringUtf8());
    }
    // Process url resource
    for (UrlResourceMessage resource : report.getLinkResourceList()) {
        if (resource.hasUrl())
            links.add(resource.getUrl().toStringUtf8());
    }
    TestRunEntity testRunEntity = new TestRunEntity(testEntity.key, testRunType, startTimestamp, endTimestamp, testBuildId, hostName, passCount, failCount, testCaseIds, links, coveredLineCount, totalLineCount);
    testEntityList.add(testRunEntity.toEntity());
    Entity test = testEntity.toEntity();
    if (datastoreTransactionalRetry(test, testEntityList)) {
        List<List<Entity>> auxiliaryEntityList = Arrays.asList(profilingPointRunEntityList, coverageEntityList, branchEntityList, buildTargetEntityList);
        int indexCount = 0;
        for (List<Entity> entityList : auxiliaryEntityList) {
            switch(indexCount) {
                case 0:
                case 1:
                    if (entityList.size() > MAX_ENTITY_SIZE_PER_TRANSACTION) {
                        List<List<Entity>> partitionedList = Lists.partition(entityList, MAX_ENTITY_SIZE_PER_TRANSACTION);
                        partitionedList.forEach(subEntityList -> {
                            datastoreTransactionalRetry(new Entity(NULL_ENTITY_KIND), subEntityList);
                        });
                    } else {
                        datastoreTransactionalRetry(new Entity(NULL_ENTITY_KIND), entityList);
                    }
                    break;
                case 2:
                case 3:
                    datastoreTransactionalRetryWithXG(new Entity(NULL_ENTITY_KIND), entityList, true);
                    break;
                default:
                    break;
            }
            indexCount++;
        }
        if (testRunEntity.type == TestRunType.POSTSUBMIT) {
            VtsAlertJobServlet.addTask(testRunKey);
            if (testRunEntity.hasCoverage) {
                VtsCoverageAlertJobServlet.addTask(testRunKey);
            }
            if (profilingPointKeys.size() > 0) {
                VtsProfilingStatsJobServlet.addTasks(profilingPointKeys);
            }
        } else {
            logger.log(Level.WARNING, "The alert email was not sent as testRunEntity type is not POSTSUBMIT!" + " \n " + " testRunEntity type => " + testRunEntity.type);
        }
    }
}
#end_block

#method_before
void showWindowInner(boolean showInput) {
    boolean doShowInput = false;
    final int previousImeWindowStatus = (mWindowVisible ? IME_ACTIVE : 0) | (isInputViewShown() ? IME_VISIBLE : 0);
    mWindowVisible = true;
    if (!mShowInputRequested && mInputStarted && showInput) {
        doShowInput = true;
        mShowInputRequested = true;
    }
    if (DEBUG)
        Log.v(TAG, "showWindow: updating UI");
    initialize();
    updateFullscreenMode();
    updateInputViewShown();
    if (!mWindowAdded || !mWindowCreated) {
        mWindowAdded = true;
        mWindowCreated = true;
        initialize();
        if (DEBUG)
            Log.v(TAG, "CALL: onCreateCandidatesView");
        View v = onCreateCandidatesView();
        if (DEBUG)
            Log.v(TAG, "showWindow: candidates=" + v);
        if (v != null) {
            setCandidatesView(v);
        }
    }
    if (mShowInputRequested) {
        if (!mInputViewStarted) {
            if (DEBUG)
                Log.v(TAG, "CALL: onStartInputView");
            mInputViewStarted = true;
            onStartInputView(mInputEditorInfo, false);
        }
    } else if (!mCandidatesViewStarted) {
        if (DEBUG)
            Log.v(TAG, "CALL: onStartCandidatesView");
        mCandidatesViewStarted = true;
        onStartCandidatesView(mInputEditorInfo, false);
    }
    if (doShowInput) {
        startExtractingText(false);
    }
    final int nextImeWindowStatus = IME_ACTIVE | (isInputViewShown() ? IME_VISIBLE : 0);
    if (previousImeWindowStatus != nextImeWindowStatus) {
        mImm.setImeWindowStatus(mToken, mStartInputToken, nextImeWindowStatus, mBackDisposition);
    }
    if ((previousImeWindowStatus & IME_ACTIVE) == 0) {
        if (DEBUG)
            Log.v(TAG, "showWindow: showing!");
        mWindow.show();
        onWindowShown();
        // Put here rather than in onWindowShown() in case people forget to call
        // super.onWindowShown().
        mShouldClearInsetOfPreviousIme = false;
    }
}
#method_after
void showWindowInner(boolean showInput) {
    boolean doShowInput = false;
    final int previousImeWindowStatus = (mWindowVisible ? IME_ACTIVE : 0) | (isInputViewShown() ? IME_VISIBLE : 0);
    mWindowVisible = true;
    if (!mShowInputRequested && mInputStarted && showInput) {
        doShowInput = true;
        mShowInputRequested = true;
    }
    if (DEBUG)
        Log.v(TAG, "showWindow: updating UI");
    initialize();
    updateFullscreenMode();
    updateInputViewShown();
    if (!mWindowAdded || !mWindowCreated) {
        mWindowAdded = true;
        mWindowCreated = true;
        initialize();
        if (DEBUG)
            Log.v(TAG, "CALL: onCreateCandidatesView");
        View v = onCreateCandidatesView();
        if (DEBUG)
            Log.v(TAG, "showWindow: candidates=" + v);
        if (v != null) {
            setCandidatesView(v);
        }
    }
    if (mShowInputRequested) {
        if (!mInputViewStarted) {
            if (DEBUG)
                Log.v(TAG, "CALL: onStartInputView");
            mInputViewStarted = true;
            onStartInputView(mInputEditorInfo, false);
        }
    } else if (!mCandidatesViewStarted) {
        if (DEBUG)
            Log.v(TAG, "CALL: onStartCandidatesView");
        mCandidatesViewStarted = true;
        onStartCandidatesView(mInputEditorInfo, false);
    }
    if (doShowInput) {
        startExtractingText(false);
    }
    final int nextImeWindowStatus = IME_ACTIVE | (isInputViewShown() ? IME_VISIBLE : 0);
    if (previousImeWindowStatus != nextImeWindowStatus) {
        mImm.setImeWindowStatus(mToken, mStartInputToken, nextImeWindowStatus, mBackDisposition);
    }
    if ((previousImeWindowStatus & IME_ACTIVE) == 0) {
        if (DEBUG)
            Log.v(TAG, "showWindow: showing!");
        onWindowShown();
        mWindow.show();
        // Put here rather than in onWindowShown() in case people forget to call
        // super.onWindowShown().
        mShouldClearInsetOfPreviousIme = false;
    }
}
#end_block

#method_before
private void testTransitionSelection(boolean testOpen, boolean testNewTask, boolean bottomWallpaper, boolean topWallpaper, boolean topTranslucent, boolean testSlowStop, String expectedTransit) throws Exception {
    // There is no wallpaper in VR mode.
    if (isVrHeadset()) {
        return;
    }
    String bottomStartCmd = getAmStartCmd(BOTTOM_ACTIVITY_NAME);
    if (bottomWallpaper) {
        bottomStartCmd += " --ez USE_WALLPAPER true";
    }
    if (testSlowStop) {
        bottomStartCmd += " --ei STOP_DELAY 3000";
    }
    executeShellCommand(bottomStartCmd);
    final String topActivityName = topTranslucent ? TRANSLUCENT_TOP_ACTIVITY_NAME : TOP_ACTIVITY_NAME;
    final String[] bottomActivityArray = new String[] { BOTTOM_ACTIVITY_NAME };
    final String[] topActivityArray = new String[] { topActivityName };
    mAmWmState.computeState(mDevice, bottomActivityArray);
    String topStartCmd = getAmStartCmd(topActivityName);
    if (testNewTask) {
        topStartCmd += " -f 0x18000000";
    }
    if (topWallpaper) {
        topStartCmd += " --ez USE_WALLPAPER true";
    }
    if (!testOpen) {
        topStartCmd += " --ei FINISH_DELAY 1000";
    }
    executeShellCommand(topStartCmd);
    Thread.sleep(5000);
    if (testOpen) {
        mAmWmState.computeState(mDevice, topActivityArray);
    } else {
        mAmWmState.computeState(mDevice, bottomActivityArray);
    }
    assertEquals("Picked wrong transition", expectedTransit, mAmWmState.getWmState().getLastTransition());
}
#method_after
// ------------------------------------------------------------------------//
private void testTransitionSelection(boolean testOpen, boolean testNewTask, boolean bottomWallpaper, boolean topWallpaper, boolean topTranslucent, boolean testSlowStop, String expectedTransit) throws Exception {
    // There is no wallpaper in VR mode.
    if (isUiModeLockedToVrHeadset() && (bottomWallpaper || topWallpaper)) {
        return;
    }
    String bottomStartCmd = getAmStartCmd(BOTTOM_ACTIVITY_NAME);
    if (bottomWallpaper) {
        bottomStartCmd += " --ez USE_WALLPAPER true";
    }
    if (testSlowStop) {
        bottomStartCmd += " --ei STOP_DELAY 3000";
    }
    executeShellCommand(bottomStartCmd);
    final String topActivityName = topTranslucent ? TRANSLUCENT_TOP_ACTIVITY_NAME : TOP_ACTIVITY_NAME;
    final String[] bottomActivityArray = new String[] { BOTTOM_ACTIVITY_NAME };
    final String[] topActivityArray = new String[] { topActivityName };
    mAmWmState.computeState(mDevice, bottomActivityArray);
    String topStartCmd = getAmStartCmd(topActivityName);
    if (testNewTask) {
        topStartCmd += " -f 0x18000000";
    }
    if (topWallpaper) {
        topStartCmd += " --ez USE_WALLPAPER true";
    }
    if (!testOpen) {
        topStartCmd += " --ei FINISH_DELAY 1000";
    }
    executeShellCommand(topStartCmd);
    Thread.sleep(5000);
    if (testOpen) {
        mAmWmState.computeState(mDevice, topActivityArray);
    } else {
        mAmWmState.computeState(mDevice, bottomActivityArray);
    }
    assertEquals("Picked wrong transition", expectedTransit, mAmWmState.getWmState().getLastTransition());
}
#end_block

#method_before
public void deflect(String number) throws ImsException {
    logi("deflect :: session=" + mSession + ", number=" + number);
    synchronized (mLockObj) {
        if (mSession == null) {
            throw new ImsException("No call to deflect", ImsReasonInfo.CODE_LOCAL_CALL_TERMINATED);
        }
        try {
            mSession.deflect(number);
        } catch (Throwable t) {
            loge("deflect :: ", t);
            throw new ImsException("deflect()", t, 0);
        }
    }
}
#method_after
public void deflect(String number) throws ImsException {
    logi("deflect :: session=" + mSession + ", number=" + Rlog.pii(TAG, number));
    synchronized (mLockObj) {
        if (mSession == null) {
            throw new ImsException("No call to deflect", ImsReasonInfo.CODE_LOCAL_CALL_TERMINATED);
        }
        try {
            mSession.deflect(number);
        } catch (Throwable t) {
            loge("deflect :: ", t);
            throw new ImsException("deflect()", t, 0);
        }
    }
}
#end_block

#method_before
public boolean onDisconnect() {
    boolean changed = false;
    if (!mDisconnected) {
        // mIndex = -1;
        mDisconnectTime = System.currentTimeMillis();
        mDuration = SystemClock.elapsedRealtime() - mConnectTimeReal;
        mDisconnected = true;
        mOwner.mPhone.notifyDisconnect(this);
        if (mParent != null) {
            changed = mParent.connectionDisconnected(this);
        } else {
            Rlog.d(LOG_TAG, "onDisconnect: no parent");
        }
        synchronized (this) {
            if (mImsCall != null)
                mImsCall.close();
            mImsCall = null;
        }
    }
    releaseWakeLock();
    return changed;
}
#method_after
public boolean onDisconnect() {
    boolean changed = false;
    if (!mDisconnected) {
        // mIndex = -1;
        mDisconnectTime = System.currentTimeMillis();
        mDuration = SystemClock.elapsedRealtime() - mConnectTimeReal;
        mDisconnected = true;
        mOwner.mPhone.notifyDisconnect(this);
        notifyDisconnect(mCause);
        if (mParent != null) {
            changed = mParent.connectionDisconnected(this);
        } else {
            Rlog.d(LOG_TAG, "onDisconnect: no parent");
        }
        synchronized (this) {
            if (mImsCall != null)
                mImsCall.close();
            mImsCall = null;
        }
    }
    releaseWakeLock();
    return changed;
}
#end_block

#method_before
@Override
public void deflect(String number) throws CallStateException {
// No-op - Deflect is not supported.
}
#method_after
@Override
public void deflect(String number) throws CallStateException {
    // Deflect is not supported.
    throw new CallStateException("deflect is not supported for CS");
}
#end_block

#method_before
int disconnectCauseFromCode(int causeCode) {
    switch(causeCode) {
        case CallFailCause.USER_BUSY:
            return DisconnectCause.BUSY;
        case CallFailCause.NO_CIRCUIT_AVAIL:
        case CallFailCause.TEMPORARY_FAILURE:
        case CallFailCause.SWITCHING_CONGESTION:
        case CallFailCause.CHANNEL_NOT_AVAIL:
        case CallFailCause.QOS_NOT_AVAIL:
        case CallFailCause.BEARER_NOT_AVAIL:
            return DisconnectCause.CONGESTION;
        case CallFailCause.EMERGENCY_TEMP_FAILURE:
            return DisconnectCause.EMERGENCY_TEMP_FAILURE;
        case CallFailCause.EMERGENCY_PERM_FAILURE:
            return DisconnectCause.EMERGENCY_PERM_FAILURE;
        case CallFailCause.ACM_LIMIT_EXCEEDED:
            return DisconnectCause.LIMIT_EXCEEDED;
        case CallFailCause.OPERATOR_DETERMINED_BARRING:
        case CallFailCause.CALL_BARRED:
            return DisconnectCause.CALL_BARRED;
        case CallFailCause.FDN_BLOCKED:
            return DisconnectCause.FDN_BLOCKED;
        case CallFailCause.IMEI_NOT_ACCEPTED:
            return DisconnectCause.IMEI_NOT_ACCEPTED;
        case CallFailCause.UNOBTAINABLE_NUMBER:
            return DisconnectCause.UNOBTAINABLE_NUMBER;
        case CallFailCause.DIAL_MODIFIED_TO_USSD:
            return DisconnectCause.DIAL_MODIFIED_TO_USSD;
        case CallFailCause.DIAL_MODIFIED_TO_SS:
            return DisconnectCause.DIAL_MODIFIED_TO_SS;
        case CallFailCause.DIAL_MODIFIED_TO_DIAL:
            return DisconnectCause.DIAL_MODIFIED_TO_DIAL;
        case CallFailCause.CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return DisconnectCause.CDMA_LOCKED_UNTIL_POWER_CYCLE;
        case CallFailCause.CDMA_DROP:
            return DisconnectCause.CDMA_DROP;
        case CallFailCause.CDMA_INTERCEPT:
            return DisconnectCause.CDMA_INTERCEPT;
        case CallFailCause.CDMA_REORDER:
            return DisconnectCause.CDMA_REORDER;
        case CallFailCause.CDMA_SO_REJECT:
            return DisconnectCause.CDMA_SO_REJECT;
        case CallFailCause.CDMA_RETRY_ORDER:
            return DisconnectCause.CDMA_RETRY_ORDER;
        case CallFailCause.CDMA_ACCESS_FAILURE:
            return DisconnectCause.CDMA_ACCESS_FAILURE;
        case CallFailCause.CDMA_PREEMPTED:
            return DisconnectCause.CDMA_PREEMPTED;
        case CallFailCause.CDMA_NOT_EMERGENCY:
            return DisconnectCause.CDMA_NOT_EMERGENCY;
        case CallFailCause.CDMA_ACCESS_BLOCKED:
            return DisconnectCause.CDMA_ACCESS_BLOCKED;
        case CallFailCause.NORMAL_UNSPECIFIED:
            return DisconnectCause.NORMAL_UNSPECIFIED;
        case CallFailCause.ERROR_UNSPECIFIED:
        case CallFailCause.NORMAL_CLEARING:
        default:
            GsmCdmaPhone phone = mOwner.getPhone();
            int serviceState = phone.getServiceState().getState();
            UiccCardApplication cardApp = phone.getUiccCardApplication();
            AppState uiccAppState = (cardApp != null) ? cardApp.getState() : AppState.APPSTATE_UNKNOWN;
            if (serviceState == ServiceState.STATE_POWER_OFF) {
                return DisconnectCause.POWER_OFF;
            }
            if (!mIsEmergencyCall) {
                // an OUT_OF_SERVICE disconnect cause during normal call ending.
                if ((serviceState == ServiceState.STATE_OUT_OF_SERVICE || serviceState == ServiceState.STATE_EMERGENCY_ONLY)) {
                    return DisconnectCause.OUT_OF_SERVICE;
                }
                // locked the AppState will always not be equal to APPSTATE_READY.
                if (uiccAppState != AppState.APPSTATE_READY) {
                    if (isPhoneTypeGsm()) {
                        return DisconnectCause.ICC_ERROR;
                    } else {
                        // CDMA
                        if (phone.mCdmaSubscriptionSource == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM) {
                            return DisconnectCause.ICC_ERROR;
                        }
                    }
                }
            }
            if (isPhoneTypeGsm()) {
                if (causeCode == CallFailCause.ERROR_UNSPECIFIED) {
                    if (phone.mSST.mRestrictedState.isCsRestricted()) {
                        return DisconnectCause.CS_RESTRICTED;
                    } else if (phone.mSST.mRestrictedState.isCsEmergencyRestricted()) {
                        return DisconnectCause.CS_RESTRICTED_EMERGENCY;
                    } else if (phone.mSST.mRestrictedState.isCsNormalRestricted()) {
                        return DisconnectCause.CS_RESTRICTED_NORMAL;
                    }
                }
            }
            if (causeCode == CallFailCause.NORMAL_CLEARING) {
                return DisconnectCause.NORMAL;
            }
            // to app, not NORMAL call end.
            return DisconnectCause.ERROR_UNSPECIFIED;
    }
}
#method_after
int disconnectCauseFromCode(int causeCode) {
    switch(causeCode) {
        case CallFailCause.USER_BUSY:
            return DisconnectCause.BUSY;
        case CallFailCause.NO_CIRCUIT_AVAIL:
        case CallFailCause.TEMPORARY_FAILURE:
        case CallFailCause.SWITCHING_CONGESTION:
        case CallFailCause.CHANNEL_NOT_AVAIL:
        case CallFailCause.QOS_NOT_AVAIL:
        case CallFailCause.BEARER_NOT_AVAIL:
            return DisconnectCause.CONGESTION;
        case CallFailCause.EMERGENCY_TEMP_FAILURE:
            return DisconnectCause.EMERGENCY_TEMP_FAILURE;
        case CallFailCause.EMERGENCY_PERM_FAILURE:
            return DisconnectCause.EMERGENCY_PERM_FAILURE;
        case CallFailCause.ACM_LIMIT_EXCEEDED:
            return DisconnectCause.LIMIT_EXCEEDED;
        case CallFailCause.OPERATOR_DETERMINED_BARRING:
        case CallFailCause.CALL_BARRED:
            return DisconnectCause.CALL_BARRED;
        case CallFailCause.FDN_BLOCKED:
            return DisconnectCause.FDN_BLOCKED;
        case CallFailCause.IMEI_NOT_ACCEPTED:
            return DisconnectCause.IMEI_NOT_ACCEPTED;
        case CallFailCause.UNOBTAINABLE_NUMBER:
            return DisconnectCause.UNOBTAINABLE_NUMBER;
        case CallFailCause.DIAL_MODIFIED_TO_USSD:
            return DisconnectCause.DIAL_MODIFIED_TO_USSD;
        case CallFailCause.DIAL_MODIFIED_TO_SS:
            return DisconnectCause.DIAL_MODIFIED_TO_SS;
        case CallFailCause.DIAL_MODIFIED_TO_DIAL:
            return DisconnectCause.DIAL_MODIFIED_TO_DIAL;
        case CallFailCause.CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return DisconnectCause.CDMA_LOCKED_UNTIL_POWER_CYCLE;
        case CallFailCause.CDMA_DROP:
            return DisconnectCause.CDMA_DROP;
        case CallFailCause.CDMA_INTERCEPT:
            return DisconnectCause.CDMA_INTERCEPT;
        case CallFailCause.CDMA_REORDER:
            return DisconnectCause.CDMA_REORDER;
        case CallFailCause.CDMA_SO_REJECT:
            return DisconnectCause.CDMA_SO_REJECT;
        case CallFailCause.CDMA_RETRY_ORDER:
            return DisconnectCause.CDMA_RETRY_ORDER;
        case CallFailCause.CDMA_ACCESS_FAILURE:
            return DisconnectCause.CDMA_ACCESS_FAILURE;
        case CallFailCause.CDMA_PREEMPTED:
            return DisconnectCause.CDMA_PREEMPTED;
        case CallFailCause.CDMA_NOT_EMERGENCY:
            return DisconnectCause.CDMA_NOT_EMERGENCY;
        case CallFailCause.CDMA_ACCESS_BLOCKED:
            return DisconnectCause.CDMA_ACCESS_BLOCKED;
        case CallFailCause.NORMAL_UNSPECIFIED:
            return DisconnectCause.NORMAL_UNSPECIFIED;
        case CallFailCause.USER_ALERTING_NO_ANSWER:
            return DisconnectCause.TIMED_OUT;
        case CallFailCause.ERROR_UNSPECIFIED:
        case CallFailCause.NORMAL_CLEARING:
        default:
            GsmCdmaPhone phone = mOwner.getPhone();
            int serviceState = phone.getServiceState().getState();
            UiccCardApplication cardApp = phone.getUiccCardApplication();
            AppState uiccAppState = (cardApp != null) ? cardApp.getState() : AppState.APPSTATE_UNKNOWN;
            if (serviceState == ServiceState.STATE_POWER_OFF) {
                return DisconnectCause.POWER_OFF;
            }
            if (!mIsEmergencyCall) {
                // an OUT_OF_SERVICE disconnect cause during normal call ending.
                if ((serviceState == ServiceState.STATE_OUT_OF_SERVICE || serviceState == ServiceState.STATE_EMERGENCY_ONLY)) {
                    return DisconnectCause.OUT_OF_SERVICE;
                }
                // locked the AppState will always not be equal to APPSTATE_READY.
                if (uiccAppState != AppState.APPSTATE_READY) {
                    if (isPhoneTypeGsm()) {
                        return DisconnectCause.ICC_ERROR;
                    } else {
                        // CDMA
                        if (phone.mCdmaSubscriptionSource == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM) {
                            return DisconnectCause.ICC_ERROR;
                        }
                    }
                }
            }
            if (isPhoneTypeGsm()) {
                if (causeCode == CallFailCause.ERROR_UNSPECIFIED) {
                    if (phone.mSST.mRestrictedState.isCsRestricted()) {
                        return DisconnectCause.CS_RESTRICTED;
                    } else if (phone.mSST.mRestrictedState.isCsEmergencyRestricted()) {
                        return DisconnectCause.CS_RESTRICTED_EMERGENCY;
                    } else if (phone.mSST.mRestrictedState.isCsNormalRestricted()) {
                        return DisconnectCause.CS_RESTRICTED_NORMAL;
                    }
                }
            }
            if (causeCode == CallFailCause.NORMAL_CLEARING) {
                return DisconnectCause.NORMAL;
            }
            // to app, not NORMAL call end.
            return DisconnectCause.ERROR_UNSPECIFIED;
    }
}
#end_block

#method_before
@Override
public boolean onDisconnect(int cause) {
    boolean changed = false;
    mCause = cause;
    if (!mDisconnected) {
        doDisconnect();
        if (DBG)
            Rlog.d(LOG_TAG, "onDisconnect: cause=" + cause);
        mOwner.getPhone().notifyDisconnect(this);
        if (mParent != null) {
            changed = mParent.connectionDisconnected(this);
        }
        mOrigConnection = null;
    }
    clearPostDialListeners();
    releaseWakeLock();
    return changed;
}
#method_after
@Override
public boolean onDisconnect(int cause) {
    boolean changed = false;
    mCause = cause;
    if (!mDisconnected) {
        doDisconnect();
        if (DBG)
            Rlog.d(LOG_TAG, "onDisconnect: cause=" + cause);
        mOwner.getPhone().notifyDisconnect(this);
        notifyDisconnect(cause);
        if (mParent != null) {
            changed = mParent.connectionDisconnected(this);
        }
        mOrigConnection = null;
    }
    clearPostDialListeners();
    releaseWakeLock();
    return changed;
}
#end_block

#method_before
public boolean update(DriverCall dc) {
    GsmCdmaCall newParent;
    boolean changed = false;
    boolean wasConnectingInOrOut = isConnectingInOrOut();
    boolean wasHolding = (getState() == GsmCdmaCall.State.HOLDING);
    newParent = parentFromDCState(dc.state);
    if (Phone.DEBUG_PHONE)
        log("parent= " + mParent + ", newParent= " + newParent);
    // Ignore dc.number and dc.name in case of a handover connection
    if (isPhoneTypeGsm() && mOrigConnection != null) {
        if (Phone.DEBUG_PHONE)
            log("update: mOrigConnection is not null");
    } else if (isIncoming()) {
        if (!equalsBaseDialString(mAddress, dc.number) && (!mNumberConverted || !equalsBaseDialString(mConvertedNumber, dc.number))) {
            if (Phone.DEBUG_PHONE)
                log("update: phone # changed!");
            mAddress = dc.number;
            changed = true;
        }
    }
    // A null cnapName should be the same as ""
    if (TextUtils.isEmpty(dc.name)) {
        if (!TextUtils.isEmpty(mCnapName)) {
            changed = true;
            mCnapName = "";
        }
    } else if (!dc.name.equals(mCnapName)) {
        changed = true;
        mCnapName = dc.name;
    }
    if (Phone.DEBUG_PHONE)
        log("--dssds----" + mCnapName);
    mCnapNamePresentation = dc.namePresentation;
    mNumberPresentation = dc.numberPresentation;
    if (newParent != mParent) {
        if (mParent != null) {
            mParent.detach(this);
        }
        newParent.attach(this, dc);
        mParent = newParent;
        changed = true;
    } else {
        boolean parentStateChange;
        parentStateChange = mParent.update(this, dc);
        changed = changed || parentStateChange;
    }
    if (Phone.DEBUG_PHONE)
        log("update: parent=" + mParent + ", hasNewParent=" + (newParent != mParent) + ", wasConnectingInOrOut=" + wasConnectingInOrOut + ", wasHolding=" + wasHolding + ", isConnectingInOrOut=" + isConnectingInOrOut() + ", changed=" + changed);
    if (wasConnectingInOrOut && !isConnectingInOrOut()) {
        onConnectedInOrOut();
    }
    if (changed && !wasHolding && (getState() == GsmCdmaCall.State.HOLDING)) {
        // We've transitioned into HOLDING
        onStartedHolding();
    }
    return changed;
}
#method_after
public boolean update(DriverCall dc) {
    GsmCdmaCall newParent;
    boolean changed = false;
    boolean wasConnectingInOrOut = isConnectingInOrOut();
    boolean wasHolding = (getState() == GsmCdmaCall.State.HOLDING);
    newParent = parentFromDCState(dc.state);
    if (Phone.DEBUG_PHONE)
        log("parent= " + mParent + ", newParent= " + newParent);
    // Ignore dc.number and dc.name in case of a handover connection
    if (isPhoneTypeGsm() && mOrigConnection != null) {
        if (Phone.DEBUG_PHONE)
            log("update: mOrigConnection is not null");
    } else if (isIncoming()) {
        if (!equalsBaseDialString(mAddress, dc.number) && (!mNumberConverted || !equalsBaseDialString(mConvertedNumber, dc.number))) {
            if (Phone.DEBUG_PHONE)
                log("update: phone # changed!");
            mAddress = dc.number;
            changed = true;
        }
    }
    int newAudioQuality = getAudioQualityFromDC(dc.audioQuality);
    if (getAudioQuality() != newAudioQuality) {
        if (Phone.DEBUG_PHONE) {
            log("update: audioQuality # changed!:  " + (newAudioQuality == Connection.AUDIO_QUALITY_HIGH_DEFINITION ? "high" : "standard"));
        }
        setAudioQuality(newAudioQuality);
        changed = true;
    }
    // A null cnapName should be the same as ""
    if (TextUtils.isEmpty(dc.name)) {
        if (!TextUtils.isEmpty(mCnapName)) {
            changed = true;
            mCnapName = "";
        }
    } else if (!dc.name.equals(mCnapName)) {
        changed = true;
        mCnapName = dc.name;
    }
    if (Phone.DEBUG_PHONE)
        log("--dssds----" + mCnapName);
    mCnapNamePresentation = dc.namePresentation;
    mNumberPresentation = dc.numberPresentation;
    if (newParent != mParent) {
        if (mParent != null) {
            mParent.detach(this);
        }
        newParent.attach(this, dc);
        mParent = newParent;
        changed = true;
    } else {
        boolean parentStateChange;
        parentStateChange = mParent.update(this, dc);
        changed = changed || parentStateChange;
    }
    if (Phone.DEBUG_PHONE)
        log("update: parent=" + mParent + ", hasNewParent=" + (newParent != mParent) + ", wasConnectingInOrOut=" + wasConnectingInOrOut + ", wasHolding=" + wasHolding + ", isConnectingInOrOut=" + isConnectingInOrOut() + ", changed=" + changed);
    if (wasConnectingInOrOut && !isConnectingInOrOut()) {
        onConnectedInOrOut();
    }
    if (changed && !wasHolding && (getState() == GsmCdmaCall.State.HOLDING)) {
        // We've transitioned into HOLDING
        onStartedHolding();
    }
    return changed;
}
#end_block

#method_before
@Override
public void deflect(String number) throws CallStateException {
// No-op - Deflect is not supported.
}
#method_after
@Override
public void deflect(String number) throws CallStateException {
    // Deflect is not supported.
    throw new CallStateException("deflect is not supported for SipPhone");
}
#end_block

#method_before
@Override
public void deflect(String number) throws CallStateException {
// No-op - Deflect is not supported for external calls.
}
#method_after
@Override
public void deflect(String number) throws CallStateException {
    // Deflect is not supported for external calls.
    throw new CallStateException("Deflect is not supported for external calls");
}
#end_block

#method_before
public static String capabilitiesToString(int capabilities) {
    StringBuilder builder = new StringBuilder();
    builder.append("[Capabilities:");
    if (can(capabilities, CAPABILITY_HOLD)) {
        builder.append(" CAPABILITY_HOLD");
    }
    if (can(capabilities, CAPABILITY_SUPPORT_HOLD)) {
        builder.append(" CAPABILITY_SUPPORT_HOLD");
    }
    if (can(capabilities, CAPABILITY_MERGE_CONFERENCE)) {
        builder.append(" CAPABILITY_MERGE_CONFERENCE");
    }
    if (can(capabilities, CAPABILITY_SWAP_CONFERENCE)) {
        builder.append(" CAPABILITY_SWAP_CONFERENCE");
    }
    if (can(capabilities, CAPABILITY_RESPOND_VIA_TEXT)) {
        builder.append(" CAPABILITY_RESPOND_VIA_TEXT");
    }
    if (can(capabilities, CAPABILITY_MUTE)) {
        builder.append(" CAPABILITY_MUTE");
    }
    if (can(capabilities, CAPABILITY_MANAGE_CONFERENCE)) {
        builder.append(" CAPABILITY_MANAGE_CONFERENCE");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_RX)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_LOCAL_RX");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_TX)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_LOCAL_TX");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_RX)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_REMOTE_RX");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_TX)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_REMOTE_TX");
    }
    if (can(capabilities, CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO)) {
        builder.append(" CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL");
    }
    if (can(capabilities, CAPABILITY_SPEED_UP_MT_AUDIO)) {
        builder.append(" CAPABILITY_SPEED_UP_MT_AUDIO");
    }
    if (can(capabilities, CAPABILITY_CAN_UPGRADE_TO_VIDEO)) {
        builder.append(" CAPABILITY_CAN_UPGRADE_TO_VIDEO");
    }
    if (can(capabilities, CAPABILITY_CAN_PAUSE_VIDEO)) {
        builder.append(" CAPABILITY_CAN_PAUSE_VIDEO");
    }
    if (can(capabilities, CAPABILITY_CAN_PULL_CALL)) {
        builder.append(" CAPABILITY_CAN_PULL_CALL");
    }
    builder.append("]");
    return builder.toString();
}
#method_after
public static String capabilitiesToString(int capabilities) {
    StringBuilder builder = new StringBuilder();
    builder.append("[Capabilities:");
    if (can(capabilities, CAPABILITY_HOLD)) {
        builder.append(" CAPABILITY_HOLD");
    }
    if (can(capabilities, CAPABILITY_SUPPORT_HOLD)) {
        builder.append(" CAPABILITY_SUPPORT_HOLD");
    }
    if (can(capabilities, CAPABILITY_MERGE_CONFERENCE)) {
        builder.append(" CAPABILITY_MERGE_CONFERENCE");
    }
    if (can(capabilities, CAPABILITY_SWAP_CONFERENCE)) {
        builder.append(" CAPABILITY_SWAP_CONFERENCE");
    }
    if (can(capabilities, CAPABILITY_RESPOND_VIA_TEXT)) {
        builder.append(" CAPABILITY_RESPOND_VIA_TEXT");
    }
    if (can(capabilities, CAPABILITY_MUTE)) {
        builder.append(" CAPABILITY_MUTE");
    }
    if (can(capabilities, CAPABILITY_MANAGE_CONFERENCE)) {
        builder.append(" CAPABILITY_MANAGE_CONFERENCE");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_RX)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_LOCAL_RX");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_TX)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_LOCAL_TX");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_RX)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_REMOTE_RX");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_TX)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_REMOTE_TX");
    }
    if (can(capabilities, CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO)) {
        builder.append(" CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL)) {
        builder.append(" CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL");
    }
    if (can(capabilities, CAPABILITY_SPEED_UP_MT_AUDIO)) {
        builder.append(" CAPABILITY_SPEED_UP_MT_AUDIO");
    }
    if (can(capabilities, CAPABILITY_CAN_UPGRADE_TO_VIDEO)) {
        builder.append(" CAPABILITY_CAN_UPGRADE_TO_VIDEO");
    }
    if (can(capabilities, CAPABILITY_CAN_PAUSE_VIDEO)) {
        builder.append(" CAPABILITY_CAN_PAUSE_VIDEO");
    }
    if (can(capabilities, CAPABILITY_CAN_PULL_CALL)) {
        builder.append(" CAPABILITY_CAN_PULL_CALL");
    }
    if (can(capabilities, CAPABILITY_SUPPORT_DEFLECT)) {
        builder.append(" CAPABILITY_SUPPORT_DEFLECT");
    }
    builder.append("]");
    return builder.toString();
}
#end_block

#method_before
public void deflect(String number) {
    mInCallAdapter.deflectCall(mTelecomCallId, number);
}
#method_after
public void deflect(Uri address) {
    mInCallAdapter.deflectCall(mTelecomCallId, address);
}
#end_block

#method_before
private static String capabilitiesToStringInternal(int capabilities, boolean isLong) {
    StringBuilder builder = new StringBuilder();
    builder.append("[");
    if (isLong) {
        builder.append("Capabilities:");
    }
    if (can(capabilities, CAPABILITY_HOLD)) {
        builder.append(isLong ? " CAPABILITY_HOLD" : " hld");
    }
    if (can(capabilities, CAPABILITY_SUPPORT_HOLD)) {
        builder.append(isLong ? " CAPABILITY_SUPPORT_HOLD" : " sup_hld");
    }
    if (can(capabilities, CAPABILITY_MERGE_CONFERENCE)) {
        builder.append(isLong ? " CAPABILITY_MERGE_CONFERENCE" : " mrg_cnf");
    }
    if (can(capabilities, CAPABILITY_SWAP_CONFERENCE)) {
        builder.append(isLong ? " CAPABILITY_SWAP_CONFERENCE" : " swp_cnf");
    }
    if (can(capabilities, CAPABILITY_RESPOND_VIA_TEXT)) {
        builder.append(isLong ? " CAPABILITY_RESPOND_VIA_TEXT" : " txt");
    }
    if (can(capabilities, CAPABILITY_MUTE)) {
        builder.append(isLong ? " CAPABILITY_MUTE" : " mut");
    }
    if (can(capabilities, CAPABILITY_MANAGE_CONFERENCE)) {
        builder.append(isLong ? " CAPABILITY_MANAGE_CONFERENCE" : " mng_cnf");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_RX)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_LOCAL_RX" : " VTlrx");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_TX)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_LOCAL_TX" : " VTltx");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL" : " VTlbi");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_RX)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_REMOTE_RX" : " VTrrx");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_TX)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_REMOTE_TX" : " VTrtx");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL" : " VTrbi");
    }
    if (can(capabilities, CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO)) {
        builder.append(isLong ? " CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO" : " !v2a");
    }
    if (can(capabilities, CAPABILITY_SPEED_UP_MT_AUDIO)) {
        builder.append(isLong ? " CAPABILITY_SPEED_UP_MT_AUDIO" : " spd_aud");
    }
    if (can(capabilities, CAPABILITY_CAN_UPGRADE_TO_VIDEO)) {
        builder.append(isLong ? " CAPABILITY_CAN_UPGRADE_TO_VIDEO" : " a2v");
    }
    if (can(capabilities, CAPABILITY_CAN_PAUSE_VIDEO)) {
        builder.append(isLong ? " CAPABILITY_CAN_PAUSE_VIDEO" : " paus_VT");
    }
    if (can(capabilities, CAPABILITY_CONFERENCE_HAS_NO_CHILDREN)) {
        builder.append(isLong ? " CAPABILITY_SINGLE_PARTY_CONFERENCE" : " 1p_cnf");
    }
    if (can(capabilities, CAPABILITY_CAN_SEND_RESPONSE_VIA_CONNECTION)) {
        builder.append(isLong ? " CAPABILITY_CAN_SEND_RESPONSE_VIA_CONNECTION" : " rsp_by_con");
    }
    if (can(capabilities, CAPABILITY_CAN_PULL_CALL)) {
        builder.append(isLong ? " CAPABILITY_CAN_PULL_CALL" : " pull");
    }
    builder.append("]");
    return builder.toString();
}
#method_after
private static String capabilitiesToStringInternal(int capabilities, boolean isLong) {
    StringBuilder builder = new StringBuilder();
    builder.append("[");
    if (isLong) {
        builder.append("Capabilities:");
    }
    if (can(capabilities, CAPABILITY_HOLD)) {
        builder.append(isLong ? " CAPABILITY_HOLD" : " hld");
    }
    if (can(capabilities, CAPABILITY_SUPPORT_HOLD)) {
        builder.append(isLong ? " CAPABILITY_SUPPORT_HOLD" : " sup_hld");
    }
    if (can(capabilities, CAPABILITY_MERGE_CONFERENCE)) {
        builder.append(isLong ? " CAPABILITY_MERGE_CONFERENCE" : " mrg_cnf");
    }
    if (can(capabilities, CAPABILITY_SWAP_CONFERENCE)) {
        builder.append(isLong ? " CAPABILITY_SWAP_CONFERENCE" : " swp_cnf");
    }
    if (can(capabilities, CAPABILITY_RESPOND_VIA_TEXT)) {
        builder.append(isLong ? " CAPABILITY_RESPOND_VIA_TEXT" : " txt");
    }
    if (can(capabilities, CAPABILITY_MUTE)) {
        builder.append(isLong ? " CAPABILITY_MUTE" : " mut");
    }
    if (can(capabilities, CAPABILITY_MANAGE_CONFERENCE)) {
        builder.append(isLong ? " CAPABILITY_MANAGE_CONFERENCE" : " mng_cnf");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_RX)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_LOCAL_RX" : " VTlrx");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_TX)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_LOCAL_TX" : " VTltx");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL" : " VTlbi");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_RX)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_REMOTE_RX" : " VTrrx");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_TX)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_REMOTE_TX" : " VTrtx");
    }
    if (can(capabilities, CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL)) {
        builder.append(isLong ? " CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL" : " VTrbi");
    }
    if (can(capabilities, CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO)) {
        builder.append(isLong ? " CAPABILITY_CANNOT_DOWNGRADE_VIDEO_TO_AUDIO" : " !v2a");
    }
    if (can(capabilities, CAPABILITY_SPEED_UP_MT_AUDIO)) {
        builder.append(isLong ? " CAPABILITY_SPEED_UP_MT_AUDIO" : " spd_aud");
    }
    if (can(capabilities, CAPABILITY_CAN_UPGRADE_TO_VIDEO)) {
        builder.append(isLong ? " CAPABILITY_CAN_UPGRADE_TO_VIDEO" : " a2v");
    }
    if (can(capabilities, CAPABILITY_CAN_PAUSE_VIDEO)) {
        builder.append(isLong ? " CAPABILITY_CAN_PAUSE_VIDEO" : " paus_VT");
    }
    if (can(capabilities, CAPABILITY_CONFERENCE_HAS_NO_CHILDREN)) {
        builder.append(isLong ? " CAPABILITY_SINGLE_PARTY_CONFERENCE" : " 1p_cnf");
    }
    if (can(capabilities, CAPABILITY_CAN_SEND_RESPONSE_VIA_CONNECTION)) {
        builder.append(isLong ? " CAPABILITY_CAN_SEND_RESPONSE_VIA_CONNECTION" : " rsp_by_con");
    }
    if (can(capabilities, CAPABILITY_CAN_PULL_CALL)) {
        builder.append(isLong ? " CAPABILITY_CAN_PULL_CALL" : " pull");
    }
    if (can(capabilities, CAPABILITY_SUPPORT_DEFLECT)) {
        builder.append(isLong ? " CAPABILITY_SUPPORT_DEFLECT" : " sup_def");
    }
    builder.append("]");
    return builder.toString();
}
#end_block

#method_before
public void onDeflect(String number) {
}
#method_after
public void onDeflect(Uri address) {
}
#end_block

#method_before
public void deflectCall(String callId, String deflectNumber) {
    try {
        mAdapter.deflectCall(callId, deflectNumber);
    } catch (RemoteException e) {
    }
}
#method_after
public void deflectCall(String callId, Uri address) {
    try {
        mAdapter.deflectCall(callId, address);
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
private void createConnection(final PhoneAccountHandle callManagerAccount, final String callId, final ConnectionRequest request, boolean isIncoming, boolean isUnknown) {
    Log.d(this, "createConnection, callManagerAccount: %s, callId: %s, request: %s, " + "isIncoming: %b, isUnknown: %b", callManagerAccount, callId, request, isIncoming, isUnknown);
    Connection connection = null;
    if (getApplicationContext().getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.O_MR1 && request.getExtras() != null && request.getExtras().getBoolean(TelecomManager.EXTRA_IS_HANDOVER, false)) {
        if (!isIncoming) {
            connection = onCreateOutgoingHandoverConnection(callManagerAccount, request);
        } else {
            connection = onCreateIncomingHandoverConnection(callManagerAccount, request);
        }
    } else {
        connection = isUnknown ? onCreateUnknownConnection(callManagerAccount, request) : isIncoming ? onCreateIncomingConnection(callManagerAccount, request) : onCreateOutgoingConnection(callManagerAccount, request);
    }
    Log.d(this, "createConnection, connection: %s", connection);
    if (connection == null) {
        Log.i(this, "createConnection, implementation returned null connection.");
        connection = Connection.createFailedConnection(new DisconnectCause(DisconnectCause.ERROR, "IMPL_RETURNED_NULL_CONNECTION"));
    }
    connection.setTelecomCallId(callId);
    if (connection.getState() != Connection.STATE_DISCONNECTED) {
        addConnection(callId, connection);
    }
    Uri address = connection.getAddress();
    String number = address == null ? "null" : address.getSchemeSpecificPart();
    Log.v(this, "createConnection, number: %s, state: %s, capabilities: %s, properties: %s", Connection.toLogSafePhoneNumber(number), Connection.stateToString(connection.getState()), Connection.capabilitiesToString(connection.getConnectionCapabilities()), Connection.propertiesToString(connection.getConnectionProperties()));
    Log.d(this, "createConnection, calling handleCreateConnectionSuccessful %s", callId);
    mAdapter.handleCreateConnectionComplete(callId, request, new ParcelableConnection(request.getAccountHandle(), connection.getState(), connection.getConnectionCapabilities(), connection.getConnectionProperties(), connection.getSupportedAudioRoutes(), connection.getAddress(), connection.getAddressPresentation(), connection.getCallerDisplayName(), connection.getCallerDisplayNamePresentation(), connection.getVideoProvider() == null ? null : connection.getVideoProvider().getInterface(), connection.getVideoState(), connection.isRingbackRequested(), connection.getAudioModeIsVoip(), connection.getConnectTimeMillis(), connection.getConnectElapsedTimeMillis(), connection.getStatusHints(), connection.getDisconnectCause(), createIdList(connection.getConferenceables()), connection.getExtras()));
    if (isIncoming && request.shouldShowIncomingCallUi() && (connection.getConnectionProperties() & Connection.PROPERTY_SELF_MANAGED) == Connection.PROPERTY_SELF_MANAGED) {
        // Tell ConnectionService to show its incoming call UX.
        connection.onShowIncomingCallUi();
    }
    if (isUnknown) {
        triggerConferenceRecalculate();
    }
}
#method_after
private void createConnection(final PhoneAccountHandle callManagerAccount, final String callId, final ConnectionRequest request, boolean isIncoming, boolean isUnknown) {
    boolean isLegacyHandover = request.getExtras() != null && request.getExtras().getBoolean(TelecomManager.EXTRA_IS_HANDOVER, false);
    boolean isHandover = request.getExtras() != null && request.getExtras().getBoolean(TelecomManager.EXTRA_IS_HANDOVER_CONNECTION, false);
    Log.d(this, "createConnection, callManagerAccount: %s, callId: %s, request: %s, " + "isIncoming: %b, isUnknown: %b, isLegacyHandover: %b, isHandover: %b", callManagerAccount, callId, request, isIncoming, isUnknown, isLegacyHandover, isHandover);
    Connection connection = null;
    if (isHandover) {
        PhoneAccountHandle fromPhoneAccountHandle = request.getExtras() != null ? (PhoneAccountHandle) request.getExtras().getParcelable(TelecomManager.EXTRA_HANDOVER_FROM_PHONE_ACCOUNT) : null;
        if (!isIncoming) {
            connection = onCreateOutgoingHandoverConnection(fromPhoneAccountHandle, request);
        } else {
            connection = onCreateIncomingHandoverConnection(fromPhoneAccountHandle, request);
        }
    } else {
        connection = isUnknown ? onCreateUnknownConnection(callManagerAccount, request) : isIncoming ? onCreateIncomingConnection(callManagerAccount, request) : onCreateOutgoingConnection(callManagerAccount, request);
    }
    Log.d(this, "createConnection, connection: %s", connection);
    if (connection == null) {
        Log.i(this, "createConnection, implementation returned null connection.");
        connection = Connection.createFailedConnection(new DisconnectCause(DisconnectCause.ERROR, "IMPL_RETURNED_NULL_CONNECTION"));
    }
    connection.setTelecomCallId(callId);
    if (connection.getState() != Connection.STATE_DISCONNECTED) {
        addConnection(callId, connection);
    }
    Uri address = connection.getAddress();
    String number = address == null ? "null" : address.getSchemeSpecificPart();
    Log.v(this, "createConnection, number: %s, state: %s, capabilities: %s, properties: %s", Connection.toLogSafePhoneNumber(number), Connection.stateToString(connection.getState()), Connection.capabilitiesToString(connection.getConnectionCapabilities()), Connection.propertiesToString(connection.getConnectionProperties()));
    Log.d(this, "createConnection, calling handleCreateConnectionSuccessful %s", callId);
    mAdapter.handleCreateConnectionComplete(callId, request, new ParcelableConnection(request.getAccountHandle(), connection.getState(), connection.getConnectionCapabilities(), connection.getConnectionProperties(), connection.getSupportedAudioRoutes(), connection.getAddress(), connection.getAddressPresentation(), connection.getCallerDisplayName(), connection.getCallerDisplayNamePresentation(), connection.getVideoProvider() == null ? null : connection.getVideoProvider().getInterface(), connection.getVideoState(), connection.isRingbackRequested(), connection.getAudioModeIsVoip(), connection.getConnectTimeMillis(), connection.getConnectElapsedTimeMillis(), connection.getStatusHints(), connection.getDisconnectCause(), createIdList(connection.getConferenceables()), connection.getExtras()));
    if (isIncoming && request.shouldShowIncomingCallUi() && (connection.getConnectionProperties() & Connection.PROPERTY_SELF_MANAGED) == Connection.PROPERTY_SELF_MANAGED) {
        // Tell ConnectionService to show its incoming call UX.
        connection.onShowIncomingCallUi();
    }
    if (isUnknown) {
        triggerConferenceRecalculate();
    }
}
#end_block

#method_before
private void deflect(String callId, String number) {
    Log.d(this, "deflect %s - %s", callId, number);
    findConnectionForAction(callId, "deflect").onDeflect(number);
}
#method_after
private void deflect(String callId, Uri address) {
    Log.d(this, "deflect %s", callId);
    findConnectionForAction(callId, "deflect").onDeflect(address);
}
#end_block

#method_before
@Override
public void setListener(IImsCallSessionListener listener) throws RemoteException {
}
#method_after
public final void setListener(IImsCallSessionListener listener) throws RemoteException {
    setListener(new ImsCallSessionListener(listener));
}
#end_block

#method_before
@Override
public void setListener(IImsCallSessionListener listener) throws RemoteException {
}
#method_after
public void setListener(ImsCallSessionListener listener) {
}
#end_block

#method_before
@Override
public void close() throws RemoteException {
}
#method_after
@Override
public void close() {
}
#end_block

#method_before
@Override
public String getCallId() throws RemoteException {
    return null;
}
#method_after
public String getCallId() {
    return null;
}
#end_block

#method_before
@Override
public ImsCallProfile getCallProfile() throws RemoteException {
    return null;
}
#method_after
public ImsCallProfile getCallProfile() {
    return null;
}
#end_block

#method_before
@Override
public ImsCallProfile getLocalCallProfile() throws RemoteException {
    return null;
}
#method_after
public ImsCallProfile getLocalCallProfile() {
    return null;
}
#end_block

#method_before
@Override
public ImsCallProfile getRemoteCallProfile() throws RemoteException {
    return null;
}
#method_after
public ImsCallProfile getRemoteCallProfile() {
    return null;
}
#end_block

#method_before
@Override
public String getProperty(String name) throws RemoteException {
    return null;
}
#method_after
public String getProperty(String name) {
    return null;
}
#end_block

#method_before
@Override
public int getState() throws RemoteException {
    return ImsCallSession.State.INVALID;
}
#method_after
public int getState() {
    return ImsCallSessionImplBase.State.INVALID;
}
#end_block

#method_before
@Override
public boolean isInCall() throws RemoteException {
    return false;
}
#method_after
public boolean isInCall() {
    return false;
}
#end_block

#method_before
@Override
public void setMute(boolean muted) throws RemoteException {
}
#method_after
public void setMute(boolean muted) {
}
#end_block

#method_before
@Override
public void start(String callee, ImsCallProfile profile) throws RemoteException {
}
#method_after
public void start(String callee, ImsCallProfile profile) {
}
#end_block

#method_before
@Override
public void startConference(String[] participants, ImsCallProfile profile) throws RemoteException {
}
#method_after
public void startConference(String[] participants, ImsCallProfile profile) {
}
#end_block

#method_before
@Override
public void accept(int callType, ImsStreamMediaProfile profile) throws RemoteException {
}
#method_after
public void accept(int callType, ImsStreamMediaProfile profile) {
}
#end_block

#method_before
@Override
public void deflect(String deflectNumber) throws RemoteException {
}
#method_after
public void deflect(String deflectNumber) {
}
#end_block

#method_before
@Override
public void reject(int reason) throws RemoteException {
}
#method_after
public void reject(int reason) {
}
#end_block

#method_before
@Override
public void terminate(int reason) throws RemoteException {
}
#method_after
public void terminate(int reason) {
}
#end_block

#method_before
@Override
public void hold(ImsStreamMediaProfile profile) throws RemoteException {
}
#method_after
public void hold(ImsStreamMediaProfile profile) {
}
#end_block

#method_before
@Override
public void resume(ImsStreamMediaProfile profile) throws RemoteException {
}
#method_after
public void resume(ImsStreamMediaProfile profile) {
}
#end_block

#method_before
@Override
public void merge() throws RemoteException {
}
#method_after
public void merge() {
}
#end_block

#method_before
@Override
public void update(int callType, ImsStreamMediaProfile profile) throws RemoteException {
}
#method_after
public void update(int callType, ImsStreamMediaProfile profile) {
}
#end_block

#method_before
@Override
public void extendToConference(String[] participants) throws RemoteException {
}
#method_after
public void extendToConference(String[] participants) {
}
#end_block

#method_before
@Override
public void inviteParticipants(String[] participants) throws RemoteException {
}
#method_after
public void inviteParticipants(String[] participants) {
}
#end_block

#method_before
@Override
public void removeParticipants(String[] participants) throws RemoteException {
}
#method_after
public void removeParticipants(String[] participants) {
}
#end_block

#method_before
@Override
public void sendDtmf(char c, Message result) throws RemoteException {
}
#method_after
public void sendDtmf(char c, Message result) {
}
#end_block

#method_before
@Override
public void startDtmf(char c) throws RemoteException {
}
#method_after
public void startDtmf(char c) {
}
#end_block

#method_before
@Override
public void stopDtmf() throws RemoteException {
}
#method_after
public void stopDtmf() {
}
#end_block

#method_before
@Override
public void sendUssd(String ussdMessage) throws RemoteException {
}
#method_after
public void sendUssd(String ussdMessage) {
}
#end_block

#method_before
@Override
public IImsVideoCallProvider getVideoCallProvider() throws RemoteException {
    return null;
}
#method_after
public IImsVideoCallProvider getVideoCallProvider() {
    ImsVideoCallProvider provider = getImsVideoCallProvider();
    return provider != null ? provider.getInterface() : null;
}
#end_block

#method_before
@Override
public boolean isMultiparty() throws RemoteException {
    return false;
}
#method_after
public boolean isMultiparty() {
    return false;
}
#end_block

#method_before
@Override
public void sendRttModifyRequest(ImsCallProfile toProfile) {
}
#method_after
public void sendRttModifyRequest(ImsCallProfile toProfile) {
}
#end_block

#method_before
@Override
public void sendRttModifyResponse(boolean status) {
}
#method_after
public void sendRttModifyResponse(boolean status) {
}
#end_block

#method_before
@Override
public void sendRttMessage(String rttMessage) {
}
#method_after
public void sendRttMessage(String rttMessage) {
}
#end_block

#method_before
@VisibleForTesting
public void setTargetPhoneAccount(PhoneAccountHandle accountHandle) {
    if (!Objects.equals(mTargetPhoneAccountHandle, accountHandle)) {
        mTargetPhoneAccountHandle = accountHandle;
        for (Listener l : mListeners) {
            l.onTargetPhoneAccountChanged(this);
        }
        configureIsWorkCall();
    }
    checkIfVideoCapable();
}
#method_after
@VisibleForTesting
public void setTargetPhoneAccount(PhoneAccountHandle accountHandle) {
    if (!Objects.equals(mTargetPhoneAccountHandle, accountHandle)) {
        mTargetPhoneAccountHandle = accountHandle;
        for (Listener l : mListeners) {
            l.onTargetPhoneAccountChanged(this);
        }
        configureCallAttributes();
    }
    checkIfVideoCapable();
}
#end_block

#method_before
@VisibleForTesting
public void deflect(String number) {
    // between the time the user hits 'deflect' and Telecomm receives the command.
    if (isRinging("deflect")) {
        // {@link ConnectionServiceAdapter#setActive} and other set* methods.
        if (mConnectionService != null) {
            mConnectionService.deflect(this, number);
        } else {
            Log.e(this, new NullPointerException(), "deflect call failed due to null CS callId=%s", getId());
        }
        Log.addEvent(this, LogUtils.Events.REQUEST_DEFLECT);
    }
}
#method_after
@VisibleForTesting
public void deflect(Uri address) {
    // between the time the user hits 'deflect' and Telecomm receives the command.
    if (isRinging("deflect")) {
        // At this point, we are asking the connection service to deflect but we don't assume
        // that it will work. Instead, we wait until confirmation from the connection service
        // that the call is in a non-STATE_RINGING state before changing the UI. See
        // {@link ConnectionServiceAdapter#setActive} and other set* methods.
        mVideoStateHistory |= mVideoState;
        if (mConnectionService != null) {
            mConnectionService.deflect(this, address);
        } else {
            Log.e(this, new NullPointerException(), "deflect call failed due to null CS callId=%s", getId());
        }
        Log.addEvent(this, LogUtils.Events.REQUEST_DEFLECT, Log.pii(address));
    }
}
#end_block

#method_before
void hold() {
    if (mState == CallState.ACTIVE) {
        if (mConnectionService != null) {
            mConnectionService.hold(this);
        } else {
            Log.e(this, new NullPointerException(), "hold call failed due to null CS callId=%s", getId());
        }
        Log.addEvent(this, LogUtils.Events.REQUEST_HOLD);
    }
}
#method_after
@VisibleForTesting
public void hold() {
    if (mState == CallState.ACTIVE) {
        if (mConnectionService != null) {
            mConnectionService.hold(this);
        } else {
            Log.e(this, new NullPointerException(), "hold call failed due to null CS callId=%s", getId());
        }
        Log.addEvent(this, LogUtils.Events.REQUEST_HOLD);
    }
}
#end_block

#method_before
void unhold() {
    if (mState == CallState.ON_HOLD) {
        if (mConnectionService != null) {
            mConnectionService.unhold(this);
        } else {
            Log.e(this, new NullPointerException(), "unhold call failed due to null CS callId=%s", getId());
        }
        Log.addEvent(this, LogUtils.Events.REQUEST_UNHOLD);
    }
}
#method_after
@VisibleForTesting
public void unhold() {
    if (mState == CallState.ON_HOLD) {
        if (mConnectionService != null) {
            mConnectionService.unhold(this);
        } else {
            Log.e(this, new NullPointerException(), "unhold call failed due to null CS callId=%s", getId());
        }
        Log.addEvent(this, LogUtils.Events.REQUEST_UNHOLD);
    }
}
#end_block

#method_before
public void sendCallEvent(String event, Bundle extras) {
    if (mConnectionService != null) {
        if (android.telecom.Call.EVENT_REQUEST_HANDOVER.equals(event)) {
            // Handover requests are targeted at Telecom, not the ConnectionService.
            if (extras == null) {
                Log.w(this, "sendCallEvent: %s event received with null extras.", android.telecom.Call.EVENT_REQUEST_HANDOVER);
                mConnectionService.sendCallEvent(this, android.telecom.Call.EVENT_HANDOVER_FAILED, null);
                return;
            }
            Parcelable parcelable = extras.getParcelable(android.telecom.Call.EXTRA_HANDOVER_PHONE_ACCOUNT_HANDLE);
            if (!(parcelable instanceof PhoneAccountHandle) || parcelable == null) {
                Log.w(this, "sendCallEvent: %s event received with invalid handover acct.", android.telecom.Call.EVENT_REQUEST_HANDOVER);
                mConnectionService.sendCallEvent(this, android.telecom.Call.EVENT_HANDOVER_FAILED, null);
                return;
            }
            PhoneAccountHandle phoneAccountHandle = (PhoneAccountHandle) parcelable;
            int videoState = extras.getInt(android.telecom.Call.EXTRA_HANDOVER_VIDEO_STATE, VideoProfile.STATE_AUDIO_ONLY);
            Parcelable handoverExtras = extras.getParcelable(android.telecom.Call.EXTRA_HANDOVER_EXTRAS);
            Bundle handoverExtrasBundle = null;
            if (handoverExtras instanceof Bundle) {
                handoverExtrasBundle = (Bundle) handoverExtras;
            }
            requestHandover(phoneAccountHandle, videoState, handoverExtrasBundle, true);
        } else {
            Log.addEvent(this, LogUtils.Events.CALL_EVENT, event);
            mConnectionService.sendCallEvent(this, event, extras);
        }
    } else {
        Log.e(this, new NullPointerException(), "sendCallEvent failed due to null CS callId=%s", getId());
    }
}
#method_after
public void sendCallEvent(String event, Bundle extras) {
    sendCallEvent(event, 0, /*For Event != EVENT_REQUEST_HANDOVER*/
    extras);
}
#end_block

#method_before
public void sendCallEvent(String event, Bundle extras) {
    if (mConnectionService != null) {
        if (android.telecom.Call.EVENT_REQUEST_HANDOVER.equals(event)) {
            // Handover requests are targeted at Telecom, not the ConnectionService.
            if (extras == null) {
                Log.w(this, "sendCallEvent: %s event received with null extras.", android.telecom.Call.EVENT_REQUEST_HANDOVER);
                mConnectionService.sendCallEvent(this, android.telecom.Call.EVENT_HANDOVER_FAILED, null);
                return;
            }
            Parcelable parcelable = extras.getParcelable(android.telecom.Call.EXTRA_HANDOVER_PHONE_ACCOUNT_HANDLE);
            if (!(parcelable instanceof PhoneAccountHandle) || parcelable == null) {
                Log.w(this, "sendCallEvent: %s event received with invalid handover acct.", android.telecom.Call.EVENT_REQUEST_HANDOVER);
                mConnectionService.sendCallEvent(this, android.telecom.Call.EVENT_HANDOVER_FAILED, null);
                return;
            }
            PhoneAccountHandle phoneAccountHandle = (PhoneAccountHandle) parcelable;
            int videoState = extras.getInt(android.telecom.Call.EXTRA_HANDOVER_VIDEO_STATE, VideoProfile.STATE_AUDIO_ONLY);
            Parcelable handoverExtras = extras.getParcelable(android.telecom.Call.EXTRA_HANDOVER_EXTRAS);
            Bundle handoverExtrasBundle = null;
            if (handoverExtras instanceof Bundle) {
                handoverExtrasBundle = (Bundle) handoverExtras;
            }
            requestHandover(phoneAccountHandle, videoState, handoverExtrasBundle, true);
        } else {
            Log.addEvent(this, LogUtils.Events.CALL_EVENT, event);
            mConnectionService.sendCallEvent(this, event, extras);
        }
    } else {
        Log.e(this, new NullPointerException(), "sendCallEvent failed due to null CS callId=%s", getId());
    }
}
#method_after
public void sendCallEvent(String event, int targetSdkVer, Bundle extras) {
    if (mConnectionService != null) {
        if (android.telecom.Call.EVENT_REQUEST_HANDOVER.equals(event)) {
            if (targetSdkVer > Build.VERSION_CODES.O_MR1) {
                Log.e(this, new Exception(), "sendCallEvent failed. Use public api handoverTo" + " for API > 27(O-MR1)");
            // TODO: Add "return" after DUO team adds new API support for handover
            }
            // Handover requests are targeted at Telecom, not the ConnectionService.
            if (extras == null) {
                Log.w(this, "sendCallEvent: %s event received with null extras.", android.telecom.Call.EVENT_REQUEST_HANDOVER);
                mConnectionService.sendCallEvent(this, android.telecom.Call.EVENT_HANDOVER_FAILED, null);
                return;
            }
            Parcelable parcelable = extras.getParcelable(android.telecom.Call.EXTRA_HANDOVER_PHONE_ACCOUNT_HANDLE);
            if (!(parcelable instanceof PhoneAccountHandle) || parcelable == null) {
                Log.w(this, "sendCallEvent: %s event received with invalid handover acct.", android.telecom.Call.EVENT_REQUEST_HANDOVER);
                mConnectionService.sendCallEvent(this, android.telecom.Call.EVENT_HANDOVER_FAILED, null);
                return;
            }
            PhoneAccountHandle phoneAccountHandle = (PhoneAccountHandle) parcelable;
            int videoState = extras.getInt(android.telecom.Call.EXTRA_HANDOVER_VIDEO_STATE, VideoProfile.STATE_AUDIO_ONLY);
            Parcelable handoverExtras = extras.getParcelable(android.telecom.Call.EXTRA_HANDOVER_EXTRAS);
            Bundle handoverExtrasBundle = null;
            if (handoverExtras instanceof Bundle) {
                handoverExtrasBundle = (Bundle) handoverExtras;
            }
            requestHandover(phoneAccountHandle, videoState, handoverExtrasBundle, true);
        } else {
            Log.addEvent(this, LogUtils.Events.CALL_EVENT, event);
            mConnectionService.sendCallEvent(this, event, extras);
        }
    } else {
        Log.e(this, new NullPointerException(), "sendCallEvent failed due to null CS callId=%s", getId());
    }
}
#end_block

#method_before
public void onHandoverFailed(int handoverError) {
    for (Listener l : mListeners) {
        l.onHandoverFailed(this, handoverError);
    }
}
#method_after
public void onHandoverFailed(int handoverError) {
    Log.i(this, "onHandoverFailed; callId=%s, handoverError=%d", getId(), handoverError);
    for (Listener l : mListeners) {
        l.onHandoverFailed(this, handoverError);
    }
}
#end_block

#method_before
public static void initLogging(Context context) {
    android.telecom.Log.setTag(TAG);
    android.telecom.Log.setSessionContext(context);
    android.telecom.Log.initMd5Sum();
    for (EventManager.TimedEventPair p : Events.Timings.sTimedEvents) {
        android.telecom.Log.addRequestResponsePair(p);
    }
    android.telecom.Log.registerEventListener(LogUtils::eventRecordAdded);
    // Store analytics about recently completed Sessions.
    android.telecom.Log.registerSessionListener(Analytics::addSessionTiming);
}
#method_after
public static void initLogging(Context context) {
    android.telecom.Log.setTag(TAG);
    android.telecom.Log.setSessionContext(context);
    for (EventManager.TimedEventPair p : Events.Timings.sTimedEvents) {
        android.telecom.Log.addRequestResponsePair(p);
    }
    android.telecom.Log.registerEventListener(LogUtils::eventRecordAdded);
    // Store analytics about recently completed Sessions.
    android.telecom.Log.registerSessionListener(Analytics::addSessionTiming);
}
#end_block

#method_before
@Override
public void deflect(String callId, String number, Session.Info info) throws RemoteException {
}
#method_after
@Override
public void deflect(String callId, Uri address, Session.Info info) throws RemoteException {
}
#end_block

#method_before
boolean hasOnlyDisconnectedCalls() {
    for (Call call : mCalls) {
        if (!call.isDisconnected()) {
            return false;
        }
    }
    return true;
}
#method_after
@VisibleForTesting
public boolean hasOnlyDisconnectedCalls() {
    if (mCalls.size() == 0) {
        return false;
    }
    for (Call call : mCalls) {
        if (!call.isDisconnected()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
void processIncomingCallIntent(PhoneAccountHandle phoneAccountHandle, Bundle extras) {
    Log.d(this, "processIncomingCallIntent");
    boolean isHandover = extras.getBoolean(TelecomManager.EXTRA_IS_HANDOVER);
    Uri handle = extras.getParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS);
    if (handle == null) {
        // Required for backwards compatibility
        handle = extras.getParcelable(TelephonyManager.EXTRA_INCOMING_NUMBER);
    }
    Call call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, handle, null, /* gatewayInfo */
    null, /* connectionManagerPhoneAccount */
    phoneAccountHandle, Call.CALL_DIRECTION_INCOMING, /* callDirection */
    false, /* forceAttachToExistingConnection */
    false, /* isConference */
    mClockProxy);
    // Ensure new calls related to self-managed calls/connections are set as such.  This will
    // be overridden when the actual connection is returned in startCreateConnection, however
    // doing this now ensures the logs and any other logic will treat this call as self-managed
    // from the moment it is created.
    PhoneAccount phoneAccount = mPhoneAccountRegistrar.getPhoneAccountUnchecked(phoneAccountHandle);
    if (phoneAccount != null) {
        call.setIsSelfManaged(phoneAccount.isSelfManaged());
        if (call.isSelfManaged()) {
            // Self managed calls will always be voip audio mode.
            call.setIsVoipAudioMode(true);
        } else {
            // whether answering will cause a background self-managed call to drop.
            if (hasSelfManagedCalls()) {
                Bundle dropCallExtras = new Bundle();
                dropCallExtras.putBoolean(Connection.EXTRA_ANSWERING_DROPS_FG_CALL, true);
                // Include the name of the app which will drop the call.
                Call foregroundCall = getForegroundCall();
                if (foregroundCall != null) {
                    CharSequence droppedApp = foregroundCall.getTargetPhoneAccountLabel();
                    dropCallExtras.putCharSequence(Connection.EXTRA_ANSWERING_DROPS_FG_CALL_APP_NAME, droppedApp);
                    Log.i(this, "Incoming managed call will drop %s call.", droppedApp);
                }
                call.putExtras(Call.SOURCE_CONNECTION_SERVICE, dropCallExtras);
            }
        }
        if (extras.getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE)) {
            Log.d(this, "processIncomingCallIntent: defaulting to voip mode for call %s", call.getId());
            call.setIsVoipAudioMode(true);
        }
    }
    if (extras.getBoolean(TelecomManager.EXTRA_START_CALL_WITH_RTT, false)) {
        if (phoneAccount != null && phoneAccount.hasCapabilities(PhoneAccount.CAPABILITY_RTT)) {
            call.setRttStreams(true);
        }
    }
    // If the extras specifies a video state, set it on the call if the PhoneAccount supports
    // video.
    int videoState = VideoProfile.STATE_AUDIO_ONLY;
    if (extras.containsKey(TelecomManager.EXTRA_INCOMING_VIDEO_STATE) && phoneAccount != null && phoneAccount.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
        videoState = extras.getInt(TelecomManager.EXTRA_INCOMING_VIDEO_STATE);
        call.setVideoState(videoState);
    }
    call.initAnalytics();
    if (getForegroundCall() != null) {
        getForegroundCall().getAnalytics().setCallIsInterrupted(true);
        call.getAnalytics().setCallIsAdditional(true);
    }
    setIntentExtrasAndStartTime(call, extras);
    // TODO: Move this to be a part of addCall()
    call.addListener(this);
    boolean isHandoverAllowed = true;
    if (isHandover) {
        if (!isHandoverInProgress() && isHandoverToPhoneAccountSupported(phoneAccountHandle)) {
            final String handleScheme = handle.getSchemeSpecificPart();
            Call fromCall = mCalls.stream().filter((c) -> mPhoneNumberUtilsAdapter.isSamePhoneNumber(c.getHandle().getSchemeSpecificPart(), handleScheme)).findFirst().orElse(null);
            if (fromCall != null) {
                if (!isHandoverFromPhoneAccountSupported(fromCall.getTargetPhoneAccount())) {
                    Log.w(this, "processIncomingCallIntent: From account doesn't support " + "handover.");
                    isHandoverAllowed = false;
                }
            } else {
                Log.w(this, "processIncomingCallIntent: handover fail; can't find from call.");
                isHandoverAllowed = false;
            }
            if (isHandoverAllowed) {
                // Link the calls so we know we're handing over.
                fromCall.setHandoverDestinationCall(call);
                call.setHandoverSourceCall(fromCall);
                call.setHandoverState(HandoverState.HANDOVER_TO_STARTED);
                fromCall.setHandoverState(HandoverState.HANDOVER_FROM_STARTED);
                Log.addEvent(fromCall, LogUtils.Events.START_HANDOVER, "handOverFrom=%s, handOverTo=%s", fromCall.getId(), call.getId());
                Log.addEvent(call, LogUtils.Events.START_HANDOVER, "handOverFrom=%s, handOverTo=%s", fromCall.getId(), call.getId());
                if (isSpeakerEnabledForVideoCalls() && VideoProfile.isVideo(videoState)) {
                    // Ensure when the call goes active that it will go to speakerphone if the
                    // handover to call is a video call.
                    call.setStartWithSpeakerphoneOn(true);
                }
            }
        } else {
            Log.w(this, "processIncomingCallIntent: To account doesn't support handover.");
        }
    }
    if (!isHandoverAllowed || (call.isSelfManaged() && !isIncomingCallPermitted(call, call.getTargetPhoneAccount()))) {
        notifyCreateConnectionFailed(phoneAccountHandle, call);
    } else {
        call.startCreateConnection(mPhoneAccountRegistrar);
    }
}
#method_after
void processIncomingCallIntent(PhoneAccountHandle phoneAccountHandle, Bundle extras) {
    Log.d(this, "processIncomingCallIntent");
    boolean isHandover = extras.getBoolean(TelecomManager.EXTRA_IS_HANDOVER);
    Uri handle = extras.getParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS);
    if (handle == null) {
        // Required for backwards compatibility
        handle = extras.getParcelable(TelephonyManager.EXTRA_INCOMING_NUMBER);
    }
    Call call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, handle, null, /* gatewayInfo */
    null, /* connectionManagerPhoneAccount */
    phoneAccountHandle, Call.CALL_DIRECTION_INCOMING, /* callDirection */
    false, /* forceAttachToExistingConnection */
    false, /* isConference */
    mClockProxy);
    // Ensure new calls related to self-managed calls/connections are set as such.  This will
    // be overridden when the actual connection is returned in startCreateConnection, however
    // doing this now ensures the logs and any other logic will treat this call as self-managed
    // from the moment it is created.
    PhoneAccount phoneAccount = mPhoneAccountRegistrar.getPhoneAccountUnchecked(phoneAccountHandle);
    if (phoneAccount != null) {
        call.setIsSelfManaged(phoneAccount.isSelfManaged());
        if (call.isSelfManaged()) {
            // Self managed calls will always be voip audio mode.
            call.setIsVoipAudioMode(true);
        } else {
            // Incoming call is managed, the active call is self-managed and can't be held.
            // We need to set extras on it to indicate whether answering will cause a
            // active self-managed call to drop.
            Call activeCall = (Call) mConnectionSvrFocusMgr.getCurrentFocusCall();
            if (activeCall != null && !canHold(activeCall) && activeCall.isSelfManaged()) {
                Bundle dropCallExtras = new Bundle();
                dropCallExtras.putBoolean(Connection.EXTRA_ANSWERING_DROPS_FG_CALL, true);
                // Include the name of the app which will drop the call.
                CharSequence droppedApp = activeCall.getTargetPhoneAccountLabel();
                dropCallExtras.putCharSequence(Connection.EXTRA_ANSWERING_DROPS_FG_CALL_APP_NAME, droppedApp);
                Log.i(this, "Incoming managed call will drop %s call.", droppedApp);
                call.putExtras(Call.SOURCE_CONNECTION_SERVICE, dropCallExtras);
            }
        }
        if (extras.getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE)) {
            Log.d(this, "processIncomingCallIntent: defaulting to voip mode for call %s", call.getId());
            call.setIsVoipAudioMode(true);
        }
    }
    if (extras.getBoolean(TelecomManager.EXTRA_START_CALL_WITH_RTT, false)) {
        if (phoneAccount != null && phoneAccount.hasCapabilities(PhoneAccount.CAPABILITY_RTT)) {
            call.setRttStreams(true);
        }
    }
    // If the extras specifies a video state, set it on the call if the PhoneAccount supports
    // video.
    int videoState = VideoProfile.STATE_AUDIO_ONLY;
    if (extras.containsKey(TelecomManager.EXTRA_INCOMING_VIDEO_STATE) && phoneAccount != null && phoneAccount.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
        videoState = extras.getInt(TelecomManager.EXTRA_INCOMING_VIDEO_STATE);
        call.setVideoState(videoState);
    }
    call.initAnalytics();
    if (getForegroundCall() != null) {
        getForegroundCall().getAnalytics().setCallIsInterrupted(true);
        call.getAnalytics().setCallIsAdditional(true);
    }
    setIntentExtrasAndStartTime(call, extras);
    // TODO: Move this to be a part of addCall()
    call.addListener(this);
    boolean isHandoverAllowed = true;
    if (isHandover) {
        if (!isHandoverInProgress() && isHandoverToPhoneAccountSupported(phoneAccountHandle)) {
            final String handleScheme = handle.getSchemeSpecificPart();
            Call fromCall = mCalls.stream().filter((c) -> mPhoneNumberUtilsAdapter.isSamePhoneNumber(c.getHandle().getSchemeSpecificPart(), handleScheme)).findFirst().orElse(null);
            if (fromCall != null) {
                if (!isHandoverFromPhoneAccountSupported(fromCall.getTargetPhoneAccount())) {
                    Log.w(this, "processIncomingCallIntent: From account doesn't support " + "handover.");
                    isHandoverAllowed = false;
                }
            } else {
                Log.w(this, "processIncomingCallIntent: handover fail; can't find from call.");
                isHandoverAllowed = false;
            }
            if (isHandoverAllowed) {
                // Link the calls so we know we're handing over.
                fromCall.setHandoverDestinationCall(call);
                call.setHandoverSourceCall(fromCall);
                call.setHandoverState(HandoverState.HANDOVER_TO_STARTED);
                fromCall.setHandoverState(HandoverState.HANDOVER_FROM_STARTED);
                Log.addEvent(fromCall, LogUtils.Events.START_HANDOVER, "handOverFrom=%s, handOverTo=%s", fromCall.getId(), call.getId());
                Log.addEvent(call, LogUtils.Events.START_HANDOVER, "handOverFrom=%s, handOverTo=%s", fromCall.getId(), call.getId());
                if (isSpeakerEnabledForVideoCalls() && VideoProfile.isVideo(videoState)) {
                    // Ensure when the call goes active that it will go to speakerphone if the
                    // handover to call is a video call.
                    call.setStartWithSpeakerphoneOn(true);
                }
            }
        } else {
            Log.w(this, "processIncomingCallIntent: To account doesn't support handover.");
        }
    }
    if (!isHandoverAllowed || (call.isSelfManaged() && !isIncomingCallPermitted(call, call.getTargetPhoneAccount()))) {
        notifyCreateConnectionFailed(phoneAccountHandle, call);
    } else {
        call.startCreateConnection(mPhoneAccountRegistrar);
    }
}
#end_block

#method_before
Call startOutgoingCall(Uri handle, PhoneAccountHandle phoneAccountHandle, Bundle extras, UserHandle initiatingUser, Intent originalIntent) {
    boolean isReusedCall = true;
    Call call = reuseOutgoingCall(handle);
    PhoneAccount account = mPhoneAccountRegistrar.getPhoneAccount(phoneAccountHandle, initiatingUser);
    boolean isSelfManaged = account != null && account.isSelfManaged();
    // to a connection service, but in most cases will remain the same.
    if (call == null) {
        call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, handle, null, /* gatewayInfo */
        null, /* connectionManagerPhoneAccount */
        null, /* phoneAccountHandle */
        Call.CALL_DIRECTION_OUTGOING, /* callDirection */
        false, /* forceAttachToExistingConnection */
        false, /* isConference */
        mClockProxy);
        call.initAnalytics();
        // Ensure new calls related to self-managed calls/connections are set as such.  This
        // will be overridden when the actual connection is returned in startCreateConnection,
        // however doing this now ensures the logs and any other logic will treat this call as
        // self-managed from the moment it is created.
        call.setIsSelfManaged(isSelfManaged);
        if (isSelfManaged) {
            // Self-managed calls will ALWAYS use voip audio mode.
            call.setIsVoipAudioMode(true);
        }
        call.setInitiatingUser(initiatingUser);
        isReusedCall = false;
    }
    int videoState = VideoProfile.STATE_AUDIO_ONLY;
    if (extras != null) {
        // Set the video state on the call early so that when it is added to the InCall UI the
        // UI knows to configure itself as a video call immediately.
        videoState = extras.getInt(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE, VideoProfile.STATE_AUDIO_ONLY);
        // supported.
        if (VideoProfile.isVideo(videoState)) {
            if (call.isEmergencyCall() && account != null && !account.hasCapabilities(PhoneAccount.CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
                // Phone account doesn't support emergency video calling, so fallback to
                // audio-only now to prevent the InCall UI from setting up video surfaces
                // needlessly.
                Log.i(this, "startOutgoingCall - emergency video calls not supported; " + "falling back to audio-only");
                videoState = VideoProfile.STATE_AUDIO_ONLY;
            } else if (account != null && !account.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
                // Phone account doesn't support video calling, so fallback to audio-only.
                Log.i(this, "startOutgoingCall - video calls not supported; fallback to " + "audio-only.");
                videoState = VideoProfile.STATE_AUDIO_ONLY;
            }
        }
        call.setVideoState(videoState);
    }
    List<PhoneAccountHandle> potentialPhoneAccounts = findOutgoingCallPhoneAccount(phoneAccountHandle, handle, VideoProfile.isVideo(videoState), initiatingUser);
    if (potentialPhoneAccounts.size() == 1) {
        phoneAccountHandle = potentialPhoneAccounts.get(0);
    } else {
        phoneAccountHandle = null;
    }
    call.setTargetPhoneAccount(phoneAccountHandle);
    boolean isPotentialInCallMMICode = isPotentialInCallMMICode(handle) && !isSelfManaged;
    // call transitioning into the CONNECTING state.
    if (!isSelfManaged && !isPotentialInCallMMICode && (!isReusedCall && !makeRoomForOutgoingCall(call, call.isEmergencyCall()))) {
        // just cancel at this point.
        Log.i(this, "No remaining room for outgoing call: %s", call);
        if (mCalls.contains(call)) {
            // This call can already exist if it is a reused call,
            // See {@link #reuseOutgoingCall}.
            call.disconnect();
        }
        return null;
    }
    boolean needsAccountSelection = phoneAccountHandle == null && potentialPhoneAccounts.size() > 1 && !call.isEmergencyCall() && !isSelfManaged;
    if (needsAccountSelection) {
        // This is the state where the user is expected to select an account
        call.setState(CallState.SELECT_PHONE_ACCOUNT, "needs account selection");
        // Create our own instance to modify (since extras may be Bundle.EMPTY)
        extras = new Bundle(extras);
        extras.putParcelableList(android.telecom.Call.AVAILABLE_PHONE_ACCOUNTS, potentialPhoneAccounts);
    } else {
        PhoneAccount accountToUse = mPhoneAccountRegistrar.getPhoneAccount(phoneAccountHandle, initiatingUser);
        if (accountToUse != null && accountToUse.getExtras() != null) {
            if (accountToUse.getExtras().getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE)) {
                Log.d(this, "startOutgoingCall: defaulting to voip mode for call %s", call.getId());
                call.setIsVoipAudioMode(true);
            }
        }
        call.setState(CallState.CONNECTING, phoneAccountHandle == null ? "no-handle" : phoneAccountHandle.toString());
        if (extras != null && extras.getBoolean(TelecomManager.EXTRA_START_CALL_WITH_RTT, false)) {
            if (accountToUse != null && accountToUse.hasCapabilities(PhoneAccount.CAPABILITY_RTT)) {
                call.setRttStreams(true);
            }
        }
    }
    setIntentExtrasAndStartTime(call, extras);
    if ((isPotentialMMICode(handle) || isPotentialInCallMMICode) && !needsAccountSelection) {
        // Do not add the call if it is a potential MMI code.
        call.addListener(this);
    } else if (!isSelfManaged && hasSelfManagedCalls() && !call.isEmergencyCall()) {
        // Adding a managed call and there are ongoing self-managed call(s).
        call.setOriginalCallIntent(originalIntent);
        startCallConfirmation(call);
        return null;
    } else if (!mCalls.contains(call)) {
        // We check if mCalls already contains the call because we could potentially be reusing
        // a call which was previously added (See {@link #reuseOutgoingCall}).
        addCall(call);
    }
    return call;
}
#method_after
@VisibleForTesting
public Call startOutgoingCall(Uri handle, PhoneAccountHandle phoneAccountHandle, Bundle extras, UserHandle initiatingUser, Intent originalIntent) {
    boolean isReusedCall = true;
    Call call = reuseOutgoingCall(handle);
    PhoneAccount account = mPhoneAccountRegistrar.getPhoneAccount(phoneAccountHandle, initiatingUser);
    boolean isSelfManaged = account != null && account.isSelfManaged();
    // to a connection service, but in most cases will remain the same.
    if (call == null) {
        call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, handle, null, /* gatewayInfo */
        null, /* connectionManagerPhoneAccount */
        null, /* phoneAccountHandle */
        Call.CALL_DIRECTION_OUTGOING, /* callDirection */
        false, /* forceAttachToExistingConnection */
        false, /* isConference */
        mClockProxy);
        call.initAnalytics();
        // Ensure new calls related to self-managed calls/connections are set as such.  This
        // will be overridden when the actual connection is returned in startCreateConnection,
        // however doing this now ensures the logs and any other logic will treat this call as
        // self-managed from the moment it is created.
        call.setIsSelfManaged(isSelfManaged);
        if (isSelfManaged) {
            // Self-managed calls will ALWAYS use voip audio mode.
            call.setIsVoipAudioMode(true);
        }
        call.setInitiatingUser(initiatingUser);
        isReusedCall = false;
    }
    int videoState = VideoProfile.STATE_AUDIO_ONLY;
    if (extras != null) {
        // Set the video state on the call early so that when it is added to the InCall UI the
        // UI knows to configure itself as a video call immediately.
        videoState = extras.getInt(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE, VideoProfile.STATE_AUDIO_ONLY);
        // supported.
        if (VideoProfile.isVideo(videoState)) {
            if (call.isEmergencyCall() && account != null && !account.hasCapabilities(PhoneAccount.CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
                // Phone account doesn't support emergency video calling, so fallback to
                // audio-only now to prevent the InCall UI from setting up video surfaces
                // needlessly.
                Log.i(this, "startOutgoingCall - emergency video calls not supported; " + "falling back to audio-only");
                videoState = VideoProfile.STATE_AUDIO_ONLY;
            } else if (account != null && !account.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
                // Phone account doesn't support video calling, so fallback to audio-only.
                Log.i(this, "startOutgoingCall - video calls not supported; fallback to " + "audio-only.");
                videoState = VideoProfile.STATE_AUDIO_ONLY;
            }
        }
        call.setVideoState(videoState);
    }
    List<PhoneAccountHandle> potentialPhoneAccounts = findOutgoingCallPhoneAccount(phoneAccountHandle, handle, VideoProfile.isVideo(videoState), initiatingUser);
    if (potentialPhoneAccounts.size() == 1) {
        phoneAccountHandle = potentialPhoneAccounts.get(0);
    } else {
        phoneAccountHandle = null;
    }
    call.setTargetPhoneAccount(phoneAccountHandle);
    boolean isPotentialInCallMMICode = isPotentialInCallMMICode(handle) && !isSelfManaged;
    // call transitioning into the CONNECTING state.
    if (!isPotentialInCallMMICode && (!isReusedCall && !makeRoomForOutgoingCall(call, call.isEmergencyCall()))) {
        Call foregroundCall = getForegroundCall();
        Log.d(this, "No more room for outgoing call %s ", call);
        if (foregroundCall.isSelfManaged()) {
            // If the ongoing call is a self-managed call, then prompt the user to ask if they'd
            // like to disconnect their ongoing call and place the outgoing call.
            call.setOriginalCallIntent(originalIntent);
            startCallConfirmation(call);
        } else {
            // If the ongoing call is a managed call, we will prevent the outgoing call from
            // dialing.
            notifyCreateConnectionFailed(call.getTargetPhoneAccount(), call);
        }
        return null;
    }
    // The outgoing call can be placed, go forward.
    boolean needsAccountSelection = phoneAccountHandle == null && potentialPhoneAccounts.size() > 1 && !call.isEmergencyCall() && !isSelfManaged;
    if (needsAccountSelection) {
        // This is the state where the user is expected to select an account
        call.setState(CallState.SELECT_PHONE_ACCOUNT, "needs account selection");
        // Create our own instance to modify (since extras may be Bundle.EMPTY)
        extras = new Bundle(extras);
        extras.putParcelableList(android.telecom.Call.AVAILABLE_PHONE_ACCOUNTS, potentialPhoneAccounts);
    } else {
        PhoneAccount accountToUse = mPhoneAccountRegistrar.getPhoneAccount(phoneAccountHandle, initiatingUser);
        if (accountToUse != null && accountToUse.getExtras() != null) {
            if (accountToUse.getExtras().getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE)) {
                Log.d(this, "startOutgoingCall: defaulting to voip mode for call %s", call.getId());
                call.setIsVoipAudioMode(true);
            }
        }
        call.setState(CallState.CONNECTING, phoneAccountHandle == null ? "no-handle" : phoneAccountHandle.toString());
        if (extras != null && extras.getBoolean(TelecomManager.EXTRA_START_CALL_WITH_RTT, false)) {
            if (accountToUse != null && accountToUse.hasCapabilities(PhoneAccount.CAPABILITY_RTT)) {
                call.setRttStreams(true);
            }
        }
    }
    setIntentExtrasAndStartTime(call, extras);
    if ((isPotentialMMICode(handle) || isPotentialInCallMMICode) && !needsAccountSelection) {
        // Do not add the call if it is a potential MMI code.
        call.addListener(this);
    } else if (!mCalls.contains(call)) {
        // We check if mCalls already contains the call because we could potentially be reusing
        // a call which was previously added (See {@link #reuseOutgoingCall}).
        addCall(call);
    }
    return call;
}
#end_block

#method_before
private boolean isSelfManaged(PhoneAccountHandle targetPhoneAccountHandle, UserHandle initiatingUser) {
    PhoneAccount targetPhoneAccount = mPhoneAccountRegistrar.getPhoneAccount(targetPhoneAccountHandle, initiatingUser);
    return targetPhoneAccount != null && targetPhoneAccount.isSelfManaged();
}
#method_after
public boolean isSelfManaged(PhoneAccountHandle targetPhoneAccountHandle, UserHandle initiatingUser) {
    PhoneAccount targetPhoneAccount = mPhoneAccountRegistrar.getPhoneAccount(targetPhoneAccountHandle, initiatingUser);
    return targetPhoneAccount != null && targetPhoneAccount.isSelfManaged();
}
#end_block

#method_before
@VisibleForTesting
public void placeOutgoingCall(Call call, Uri handle, GatewayInfo gatewayInfo, boolean speakerphoneOn, int videoState) {
    if (call == null) {
        // don't do anything if the call no longer exists
        Log.i(this, "Canceling unknown call.");
        return;
    }
    final Uri uriHandle = (gatewayInfo == null) ? handle : gatewayInfo.getGatewayAddress();
    if (gatewayInfo == null) {
        Log.i(this, "Creating a new outgoing call with handle: %s", Log.piiHandle(uriHandle));
    } else {
        Log.i(this, "Creating a new outgoing call with gateway handle: %s, original handle: %s", Log.pii(uriHandle), Log.pii(handle));
    }
    call.setHandle(uriHandle);
    call.setGatewayInfo(gatewayInfo);
    final boolean useSpeakerWhenDocked = mContext.getResources().getBoolean(R.bool.use_speaker_when_docked);
    final boolean useSpeakerForDock = isSpeakerphoneEnabledForDock();
    final boolean useSpeakerForVideoCall = isSpeakerphoneAutoEnabledForVideoCalls(videoState);
    // Auto-enable speakerphone if the originating intent specified to do so, if the call
    // is a video call, of if using speaker when docked
    call.setStartWithSpeakerphoneOn(speakerphoneOn || useSpeakerForVideoCall || (useSpeakerWhenDocked && useSpeakerForDock));
    call.setVideoState(videoState);
    if (speakerphoneOn) {
        Log.i(this, "%s Starting with speakerphone as requested", call);
    } else if (useSpeakerWhenDocked && useSpeakerForDock) {
        Log.i(this, "%s Starting with speakerphone because car is docked.", call);
    } else if (useSpeakerForVideoCall) {
        Log.i(this, "%s Starting with speakerphone because its a video call.", call);
    }
    if (call.isEmergencyCall()) {
        new AsyncEmergencyContactNotifier(mContext).execute();
    }
    final boolean requireCallCapableAccountByHandle = mContext.getResources().getBoolean(com.android.internal.R.bool.config_requireCallCapableAccountForHandle);
    final boolean isOutgoingCallPermitted = isOutgoingCallPermitted(call, call.getTargetPhoneAccount());
    if (call.getTargetPhoneAccount() != null || call.isEmergencyCall()) {
        // Otherwise the connection will be initiated when the account is set by the user.
        if (call.isSelfManaged() && !isOutgoingCallPermitted) {
            notifyCreateConnectionFailed(call.getTargetPhoneAccount(), call);
        } else if (!call.isSelfManaged() && hasSelfManagedCalls() && !call.isEmergencyCall()) {
            markCallDisconnectedDueToSelfManagedCall(call);
        } else {
            if (call.isEmergencyCall()) {
                // Disconnect all self-managed calls to make priority for emergency call.
                disconnectSelfManagedCalls();
            }
            call.startCreateConnection(mPhoneAccountRegistrar);
        }
    } else if (mPhoneAccountRegistrar.getCallCapablePhoneAccounts(requireCallCapableAccountByHandle ? call.getHandle().getScheme() : null, false, call.getInitiatingUser()).isEmpty()) {
        // If there are no call capable accounts, disconnect the call.
        markCallAsDisconnected(call, new DisconnectCause(DisconnectCause.CANCELED, "No registered PhoneAccounts"));
        markCallAsRemoved(call);
    }
}
#method_after
@VisibleForTesting
public void placeOutgoingCall(Call call, Uri handle, GatewayInfo gatewayInfo, boolean speakerphoneOn, int videoState) {
    if (call == null) {
        // don't do anything if the call no longer exists
        Log.i(this, "Canceling unknown call.");
        return;
    }
    final Uri uriHandle = (gatewayInfo == null) ? handle : gatewayInfo.getGatewayAddress();
    if (gatewayInfo == null) {
        Log.i(this, "Creating a new outgoing call with handle: %s", Log.piiHandle(uriHandle));
    } else {
        Log.i(this, "Creating a new outgoing call with gateway handle: %s, original handle: %s", Log.pii(uriHandle), Log.pii(handle));
    }
    call.setHandle(uriHandle);
    call.setGatewayInfo(gatewayInfo);
    final boolean useSpeakerWhenDocked = mContext.getResources().getBoolean(R.bool.use_speaker_when_docked);
    final boolean useSpeakerForDock = isSpeakerphoneEnabledForDock();
    final boolean useSpeakerForVideoCall = isSpeakerphoneAutoEnabledForVideoCalls(videoState);
    // Auto-enable speakerphone if the originating intent specified to do so, if the call
    // is a video call, of if using speaker when docked
    call.setStartWithSpeakerphoneOn(speakerphoneOn || useSpeakerForVideoCall || (useSpeakerWhenDocked && useSpeakerForDock));
    call.setVideoState(videoState);
    if (speakerphoneOn) {
        Log.i(this, "%s Starting with speakerphone as requested", call);
    } else if (useSpeakerWhenDocked && useSpeakerForDock) {
        Log.i(this, "%s Starting with speakerphone because car is docked.", call);
    } else if (useSpeakerForVideoCall) {
        Log.i(this, "%s Starting with speakerphone because its a video call.", call);
    }
    if (call.isEmergencyCall()) {
        new AsyncEmergencyContactNotifier(mContext).execute();
    }
    final boolean requireCallCapableAccountByHandle = mContext.getResources().getBoolean(com.android.internal.R.bool.config_requireCallCapableAccountForHandle);
    final boolean isOutgoingCallPermitted = isOutgoingCallPermitted(call, call.getTargetPhoneAccount());
    if (call.getTargetPhoneAccount() != null || call.isEmergencyCall()) {
        // Otherwise the connection will be initiated when the account is set by the user.
        if (call.isSelfManaged() && !isOutgoingCallPermitted) {
            notifyCreateConnectionFailed(call.getTargetPhoneAccount(), call);
        } else {
            if (call.isEmergencyCall()) {
                // Disconnect calls from other ConnectionServices other than the one the
                // emergency call targets.
                // Except, do not disconnect calls from the Connection Manager's
                // ConnectionService.
                disconnectCallsHaveDifferentConnectionService(call);
            }
            call.startCreateConnection(mPhoneAccountRegistrar);
        }
    } else if (mPhoneAccountRegistrar.getCallCapablePhoneAccounts(requireCallCapableAccountByHandle ? call.getHandle().getScheme() : null, false, call.getInitiatingUser()).isEmpty()) {
        // If there are no call capable accounts, disconnect the call.
        markCallAsDisconnected(call, new DisconnectCause(DisconnectCause.CANCELED, "No registered PhoneAccounts"));
        markCallAsRemoved(call);
    }
}
#end_block

#method_before
@VisibleForTesting
public void answerCall(Call call, int videoState) {
    if (!mCalls.contains(call)) {
        Log.i(this, "Request to answer a non-existent call %s", call);
    } else {
        Call foregroundCall = getForegroundCall();
        // STATE_DIALING, put it on hold before answering the call.
        if (foregroundCall != null && foregroundCall != call && (foregroundCall.isActive() || foregroundCall.getState() == CallState.DIALING || foregroundCall.getState() == CallState.PULLING)) {
            if (!foregroundCall.getTargetPhoneAccount().equals(call.getTargetPhoneAccount()) && ((call.isSelfManaged() != foregroundCall.isSelfManaged()) || call.isSelfManaged())) {
                // The foreground call is from another connection service, and either:
                // 1. FG call's managed state doesn't match that of the incoming call.
                // E.g. Incoming is self-managed and FG is managed, or incoming is managed
                // and foreground is self-managed.
                // 2. The incoming call is self-managed.
                // E.g. The incoming call is
                Log.i(this, "Answering call from %s CS; disconnecting calls from %s CS.", foregroundCall.isSelfManaged() ? "selfMg" : "mg", call.isSelfManaged() ? "selfMg" : "mg");
                disconnectOtherCalls(call.getTargetPhoneAccount());
            } else if (0 == (foregroundCall.getConnectionCapabilities() & Connection.CAPABILITY_HOLD)) {
                // figure out the right states.
                if (foregroundCall.getConnectionService() != call.getConnectionService()) {
                    foregroundCall.disconnect();
                }
            } else {
                Call heldCall = getHeldCall();
                if (heldCall != null) {
                    Log.i(this, "Disconnecting held call %s before holding active call.", heldCall);
                    heldCall.disconnect();
                }
                foregroundCall.hold();
            }
        // TODO: Wait until we get confirmation of the active call being
        // on-hold before answering the new call.
        // TODO: Import logic from CallManager.acceptCall()
        }
        for (CallsManagerListener listener : mListeners) {
            listener.onIncomingCallAnswered(call);
        }
        // We do not update the UI until we get confirmation of the answer() through
        // {@link #markCallAsActive}.
        call.answer(videoState);
        if (isSpeakerphoneAutoEnabledForVideoCalls(videoState)) {
            call.setStartWithSpeakerphoneOn(true);
        }
    }
}
#method_after
@VisibleForTesting
public void answerCall(Call call, int videoState) {
    if (!mCalls.contains(call)) {
        Log.i(this, "Request to answer a non-existent call %s", call);
    } else {
        // Hold or disconnect the active call and request call focus for the incoming call.
        Call activeCall = (Call) mConnectionSvrFocusMgr.getCurrentFocusCall();
        Log.d(this, "Incoming call = %s Ongoing call %s", call, activeCall);
        if (activeCall != null && activeCall != call) {
            // Hold the telephony call even if it doesn't have the hold capability.
            if (canHold(activeCall)) {
                Log.d(this, "Answer %s, hold %s", call, activeCall);
                activeCall.hold();
            } else {
                // figure out the right states.
                if (activeCall.getConnectionService() != call.getConnectionService()) {
                    activeCall.disconnect();
                }
            }
        }
        mConnectionSvrFocusMgr.requestFocus(call, new RequestCallback(new ActionAnswerCall(call, videoState)));
    }
}
#end_block

#method_before
@VisibleForTesting
public void deflectCall(Call call, String number) {
    if (!mCalls.contains(call)) {
        Log.i(this, "Request to deflect a non-existent call %s", call);
    } else {
        call.deflect(number);
    }
}
#method_after
@VisibleForTesting
public void deflectCall(Call call, Uri address) {
    if (!mCalls.contains(call)) {
        Log.i(this, "Request to deflect a non-existent call %s", call);
    } else {
        call.deflect(address);
    }
}
#end_block

#method_before
@VisibleForTesting
public void unholdCall(Call call) {
    if (!mCalls.contains(call)) {
        Log.w(this, "Unknown call (%s) asked to be removed from hold", call);
    } else {
        boolean otherCallHeld = false;
        Log.d(this, "unholding call: (%s)", call);
        for (Call c : mCalls) {
            // Only attempt to hold parent calls and not the individual children.
            if (c != null && c.isAlive() && c != call && c.getParentCall() == null) {
                otherCallHeld = true;
                Log.addEvent(c, LogUtils.Events.SWAP);
                c.hold();
            }
        }
        if (otherCallHeld) {
            Log.addEvent(call, LogUtils.Events.SWAP);
        }
        call.unhold();
    }
}
#method_after
@VisibleForTesting
public void unholdCall(Call call) {
    if (!mCalls.contains(call)) {
        Log.w(this, "Unknown call (%s) asked to be removed from hold", call);
    } else {
        Call activeCall = (Call) mConnectionSvrFocusMgr.getCurrentFocusCall();
        if (activeCall != null) {
            if (canHold(activeCall)) {
                activeCall.hold();
                Log.addEvent(activeCall, LogUtils.Events.SWAP);
                Log.addEvent(call, LogUtils.Events.SWAP);
            } else {
                // connection service to handle the situation.
                if (activeCall.getConnectionService() != call.getConnectionService()) {
                    activeCall.disconnect();
                } else {
                    activeCall.hold();
                }
            }
        }
        mConnectionSvrFocusMgr.requestFocus(call, new RequestCallback(new ActionUnHoldCall(call)));
    }
}
#end_block

#method_before
void markCallAsActive(Call call) {
    setCallState(call, CallState.ACTIVE, "active set explicitly");
    maybeMoveToSpeakerPhone(call);
}
#method_after
void markCallAsActive(Call call) {
    if (call.isSelfManaged()) {
        // backward compatibility, the self-managed connection service will set the call state
        // to active directly. We should request the call focus for self-managed call before
        // the state change
        mConnectionSvrFocusMgr.requestFocus(call, new RequestCallback(new ActionSetCallState(call, CallState.ACTIVE, "active set explicitly for self-managed")));
    } else {
        setCallState(call, CallState.ACTIVE, "active set explicitly");
        maybeMoveToSpeakerPhone(call);
    }
}
#end_block

#method_before
private void completeHandoverFrom(Call call) {
    Call handoverTo = call.getHandoverDestinationCall();
    Log.addEvent(handoverTo, LogUtils.Events.HANDOVER_COMPLETE, "from=%s, to=%s", call.getId(), handoverTo.getId());
    Log.addEvent(call, LogUtils.Events.HANDOVER_COMPLETE, "from=%s, to=%s", call.getId(), handoverTo.getId());
    // Inform the "from" Call (ie the source call) that the handover from it has
    // completed; this allows the InCallService to be notified that a handover it
    // initiated completed.
    call.onConnectionEvent(Connection.EVENT_HANDOVER_COMPLETE, null);
    // Inform the "to" ConnectionService that handover to it has completed.
    handoverTo.sendCallEvent(android.telecom.Call.EVENT_HANDOVER_COMPLETE, null);
    answerCall(handoverTo, handoverTo.getVideoState());
    call.markFinishedHandoverStateAndCleanup(HandoverState.HANDOVER_COMPLETE);
    // ConnectionServices.
    if (handoverTo.isSelfManaged()) {
        disconnectOtherCalls(handoverTo.getTargetPhoneAccount());
    }
}
#method_after
private void completeHandoverFrom(Call call) {
    Call handoverTo = call.getHandoverDestinationCall();
    Log.addEvent(handoverTo, LogUtils.Events.HANDOVER_COMPLETE, "from=%s, to=%s", call.getId(), handoverTo.getId());
    Log.addEvent(call, LogUtils.Events.HANDOVER_COMPLETE, "from=%s, to=%s", call.getId(), handoverTo.getId());
    // Inform the "from" Call (ie the source call) that the handover from it has
    // completed; this allows the InCallService to be notified that a handover it
    // initiated completed.
    call.onConnectionEvent(Connection.EVENT_HANDOVER_COMPLETE, null);
    call.onHandoverComplete();
    // Inform the "to" ConnectionService that handover to it has completed.
    handoverTo.sendCallEvent(android.telecom.Call.EVENT_HANDOVER_COMPLETE, null);
    handoverTo.onHandoverComplete();
    answerCall(handoverTo, handoverTo.getVideoState());
    call.markFinishedHandoverStateAndCleanup(HandoverState.HANDOVER_COMPLETE);
    // ConnectionServices.
    if (handoverTo.isSelfManaged()) {
        disconnectOtherCalls(handoverTo.getTargetPhoneAccount());
    }
}
#end_block

#method_before
private boolean makeRoomForOutgoingCall(Call call, boolean isEmergency) {
    if (hasMaximumManagedLiveCalls(call)) {
        // NOTE: If the amount of live calls changes beyond 1, this logic will probably
        // have to change.
        Call liveCall = getFirstCallWithState(LIVE_CALL_STATES);
        Log.i(this, "makeRoomForOutgoingCall call = " + call + " livecall = " + liveCall);
        if (call == liveCall) {
            // state since the call was already populated into the list.
            return true;
        }
        if (hasMaximumManagedOutgoingCalls(call)) {
            Call outgoingCall = getFirstCallWithState(OUTGOING_CALL_STATES);
            if (isEmergency && !outgoingCall.isEmergencyCall()) {
                // Disconnect the current outgoing call if it's not an emergency call. If the
                // user tries to make two outgoing calls to different emergency call numbers,
                // we will try to connect the first outgoing call.
                call.getAnalytics().setCallIsAdditional(true);
                outgoingCall.getAnalytics().setCallIsInterrupted(true);
                outgoingCall.disconnect();
                return true;
            }
            if (outgoingCall.getState() == CallState.SELECT_PHONE_ACCOUNT) {
                // If there is an orphaned call in the {@link CallState#SELECT_PHONE_ACCOUNT}
                // state, just disconnect it since the user has explicitly started a new call.
                call.getAnalytics().setCallIsAdditional(true);
                outgoingCall.getAnalytics().setCallIsInterrupted(true);
                outgoingCall.disconnect();
                return true;
            }
            return false;
        }
        if (hasMaximumManagedHoldingCalls(call)) {
            // There is no more room for any more calls, unless it's an emergency.
            if (isEmergency) {
                // Kill the current active call, this is easier then trying to disconnect a
                // holding call and hold an active call.
                call.getAnalytics().setCallIsAdditional(true);
                liveCall.getAnalytics().setCallIsInterrupted(true);
                liveCall.disconnect();
                return true;
            }
            // No more room!
            return false;
        }
        // We have room for at least one more holding call at this point.
        // TODO: Remove once b/23035408 has been corrected.
        // If the live call is a conference, it will not have a target phone account set.  This
        // means the check to see if the live call has the same target phone account as the new
        // call will not cause us to bail early.  As a result, we'll end up holding the
        // ongoing conference call.  However, the ConnectionService is already doing that.  This
        // has caused problems with some carriers.  As a workaround until b/23035408 is
        // corrected, we will try and get the target phone account for one of the conference's
        // children and use that instead.
        PhoneAccountHandle liveCallPhoneAccount = liveCall.getTargetPhoneAccount();
        if (liveCallPhoneAccount == null && liveCall.isConference() && !liveCall.getChildCalls().isEmpty()) {
            liveCallPhoneAccount = getFirstChildPhoneAccount(liveCall);
            Log.i(this, "makeRoomForOutgoingCall: using child call PhoneAccount = " + liveCallPhoneAccount);
        }
        // how to handle the new call relative to the current one.
        if (Objects.equals(liveCallPhoneAccount, call.getTargetPhoneAccount())) {
            Log.i(this, "makeRoomForOutgoingCall: phoneAccount matches.");
            call.getAnalytics().setCallIsAdditional(true);
            liveCall.getAnalytics().setCallIsInterrupted(true);
            return true;
        } else if (call.getTargetPhoneAccount() == null) {
            // account.
            return true;
        }
        // Try to hold the live call before attempting the new outgoing call.
        if (liveCall.can(Connection.CAPABILITY_HOLD)) {
            Log.i(this, "makeRoomForOutgoingCall: holding live call.");
            call.getAnalytics().setCallIsAdditional(true);
            liveCall.getAnalytics().setCallIsInterrupted(true);
            liveCall.hold();
            return true;
        }
        // The live call cannot be held so we're out of luck here.  There's no room.
        return false;
    }
    return true;
}
#method_after
private boolean makeRoomForOutgoingCall(Call call, boolean isEmergency) {
    if (hasMaximumLiveCalls(call)) {
        // NOTE: If the amount of live calls changes beyond 1, this logic will probably
        // have to change.
        Call liveCall = getFirstCallWithState(LIVE_CALL_STATES);
        Log.i(this, "makeRoomForOutgoingCall call = " + call + " livecall = " + liveCall);
        if (call == liveCall) {
            // state since the call was already populated into the list.
            return true;
        }
        if (hasMaximumOutgoingCalls(call)) {
            Call outgoingCall = getFirstCallWithState(OUTGOING_CALL_STATES);
            if (isEmergency && !outgoingCall.isEmergencyCall()) {
                // Disconnect the current outgoing call if it's not an emergency call. If the
                // user tries to make two outgoing calls to different emergency call numbers,
                // we will try to connect the first outgoing call.
                call.getAnalytics().setCallIsAdditional(true);
                outgoingCall.getAnalytics().setCallIsInterrupted(true);
                outgoingCall.disconnect();
                return true;
            }
            if (outgoingCall.getState() == CallState.SELECT_PHONE_ACCOUNT) {
                // If there is an orphaned call in the {@link CallState#SELECT_PHONE_ACCOUNT}
                // state, just disconnect it since the user has explicitly started a new call.
                call.getAnalytics().setCallIsAdditional(true);
                outgoingCall.getAnalytics().setCallIsInterrupted(true);
                outgoingCall.disconnect();
                return true;
            }
            return false;
        }
        // Disconnected the live call if the outgoing call is an emergency call.
        if (isEmergency && !canHold(liveCall)) {
            call.getAnalytics().setCallIsAdditional(true);
            liveCall.getAnalytics().setCallIsInterrupted(true);
            liveCall.disconnect();
            return true;
        }
        // TODO: Remove once b/23035408 has been corrected.
        // If the live call is a conference, it will not have a target phone account set.  This
        // means the check to see if the live call has the same target phone account as the new
        // call will not cause us to bail early.  As a result, we'll end up holding the
        // ongoing conference call.  However, the ConnectionService is already doing that.  This
        // has caused problems with some carriers.  As a workaround until b/23035408 is
        // corrected, we will try and get the target phone account for one of the conference's
        // children and use that instead.
        PhoneAccountHandle liveCallPhoneAccount = liveCall.getTargetPhoneAccount();
        if (liveCallPhoneAccount == null && liveCall.isConference() && !liveCall.getChildCalls().isEmpty()) {
            liveCallPhoneAccount = getFirstChildPhoneAccount(liveCall);
            Log.i(this, "makeRoomForOutgoingCall: using child call PhoneAccount = " + liveCallPhoneAccount);
        }
        // how to handle the new call relative to the current one.
        if (Objects.equals(liveCallPhoneAccount, call.getTargetPhoneAccount())) {
            Log.i(this, "makeRoomForOutgoingCall: phoneAccount matches.");
            call.getAnalytics().setCallIsAdditional(true);
            liveCall.getAnalytics().setCallIsInterrupted(true);
            return true;
        } else if (call.getTargetPhoneAccount() == null) {
            // account.
            return true;
        }
        // Try to hold the live call before attempting the new outgoing call.
        if (canHold(liveCall)) {
            Log.i(this, "makeRoomForOutgoingCall: holding live call.");
            call.getAnalytics().setCallIsAdditional(true);
            liveCall.getAnalytics().setCallIsInterrupted(true);
            liveCall.hold();
            return true;
        }
        // The live call cannot be held so we're out of luck here.  There's no room.
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean isOutgoingCallPermitted(Call excludeCall, PhoneAccountHandle phoneAccountHandle) {
    if (phoneAccountHandle == null) {
        return false;
    }
    PhoneAccount phoneAccount = mPhoneAccountRegistrar.getPhoneAccountUnchecked(phoneAccountHandle);
    if (phoneAccount == null) {
        return false;
    }
    if (!phoneAccount.isSelfManaged()) {
        return !hasMaximumManagedOutgoingCalls(excludeCall) && !hasMaximumManagedDialingCalls(excludeCall) && !hasMaximumManagedLiveCalls(excludeCall) && !hasMaximumManagedHoldingCalls(excludeCall);
    } else {
        // are associated with the current PhoneAccountHandle.
        return !hasEmergencyCall() && ((excludeCall != null && excludeCall.getHandoverSourceCall() != null) || (!hasMaximumSelfManagedCalls(excludeCall, phoneAccountHandle) && !hasCallsForOtherPhoneAccount(phoneAccountHandle) && !hasManagedCalls()));
    }
}
#method_after
public boolean isOutgoingCallPermitted(Call excludeCall, PhoneAccountHandle phoneAccountHandle) {
    if (phoneAccountHandle == null) {
        return false;
    }
    PhoneAccount phoneAccount = mPhoneAccountRegistrar.getPhoneAccountUnchecked(phoneAccountHandle);
    if (phoneAccount == null) {
        return false;
    }
    if (!phoneAccount.isSelfManaged()) {
        return !hasMaximumManagedOutgoingCalls(excludeCall) && !hasMaximumManagedDialingCalls(excludeCall) && !hasMaximumManagedLiveCalls(excludeCall) && !hasMaximumManagedHoldingCalls(excludeCall);
    } else {
        // Only permit self-managed outgoing calls if
        // 1. there is no emergency ongoing call
        // 2. The outgoing call is an handover call or it not hit the self-managed call limit
        // and the current active call can be held.
        Call activeCall = (Call) mConnectionSvrFocusMgr.getCurrentFocusCall();
        return !hasEmergencyCall() && ((excludeCall != null && excludeCall.getHandoverSourceCall() != null) || (!hasMaximumSelfManagedCalls(excludeCall, phoneAccountHandle) && (activeCall == null || canHold(activeCall))));
    }
}
#end_block

#method_before
private void startCallConfirmation(Call call) {
    if (mPendingCall != null) {
        Log.i(this, "startCallConfirmation: call %s is already pending; disconnecting %s", mPendingCall.getId(), call.getId());
        markCallDisconnectedDueToSelfManagedCall(call);
        return;
    }
    Log.addEvent(call, LogUtils.Events.USER_CONFIRMATION);
    mPendingCall = call;
    // Figure out the name of the app in charge of the self-managed call(s).
    Call selfManagedCall = mCalls.stream().filter(c -> c.isSelfManaged()).findFirst().orElse(null);
    CharSequence ongoingAppName = "";
    if (selfManagedCall != null) {
        ongoingAppName = selfManagedCall.getTargetPhoneAccountLabel();
    }
    Log.i(this, "startCallConfirmation: callId=%s, ongoingApp=%s", call.getId(), ongoingAppName);
    Intent confirmIntent = new Intent(mContext, ConfirmCallDialogActivity.class);
    confirmIntent.putExtra(ConfirmCallDialogActivity.EXTRA_OUTGOING_CALL_ID, call.getId());
    confirmIntent.putExtra(ConfirmCallDialogActivity.EXTRA_ONGOING_APP_NAME, ongoingAppName);
    confirmIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mContext.startActivityAsUser(confirmIntent, UserHandle.CURRENT);
}
#method_after
private void startCallConfirmation(Call call) {
    if (mPendingCall != null) {
        Log.i(this, "startCallConfirmation: call %s is already pending; disconnecting %s", mPendingCall.getId(), call.getId());
        markCallDisconnectedDueToSelfManagedCall(call);
        return;
    }
    Log.addEvent(call, LogUtils.Events.USER_CONFIRMATION);
    mPendingCall = call;
    // Figure out the name of the app in charge of the self-managed call(s).
    Call activeCall = (Call) mConnectionSvrFocusMgr.getCurrentFocusCall();
    if (activeCall != null) {
        CharSequence ongoingAppName = activeCall.getTargetPhoneAccountLabel();
        Log.i(this, "startCallConfirmation: callId=%s, ongoingApp=%s", call.getId(), ongoingAppName);
        Intent confirmIntent = new Intent(mContext, ConfirmCallDialogActivity.class);
        confirmIntent.putExtra(ConfirmCallDialogActivity.EXTRA_OUTGOING_CALL_ID, call.getId());
        confirmIntent.putExtra(ConfirmCallDialogActivity.EXTRA_ONGOING_APP_NAME, ongoingAppName);
        confirmIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivityAsUser(confirmIntent, UserHandle.CURRENT);
    }
}
#end_block

#method_before
private void setIntentExtrasAndStartTime(Call call, Bundle extras) {
    // Create our own instance to modify (since extras may be Bundle.EMPTY)
    extras = new Bundle(extras);
    // Specifies the time telecom began routing the call. This is used by the dialer for
    // analytics.
    extras.putLong(TelecomManager.EXTRA_CALL_TELECOM_ROUTING_START_TIME_MILLIS, SystemClock.elapsedRealtime());
    call.setIntentExtras(extras);
}
#method_after
private void setIntentExtrasAndStartTime(Call call, Bundle extras) {
    if (extras != null) {
        // Create our own instance to modify (since extras may be Bundle.EMPTY)
        extras = new Bundle(extras);
    } else {
        extras = new Bundle();
    }
    // Specifies the time telecom began routing the call. This is used by the dialer for
    // analytics.
    extras.putLong(TelecomManager.EXTRA_CALL_TELECOM_ROUTING_START_TIME_MILLIS, SystemClock.elapsedRealtime());
    call.setIntentExtras(extras);
}
#end_block

#method_before
private void requestHandover(Call handoverFromCall, PhoneAccountHandle handoverToHandle, int videoState, Bundle extras) {
    // Send an error back if there are any ongoing emergency calls.
    if (hasEmergencyCall()) {
        handoverFromCall.onHandoverFailed(android.telecom.Call.Callback.HANDOVER_FAILURE_ONGOING_EMERG_CALL);
        return;
    }
    // If source and destination phone accounts don't support handover, send an error back.
    boolean isHandoverFromSupported = isHandoverFromPhoneAccountSupported(handoverFromCall.getTargetPhoneAccount());
    boolean isHandoverToSupported = isHandoverToPhoneAccountSupported(handoverToHandle);
    if (!isHandoverFromSupported || !isHandoverToSupported) {
        handoverFromCall.onHandoverFailed(android.telecom.Call.Callback.HANDOVER_FAILURE_DEST_NOT_SUPPORTED);
        return;
    }
    Log.addEvent(handoverFromCall, LogUtils.Events.HANDOVER_REQUEST, handoverToHandle);
    // Create a new instance of Call
    PhoneAccount account = mPhoneAccountRegistrar.getPhoneAccount(handoverToHandle, getCurrentUserHandle());
    boolean isSelfManaged = account != null && account.isSelfManaged();
    Call call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, handoverFromCall.getHandle(), null, null, null, Call.CALL_DIRECTION_OUTGOING, false, false, mClockProxy);
    call.initAnalytics();
    // Set self-managed and voipAudioMode if destination is self-managed CS
    call.setIsSelfManaged(isSelfManaged);
    if (isSelfManaged) {
        call.setIsVoipAudioMode(true);
    }
    call.setInitiatingUser(getCurrentUserHandle());
    // supported.
    if (VideoProfile.isVideo(videoState) && account != null && !account.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
        call.setVideoState(VideoProfile.STATE_AUDIO_ONLY);
    } else {
        call.setVideoState(videoState);
    }
    // Set target phone account to destAcct.
    call.setTargetPhoneAccount(handoverToHandle);
    if (account != null && account.getExtras() != null && account.getExtras().getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE)) {
        Log.d(this, "requestHandover: defaulting to voip mode for call %s", call.getId());
        call.setIsVoipAudioMode(true);
    }
    // Set call state to connecting
    call.setState(CallState.CONNECTING, handoverToHandle == null ? "no-handle" : handoverToHandle.toString());
    setIntentExtrasAndStartTime(call, extras);
    // Add call to call tracker
    if (!mCalls.contains(call)) {
        addCall(call);
    }
    Log.addEvent(handoverFromCall, LogUtils.Events.START_HANDOVER, "handOverFrom=%s, handOverTo=%s", handoverFromCall.getId(), call.getId());
    handoverFromCall.setHandoverDestinationCall(call);
    handoverFromCall.setHandoverState(HandoverState.HANDOVER_FROM_STARTED);
    call.setHandoverState(HandoverState.HANDOVER_TO_STARTED);
    call.setHandoverSourceCall(handoverFromCall);
    call.setNewOutgoingCallIntentBroadcastIsDone();
    // Auto-enable speakerphone if the originating intent specified to do so, if the call
    // is a video call, of if using speaker when docked
    final boolean useSpeakerWhenDocked = mContext.getResources().getBoolean(R.bool.use_speaker_when_docked);
    final boolean useSpeakerForDock = isSpeakerphoneEnabledForDock();
    final boolean useSpeakerForVideoCall = isSpeakerphoneAutoEnabledForVideoCalls(videoState);
    call.setStartWithSpeakerphoneOn(false || useSpeakerForVideoCall || (useSpeakerWhenDocked && useSpeakerForDock));
    call.setVideoState(videoState);
    final boolean isOutgoingCallPermitted = isOutgoingCallPermitted(call, call.getTargetPhoneAccount());
    // If the account has been set, proceed to place the outgoing call.
    if (call.isSelfManaged() && !isOutgoingCallPermitted) {
        notifyCreateConnectionFailed(call.getTargetPhoneAccount(), call);
    } else if (!call.isSelfManaged() && hasSelfManagedCalls() && !call.isEmergencyCall()) {
        markCallDisconnectedDueToSelfManagedCall(call);
    } else {
        if (call.isEmergencyCall()) {
            // Disconnect all self-managed calls to make priority for emergency call.
            disconnectSelfManagedCalls();
        }
        call.startCreateConnection(mPhoneAccountRegistrar);
    }
}
#method_after
private void requestHandover(Call handoverFromCall, PhoneAccountHandle handoverToHandle, int videoState, Bundle extras) {
    // Send an error back if there are any ongoing emergency calls.
    if (hasEmergencyCall()) {
        handoverFromCall.onHandoverFailed(android.telecom.Call.Callback.HANDOVER_FAILURE_ONGOING_EMERG_CALL);
        return;
    }
    // If source and destination phone accounts don't support handover, send an error back.
    boolean isHandoverFromSupported = isHandoverFromPhoneAccountSupported(handoverFromCall.getTargetPhoneAccount());
    boolean isHandoverToSupported = isHandoverToPhoneAccountSupported(handoverToHandle);
    if (!isHandoverFromSupported || !isHandoverToSupported) {
        handoverFromCall.onHandoverFailed(android.telecom.Call.Callback.HANDOVER_FAILURE_DEST_NOT_SUPPORTED);
        return;
    }
    Log.addEvent(handoverFromCall, LogUtils.Events.HANDOVER_REQUEST, handoverToHandle);
    // Create a new instance of Call
    PhoneAccount account = mPhoneAccountRegistrar.getPhoneAccount(handoverToHandle, getCurrentUserHandle());
    boolean isSelfManaged = account != null && account.isSelfManaged();
    Call call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, handoverFromCall.getHandle(), null, null, null, Call.CALL_DIRECTION_OUTGOING, false, false, mClockProxy);
    call.initAnalytics();
    // Set self-managed and voipAudioMode if destination is self-managed CS
    call.setIsSelfManaged(isSelfManaged);
    if (isSelfManaged) {
        call.setIsVoipAudioMode(true);
    }
    call.setInitiatingUser(getCurrentUserHandle());
    // supported.
    if (VideoProfile.isVideo(videoState) && account != null && !account.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
        call.setVideoState(VideoProfile.STATE_AUDIO_ONLY);
    } else {
        call.setVideoState(videoState);
    }
    // Set target phone account to destAcct.
    call.setTargetPhoneAccount(handoverToHandle);
    if (account != null && account.getExtras() != null && account.getExtras().getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE)) {
        Log.d(this, "requestHandover: defaulting to voip mode for call %s", call.getId());
        call.setIsVoipAudioMode(true);
    }
    // Set call state to connecting
    call.setState(CallState.CONNECTING, handoverToHandle == null ? "no-handle" : handoverToHandle.toString());
    // Mark as handover so that the ConnectionService knows this is a handover request.
    if (extras == null) {
        extras = new Bundle();
    }
    extras.putBoolean(TelecomManager.EXTRA_IS_HANDOVER_CONNECTION, true);
    extras.putParcelable(TelecomManager.EXTRA_HANDOVER_FROM_PHONE_ACCOUNT, handoverFromCall.getTargetPhoneAccount());
    setIntentExtrasAndStartTime(call, extras);
    // Add call to call tracker
    if (!mCalls.contains(call)) {
        addCall(call);
    }
    Log.addEvent(handoverFromCall, LogUtils.Events.START_HANDOVER, "handOverFrom=%s, handOverTo=%s", handoverFromCall.getId(), call.getId());
    handoverFromCall.setHandoverDestinationCall(call);
    handoverFromCall.setHandoverState(HandoverState.HANDOVER_FROM_STARTED);
    call.setHandoverState(HandoverState.HANDOVER_TO_STARTED);
    call.setHandoverSourceCall(handoverFromCall);
    call.setNewOutgoingCallIntentBroadcastIsDone();
    // Auto-enable speakerphone if the originating intent specified to do so, if the call
    // is a video call, of if using speaker when docked
    final boolean useSpeakerWhenDocked = mContext.getResources().getBoolean(R.bool.use_speaker_when_docked);
    final boolean useSpeakerForDock = isSpeakerphoneEnabledForDock();
    final boolean useSpeakerForVideoCall = isSpeakerphoneAutoEnabledForVideoCalls(videoState);
    call.setStartWithSpeakerphoneOn(false || useSpeakerForVideoCall || (useSpeakerWhenDocked && useSpeakerForDock));
    call.setVideoState(videoState);
    final boolean isOutgoingCallPermitted = isOutgoingCallPermitted(call, call.getTargetPhoneAccount());
    // If the account has been set, proceed to place the outgoing call.
    if (call.isSelfManaged() && !isOutgoingCallPermitted) {
        notifyCreateConnectionFailed(call.getTargetPhoneAccount(), call);
    } else if (!call.isSelfManaged() && hasSelfManagedCalls() && !call.isEmergencyCall()) {
        markCallDisconnectedDueToSelfManagedCall(call);
    } else {
        if (call.isEmergencyCall()) {
            // Disconnect all self-managed calls to make priority for emergency call.
            disconnectSelfManagedCalls();
        }
        call.startCreateConnection(mPhoneAccountRegistrar);
    }
}
#end_block

#method_before
public void acceptHandover(Uri srcAddr, int videoState, PhoneAccountHandle destAcct) {
    final String handleScheme = srcAddr.getSchemeSpecificPart();
    Call fromCall = mCalls.stream().filter((c) -> mPhoneNumberUtilsAdapter.isSamePhoneNumber(c.getHandle().getSchemeSpecificPart(), handleScheme)).findFirst().orElse(null);
    Call call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, srcAddr, null, /* gatewayInfo */
    null, /* connectionManagerPhoneAccount */
    destAcct, Call.CALL_DIRECTION_INCOMING, /* callDirection */
    false, /* forceAttachToExistingConnection */
    false, /* isConference */
    mClockProxy);
    if (fromCall == null || isHandoverInProgress() || !isHandoverFromPhoneAccountSupported(fromCall.getTargetPhoneAccount()) || !isHandoverToPhoneAccountSupported(destAcct) || hasEmergencyCall()) {
        Log.w(this, "acceptHandover: Handover not supported");
        notifyHandoverFailed(call, android.telecom.Call.Callback.HANDOVER_FAILURE_DEST_NOT_SUPPORTED);
        return;
    }
    PhoneAccount phoneAccount = mPhoneAccountRegistrar.getPhoneAccountUnchecked(destAcct);
    if (phoneAccount == null) {
        Log.w(this, "acceptHandover: Handover not supported. phoneAccount = null");
        notifyHandoverFailed(call, android.telecom.Call.Callback.HANDOVER_FAILURE_DEST_NOT_SUPPORTED);
        return;
    }
    call.setIsSelfManaged(phoneAccount.isSelfManaged());
    if (call.isSelfManaged() || (phoneAccount.getExtras() != null && phoneAccount.getExtras().getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE))) {
        call.setIsVoipAudioMode(true);
    }
    if (!phoneAccount.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
        call.setVideoState(VideoProfile.STATE_AUDIO_ONLY);
    } else {
        call.setVideoState(videoState);
    }
    call.initAnalytics();
    call.addListener(this);
    fromCall.setHandoverDestinationCall(call);
    call.setHandoverSourceCall(fromCall);
    call.setHandoverState(HandoverState.HANDOVER_TO_STARTED);
    fromCall.setHandoverState(HandoverState.HANDOVER_FROM_STARTED);
    if (isSpeakerEnabledForVideoCalls() && VideoProfile.isVideo(videoState)) {
        // Ensure when the call goes active that it will go to speakerphone if the
        // handover to call is a video call.
        call.setStartWithSpeakerphoneOn(true);
    }
    call.startCreateConnection(mPhoneAccountRegistrar);
}
#method_after
public void acceptHandover(Uri srcAddr, int videoState, PhoneAccountHandle destAcct) {
    final String handleScheme = srcAddr.getSchemeSpecificPart();
    Call fromCall = mCalls.stream().filter((c) -> mPhoneNumberUtilsAdapter.isSamePhoneNumber(c.getHandle().getSchemeSpecificPart(), handleScheme)).findFirst().orElse(null);
    Call call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, srcAddr, null, /* gatewayInfo */
    null, /* connectionManagerPhoneAccount */
    destAcct, Call.CALL_DIRECTION_INCOMING, /* callDirection */
    false, /* forceAttachToExistingConnection */
    false, /* isConference */
    mClockProxy);
    if (fromCall == null || isHandoverInProgress() || !isHandoverFromPhoneAccountSupported(fromCall.getTargetPhoneAccount()) || !isHandoverToPhoneAccountSupported(destAcct) || hasEmergencyCall()) {
        Log.w(this, "acceptHandover: Handover not supported");
        notifyHandoverFailed(call, android.telecom.Call.Callback.HANDOVER_FAILURE_DEST_NOT_SUPPORTED);
        return;
    }
    PhoneAccount phoneAccount = mPhoneAccountRegistrar.getPhoneAccountUnchecked(destAcct);
    if (phoneAccount == null) {
        Log.w(this, "acceptHandover: Handover not supported. phoneAccount = null");
        notifyHandoverFailed(call, android.telecom.Call.Callback.HANDOVER_FAILURE_DEST_NOT_SUPPORTED);
        return;
    }
    call.setIsSelfManaged(phoneAccount.isSelfManaged());
    if (call.isSelfManaged() || (phoneAccount.getExtras() != null && phoneAccount.getExtras().getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE))) {
        call.setIsVoipAudioMode(true);
    }
    if (!phoneAccount.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
        call.setVideoState(VideoProfile.STATE_AUDIO_ONLY);
    } else {
        call.setVideoState(videoState);
    }
    call.initAnalytics();
    call.addListener(this);
    fromCall.setHandoverDestinationCall(call);
    call.setHandoverSourceCall(fromCall);
    call.setHandoverState(HandoverState.HANDOVER_TO_STARTED);
    fromCall.setHandoverState(HandoverState.HANDOVER_FROM_STARTED);
    if (isSpeakerEnabledForVideoCalls() && VideoProfile.isVideo(videoState)) {
        // Ensure when the call goes active that it will go to speakerphone if the
        // handover to call is a video call.
        call.setStartWithSpeakerphoneOn(true);
    }
    Bundle extras = call.getIntentExtras();
    if (extras == null) {
        extras = new Bundle();
    }
    extras.putBoolean(TelecomManager.EXTRA_IS_HANDOVER_CONNECTION, true);
    extras.putParcelable(TelecomManager.EXTRA_HANDOVER_FROM_PHONE_ACCOUNT, fromCall.getTargetPhoneAccount());
    call.startCreateConnection(mPhoneAccountRegistrar);
}
#end_block

#method_before
void deflect(Call call, String number) {
    final String callId = mCallIdMapper.getCallId(call);
    if (callId != null && isServiceValid("deflect")) {
        try {
            logOutgoing("deflect %s %s", callId, number);
            mServiceInterface.deflect(callId, number, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
#method_after
void deflect(Call call, Uri address) {
    final String callId = mCallIdMapper.getCallId(call);
    if (callId != null && isServiceValid("deflect")) {
        try {
            logOutgoing("deflect %s", callId);
            mServiceInterface.deflect(callId, address, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
#end_block

#method_before
private void handleConnectionServiceDeath() {
    if (!mPendingResponses.isEmpty()) {
        CreateConnectionResponse[] responses = mPendingResponses.values().toArray(new CreateConnectionResponse[mPendingResponses.values().size()]);
        mPendingResponses.clear();
        for (int i = 0; i < responses.length; i++) {
            responses[i].handleCreateConnectionFailure(new DisconnectCause(DisconnectCause.ERROR, "CS_DEATH"));
        }
    }
    mCallIdMapper.clear();
}
#method_after
private void handleConnectionServiceDeath() {
    if (!mPendingResponses.isEmpty()) {
        CreateConnectionResponse[] responses = mPendingResponses.values().toArray(new CreateConnectionResponse[mPendingResponses.values().size()]);
        mPendingResponses.clear();
        for (int i = 0; i < responses.length; i++) {
            responses[i].handleCreateConnectionFailure(new DisconnectCause(DisconnectCause.ERROR, "CS_DEATH"));
        }
    }
    mCallIdMapper.clear();
    if (mConnSvrFocusListener != null) {
        mConnSvrFocusListener.onConnectionServiceDeath(this);
    }
}
#end_block

#method_before
@Override
public void deflectCall(String callId, String deflectNumber) {
    try {
        Log.startSession(LogUtils.Sessions.ICA_DEFLECT_CALL, mOwnerComponentName);
        long token = Binder.clearCallingIdentity();
        try {
            synchronized (mLock) {
                Log.i(this, "deflectCall(%s,%s)", callId, deflectNumber);
                Call call = mCallIdMapper.getCall(callId);
                if (call != null) {
                    mCallsManager.deflectCall(call, deflectNumber);
                } else {
                    Log.w(this, "deflectCall, unknown call id: %s", callId);
                }
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    } finally {
        Log.endSession();
    }
}
#method_after
@Override
public void deflectCall(String callId, Uri address) {
    try {
        Log.startSession(LogUtils.Sessions.ICA_DEFLECT_CALL, mOwnerComponentName);
        long token = Binder.clearCallingIdentity();
        try {
            synchronized (mLock) {
                Log.i(this, "deflectCall - %s, %s ", callId, Log.pii(address));
                Call call = mCallIdMapper.getCall(callId);
                if (call != null) {
                    mCallsManager.deflectCall(call, address);
                } else {
                    Log.w(this, "deflectCall, unknown call id: %s", callId);
                }
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    } finally {
        Log.endSession();
    }
}
#end_block

#method_before
@Override
public void sendCallEvent(String callId, String event, Bundle extras) {
    try {
        Log.startSession("ICA.sCE", mOwnerComponentName);
        long token = Binder.clearCallingIdentity();
        try {
            synchronized (mLock) {
                Call call = mCallIdMapper.getCall(callId);
                if (call != null) {
                    call.sendCallEvent(event, extras);
                } else {
                    Log.w(this, "sendCallEvent, unknown call id: %s", callId);
                }
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    } finally {
        Log.endSession();
    }
}
#method_after
@Override
public void sendCallEvent(String callId, String event, int targetSdkVer, Bundle extras) {
    try {
        Log.startSession("ICA.sCE", mOwnerComponentName);
        long token = Binder.clearCallingIdentity();
        try {
            synchronized (mLock) {
                Call call = mCallIdMapper.getCall(callId);
                if (call != null) {
                    call.sendCallEvent(event, targetSdkVer, extras);
                } else {
                    Log.w(this, "sendCallEvent, unknown call id: %s", callId);
                }
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    } finally {
        Log.endSession();
    }
}
#end_block

#method_before
public void update(CommandsInterface ci, IccSlotStatus iss) {
    log("slotStatus update");
    synchronized (mLock) {
        mCi = ci;
        if (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_INACTIVE) {
            if (mActive) {
                mActive = false;
                mLastRadioState = RadioState.RADIO_UNAVAILABLE;
                mPhoneId = null;
                if (mUiccCard != null)
                    mUiccCard.dispose();
                mUiccCard = null;
            }
            parseAtr(iss.atr);
            mCardState = iss.cardState;
            mIccId = iss.iccid;
        } else if (!mActive && iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE) {
            mActive = true;
            parseAtr(ics.atr);
        // todo - ignoring these fields for now; relying on sim state changed to update
        // these
        // iss.cardState;
        // iss.iccid;
        // iss.logicalSlotIndex;
        }
    }
}
#method_after
public void update(CommandsInterface ci, IccSlotStatus iss) {
    log("slotStatus update");
    synchronized (mLock) {
        mCi = ci;
        if (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_INACTIVE) {
            if (mActive) {
                mActive = false;
                mLastRadioState = RadioState.RADIO_UNAVAILABLE;
                mPhoneId = null;
                if (mUiccCard != null)
                    mUiccCard.dispose();
                mUiccCard = null;
            }
            parseAtr(iss.atr);
            mCardState = iss.cardState;
            mIccId = iss.iccid;
        } else if (!mActive && iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE) {
            mActive = true;
            parseAtr(iss.atr);
        // todo - ignoring these fields for now; relying on sim state changed to update
        // these
        // iss.cardState;
        // iss.iccid;
        // iss.logicalSlotIndex;
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    // Setup mocks and test assets
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    // Stub system interface
    when(mSystemInterface.getHeadsetPhoneState()).thenReturn(mPhoneState);
    when(mSystemInterface.getAudioManager()).thenReturn(mAudioManager);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    // Spy on native interface
    mNativeInterface = spy(HeadsetNativeInterface.getInstance());
    doNothing().when(mNativeInterface).init(anyInt(), anyBoolean());
    doReturn(true).when(mNativeInterface).connectHfp(mTestDevice);
    doReturn(true).when(mNativeInterface).disconnectHfp(mTestDevice);
    doReturn(true).when(mNativeInterface).connectAudio(mTestDevice);
    doReturn(true).when(mNativeInterface).disconnectAudio(mTestDevice);
    // Stub headset service
    doReturn(BluetoothDevice.BOND_BONDED).when(mAdapterService).getBondState(any(BluetoothDevice.class));
    when(mHeadsetService.bindService(any(Intent.class), any(ServiceConnection.class), anyInt())).thenReturn(true);
    when(mHeadsetService.getResources()).thenReturn(InstrumentationRegistry.getTargetContext().getResources());
    when(mHeadsetService.getPackageManager()).thenReturn(InstrumentationRegistry.getContext().getPackageManager());
    when(mHeadsetService.getPriority(any(BluetoothDevice.class))).thenReturn(BluetoothProfile.PRIORITY_ON);
    when(mHeadsetService.getForceScoAudio()).thenReturn(true);
    when(mHeadsetService.okToAcceptConnection(any(BluetoothDevice.class))).thenReturn(true);
    // Setup thread and looper
    mHandlerThread = new HandlerThread("HeadsetStateMachineTestHandlerThread");
    mHandlerThread.start();
    // Modify CONNECT timeout to a smaller value for test only
    HeadsetStateMachine.sConnectTimeoutMs = CONNECT_TIMEOUT_TEST_MILLIS;
    mHeadsetStateMachine = HeadsetObjectsFactory.getInstance().makeStateMachine(mTestDevice, mHandlerThread.getLooper(), mHeadsetService, mAdapterService, mNativeInterface, mSystemInterface);
}
#method_after
@Before
public void setUp() throws Exception {
    mTargetContext = InstrumentationRegistry.getTargetContext();
    Assume.assumeTrue("Ignore test when HeadsetService is not enabled", mTargetContext.getResources().getBoolean(R.bool.profile_supported_hs_hfp));
    // Setup mocks and test assets
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    // Stub system interface
    when(mSystemInterface.getHeadsetPhoneState()).thenReturn(mPhoneState);
    when(mSystemInterface.getAudioManager()).thenReturn(mAudioManager);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    // Spy on native interface
    mNativeInterface = spy(HeadsetNativeInterface.getInstance());
    doNothing().when(mNativeInterface).init(anyInt(), anyBoolean());
    doReturn(true).when(mNativeInterface).connectHfp(mTestDevice);
    doReturn(true).when(mNativeInterface).disconnectHfp(mTestDevice);
    doReturn(true).when(mNativeInterface).connectAudio(mTestDevice);
    doReturn(true).when(mNativeInterface).disconnectAudio(mTestDevice);
    // Stub headset service
    doReturn(BluetoothDevice.BOND_BONDED).when(mAdapterService).getBondState(any(BluetoothDevice.class));
    when(mHeadsetService.bindService(any(Intent.class), any(ServiceConnection.class), anyInt())).thenReturn(true);
    when(mHeadsetService.getResources()).thenReturn(InstrumentationRegistry.getTargetContext().getResources());
    when(mHeadsetService.getPackageManager()).thenReturn(InstrumentationRegistry.getContext().getPackageManager());
    when(mHeadsetService.getPriority(any(BluetoothDevice.class))).thenReturn(BluetoothProfile.PRIORITY_ON);
    when(mHeadsetService.getForceScoAudio()).thenReturn(true);
    when(mHeadsetService.okToAcceptConnection(any(BluetoothDevice.class))).thenReturn(true);
    // Setup thread and looper
    mHandlerThread = new HandlerThread("HeadsetStateMachineTestHandlerThread");
    mHandlerThread.start();
    // Modify CONNECT timeout to a smaller value for test only
    HeadsetStateMachine.sConnectTimeoutMs = CONNECT_TIMEOUT_TEST_MILLIS;
    mHeadsetStateMachine = HeadsetObjectsFactory.getInstance().makeStateMachine(mTestDevice, mHandlerThread.getLooper(), mHeadsetService, mAdapterService, mNativeInterface, mSystemInterface);
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    HeadsetObjectsFactory.getInstance().destroyStateMachine(mHeadsetStateMachine);
    mHandlerThread.quit();
    TestUtils.clearAdapterService(mAdapterService);
    mAdapterService = null;
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_hs_hfp)) {
        return;
    }
    HeadsetObjectsFactory.getInstance().destroyStateMachine(mHeadsetStateMachine);
    mHandlerThread.quit();
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    mHandlerThread = new HandlerThread("PbapTestHandlerThread");
    mHandlerThread.start();
    mHandler = new Handler(mHandlerThread.getLooper());
    mBluetoothPbapService = mock(BluetoothPbapService.class);
    doNothing().when(mBluetoothPbapService).checkOrGetPhonebookPermission(any());
    mPbapStateMachine = PbapStateMachine.make(mBluetoothPbapService, mHandlerThread.getLooper(), mTestDevice, mSocket, mBluetoothPbapService, mHandler, TEST_NOTIFICATION_ID);
}
#method_after
@Before
public void setUp() throws Exception {
    mTargetContext = InstrumentationRegistry.getTargetContext();
    Assume.assumeTrue("Ignore test when BluetoothPbapService is not enabled", mTargetContext.getResources().getBoolean(R.bool.profile_supported_pbap));
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    mHandlerThread = new HandlerThread("PbapTestHandlerThread");
    mHandlerThread.start();
    mHandler = new Handler(mHandlerThread.getLooper());
    mBluetoothPbapService = mock(BluetoothPbapService.class);
    doNothing().when(mBluetoothPbapService).checkOrGetPhonebookPermission(any());
    mPbapStateMachine = PbapStateMachine.make(mBluetoothPbapService, mHandlerThread.getLooper(), mTestDevice, mSocket, mBluetoothPbapService, mHandler, TEST_NOTIFICATION_ID);
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    mHandlerThread.quitSafely();
    TestUtils.clearAdapterService(mAdapterService);
    mAdapterService = null;
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_pbap)) {
        return;
    }
    mHandlerThread.quitSafely();
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
@Override
protected void cleanup() {
    HeadsetClientStateMachine.cleanup();
    // TODO: should be moved to stop()
    clearHeadsetClientService();
}
#method_after
@Override
protected void cleanup() {
    HeadsetClientStateMachine.cleanup();
    // TODO(b/72948646): should be moved to stop()
    setHeadsetClientService(null);
}
#end_block

#method_before
@Override
protected void cleanup() {
    if (DBG) {
        Log.d(TAG, "in Cleanup");
    }
    removeUncleanAccounts();
    // TODO: should be moved to stop()
    setMapClientService(null);
}
#method_after
@Override
protected void cleanup() {
    if (DBG) {
        Log.d(TAG, "in Cleanup");
    }
    removeUncleanAccounts();
    // TODO(b/72948646): should be moved to stop()
    setMapClientService(null);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    Assert.assertNotNull(Looper.myLooper());
    mTargetContext = InstrumentationRegistry.getTargetContext();
    // Set up mocks and test assets
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    setHidDeviceNativeInterfaceInstance(mHidDeviceNativeInterface);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("10:11:12:13:14:15");
    TestUtils.startService(mServiceRule, HidDeviceService.class);
    mHidDeviceService = HidDeviceService.getHidDeviceService();
    Assert.assertNotNull(mHidDeviceService);
    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            mHidDeviceService.start();
        }
    });
    // Force unregister app first
    mHidDeviceService.unregisterApp();
    Field field = HidDeviceService.class.getDeclaredField("mHidDeviceNativeInterface");
    field.setAccessible(true);
    HidDeviceNativeInterface nativeInterface = (HidDeviceNativeInterface) field.get(mHidDeviceService);
    Assert.assertEquals(nativeInterface, mHidDeviceNativeInterface);
    // Dummy SDP settings
    mSettings = new BluetoothHidDeviceAppSdpSettings("Unit test", "test", "Android", BluetoothHidDevice.SUBCLASS1_COMBO, new byte[] {});
    // Set up the Connection State Changed receiver
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothHidDevice.ACTION_CONNECTION_STATE_CHANGED);
    mConnectionStateChangedReceiver = new ConnectionStateChangedReceiver();
    mTargetContext.registerReceiver(mConnectionStateChangedReceiver, filter);
    reset(mHidDeviceNativeInterface, mAdapterService);
}
#method_after
@Before
public void setUp() throws Exception {
    mTargetContext = InstrumentationRegistry.getTargetContext();
    Assume.assumeTrue("Ignore test when HidDeviceService is not enabled", mTargetContext.getResources().getBoolean(R.bool.profile_supported_hid_device));
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    Assert.assertNotNull(Looper.myLooper());
    // Set up mocks and test assets
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    setHidDeviceNativeInterfaceInstance(mHidDeviceNativeInterface);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("10:11:12:13:14:15");
    TestUtils.startService(mServiceRule, HidDeviceService.class);
    mHidDeviceService = HidDeviceService.getHidDeviceService();
    Assert.assertNotNull(mHidDeviceService);
    InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {

        @Override
        public void run() {
            mHidDeviceService.start();
        }
    });
    // Force unregister app first
    mHidDeviceService.unregisterApp();
    Field field = HidDeviceService.class.getDeclaredField("mHidDeviceNativeInterface");
    field.setAccessible(true);
    HidDeviceNativeInterface nativeInterface = (HidDeviceNativeInterface) field.get(mHidDeviceService);
    Assert.assertEquals(nativeInterface, mHidDeviceNativeInterface);
    // Dummy SDP settings
    mSettings = new BluetoothHidDeviceAppSdpSettings("Unit test", "test", "Android", BluetoothHidDevice.SUBCLASS1_COMBO, new byte[] {});
    // Set up the Connection State Changed receiver
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothHidDevice.ACTION_CONNECTION_STATE_CHANGED);
    mConnectionStateChangedReceiver = new ConnectionStateChangedReceiver();
    mTargetContext.registerReceiver(mConnectionStateChangedReceiver, filter);
    reset(mHidDeviceNativeInterface, mAdapterService);
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    TestUtils.stopService(mServiceRule, HidDeviceService.class);
    mHidDeviceService = HidDeviceService.getHidDeviceService();
    Assert.assertNull(mHidDeviceService);
    mTargetContext.unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedQueue.clear();
    mCallbackQueue.clear();
    setHidDeviceNativeInterfaceInstance(null);
    TestUtils.clearAdapterService(mAdapterService);
    mAdapterService = null;
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_hid_device)) {
        return;
    }
    TestUtils.stopService(mServiceRule, HidDeviceService.class);
    mHidDeviceService = HidDeviceService.getHidDeviceService();
    Assert.assertNull(mHidDeviceService);
    mTargetContext.unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedQueue.clear();
    mCallbackQueue.clear();
    setHidDeviceNativeInterfaceInstance(null);
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
@Override
protected void cleanup() {
    // TODO: this should be moved to stop()
    setPanService(null);
    if (mNativeAvailable) {
        cleanupNative();
        mNativeAvailable = false;
    }
    if (mPanDevices != null) {
        List<BluetoothDevice> devList = getConnectedDevices();
        for (BluetoothDevice dev : devList) {
            handlePanDeviceStateChange(dev, mPanIfName, BluetoothProfile.STATE_DISCONNECTED, BluetoothPan.LOCAL_PANU_ROLE, BluetoothPan.REMOTE_NAP_ROLE);
        }
        mPanDevices.clear();
    }
}
#method_after
@Override
protected void cleanup() {
    // TODO(b/72948646): this should be moved to stop()
    setPanService(null);
    if (mNativeAvailable) {
        cleanupNative();
        mNativeAvailable = false;
    }
    if (mPanDevices != null) {
        List<BluetoothDevice> devList = getConnectedDevices();
        for (BluetoothDevice dev : devList) {
            handlePanDeviceStateChange(dev, mPanIfName, BluetoothProfile.STATE_DISCONNECTED, BluetoothPan.LOCAL_PANU_ROLE, BluetoothPan.REMOTE_NAP_ROLE);
        }
        mPanDevices.clear();
    }
}
#end_block

#method_before
private void onConnectStateChanged(byte[] address, int state, int error, int localRole, int remoteRole) {
    if (DBG) {
        log("onConnectStateChanged: " + state + ", local role:" + localRole + ", remoteRole: " + remoteRole);
    }
    Message msg = mHandler.obtainMessage(MESSAGE_CONNECT_STATE_CHANGED);
    msg.obj = new ConnectState(address, state, error, localRole, remoteRole);
    mHandler.sendMessage(msg);
}
#method_after
private void onConnectStateChanged(byte[] address, int state, int error, int localRole, int remoteRole) {
    if (DBG) {
        Log.d(TAG, "onConnectStateChanged: " + state + ", local role:" + localRole + ", remoteRole: " + remoteRole);
    }
    Message msg = mHandler.obtainMessage(MESSAGE_CONNECT_STATE_CHANGED);
    msg.obj = new ConnectState(address, state, error, localRole, remoteRole);
    mHandler.sendMessage(msg);
}
#end_block

#method_before
private void onControlStateChanged(int localRole, int state, int error, String ifname) {
    if (DBG) {
        log("onControlStateChanged: " + state + ", error: " + error + ", ifname: " + ifname);
    }
    if (error == 0) {
        mPanIfName = ifname;
    }
}
#method_after
private void onControlStateChanged(int localRole, int state, int error, String ifname) {
    if (DBG) {
        Log.d(TAG, "onControlStateChanged: " + state + ", error: " + error + ", ifname: " + ifname);
    }
    if (error == 0) {
        mPanIfName = ifname;
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    doReturn(true).when(mAdapterService).isEnabled();
    doReturn(MAX_HEADSET_CONNECTIONS).when(mAdapterService).getMaxConnectedAudioDevices();
    doReturn(new ParcelUuid[] { BluetoothUuid.Handsfree }).when(mAdapterService).getRemoteUuids(any(BluetoothDevice.class));
    // We cannot mock HeadsetObjectsFactory.getInstance() with Mockito.
    // Hence we need to use reflection to call a private method to
    // initialize properly the HeadsetObjectsFactory.sInstance field.
    Method method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(null, mObjectsFactory);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Mock methods in AdapterService
    doReturn(FAKE_HEADSET_UUID).when(mAdapterService).getRemoteUuids(any(BluetoothDevice.class));
    doReturn(BluetoothDevice.BOND_BONDED).when(mAdapterService).getBondState(any(BluetoothDevice.class));
    doAnswer(invocation -> mBondedDevices.toArray(new BluetoothDevice[] {})).when(mAdapterService).getBondedDevices();
    // Mock system interface
    doNothing().when(mSystemInterface).init();
    doNothing().when(mSystemInterface).stop();
    when(mSystemInterface.getHeadsetPhoneState()).thenReturn(mPhoneState);
    when(mSystemInterface.getAudioManager()).thenReturn(mAudioManager);
    // Mock methods in HeadsetNativeInterface
    mNativeInterface = spy(HeadsetNativeInterface.getInstance());
    doNothing().when(mNativeInterface).init(anyInt(), anyBoolean());
    doNothing().when(mNativeInterface).cleanup();
    doReturn(true).when(mNativeInterface).connectHfp(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).disconnectHfp(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).connectAudio(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).disconnectAudio(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).setActiveDevice(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).sendBsir(any(BluetoothDevice.class), anyBoolean());
    // Use real state machines here
    doCallRealMethod().when(mObjectsFactory).makeStateMachine(any(), any(), any(), any(), any(), any());
    // Mock methods in HeadsetObjectsFactory
    doReturn(mSystemInterface).when(mObjectsFactory).makeSystemInterface(any());
    doReturn(mNativeInterface).when(mObjectsFactory).getNativeInterface();
    TestUtils.startService(mServiceRule, HeadsetService.class);
    mHeadsetService = HeadsetService.getHeadsetService();
    Assert.assertNotNull(mHeadsetService);
    verify(mObjectsFactory).makeSystemInterface(mHeadsetService);
    verify(mObjectsFactory).getNativeInterface();
}
#method_after
@Before
public void setUp() throws Exception {
    mTargetContext = InstrumentationRegistry.getTargetContext();
    Assume.assumeTrue("Ignore test when HeadsetService is not enabled", mTargetContext.getResources().getBoolean(R.bool.profile_supported_hs_hfp));
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    doReturn(true).when(mAdapterService).isEnabled();
    doReturn(MAX_HEADSET_CONNECTIONS).when(mAdapterService).getMaxConnectedAudioDevices();
    doReturn(new ParcelUuid[] { BluetoothUuid.Handsfree }).when(mAdapterService).getRemoteUuids(any(BluetoothDevice.class));
    // We cannot mock HeadsetObjectsFactory.getInstance() with Mockito.
    // Hence we need to use reflection to call a private method to
    // initialize properly the HeadsetObjectsFactory.sInstance field.
    Method method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(null, mObjectsFactory);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Mock methods in AdapterService
    doReturn(FAKE_HEADSET_UUID).when(mAdapterService).getRemoteUuids(any(BluetoothDevice.class));
    doReturn(BluetoothDevice.BOND_BONDED).when(mAdapterService).getBondState(any(BluetoothDevice.class));
    doAnswer(invocation -> mBondedDevices.toArray(new BluetoothDevice[] {})).when(mAdapterService).getBondedDevices();
    // Mock system interface
    doNothing().when(mSystemInterface).init();
    doNothing().when(mSystemInterface).stop();
    when(mSystemInterface.getHeadsetPhoneState()).thenReturn(mPhoneState);
    when(mSystemInterface.getAudioManager()).thenReturn(mAudioManager);
    // Mock methods in HeadsetNativeInterface
    mNativeInterface = spy(HeadsetNativeInterface.getInstance());
    doNothing().when(mNativeInterface).init(anyInt(), anyBoolean());
    doNothing().when(mNativeInterface).cleanup();
    doReturn(true).when(mNativeInterface).connectHfp(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).disconnectHfp(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).connectAudio(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).disconnectAudio(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).setActiveDevice(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).sendBsir(any(BluetoothDevice.class), anyBoolean());
    // Use real state machines here
    doCallRealMethod().when(mObjectsFactory).makeStateMachine(any(), any(), any(), any(), any(), any());
    // Mock methods in HeadsetObjectsFactory
    doReturn(mSystemInterface).when(mObjectsFactory).makeSystemInterface(any());
    doReturn(mNativeInterface).when(mObjectsFactory).getNativeInterface();
    TestUtils.startService(mServiceRule, HeadsetService.class);
    mHeadsetService = HeadsetService.getHeadsetService();
    Assert.assertNotNull(mHeadsetService);
    verify(mObjectsFactory).makeSystemInterface(mHeadsetService);
    verify(mObjectsFactory).getNativeInterface();
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    TestUtils.stopService(mServiceRule, HeadsetService.class);
    mHeadsetService = HeadsetService.getHeadsetService();
    Assert.assertNull(mHeadsetService);
    reset(mObjectsFactory, mAdapterService);
    mCurrentDevice = null;
    Method method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(null, (HeadsetObjectsFactory) null);
    mObjectsFactory = null;
    TestUtils.clearAdapterService(mAdapterService);
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_hs_hfp)) {
        return;
    }
    TestUtils.stopService(mServiceRule, HeadsetService.class);
    mHeadsetService = HeadsetService.getHeadsetService();
    Assert.assertNull(mHeadsetService);
    Method method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(null, (HeadsetObjectsFactory) null);
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
public static synchronized PbapClientService getPbapClientService() {
    if (sPbapClientService != null && sPbapClientService.isAvailable()) {
        if (DBG) {
            Log.d(TAG, "getPbapClientService(): returning " + sPbapClientService);
        }
        return sPbapClientService;
    }
    if (DBG) {
        if (sPbapClientService == null) {
            Log.d(TAG, "getPbapClientService(): service is NULL");
        } else if (!(sPbapClientService.isAvailable())) {
            Log.d(TAG, "getPbapClientService(): service is not available");
        }
    }
    return null;
}
#method_after
public static synchronized PbapClientService getPbapClientService() {
    if (sPbapClientService == null) {
        Log.w(TAG, "getPbapClientService(): service is null");
        return null;
    }
    if (!sPbapClientService.isAvailable()) {
        Log.w(TAG, "getPbapClientService(): service is not available");
        return null;
    }
    return sPbapClientService;
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    TestUtils.stopService(mServiceRule, HeadsetService.class);
    mHeadsetService = HeadsetService.getHeadsetService();
    Assert.assertNull(mHeadsetService);
    mStateMachines.clear();
    mCurrentDevice = null;
    Method method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(null, (HeadsetObjectsFactory) null);
    mObjectsFactory = null;
    TestUtils.clearAdapterService(mAdapterService);
    mAdapterService = null;
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_hs_hfp)) {
        return;
    }
    TestUtils.stopService(mServiceRule, HeadsetService.class);
    mHeadsetService = HeadsetService.getHeadsetService();
    Assert.assertNull(mHeadsetService);
    mStateMachines.clear();
    mCurrentDevice = null;
    Method method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(null, (HeadsetObjectsFactory) null);
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    // Set up mocks and test assets
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    mTargetContext = InstrumentationRegistry.getTargetContext();
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    // Set up thread and looper
    mHandlerThread = new HandlerThread("A2dpStateMachineTestHandlerThread");
    mHandlerThread.start();
    mA2dpStateMachine = new A2dpStateMachine(mTestDevice, mA2dpService, mTargetContext, mA2dpNativeInterface, mHandlerThread.getLooper());
    // Override the timeout value to speed up the test
    // 1s
    A2dpStateMachine.sConnectTimeoutMs = 1000;
    mA2dpStateMachine.start();
}
#method_after
@Before
public void setUp() throws Exception {
    mTargetContext = InstrumentationRegistry.getTargetContext();
    Assume.assumeTrue("Ignore test when A2dpService is not enabled", mTargetContext.getResources().getBoolean(R.bool.profile_supported_a2dp));
    // Set up mocks and test assets
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    // Set up thread and looper
    mHandlerThread = new HandlerThread("A2dpStateMachineTestHandlerThread");
    mHandlerThread.start();
    mA2dpStateMachine = new A2dpStateMachine(mTestDevice, mA2dpService, mTargetContext, mA2dpNativeInterface, mHandlerThread.getLooper());
    // Override the timeout value to speed up the test
    // 1s
    A2dpStateMachine.sConnectTimeoutMs = 1000;
    mA2dpStateMachine.start();
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    mA2dpStateMachine.doQuit();
    mHandlerThread.quit();
    TestUtils.clearAdapterService(mAdapterService);
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_a2dp)) {
        return;
    }
    mA2dpStateMachine.doQuit();
    mHandlerThread.quit();
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    TestUtils.stopService(mServiceRule, HeadsetClientService.class);
    mService = null;
    mAdapter = null;
    TestUtils.clearAdapterService(mAdapterService);
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_hfpclient)) {
        return;
    }
    TestUtils.stopService(mServiceRule, HeadsetClientService.class);
    mService = HeadsetClientService.getHeadsetClientService();
    Assert.assertNull(mService);
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
@Test
public void testInitialize() {
    // Test that we can initialize the service
    Log.i(TAG, "testInitialize, test passed");
}
#method_after
@Test
public void testInitialize() {
    Assert.assertNotNull(HeadsetClientService.getHeadsetClientService());
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    TestUtils.stopService(mServiceRule, MapClientService.class);
    mService = MapClientService.getMapClientService();
    Assert.assertNull(mService);
    mAdapter = null;
    TestUtils.clearAdapterService(mAdapterService);
    mAdapterService = null;
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_mapmce)) {
        return;
    }
    TestUtils.stopService(mServiceRule, MapClientService.class);
    mService = MapClientService.getMapClientService();
    Assert.assertNull(mService);
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
@Test
public void testInitialize() {
    // Test that we can initialize the service
    Log.i(TAG, "testInitialize, test passed");
}
#method_after
@Test
public void testInitialize() {
    Assert.assertNotNull(MapClientService.getMapClientService());
}
#end_block

#method_before
@Before
public void setUp() {
    mTargetContext = InstrumentationRegistry.getTargetContext();
    if (skipTest())
        return;
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    mLock = new CountDownLatch(1);
    mFakeMapClientService = new FakeMapClientService(mLock);
    mMceStateMachine = new MceStateMachine(mFakeMapClientService, mTestDevice);
    Assert.assertNotNull(mMceStateMachine);
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    mHandler = new Handler();
}
#method_after
@Before
public void setUp() {
    mTargetContext = InstrumentationRegistry.getTargetContext();
    Assume.assumeTrue("Ignore test when MapClientService is not enabled", mTargetContext.getResources().getBoolean(R.bool.profile_supported_mapmce));
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    mLock = new CountDownLatch(1);
    mFakeMapClientService = new FakeMapClientService(mLock);
    mMceStateMachine = new MceStateMachine(mFakeMapClientService, mTestDevice);
    Assert.assertNotNull(mMceStateMachine);
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    mHandler = new Handler();
}
#end_block

#method_before
@After
public void tearDown() {
    if (mMceStateMachine != null) {
        mMceStateMachine.doQuit();
    }
}
#method_after
@After
public void tearDown() {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_mapmce)) {
        return;
    }
    if (mMceStateMachine != null) {
        mMceStateMachine.doQuit();
    }
}
#end_block

#method_before
@Test
public void testDefaultDisconnectedState() {
    if (skipTest())
        return;
    Log.i(TAG, "in testDefaultDisconnectedState");
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTING, mMceStateMachine.getState());
}
#method_after
@Test
public void testDefaultDisconnectedState() {
    Log.i(TAG, "in testDefaultDisconnectedState");
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTING, mMceStateMachine.getState());
}
#end_block

#method_before
@Test
public void testStateTransitionFromConnectingToConnected() {
    if (skipTest())
        return;
    Log.i(TAG, "in testStateTransitionFromConnectingToConnected");
    setupSdpRecordReceipt();
    Message msg = Message.obtain(mHandler, MceStateMachine.MSG_MAS_CONNECTED);
    mMceStateMachine.getCurrentState().processMessage(msg);
    // state from STATE_CONNECTING to STATE_CONNECTED
    try {
        mLock.await();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mMceStateMachine.getState());
}
#method_after
@Test
public void testStateTransitionFromConnectingToConnected() {
    Log.i(TAG, "in testStateTransitionFromConnectingToConnected");
    setupSdpRecordReceipt();
    Message msg = Message.obtain(mHandler, MceStateMachine.MSG_MAS_CONNECTED);
    mMceStateMachine.getCurrentState().processMessage(msg);
    // state from STATE_CONNECTING to STATE_CONNECTED
    try {
        mLock.await();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mMceStateMachine.getState());
}
#end_block

#method_before
@Override
protected void cleanup() {
    if (DBG)
        Log.d(TAG, "Stopping Bluetooth HidHostService");
    if (mNativeAvailable) {
        cleanupNative();
        mNativeAvailable = false;
    }
    if (mInputDevices != null) {
        for (BluetoothDevice device : mInputDevices.keySet()) {
            int inputDeviceState = getConnectionState(device);
            if (inputDeviceState != BluetoothProfile.STATE_DISCONNECTED) {
                broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED);
            }
        }
        mInputDevices.clear();
    }
    // TODO: this should be moved to stop()
    setHidHostService(null);
}
#method_after
@Override
protected void cleanup() {
    if (DBG)
        Log.d(TAG, "Stopping Bluetooth HidHostService");
    if (mNativeAvailable) {
        cleanupNative();
        mNativeAvailable = false;
    }
    if (mInputDevices != null) {
        for (BluetoothDevice device : mInputDevices.keySet()) {
            int inputDeviceState = getConnectionState(device);
            if (inputDeviceState != BluetoothProfile.STATE_DISCONNECTED) {
                broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED);
            }
        }
        mInputDevices.clear();
    }
    // TODO(b/72948646): this should be moved to stop()
    setHidHostService(null);
}
#end_block

#method_before
private void broadcastConnectionState(BluetoothDevice device, int newState) {
    Integer prevStateInteger = mInputDevices.get(device);
    int prevState = (prevStateInteger == null) ? BluetoothHidHost.STATE_DISCONNECTED : prevStateInteger;
    if (prevState == newState) {
        Log.w(TAG, "no state change: " + newState);
        return;
    }
    mInputDevices.put(device, newState);
    /* Notifying the connection state change of the profile before sending the intent for
           connection state change, as it was causing a race condition, with the UI not being
           updated with the correct connection state. */
    log("Connection state " + device + ": " + prevState + "->" + newState);
    Intent intent = new Intent(BluetoothHidHost.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
}
#method_after
private void broadcastConnectionState(BluetoothDevice device, int newState) {
    Integer prevStateInteger = mInputDevices.get(device);
    int prevState = (prevStateInteger == null) ? BluetoothHidHost.STATE_DISCONNECTED : prevStateInteger;
    if (prevState == newState) {
        Log.w(TAG, "no state change: " + newState);
        return;
    }
    mInputDevices.put(device, newState);
    /* Notifying the connection state change of the profile before sending the intent for
           connection state change, as it was causing a race condition, with the UI not being
           updated with the correct connection state. */
    Log.d(TAG, "Connection state " + device + ": " + prevState + "->" + newState);
    Intent intent = new Intent(BluetoothHidHost.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
}
#end_block

#method_before
private void broadcastProtocolMode(BluetoothDevice device, int protocolMode) {
    Intent intent = new Intent(BluetoothHidHost.ACTION_PROTOCOL_MODE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.putExtra(BluetoothHidHost.EXTRA_PROTOCOL_MODE, protocolMode);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcast(intent, BLUETOOTH_PERM);
    if (DBG) {
        log("Protocol Mode (" + device + "): " + protocolMode);
    }
}
#method_after
private void broadcastProtocolMode(BluetoothDevice device, int protocolMode) {
    Intent intent = new Intent(BluetoothHidHost.ACTION_PROTOCOL_MODE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.putExtra(BluetoothHidHost.EXTRA_PROTOCOL_MODE, protocolMode);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcast(intent, BLUETOOTH_PERM);
    if (DBG) {
        Log.d(TAG, "Protocol Mode (" + device + "): " + protocolMode);
    }
}
#end_block

#method_before
private void broadcastIdleTime(BluetoothDevice device, int idleTime) {
    Intent intent = new Intent(BluetoothHidHost.ACTION_IDLE_TIME_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.putExtra(BluetoothHidHost.EXTRA_IDLE_TIME, idleTime);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcast(intent, BLUETOOTH_PERM);
    if (DBG) {
        log("Idle time (" + device + "): " + idleTime);
    }
}
#method_after
private void broadcastIdleTime(BluetoothDevice device, int idleTime) {
    Intent intent = new Intent(BluetoothHidHost.ACTION_IDLE_TIME_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.putExtra(BluetoothHidHost.EXTRA_IDLE_TIME, idleTime);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcast(intent, BLUETOOTH_PERM);
    if (DBG) {
        Log.d(TAG, "Idle time (" + device + "): " + idleTime);
    }
}
#end_block

#method_before
@Override
protected void cleanup() {
    if (DBG) {
        Log.d(TAG, "cleanup()");
    }
    if (mConnectionStateChangedReceiver != null) {
        unregisterReceiver(mConnectionStateChangedReceiver);
        mConnectionStateChangedReceiver = null;
    }
    if (mBondStateChangedReceiver != null) {
        unregisterReceiver(mBondStateChangedReceiver);
        mBondStateChangedReceiver = null;
    }
    for (Iterator<Map.Entry<BluetoothDevice, A2dpStateMachine>> it = mStateMachines.entrySet().iterator(); it.hasNext(); ) {
        A2dpStateMachine sm = it.next().getValue();
        sm.cleanup();
        it.remove();
    }
    mA2dpNativeInterface.cleanup();
    if (mAvrcp != null) {
        mAvrcp.cleanup();
        mAvrcp = null;
    }
    // TODO: should be moved to stop()
    clearA2dpService();
}
#method_after
@Override
protected void cleanup() {
    if (DBG) {
        Log.d(TAG, "cleanup()");
    }
    if (mConnectionStateChangedReceiver != null) {
        unregisterReceiver(mConnectionStateChangedReceiver);
        mConnectionStateChangedReceiver = null;
    }
    if (mBondStateChangedReceiver != null) {
        unregisterReceiver(mBondStateChangedReceiver);
        mBondStateChangedReceiver = null;
    }
    for (Iterator<Map.Entry<BluetoothDevice, A2dpStateMachine>> it = mStateMachines.entrySet().iterator(); it.hasNext(); ) {
        A2dpStateMachine sm = it.next().getValue();
        sm.cleanup();
        it.remove();
    }
    mA2dpNativeInterface.cleanup();
    if (mAvrcp != null) {
        mAvrcp.cleanup();
        mAvrcp = null;
    }
    // TODO(b/72948646): should be moved to stop()
    setA2dpService(null);
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    stopService();
    mTargetContext.unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedQueue.clear();
    TestUtils.clearAdapterService(mAdapterService);
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_a2dp)) {
        return;
    }
    stopService();
    mTargetContext.unregisterReceiver(mConnectionStateChangedReceiver);
    mConnectionStateChangedQueue.clear();
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
@Override
protected void cleanup() {
    if (DBG) {
        Log.d(TAG, "cleanup()");
    }
    if (mNativeAvailable) {
        mHidDeviceNativeInterface.cleanup();
        mNativeAvailable = false;
    }
    // TODO: should be moved to stop()
    setHidDeviceService(null);
}
#method_after
@Override
protected void cleanup() {
    if (DBG) {
        Log.d(TAG, "cleanup()");
    }
    if (mNativeAvailable) {
        mHidDeviceNativeInterface.cleanup();
        mNativeAvailable = false;
    }
    // TODO(b/72948646): should be moved to stop()
    setHidDeviceService(null);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mTargetContext = InstrumentationRegistry.getTargetContext();
    Assume.assumeTrue("Ignore test when HealthService is not enabled", mTargetContext.getResources().getBoolean(R.bool.profile_supported_hdp));
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    TestUtils.startService(mServiceRule, HealthService.class);
    // Try getting the Bluetooth adapter
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    Assert.assertNotNull(mAdapter);
}
#method_after
@Before
public void setUp() throws Exception {
    mTargetContext = InstrumentationRegistry.getTargetContext();
    Assume.assumeTrue("Ignore test when HealthService is not enabled", mTargetContext.getResources().getBoolean(R.bool.profile_supported_hdp));
    MockitoAnnotations.initMocks(this);
    TestUtils.setAdapterService(mAdapterService);
    TestUtils.startService(mServiceRule, HealthService.class);
    mService = HealthService.getHealthService();
    Assert.assertNotNull(mService);
    // Try getting the Bluetooth adapter
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    Assert.assertNotNull(mAdapter);
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    TestUtils.stopService(mServiceRule, HealthService.class);
    mAdapter = null;
    TestUtils.clearAdapterService(mAdapterService);
}
#method_after
@After
public void tearDown() throws Exception {
    if (!mTargetContext.getResources().getBoolean(R.bool.profile_supported_hdp)) {
        return;
    }
    TestUtils.stopService(mServiceRule, HealthService.class);
    mService = HealthService.getHealthService();
    Assert.assertNull(mService);
    TestUtils.clearAdapterService(mAdapterService);
}
#end_block

#method_before
@Test
public void testInitialize() {
    // Test that we can initialize the service
    Log.i(TAG, "testInitialize, test passed");
}
#method_after
@Test
public void testInitialize() {
    Assert.assertNotNull(HealthService.getHealthService());
}
#end_block

#method_before
public int getCarrierPrivilegeStatus(PackageManager packageManager, String packageName) {
    try {
        // the package info with signatures.
        if (!hasCarrierPrivilegeRules()) {
            int state = mState.get();
            if (state == STATE_LOADING) {
                return TelephonyManager.CARRIER_PRIVILEGE_STATUS_RULES_NOT_LOADED;
            } else if (state == STATE_ERROR) {
                return TelephonyManager.CARRIER_PRIVILEGE_STATUS_ERROR_LOADING_RULES;
            }
            return TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS;
        }
        // Include DISABLED_UNTIL_USED components. This facilitates cases where a carrier app
        // is disabled by default, and some other component wants to enable it when it has
        // gained carrier privileges (as an indication that a matching SIM has been inserted).
        PackageInfo pInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS);
        return getCarrierPrivilegeStatus(pInfo);
    } catch (PackageManager.NameNotFoundException ex) {
    // Package does not exist, so by definition it has no access.
    }
    return TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS;
}
#method_after
public int getCarrierPrivilegeStatus(PackageManager packageManager, String packageName) {
    try {
        // the package info with signatures.
        if (!hasCarrierPrivilegeRules()) {
            int state = mState.get();
            if (state == STATE_LOADING) {
                return TelephonyManager.CARRIER_PRIVILEGE_STATUS_RULES_NOT_LOADED;
            } else if (state == STATE_ERROR) {
                return TelephonyManager.CARRIER_PRIVILEGE_STATUS_ERROR_LOADING_RULES;
            }
            return TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS;
        }
        // Include DISABLED_UNTIL_USED components. This facilitates cases where a carrier app
        // is disabled by default, and some other component wants to enable it when it has
        // gained carrier privileges (as an indication that a matching SIM has been inserted).
        PackageInfo pInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS);
        return getCarrierPrivilegeStatus(pInfo);
    } catch (PackageManager.NameNotFoundException ex) {
        log("Package " + packageName + " not found for carrier privilege status check");
    }
    return TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    super.setUp("SubscriptionControllerTest");
    mPhoneId = mPhone.getPhoneId();
    mBundle = mContextFixture.getCarrierConfigBundle();
    doReturn(mSubId).when(mSubscriptionController).getSubId(mPhoneId);
    doReturn(mSubscriptionController).when(mBinder).queryLocalInterface(anyString());
    mServiceManagerMockedServices.put("isub", mBinder);
    mImsManagerInstances.remove(mPhoneId);
}
#method_after
@Before
public void setUp() throws Exception {
    super.setUp("SubscriptionControllerTest");
    mPhoneId = mPhone.getPhoneId();
    mBundle = mContextFixture.getCarrierConfigBundle();
    doReturn(mSubId).when(mSubscriptionController).getSubId(mPhoneId);
    doReturn(mSubscriptionController).when(mBinder).queryLocalInterface(anyString());
    mServiceManagerMockedServices.put("isub", mBinder);
    mImsManagerInstances.remove(mPhoneId);
    setDefaultValues();
}
#end_block

#method_before
private void setDefaultValues() {
    mBundle.putBoolean(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL, ENHANCED_4G_ENABLE_DEFAULT_VAL);
    mBundle.putBoolean(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL, WFC_IMS_ENABLE_DEFAULT_VAL);
    mBundle.putBoolean(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL, WFC_IMS_ROAMING_ENABLE_DEFAULT_VAL);
    mBundle.putInt(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT, WFC_IMS_MODE_DEFAULT_VAL);
    mBundle.putInt(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT, WFC_IMS_ROAMING_MODE_DEFAULT_VAL);
    mBundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL, true);
}
#method_after
private void setDefaultValues() {
    mBundle.putBoolean(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL, ENHANCED_4G_ENABLE_DEFAULT_VAL);
    mBundle.putBoolean(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL, WFC_IMS_ENABLE_DEFAULT_VAL);
    mBundle.putBoolean(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL, WFC_IMS_ROAMING_ENABLE_DEFAULT_VAL);
    mBundle.putInt(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT, WFC_IMS_MODE_DEFAULT_VAL);
    mBundle.putInt(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT, WFC_IMS_ROAMING_MODE_DEFAULT_VAL);
    mBundle.putBoolean(CarrierConfigManager.KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL, ENHANCED_4G_MODE_DEFAULT_VAL);
    mBundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL, true);
}
#end_block

#method_before
@Test
@SmallTest
public void testGetDefaultValues() {
    doReturn("-1").when(mSubscriptionController).getSubscriptionProperty(anyInt(), anyString(), anyString());
    setDefaultValues();
    ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
    assertEquals(WFC_IMS_ENABLE_DEFAULT_VAL, imsManager.isWfcEnabledByUser());
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.WFC_IMS_ENABLED), anyString());
    assertEquals(ENHANCED_4G_ENABLE_DEFAULT_VAL, imsManager.isEnhanced4gLteModeSettingEnabledByUser());
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.ENHANCED_4G_MODE_ENABLED), anyString());
    assertEquals(WFC_IMS_MODE_DEFAULT_VAL, imsManager.getWfcMode(false));
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.WFC_IMS_MODE), anyString());
    assertEquals(WFC_IMS_ROAMING_MODE_DEFAULT_VAL, imsManager.getWfcMode(true));
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.WFC_IMS_ROAMING_MODE), anyString());
    assertEquals(VT_IMS_ENABLE_DEFAULT_VAL, imsManager.isVtEnabledByUser());
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.VT_IMS_ENABLED), anyString());
}
#method_after
@Test
@SmallTest
public void testGetDefaultValues() {
    doReturn("-1").when(mSubscriptionController).getSubscriptionProperty(anyInt(), anyString(), anyString());
    ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
    assertEquals(WFC_IMS_ENABLE_DEFAULT_VAL, imsManager.isWfcEnabledByUser());
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.WFC_IMS_ENABLED), anyString());
    assertEquals(ENHANCED_4G_ENABLE_DEFAULT_VAL, imsManager.isEnhanced4gLteModeSettingEnabledByUser());
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.ENHANCED_4G_MODE_ENABLED), anyString());
    assertEquals(WFC_IMS_MODE_DEFAULT_VAL, imsManager.getWfcMode(false));
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.WFC_IMS_MODE), anyString());
    assertEquals(WFC_IMS_ROAMING_MODE_DEFAULT_VAL, imsManager.getWfcMode(true));
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.WFC_IMS_ROAMING_MODE), anyString());
    assertEquals(VT_IMS_ENABLE_DEFAULT_VAL, imsManager.isVtEnabledByUser());
    verify(mSubscriptionController, times(1)).getSubscriptionProperty(anyInt(), eq(SubscriptionManager.VT_IMS_ENABLED), anyString());
}
#end_block

#method_before
@Test
@SmallTest
public void testSetValues() {
    ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
    imsManager.setWfcMode(ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.WFC_IMS_MODE), eq("1"));
    imsManager.setWfcMode(ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED, true);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.WFC_IMS_ROAMING_MODE), eq("1"));
    imsManager.setVtSetting(false);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.VT_IMS_ENABLED), eq("0"));
    imsManager.setEnhanced4gLteModeSetting(true);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.ENHANCED_4G_MODE_ENABLED), eq("1"));
    imsManager.setWfcSetting(true);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.WFC_IMS_ENABLED), eq("1"));
}
#method_after
@Test
@SmallTest
public void testSetValues() {
    ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
    imsManager.setWfcMode(ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.WFC_IMS_MODE), eq("1"));
    imsManager.setWfcMode(ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED, true);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.WFC_IMS_ROAMING_MODE), eq("1"));
    imsManager.setVtSetting(false);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.VT_IMS_ENABLED), eq("0"));
    // enhanced 4g mode must be editable to use setEnhanced4gLteModeSetting
    mBundle.putBoolean(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL, ENHANCED_4G_MODE_EDITABLE);
    imsManager.setEnhanced4gLteModeSetting(true);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.ENHANCED_4G_MODE_ENABLED), eq("1"));
    imsManager.setWfcSetting(true);
    verify(mSubscriptionController, times(1)).setSubscriptionProperty(eq(mSubId[0]), eq(SubscriptionManager.WFC_IMS_ENABLED), eq("1"));
}
#end_block

#method_before
@Test
public void testGetProvisionedValues() throws Exception {
    ImsManager imsManager = initializeProvisionedValues();
    assertEquals(true, imsManager.isWfcProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getProvisionedValue(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
    assertEquals(true, imsManager.isVtProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getProvisionedValue(eq(ImsConfig.ConfigConstants.LVC_SETTING_ENABLED));
    assertEquals(true, imsManager.isVolteProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getProvisionedValue(eq(ImsConfig.ConfigConstants.VLT_SETTING_ENABLED));
    // If we call get again, times should still be one because the value should be fetched
    // from cache.
    assertEquals(true, imsManager.isWfcProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getProvisionedValue(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
    assertEquals(true, imsManager.isVtProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getProvisionedValue(eq(ImsConfig.ConfigConstants.LVC_SETTING_ENABLED));
    assertEquals(true, imsManager.isVolteProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getProvisionedValue(eq(ImsConfig.ConfigConstants.VLT_SETTING_ENABLED));
}
#method_after
@Test
public void testGetProvisionedValues() throws Exception {
    ImsManager imsManager = initializeProvisionedValues();
    assertEquals(true, imsManager.isWfcProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getConfigInt(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
    assertEquals(true, imsManager.isVtProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getConfigInt(eq(ImsConfig.ConfigConstants.LVC_SETTING_ENABLED));
    assertEquals(true, imsManager.isVolteProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getConfigInt(eq(ImsConfig.ConfigConstants.VLT_SETTING_ENABLED));
    // If we call get again, times should still be one because the value should be fetched
    // from cache.
    assertEquals(true, imsManager.isWfcProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getConfigInt(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
    assertEquals(true, imsManager.isVtProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getConfigInt(eq(ImsConfig.ConfigConstants.LVC_SETTING_ENABLED));
    assertEquals(true, imsManager.isVolteProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getConfigInt(eq(ImsConfig.ConfigConstants.VLT_SETTING_ENABLED));
}
#end_block

#method_before
@Test
public void testSetProvisionedValues() throws Exception {
    ImsManager imsManager = initializeProvisionedValues();
    assertEquals(true, imsManager.isWfcProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getProvisionedValue(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
    imsManager.getConfigInterface().setProvisionedValue(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED, ImsConfig.FeatureValueConstants.OFF);
    assertEquals(0, (int) mProvisionedIntVals.get(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
    assertEquals(false, imsManager.isWfcProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).setProvisionedValue(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED), eq(0));
    verify(mImsConfigImplBaseMock, times(1)).getProvisionedValue(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
}
#method_after
@Test
public void testSetProvisionedValues() throws Exception {
    ImsManager imsManager = initializeProvisionedValues();
    assertEquals(true, imsManager.isWfcProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).getConfigInt(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
    imsManager.getConfigInterface().setProvisionedValue(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED, ImsConfig.FeatureValueConstants.OFF);
    assertEquals(0, (int) mProvisionedIntVals.get(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
    assertEquals(false, imsManager.isWfcProvisionedOnDevice());
    verify(mImsConfigImplBaseMock, times(1)).setConfig(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED), eq(0));
    verify(mImsConfigImplBaseMock, times(1)).getConfigInt(eq(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
}
#end_block

#method_before
private ImsManager initializeProvisionedValues() {
    try {
        when(mImsConfigImplBaseMock.getProvisionedValue(anyInt())).thenAnswer(invocation -> {
            return getProvisionedInt((Integer) (invocation.getArguments()[0]));
        });
        when(mImsConfigImplBaseMock.setProvisionedValue(anyInt(), anyInt())).thenAnswer(invocation -> {
            mProvisionedIntVals.put((Integer) (invocation.getArguments()[0]), (Integer) (invocation.getArguments()[1]));
            return ImsConfig.OperationStatusConstants.SUCCESS;
        });
        when(mImsConfigImplBaseMock.getProvisionedStringValue(anyInt())).thenAnswer(invocation -> {
            return getProvisionedString((Integer) (invocation.getArguments()[0]));
        });
        when(mImsConfigImplBaseMock.setProvisionedStringValue(anyInt(), anyString())).thenAnswer(invocation -> {
            mProvisionedStringVals.put((Integer) (invocation.getArguments()[0]), (String) (invocation.getArguments()[1]));
            return ImsConfig.OperationStatusConstants.SUCCESS;
        });
    } catch (RemoteException ex) {
        fail("initializeProvisionedValues failed with " + ex);
    }
    // Configure ImsConfigStub
    mImsConfigStub = new ImsConfigImplBase.ImsConfigStub(mImsConfigImplBaseMock);
    doReturn(mImsConfigStub).when(mImsConfigImplBaseMock).getIImsConfig();
    // Configure ImsConfig
    mImsConfig = new ImsConfig(mImsConfigStub, mContext);
    // Configure ImsManager
    ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
    try {
        replaceInstance(ImsManager.class, "mConfig", imsManager, mImsConfig);
    } catch (Exception ex) {
        fail("failed with " + ex);
    }
    return imsManager;
}
#method_after
private ImsManager initializeProvisionedValues() {
    when(mImsConfigImplBaseMock.getConfigInt(anyInt())).thenAnswer(invocation -> {
        return getProvisionedInt((Integer) (invocation.getArguments()[0]));
    });
    when(mImsConfigImplBaseMock.setConfig(anyInt(), anyInt())).thenAnswer(invocation -> {
        mProvisionedIntVals.put((Integer) (invocation.getArguments()[0]), (Integer) (invocation.getArguments()[1]));
        return ImsConfig.OperationStatusConstants.SUCCESS;
    });
    // Configure ImsConfigStub
    mImsConfigStub = new ImsConfigImplBase.ImsConfigStub(mImsConfigImplBaseMock);
    doReturn(mImsConfigStub).when(mImsConfigImplBaseMock).getIImsConfig();
    // Configure ImsConfig
    mImsConfig = new ImsConfig(mImsConfigStub, mContext);
    // Configure ImsManager
    ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
    try {
        replaceInstance(ImsManager.class, "mConfig", imsManager, mImsConfig);
    } catch (Exception ex) {
        fail("failed with " + ex);
    }
    return imsManager;
}
#end_block

#method_before
public boolean isImsUseEnabled() {
    boolean imsUseEnabled = ((ImsManager.isVolteEnabledByPlatform(mContext) && ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mContext)) || (ImsManager.isWfcEnabledByPlatform(mContext) && ImsManager.isWfcEnabledByUser(mContext)) && ImsManager.isNonTtyOrTtyOnVolteEnabled(mContext));
    return imsUseEnabled;
}
#method_after
public boolean isImsUseEnabled() {
    ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
    boolean imsUseEnabled = ((imsManager.isVolteEnabledByPlatform() && imsManager.isEnhanced4gLteModeSettingEnabledByUser()) || (imsManager.isWfcEnabledByPlatform() && imsManager.isWfcEnabledByUser()) && imsManager.isNonTtyOrTtyOnVolteEnabled());
    return imsUseEnabled;
}
#end_block

#method_before
public static void checkWfcWifiOnlyModeBeforeDial(Phone imsPhone, Context context) throws CallStateException {
    if (imsPhone == null || !imsPhone.isWifiCallingEnabled()) {
        boolean wfcWiFiOnly = (ImsManager.isWfcEnabledByPlatform(context) && ImsManager.isWfcEnabledByUser(context) && (ImsManager.getWfcMode(context) == ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY));
        if (wfcWiFiOnly) {
            throw new CallStateException(CallStateException.ERROR_OUT_OF_SERVICE, "WFC Wi-Fi Only Mode: IMS not registered");
        }
    }
}
#method_after
public static void checkWfcWifiOnlyModeBeforeDial(Phone imsPhone, int phoneId, Context context) throws CallStateException {
    if (imsPhone == null || !imsPhone.isWifiCallingEnabled()) {
        ImsManager imsManager = ImsManager.getInstance(context, phoneId);
        boolean wfcWiFiOnly = (imsManager.isWfcEnabledByPlatform() && imsManager.isWfcEnabledByUser() && (imsManager.getWfcMode() == ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY));
        if (wfcWiFiOnly) {
            throw new CallStateException(CallStateException.ERROR_OUT_OF_SERVICE, "WFC Wi-Fi Only Mode: IMS not registered");
        }
    }
}
#end_block

#method_before
public boolean isEnhanced4gLteModeSettingEnabledByUser() {
    // If user can't edit Enhanced 4G LTE Mode, it assumes Enhanced 4G LTE Mode is default
    // value.
    // If user changes SIM from editable mode to uneditable mode, need to return default value.
    int defaultValue = getBooleanCarrierConfig(CarrierConfigManager.KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
    if (!getBooleanCarrierConfig(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL)) {
        return (defaultValue == ImsConfig.FeatureValueConstants.ON);
    }
    int enabled = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, defaultValue);
    return (enabled == ImsConfig.FeatureValueConstants.ON);
}
#method_after
public boolean isEnhanced4gLteModeSettingEnabledByUser() {
    int setting = SubscriptionManager.getIntegerSubscriptionProperty(getSubId(), SubscriptionManager.ENHANCED_4G_MODE_ENABLED, SUB_PROPERTY_NOT_INITIALIZED, mContext);
    boolean onByDefault = getBooleanCarrierConfig(CarrierConfigManager.KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL);
    // If Enhanced 4G LTE Mode is uneditable or not initialized, we use the default value
    if (!getBooleanCarrierConfig(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL) || setting == SUB_PROPERTY_NOT_INITIALIZED) {
        return onByDefault;
    } else {
        return (setting == ImsConfig.FeatureValueConstants.ON);
    }
}
#end_block

#method_before
public void setEnhanced4gLteModeSetting(boolean enabled) {
    int value = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
    // If editable=false, we must keep default advanced 4G mode.
    if (!getBooleanCarrierConfig(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL)) {
        value = getBooleanCarrierConfig(CarrierConfigManager.KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
    }
    try {
        int prevSetting = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED);
        if (prevSetting == value) {
            // Don't trigger setAdvanced4GMode if the setting hasn't changed.
            return;
        }
    } catch (Settings.SettingNotFoundException e) {
    // Setting doesn't exist yet, so set it below.
    }
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED, value);
    if (isNonTtyOrTtyOnVolteEnabled()) {
        try {
            setAdvanced4GMode(value == ImsConfig.FeatureValueConstants.ON);
        } catch (ImsException ie) {
        // do nothing
        }
    }
}
#method_after
public void setEnhanced4gLteModeSetting(boolean enabled) {
    // If editable=false, we must keep default advanced 4G mode.
    if (!getBooleanCarrierConfig(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL)) {
        enabled = getBooleanCarrierConfig(CarrierConfigManager.KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL);
    }
    int prevSetting = SubscriptionManager.getIntegerSubscriptionProperty(getSubId(), SubscriptionManager.ENHANCED_4G_MODE_ENABLED, SUB_PROPERTY_NOT_INITIALIZED, mContext);
    if (prevSetting != (enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF)) {
        SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.ENHANCED_4G_MODE_ENABLED, booleanToPropertyString(enabled));
        if (isNonTtyOrTtyOnVolteEnabled()) {
            try {
                setAdvanced4GMode(enabled);
            } catch (ImsException ie) {
            // do nothing
            }
        }
    }
}
#end_block

#method_before
public boolean isVolteEnabledByPlatform() {
    int slotId = getSlotId();
    // doesn't exist, we use the hardcoded default value.
    if (SystemProperties.getInt(PROPERTY_DBG_VOLTE_AVAIL_OVERRIDE + Integer.toString(slotId), SystemProperties.getInt(PROPERTY_DBG_VOLTE_AVAIL_OVERRIDE, PROPERTY_DBG_VOLTE_AVAIL_OVERRIDE_DEFAULT)) == 1) {
        return true;
    }
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_device_volte_available) && getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_VOLTE_AVAILABLE_BOOL) && isGbaValid();
}
#method_after
public boolean isVolteEnabledByPlatform() {
    // doesn't exist, we use the hardcoded default value.
    if (SystemProperties.getInt(PROPERTY_DBG_VOLTE_AVAIL_OVERRIDE + Integer.toString(mPhoneId), SYSTEM_PROPERTY_NOT_SET) == 1 || SystemProperties.getInt(PROPERTY_DBG_VOLTE_AVAIL_OVERRIDE, SYSTEM_PROPERTY_NOT_SET) == 1) {
        return true;
    }
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_device_volte_available) && getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_VOLTE_AVAILABLE_BOOL) && isGbaValid();
}
#end_block

#method_before
public boolean isVtEnabledByPlatform() {
    int slotId = getSlotId();
    // doesn't exist, we use the hardcoded default value.
    if (SystemProperties.getInt(PROPERTY_DBG_VT_AVAIL_OVERRIDE + Integer.toString(slotId), SystemProperties.getInt(PROPERTY_DBG_VT_AVAIL_OVERRIDE, PROPERTY_DBG_VT_AVAIL_OVERRIDE_DEFAULT)) == 1) {
        return true;
    }
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_device_vt_available) && getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_VT_AVAILABLE_BOOL) && isGbaValid();
}
#method_after
public boolean isVtEnabledByPlatform() {
    // doesn't exist, we use the hardcoded default value.
    if (SystemProperties.getInt(PROPERTY_DBG_VT_AVAIL_OVERRIDE + Integer.toString(mPhoneId), SYSTEM_PROPERTY_NOT_SET) == 1 || SystemProperties.getInt(PROPERTY_DBG_VT_AVAIL_OVERRIDE, SYSTEM_PROPERTY_NOT_SET) == 1) {
        return true;
    }
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_device_vt_available) && getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_VT_AVAILABLE_BOOL) && isGbaValid();
}
#end_block

#method_before
public boolean isVtEnabledByUser() {
    int enabled = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.VT_IMS_ENABLED, ImsConfig.FeatureValueConstants.ON);
    return (enabled == 1);
}
#method_after
public boolean isVtEnabledByUser() {
    int setting = SubscriptionManager.getIntegerSubscriptionProperty(getSubId(), SubscriptionManager.VT_IMS_ENABLED, SUB_PROPERTY_NOT_INITIALIZED, mContext);
    // If it's never set, by default we return true.
    return (setting == SUB_PROPERTY_NOT_INITIALIZED || setting == 1);
}
#end_block

#method_before
public void setVtSetting(boolean enabled) {
    int value = enabled ? 1 : 0;
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.VT_IMS_ENABLED, value);
    try {
        ImsConfig config = getConfigInterface();
        config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, mImsConfigListener);
        if (enabled) {
            log("setVtSetting(b) : turnOnIms");
            turnOnIms();
        } else if (isVolteEnabledByPlatform() && (!isVolteEnabledByPlatform() || !isEnhanced4gLteModeSettingEnabledByUser())) {
            log("setVtSetting(b) : imsServiceAllowTurnOff -> turnOffIms");
            turnOffIms();
        }
    } catch (ImsException e) {
        loge("setVtSetting(b): ", e);
    }
}
#method_after
public void setVtSetting(boolean enabled) {
    SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.VT_IMS_ENABLED, booleanToPropertyString(enabled));
    try {
        changeMmTelCapability(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO, ImsRegistrationImplBase.REGISTRATION_TECH_LTE, enabled);
        if (enabled) {
            log("setVtSetting(b) : turnOnIms");
            turnOnIms();
        } else if (isVolteEnabledByPlatform() && (!isVolteEnabledByPlatform() || !isEnhanced4gLteModeSettingEnabledByUser())) {
            log("setVtSetting(b) : imsServiceAllowTurnOff -> turnOffIms");
            turnOffIms();
        }
    } catch (ImsException | RemoteException e) {
        // The ImsService is down. Since the SubscriptionManager already recorded the user's
        // preference, it will be resent in updateImsServiceConfig when the ImsPhoneCallTracker
        // reconnects.
        loge("setVtSetting(b): ", e);
    }
}
#end_block

#method_before
private boolean isTurnOffImsAllowedByPlatform() {
    int slotId = getSlotId();
    // doesn't exist, we use the hardcoded default value.
    if (SystemProperties.getInt(PROPERTY_DBG_ALLOW_IMS_OFF_OVERRIDE + Integer.toString(slotId), SystemProperties.getInt(PROPERTY_DBG_ALLOW_IMS_OFF_OVERRIDE, PROPERTY_DBG_ALLOW_IMS_OFF_OVERRIDE_DEFAULT)) == 1) {
        return true;
    }
    return getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_ALLOW_TURNOFF_IMS_BOOL);
}
#method_after
private boolean isTurnOffImsAllowedByPlatform() {
    // doesn't exist, we use the hardcoded default value.
    if (SystemProperties.getInt(PROPERTY_DBG_ALLOW_IMS_OFF_OVERRIDE + Integer.toString(mPhoneId), SYSTEM_PROPERTY_NOT_SET) == 1 || SystemProperties.getInt(PROPERTY_DBG_ALLOW_IMS_OFF_OVERRIDE, SYSTEM_PROPERTY_NOT_SET) == 1) {
        return true;
    }
    return getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_ALLOW_TURNOFF_IMS_BOOL);
}
#end_block

#method_before
public boolean isWfcEnabledByUser() {
    int enabled = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    return enabled == 1;
}
#method_after
public boolean isWfcEnabledByUser() {
    int setting = SubscriptionManager.getIntegerSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_ENABLED, SUB_PROPERTY_NOT_INITIALIZED, mContext);
    // SUB_PROPERTY_NOT_INITIALIZED indicates it's never set in sub db.
    if (setting == SUB_PROPERTY_NOT_INITIALIZED) {
        return getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL);
    } else {
        return setting == 1;
    }
}
#end_block

#method_before
public void setWfcSetting(boolean enabled) {
    int value = enabled ? 1 : 0;
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, value);
    setWfcNonPersistent(enabled, getWfcMode());
}
#method_after
public void setWfcSetting(boolean enabled) {
    SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_ENABLED, booleanToPropertyString(enabled));
    setWfcNonPersistent(enabled, getWfcMode());
}
#end_block

#method_before
public void setWfcNonPersistent(boolean enabled, int wfcMode) {
    int imsFeatureValue = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
    // Force IMS to register over LTE when turning off WFC
    int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
    try {
        ImsConfig config = getConfigInterface();
        config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, imsFeatureValue, mImsConfigListener);
        if (enabled) {
            log("setWfcSetting() : turnOnIms");
            turnOnIms();
        } else if (isTurnOffImsAllowedByPlatform() && (!isVolteEnabledByPlatform() || !isEnhanced4gLteModeSettingEnabledByUser())) {
            log("setWfcSetting() : imsServiceAllowTurnOff -> turnOffIms");
            turnOffIms();
        }
        setWfcModeInternal(imsWfcModeFeatureValue);
    } catch (ImsException e) {
        loge("setWfcSetting(): ", e);
    }
}
#method_after
public void setWfcNonPersistent(boolean enabled, int wfcMode) {
    // Force IMS to register over LTE when turning off WFC
    int imsWfcModeFeatureValue = enabled ? wfcMode : ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
    try {
        changeMmTelCapability(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE, ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, enabled);
        if (enabled) {
            log("setWfcSetting() : turnOnIms");
            turnOnIms();
        } else if (isTurnOffImsAllowedByPlatform() && (!isVolteEnabledByPlatform() || !isEnhanced4gLteModeSettingEnabledByUser())) {
            log("setWfcSetting() : imsServiceAllowTurnOff -> turnOffIms");
            turnOffIms();
        }
        setWfcModeInternal(imsWfcModeFeatureValue);
    } catch (ImsException | RemoteException e) {
        loge("setWfcSetting(): ", e);
    }
}
#end_block

#method_before
public int getWfcMode() {
    int setting = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_MODE, getIntCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT));
    if (DBG)
        log("getWfcMode - setting=" + setting);
    return setting;
}
#method_after
public int getWfcMode() {
    return getWfcMode(false);
}
#end_block

#method_before
public void setWfcMode(int wfcMode) {
    if (DBG)
        log("setWfcMode(i) - setting=" + wfcMode);
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_MODE, wfcMode);
    setWfcModeInternal(wfcMode);
}
#method_after
public void setWfcMode(int wfcMode) {
    if (DBG)
        log("setWfcMode(i) - setting=" + wfcMode);
    SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_MODE, Integer.toString(wfcMode));
    setWfcModeInternal(wfcMode);
}
#end_block

#method_before
public int getWfcMode(boolean roaming) {
    int setting = 0;
    if (!roaming) {
        setting = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_MODE, getIntCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT));
        if (DBG)
            log("getWfcMode - setting=" + setting);
    } else {
        setting = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ROAMING_MODE, getIntCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT));
        if (DBG)
            log("getWfcMode (roaming) - setting=" + setting);
    }
    return setting;
}
#method_after
public int getWfcMode(boolean roaming) {
    int setting = 0;
    if (!roaming) {
        setting = SubscriptionManager.getIntegerSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_MODE, SUB_PROPERTY_NOT_INITIALIZED, mContext);
        // SUB_PROPERTY_NOT_INITIALIZED indicates it's never set in sub db.
        if (setting == SUB_PROPERTY_NOT_INITIALIZED) {
            setting = getIntCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT);
        }
        if (DBG)
            log("getWfcMode - setting=" + setting);
    } else {
        setting = SubscriptionManager.getIntegerSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_ROAMING_MODE, SUB_PROPERTY_NOT_INITIALIZED, mContext);
        // SUB_PROPERTY_NOT_INITIALIZED indicates it's never set in sub db.
        if (setting == SUB_PROPERTY_NOT_INITIALIZED) {
            setting = getIntCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT);
        }
        if (DBG)
            log("getWfcMode (roaming) - setting=" + setting);
    }
    return setting;
}
#end_block

#method_before
public void setWfcMode(int wfcMode, boolean roaming) {
    if (!roaming) {
        if (DBG)
            log("setWfcMode(i,b) - setting=" + wfcMode);
        android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_MODE, wfcMode);
    } else {
        if (DBG)
            log("setWfcMode(i,b) (roaming) - setting=" + wfcMode);
        android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ROAMING_MODE, wfcMode);
    }
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    if (roaming == tm.isNetworkRoaming(getSubId())) {
        setWfcModeInternal(wfcMode);
    }
}
#method_after
public void setWfcMode(int wfcMode, boolean roaming) {
    if (!roaming) {
        if (DBG)
            log("setWfcMode(i,b) - setting=" + wfcMode);
        SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_MODE, Integer.toString(wfcMode));
    } else {
        if (DBG)
            log("setWfcMode(i,b) (roaming) - setting=" + wfcMode);
        SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_ROAMING_MODE, Integer.toString(wfcMode));
    }
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    if (roaming == tm.isNetworkRoaming(getSubId())) {
        setWfcModeInternal(wfcMode);
    }
}
#end_block

#method_before
private static void setWfcModeInternal(Context context, int wfcMode) {
    final ImsManager imsManager = ImsManager.getInstance(context, SubscriptionManager.getDefaultVoicePhoneId());
    if (imsManager != null) {
        final int value = wfcMode;
        Thread thread = new Thread(new Runnable() {

            public void run() {
                try {
                    imsManager.getConfigInterface().setProvisionedValue(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_MODE, value);
                } catch (ImsException e) {
                // do nothing
                }
            }
        });
        thread.start();
    }
}
#method_after
private static void setWfcModeInternal(Context context, int wfcMode) {
    final ImsManager imsManager = ImsManager.getInstance(context, SubscriptionManager.getDefaultVoicePhoneId());
    if (imsManager != null) {
        final int value = wfcMode;
        Thread thread = new Thread(new Runnable() {

            public void run() {
                try {
                    imsManager.getConfigInterface().setConfig(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_MODE, value);
                } catch (ImsException e) {
                // do nothing
                }
            }
        });
        thread.start();
    }
}
#end_block

#method_before
private void setWfcModeInternal(int wfcMode) {
    final int value = wfcMode;
    Thread thread = new Thread(() -> {
        try {
            getConfigInterface().setProvisionedValue(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_MODE, value);
        } catch (ImsException e) {
        // do nothing
        }
    });
    thread.start();
}
#method_after
private void setWfcModeInternal(int wfcMode) {
    final int value = wfcMode;
    Thread thread = new Thread(() -> {
        try {
            getConfigInterface().setConfig(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_MODE, value);
        } catch (ImsException e) {
        // do nothing
        }
    });
    thread.start();
}
#end_block

#method_before
public boolean isWfcRoamingEnabledByUser() {
    int enabled = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    return (enabled == 1);
}
#method_after
public boolean isWfcRoamingEnabledByUser() {
    int setting = SubscriptionManager.getIntegerSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_ROAMING_ENABLED, SUB_PROPERTY_NOT_INITIALIZED, mContext);
    if (setting == SUB_PROPERTY_NOT_INITIALIZED) {
        return getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL);
    } else {
        return (setting == 1);
    }
}
#end_block

#method_before
public void setWfcRoamingSetting(boolean enabled) {
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED, enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    setWfcRoamingSettingInternal(enabled);
}
#method_after
public void setWfcRoamingSetting(boolean enabled) {
    SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_ROAMING_ENABLED, booleanToPropertyString(enabled));
    setWfcRoamingSettingInternal(enabled);
}
#end_block

#method_before
private void setWfcRoamingSettingInternal(boolean enabled) {
    final int value = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
    Thread thread = new Thread(() -> {
        try {
            getConfigInterface().setProvisionedValue(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_ROAMING, value);
        } catch (ImsException e) {
        // do nothing
        }
    });
    thread.start();
}
#method_after
private void setWfcRoamingSettingInternal(boolean enabled) {
    final int value = enabled ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF;
    Thread thread = new Thread(() -> {
        try {
            getConfigInterface().setConfig(ImsConfig.ConfigConstants.VOICE_OVER_WIFI_ROAMING, value);
        } catch (ImsException e) {
        // do nothing
        }
    });
    thread.start();
}
#end_block

#method_before
public boolean isWfcEnabledByPlatform() {
    int slotId = getSlotId();
    // doesn't exist, we use the hardcoded default value.
    if (SystemProperties.getInt(PROPERTY_DBG_WFC_AVAIL_OVERRIDE + Integer.toString(slotId), SystemProperties.getInt(PROPERTY_DBG_WFC_AVAIL_OVERRIDE, PROPERTY_DBG_WFC_AVAIL_OVERRIDE_DEFAULT)) == 1) {
        return true;
    }
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_device_wfc_ims_available) && getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_WFC_IMS_AVAILABLE_BOOL) && isGbaValid();
}
#method_after
public boolean isWfcEnabledByPlatform() {
    // doesn't exist, we use the hardcoded default value.
    if (SystemProperties.getInt(PROPERTY_DBG_WFC_AVAIL_OVERRIDE + Integer.toString(mPhoneId), SYSTEM_PROPERTY_NOT_SET) == 1 || SystemProperties.getInt(PROPERTY_DBG_WFC_AVAIL_OVERRIDE, SYSTEM_PROPERTY_NOT_SET) == 1) {
        return true;
    }
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_device_wfc_ims_available) && getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_WFC_IMS_AVAILABLE_BOOL) && isGbaValid();
}
#end_block

#method_before
private boolean getProvisionedBool(ImsConfig config, int item) throws ImsException {
    int value = config.getProvisionedValue(item);
    if (value == ImsConfig.FeatureValueConstants.ERROR) {
        throw new ImsException("getProvisionedBool failed with error for item: " + item, ImsReasonInfo.CODE_LOCAL_INTERNAL_ERROR);
    }
    return config.getProvisionedValue(item) == ImsConfig.FeatureValueConstants.ON;
}
#method_after
private boolean getProvisionedBool(ImsConfig config, int item) throws ImsException {
    int value = config.getProvisionedValue(item);
    if (value == ImsConfig.OperationStatusConstants.UNKNOWN) {
        throw new ImsException("getProvisionedBool failed with error for item: " + item, ImsReasonInfo.CODE_LOCAL_INTERNAL_ERROR);
    }
    return config.getProvisionedValue(item) == ImsConfig.FeatureValueConstants.ON;
}
#end_block

#method_before
private boolean getProvisionedBoolNoException(int item) {
    try {
        ImsConfig config = getConfigInterface();
        int value = config.getProvisionedValue(item);
        return value == ImsConfig.FeatureValueConstants.ON;
    } catch (ImsException ex) {
        return false;
    }
}
#method_after
private boolean getProvisionedBoolNoException(int item) {
    try {
        ImsConfig config = getConfigInterface();
        return getProvisionedBool(config, item);
    } catch (ImsException ex) {
        return false;
    }
}
#end_block

#method_before
public void updateImsServiceConfig(boolean force) {
    if (!force) {
        TelephonyManager tm = new TelephonyManager(mContext, getSubId());
        if (tm.getSimState() != TelephonyManager.SIM_STATE_READY) {
            log("updateImsServiceConfig: SIM not ready");
            // Don't disable IMS if SIM is not ready
            return;
        }
    }
    if (!mConfigUpdated || force) {
        try {
            updateProvisionedValues();
            // TODO: Extend ImsConfig API and set all feature values in single function call.
            // Note: currently the order of updates is set to produce different order of
            // setFeatureValue() function calls from setAdvanced4GMode(). This is done to
            // differentiate this code path from vendor code perspective.
            boolean isImsUsed = updateVolteFeatureValue();
            isImsUsed |= updateWfcFeatureAndProvisionedValues();
            isImsUsed |= updateVideoCallFeatureValue();
            if (isImsUsed || !isTurnOffImsAllowedByPlatform()) {
                // Turn on IMS if it is used.
                // Also, if turning off is not allowed for current carrier,
                // we need to turn IMS on because it might be turned off before
                // phone switched to current carrier.
                log("updateImsServiceConfig: turnOnIms");
                turnOnIms();
            } else {
                // Turn off IMS if it is not used AND turning off is allowed for carrier.
                log("updateImsServiceConfig: turnOffIms");
                turnOffIms();
            }
            mConfigUpdated = true;
        } catch (ImsException e) {
            loge("updateImsServiceConfig: ", e);
            mConfigUpdated = false;
        }
    }
}
#method_after
public void updateImsServiceConfig(boolean force) {
    if (!force) {
        TelephonyManager tm = new TelephonyManager(mContext, getSubId());
        if (tm.getSimState() != TelephonyManager.SIM_STATE_READY) {
            log("updateImsServiceConfig: SIM not ready");
            // Don't disable IMS if SIM is not ready
            return;
        }
    }
    if (!mConfigUpdated || force) {
        try {
            // TODO: Extend ImsConfig API and set all feature values in single function call.
            // Note: currently the order of updates is set to produce different order of
            // changeEnabledCapabilities() function calls from setAdvanced4GMode(). This is done
            // to differentiate this code path from vendor code perspective.
            boolean isImsUsed = updateVolteFeatureValue();
            isImsUsed |= updateWfcFeatureAndProvisionedValues();
            isImsUsed |= updateVideoCallFeatureValue();
            if (isImsUsed || !isTurnOffImsAllowedByPlatform()) {
                // Turn on IMS if it is used.
                // Also, if turning off is not allowed for current carrier,
                // we need to turn IMS on because it might be turned off before
                // phone switched to current carrier.
                log("updateImsServiceConfig: turnOnIms");
                turnOnIms();
            } else {
                // Turn off IMS if it is not used AND turning off is allowed for carrier.
                log("updateImsServiceConfig: turnOffIms");
                turnOffIms();
            }
            mConfigUpdated = true;
        } catch (ImsException | RemoteException e) {
            loge("updateImsServiceConfig: ", e);
            mConfigUpdated = false;
        }
    }
}
#end_block

#method_before
private boolean updateVolteFeatureValue() throws ImsException {
    boolean available = isVolteEnabledByPlatform();
    boolean enabled = isEnhanced4gLteModeSettingEnabledByUser();
    boolean isNonTty = isNonTtyOrTtyOnVolteEnabled();
    boolean isFeatureOn = available && enabled && isNonTty;
    log("updateVolteFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, mImsConfigListener);
    return isFeatureOn;
}
#method_after
private boolean updateVolteFeatureValue() throws RemoteException {
    boolean available = isVolteEnabledByPlatform();
    boolean enabled = isEnhanced4gLteModeSettingEnabledByUser();
    boolean isNonTty = isNonTtyOrTtyOnVolteEnabled();
    boolean isFeatureOn = available && enabled && isNonTty;
    log("updateVolteFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty);
    changeMmTelCapability(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE, ImsRegistrationImplBase.REGISTRATION_TECH_LTE, isFeatureOn);
    return isFeatureOn;
}
#end_block

#method_before
private boolean updateVideoCallFeatureValue() throws ImsException {
    boolean available = isVtEnabledByPlatform();
    boolean enabled = isVtEnabledByUser();
    boolean isNonTty = isNonTtyOrTtyOnVolteEnabled();
    boolean isDataEnabled = isDataEnabled();
    boolean ignoreDataEnabledChanged = getBooleanCarrierConfig(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
    boolean isFeatureOn = available && enabled && isNonTty && (ignoreDataEnabledChanged || isDataEnabled);
    log("updateVideoCallFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty + ", data enabled = " + isDataEnabled);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, mImsConfigListener);
    return isFeatureOn;
}
#method_after
private boolean updateVideoCallFeatureValue() throws RemoteException {
    boolean available = isVtEnabledByPlatform();
    boolean enabled = isVtEnabledByUser();
    boolean isNonTty = isNonTtyOrTtyOnVolteEnabled();
    boolean isDataEnabled = isDataEnabled();
    boolean ignoreDataEnabledChanged = getBooleanCarrierConfig(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
    boolean isFeatureOn = available && enabled && isNonTty && (ignoreDataEnabledChanged || isDataEnabled);
    log("updateVideoCallFeatureValue: available = " + available + ", enabled = " + enabled + ", nonTTY = " + isNonTty + ", data enabled = " + isDataEnabled);
    changeMmTelCapability(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO, ImsRegistrationImplBase.REGISTRATION_TECH_LTE, isFeatureOn);
    return isFeatureOn;
}
#end_block

#method_before
private boolean updateWfcFeatureAndProvisionedValues() throws ImsException {
    TelephonyManager tm = new TelephonyManager(mContext, getSubId());
    boolean isNetworkRoaming = tm.isNetworkRoaming();
    boolean available = isWfcEnabledByPlatform();
    boolean enabled = isWfcEnabledByUser();
    updateDefaultWfcMode();
    int mode = getWfcMode(isNetworkRoaming);
    boolean roaming = isWfcRoamingEnabledByUser();
    boolean isFeatureOn = available && enabled;
    log("updateWfcFeatureAndProvisionedValues: available = " + available + ", enabled = " + enabled + ", mode = " + mode + ", roaming = " + roaming);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, mImsConfigListener);
    if (!isFeatureOn) {
        mode = ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
        roaming = false;
    }
    setWfcModeInternal(mContext, mode);
    setWfcRoamingSettingInternal(roaming);
    return isFeatureOn;
}
#method_after
private boolean updateWfcFeatureAndProvisionedValues() throws RemoteException {
    TelephonyManager tm = new TelephonyManager(mContext, getSubId());
    boolean isNetworkRoaming = tm.isNetworkRoaming();
    boolean available = isWfcEnabledByPlatform();
    boolean enabled = isWfcEnabledByUser();
    updateDefaultWfcMode();
    int mode = getWfcMode(isNetworkRoaming);
    boolean roaming = isWfcRoamingEnabledByUser();
    boolean isFeatureOn = available && enabled;
    log("updateWfcFeatureAndProvisionedValues: available = " + available + ", enabled = " + enabled + ", mode = " + mode + ", roaming = " + roaming);
    changeMmTelCapability(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE, ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN, isFeatureOn);
    if (!isFeatureOn) {
        mode = ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
        roaming = false;
    }
    setWfcModeInternal(mContext, mode);
    setWfcRoamingSettingInternal(roaming);
    return isFeatureOn;
}
#end_block

#method_before
public boolean isServiceAvailable() {
    connectIfServiceIsAvailable();
    // mImsServiceProxy will always create an ImsServiceProxy.
    return mImsServiceProxy.isBinderAlive();
}
#method_after
public boolean isServiceAvailable() {
    connectIfServiceIsAvailable();
    // mImsServiceProxy will always create an ImsServiceProxy.
    return mMmTelFeatureConnection.isBinderAlive();
}
#end_block

#method_before
public boolean isServiceReady() {
    connectIfServiceIsAvailable();
    return mImsServiceProxy.isBinderReady();
}
#method_after
public boolean isServiceReady() {
    connectIfServiceIsAvailable();
    return mMmTelFeatureConnection.isBinderReady();
}
#end_block

#method_before
public void connectIfServiceIsAvailable() {
    if (mImsServiceProxy == null || !mImsServiceProxy.isBinderAlive()) {
        createImsService();
    }
}
#method_after
public void connectIfServiceIsAvailable() {
    if (mMmTelFeatureConnection == null || !mMmTelFeatureConnection.isBinderAlive()) {
        createImsService();
    }
}
#end_block

#method_before
public void addNotifyStatusChangedCallbackIfAvailable(ImsServiceProxy.INotifyStatusChanged c) throws ImsException {
    if (!mImsServiceProxy.isBinderAlive()) {
        throw new ImsException("Binder is not active!", ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    if (c != null) {
        mStatusCallbacks.add(c);
    }
}
#method_after
public void addNotifyStatusChangedCallbackIfAvailable(MmTelFeatureConnection.IFeatureUpdate c) throws ImsException {
    if (!mMmTelFeatureConnection.isBinderAlive()) {
        throw new ImsException("Binder is not active!", ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    if (c != null) {
        mStatusCallbacks.add(c);
    }
}
#end_block

#method_before
public int open(int serviceClass, PendingIntent incomingCallPendingIntent, ImsConnectionStateListener listener) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    if (incomingCallPendingIntent == null) {
        throw new NullPointerException("incomingCallPendingIntent can't be null");
    }
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    int result = 0;
    try {
        // Register a stub implementation of the ImsRegistrationListener. There is the
        // possibility that if we use the real implementation of the ImsRegistrationListener,
        // it will be added twice.
        // TODO: Remove ImsRegistrationListener from startSession API (b/62588776)
        result = mImsServiceProxy.startSession(incomingCallPendingIntent, new ImsRegistrationListenerBase());
        addRegistrationListener(listener);
        log("open: Session started and registration listener added.");
    } catch (RemoteException e) {
        throw new ImsException("open()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    if (result <= 0) {
        // So, it needs to convert to the reason code specified in ImsReasonInfo.
        throw new ImsException("open()", (result * (-1)));
    }
    return result;
}
#method_after
public void open(MmTelFeature.Listener listener) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    try {
        mMmTelFeatureConnection.openConnection(listener);
    } catch (RemoteException e) {
        throw new ImsException("open()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
public void addRegistrationListener(ImsConnectionStateListener listener) throws ImsException {
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    // We only want this Proxy registered once.
    synchronized (mHasRegisteredLock) {
        if (!mHasRegisteredForProxy) {
            try {
                checkAndThrowExceptionIfServiceUnavailable();
                mImsServiceProxy.addRegistrationListener(mRegistrationListenerProxy);
                log("RegistrationListenerProxy registered.");
                // Only record if there isn't a RemoteException.
                mHasRegisteredForProxy = true;
            } catch (RemoteException e) {
                throw new ImsException("addRegistrationListener()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
            }
        }
    }
    synchronized (mRegistrationListeners) {
        log("Local registration listener added: " + listener);
        mRegistrationListeners.add(listener);
    }
}
#method_after
public void addRegistrationListener(ImsConnectionStateListener listener) throws ImsException {
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    addRegistrationCallback(listener);
    // connect the ImsConnectionStateListener to the new CapabilityCallback.
    addCapabilitiesCallback(new ImsFeature.CapabilityCallback() {

        @Override
        public void onCapabilitiesStatusChanged(ImsFeature.Capabilities config) {
            listener.onFeatureCapabilityChangedAdapter(getRegistrationTech(), config);
        }
    });
    log("Registration Callback registered.");
}
#end_block

#method_before
public void removeRegistrationListener(ImsConnectionStateListener listener) throws ImsException {
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    synchronized (mRegistrationListeners) {
        log("Local registration listener removed: " + listener);
        mRegistrationListeners.remove(listener);
    }
}
#method_after
public void removeRegistrationListener(ImsConnectionStateListener listener) throws ImsException {
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        mMmTelFeatureConnection.removeRegistrationCallback(listener);
        log("Registration Callback/Listener registered.");
    // Only record if there isn't a RemoteException.
    } catch (RemoteException e) {
        throw new ImsException("addRegistrationCallback()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
public void close(int sessionId) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        mImsServiceProxy.endSession(sessionId);
    } catch (RemoteException e) {
        throw new ImsException("close()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    } finally {
        mUt = null;
        mConfig = null;
        mEcbm = null;
        mMultiEndpoint = null;
    }
}
#method_after
public void close() {
    if (mMmTelFeatureConnection != null) {
        mMmTelFeatureConnection.closeConnection();
    }
    mUt = null;
    mConfig = null;
    mEcbm = null;
    mMultiEndpoint = null;
}
#end_block

#method_before
public ImsUtInterface getSupplementaryServiceConfiguration() throws ImsException {
    // FIXME: manage the multiple Ut interfaces based on the session id
    if (mUt != null && mUt.isBinderAlive()) {
        return mUt;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsUt iUt = mImsServiceProxy.getUtInterface();
        if (iUt == null) {
            throw new ImsException("getSupplementaryServiceConfiguration()", ImsReasonInfo.CODE_UT_NOT_SUPPORTED);
        }
        mUt = new ImsUt(iUt);
    } catch (RemoteException e) {
        throw new ImsException("getSupplementaryServiceConfiguration()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mUt;
}
#method_after
public ImsUtInterface getSupplementaryServiceConfiguration() throws ImsException {
    // FIXME: manage the multiple Ut interfaces based on the session id
    if (mUt != null && mUt.isBinderAlive()) {
        return mUt;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsUt iUt = mMmTelFeatureConnection.getUtInterface();
        if (iUt == null) {
            throw new ImsException("getSupplementaryServiceConfiguration()", ImsReasonInfo.CODE_UT_NOT_SUPPORTED);
        }
        mUt = new ImsUt(iUt);
    } catch (RemoteException e) {
        throw new ImsException("getSupplementaryServiceConfiguration()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mUt;
}
#end_block

#method_before
public ImsCallProfile createCallProfile(int sessionId, int serviceType, int callType) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        return mImsServiceProxy.createCallProfile(sessionId, serviceType, callType);
    } catch (RemoteException e) {
        throw new ImsException("createCallProfile()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
public ImsCallProfile createCallProfile(int serviceType, int callType) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        return mMmTelFeatureConnection.createCallProfile(serviceType, callType);
    } catch (RemoteException e) {
        throw new ImsException("createCallProfile()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
public ImsCall makeCall(int sessionId, ImsCallProfile profile, String[] callees, ImsCall.Listener listener) throws ImsException {
    if (DBG) {
        log("makeCall :: sessionId=" + sessionId + ", profile=" + profile);
    }
    checkAndThrowExceptionIfServiceUnavailable();
    ImsCall call = new ImsCall(mContext, profile);
    call.setListener(listener);
    ImsCallSession session = createCallSession(sessionId, profile);
    if ((callees != null) && (callees.length == 1)) {
        call.start(session, callees[0]);
    } else {
        call.start(session, callees);
    }
    return call;
}
#method_after
public ImsCall makeCall(ImsCallProfile profile, String[] callees, ImsCall.Listener listener) throws ImsException {
    if (DBG) {
        log("makeCall :: profile=" + profile);
    }
    checkAndThrowExceptionIfServiceUnavailable();
    ImsCall call = new ImsCall(mContext, profile);
    call.setListener(listener);
    ImsCallSession session = createCallSession(profile);
    if ((callees != null) && (callees.length == 1)) {
        call.start(session, callees[0]);
    } else {
        call.start(session, callees);
    }
    return call;
}
#end_block

#method_before
public ImsCall takeCall(int sessionId, Intent incomingCallIntent, ImsCall.Listener listener) throws ImsException {
    if (DBG) {
        log("takeCall :: sessionId=" + sessionId + ", incomingCall=" + incomingCallIntent);
    }
    checkAndThrowExceptionIfServiceUnavailable();
    if (incomingCallIntent == null) {
        throw new ImsException("Can't retrieve session with null intent", ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
    }
    int incomingServiceId = getImsSessionId(incomingCallIntent);
    if (sessionId != incomingServiceId) {
        throw new ImsException("Service id is mismatched in the incoming call intent", ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
    }
    String callId = getCallId(incomingCallIntent);
    if (callId == null) {
        throw new ImsException("Call ID missing in the incoming call intent", ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
    }
    try {
        IImsCallSession session = mImsServiceProxy.getPendingCallSession(sessionId, callId);
        if (session == null) {
            throw new ImsException("No pending session for the call", ImsReasonInfo.CODE_LOCAL_NO_PENDING_CALL);
        }
        ImsCall call = new ImsCall(mContext, session.getCallProfile());
        call.attachSession(new ImsCallSession(session));
        call.setListener(listener);
        return call;
    } catch (Throwable t) {
        throw new ImsException("takeCall()", t, ImsReasonInfo.CODE_UNSPECIFIED);
    }
}
#method_after
public ImsCall takeCall(IImsCallSession session, Bundle incomingCallExtras, ImsCall.Listener listener) throws ImsException {
    if (DBG) {
        log("takeCall :: incomingCall=" + incomingCallExtras);
    }
    checkAndThrowExceptionIfServiceUnavailable();
    if (incomingCallExtras == null) {
        throw new ImsException("Can't retrieve session with null intent", ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
    }
    String callId = getCallId(incomingCallExtras);
    if (callId == null) {
        throw new ImsException("Call ID missing in the incoming call intent", ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
    }
    try {
        if (session == null) {
            throw new ImsException("No pending session for the call", ImsReasonInfo.CODE_LOCAL_NO_PENDING_CALL);
        }
        ImsCall call = new ImsCall(mContext, session.getCallProfile());
        call.attachSession(new ImsCallSession(session));
        call.setListener(listener);
        return call;
    } catch (Throwable t) {
        throw new ImsException("takeCall()", t, ImsReasonInfo.CODE_UNSPECIFIED);
    }
}
#end_block

#method_before
public ImsConfig getConfigInterface() throws ImsException {
    if (mConfig != null && mConfig.isBinderAlive()) {
        return mConfig;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsConfig config = mImsServiceProxy.getConfigInterface();
        if (config == null) {
            throw new ImsException("getConfigInterface()", ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
        }
        mConfig = new ImsConfig(config, mContext);
    } catch (RemoteException e) {
        throw new ImsException("getConfigInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mConfig;
}
#method_after
public ImsConfig getConfigInterface() throws ImsException {
    if (mConfig != null && mConfig.isBinderAlive()) {
        return mConfig;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsConfig config = mMmTelFeatureConnection.getConfigInterface();
        if (config == null) {
            throw new ImsException("getConfigInterface()", ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
        }
        mConfig = new ImsConfig(config, mContext);
    } catch (RemoteException e) {
        throw new ImsException("getConfigInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mConfig;
}
#end_block

#method_before
public void setUiTTYMode(Context context, int uiTtyMode, Message onComplete) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        mImsServiceProxy.setUiTTYMode(uiTtyMode, onComplete);
    } catch (RemoteException e) {
        throw new ImsException("setTTYMode()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
public void setUiTTYMode(Context context, int uiTtyMode, Message onComplete) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        mMmTelFeatureConnection.setUiTTYMode(uiTtyMode, onComplete);
    } catch (RemoteException e) {
        throw new ImsException("setTTYMode()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
private static String getCallId(Intent incomingCallIntent) {
    if (incomingCallIntent == null) {
        return null;
    }
    return incomingCallIntent.getStringExtra(EXTRA_CALL_ID);
}
#method_after
private static String getCallId(Bundle incomingCallExtras) {
    if (incomingCallExtras == null) {
        return null;
    }
    return incomingCallExtras.getString(EXTRA_CALL_ID);
}
#end_block

#method_before
private void checkAndThrowExceptionIfServiceUnavailable() throws ImsException {
    if (mImsServiceProxy == null || !mImsServiceProxy.isBinderAlive()) {
        createImsService();
        if (mImsServiceProxy == null) {
            throw new ImsException("Service is unavailable", ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
}
#method_after
private void checkAndThrowExceptionIfServiceUnavailable() throws ImsException {
    if (mMmTelFeatureConnection == null || !mMmTelFeatureConnection.isBinderAlive()) {
        createImsService();
        if (mMmTelFeatureConnection == null) {
            throw new ImsException("Service is unavailable", ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
}
#end_block

#method_before
private void createImsService() {
    if (!mConfigDynamicBind) {
        // Old method of binding
        Rlog.i(TAG, "Creating ImsService using ServiceManager");
        mImsServiceProxy = getServiceProxyCompat();
    } else {
        Rlog.i(TAG, "Creating ImsService using ImsResolver");
        mImsServiceProxy = getServiceProxy();
    }
    // We have created a new ImsService connection, signal for re-registration
    synchronized (mHasRegisteredLock) {
        mHasRegisteredForProxy = false;
    }
}
#method_after
private void createImsService() {
    Rlog.i(TAG, "Creating ImsService");
    mMmTelFeatureConnection = MmTelFeatureConnection.create(mContext, mPhoneId);
    // Forwarding interface to tell mStatusCallbacks that the Proxy is unavailable.
    mMmTelFeatureConnection.setStatusCallback(new MmTelFeatureConnection.IFeatureUpdate() {

        @Override
        public void notifyStateChanged() {
            mStatusCallbacks.forEach(MmTelFeatureConnection.IFeatureUpdate::notifyStateChanged);
        }

        @Override
        public void notifyUnavailable() {
            mStatusCallbacks.forEach(MmTelFeatureConnection.IFeatureUpdate::notifyUnavailable);
        }
    });
}
#end_block

#method_before
private ImsCallSession createCallSession(int serviceId, ImsCallProfile profile) throws ImsException {
    try {
        // Throws an exception if the ImsService Feature is not ready to accept commands.
        return new ImsCallSession(mImsServiceProxy.createCallSession(serviceId, profile, null));
    } catch (RemoteException e) {
        Rlog.w(TAG, "CreateCallSession: Error, remote exception: " + e.getMessage());
        throw new ImsException("createCallSession()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
private ImsCallSession createCallSession(ImsCallProfile profile) throws ImsException {
    try {
        // Throws an exception if the ImsService Feature is not ready to accept commands.
        return new ImsCallSession(mMmTelFeatureConnection.createCallSession(profile));
    } catch (RemoteException e) {
        Rlog.w(TAG, "CreateCallSession: Error, remote exception: " + e.getMessage());
        throw new ImsException("createCallSession()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
private void turnOnIms() throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        mImsServiceProxy.turnOnIms();
    } catch (RemoteException e) {
        throw new ImsException("turnOnIms() ", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
private void turnOnIms() throws ImsException {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    tm.enableIms(mPhoneId);
}
#end_block

#method_before
private void setLteFeatureValues(boolean turnOn) {
    log("setLteFeatureValues: " + turnOn);
    try {
        ImsConfig config = getConfigInterface();
        if (config != null) {
            config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, turnOn ? 1 : 0, mImsConfigListener);
            if (isVolteEnabledByPlatform()) {
                boolean ignoreDataEnabledChanged = getBooleanCarrierConfig(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
                boolean enableViLte = turnOn && isVtEnabledByUser() && (ignoreDataEnabledChanged || isDataEnabled());
                config.setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE, TelephonyManager.NETWORK_TYPE_LTE, enableViLte ? 1 : 0, mImsConfigListener);
            }
        }
    } catch (ImsException e) {
        loge("setLteFeatureValues: exception ", e);
    }
}
#method_after
private void setLteFeatureValues(boolean turnOn) {
    log("setLteFeatureValues: " + turnOn);
    CapabilityChangeRequest request = new CapabilityChangeRequest();
    if (turnOn) {
        request.addCapabilitiesToEnableForTech(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE, ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
    } else {
        request.addCapabilitiesToDisableForTech(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE, ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
    }
    if (isVolteEnabledByPlatform()) {
        boolean ignoreDataEnabledChanged = getBooleanCarrierConfig(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
        boolean enableViLte = turnOn && isVtEnabledByUser() && (ignoreDataEnabledChanged || isDataEnabled());
        if (enableViLte) {
            request.addCapabilitiesToEnableForTech(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO, ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        } else {
            request.addCapabilitiesToDisableForTech(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO, ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        }
    }
    try {
        mMmTelFeatureConnection.changeEnabledCapabilities(request, null);
    } catch (RemoteException e) {
        Log.e(TAG, "setLteFeatureValues: Exception: " + e.getMessage());
    }
}
#end_block

#method_before
private void turnOffIms() throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        mImsServiceProxy.turnOffIms();
    } catch (RemoteException e) {
        throw new ImsException("turnOffIms() ", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
private void turnOffIms() throws ImsException {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    tm.disableIms(mPhoneId);
}
#end_block

#method_before
@Override
public void binderDied() {
    mImsServiceProxy = null;
    mUt = null;
    mConfig = null;
    mEcbm = null;
    mMultiEndpoint = null;
}
#method_after
@Override
public void binderDied() {
    mMmTelFeatureConnection = null;
    mUt = null;
    mConfig = null;
    mEcbm = null;
    mMultiEndpoint = null;
}
#end_block

#method_before
public ImsEcbm getEcbmInterface(int serviceId) throws ImsException {
    if (mEcbm != null && mEcbm.isBinderAlive()) {
        return mEcbm;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsEcbm iEcbm = mImsServiceProxy.getEcbmInterface();
        if (iEcbm == null) {
            throw new ImsException("getEcbmInterface()", ImsReasonInfo.CODE_ECBM_NOT_SUPPORTED);
        }
        mEcbm = new ImsEcbm(iEcbm);
    } catch (RemoteException e) {
        throw new ImsException("getEcbmInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mEcbm;
}
#method_after
public ImsEcbm getEcbmInterface() throws ImsException {
    if (mEcbm != null && mEcbm.isBinderAlive()) {
        return mEcbm;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsEcbm iEcbm = mMmTelFeatureConnection.getEcbmInterface();
        if (iEcbm == null) {
            throw new ImsException("getEcbmInterface()", ImsReasonInfo.CODE_ECBM_NOT_SUPPORTED);
        }
        mEcbm = new ImsEcbm(iEcbm);
    } catch (RemoteException e) {
        throw new ImsException("getEcbmInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mEcbm;
}
#end_block

#method_before
public ImsMultiEndpoint getMultiEndpointInterface(int serviceId) throws ImsException {
    if (mMultiEndpoint != null && mMultiEndpoint.isBinderAlive()) {
        return mMultiEndpoint;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsMultiEndpoint iImsMultiEndpoint = mImsServiceProxy.getMultiEndpointInterface();
        if (iImsMultiEndpoint == null) {
            throw new ImsException("getMultiEndpointInterface()", ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED);
        }
        mMultiEndpoint = new ImsMultiEndpoint(iImsMultiEndpoint);
    } catch (RemoteException e) {
        throw new ImsException("getMultiEndpointInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mMultiEndpoint;
}
#method_after
public ImsMultiEndpoint getMultiEndpointInterface() throws ImsException {
    if (mMultiEndpoint != null && mMultiEndpoint.isBinderAlive()) {
        return mMultiEndpoint;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsMultiEndpoint iImsMultiEndpoint = mMmTelFeatureConnection.getMultiEndpointInterface();
        if (iImsMultiEndpoint == null) {
            throw new ImsException("getMultiEndpointInterface()", ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED);
        }
        mMultiEndpoint = new ImsMultiEndpoint(iImsMultiEndpoint);
    } catch (RemoteException e) {
        throw new ImsException("getMultiEndpointInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mMultiEndpoint;
}
#end_block

#method_before
public void factoryReset() {
    // Delete VoLTE row to retrieve the default value.
    mContext.getContentResolver().delete(Settings.Global.getUriFor(Settings.Global.ENHANCED_4G_MODE_ENABLED), null, null);
    // Set VoWiFi to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    // Set VoWiFi mode to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_MODE, getIntCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT));
    // Set VoWiFi roaming to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ROAMING_ENABLED, getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL) ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF);
    // Set VT to default
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.VT_IMS_ENABLED, ImsConfig.FeatureValueConstants.ON);
    // Push settings to ImsConfig
    updateImsServiceConfig(true);
}
#method_after
public void factoryReset() {
    // Set VoLTE to default
    SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.ENHANCED_4G_MODE_ENABLED, booleanToPropertyString(true));
    // Set VoWiFi to default
    SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_ENABLED, booleanToPropertyString(getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL)));
    // Set VoWiFi mode to default
    SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_MODE, Integer.toString(getIntCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT)));
    // Set VoWiFi roaming to default
    SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.WFC_IMS_ROAMING_ENABLED, booleanToPropertyString(getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL)));
    // Set VT to default
    SubscriptionManager.setSubscriptionProperty(getSubId(), SubscriptionManager.VT_IMS_ENABLED, booleanToPropertyString(true));
    // Push settings to ImsConfig
    updateImsServiceConfig(true);
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ImsManager:");
    pw.println("  mPhoneId = " + mPhoneId);
    pw.println("  mConfigUpdated = " + mConfigUpdated);
    pw.println("  mImsServiceProxy = " + mImsServiceProxy);
    pw.println("  mDataEnabled = " + isDataEnabled());
    pw.println("  ignoreDataEnabledChanged = " + getBooleanCarrierConfig(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS));
    pw.println("  isGbaValid = " + isGbaValid());
    pw.println("  isImsTurnOffAllowed = " + isImsTurnOffAllowed());
    pw.println("  isNonTtyOrTtyOnVolteEnabled = " + isNonTtyOrTtyOnVolteEnabled());
    pw.println("  isVolteEnabledByPlatform = " + isVolteEnabledByPlatform());
    pw.println("  isVolteProvisionedOnDevice = " + isVolteProvisionedOnDevice());
    pw.println("  isEnhanced4gLteModeSettingEnabledByUser = " + isEnhanced4gLteModeSettingEnabledByUser());
    pw.println("  isVtEnabledByPlatform = " + isVtEnabledByPlatform());
    pw.println("  isVtEnabledByUser = " + isVtEnabledByUser());
    pw.println("  isWfcEnabledByPlatform = " + isWfcEnabledByPlatform());
    pw.println("  isWfcEnabledByUser = " + isWfcEnabledByUser());
    pw.println("  getWfcMode = " + getWfcMode());
    pw.println("  isWfcRoamingEnabledByUser = " + isWfcRoamingEnabledByUser());
    pw.println("  isVtProvisionedOnDevice = " + isVtProvisionedOnDevice());
    pw.println("  isWfcProvisionedOnDevice = " + isWfcProvisionedOnDevice());
    pw.flush();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ImsManager:");
    pw.println("  mPhoneId = " + mPhoneId);
    pw.println("  mConfigUpdated = " + mConfigUpdated);
    pw.println("  mImsServiceProxy = " + mMmTelFeatureConnection);
    pw.println("  mDataEnabled = " + isDataEnabled());
    pw.println("  ignoreDataEnabledChanged = " + getBooleanCarrierConfig(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS));
    pw.println("  isGbaValid = " + isGbaValid());
    pw.println("  isImsTurnOffAllowed = " + isImsTurnOffAllowed());
    pw.println("  isNonTtyOrTtyOnVolteEnabled = " + isNonTtyOrTtyOnVolteEnabled());
    pw.println("  isVolteEnabledByPlatform = " + isVolteEnabledByPlatform());
    pw.println("  isVolteProvisionedOnDevice = " + isVolteProvisionedOnDevice());
    pw.println("  isEnhanced4gLteModeSettingEnabledByUser = " + isEnhanced4gLteModeSettingEnabledByUser());
    pw.println("  isVtEnabledByPlatform = " + isVtEnabledByPlatform());
    pw.println("  isVtEnabledByUser = " + isVtEnabledByUser());
    pw.println("  isWfcEnabledByPlatform = " + isWfcEnabledByPlatform());
    pw.println("  isWfcEnabledByUser = " + isWfcEnabledByUser());
    pw.println("  getWfcMode = " + getWfcMode());
    pw.println("  isWfcRoamingEnabledByUser = " + isWfcRoamingEnabledByUser());
    pw.println("  isVtProvisionedOnDevice = " + isVtProvisionedOnDevice());
    pw.println("  isWfcProvisionedOnDevice = " + isWfcProvisionedOnDevice());
    pw.flush();
}
#end_block

#method_before
private static void testRelativePositions(ByteBuffer b) throws Exception {
    b.put((byte) 0);
    assertEquals(1, b.position());
}
#method_after
private static void testRelativePositions(ByteBuffer b) throws Exception {
    // This goes into Memory.pokeByte(), which is an intrinsic that has
    // kWriteSideEffects. Stores before this call need to be kept.
    b.put((byte) 0);
    assertEquals(1, b.position());
}
#end_block

#method_before
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    Map<String, Map<String, List<String>>> paramInfoMap = new HashMap<String, Map<String, List<String>>>() {

        {
            put("master", new HashMap<String, List<String>>() {

                {
                    put("pixel", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
                }
            });
            put("oc-mr1", new HashMap<String, List<String>>() {

                {
                    put("pixel", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
                    put("pixel 2", Arrays.asList("taimen-userdebug", "walleye-userdebug"));
                    put("arm", Arrays.asList("aosp_arm_a-userdebug"));
                }
            });
            put("oc", new HashMap<String, List<String>>() {

                {
                    put("pixel", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
                }
            });
        }
    };
    String testPlan = request.getParameter("plan");
    Map<String, Map<String, List<DeviceBuildInfo>>> baseParamMap = getBasicParamMap(paramInfoMap);
    baseParamMap.forEach((branchKey, deviceObj) -> {
        List<List<String>> allPassIdLists = new ArrayList<>();
        Map<String, List<TestPlanRunEntity>> allTestPlanRunEntityMap = new HashMap<>();
        logger.log(Level.INFO, "branch name => " + branchKey);
        deviceObj.forEach((deviceName, deviceBuildInfoList) -> {
            deviceBuildInfoList.forEach(deviceBuildInfo -> {
                Map<String, Object> paramMap = new HashMap<String, Object>() {

                    {
                        put("branch", new String[] { branchKey });
                        put("device", new String[] { deviceBuildInfo.getDeviceBuildTarget() });
                        put("nonpassing", new String[] { "0" });
                    }
                };
                Calendar cal = Calendar.getInstance();
                cal.add(Calendar.DATE, -7);
                Long startTime = cal.getTime().getTime() * 1000;
                Long endTime = Calendar.getInstance().getTime().getTime() * 1000;
                logger.log(Level.INFO, "startTime => " + startTime);
                logger.log(Level.INFO, "endTime => " + endTime);
                SortDirection dir = SortDirection.DESCENDING;
                boolean unfiltered = false;
                boolean showPresubmit = false;
                boolean showPostsubmit = true;
                Filter typeFilter = FilterUtil.getTestTypeFilter(showPresubmit, showPostsubmit, unfiltered);
                Key testPlanKey = KeyFactory.createKey(TestPlanEntity.KIND, testPlan);
                Filter testPlanRunFilter = FilterUtil.getTimeFilter(testPlanKey, TestPlanRunEntity.KIND, startTime, endTime, typeFilter);
                List<Filter> userTestFilters = FilterUtil.getUserTestFilters(paramMap);
                userTestFilters.add(0, testPlanRunFilter);
                Filter userDeviceFilter = FilterUtil.getUserDeviceFilter(paramMap);
                List<Key> matchingKeyList = FilterUtil.getMatchingKeys(testPlanKey, TestPlanRunEntity.KIND, userTestFilters, userDeviceFilter, dir, MAX_RUNS_PER_PAGE);
                logger.log(Level.INFO, "the number of matching key => " + matchingKeyList.size());
                if (matchingKeyList.size() > 0) {
                    Map<Key, Entity> entityMap = datastore.get(matchingKeyList);
                    List<TestPlanRunEntity> testPlanRunEntityList = entityMap.values().stream().map(entity -> TestPlanRunEntity.fromEntity(entity)).collect(Collectors.toList());
                    allTestPlanRunEntityMap.put(deviceName + "-" + deviceBuildInfo.getDeviceBuildTarget(), testPlanRunEntityList);
                    // The passBuildIdList containing all passed buildId List for device
                    List<String> passBuildIdList = testPlanRunEntityList.stream().map(entity -> entity.testBuildId).collect(Collectors.toList());
                    allPassIdLists.add(passBuildIdList);
                    // The logic for candidate build ID is starting from here
                    Comparator<TestPlanRunEntity> byPassing = Comparator.comparingLong(elemFirst -> elemFirst.passCount);
                    Comparator<TestPlanRunEntity> byNonPassing = Comparator.comparingLong(elemFirst -> elemFirst.failCount);
                    // This will get the TestPlanRunEntity having maximum number of passing and
                    // minimum number of fail
                    Optional<TestPlanRunEntity> testPlanRunEntity = testPlanRunEntityList.stream().sorted(byPassing.reversed().thenComparing(byNonPassing)).findFirst();
                    String buildId = testPlanRunEntity.map(entity -> entity.testBuildId).orElse("");
                    deviceBuildInfo.setCandidateBuildId(buildId);
                    Long buildIdTimestamp = testPlanRunEntity.map(entity -> entity.startTimestamp).orElse(0L);
                    deviceBuildInfo.setCandidateBuildIdTimestamp(buildIdTimestamp);
                    logger.log(Level.INFO, "passBuildIdList => " + passBuildIdList);
                } else {
                    allPassIdLists.add(new ArrayList<>());
                    deviceBuildInfo.setCandidateBuildId("No Test Results");
                }
            });
        });
        Set<String> greenBuildIdList = FilterUtil.getCommonElements(allPassIdLists);
        if (greenBuildIdList.size() > 0) {
            String greenBuildId = greenBuildIdList.iterator().next();
            deviceObj.forEach((deviceName, deviceBuildInfoList) -> {
                deviceBuildInfoList.forEach(deviceBuildInfo -> {
                    // This is to get the timestamp for greenBuildId
                    Optional<TestPlanRunEntity> testPlanRunEntity = allTestPlanRunEntityMap.get(deviceName + "-" + deviceBuildInfo.getDeviceBuildTarget()).stream().filter(entity -> entity.testBuildId.equalsIgnoreCase(greenBuildId)).findFirst();
                    // Setting the greenBuildId value and timestamp to deviceBuildInfo object
                    deviceBuildInfo.setGreenBuildId(greenBuildId);
                    Long buildIdTimestamp = testPlanRunEntity.map(entity -> entity.startTimestamp).orElse(0L);
                    deviceBuildInfo.setGreenBuildIdTimestamp(buildIdTimestamp);
                });
            });
        }
    });
    request.setAttribute("plan", request.getParameter("plan"));
    request.setAttribute("greenBuildInfo", baseParamMap);
    response.setStatus(HttpServletResponse.SC_OK);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
    }
}
#method_after
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    Map<String, Map<String, List<String>>> paramInfoMap = new HashMap<String, Map<String, List<String>>>() {

        {
            put("master", new HashMap<String, List<String>>() {

                {
                    put("pixel", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
                }
            });
            put("oc-mr1", new HashMap<String, List<String>>() {

                {
                    put("pixel", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
                    put("pixel 2", Arrays.asList("taimen-userdebug", "walleye-userdebug"));
                    put("other", Arrays.asList("aosp_arm_a-userdebug"));
                }
            });
            put("oc", new HashMap<String, List<String>>() {

                {
                    put("pixel", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
                }
            });
        }
    };
    String testPlan = request.getParameter("plan");
    Map<String, Map<String, List<DeviceBuildInfo>>> baseParamMap = getBasicParamMap(paramInfoMap);
    baseParamMap.forEach((branchKey, deviceObj) -> {
        List<List<String>> allPassIdLists = new ArrayList<>();
        Map<String, List<TestPlanRunEntity>> allTestPlanRunEntityMap = new HashMap<>();
        logger.log(Level.INFO, "branch name => " + branchKey);
        deviceObj.forEach((deviceName, deviceBuildInfoList) -> {
            deviceBuildInfoList.forEach(deviceBuildInfo -> {
                Map<String, Object> paramMap = new HashMap<String, Object>() {

                    {
                        put("branch", new String[] { branchKey });
                        put("device", new String[] { deviceBuildInfo.getDeviceBuildTarget() });
                        put("nonpassing", new String[] { "0" });
                    }
                };
                Calendar cal = Calendar.getInstance();
                cal.add(Calendar.DATE, -7);
                Long startTime = cal.getTime().getTime() * 1000;
                Long endTime = Calendar.getInstance().getTime().getTime() * 1000;
                logger.log(Level.INFO, "startTime => " + startTime);
                logger.log(Level.INFO, "endTime => " + endTime);
                SortDirection dir = SortDirection.DESCENDING;
                boolean unfiltered = false;
                boolean showPresubmit = false;
                boolean showPostsubmit = true;
                Filter typeFilter = FilterUtil.getTestTypeFilter(showPresubmit, showPostsubmit, unfiltered);
                Key testPlanKey = KeyFactory.createKey(TestPlanEntity.KIND, testPlan);
                Filter testPlanRunFilter = FilterUtil.getTimeFilter(testPlanKey, TestPlanRunEntity.KIND, startTime, endTime, typeFilter);
                List<Filter> userTestFilters = FilterUtil.getUserTestFilters(paramMap);
                userTestFilters.add(0, testPlanRunFilter);
                Filter userDeviceFilter = FilterUtil.getUserDeviceFilter(paramMap);
                List<Key> matchingKeyList = FilterUtil.getMatchingKeys(testPlanKey, TestPlanRunEntity.KIND, userTestFilters, userDeviceFilter, dir, MAX_RUNS_PER_PAGE);
                logger.log(Level.INFO, "the number of matching key => " + matchingKeyList.size());
                if (matchingKeyList.size() > 0) {
                    Map<Key, Entity> entityMap = datastore.get(matchingKeyList);
                    List<TestPlanRunEntity> testPlanRunEntityList = entityMap.values().stream().map(entity -> TestPlanRunEntity.fromEntity(entity)).collect(Collectors.toList());
                    allTestPlanRunEntityMap.put(deviceName + "-" + deviceBuildInfo.getDeviceBuildTarget(), testPlanRunEntityList);
                    // The passBuildIdList containing all passed buildId List for device
                    List<String> passBuildIdList = testPlanRunEntityList.stream().map(entity -> entity.testBuildId).collect(Collectors.toList());
                    allPassIdLists.add(passBuildIdList);
                    // The logic for candidate build ID is starting from here
                    Comparator<TestPlanRunEntity> byPassing = Comparator.comparingLong(elemFirst -> elemFirst.passCount);
                    Comparator<TestPlanRunEntity> byNonPassing = Comparator.comparingLong(elemFirst -> elemFirst.failCount);
                    // This will get the TestPlanRunEntity having maximum number of passing and
                    // minimum number of fail
                    Optional<TestPlanRunEntity> testPlanRunEntity = testPlanRunEntityList.stream().sorted(byPassing.reversed().thenComparing(byNonPassing)).findFirst();
                    String buildId = testPlanRunEntity.map(entity -> entity.testBuildId).orElse("");
                    deviceBuildInfo.setCandidateBuildId(buildId);
                    Long buildIdTimestamp = testPlanRunEntity.map(entity -> {
                        return entity.startTimestamp;
                    }).orElse(0L);
                    deviceBuildInfo.setCandidateBuildIdTimestamp(buildIdTimestamp);
                    logger.log(Level.INFO, "passBuildIdList => " + passBuildIdList);
                } else {
                    allPassIdLists.add(new ArrayList<>());
                    deviceBuildInfo.setCandidateBuildId("No Test Results");
                }
            });
        });
        Set<String> greenBuildIdList = FilterUtil.getCommonElements(allPassIdLists);
        if (greenBuildIdList.size() > 0) {
            String greenBuildId = greenBuildIdList.iterator().next();
            deviceObj.forEach((deviceName, deviceBuildInfoList) -> {
                deviceBuildInfoList.forEach(deviceBuildInfo -> {
                    // This is to get the timestamp for greenBuildId
                    Optional<TestPlanRunEntity> testPlanRunEntity = allTestPlanRunEntityMap.get(deviceName + "-" + deviceBuildInfo.getDeviceBuildTarget()).stream().filter(entity -> entity.testBuildId.equalsIgnoreCase(greenBuildId)).findFirst();
                    // Setting the greenBuildId value and timestamp to deviceBuildInfo object
                    deviceBuildInfo.setGreenBuildId(greenBuildId);
                    Long buildIdTimestamp = testPlanRunEntity.map(entity -> entity.startTimestamp).orElse(0L);
                    deviceBuildInfo.setGreenBuildIdTimestamp(buildIdTimestamp);
                });
            });
        }
    });
    request.setAttribute("plan", request.getParameter("plan"));
    request.setAttribute("greenBuildInfo", baseParamMap);
    response.setStatus(HttpServletResponse.SC_OK);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Exception caught : ", e);
    }
}
#end_block

#method_before
public ArrayMap<String, IpConfiguration> getIpConfigurations() {
    synchronized (mSync) {
        return mIpConfigurations;
    }
}
#method_after
public ArrayMap<String, IpConfiguration> getIpConfigurations() {
    synchronized (mSync) {
        return new ArrayMap<>(mIpConfigurations);
    }
}
#end_block

#method_before
public IpConfiguration getIpConfigurationForDefaultInterface() {
    synchronized (mSync) {
        return mIpConfigurationForDefaultInterface;
    }
}
#method_after
public IpConfiguration getIpConfigurationForDefaultInterface() {
    synchronized (mSync) {
        return new IpConfiguration(mIpConfigurationForDefaultInterface);
    }
}
#end_block

#method_before
void addInterface(String ifaceName, String hwAddress, NetworkCapabilities capabilities, IpConfiguration ipConfiguration) {
    if (mTrackingInterfaces.containsKey(ifaceName)) {
        return;
    }
    if (DBG) {
        Log.d(TAG, "addInterface, iface: " + ifaceName + ", capabilities: " + capabilities);
    }
    NetworkInterfaceState iface = new NetworkInterfaceState(ifaceName, hwAddress, mHandler, mContext, capabilities);
    iface.setIpConfig(ipConfiguration);
    mTrackingInterfaces.put(ifaceName, iface);
}
#method_after
void addInterface(String ifaceName, String hwAddress, NetworkCapabilities capabilities, IpConfiguration ipConfiguration) {
    if (mTrackingInterfaces.containsKey(ifaceName)) {
        Log.e(TAG, "Interface with name " + ifaceName + " already exists.");
        return;
    }
    if (DBG) {
        Log.d(TAG, "addInterface, iface: " + ifaceName + ", capabilities: " + capabilities);
    }
    NetworkInterfaceState iface = new NetworkInterfaceState(ifaceName, hwAddress, mHandler, mContext, capabilities);
    iface.setIpConfig(ipConfiguration);
    mTrackingInterfaces.put(ifaceName, iface);
    updateCapabilityFilter();
}
#end_block

#method_before
void removeInterface(String interfaceName) {
    NetworkInterfaceState iface = mTrackingInterfaces.remove(interfaceName);
    if (iface != null) {
        iface.stop();
    }
}
#method_after
void removeInterface(String interfaceName) {
    NetworkInterfaceState iface = mTrackingInterfaces.remove(interfaceName);
    if (iface != null) {
        iface.stop();
    }
    updateCapabilityFilter();
}
#end_block

#method_before
private NetworkInterfaceState networkForRequest(NetworkRequest request) {
    String requestedIface = null;
    NetworkSpecifier specifier = request.networkCapabilities.getNetworkSpecifier();
    if (specifier instanceof StringNetworkSpecifier) {
        requestedIface = ((StringNetworkSpecifier) specifier).specifier;
    }
    NetworkInterfaceState network = null;
    if (!TextUtils.isEmpty(requestedIface)) {
        NetworkInterfaceState n = mTrackingInterfaces.get(requestedIface);
        network = n.statisified(request.networkCapabilities) ? n : null;
    } else {
        for (NetworkInterfaceState n : mTrackingInterfaces.values()) {
            if (n.statisified(request.networkCapabilities)) {
                network = n;
                break;
            }
        }
    }
    return network;
}
#method_after
private NetworkInterfaceState networkForRequest(NetworkRequest request) {
    String requestedIface = null;
    NetworkSpecifier specifier = request.networkCapabilities.getNetworkSpecifier();
    if (specifier instanceof StringNetworkSpecifier) {
        requestedIface = ((StringNetworkSpecifier) specifier).specifier;
    }
    NetworkInterfaceState network = null;
    if (!TextUtils.isEmpty(requestedIface)) {
        NetworkInterfaceState n = mTrackingInterfaces.get(requestedIface);
        if (n != null && n.statisified(request.networkCapabilities)) {
            network = n;
        }
    } else {
        for (NetworkInterfaceState n : mTrackingInterfaces.values()) {
            if (n.statisified(request.networkCapabilities)) {
                network = n;
                break;
            }
        }
    }
    if (DBG) {
        Log.i(TAG, "networkForRequest, request: " + request + ", network: " + network);
    }
    return network;
}
#end_block

#method_before
boolean statisified(NetworkCapabilities capabilities) {
    return this.mCapabilities.satisfiedByImmutableNetworkCapabilities(capabilities);
}
#method_after
boolean statisified(NetworkCapabilities requestedCapabilities) {
    return requestedCapabilities.satisfiedByNetworkCapabilities(mCapabilities);
}
#end_block

#method_before
private void start() {
    if (DBG) {
        Log.d(TAG, String.format("starting IpManager(%s): mNetworkInfo=%s", name, mNetworkInfo));
    }
    if (mIpManager != null)
        stop();
    mNetworkInfo.setDetailedState(DetailedState.OBTAINING_IPADDR, null, mHwAddress);
    mIpManager = new IpManager(mContext, name, mIpManagerCallback);
    if (sTcpBufferSizes == null) {
        sTcpBufferSizes = mContext.getResources().getString(com.android.internal.R.string.config_ethernet_tcp_buffers);
    }
    provisionIpManager(mIpManager, mIpConfig, sTcpBufferSizes);
}
#method_after
private void start() {
    if (DBG) {
        Log.d(TAG, String.format("starting IpClient(%s): mNetworkInfo=%s", name, mNetworkInfo));
    }
    if (mIpClient != null)
        stop();
    mNetworkInfo.setDetailedState(DetailedState.OBTAINING_IPADDR, null, mHwAddress);
    mIpClient = new IpClient(mContext, name, mIpClientCallback);
    if (sTcpBufferSizes == null) {
        sTcpBufferSizes = mContext.getResources().getString(com.android.internal.R.string.config_ethernet_tcp_buffers);
    }
    provisionIpClient(mIpClient, mIpConfig, sTcpBufferSizes);
}
#end_block

#method_before
void onIpLayerStarted(LinkProperties linkProperties) {
    if (mNetworkAgent != null) {
        Log.e(TAG, "Already have a NetworkAgent - aborting new request");
        stop();
        return;
    }
    mLinkProperties = linkProperties;
    mNetworkInfo.setDetailedState(DetailedState.CONNECTED, null, mHwAddress);
    // Create our NetworkAgent.
    mNetworkAgent = new NetworkAgent(mHandler.getLooper(), mContext, NETWORK_TYPE, mNetworkInfo, mCapabilities, mLinkProperties, NETWORK_SCORE) {

        public void unwanted() {
            if (this == mNetworkAgent) {
                stop();
            } else if (mNetworkAgent != null) {
                Log.d(TAG, "Ignoring unwanted as we have a more modern " + "instance");
            }
        // Otherwise, we've already called stop.
        }
    };
}
#method_after
void onIpLayerStarted(LinkProperties linkProperties) {
    if (mNetworkAgent != null) {
        Log.e(TAG, "Already have a NetworkAgent - aborting new request");
        stop();
        return;
    }
    mLinkProperties = linkProperties;
    mNetworkInfo.setDetailedState(DetailedState.CONNECTED, null, mHwAddress);
    mNetworkInfo.setIsAvailable(true);
    // Create our NetworkAgent.
    mNetworkAgent = new NetworkAgent(mHandler.getLooper(), mContext, NETWORK_TYPE, mNetworkInfo, mCapabilities, mLinkProperties, NETWORK_SCORE) {

        public void unwanted() {
            if (this == mNetworkAgent) {
                stop();
            } else if (mNetworkAgent != null) {
                Log.d(TAG, "Ignoring unwanted as we have a more modern " + "instance");
            }
        // Otherwise, we've already called stop.
        }
    };
}
#end_block

#method_before
void stop() {
    if (mIpManager != null) {
        mIpManager.shutdown();
        mIpManager = null;
    }
    // ConnectivityService will only forget our NetworkAgent if we send it a NetworkInfo object
    // with a state of DISCONNECTED or SUSPENDED. So we can't simply clear our NetworkInfo here:
    // that sets the state to IDLE, and ConnectivityService will still think we're connected.
    // 
    mNetworkInfo.setDetailedState(DetailedState.DISCONNECTED, null, mHwAddress);
    if (mNetworkAgent != null) {
        updateAgent();
        mNetworkAgent = null;
    }
    clear();
}
#method_after
void stop() {
    if (mIpClient != null) {
        mIpClient.shutdown();
        mIpClient = null;
    }
    // ConnectivityService will only forget our NetworkAgent if we send it a NetworkInfo object
    // with a state of DISCONNECTED or SUSPENDED. So we can't simply clear our NetworkInfo here:
    // that sets the state to IDLE, and ConnectivityService will still think we're connected.
    // 
    mNetworkInfo.setDetailedState(DetailedState.DISCONNECTED, null, mHwAddress);
    if (mNetworkAgent != null) {
        updateAgent();
        mNetworkAgent = null;
    }
    clear();
}
#end_block

#method_before
@Override
public String toString() {
    return getClass().getSimpleName() + "{ " + "iface: " + name + ", " + "up: " + mLinkUp + ", " + "hwAddress: " + mHwAddress + ", " + "networkInfo: " + mNetworkInfo + ", " + "networkAgent: " + mNetworkAgent + ", " + "ipManager: " + mIpManager + "," + "linkProperties: " + mLinkProperties + "}";
}
#method_after
@Override
public String toString() {
    return getClass().getSimpleName() + "{ " + "iface: " + name + ", " + "up: " + mLinkUp + ", " + "hwAddress: " + mHwAddress + ", " + "networkInfo: " + mNetworkInfo + ", " + "networkAgent: " + mNetworkAgent + ", " + "ipClient: " + mIpClient + "," + "linkProperties: " + mLinkProperties + "}";
}
#end_block

#method_before
void dump(FileDescriptor fd, IndentingPrintWriter pw, String[] args) {
    pw.println(getClass().getSimpleName());
    pw.println("Tracking interfaces:");
    pw.increaseIndent();
    for (String iface : mTrackingInterfaces.keySet()) {
        pw.println(iface + ":" + mTrackingInterfaces.get(iface));
    }
    pw.decreaseIndent();
}
#method_after
void dump(FileDescriptor fd, IndentingPrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    pw.println(getClass().getSimpleName());
    pw.println("Tracking interfaces:");
    pw.increaseIndent();
    for (String iface : mTrackingInterfaces.keySet()) {
        NetworkInterfaceState ifaceState = mTrackingInterfaces.get(iface);
        pw.println(iface + ":" + ifaceState);
        pw.increaseIndent();
        ifaceState.mIpClient.dump(fd, pw, args);
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
}
#end_block

#method_before
void updateIpConfiguration(String iface, IpConfiguration ipConfiguration) {
    if (DBG)
        Log.i(TAG, "updateIpConfiguration, iface: " + iface + ", cfg: " + ipConfiguration);
    mConfigStore.write(iface, ipConfiguration);
    mIpConfigurations.put(iface, ipConfiguration);
    mHandler.post(() -> mFactory.updateIpConfiguration(iface, ipConfiguration));
}
#method_after
void updateIpConfiguration(String iface, IpConfiguration ipConfiguration) {
    if (DBG) {
        Log.i(TAG, "updateIpConfiguration, iface: " + iface + ", cfg: " + ipConfiguration);
    }
    mConfigStore.write(iface, ipConfiguration);
    mIpConfigurations.put(iface, ipConfiguration);
    mHandler.post(() -> mFactory.updateIpConfiguration(iface, ipConfiguration));
}
#end_block

#method_before
private void addInterface(String iface) {
    InterfaceConfiguration config = null;
    // Bring up the interface so we get link status indications.
    try {
        mNMService.setInterfaceUp(iface);
        config = mNMService.getInterfaceConfig(iface);
    } catch (RemoteException | IllegalStateException e) {
        // Either the system is crashing or the interface has disappeared. Just ignore the
        // error; we haven't modified any state because we only do that if our calls succeed.
        Log.e(TAG, "Error upping interface " + iface, e);
    }
    if (config == null) {
        Log.e(TAG, "Null interface config for " + iface + ". Bailing out.");
        return;
    }
    NetworkCapabilities nc = mNetworkCapabilities.get(iface);
    if (nc == null) {
        nc = createDefaultNetworkCapabilities();
    }
    IpConfiguration ipConfiguration = mIpConfigurations.get(iface);
    if (ipConfiguration == null) {
        ipConfiguration = createDefaultIpConfiguration();
    }
    Log.d(TAG, "Started tracking interface " + iface);
    mFactory.addInterface(iface, config.getHardwareAddress(), nc, ipConfiguration);
    // start configuring it.
    if (config.hasFlag("running")) {
        updateInterfaceState(iface, true);
    }
}
#method_after
private void addInterface(String iface) {
    InterfaceConfiguration config = null;
    // Bring up the interface so we get link status indications.
    try {
        mNMService.setInterfaceUp(iface);
        config = mNMService.getInterfaceConfig(iface);
    } catch (RemoteException | IllegalStateException e) {
        // Either the system is crashing or the interface has disappeared. Just ignore the
        // error; we haven't modified any state because we only do that if our calls succeed.
        Log.e(TAG, "Error upping interface " + iface, e);
    }
    if (config == null) {
        Log.e(TAG, "Null interface config for " + iface + ". Bailing out.");
        return;
    }
    final String hwAddress = config.getHardwareAddress();
    NetworkCapabilities nc = mNetworkCapabilities.get(iface);
    if (nc == null) {
        // Try to resolve using mac address
        nc = mNetworkCapabilities.get(hwAddress);
        if (nc == null) {
            nc = createDefaultNetworkCapabilities();
        }
    }
    IpConfiguration ipConfiguration = mIpConfigurations.get(iface);
    if (ipConfiguration == null) {
        ipConfiguration = createDefaultIpConfiguration();
    }
    Log.d(TAG, "Started tracking interface " + iface);
    mFactory.addInterface(iface, hwAddress, nc, ipConfiguration);
    // start configuring it.
    if (config.hasFlag("running")) {
        updateInterfaceState(iface, true);
    }
}
#end_block

#method_before
private void updateInterfaceState(String iface, boolean up) {
    boolean modified = mFactory.updateInterfaceLinkState(iface, up);
    if (modified) {
        boolean restricted = isRestrictedInterface(iface);
        int n = mListeners.beginBroadcast();
        for (int i = 0; i < n; i++) {
            try {
                if (restricted) {
                    ListenerInfo listenerInfo = (ListenerInfo) mListeners.getBroadcastCookie(i);
                    if (!listenerInfo.canUseRestrictedNetworks)
                        continue;
                }
                mListeners.getBroadcastItem(i).onAvailabilityChanged(iface, up);
            } catch (RemoteException e) {
            // Do nothing here.
            }
        }
        mListeners.finishBroadcast();
    }
}
#method_after
private void updateInterfaceState(String iface, boolean up) {
    boolean modified = mFactory.updateInterfaceLinkState(iface, up);
    if (modified) {
        boolean restricted = isRestrictedInterface(iface);
        int n = mListeners.beginBroadcast();
        for (int i = 0; i < n; i++) {
            try {
                if (restricted) {
                    ListenerInfo listenerInfo = (ListenerInfo) mListeners.getBroadcastCookie(i);
                    if (!listenerInfo.canUseRestrictedNetworks) {
                        continue;
                    }
                }
                mListeners.getBroadcastItem(i).onAvailabilityChanged(iface, up);
            } catch (RemoteException e) {
            // Do nothing here.
            }
        }
        mListeners.finishBroadcast();
    }
}
#end_block

#method_before
@Override
public void interfaceLinkStateChanged(String iface, boolean up) {
    if (DBG)
        Log.i(TAG, "interfaceLinkStateChanged, iface: " + iface + ", up: " + up);
    mHandler.post(() -> updateInterfaceState(iface, up));
}
#method_after
@Override
public void interfaceLinkStateChanged(String iface, boolean up) {
    if (DBG) {
        Log.i(TAG, "interfaceLinkStateChanged, iface: " + iface + ", up: " + up);
    }
    mHandler.post(() -> updateInterfaceState(iface, up));
}
#end_block

#method_before
private void parseEthernetConfig(String configString) {
    String[] tokens = configString.split(";");
    String name = tokens[0];
    NetworkCapabilities nc = createNetworkCapabilities(tokens.length > 1 ? tokens[1] : null);
    mNetworkCapabilities.put(name, nc);
    if (tokens.length > 2 && !TextUtils.isEmpty(tokens[2])) {
        IpConfiguration ipConfig = createStaticIpConfiguration(tokens[2]);
        mIpConfigurations.put(name, ipConfig);
    }
}
#method_after
private void parseEthernetConfig(String configString) {
    String[] tokens = configString.split(";");
    String name = tokens[0];
    String capabilities = tokens.length > 1 ? tokens[1] : null;
    NetworkCapabilities nc = createNetworkCapabilities(!TextUtils.isEmpty(capabilities), /* clear default capabilities */
    capabilities);
    mNetworkCapabilities.put(name, nc);
    if (tokens.length > 2 && !TextUtils.isEmpty(tokens[2])) {
        IpConfiguration ipConfig = createStaticIpConfiguration(tokens[2]);
        mIpConfigurations.put(name, ipConfig);
    }
}
#end_block

#method_before
private static NetworkCapabilities createDefaultNetworkCapabilities() {
    NetworkCapabilities nc = createNetworkCapabilities(null);
    nc.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
    nc.addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED);
    return nc;
}
#method_after
private static NetworkCapabilities createDefaultNetworkCapabilities() {
    NetworkCapabilities nc = createNetworkCapabilities(false);
    nc.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
    nc.addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED);
    nc.addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    nc.addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING);
    return nc;
}
#end_block

#method_before
private static NetworkCapabilities createNetworkCapabilities(@Nullable String commaSeparatedCapabilities) {
    NetworkCapabilities nc = new NetworkCapabilities();
    // Remove default capabilities.
    nc.clearAll();
    nc.addTransportType(NetworkCapabilities.TRANSPORT_ETHERNET);
    nc.setLinkUpstreamBandwidthKbps(100 * 1000);
    nc.setLinkDownstreamBandwidthKbps(100 * 1000);
    if (!TextUtils.isEmpty(commaSeparatedCapabilities)) {
        for (String strNetworkCapability : commaSeparatedCapabilities.split(",")) {
            if (!TextUtils.isEmpty(strNetworkCapability)) {
                nc.addCapability(Integer.valueOf(strNetworkCapability));
            }
        }
    }
    return nc;
}
#method_after
private static NetworkCapabilities createNetworkCapabilities(boolean clearDefaultCapabilities) {
    return createNetworkCapabilities(clearDefaultCapabilities, null);
}
#end_block

#method_before
private void postAndWaitForRunnable(Runnable r) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(1);
    mHandler.post(() -> {
        try {
            r.run();
        } finally {
            latch.countDown();
        }
    });
    latch.await();
}
#method_after
private void postAndWaitForRunnable(Runnable r) {
    mHandler.runWithScissors(r, 2000L);
}
#end_block

#method_before
void dump(FileDescriptor fd, IndentingPrintWriter pw, String[] args) {
    try {
        postAndWaitForRunnable(() -> {
            pw.println(getClass().getSimpleName());
            pw.println("Ethernet interface name filter: " + mIfaceMatch);
            pw.println("Listeners: " + mListeners.getRegisteredCallbackCount());
            pw.println("IP Configurations:");
            pw.increaseIndent();
            for (String iface : mIpConfigurations.keySet()) {
                pw.println(iface + ": " + mIpConfigurations.get(iface));
            }
            pw.decreaseIndent();
            pw.println();
            pw.println("Network Capabilities:");
            pw.increaseIndent();
            for (String iface : mNetworkCapabilities.keySet()) {
                pw.println(iface + ": " + mNetworkCapabilities.get(iface));
            }
            pw.decreaseIndent();
            pw.println();
            mFactory.dump(fd, pw, args);
        });
    } catch (InterruptedException e) {
        throw new IllegalStateException("dump() interrupted");
    }
}
#method_after
void dump(FileDescriptor fd, IndentingPrintWriter pw, String[] args) {
    postAndWaitForRunnable(() -> {
        pw.println(getClass().getSimpleName());
        pw.println("Ethernet interface name filter: " + mIfaceMatch);
        pw.println("Listeners: " + mListeners.getRegisteredCallbackCount());
        pw.println("IP Configurations:");
        pw.increaseIndent();
        for (String iface : mIpConfigurations.keySet()) {
            pw.println(iface + ": " + mIpConfigurations.get(iface));
        }
        pw.decreaseIndent();
        pw.println();
        pw.println("Network Capabilities:");
        pw.increaseIndent();
        for (String iface : mNetworkCapabilities.keySet()) {
            pw.println(iface + ": " + mNetworkCapabilities.get(iface));
        }
        pw.decreaseIndent();
        pw.println();
        mFactory.dump(fd, pw, args);
    });
}
#end_block

#method_before
@VisibleForTesting
public static boolean writeConfig(DataOutputStream out, String configKey, IpConfiguration config) throws IOException {
    boolean written = false;
    try {
        switch(config.ipAssignment) {
            case STATIC:
                out.writeUTF(IP_ASSIGNMENT_KEY);
                out.writeUTF(config.ipAssignment.toString());
                StaticIpConfiguration staticIpConfiguration = config.staticIpConfiguration;
                if (staticIpConfiguration != null) {
                    if (staticIpConfiguration.ipAddress != null) {
                        LinkAddress ipAddress = staticIpConfiguration.ipAddress;
                        out.writeUTF(LINK_ADDRESS_KEY);
                        out.writeUTF(ipAddress.getAddress().getHostAddress());
                        out.writeInt(ipAddress.getPrefixLength());
                    }
                    if (staticIpConfiguration.gateway != null) {
                        out.writeUTF(GATEWAY_KEY);
                        // Default route.
                        out.writeInt(0);
                        // Have a gateway.
                        out.writeInt(1);
                        out.writeUTF(staticIpConfiguration.gateway.getHostAddress());
                    }
                    for (InetAddress inetAddr : staticIpConfiguration.dnsServers) {
                        out.writeUTF(DNS_KEY);
                        out.writeUTF(inetAddr.getHostAddress());
                    }
                }
                written = true;
                break;
            case DHCP:
                out.writeUTF(IP_ASSIGNMENT_KEY);
                out.writeUTF(config.ipAssignment.toString());
                written = true;
                break;
            case UNASSIGNED:
                /* Ignore */
                break;
            default:
                loge("Ignore invalid ip assignment while writing");
                break;
        }
        switch(config.proxySettings) {
            case STATIC:
                ProxyInfo proxyProperties = config.httpProxy;
                String exclusionList = proxyProperties.getExclusionListAsString();
                out.writeUTF(PROXY_SETTINGS_KEY);
                out.writeUTF(config.proxySettings.toString());
                out.writeUTF(PROXY_HOST_KEY);
                out.writeUTF(proxyProperties.getHost());
                out.writeUTF(PROXY_PORT_KEY);
                out.writeInt(proxyProperties.getPort());
                if (exclusionList != null) {
                    out.writeUTF(EXCLUSION_LIST_KEY);
                    out.writeUTF(exclusionList);
                }
                written = true;
                break;
            case PAC:
                ProxyInfo proxyPacProperties = config.httpProxy;
                out.writeUTF(PROXY_SETTINGS_KEY);
                out.writeUTF(config.proxySettings.toString());
                out.writeUTF(PROXY_PAC_FILE);
                out.writeUTF(proxyPacProperties.getPacFileUrl().toString());
                written = true;
                break;
            case NONE:
                out.writeUTF(PROXY_SETTINGS_KEY);
                out.writeUTF(config.proxySettings.toString());
                written = true;
                break;
            case UNASSIGNED:
                /* Ignore */
                break;
            default:
                loge("Ignore invalid proxy settings while writing");
                break;
        }
        if (written) {
            out.writeUTF(ID_KEY);
            out.writeUTF(configKey);
        }
    } catch (NullPointerException e) {
        loge("Failure in writing " + config + e);
    }
    out.writeUTF(EOS);
    return written;
}
#method_after
private static boolean writeConfig(DataOutputStream out, String configKey, IpConfiguration config) throws IOException {
    return writeConfig(out, configKey, config, IPCONFIG_FILE_VERSION);
}
#end_block

#method_before
@VisibleForTesting
public static boolean writeConfig(DataOutputStream out, String configKey, IpConfiguration config) throws IOException {
    boolean written = false;
    try {
        switch(config.ipAssignment) {
            case STATIC:
                out.writeUTF(IP_ASSIGNMENT_KEY);
                out.writeUTF(config.ipAssignment.toString());
                StaticIpConfiguration staticIpConfiguration = config.staticIpConfiguration;
                if (staticIpConfiguration != null) {
                    if (staticIpConfiguration.ipAddress != null) {
                        LinkAddress ipAddress = staticIpConfiguration.ipAddress;
                        out.writeUTF(LINK_ADDRESS_KEY);
                        out.writeUTF(ipAddress.getAddress().getHostAddress());
                        out.writeInt(ipAddress.getPrefixLength());
                    }
                    if (staticIpConfiguration.gateway != null) {
                        out.writeUTF(GATEWAY_KEY);
                        // Default route.
                        out.writeInt(0);
                        // Have a gateway.
                        out.writeInt(1);
                        out.writeUTF(staticIpConfiguration.gateway.getHostAddress());
                    }
                    for (InetAddress inetAddr : staticIpConfiguration.dnsServers) {
                        out.writeUTF(DNS_KEY);
                        out.writeUTF(inetAddr.getHostAddress());
                    }
                }
                written = true;
                break;
            case DHCP:
                out.writeUTF(IP_ASSIGNMENT_KEY);
                out.writeUTF(config.ipAssignment.toString());
                written = true;
                break;
            case UNASSIGNED:
                /* Ignore */
                break;
            default:
                loge("Ignore invalid ip assignment while writing");
                break;
        }
        switch(config.proxySettings) {
            case STATIC:
                ProxyInfo proxyProperties = config.httpProxy;
                String exclusionList = proxyProperties.getExclusionListAsString();
                out.writeUTF(PROXY_SETTINGS_KEY);
                out.writeUTF(config.proxySettings.toString());
                out.writeUTF(PROXY_HOST_KEY);
                out.writeUTF(proxyProperties.getHost());
                out.writeUTF(PROXY_PORT_KEY);
                out.writeInt(proxyProperties.getPort());
                if (exclusionList != null) {
                    out.writeUTF(EXCLUSION_LIST_KEY);
                    out.writeUTF(exclusionList);
                }
                written = true;
                break;
            case PAC:
                ProxyInfo proxyPacProperties = config.httpProxy;
                out.writeUTF(PROXY_SETTINGS_KEY);
                out.writeUTF(config.proxySettings.toString());
                out.writeUTF(PROXY_PAC_FILE);
                out.writeUTF(proxyPacProperties.getPacFileUrl().toString());
                written = true;
                break;
            case NONE:
                out.writeUTF(PROXY_SETTINGS_KEY);
                out.writeUTF(config.proxySettings.toString());
                written = true;
                break;
            case UNASSIGNED:
                /* Ignore */
                break;
            default:
                loge("Ignore invalid proxy settings while writing");
                break;
        }
        if (written) {
            out.writeUTF(ID_KEY);
            out.writeUTF(configKey);
        }
    } catch (NullPointerException e) {
        loge("Failure in writing " + config + e);
    }
    out.writeUTF(EOS);
    return written;
}
#method_after
@VisibleForTesting
public static boolean writeConfig(DataOutputStream out, String configKey, IpConfiguration config, int version) throws IOException {
    boolean written = false;
    try {
        switch(config.ipAssignment) {
            case STATIC:
                out.writeUTF(IP_ASSIGNMENT_KEY);
                out.writeUTF(config.ipAssignment.toString());
                StaticIpConfiguration staticIpConfiguration = config.staticIpConfiguration;
                if (staticIpConfiguration != null) {
                    if (staticIpConfiguration.ipAddress != null) {
                        LinkAddress ipAddress = staticIpConfiguration.ipAddress;
                        out.writeUTF(LINK_ADDRESS_KEY);
                        out.writeUTF(ipAddress.getAddress().getHostAddress());
                        out.writeInt(ipAddress.getPrefixLength());
                    }
                    if (staticIpConfiguration.gateway != null) {
                        out.writeUTF(GATEWAY_KEY);
                        // Default route.
                        out.writeInt(0);
                        // Have a gateway.
                        out.writeInt(1);
                        out.writeUTF(staticIpConfiguration.gateway.getHostAddress());
                    }
                    for (InetAddress inetAddr : staticIpConfiguration.dnsServers) {
                        out.writeUTF(DNS_KEY);
                        out.writeUTF(inetAddr.getHostAddress());
                    }
                }
                written = true;
                break;
            case DHCP:
                out.writeUTF(IP_ASSIGNMENT_KEY);
                out.writeUTF(config.ipAssignment.toString());
                written = true;
                break;
            case UNASSIGNED:
                /* Ignore */
                break;
            default:
                loge("Ignore invalid ip assignment while writing");
                break;
        }
        switch(config.proxySettings) {
            case STATIC:
                ProxyInfo proxyProperties = config.httpProxy;
                String exclusionList = proxyProperties.getExclusionListAsString();
                out.writeUTF(PROXY_SETTINGS_KEY);
                out.writeUTF(config.proxySettings.toString());
                out.writeUTF(PROXY_HOST_KEY);
                out.writeUTF(proxyProperties.getHost());
                out.writeUTF(PROXY_PORT_KEY);
                out.writeInt(proxyProperties.getPort());
                if (exclusionList != null) {
                    out.writeUTF(EXCLUSION_LIST_KEY);
                    out.writeUTF(exclusionList);
                }
                written = true;
                break;
            case PAC:
                ProxyInfo proxyPacProperties = config.httpProxy;
                out.writeUTF(PROXY_SETTINGS_KEY);
                out.writeUTF(config.proxySettings.toString());
                out.writeUTF(PROXY_PAC_FILE);
                out.writeUTF(proxyPacProperties.getPacFileUrl().toString());
                written = true;
                break;
            case NONE:
                out.writeUTF(PROXY_SETTINGS_KEY);
                out.writeUTF(config.proxySettings.toString());
                written = true;
                break;
            case UNASSIGNED:
                /* Ignore */
                break;
            default:
                loge("Ignore invalid proxy settings while writing");
                break;
        }
        if (written) {
            out.writeUTF(ID_KEY);
            if (version < 3) {
                out.writeInt(Integer.valueOf(configKey));
            } else {
                out.writeUTF(configKey);
            }
        }
    } catch (NullPointerException e) {
        loge("Failure in writing " + config + e);
    }
    out.writeUTF(EOS);
    return written;
}
#end_block

#method_before
@Deprecated
public void writeIpAndProxyConfigurationsToFile(String filePath, final SparseArray<IpConfiguration> networks) {
    mWriter.write(filePath, new DelayedDiskWrite.Writer() {

        public void onWriteCalled(DataOutputStream out) throws IOException {
            out.writeInt(IPCONFIG_FILE_VERSION);
            for (int i = 0; i < networks.size(); i++) {
                writeConfig(out, String.valueOf(networks.keyAt(i)), networks.valueAt(i));
            }
        }
    });
}
#method_after
@Deprecated
public void writeIpAndProxyConfigurationsToFile(String filePath, final SparseArray<IpConfiguration> networks) {
    mWriter.write(filePath, out -> {
        out.writeInt(IPCONFIG_FILE_VERSION);
        for (int i = 0; i < networks.size(); i++) {
            writeConfig(out, String.valueOf(networks.keyAt(i)), networks.valueAt(i));
        }
    });
}
#end_block

#method_before
public boolean isAvailable(String iface) {
    try {
        return mService.isAvailable(iface);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public boolean isAvailable() {
    return getAvailableInterfaces().length > 0;
}
#end_block

#method_before
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // If the user is logged out, allow them to log back in and return to the page.
    // Set the logout URL to direct back to a login page that directs to the current request.
    UserService userService = UserServiceFactory.getUserService();
    Optional<User> currentUser = Optional.ofNullable(userService.getCurrentUser());
    String currentUserEmail = currentUser.isPresent() ? currentUser.map(user -> user.getEmail().trim()).orElse("") : "";
    String requestUri = request.getRequestURI();
    String requestArgs = request.getQueryString();
    String loginURI = userService.createLoginURL(requestUri + '?' + requestArgs);
    String logoutURI = userService.createLogoutURL(loginURI);
    if (currentUserEmail != "") {
        int activeIndex;
        switch(getNavParentType()) {
            case PROFILING_LIST:
                activeIndex = 3;
                break;
            case COVERAGE_OVERVIEW:
                activeIndex = 2;
                break;
            case RELEASE:
                activeIndex = 1;
                break;
            default:
                activeIndex = 0;
                break;
        }
        if (request.getParameter(TREE_DEFAULT_PARAM) != null) {
            HttpSession session = request.getSession(true);
            boolean treeDefault = request.getParameter(TREE_DEFAULT_PARAM).equals("true");
            session.setAttribute(TREE_DEFAULT_PARAM, treeDefault);
        }
        request.setAttribute("serverName", request.getServerName());
        request.setAttribute("logoutURL", logoutURI);
        request.setAttribute("email", currentUserEmail);
        request.setAttribute("analyticsID", new Gson().toJson(ANALYTICS_ID));
        request.setAttribute("breadcrumbLinks", getBreadcrumbLinks(request));
        request.setAttribute("navbarLinks", navbarLinks);
        request.setAttribute("activeIndex", activeIndex);
        response.setContentType("text/html");
        if (currentUserEmail.endsWith("google.com")) {
            doGetHandler(request, response);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher("WEB-INF/jsp/auth_error.jsp");
            try {
                dispatcher.forward(request, response);
            } catch (ServletException e) {
                logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
            }
        }
    } else {
        response.sendRedirect(loginURI);
    }
}
#method_after
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // If the user is logged out, allow them to log back in and return to the page.
    // Set the logout URL to direct back to a login page that directs to the current request.
    UserService userService = UserServiceFactory.getUserService();
    Optional<User> currentUser = Optional.ofNullable(userService.getCurrentUser());
    String currentUserEmail = currentUser.isPresent() ? currentUser.map(user -> user.getEmail().trim()).orElse("") : "";
    String requestUri = request.getRequestURI();
    String requestArgs = request.getQueryString();
    String loginURI = userService.createLoginURL(requestUri + '?' + requestArgs);
    String logoutURI = userService.createLogoutURL(loginURI);
    if (currentUserEmail != "") {
        int activeIndex;
        switch(getNavParentType()) {
            case PROFILING_LIST:
                activeIndex = 3;
                break;
            case COVERAGE_OVERVIEW:
                activeIndex = 2;
                break;
            case RELEASE:
                activeIndex = 1;
                break;
            default:
                activeIndex = 0;
                break;
        }
        if (request.getParameter(TREE_DEFAULT_PARAM) != null) {
            HttpSession session = request.getSession(true);
            boolean treeDefault = request.getParameter(TREE_DEFAULT_PARAM).equals("true");
            session.setAttribute(TREE_DEFAULT_PARAM, treeDefault);
        }
        request.setAttribute("serverName", request.getServerName());
        request.setAttribute("logoutURL", logoutURI);
        request.setAttribute("email", currentUserEmail);
        request.setAttribute("analyticsID", new Gson().toJson(ANALYTICS_ID));
        request.setAttribute("breadcrumbLinks", getBreadcrumbLinks(request));
        request.setAttribute("navbarLinks", navbarLinks);
        request.setAttribute("activeIndex", activeIndex);
        response.setContentType("text/html");
        if (currentUserEmail.endsWith("google.com")) {
            doGetHandler(request, response);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher("WEB-INF/jsp/auth_error.jsp");
            try {
                dispatcher.forward(request, response);
            } catch (ServletException e) {
                logger.log(Level.SEVERE, "Servlet Exception caught : ", e);
            }
        }
    } else {
        response.sendRedirect(loginURI);
    }
}
#end_block

#method_before
public static long getMobileTxPackets() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        stat = getTxPackets(iface);
        if (stat != UNSUPPORTED) {
            total += stat;
        }
    }
    return total;
}
#method_after
public static long getMobileTxPackets() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getTxPackets(iface));
    }
    return total;
}
#end_block

#method_before
public static long getMobileRxPackets() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        stat = getRxPackets(iface);
        if (stat != UNSUPPORTED) {
            total += stat;
        }
    }
    return total;
}
#method_after
public static long getMobileRxPackets() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getRxPackets(iface));
    }
    return total;
}
#end_block

#method_before
public static long getMobileTxBytes() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        stat = getTxBytes(iface);
        if (stat != UNSUPPORTED) {
            total += stat;
        }
    }
    return total;
}
#method_after
public static long getMobileTxBytes() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getTxBytes(iface));
    }
    return total;
}
#end_block

#method_before
public static long getMobileRxBytes() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        stat = getRxBytes(iface);
        if (stat != UNSUPPORTED) {
            total += stat;
        }
    }
    return total;
}
#method_after
public static long getMobileRxBytes() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getRxBytes(iface));
    }
    return total;
}
#end_block

#method_before
public static long getMobileTcpRxPackets() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        try {
            stat = getStatsService().getIfaceStats(iface, TYPE_TCP_RX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        if (stat != UNSUPPORTED) {
            total += stat;
        }
    }
    return total;
}
#method_after
public static long getMobileTcpRxPackets() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        try {
            stat = getStatsService().getIfaceStats(iface, TYPE_TCP_RX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        total += addIfSupported(stat);
    }
    return total;
}
#end_block

#method_before
public static long getMobileTcpTxPackets() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        try {
            stat = getStatsService().getIfaceStats(iface, TYPE_TCP_TX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        if (stat != UNSUPPORTED) {
            total += stat;
        }
    }
    return total;
}
#method_after
public static long getMobileTcpTxPackets() {
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        try {
            stat = getStatsService().getIfaceStats(iface, TYPE_TCP_TX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        total += addIfSupported(stat);
    }
    return total;
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    if (args.length == 0) {
        writer.println("Skipping dump in APP SERVICES, see bluetooth_manager section.");
        writer.println("Use --print argument for dumpsys direct from AdapterService.");
        return;
    }
    verboseLog("dumpsys arguments, check for protobuf output: " + TextUtils.join(" ", args));
    if (args[0].startsWith("--proto")) {
        if (args[0].equals("--proto-bin")) {
            dumpMetrics(fd);
        }
        return;
    }
    writer.println("Bonded devices:");
    for (BluetoothDevice device : getBondedDevices()) {
        writer.println("  " + device.getAddress() + " [" + DEVICE_TYPE_NAMES[device.getType()] + "] " + device.getName());
    }
    // Dump profile information
    StringBuilder sb = new StringBuilder();
    synchronized (mProfiles) {
        for (ProfileService profile : mProfiles) {
            profile.dump(sb);
        }
    }
    writer.write(sb.toString());
    writer.flush();
    dumpNative(fd, args);
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    if (args.length == 0) {
        writer.println("Skipping dump in APP SERVICES, see bluetooth_manager section.");
        writer.println("Use --print argument for dumpsys direct from AdapterService.");
        return;
    }
    verboseLog("dumpsys arguments, check for protobuf output: " + TextUtils.join(" ", args));
    if (args[0].startsWith("--proto")) {
        if (args[0].equals("--proto-bin")) {
            dumpMetrics(fd);
        } else if (args[0].equals("--proto-java-bin")) {
            // TODO: Remove once --proto-java-bin is no longer used
            BluetoothProto.BluetoothLog metrics = new BluetoothProto.BluetoothLog();
            byte[] metricsBytes = Base64.encode(metrics.toByteArray(), Base64.DEFAULT);
            Log.w(TAG, "proto-java-bin dump, empty metrics size is " + metricsBytes.length);
            try (FileOutputStream protoOut = new FileOutputStream(fd)) {
                protoOut.write(metricsBytes);
            } catch (IOException e) {
                errorLog("Unable to write Java protobuf to file descriptor.");
            }
        }
        return;
    }
    writer.println("Bonded devices:");
    for (BluetoothDevice device : getBondedDevices()) {
        writer.println("  " + device.getAddress() + " [" + DEVICE_TYPE_NAMES[device.getType()] + "] " + device.getName());
    }
    // Dump profile information
    StringBuilder sb = new StringBuilder();
    synchronized (mProfiles) {
        for (ProfileService profile : mProfiles) {
            profile.dump(sb);
        }
    }
    writer.write(sb.toString());
    writer.flush();
    dumpNative(fd, args);
}
#end_block

#method_before
private void dumpMetrics(FileDescriptor fd) {
    Log.i(TAG, "dumpMetrics");
    BluetoothProto.BluetoothLog metrics = new BluetoothProto.BluetoothLog();
    metrics.setNumBondedDevices(getBondedDevices().length);
    for (ProfileService profile : mProfiles) {
        profile.dumpProto(metrics);
    }
    byte[] nativeMetricsBytes = dumpMetricsNative();
    Log.i(TAG, "dumpMetrics, native metrics size is " + nativeMetricsBytes.length);
    try {
        metrics.mergeFrom(nativeMetricsBytes);
    } catch (InvalidProtocolBufferMicroException ex) {
        Log.w(TAG, "Problem parsing metrics Protobuf: " + ex.getMessage());
        return;
    }
    byte[] metricsBytes = Base64.encode(metrics.toByteArray(), Base64.DEFAULT);
    Log.i(TAG, "dumpMetrics, combined metrics size is " + metricsBytes.length);
    try (FileOutputStream protoOut = new FileOutputStream(fd)) {
        protoOut.write(metricsBytes);
    } catch (IOException e) {
        errorLog("Unable to write Java protobuf to file descriptor.");
    }
}
#method_after
private void dumpMetrics(FileDescriptor fd) {
    BluetoothProto.BluetoothLog metrics = new BluetoothProto.BluetoothLog();
    metrics.setNumBondedDevices(getBondedDevices().length);
    for (ProfileService profile : mProfiles) {
        profile.dumpProto(metrics);
    }
    byte[] nativeMetricsBytes = dumpMetricsNative();
    debugLog("dumpMetrics: native metrics size is " + nativeMetricsBytes.length);
    if (nativeMetricsBytes.length > 0) {
        try {
            metrics.mergeFrom(nativeMetricsBytes);
        } catch (InvalidProtocolBufferMicroException ex) {
            Log.w(TAG, "dumpMetrics: problem parsing metrics protobuf, " + ex.getMessage());
            return;
        }
    }
    byte[] metricsBytes = Base64.encode(metrics.toByteArray(), Base64.DEFAULT);
    debugLog("dumpMetrics: combined metrics size is " + metricsBytes.length);
    try (FileOutputStream protoOut = new FileOutputStream(fd)) {
        protoOut.write(metricsBytes);
    } catch (IOException e) {
        errorLog("dumpMetrics: error writing combined protobuf to fd, " + e.getMessage());
    }
}
#end_block

#method_before
private void initOnce(CommandsInterface ci) {
    if (ci instanceof SimulatedRadioControl) {
        mSimulatedRadioControl = (SimulatedRadioControl) ci;
    }
    mCT = mTelephonyComponentFactory.makeGsmCdmaCallTracker(this);
    mIccPhoneBookIntManager = mTelephonyComponentFactory.makeIccPhoneBookInterfaceManager(this);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
    mIccSmsInterfaceManager = mTelephonyComponentFactory.makeIccSmsInterfaceManager(this);
    mIccCardProxy = mTelephonyComponentFactory.makeIccCardProxy(mContext, mCi, mPhoneId);
    mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
    mCi.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mCi.registerForOn(this, EVENT_RADIO_ON, null);
    mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
    // GSM
    mCi.setOnUSSD(this, EVENT_USSD, null);
    mCi.setOnSs(this, EVENT_SS, null);
    // CDMA
    mCdmaSSM = mTelephonyComponentFactory.getCdmaSubscriptionSourceManagerInstance(mContext, mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
    mEriManager = mTelephonyComponentFactory.makeEriManager(this, mContext, EriManager.ERI_FROM_XML);
    mCi.setEmergencyCallbackMode(this, EVENT_EMERGENCY_CALLBACK_MODE_ENTER, null);
    mCi.registerForExitEmergencyCallbackMode(this, EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE, null);
    // get the string that specifies the carrier OTA Sp number
    mCarrierOtaSpNumSchema = TelephonyManager.from(mContext).getOtaSpNumberSchemaForPhone(getPhoneId(), "");
    mResetModemOnRadioTechnologyChange = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RESET_ON_RADIO_TECH_CHANGE, false);
    mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
    mCi.registerForVoiceRadioTechChanged(this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
    mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED));
}
#method_after
private void initOnce(CommandsInterface ci) {
    if (ci instanceof SimulatedRadioControl) {
        mSimulatedRadioControl = (SimulatedRadioControl) ci;
    }
    mCT = mTelephonyComponentFactory.makeGsmCdmaCallTracker(this);
    mIccPhoneBookIntManager = mTelephonyComponentFactory.makeIccPhoneBookInterfaceManager(this);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
    mIccSmsInterfaceManager = mTelephonyComponentFactory.makeIccSmsInterfaceManager(this);
    mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
    mCi.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mCi.registerForOn(this, EVENT_RADIO_ON, null);
    mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
    // GSM
    mCi.setOnUSSD(this, EVENT_USSD, null);
    mCi.setOnSs(this, EVENT_SS, null);
    // CDMA
    mCdmaSSM = mTelephonyComponentFactory.getCdmaSubscriptionSourceManagerInstance(mContext, mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
    mEriManager = mTelephonyComponentFactory.makeEriManager(this, mContext, EriManager.ERI_FROM_XML);
    mCi.setEmergencyCallbackMode(this, EVENT_EMERGENCY_CALLBACK_MODE_ENTER, null);
    mCi.registerForExitEmergencyCallbackMode(this, EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE, null);
    mCi.registerForModemReset(this, EVENT_MODEM_RESET, null);
    // get the string that specifies the carrier OTA Sp number
    mCarrierOtaSpNumSchema = TelephonyManager.from(mContext).getOtaSpNumberSchemaForPhone(getPhoneId(), "");
    mResetModemOnRadioTechnologyChange = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RESET_ON_RADIO_TECH_CHANGE, false);
    mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
    mCi.registerForVoiceRadioTechChanged(this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
    mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED));
    mCDM = new CarrierKeyDownloadManager(this);
}
#end_block

#method_before
private void initRatSpecific(int precisePhoneType) {
    mPendingMMIs.clear();
    mIccPhoneBookIntManager.updateIccRecords(null);
    // todo: maybe not needed?? should the count also be updated on sim_state_absent?
    mVmCount = 0;
    mEsn = null;
    mMeid = null;
    mPrecisePhoneType = precisePhoneType;
    TelephonyManager tm = TelephonyManager.from(mContext);
    if (isPhoneTypeGsm()) {
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_GSM);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_GSM);
        mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else {
        mCdmaSubscriptionSource = CdmaSubscriptionSourceManager.SUBSCRIPTION_SOURCE_UNKNOWN;
        // This is needed to handle phone process crashes
        String inEcm = SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE, "false");
        mIsPhoneInEcmState = inEcm.equals("true");
        if (mIsPhoneInEcmState) {
            // Send a message which will invoke handleExitEmergencyCallbackMode
            mCi.exitEmergencyCallbackMode(obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
        }
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_CDMA);
        mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT);
        // Sets operator properties by retrieving from build-time system property
        String operatorAlpha = SystemProperties.get("ro.cdma.home.operator.alpha");
        String operatorNumeric = SystemProperties.get(PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
        logd("init: operatorAlpha='" + operatorAlpha + "' operatorNumeric='" + operatorNumeric + "'");
        if (mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP) == null || isPhoneTypeCdmaLte()) {
            if (!TextUtils.isEmpty(operatorAlpha)) {
                logd("init: set 'gsm.sim.operator.alpha' to operator='" + operatorAlpha + "'");
                tm.setSimOperatorNameForPhone(mPhoneId, operatorAlpha);
            }
            if (!TextUtils.isEmpty(operatorNumeric)) {
                logd("init: set 'gsm.sim.operator.numeric' to operator='" + operatorNumeric + "'");
                logd("update icc_operator_numeric=" + operatorNumeric);
                tm.setSimOperatorNumericForPhone(mPhoneId, operatorNumeric);
                SubscriptionController.getInstance().setMccMnc(operatorNumeric, getSubId());
                // Sets iso country property by retrieving from build-time system property
                setIsoCountryProperty(operatorNumeric);
                // Updates MCC MNC device configuration information
                logd("update mccmnc=" + operatorNumeric);
                MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
            }
        }
        // Sets current entry in the telephony carrier table
        updateCurrentCarrierInProvider(operatorNumeric);
    }
}
#method_after
private void initRatSpecific(int precisePhoneType) {
    mPendingMMIs.clear();
    mIccPhoneBookIntManager.updateIccRecords(null);
    mEsn = null;
    mMeid = null;
    mPrecisePhoneType = precisePhoneType;
    logd("Precise phone type " + mPrecisePhoneType);
    TelephonyManager tm = TelephonyManager.from(mContext);
    UiccProfile uiccProfile = getUiccProfile();
    if (isPhoneTypeGsm()) {
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_GSM);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_GSM);
        if (uiccProfile != null) {
            uiccProfile.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
        }
    } else {
        mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
        // This is needed to handle phone process crashes
        mIsPhoneInEcmState = getInEcmMode();
        if (mIsPhoneInEcmState) {
            // Send a message which will invoke handleExitEmergencyCallbackMode
            mCi.exitEmergencyCallbackMode(obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
        }
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_CDMA);
        if (uiccProfile != null) {
            uiccProfile.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT);
        }
        // Sets operator properties by retrieving from build-time system property
        String operatorAlpha = SystemProperties.get("ro.cdma.home.operator.alpha");
        String operatorNumeric = SystemProperties.get(PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
        logd("init: operatorAlpha='" + operatorAlpha + "' operatorNumeric='" + operatorNumeric + "'");
        if (!TextUtils.isEmpty(operatorAlpha)) {
            logd("init: set 'gsm.sim.operator.alpha' to operator='" + operatorAlpha + "'");
            tm.setSimOperatorNameForPhone(mPhoneId, operatorAlpha);
        }
        if (!TextUtils.isEmpty(operatorNumeric)) {
            logd("init: set 'gsm.sim.operator.numeric' to operator='" + operatorNumeric + "'");
            logd("update icc_operator_numeric=" + operatorNumeric);
            tm.setSimOperatorNumericForPhone(mPhoneId, operatorNumeric);
            SubscriptionController.getInstance().setMccMnc(operatorNumeric, getSubId());
            // Sets iso country property by retrieving from build-time system property
            setIsoCountryProperty(operatorNumeric);
            // Updates MCC MNC device configuration information
            logd("update mccmnc=" + operatorNumeric);
            MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
        }
        // Sets current entry in the telephony carrier table
        updateCurrentCarrierInProvider(operatorNumeric);
    }
}
#end_block

#method_before
@Override
protected void finalize() {
    if (DBG)
        logd("GsmCdmaPhone finalized");
    if (mWakeLock.isHeld()) {
        Rlog.e(LOG_TAG, "UNEXPECTED; mWakeLock is held when finalizing.");
        mWakeLock.release();
    }
}
#method_after
@Override
protected void finalize() {
    if (DBG)
        logd("GsmCdmaPhone finalized");
    if (mWakeLock != null && mWakeLock.isHeld()) {
        Rlog.e(LOG_TAG, "UNEXPECTED; mWakeLock is held when finalizing.");
        mWakeLock.release();
    }
}
#end_block

#method_before
@Override
public CellLocation getCellLocation() {
    if (isPhoneTypeGsm()) {
        return mSST.getCellLocation();
    } else {
        CdmaCellLocation loc = (CdmaCellLocation) mSST.mCellLoc;
        int mode = Settings.Secure.getInt(getContext().getContentResolver(), Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF);
        if (mode == Settings.Secure.LOCATION_MODE_OFF) {
            // clear lat/long values for location privacy
            CdmaCellLocation privateLoc = new CdmaCellLocation();
            privateLoc.setCellLocationData(loc.getBaseStationId(), CdmaCellLocation.INVALID_LAT_LONG, CdmaCellLocation.INVALID_LAT_LONG, loc.getSystemId(), loc.getNetworkId());
            loc = privateLoc;
        }
        return loc;
    }
}
#method_after
@Override
public CellLocation getCellLocation(WorkSource workSource) {
    if (isPhoneTypeGsm()) {
        return mSST.getCellLocation(workSource);
    } else {
        CdmaCellLocation loc = (CdmaCellLocation) mSST.mCellLoc;
        int mode = Settings.Secure.getInt(getContext().getContentResolver(), Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF);
        if (mode == Settings.Secure.LOCATION_MODE_OFF) {
            // clear lat/long values for location privacy
            CdmaCellLocation privateLoc = new CdmaCellLocation();
            privateLoc.setCellLocationData(loc.getBaseStationId(), CdmaCellLocation.INVALID_LAT_LONG, CdmaCellLocation.INVALID_LAT_LONG, loc.getSystemId(), loc.getNetworkId());
            loc = privateLoc;
        }
        return loc;
    }
}
#end_block

#method_before
@Override
public void updateVoiceMail() {
    if (isPhoneTypeGsm()) {
        int countVoiceMessages = 0;
        IccRecords r = mIccRecords.get();
        if (r != null) {
            // get voice mail count from SIM
            countVoiceMessages = r.getVoiceMessageCount();
        }
        int countVoiceMessagesStored = getStoredVoiceMessageCount();
        if (countVoiceMessages == -1 && countVoiceMessagesStored != 0) {
            countVoiceMessages = countVoiceMessagesStored;
        }
        logd("updateVoiceMail countVoiceMessages = " + countVoiceMessages + " subId " + getSubId());
        setVoiceMessageCount(countVoiceMessages);
    } else {
        setVoiceMessageCount(getStoredVoiceMessageCount());
    }
}
#method_after
@Override
public void updateVoiceMail() {
    if (isPhoneTypeGsm()) {
        int countVoiceMessages = 0;
        IccRecords r = mIccRecords.get();
        if (r != null) {
            // get voice mail count from SIM
            countVoiceMessages = r.getVoiceMessageCount();
        }
        if (countVoiceMessages == IccRecords.DEFAULT_VOICE_MESSAGE_COUNT) {
            countVoiceMessages = getStoredVoiceMessageCount();
        }
        logd("updateVoiceMail countVoiceMessages = " + countVoiceMessages + " subId " + getSubId());
        setVoiceMessageCount(countVoiceMessages);
    } else {
        setVoiceMessageCount(getStoredVoiceMessageCount());
    }
}
#end_block

#method_before
@Override
public PhoneConstants.DataState getDataConnectionState(String apnType) {
    PhoneConstants.DataState ret = PhoneConstants.DataState.DISCONNECTED;
    if (mSST == null) {
        // Radio Technology Change is ongoning, dispose() and removeReferences() have
        // already been called
        ret = PhoneConstants.DataState.DISCONNECTED;
    } else if (mSST.getCurrentDataConnectionState() != ServiceState.STATE_IN_SERVICE && (isPhoneTypeCdma() || (isPhoneTypeGsm() && !apnType.equals(PhoneConstants.APN_TYPE_EMERGENCY)))) {
        // If we're out of service, open TCP sockets may still work
        // but no data will flow
        // Emergency APN is available even in Out Of Service
        // Pass the actual State of EPDN
        ret = PhoneConstants.DataState.DISCONNECTED;
    } else {
        /* mSST.gprsState == ServiceState.STATE_IN_SERVICE */
        switch(mDcTracker.getState(apnType)) {
            case RETRYING:
            case FAILED:
            case IDLE:
                ret = PhoneConstants.DataState.DISCONNECTED;
                break;
            case CONNECTED:
            case DISCONNECTING:
                if (mCT.mState != PhoneConstants.State.IDLE && !mSST.isConcurrentVoiceAndDataAllowed()) {
                    ret = PhoneConstants.DataState.SUSPENDED;
                } else {
                    ret = PhoneConstants.DataState.CONNECTED;
                }
                break;
            case CONNECTING:
            case SCANNING:
                ret = PhoneConstants.DataState.CONNECTING;
                break;
        }
    }
    logd("getDataConnectionState apnType=" + apnType + " ret=" + ret);
    return ret;
}
#method_after
@Override
public PhoneConstants.DataState getDataConnectionState(String apnType) {
    PhoneConstants.DataState ret = PhoneConstants.DataState.DISCONNECTED;
    if (mSST == null) {
        // Radio Technology Change is ongoning, dispose() and removeReferences() have
        // already been called
        ret = PhoneConstants.DataState.DISCONNECTED;
    } else if (mSST.getCurrentDataConnectionState() != ServiceState.STATE_IN_SERVICE && (isPhoneTypeCdma() || isPhoneTypeCdmaLte() || (isPhoneTypeGsm() && !apnType.equals(PhoneConstants.APN_TYPE_EMERGENCY)))) {
        // If we're out of service, open TCP sockets may still work
        // but no data will flow
        // Emergency APN is available even in Out Of Service
        // Pass the actual State of EPDN
        ret = PhoneConstants.DataState.DISCONNECTED;
    } else {
        /* mSST.gprsState == ServiceState.STATE_IN_SERVICE */
        switch(mDcTracker.getState(apnType)) {
            case RETRYING:
            case FAILED:
            case IDLE:
                ret = PhoneConstants.DataState.DISCONNECTED;
                break;
            case CONNECTED:
            case DISCONNECTING:
                if (mCT.mState != PhoneConstants.State.IDLE && !mSST.isConcurrentVoiceAndDataAllowed()) {
                    ret = PhoneConstants.DataState.SUSPENDED;
                } else {
                    ret = PhoneConstants.DataState.CONNECTED;
                }
                break;
            case CONNECTING:
            case SCANNING:
                ret = PhoneConstants.DataState.CONNECTING;
                break;
        }
    }
    logd("getDataConnectionState apnType=" + apnType + " ret=" + ret);
    return ret;
}
#end_block

#method_before
private void sendEmergencyCallbackModeChange() {
    // Send an Intent
    Intent intent = new Intent(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
    intent.putExtra(PhoneConstants.PHONE_IN_ECM_STATE, mIsPhoneInEcmState);
    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, getPhoneId());
    ActivityManagerNative.broadcastStickyIntent(intent, null, UserHandle.USER_ALL);
    if (DBG)
        logd("sendEmergencyCallbackModeChange");
}
#method_after
private void sendEmergencyCallbackModeChange() {
    // Send an Intent
    Intent intent = new Intent(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
    intent.putExtra(PhoneConstants.PHONE_IN_ECM_STATE, isInEcm());
    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, getPhoneId());
    ActivityManager.broadcastStickyIntent(intent, UserHandle.USER_ALL);
    if (DBG)
        logd("sendEmergencyCallbackModeChange");
}
#end_block

#method_before
@Override
public void sendEmergencyCallStateChange(boolean callActive) {
    if (mBroadcastEmergencyCallStateChanges) {
        Intent intent = new Intent(TelephonyIntents.ACTION_EMERGENCY_CALL_STATE_CHANGED);
        intent.putExtra(PhoneConstants.PHONE_IN_EMERGENCY_CALL, callActive);
        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, getPhoneId());
        ActivityManagerNative.broadcastStickyIntent(intent, null, UserHandle.USER_ALL);
        if (DBG)
            Rlog.d(LOG_TAG, "sendEmergencyCallStateChange");
    }
}
#method_after
@Override
public void sendEmergencyCallStateChange(boolean callActive) {
    if (mBroadcastEmergencyCallStateChanges) {
        Intent intent = new Intent(TelephonyIntents.ACTION_EMERGENCY_CALL_STATE_CHANGED);
        intent.putExtra(PhoneConstants.PHONE_IN_EMERGENCY_CALL, callActive);
        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, getPhoneId());
        ActivityManager.broadcastStickyIntent(intent, UserHandle.USER_ALL);
        if (DBG)
            Rlog.d(LOG_TAG, "sendEmergencyCallStateChange: callActive " + callActive);
    }
}
#end_block

#method_before
// override for allowing access from other classes of this package
@Override
public void setSystemProperty(String property, String value) {
    if (getUnitTestMode()) {
        return;
    }
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        TelephonyManager.setTelephonyProperty(mPhoneId, property, value);
    } else {
        super.setSystemProperty(property, value);
    }
}
#method_after
// override for allowing access from other classes of this package
@Override
public void setSystemProperty(String property, String value) {
    if (getUnitTestMode()) {
        return;
    }
    TelephonyManager.setTelephonyProperty(mPhoneId, property, value);
}
#end_block

#method_before
@Override
public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    if (!isPhoneTypeGsm() && uusInfo != null) {
        throw new CallStateException("Sending UUS information NOT supported in CDMA!");
    }
    boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(dialString);
    Phone imsPhone = mImsPhone;
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    boolean alwaysTryImsForEmergencyCarrierConfig = configManager.getConfigForSubId(getSubId()).getBoolean(CarrierConfigManager.KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL);
    boolean imsUseEnabled = isImsUseEnabled() && imsPhone != null && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() || (imsPhone.isVideoEnabled() && VideoProfile.isVideo(videoState))) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
    boolean useImsForEmergency = imsPhone != null && isEmergency && alwaysTryImsForEmergencyCarrierConfig && ImsManager.isNonTtyOrTtyOnVolteEnabled(mContext) && (imsPhone.getServiceState().getState() != ServiceState.STATE_POWER_OFF);
    String dialPart = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.stripSeparators(dialString));
    boolean isUt = (dialPart.startsWith("*") || dialPart.startsWith("#")) && dialPart.endsWith("#");
    boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
    if (DBG) {
        logd("imsUseEnabled=" + imsUseEnabled + ", useImsForEmergency=" + useImsForEmergency + ", useImsForUt=" + useImsForUt + ", isUt=" + isUt + ", imsPhone=" + imsPhone + ", imsPhone.isVolteEnabled()=" + ((imsPhone != null) ? imsPhone.isVolteEnabled() : "N/A") + ", imsPhone.isVowifiEnabled()=" + ((imsPhone != null) ? imsPhone.isWifiCallingEnabled() : "N/A") + ", imsPhone.isVideoEnabled()=" + ((imsPhone != null) ? imsPhone.isVideoEnabled() : "N/A") + ", imsPhone.getServiceState().getState()=" + ((imsPhone != null) ? imsPhone.getServiceState().getState() : "N/A"));
    }
    Phone.checkWfcWifiOnlyModeBeforeDial(mImsPhone, mContext);
    if ((imsUseEnabled && (!isUt || useImsForUt)) || useImsForEmergency) {
        try {
            if (DBG)
                logd("Trying IMS PS call");
            return imsPhone.dial(dialString, uusInfo, videoState, intentExtras);
        } catch (CallStateException e) {
            if (DBG)
                logd("IMS PS call exception " + e + "imsUseEnabled =" + imsUseEnabled + ", imsPhone =" + imsPhone);
            if (!Phone.CS_FALLBACK.equals(e.getMessage())) {
                CallStateException ce = new CallStateException(e.getMessage());
                ce.setStackTrace(e.getStackTrace());
                throw ce;
            }
        }
    }
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && mSST.mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && !isEmergency) {
        throw new CallStateException("cannot dial in current state");
    }
    if (DBG)
        logd("Trying (non-IMS) CS call");
    if (isPhoneTypeGsm()) {
        return dialInternal(dialString, null, VideoProfile.STATE_AUDIO_ONLY, intentExtras);
    } else {
        return dialInternal(dialString, null, videoState, intentExtras);
    }
}
#method_after
@Override
public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    if (!isPhoneTypeGsm() && uusInfo != null) {
        throw new CallStateException("Sending UUS information NOT supported in CDMA!");
    }
    boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(getSubId(), dialString);
    Phone imsPhone = mImsPhone;
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    boolean alwaysTryImsForEmergencyCarrierConfig = configManager.getConfigForSubId(getSubId()).getBoolean(CarrierConfigManager.KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL);
    boolean useImsForCall = isImsUseEnabled() && imsPhone != null && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() || (imsPhone.isVideoEnabled() && VideoProfile.isVideo(videoState))) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
    boolean useImsForEmergency = imsPhone != null && isEmergency && alwaysTryImsForEmergencyCarrierConfig && ImsManager.getInstance(mContext, mPhoneId).isNonTtyOrTtyOnVolteEnabled() && imsPhone.isImsAvailable();
    String dialPart = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.stripSeparators(dialString));
    boolean isUt = (dialPart.startsWith("*") || dialPart.startsWith("#")) && dialPart.endsWith("#");
    boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
    if (DBG) {
        logd("useImsForCall=" + useImsForCall + ", useImsForEmergency=" + useImsForEmergency + ", useImsForUt=" + useImsForUt + ", isUt=" + isUt + ", imsPhone=" + imsPhone + ", imsPhone.isVolteEnabled()=" + ((imsPhone != null) ? imsPhone.isVolteEnabled() : "N/A") + ", imsPhone.isVowifiEnabled()=" + ((imsPhone != null) ? imsPhone.isWifiCallingEnabled() : "N/A") + ", imsPhone.isVideoEnabled()=" + ((imsPhone != null) ? imsPhone.isVideoEnabled() : "N/A") + ", imsPhone.getServiceState().getState()=" + ((imsPhone != null) ? imsPhone.getServiceState().getState() : "N/A"));
    }
    Phone.checkWfcWifiOnlyModeBeforeDial(mImsPhone, mPhoneId, mContext);
    if ((useImsForCall && !isUt) || (isUt && useImsForUt) || useImsForEmergency) {
        try {
            if (DBG)
                logd("Trying IMS PS call");
            return imsPhone.dial(dialString, uusInfo, videoState, intentExtras);
        } catch (CallStateException e) {
            if (DBG)
                logd("IMS PS call exception " + e + "useImsForCall =" + useImsForCall + ", imsPhone =" + imsPhone);
            // for emergency calls and MMI codes.
            if (Phone.CS_FALLBACK.equals(e.getMessage()) || isEmergency) {
                logi("IMS call failed with Exception: " + e.getMessage() + ". Falling back " + "to CS.");
            } else {
                CallStateException ce = new CallStateException(e.getMessage());
                ce.setStackTrace(e.getStackTrace());
                throw ce;
            }
        }
    }
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && mSST.mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && !isEmergency) {
        throw new CallStateException("cannot dial in current state");
    }
    // Check non-emergency voice CS call - shouldn't dial when POWER_OFF
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_POWER_OFF && /* CS POWER_OFF */
    !VideoProfile.isVideo(videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_POWER_OFF, "cannot dial voice call in airplane mode");
    }
    // Allow dial only if either CS is camped on any RAT (or) PS is in LTE service.
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && /* CS out of service */
    !(mSST.mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ServiceState.isLte(mSST.mSS.getRilDataRadioTechnology())) && /* PS not in LTE */
    !VideoProfile.isVideo(videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_OUT_OF_SERVICE, "cannot dial voice call in out of service");
    }
    if (DBG)
        logd("Trying (non-IMS) CS call");
    if (isPhoneTypeGsm()) {
        return dialInternal(dialString, null, VideoProfile.STATE_AUDIO_ONLY, intentExtras);
    } else {
        return dialInternal(dialString, null, videoState, intentExtras);
    }
}
#end_block

#method_before
@Override
protected Connection dialInternal(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    // Need to make sure dialString gets parsed properly
    String newDialString = PhoneNumberUtils.stripSeparators(dialString);
    if (isPhoneTypeGsm()) {
        // handle in-call MMI first if applicable
        if (handleInCallMmiCommands(newDialString)) {
            return null;
        }
        // Only look at the Network portion for mmi
        String networkPortion = PhoneNumberUtils.extractNetworkPortionAlt(newDialString);
        GsmMmiCode mmi = GsmMmiCode.newFromDialString(networkPortion, this, mUiccApplication.get());
        if (DBG)
            logd("dialing w/ mmi '" + mmi + "'...");
        if (mmi == null) {
            return mCT.dial(newDialString, uusInfo, intentExtras);
        } else if (mmi.isTemporaryModeCLIR()) {
            return mCT.dial(mmi.mDialingNumber, mmi.getCLIRMode(), uusInfo, intentExtras);
        } else {
            mPendingMMIs.add(mmi);
            mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
            try {
                mmi.processCode();
            } catch (CallStateException e) {
            // do nothing
            }
            // FIXME should this return null or something else?
            return null;
        }
    } else {
        return mCT.dial(newDialString);
    }
}
#method_after
@Override
protected Connection dialInternal(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    return dialInternal(dialString, uusInfo, videoState, intentExtras, null);
}
#end_block

#method_before
@Override
protected Connection dialInternal(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    // Need to make sure dialString gets parsed properly
    String newDialString = PhoneNumberUtils.stripSeparators(dialString);
    if (isPhoneTypeGsm()) {
        // handle in-call MMI first if applicable
        if (handleInCallMmiCommands(newDialString)) {
            return null;
        }
        // Only look at the Network portion for mmi
        String networkPortion = PhoneNumberUtils.extractNetworkPortionAlt(newDialString);
        GsmMmiCode mmi = GsmMmiCode.newFromDialString(networkPortion, this, mUiccApplication.get());
        if (DBG)
            logd("dialing w/ mmi '" + mmi + "'...");
        if (mmi == null) {
            return mCT.dial(newDialString, uusInfo, intentExtras);
        } else if (mmi.isTemporaryModeCLIR()) {
            return mCT.dial(mmi.mDialingNumber, mmi.getCLIRMode(), uusInfo, intentExtras);
        } else {
            mPendingMMIs.add(mmi);
            mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
            try {
                mmi.processCode();
            } catch (CallStateException e) {
            // do nothing
            }
            // FIXME should this return null or something else?
            return null;
        }
    } else {
        return mCT.dial(newDialString);
    }
}
#method_after
protected Connection dialInternal(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras, ResultReceiver wrappedCallback) throws CallStateException {
    // Need to make sure dialString gets parsed properly
    String newDialString = PhoneNumberUtils.stripSeparators(dialString);
    if (isPhoneTypeGsm()) {
        // handle in-call MMI first if applicable
        if (handleInCallMmiCommands(newDialString)) {
            return null;
        }
        // Only look at the Network portion for mmi
        String networkPortion = PhoneNumberUtils.extractNetworkPortionAlt(newDialString);
        GsmMmiCode mmi = GsmMmiCode.newFromDialString(networkPortion, this, mUiccApplication.get(), wrappedCallback);
        if (DBG)
            logd("dialInternal: dialing w/ mmi '" + mmi + "'...");
        if (mmi == null) {
            return mCT.dial(newDialString, uusInfo, intentExtras);
        } else if (mmi.isTemporaryModeCLIR()) {
            return mCT.dial(mmi.mDialingNumber, mmi.getCLIRMode(), uusInfo, intentExtras);
        } else {
            mPendingMMIs.add(mmi);
            mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
            mmi.processCode();
            return null;
        }
    } else {
        return mCT.dial(newDialString);
    }
}
#end_block

#method_before
@Override
public void sendUssdResponse(String ussdMessge) {
    if (isPhoneTypeGsm()) {
        GsmMmiCode mmi = GsmMmiCode.newFromUssdUserInput(ussdMessge, this, mUiccApplication.get());
        mPendingMMIs.add(mmi);
        mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
        mmi.sendUssd(ussdMessge);
    } else {
        loge("sendUssdResponse: not possible in CDMA");
    }
}
#method_after
private void sendUssdResponse(String ussdRequest, CharSequence message, int returnCode, ResultReceiver wrappedCallback) {
    UssdResponse response = new UssdResponse(ussdRequest, message);
    Bundle returnData = new Bundle();
    returnData.putParcelable(TelephonyManager.USSD_RESPONSE, response);
    wrappedCallback.send(returnCode, returnData);
}
#end_block

#method_before
@Override
public String getVoiceMailNumber() {
    String number = null;
    if (isPhoneTypeGsm()) {
        // Read from the SIM. If its null, try reading from the shared preference area.
        IccRecords r = mIccRecords.get();
        number = (r != null) ? r.getVoiceMailNumber() : "";
        if (TextUtils.isEmpty(number)) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
            number = sp.getString(VM_NUMBER + getPhoneId(), null);
        }
    } else {
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        number = sp.getString(VM_NUMBER_CDMA + getPhoneId(), null);
    }
    if (TextUtils.isEmpty(number)) {
        String[] listArray = getContext().getResources().getStringArray(com.android.internal.R.array.config_default_vm_number);
        if (listArray != null && listArray.length > 0) {
            for (int i = 0; i < listArray.length; i++) {
                if (!TextUtils.isEmpty(listArray[i])) {
                    String[] defaultVMNumberArray = listArray[i].split(";");
                    if (defaultVMNumberArray != null && defaultVMNumberArray.length > 0) {
                        if (defaultVMNumberArray.length == 1) {
                            number = defaultVMNumberArray[0];
                        } else if (defaultVMNumberArray.length == 2 && !TextUtils.isEmpty(defaultVMNumberArray[1]) && isMatchGid(defaultVMNumberArray[1])) {
                            number = defaultVMNumberArray[0];
                            break;
                        }
                    }
                }
            }
        }
    }
    if (!isPhoneTypeGsm() && TextUtils.isEmpty(number)) {
        // Read platform settings for dynamic voicemail number
        if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_telephony_use_own_number_for_voicemail)) {
            number = getLine1Number();
        } else {
            number = "*86";
        }
    }
    return number;
}
#method_after
@Override
public String getVoiceMailNumber() {
    String number = null;
    if (isPhoneTypeGsm()) {
        // Read from the SIM. If its null, try reading from the shared preference area.
        IccRecords r = mIccRecords.get();
        number = (r != null) ? r.getVoiceMailNumber() : "";
        if (TextUtils.isEmpty(number)) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
            number = sp.getString(VM_NUMBER + getPhoneId(), null);
        }
    } else {
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        number = sp.getString(VM_NUMBER_CDMA + getPhoneId(), null);
    }
    if (TextUtils.isEmpty(number)) {
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null) {
            String defaultVmNumber = b.getString(CarrierConfigManager.KEY_DEFAULT_VM_NUMBER_STRING);
            if (!TextUtils.isEmpty(defaultVmNumber)) {
                number = defaultVmNumber;
            }
        }
    }
    if (!isPhoneTypeGsm() && TextUtils.isEmpty(number)) {
        // Read platform settings for dynamic voicemail number
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null && b.getBoolean(CarrierConfigManager.KEY_CONFIG_TELEPHONY_USE_OWN_NUMBER_FOR_VOICEMAIL_BOOL)) {
            number = getLine1Number();
        } else {
            number = "*86";
        }
    }
    return number;
}
#end_block

#method_before
@Override
public String getDeviceId() {
    if (isPhoneTypeGsm()) {
        return mImei;
    } else {
        String id = getMeid();
        if ((id == null) || id.matches("^0*$")) {
            loge("getDeviceId(): MEID is not initialized use ESN");
            id = getEsn();
        }
        return id;
    }
}
#method_after
@Override
public String getDeviceId() {
    if (isPhoneTypeGsm()) {
        return mImei;
    } else {
        CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
        boolean force_imei = configManager.getConfigForSubId(getSubId()).getBoolean(CarrierConfigManager.KEY_FORCE_IMEI_BOOL);
        if (force_imei)
            return mImei;
        String id = getMeid();
        if ((id == null) || id.matches("^0*$")) {
            loge("getDeviceId(): MEID is not initialized use ESN");
            id = getEsn();
        }
        return id;
    }
}
#end_block

#method_before
@Override
public String getMeid() {
    if (isPhoneTypeGsm()) {
        loge("[GsmCdmaPhone] getMeid() is a CDMA method");
        return "0";
    } else {
        return mMeid;
    }
}
#method_after
@Override
public String getMeid() {
    return mMeid;
}
#end_block

#method_before
@Override
public String getSystemProperty(String property, String defValue) {
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        if (getUnitTestMode()) {
            return null;
        }
        return TelephonyManager.getTelephonyProperty(mPhoneId, property, defValue);
    } else {
        return super.getSystemProperty(property, defValue);
    }
}
#method_after
@Override
public String getSystemProperty(String property, String defValue) {
    if (getUnitTestMode()) {
        return null;
    }
    return TelephonyManager.getTelephonyProperty(mPhoneId, property, defValue);
}
#end_block

#method_before
@Override
public void getOutgoingCallerIdDisplay(Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
            imsPhone.getOutgoingCallerIdDisplay(onComplete);
            return;
        }
        mCi.getCLIR(onComplete);
    } else {
        loge("getOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#method_after
@Override
public void getOutgoingCallerIdDisplay(Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) || imsPhone.isUtEnabled())) {
            imsPhone.getOutgoingCallerIdDisplay(onComplete);
            return;
        }
        mCi.getCLIR(onComplete);
    } else {
        loge("getOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#end_block

#method_before
@Override
public void setOutgoingCallerIdDisplay(int commandInterfaceCLIRMode, Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
            imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, onComplete);
            return;
        }
        // Packing CLIR value in the message. This will be required for
        // SharedPreference caching, if the message comes back as part of
        // a success response.
        mCi.setCLIR(commandInterfaceCLIRMode, obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode, 0, onComplete));
    } else {
        loge("setOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#method_after
@Override
public void setOutgoingCallerIdDisplay(int commandInterfaceCLIRMode, Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) || imsPhone.isUtEnabled())) {
            imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, onComplete);
            return;
        }
        // Packing CLIR value in the message. This will be required for
        // SharedPreference caching, if the message comes back as part of
        // a success response.
        mCi.setCLIR(commandInterfaceCLIRMode, obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode, 0, onComplete));
    } else {
        loge("setOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#end_block

#method_before
@Override
public void getNeighboringCids(Message response) {
    if (isPhoneTypeGsm()) {
        mCi.getNeighboringCids(response);
    } else {
        /*
             * This is currently not implemented.  At least as of June
             * 2009, there is no neighbor cell information available for
             * CDMA because some party is resisting making this
             * information readily available.  Consequently, calling this
             * function can have no useful effect.  This situation may
             * (and hopefully will) change in the future.
             */
        if (response != null) {
            CommandException ce = new CommandException(CommandException.Error.REQUEST_NOT_SUPPORTED);
            AsyncResult.forMessage(response).exception = ce;
            response.sendToTarget();
        }
    }
}
#method_after
@Override
public void getNeighboringCids(Message response, WorkSource workSource) {
    if (isPhoneTypeGsm()) {
        mCi.getNeighboringCids(response, workSource);
    } else {
        /*
             * This is currently not implemented.  At least as of June
             * 2009, there is no neighbor cell information available for
             * CDMA because some party is resisting making this
             * information readily available.  Consequently, calling this
             * function can have no useful effect.  This situation may
             * (and hopefully will) change in the future.
             */
        if (response != null) {
            CommandException ce = new CommandException(CommandException.Error.REQUEST_NOT_SUPPORTED);
            AsyncResult.forMessage(response).exception = ce;
            response.sendToTarget();
        }
    }
}
#end_block

#method_before
@Override
public boolean getDataRoamingEnabled() {
    return mDcTracker.getDataOnRoamingEnabled();
}
#method_after
@Override
public boolean getDataRoamingEnabled() {
    return mDcTracker.getDataRoamingEnabled();
}
#end_block

#method_before
@Override
public void setDataRoamingEnabled(boolean enable) {
    mDcTracker.setDataOnRoamingEnabled(enable);
}
#method_after
@Override
public void setDataRoamingEnabled(boolean enable) {
    mDcTracker.setDataRoamingEnabledByUser(enable);
}
#end_block

#method_before
public void onMMIDone(MmiCode mmi) {
    /* Only notify complete if it's on the pending list.
         * Otherwise, it's already been handled (eg, previously canceled).
         * The exception is cancellation of an incoming USSD-REQUEST, which is
         * not on the list.
         */
    if (mPendingMMIs.remove(mmi) || (isPhoneTypeGsm() && (mmi.isUssdRequest() || ((GsmMmiCode) mmi).isSsInfo()))) {
        mMmiCompleteRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
    }
}
#method_after
public void onMMIDone(MmiCode mmi) {
    /* Only notify complete if it's on the pending list.
         * Otherwise, it's already been handled (eg, previously canceled).
         * The exception is cancellation of an incoming USSD-REQUEST, which is
         * not on the list.
         */
    if (mPendingMMIs.remove(mmi) || (isPhoneTypeGsm() && (mmi.isUssdRequest() || ((GsmMmiCode) mmi).isSsInfo()))) {
        ResultReceiver receiverCallback = mmi.getUssdCallbackReceiver();
        if (receiverCallback != null) {
            Rlog.i(LOG_TAG, "onMMIDone: invoking callback: " + mmi);
            int returnCode = (mmi.getState() == MmiCode.State.COMPLETE) ? TelephonyManager.USSD_RETURN_SUCCESS : TelephonyManager.USSD_RETURN_FAILURE;
            sendUssdResponse(mmi.getDialString(), mmi.getMessage(), returnCode, receiverCallback);
        } else {
            Rlog.i(LOG_TAG, "onMMIDone: notifying registrants: " + mmi);
            mMmiCompleteRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
        }
    } else {
        Rlog.i(LOG_TAG, "onMMIDone: invalid response or already handled; ignoring: " + mmi);
    }
}
#end_block

#method_before
private void onNetworkInitiatedUssd(MmiCode mmi) {
    mMmiCompleteRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
}
#method_after
private void onNetworkInitiatedUssd(MmiCode mmi) {
    Rlog.v(LOG_TAG, "onNetworkInitiatedUssd: mmi=" + mmi);
    mMmiCompleteRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
}
#end_block

#method_before
private void onIncomingUSSD(int ussdMode, String ussdMessage) {
    if (!isPhoneTypeGsm()) {
        loge("onIncomingUSSD: not expected on GSM");
    }
    boolean isUssdError;
    boolean isUssdRequest;
    boolean isUssdRelease;
    isUssdRequest = (ussdMode == CommandsInterface.USSD_MODE_REQUEST);
    isUssdError = (ussdMode != CommandsInterface.USSD_MODE_NOTIFY && ussdMode != CommandsInterface.USSD_MODE_REQUEST);
    isUssdRelease = (ussdMode == CommandsInterface.USSD_MODE_NW_RELEASE);
    // See comments in GsmMmiCode.java
    // USSD requests aren't finished until one
    // of these two events happen
    GsmMmiCode found = null;
    for (int i = 0, s = mPendingMMIs.size(); i < s; i++) {
        if (((GsmMmiCode) mPendingMMIs.get(i)).isPendingUSSD()) {
            found = (GsmMmiCode) mPendingMMIs.get(i);
            break;
        }
    }
    if (found != null) {
        if (isUssdRelease) {
            found.onUssdRelease();
        } else if (isUssdError) {
            found.onUssdFinishedError();
        } else {
            found.onUssdFinished(ussdMessage, isUssdRequest);
        }
    } else {
        // also, discard if there is no message to present
        if (!isUssdError && ussdMessage != null) {
            GsmMmiCode mmi;
            mmi = GsmMmiCode.newNetworkInitiatedUssd(ussdMessage, isUssdRequest, GsmCdmaPhone.this, mUiccApplication.get());
            onNetworkInitiatedUssd(mmi);
        }
    }
}
#method_after
private void onIncomingUSSD(int ussdMode, String ussdMessage) {
    if (!isPhoneTypeGsm()) {
        loge("onIncomingUSSD: not expected on GSM");
    }
    boolean isUssdError;
    boolean isUssdRequest;
    boolean isUssdRelease;
    isUssdRequest = (ussdMode == CommandsInterface.USSD_MODE_REQUEST);
    isUssdError = (ussdMode != CommandsInterface.USSD_MODE_NOTIFY && ussdMode != CommandsInterface.USSD_MODE_REQUEST);
    isUssdRelease = (ussdMode == CommandsInterface.USSD_MODE_NW_RELEASE);
    // See comments in GsmMmiCode.java
    // USSD requests aren't finished until one
    // of these two events happen
    GsmMmiCode found = null;
    for (int i = 0, s = mPendingMMIs.size(); i < s; i++) {
        if (((GsmMmiCode) mPendingMMIs.get(i)).isPendingUSSD()) {
            found = (GsmMmiCode) mPendingMMIs.get(i);
            break;
        }
    }
    if (found != null) {
        if (isUssdRelease) {
            found.onUssdRelease();
        } else if (isUssdError) {
            found.onUssdFinishedError();
        } else {
            found.onUssdFinished(ussdMessage, isUssdRequest);
        }
    } else if (!isUssdError && ussdMessage != null) {
        // pending USSD not found
        // The network may initiate its own USSD request
        // ignore everything that isnt a Notify or a Request
        // also, discard if there is no message to present
        GsmMmiCode mmi;
        mmi = GsmMmiCode.newNetworkInitiatedUssd(ussdMessage, isUssdRequest, GsmCdmaPhone.this, mUiccApplication.get());
        onNetworkInitiatedUssd(mmi);
    }
}
#end_block

#method_before
private void syncClirSetting() {
    SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
    int clirSetting = sp.getInt(CLIR_KEY + getPhoneId(), -1);
    if (clirSetting >= 0) {
        mCi.setCLIR(clirSetting, null);
    }
}
#method_after
private void syncClirSetting() {
    SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
    int clirSetting = sp.getInt(CLIR_KEY + getPhoneId(), -1);
    Rlog.i(LOG_TAG, "syncClirSetting: " + CLIR_KEY + getPhoneId() + "=" + clirSetting);
    if (clirSetting >= 0) {
        mCi.setCLIR(clirSetting, null);
    }
}
#end_block

#method_before
private void handleRadioAvailable() {
    mCi.getBasebandVersion(obtainMessage(EVENT_GET_BASEBAND_VERSION_DONE));
    if (isPhoneTypeGsm()) {
        mCi.getIMEI(obtainMessage(EVENT_GET_IMEI_DONE));
        mCi.getIMEISV(obtainMessage(EVENT_GET_IMEISV_DONE));
    } else {
        mCi.getDeviceIdentity(obtainMessage(EVENT_GET_DEVICE_IDENTITY_DONE));
    }
    mCi.getRadioCapability(obtainMessage(EVENT_GET_RADIO_CAPABILITY));
    startLceAfterRadioIsAvailable();
}
#method_after
private void handleRadioAvailable() {
    mCi.getBasebandVersion(obtainMessage(EVENT_GET_BASEBAND_VERSION_DONE));
    mCi.getDeviceIdentity(obtainMessage(EVENT_GET_DEVICE_IDENTITY_DONE));
    mCi.getRadioCapability(obtainMessage(EVENT_GET_RADIO_CAPABILITY));
    startLceAfterRadioIsAvailable();
}
#end_block

#method_before
private void handleRadioOffOrNotAvailable() {
    if (isPhoneTypeGsm()) {
        for (int i = mPendingMMIs.size() - 1; i >= 0; i--) {
            if (((GsmMmiCode) mPendingMMIs.get(i)).isPendingUSSD()) {
                ((GsmMmiCode) mPendingMMIs.get(i)).onUssdFinishedError();
            }
        }
    }
    Phone imsPhone = mImsPhone;
    if (imsPhone != null) {
        imsPhone.getServiceState().setStateOff();
    }
    mRadioOffOrNotAvailableRegistrants.notifyRegistrants();
}
#method_after
private void handleRadioOffOrNotAvailable() {
    if (isPhoneTypeGsm()) {
        for (int i = mPendingMMIs.size() - 1; i >= 0; i--) {
            if (((GsmMmiCode) mPendingMMIs.get(i)).isPendingUSSD()) {
                ((GsmMmiCode) mPendingMMIs.get(i)).onUssdFinishedError();
            }
        }
    }
    mRadioOffOrNotAvailableRegistrants.notifyRegistrants();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service
            ImsManager.updateImsServiceConfig(mContext, mPhoneId, true);
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges =" + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            if (!isPhoneTypeGsm()) {
                mSST.pollState();
            }
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            if (isPhoneTypeGsm()) {
                updateCurrentCarrierInProvider();
                // Check if this is a different SIM than the previous one. If so unset the
                // voice mail number.
                String imsi = getVmSimImsi();
                String imsiFromSIM = getSubscriberId();
                if (imsi != null && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                    storeVoiceMailNumber(null);
                    setVmSimImsi(null);
                }
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_MODEM_RESET:
            {
                logd("Event EVENT_MODEM_RESET Received" + " isInEcm = " + isInEcm() + " isPhoneTypeGsm = " + isPhoneTypeGsm() + " mImsPhone = " + mImsPhone);
                if (isInEcm()) {
                    if (isPhoneTypeGsm()) {
                        if (mImsPhone != null) {
                            mImsPhone.handleExitEmergencyCallbackMode();
                        }
                    } else {
                        handleExitEmergencyCallbackMode(msg);
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service
            ImsManager.getInstance(mContext, mPhoneId).updateImsServiceConfig(true);
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            if (!isPhoneTypeGsm()) {
                mSST.pollState();
            }
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#end_block

#method_before
@Override
protected void onUpdateIccAvailability() {
    if (mUiccController == null) {
        return;
    }
    UiccCardApplication newUiccApplication = null;
    // Update mIsimUiccRecords
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_IMS);
        IsimUiccRecords newIsimUiccRecords = null;
        if (newUiccApplication != null) {
            newIsimUiccRecords = (IsimUiccRecords) newUiccApplication.getIccRecords();
            if (DBG)
                logd("New ISIM application found");
        }
        mIsimUiccRecords = newIsimUiccRecords;
    }
    // Update mSimRecords
    if (mSimRecords != null) {
        mSimRecords.unregisterForRecordsLoaded(this);
    }
    if (isPhoneTypeCdmaLte()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
        SIMRecords newSimRecords = null;
        if (newUiccApplication != null) {
            newSimRecords = (SIMRecords) newUiccApplication.getIccRecords();
        }
        mSimRecords = newSimRecords;
        if (mSimRecords != null) {
            mSimRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
    } else {
        mSimRecords = null;
    }
    // Update mIccRecords, mUiccApplication, mIccPhoneBookIntManager
    newUiccApplication = getUiccCardApplication();
    if (!isPhoneTypeGsm() && newUiccApplication == null) {
        logd("can't find 3GPP2 application; trying APP_FAM_3GPP");
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
    }
    UiccCardApplication app = mUiccApplication.get();
    if (app != newUiccApplication) {
        if (app != null) {
            if (DBG)
                logd("Removing stale icc objects.");
            if (mIccRecords.get() != null) {
                unregisterForIccRecordEvents();
                mIccPhoneBookIntManager.updateIccRecords(null);
            }
            mIccRecords.set(null);
            mUiccApplication.set(null);
        }
        if (newUiccApplication != null) {
            if (DBG) {
                logd("New Uicc application found. type = " + newUiccApplication.getType());
            }
            mUiccApplication.set(newUiccApplication);
            mIccRecords.set(newUiccApplication.getIccRecords());
            registerForIccRecordEvents();
            mIccPhoneBookIntManager.updateIccRecords(mIccRecords.get());
        }
    }
}
#method_after
// todo: check if ICC availability needs to be handled here. mSimRecords should not be needed
// now because APIs can be called directly on UiccProfile, and that should handle the requests
@Override
protected void onUpdateIccAvailability() {
    if (mUiccController == null) {
        return;
    }
    UiccCardApplication newUiccApplication = null;
    // Update mIsimUiccRecords
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_IMS);
        IsimUiccRecords newIsimUiccRecords = null;
        if (newUiccApplication != null) {
            newIsimUiccRecords = (IsimUiccRecords) newUiccApplication.getIccRecords();
            if (DBG)
                logd("New ISIM application found");
        }
        mIsimUiccRecords = newIsimUiccRecords;
    }
    // Update mSimRecords
    if (mSimRecords != null) {
        mSimRecords.unregisterForRecordsLoaded(this);
    }
    if (isPhoneTypeCdmaLte() || isPhoneTypeCdma()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
        SIMRecords newSimRecords = null;
        if (newUiccApplication != null) {
            newSimRecords = (SIMRecords) newUiccApplication.getIccRecords();
        }
        mSimRecords = newSimRecords;
        if (mSimRecords != null) {
            mSimRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
    } else {
        mSimRecords = null;
    }
    // Update mIccRecords, mUiccApplication, mIccPhoneBookIntManager
    newUiccApplication = getUiccCardApplication();
    if (!isPhoneTypeGsm() && newUiccApplication == null) {
        logd("can't find 3GPP2 application; trying APP_FAM_3GPP");
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
    }
    UiccCardApplication app = mUiccApplication.get();
    if (app != newUiccApplication) {
        if (app != null) {
            if (DBG)
                logd("Removing stale icc objects.");
            if (mIccRecords.get() != null) {
                unregisterForIccRecordEvents();
                mIccPhoneBookIntManager.updateIccRecords(null);
            }
            mIccRecords.set(null);
            mUiccApplication.set(null);
        }
        if (newUiccApplication != null) {
            if (DBG) {
                logd("New Uicc application found. type = " + newUiccApplication.getType());
            }
            mUiccApplication.set(newUiccApplication);
            mIccRecords.set(newUiccApplication.getIccRecords());
            registerForIccRecordEvents();
            mIccPhoneBookIntManager.updateIccRecords(mIccRecords.get());
        }
    }
}
#end_block

#method_before
private void processIccRecordEvents(int eventCode) {
    switch(eventCode) {
        case IccRecords.EVENT_CFI:
            notifyCallForwardingIndicator();
            break;
    }
}
#method_after
private void processIccRecordEvents(int eventCode) {
    switch(eventCode) {
        case IccRecords.EVENT_CFI:
            logi("processIccRecordEvents: EVENT_CFI");
            notifyCallForwardingIndicator();
            break;
    }
}
#end_block

#method_before
@Override
public boolean updateCurrentCarrierInProvider() {
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        long currentDds = SubscriptionManager.getDefaultDataSubscriptionId();
        String operatorNumeric = getOperatorNumeric();
        logd("updateCurrentCarrierInProvider: mSubId = " + getSubId() + " currentDds = " + currentDds + " operatorNumeric = " + operatorNumeric);
        if (!TextUtils.isEmpty(operatorNumeric) && (getSubId() == currentDds)) {
            try {
                Uri uri = Uri.withAppendedPath(Telephony.Carriers.CONTENT_URI, "current");
                ContentValues map = new ContentValues();
                map.put(Telephony.Carriers.NUMERIC, operatorNumeric);
                mContext.getContentResolver().insert(uri, map);
                return true;
            } catch (SQLException e) {
                Rlog.e(LOG_TAG, "Can't store current operator", e);
            }
        }
        return false;
    } else {
        return true;
    }
}
#method_after
@Override
public boolean updateCurrentCarrierInProvider() {
    long currentDds = SubscriptionManager.getDefaultDataSubscriptionId();
    String operatorNumeric = getOperatorNumeric();
    logd("updateCurrentCarrierInProvider: mSubId = " + getSubId() + " currentDds = " + currentDds + " operatorNumeric = " + operatorNumeric);
    if (!TextUtils.isEmpty(operatorNumeric) && (getSubId() == currentDds)) {
        try {
            Uri uri = Uri.withAppendedPath(Telephony.Carriers.CONTENT_URI, "current");
            ContentValues map = new ContentValues();
            map.put(Telephony.Carriers.NUMERIC, operatorNumeric);
            mContext.getContentResolver().insert(uri, map);
            return true;
        } catch (SQLException e) {
            Rlog.e(LOG_TAG, "Can't store current operator", e);
        }
    }
    return false;
}
#end_block

#method_before
@Override
public boolean needsOtaServiceProvisioning() {
    if (isPhoneTypeGsm()) {
        return false;
    } else {
        return mSST.getOtasp() != ServiceStateTracker.OTASP_NOT_NEEDED;
    }
}
#method_after
@Override
public boolean needsOtaServiceProvisioning() {
    if (isPhoneTypeGsm()) {
        return false;
    } else {
        return mSST.getOtasp() != TelephonyManager.OTASP_NOT_NEEDED;
    }
}
#end_block

#method_before
private void registerForIccRecordEvents() {
    IccRecords r = mIccRecords.get();
    if (r == null) {
        return;
    }
    if (isPhoneTypeGsm()) {
        r.registerForNetworkSelectionModeAutomatic(this, EVENT_SET_NETWORK_AUTOMATIC, null);
        r.registerForRecordsEvents(this, EVENT_ICC_RECORD_EVENTS, null);
        r.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
    } else {
        r.registerForRecordsLoaded(this, EVENT_RUIM_RECORDS_LOADED, null);
    }
}
#method_after
private void registerForIccRecordEvents() {
    IccRecords r = mIccRecords.get();
    if (r == null) {
        return;
    }
    if (isPhoneTypeGsm()) {
        r.registerForNetworkSelectionModeAutomatic(this, EVENT_SET_NETWORK_AUTOMATIC, null);
        r.registerForRecordsEvents(this, EVENT_ICC_RECORD_EVENTS, null);
        r.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
    } else {
        r.registerForRecordsLoaded(this, EVENT_RUIM_RECORDS_LOADED, null);
        if (isPhoneTypeCdmaLte()) {
            // notify simRecordsLoaded registrants for cdmaLte phone
            r.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
    }
}
#end_block

#method_before
@Override
public void exitEmergencyCallbackMode() {
    if (isPhoneTypeGsm()) {
        if (mImsPhone != null) {
            mImsPhone.exitEmergencyCallbackMode();
        }
    } else {
        if (mWakeLock.isHeld()) {
            mWakeLock.release();
        }
        // Send a message which will invoke handleExitEmergencyCallbackMode
        mCi.exitEmergencyCallbackMode(obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
    }
}
#method_after
@Override
public void exitEmergencyCallbackMode() {
    if (DBG) {
        Rlog.d(LOG_TAG, "exitEmergencyCallbackMode: mImsPhone=" + mImsPhone + " isPhoneTypeGsm=" + isPhoneTypeGsm());
    }
    if (isPhoneTypeGsm()) {
        if (mImsPhone != null) {
            mImsPhone.exitEmergencyCallbackMode();
        }
    } else {
        if (mWakeLock.isHeld()) {
            mWakeLock.release();
        }
        // Send a message which will invoke handleExitEmergencyCallbackMode
        mCi.exitEmergencyCallbackMode(obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
    }
}
#end_block

#method_before
private void handleEnterEmergencyCallbackMode(Message msg) {
    if (DBG) {
        Rlog.d(LOG_TAG, "handleEnterEmergencyCallbackMode,mIsPhoneInEcmState= " + mIsPhoneInEcmState);
    }
    // if phone is not in Ecm mode, and it's changed to Ecm mode
    if (mIsPhoneInEcmState == false) {
        mIsPhoneInEcmState = true;
        // notify change
        sendEmergencyCallbackModeChange();
        setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, "true");
        // Post this runnable so we will automatically exit
        // if no one invokes exitEmergencyCallbackMode() directly.
        long delayInMillis = SystemProperties.getLong(TelephonyProperties.PROPERTY_ECM_EXIT_TIMER, DEFAULT_ECM_EXIT_TIMER_VALUE);
        postDelayed(mExitEcmRunnable, delayInMillis);
        // We don't want to go to sleep while in Ecm
        mWakeLock.acquire();
    }
}
#method_after
private void handleEnterEmergencyCallbackMode(Message msg) {
    if (DBG) {
        Rlog.d(LOG_TAG, "handleEnterEmergencyCallbackMode, isInEcm()=" + isInEcm());
    }
    // if phone is not in Ecm mode, and it's changed to Ecm mode
    if (!isInEcm()) {
        setIsInEcm(true);
        // notify change
        sendEmergencyCallbackModeChange();
        // Post this runnable so we will automatically exit
        // if no one invokes exitEmergencyCallbackMode() directly.
        long delayInMillis = SystemProperties.getLong(TelephonyProperties.PROPERTY_ECM_EXIT_TIMER, DEFAULT_ECM_EXIT_TIMER_VALUE);
        postDelayed(mExitEcmRunnable, delayInMillis);
        // We don't want to go to sleep while in Ecm
        mWakeLock.acquire();
    }
}
#end_block

#method_before
private void handleExitEmergencyCallbackMode(Message msg) {
    AsyncResult ar = (AsyncResult) msg.obj;
    if (DBG) {
        Rlog.d(LOG_TAG, "handleExitEmergencyCallbackMode,ar.exception , mIsPhoneInEcmState " + ar.exception + mIsPhoneInEcmState);
    }
    // Remove pending exit Ecm runnable, if any
    removeCallbacks(mExitEcmRunnable);
    if (mEcmExitRespRegistrant != null) {
        mEcmExitRespRegistrant.notifyRegistrant(ar);
    }
    // if exiting ecm success
    if (ar.exception == null) {
        // release wakeLock
        if (mWakeLock.isHeld()) {
            mWakeLock.release();
        }
        if (mIsPhoneInEcmState) {
            mIsPhoneInEcmState = false;
            setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE, "false");
        }
        // send an Intent
        sendEmergencyCallbackModeChange();
        // Re-initiate data connection
        mDcTracker.setInternalDataEnabled(true);
        notifyEmergencyCallRegistrants(false);
    }
}
#method_after
private void handleExitEmergencyCallbackMode(Message msg) {
    AsyncResult ar = (AsyncResult) msg.obj;
    if (DBG) {
        Rlog.d(LOG_TAG, "handleExitEmergencyCallbackMode,ar.exception , isInEcm=" + ar.exception + isInEcm());
    }
    // Remove pending exit Ecm runnable, if any
    removeCallbacks(mExitEcmRunnable);
    if (mEcmExitRespRegistrant != null) {
        mEcmExitRespRegistrant.notifyRegistrant(ar);
    }
    // if exiting ecm success
    if (ar.exception == null) {
        if (isInEcm()) {
            setIsInEcm(false);
        }
        // release wakeLock
        if (mWakeLock.isHeld()) {
            mWakeLock.release();
        }
        // send an Intent
        sendEmergencyCallbackModeChange();
        // Re-initiate data connection
        mDcTracker.setInternalDataEnabled(true);
        notifyEmergencyCallRegistrants(false);
    }
}
#end_block

#method_before
private void phoneObjectUpdater(int newVoiceRadioTech) {
    logd("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech);
    // Check for a voice over lte replacement
    if ((newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) || (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
        CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configMgr.getConfigForSubId(getSubId());
        if (b != null) {
            int volteReplacementRat = b.getInt(CarrierConfigManager.KEY_VOLTE_REPLACEMENT_RAT_INT);
            logd("phoneObjectUpdater: volteReplacementRat=" + volteReplacementRat);
            if (volteReplacementRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
                newVoiceRadioTech = volteReplacementRat;
            }
        } else {
            loge("phoneObjectUpdater: didn't get volteReplacementRat from carrier config");
        }
    }
    if (mRilVersion == 6 && getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
        /*
             * On v6 RIL, when LTE_ON_CDMA is TRUE, always create CDMALTEPhone
             * irrespective of the voice radio tech reported.
             */
        if (getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
            logd("phoneObjectUpdater: LTE ON CDMA property is set. Use CDMA Phone" + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            return;
        } else {
            logd("phoneObjectUpdater: LTE ON CDMA property is set. Switch to CDMALTEPhone" + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            newVoiceRadioTech = ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT;
        }
    } else {
        // which might send unnecessary attach request to the modem.
        if (isShuttingDown()) {
            logd("Device is shutting down. No need to switch phone now.");
            return;
        }
        boolean matchCdma = ServiceState.isCdma(newVoiceRadioTech);
        boolean matchGsm = ServiceState.isGsm(newVoiceRadioTech);
        if ((matchCdma && getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) || (matchGsm && getPhoneType() == PhoneConstants.PHONE_TYPE_GSM)) {
            // Nothing changed. Keep phone as it is.
            logd("phoneObjectUpdater: No change ignore," + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            return;
        }
        if (!matchCdma && !matchGsm) {
            loge("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech + " doesn't match either CDMA or GSM - error! No phone change");
            return;
        }
    }
    if (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
        // We need some voice phone object to be active always, so never
        // delete the phone without anything to replace it with!
        logd("phoneObjectUpdater: Unknown rat ignore, " + " newVoiceRadioTech=Unknown. mActivePhone=" + getPhoneName());
        return;
    }
    // old power state to off
    boolean oldPowerState = false;
    if (mResetModemOnRadioTechnologyChange) {
        if (mCi.getRadioState().isOn()) {
            oldPowerState = true;
            logd("phoneObjectUpdater: Setting Radio Power to Off");
            mCi.setRadioPower(false, null);
        }
    }
    switchVoiceRadioTech(newVoiceRadioTech);
    if (mResetModemOnRadioTechnologyChange && oldPowerState) {
        // restore power state
        logd("phoneObjectUpdater: Resetting Radio");
        mCi.setRadioPower(oldPowerState, null);
    }
    // update voice radio tech in icc card proxy
    mIccCardProxy.setVoiceRadioTech(newVoiceRadioTech);
    // Send an Intent to the PhoneApp that we had a radio technology change
    Intent intent = new Intent(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED);
    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    intent.putExtra(PhoneConstants.PHONE_NAME_KEY, getPhoneName());
    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhoneId);
    ActivityManagerNative.broadcastStickyIntent(intent, null, UserHandle.USER_ALL);
}
#method_after
private void phoneObjectUpdater(int newVoiceRadioTech) {
    logd("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech);
    // Check for a voice over lte replacement
    if (ServiceState.isLte(newVoiceRadioTech) || (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
        CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configMgr.getConfigForSubId(getSubId());
        if (b != null) {
            int volteReplacementRat = b.getInt(CarrierConfigManager.KEY_VOLTE_REPLACEMENT_RAT_INT);
            logd("phoneObjectUpdater: volteReplacementRat=" + volteReplacementRat);
            if (volteReplacementRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
                newVoiceRadioTech = volteReplacementRat;
            }
        } else {
            loge("phoneObjectUpdater: didn't get volteReplacementRat from carrier config");
        }
    }
    if (mRilVersion == 6 && getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
        /*
             * On v6 RIL, when LTE_ON_CDMA is TRUE, always create CDMALTEPhone
             * irrespective of the voice radio tech reported.
             */
        if (getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
            logd("phoneObjectUpdater: LTE ON CDMA property is set. Use CDMA Phone" + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            return;
        } else {
            logd("phoneObjectUpdater: LTE ON CDMA property is set. Switch to CDMALTEPhone" + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            newVoiceRadioTech = ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT;
        }
    } else {
        // which might send unnecessary attach request to the modem.
        if (isShuttingDown()) {
            logd("Device is shutting down. No need to switch phone now.");
            return;
        }
        boolean matchCdma = ServiceState.isCdma(newVoiceRadioTech);
        boolean matchGsm = ServiceState.isGsm(newVoiceRadioTech);
        if ((matchCdma && getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) || (matchGsm && getPhoneType() == PhoneConstants.PHONE_TYPE_GSM)) {
            // Nothing changed. Keep phone as it is.
            logd("phoneObjectUpdater: No change ignore," + " newVoiceRadioTech=" + newVoiceRadioTech + " mActivePhone=" + getPhoneName());
            return;
        }
        if (!matchCdma && !matchGsm) {
            loge("phoneObjectUpdater: newVoiceRadioTech=" + newVoiceRadioTech + " doesn't match either CDMA or GSM - error! No phone change");
            return;
        }
    }
    if (newVoiceRadioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
        // We need some voice phone object to be active always, so never
        // delete the phone without anything to replace it with!
        logd("phoneObjectUpdater: Unknown rat ignore, " + " newVoiceRadioTech=Unknown. mActivePhone=" + getPhoneName());
        return;
    }
    // old power state to off
    boolean oldPowerState = false;
    if (mResetModemOnRadioTechnologyChange) {
        if (mCi.getRadioState().isOn()) {
            oldPowerState = true;
            logd("phoneObjectUpdater: Setting Radio Power to Off");
            mCi.setRadioPower(false, null);
        }
    }
    switchVoiceRadioTech(newVoiceRadioTech);
    if (mResetModemOnRadioTechnologyChange && oldPowerState) {
        // restore power state
        logd("phoneObjectUpdater: Resetting Radio");
        mCi.setRadioPower(oldPowerState, null);
    }
    // update voice radio tech in UiccProfile
    UiccProfile uiccProfile = getUiccProfile();
    if (uiccProfile != null) {
        uiccProfile.setVoiceRadioTech(newVoiceRadioTech);
    }
    // Send an Intent to the PhoneApp that we had a radio technology change
    Intent intent = new Intent(TelephonyIntents.ACTION_RADIO_TECHNOLOGY_CHANGED);
    intent.putExtra(PhoneConstants.PHONE_NAME_KEY, getPhoneName());
    SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhoneId);
    ActivityManager.broadcastStickyIntent(intent, UserHandle.USER_ALL);
}
#end_block

#method_before
private void switchVoiceRadioTech(int newVoiceRadioTech) {
    String outgoingPhoneName = getPhoneName();
    logd("Switching Voice Phone : " + outgoingPhoneName + " >>> " + (ServiceState.isGsm(newVoiceRadioTech) ? "GSM" : "CDMA"));
    if (ServiceState.isCdma(newVoiceRadioTech)) {
        switchPhoneType(PhoneConstants.PHONE_TYPE_CDMA_LTE);
    } else if (ServiceState.isGsm(newVoiceRadioTech)) {
        switchPhoneType(PhoneConstants.PHONE_TYPE_GSM);
    } else {
        loge("deleteAndCreatePhone: newVoiceRadioTech=" + newVoiceRadioTech + " is not CDMA or GSM (error) - aborting!");
        return;
    }
}
#method_after
private void switchVoiceRadioTech(int newVoiceRadioTech) {
    String outgoingPhoneName = getPhoneName();
    logd("Switching Voice Phone : " + outgoingPhoneName + " >>> " + (ServiceState.isGsm(newVoiceRadioTech) ? "GSM" : "CDMA"));
    if (ServiceState.isCdma(newVoiceRadioTech)) {
        UiccCardApplication cdmaApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP2);
        if (cdmaApplication != null && cdmaApplication.getType() == AppType.APPTYPE_RUIM) {
            switchPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
        } else {
            switchPhoneType(PhoneConstants.PHONE_TYPE_CDMA_LTE);
        }
    } else if (ServiceState.isGsm(newVoiceRadioTech)) {
        switchPhoneType(PhoneConstants.PHONE_TYPE_GSM);
    } else {
        loge("deleteAndCreatePhone: newVoiceRadioTech=" + newVoiceRadioTech + " is not CDMA or GSM (error) - aborting!");
        return;
    }
}
#end_block

#method_before
@Override
public boolean getIccRecordsLoaded() {
    return mIccCardProxy.getIccRecordsLoaded();
}
#method_after
@Override
public boolean getIccRecordsLoaded() {
    UiccProfile uiccProfile = getUiccProfile();
    return uiccProfile != null && uiccProfile.getIccRecordsLoaded();
}
#end_block

#method_before
@Override
public IccCard getIccCard() {
    return mIccCardProxy;
}
#method_after
@Override
public IccCard getIccCard() {
    return UiccController.getInstance().getUiccProfileForPhone(mPhoneId);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("GsmCdmaPhone extends:");
    super.dump(fd, pw, args);
    pw.println(" mPrecisePhoneType=" + mPrecisePhoneType);
    pw.println(" mCT=" + mCT);
    pw.println(" mSST=" + mSST);
    pw.println(" mPendingMMIs=" + mPendingMMIs);
    pw.println(" mIccPhoneBookIntManager=" + mIccPhoneBookIntManager);
    if (VDBG)
        pw.println(" mImei=" + mImei);
    if (VDBG)
        pw.println(" mImeiSv=" + mImeiSv);
    pw.println(" mVmNumber=" + mVmNumber);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mCdmaSubscriptionSource=" + mCdmaSubscriptionSource);
    pw.println(" mEriManager=" + mEriManager);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mIsPhoneInEcmState=" + mIsPhoneInEcmState);
    if (VDBG)
        pw.println(" mEsn=" + mEsn);
    if (VDBG)
        pw.println(" mMeid=" + mMeid);
    pw.println(" mCarrierOtaSpNumSchema=" + mCarrierOtaSpNumSchema);
    if (!isPhoneTypeGsm()) {
        pw.println(" getCdmaEriIconIndex()=" + getCdmaEriIconIndex());
        pw.println(" getCdmaEriIconMode()=" + getCdmaEriIconMode());
        pw.println(" getCdmaEriText()=" + getCdmaEriText());
        pw.println(" isMinInfoReady()=" + isMinInfoReady());
    }
    pw.println(" isCspPlmnEnabled()=" + isCspPlmnEnabled());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    try {
        mIccCardProxy.dump(fd, pw, args);
    } catch (Exception e) {
        e.printStackTrace();
    }
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("GsmCdmaPhone extends:");
    super.dump(fd, pw, args);
    pw.println(" mPrecisePhoneType=" + mPrecisePhoneType);
    pw.println(" mCT=" + mCT);
    pw.println(" mSST=" + mSST);
    pw.println(" mPendingMMIs=" + mPendingMMIs);
    pw.println(" mIccPhoneBookIntManager=" + mIccPhoneBookIntManager);
    if (VDBG)
        pw.println(" mImei=" + mImei);
    if (VDBG)
        pw.println(" mImeiSv=" + mImeiSv);
    if (VDBG)
        pw.println(" mVmNumber=" + mVmNumber);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mCdmaSubscriptionSource=" + mCdmaSubscriptionSource);
    pw.println(" mEriManager=" + mEriManager);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" isInEcm()=" + isInEcm());
    if (VDBG)
        pw.println(" mEsn=" + mEsn);
    if (VDBG)
        pw.println(" mMeid=" + mMeid);
    pw.println(" mCarrierOtaSpNumSchema=" + mCarrierOtaSpNumSchema);
    if (!isPhoneTypeGsm()) {
        pw.println(" getCdmaEriIconIndex()=" + getCdmaEriIconIndex());
        pw.println(" getCdmaEriIconMode()=" + getCdmaEriIconMode());
        pw.println(" getCdmaEriText()=" + getCdmaEriText());
        pw.println(" isMinInfoReady()=" + isMinInfoReady());
    }
    pw.println(" isCspPlmnEnabled()=" + isCspPlmnEnabled());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    pw.println("DeviceStateMonitor:");
    mDeviceStateMonitor.dump(fd, pw, args);
    pw.println("++++++++++++++++++++++++++++++++");
}
#end_block

#method_before
private String getOperatorNumeric() {
    String operatorNumeric = null;
    if (isPhoneTypeGsm()) {
        IccRecords r = mIccRecords.get();
        if (r != null) {
            operatorNumeric = r.getOperatorNumeric();
        }
    } else {
        // isPhoneTypeCdmaLte()
        IccRecords curIccRecords = null;
        if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_NV) {
            operatorNumeric = SystemProperties.get("ro.cdma.home.operator.numeric");
        } else if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_RUIM_SIM) {
            curIccRecords = mSimRecords;
            if (curIccRecords != null) {
                operatorNumeric = curIccRecords.getOperatorNumeric();
            } else {
                curIccRecords = mIccRecords.get();
                if (curIccRecords != null && (curIccRecords instanceof RuimRecords)) {
                    RuimRecords csim = (RuimRecords) curIccRecords;
                    operatorNumeric = csim.getRUIMOperatorNumeric();
                }
            }
        }
        if (operatorNumeric == null) {
            loge("getOperatorNumeric: Cannot retrieve operatorNumeric:" + " mCdmaSubscriptionSource = " + mCdmaSubscriptionSource + " mIccRecords = " + ((curIccRecords != null) ? curIccRecords.getRecordsLoaded() : null));
        }
        logd("getOperatorNumeric: mCdmaSubscriptionSource = " + mCdmaSubscriptionSource + " operatorNumeric = " + operatorNumeric);
    }
    return operatorNumeric;
}
#method_after
private String getOperatorNumeric() {
    String operatorNumeric = null;
    if (isPhoneTypeGsm()) {
        IccRecords r = mIccRecords.get();
        if (r != null) {
            operatorNumeric = r.getOperatorNumeric();
        }
    } else {
        // isPhoneTypeCdmaLte()
        IccRecords curIccRecords = null;
        if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_NV) {
            operatorNumeric = SystemProperties.get("ro.cdma.home.operator.numeric");
        } else if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_RUIM_SIM) {
            UiccCardApplication uiccCardApplication = mUiccApplication.get();
            if (uiccCardApplication != null && uiccCardApplication.getType() == AppType.APPTYPE_RUIM) {
                logd("Legacy RUIM app present");
                curIccRecords = mIccRecords.get();
            } else {
                // Use sim-records for SimApp, USimApp, CSimApp and ISimApp.
                curIccRecords = mSimRecords;
            }
            if (curIccRecords != null && curIccRecords == mSimRecords) {
                operatorNumeric = curIccRecords.getOperatorNumeric();
            } else {
                curIccRecords = mIccRecords.get();
                if (curIccRecords != null && (curIccRecords instanceof RuimRecords)) {
                    RuimRecords csim = (RuimRecords) curIccRecords;
                    operatorNumeric = csim.getRUIMOperatorNumeric();
                }
            }
        }
        if (operatorNumeric == null) {
            loge("getOperatorNumeric: Cannot retrieve operatorNumeric:" + " mCdmaSubscriptionSource = " + mCdmaSubscriptionSource + " mIccRecords = " + ((curIccRecords != null) ? curIccRecords.getRecordsLoaded() : null));
        }
        logd("getOperatorNumeric: mCdmaSubscriptionSource = " + mCdmaSubscriptionSource + " operatorNumeric = " + operatorNumeric);
    }
    return operatorNumeric;
}
#end_block

#method_before
@SystemApi
public void updateConfigForPhoneId(int phoneId, String simState) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error updating config for phoneId=" + phoneId + " ICarrierConfigLoader is null");
            return;
        }
        loader.updateConfigForPhoneId(phoneId, simState);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error updating config for phoneId=" + phoneId + ": " + ex.toString());
    }
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void updateConfigForPhoneId(int phoneId, String simState) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error updating config for phoneId=" + phoneId + " ICarrierConfigLoader is null");
            return;
        }
        loader.updateConfigForPhoneId(phoneId, simState);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error updating config for phoneId=" + phoneId + ": " + ex.toString());
    }
}
#end_block

#method_before
@NonNull
@SystemApi
public static PersistableBundle getDefaultConfig() {
    return new PersistableBundle(sDefaults);
}
#method_after
@NonNull
@SystemApi
@SuppressLint("Doclava125")
public static PersistableBundle getDefaultConfig() {
    return new PersistableBundle(sDefaults);
}
#end_block

#method_before
private void responseIccCardStatus(RadioResponseInfo responseInfo, CardStatus cardStatus) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        IccCardStatus iccCardStatus = new IccCardStatus();
        iccCardStatus.setCardState(cardStatus.cardState);
        iccCardStatus.setUniversalPinState(cardStatus.universalPinState);
        iccCardStatus.mGsmUmtsSubscriptionAppIndex = cardStatus.gsmUmtsSubscriptionAppIndex;
        iccCardStatus.mCdmaSubscriptionAppIndex = cardStatus.cdmaSubscriptionAppIndex;
        iccCardStatus.mImsSubscriptionAppIndex = cardStatus.imsSubscriptionAppIndex;
        int numApplications = cardStatus.applications.size();
        // limit to maximum allowed applications
        if (numApplications > com.android.internal.telephony.uicc.IccCardStatus.CARD_MAX_APPS) {
            numApplications = com.android.internal.telephony.uicc.IccCardStatus.CARD_MAX_APPS;
        }
        iccCardStatus.mApplications = new IccCardApplicationStatus[numApplications];
        for (int i = 0; i < numApplications; i++) {
            AppStatus rilAppStatus = cardStatus.applications.get(i);
            IccCardApplicationStatus appStatus = new IccCardApplicationStatus();
            appStatus.app_type = appStatus.AppTypeFromRILInt(rilAppStatus.appType);
            appStatus.app_state = appStatus.AppStateFromRILInt(rilAppStatus.appState);
            appStatus.perso_substate = appStatus.PersoSubstateFromRILInt(rilAppStatus.persoSubstate);
            appStatus.aid = rilAppStatus.aidPtr;
            appStatus.app_label = rilAppStatus.appLabelPtr;
            appStatus.pin1_replaced = rilAppStatus.pin1Replaced;
            appStatus.pin1 = appStatus.PinStateFromRILInt(rilAppStatus.pin1);
            appStatus.pin2 = appStatus.PinStateFromRILInt(rilAppStatus.pin2);
            iccCardStatus.mApplications[i] = appStatus;
        }
        mRil.riljLog("responseIccCardStatus: from HIDL: " + iccCardStatus);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, iccCardStatus);
        }
        mRil.processResponseDone(rr, responseInfo, iccCardStatus);
    }
}
#method_after
private void responseIccCardStatus(RadioResponseInfo responseInfo, CardStatus cardStatus) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        IccCardStatus iccCardStatus = convertHalCardStatus(cardStatus);
        mRil.riljLog("responseIccCardStatus: from HIDL: " + iccCardStatus);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, iccCardStatus);
        }
        mRil.processResponseDone(rr, responseInfo, iccCardStatus);
    }
}
#end_block

#method_before
int disconnectCauseFromCode(int causeCode) {
    switch(causeCode) {
        case CallFailCause.USER_BUSY:
            return DisconnectCause.BUSY;
        case CallFailCause.NO_CIRCUIT_AVAIL:
        case CallFailCause.TEMPORARY_FAILURE:
        case CallFailCause.SWITCHING_CONGESTION:
        case CallFailCause.CHANNEL_NOT_AVAIL:
        case CallFailCause.QOS_NOT_AVAIL:
        case CallFailCause.BEARER_NOT_AVAIL:
            return DisconnectCause.CONGESTION;
        case CallFailCause.EMERGENCY_TEMP_FAILURE:
            return DisconnectCause.EMERGENCY_TEMP_FAILURE;
        case CallFailCause.EMERGENCY_PERM_FAILURE:
            return DisconnectCause.EMERGENCY_PERM_FAILURE;
        case CallFailCause.ACM_LIMIT_EXCEEDED:
            return DisconnectCause.LIMIT_EXCEEDED;
        case CallFailCause.OPERATOR_DETERMINED_BARRING:
        case CallFailCause.CALL_BARRED:
            return DisconnectCause.CALL_BARRED;
        case CallFailCause.FDN_BLOCKED:
            return DisconnectCause.FDN_BLOCKED;
        case CallFailCause.IMEI_NOT_ACCEPTED:
            return DisconnectCause.IMEI_NOT_ACCEPTED;
        case CallFailCause.UNOBTAINABLE_NUMBER:
            return DisconnectCause.UNOBTAINABLE_NUMBER;
        case CallFailCause.DIAL_MODIFIED_TO_USSD:
            return DisconnectCause.DIAL_MODIFIED_TO_USSD;
        case CallFailCause.DIAL_MODIFIED_TO_SS:
            return DisconnectCause.DIAL_MODIFIED_TO_SS;
        case CallFailCause.DIAL_MODIFIED_TO_DIAL:
            return DisconnectCause.DIAL_MODIFIED_TO_DIAL;
        case CallFailCause.CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return DisconnectCause.CDMA_LOCKED_UNTIL_POWER_CYCLE;
        case CallFailCause.CDMA_DROP:
            return DisconnectCause.CDMA_DROP;
        case CallFailCause.CDMA_INTERCEPT:
            return DisconnectCause.CDMA_INTERCEPT;
        case CallFailCause.CDMA_REORDER:
            return DisconnectCause.CDMA_REORDER;
        case CallFailCause.CDMA_SO_REJECT:
            return DisconnectCause.CDMA_SO_REJECT;
        case CallFailCause.CDMA_RETRY_ORDER:
            return DisconnectCause.CDMA_RETRY_ORDER;
        case CallFailCause.CDMA_ACCESS_FAILURE:
            return DisconnectCause.CDMA_ACCESS_FAILURE;
        case CallFailCause.CDMA_PREEMPTED:
            return DisconnectCause.CDMA_PREEMPTED;
        case CallFailCause.CDMA_NOT_EMERGENCY:
            return DisconnectCause.CDMA_NOT_EMERGENCY;
        case CallFailCause.CDMA_ACCESS_BLOCKED:
            return DisconnectCause.CDMA_ACCESS_BLOCKED;
        case CallFailCause.NORMAL_UNSPECIFIED:
            return DisconnectCause.NORMAL_UNSPECIFIED;
        case CallFailCause.ERROR_UNSPECIFIED:
        case CallFailCause.NORMAL_CLEARING:
        default:
            GsmCdmaPhone phone = mOwner.getPhone();
            int serviceState = phone.getServiceState().getState();
            UiccCardApplication cardApp = phone.getUiccCardApplication();
            AppState uiccAppState = (cardApp != null) ? cardApp.getState() : AppState.APPSTATE_UNKNOWN;
            if (serviceState == ServiceState.STATE_POWER_OFF) {
                return DisconnectCause.POWER_OFF;
            }
            if (!mIsEmergencyCall) {
                // an OUT_OF_SERVICE disconnect cause during normal call ending.
                if ((serviceState == ServiceState.STATE_OUT_OF_SERVICE || serviceState == ServiceState.STATE_EMERGENCY_ONLY)) {
                    return DisconnectCause.OUT_OF_SERVICE;
                }
                // locked the AppState will always not be equal to APPSTATE_READY.
                if (uiccAppState != AppState.APPSTATE_READY) {
                    if (isPhoneTypeGsm()) {
                        return DisconnectCause.ICC_ERROR;
                    } else {
                        // CDMA
                        if (phone.mCdmaSubscriptionSource == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM) {
                            return DisconnectCause.ICC_ERROR;
                        }
                    }
                }
            }
            if (isPhoneTypeGsm()) {
                if (causeCode == CallFailCause.ERROR_UNSPECIFIED) {
                    if (phone.mSST.mRestrictedState.isCsRestricted()) {
                        return DisconnectCause.CS_RESTRICTED;
                    } else if (phone.mSST.mRestrictedState.isCsEmergencyRestricted()) {
                        return DisconnectCause.CS_RESTRICTED_EMERGENCY;
                    } else if (phone.mSST.mRestrictedState.isCsNormalRestricted()) {
                        return DisconnectCause.CS_RESTRICTED_NORMAL;
                    }
                }
            }
            if (causeCode == CallFailCause.NORMAL_CLEARING) {
                return DisconnectCause.NORMAL;
            }
            // to app, not NORMAL call end.
            return DisconnectCause.ERROR_UNSPECIFIED;
    }
}
#method_after
int disconnectCauseFromCode(int causeCode) {
    switch(causeCode) {
        case CallFailCause.USER_BUSY:
            return DisconnectCause.BUSY;
        case CallFailCause.NO_CIRCUIT_AVAIL:
        case CallFailCause.TEMPORARY_FAILURE:
        case CallFailCause.SWITCHING_CONGESTION:
        case CallFailCause.CHANNEL_NOT_AVAIL:
        case CallFailCause.QOS_NOT_AVAIL:
        case CallFailCause.BEARER_NOT_AVAIL:
            return DisconnectCause.CONGESTION;
        case CallFailCause.EMERGENCY_TEMP_FAILURE:
            return DisconnectCause.EMERGENCY_TEMP_FAILURE;
        case CallFailCause.EMERGENCY_PERM_FAILURE:
            return DisconnectCause.EMERGENCY_PERM_FAILURE;
        case CallFailCause.ACM_LIMIT_EXCEEDED:
            return DisconnectCause.LIMIT_EXCEEDED;
        case CallFailCause.OPERATOR_DETERMINED_BARRING:
        case CallFailCause.CALL_BARRED:
            return DisconnectCause.CALL_BARRED;
        case CallFailCause.FDN_BLOCKED:
            return DisconnectCause.FDN_BLOCKED;
        case CallFailCause.IMEI_NOT_ACCEPTED:
            return DisconnectCause.IMEI_NOT_ACCEPTED;
        case CallFailCause.UNOBTAINABLE_NUMBER:
            return DisconnectCause.UNOBTAINABLE_NUMBER;
        case CallFailCause.DIAL_MODIFIED_TO_USSD:
            return DisconnectCause.DIAL_MODIFIED_TO_USSD;
        case CallFailCause.DIAL_MODIFIED_TO_SS:
            return DisconnectCause.DIAL_MODIFIED_TO_SS;
        case CallFailCause.DIAL_MODIFIED_TO_DIAL:
            return DisconnectCause.DIAL_MODIFIED_TO_DIAL;
        case CallFailCause.CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return DisconnectCause.CDMA_LOCKED_UNTIL_POWER_CYCLE;
        case CallFailCause.CDMA_DROP:
            return DisconnectCause.CDMA_DROP;
        case CallFailCause.CDMA_INTERCEPT:
            return DisconnectCause.CDMA_INTERCEPT;
        case CallFailCause.CDMA_REORDER:
            return DisconnectCause.CDMA_REORDER;
        case CallFailCause.CDMA_SO_REJECT:
            return DisconnectCause.CDMA_SO_REJECT;
        case CallFailCause.CDMA_RETRY_ORDER:
            return DisconnectCause.CDMA_RETRY_ORDER;
        case CallFailCause.CDMA_ACCESS_FAILURE:
            return DisconnectCause.CDMA_ACCESS_FAILURE;
        case CallFailCause.CDMA_PREEMPTED:
            return DisconnectCause.CDMA_PREEMPTED;
        case CallFailCause.CDMA_NOT_EMERGENCY:
            return DisconnectCause.CDMA_NOT_EMERGENCY;
        case CallFailCause.CDMA_ACCESS_BLOCKED:
            return DisconnectCause.CDMA_ACCESS_BLOCKED;
        case CallFailCause.NORMAL_UNSPECIFIED:
            return DisconnectCause.NORMAL_UNSPECIFIED;
        case CallFailCause.USER_ALERTING_NO_ANSWER:
            return DisconnectCause.TIMED_OUT;
        case CallFailCause.ERROR_UNSPECIFIED:
        case CallFailCause.NORMAL_CLEARING:
        default:
            GsmCdmaPhone phone = mOwner.getPhone();
            int serviceState = phone.getServiceState().getState();
            UiccCardApplication cardApp = phone.getUiccCardApplication();
            AppState uiccAppState = (cardApp != null) ? cardApp.getState() : AppState.APPSTATE_UNKNOWN;
            if (serviceState == ServiceState.STATE_POWER_OFF) {
                return DisconnectCause.POWER_OFF;
            }
            if (!mIsEmergencyCall) {
                // an OUT_OF_SERVICE disconnect cause during normal call ending.
                if ((serviceState == ServiceState.STATE_OUT_OF_SERVICE || serviceState == ServiceState.STATE_EMERGENCY_ONLY)) {
                    return DisconnectCause.OUT_OF_SERVICE;
                }
                // locked the AppState will always not be equal to APPSTATE_READY.
                if (uiccAppState != AppState.APPSTATE_READY) {
                    if (isPhoneTypeGsm()) {
                        return DisconnectCause.ICC_ERROR;
                    } else {
                        // CDMA
                        if (phone.mCdmaSubscriptionSource == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM) {
                            return DisconnectCause.ICC_ERROR;
                        }
                    }
                }
            }
            if (isPhoneTypeGsm()) {
                if (causeCode == CallFailCause.ERROR_UNSPECIFIED) {
                    if (phone.mSST.mRestrictedState.isCsRestricted()) {
                        return DisconnectCause.CS_RESTRICTED;
                    } else if (phone.mSST.mRestrictedState.isCsEmergencyRestricted()) {
                        return DisconnectCause.CS_RESTRICTED_EMERGENCY;
                    } else if (phone.mSST.mRestrictedState.isCsNormalRestricted()) {
                        return DisconnectCause.CS_RESTRICTED_NORMAL;
                    }
                }
            }
            if (causeCode == CallFailCause.NORMAL_CLEARING) {
                return DisconnectCause.NORMAL;
            }
            // to app, not NORMAL call end.
            return DisconnectCause.ERROR_UNSPECIFIED;
    }
}
#end_block

#method_before
public void update(CommandsInterface ci, IccSlotStatus iss) {
    log("slotStatus update");
    synchronized (mLock) {
        mCi = ci;
        if (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_INACTIVE) {
            if (mActive) {
                mActive = false;
                mPhoneId = null;
                // treat as radio state unavailable
                onRadioStateUnavailable();
            }
            parseAtr(iss.atr);
            mCardState = iss.cardState;
            mIccId = iss.iccid;
        } else if (!mActive && iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE) {
            mActive = true;
        // todo - ignoring these fields for now; relying on sim state changed to update
        // these
        // iss.atr;
        // iss.cardState;
        // iss.iccid;
        // iss.logicalSlotIndex;
        }
    }
}
#method_after
public void update(CommandsInterface ci, IccSlotStatus iss) {
    log("slotStatus update");
    synchronized (mLock) {
        mCi = ci;
        if (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_INACTIVE) {
            if (mActive) {
                mActive = false;
                // treat as radio state unavailable
                onRadioStateUnavailable();
                // set mPhoneId to null only after sim state changed broadcast is sent as it
                // needs the phoneId. The broadcast is sent from onRadioStateUnavailable()
                mPhoneId = null;
            }
            parseAtr(iss.atr);
            mCardState = iss.cardState;
            mIccId = iss.iccid;
        } else if (!mActive && iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE) {
            mActive = true;
        // todo - ignoring these fields for now; relying on sim state changed to update
        // these
        // iss.atr;
        // iss.cardState;
        // iss.iccid;
        // iss.logicalSlotIndex;
        }
    }
}
#end_block

#method_before
public void onRadioStateUnavailable() {
    if (mUiccCard != null) {
        mUiccCard.dispose();
    }
    mUiccCard = null;
    UiccProfile.broadcastInternalIccStateChangedIntent(IccCardConstants.INTENT_VALUE_ICC_UNKNOWN, null, mPhoneId);
    mCardState = CardState.CARDSTATE_ABSENT;
    mLastRadioState = RadioState.RADIO_UNAVAILABLE;
}
#method_after
public void onRadioStateUnavailable() {
    if (mUiccCard != null) {
        mUiccCard.dispose();
    }
    mUiccCard = null;
    if (mPhoneId != null) {
        UiccProfile.broadcastInternalIccStateChangedIntent(IccCardConstants.INTENT_VALUE_ICC_UNKNOWN, null, mPhoneId);
    }
    mCardState = CardState.CARDSTATE_ABSENT;
    mLastRadioState = RadioState.RADIO_UNAVAILABLE;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (mDisposed) {
        loge("handleMessage: Received " + msg.what + " after dispose(); ignoring the message");
        return;
    }
    switch(msg.what) {
        case EVENT_RADIO_OFF_OR_UNAVAILABLE:
            updateExternalState();
            break;
        case EVENT_ICC_LOCKED:
            processLockedState();
            break;
        case EVENT_APP_READY:
            if (VDBG)
                log("EVENT_APP_READY");
            if (areAllApplicationsReady()) {
                if (areAllRecordsLoaded() && areCarrierPriviligeRulesLoaded()) {
                    setExternalState(IccCardConstants.State.LOADED);
                } else {
                    setExternalState(IccCardConstants.State.READY);
                }
            }
            break;
        case EVENT_RECORDS_LOADED:
            if (VDBG)
                log("EVENT_RECORDS_LOADED");
            if (!areAllRecordsLoaded()) {
                break;
            }
            if (areCarrierPriviligeRulesLoaded()) {
                setExternalState(IccCardConstants.State.LOADED);
            }
            break;
        case EVENT_NETWORK_LOCKED:
            mNetworkLockedRegistrants.notifyRegistrants();
            setExternalState(IccCardConstants.State.NETWORK_LOCKED);
            break;
        case EVENT_ICC_RECORD_EVENTS:
            if ((mCurrentAppType == UiccController.APP_FAM_3GPP) && (mIccRecords != null)) {
                AsyncResult ar = (AsyncResult) msg.obj;
                int eventCode = (Integer) ar.result;
                if (eventCode == SIMRecords.EVENT_SPN) {
                    mTelephonyManager.setSimOperatorNameForPhone(mPhoneId, mIccRecords.getServiceProviderName());
                }
            }
            break;
        case EVENT_CARRIER_PRIVILEGES_LOADED:
            if (VDBG)
                log("EVENT_CARRIER_PRIVILEGES_LOADED");
            onCarrierPriviligesLoadedMessage();
            if (areAllRecordsLoaded()) {
                setExternalState(IccCardConstants.State.LOADED);
            }
            break;
        case EVENT_OPEN_LOGICAL_CHANNEL_DONE:
        case EVENT_CLOSE_LOGICAL_CHANNEL_DONE:
        case EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE:
        case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
        case EVENT_SIM_IO_DONE:
            AsyncResult ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                loglocal("Exception: " + ar.exception);
                log("Error in SIM access with exception" + ar.exception);
            }
            AsyncResult.forMessage((Message) ar.userObj, ar.result, ar.exception);
            ((Message) ar.userObj).sendToTarget();
            break;
        default:
            loge("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (mDisposed) {
        loge("handleMessage: Received " + msg.what + " after dispose(); ignoring the message");
        return;
    }
    switch(msg.what) {
        case EVENT_RADIO_OFF_OR_UNAVAILABLE:
            updateExternalState();
            break;
        case EVENT_ICC_LOCKED:
            processLockedState();
            break;
        case EVENT_APP_READY:
            if (VDBG)
                log("EVENT_APP_READY");
            if (areAllApplicationsReady()) {
                if (areAllRecordsLoaded() && areCarrierPriviligeRulesLoaded()) {
                    setExternalState(IccCardConstants.State.LOADED);
                } else {
                    setExternalState(IccCardConstants.State.READY);
                }
            }
            break;
        case EVENT_RECORDS_LOADED:
            if (VDBG)
                log("EVENT_RECORDS_LOADED");
            if (!areAllRecordsLoaded()) {
                break;
            }
            // Update the MCC/MNC.
            if (mIccRecords != null) {
                String operator = mIccRecords.getOperatorNumeric();
                log("operator=" + operator + " mPhoneId=" + mPhoneId);
                if (!TextUtils.isEmpty(operator)) {
                    mTelephonyManager.setSimOperatorNumericForPhone(mPhoneId, operator);
                    String countryCode = operator.substring(0, 3);
                    if (countryCode != null) {
                        mTelephonyManager.setSimCountryIsoForPhone(mPhoneId, MccTable.countryCodeForMcc(Integer.parseInt(countryCode)));
                    } else {
                        loge("EVENT_RECORDS_LOADED Country code is null");
                    }
                } else {
                    loge("EVENT_RECORDS_LOADED Operator name is null");
                }
            }
            if (areCarrierPriviligeRulesLoaded()) {
                setExternalState(IccCardConstants.State.LOADED);
            }
            break;
        case EVENT_NETWORK_LOCKED:
            mNetworkLockedRegistrants.notifyRegistrants();
            setExternalState(IccCardConstants.State.NETWORK_LOCKED);
            break;
        case EVENT_ICC_RECORD_EVENTS:
            if ((mCurrentAppType == UiccController.APP_FAM_3GPP) && (mIccRecords != null)) {
                AsyncResult ar = (AsyncResult) msg.obj;
                int eventCode = (Integer) ar.result;
                if (eventCode == SIMRecords.EVENT_SPN) {
                    mTelephonyManager.setSimOperatorNameForPhone(mPhoneId, mIccRecords.getServiceProviderName());
                }
            }
            break;
        case EVENT_CARRIER_PRIVILEGES_LOADED:
            if (VDBG)
                log("EVENT_CARRIER_PRIVILEGES_LOADED");
            onCarrierPriviligesLoadedMessage();
            if (areAllRecordsLoaded()) {
                setExternalState(IccCardConstants.State.LOADED);
            }
            break;
        case EVENT_OPEN_LOGICAL_CHANNEL_DONE:
        case EVENT_CLOSE_LOGICAL_CHANNEL_DONE:
        case EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE:
        case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
        case EVENT_SIM_IO_DONE:
            AsyncResult ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                loglocal("Exception: " + ar.exception);
                log("Error in SIM access with exception" + ar.exception);
            }
            AsyncResult.forMessage((Message) ar.userObj, ar.result, ar.exception);
            ((Message) ar.userObj).sendToTarget();
            break;
        default:
            loge("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
private void updateExternalState() {
    if (mUiccCard.getCardState() == IccCardStatus.CardState.CARDSTATE_ERROR) {
        setExternalState(IccCardConstants.State.CARD_IO_ERROR);
        return;
    }
    if (mUiccCard.getCardState() == IccCardStatus.CardState.CARDSTATE_RESTRICTED) {
        setExternalState(IccCardConstants.State.CARD_RESTRICTED);
        return;
    }
    if (mUiccApplication == null || !areAllApplicationsReady()) {
        setExternalState(IccCardConstants.State.NOT_READY);
        return;
    }
    // By process of elimination, the UICC Card State = PRESENT
    switch(mUiccApplication.getState()) {
        case APPSTATE_UNKNOWN:
            /*
                 * APPSTATE_UNKNOWN is a catch-all state reported whenever the app
                 * is not explicitly in one of the other states. To differentiate the
                 * case where we know that there is a card present, but the APP is not
                 * ready, we choose NOT_READY here instead of unknown. This is possible
                 * in at least two cases:
                 * 1) A transient during the process of the SIM bringup
                 * 2) There is no valid App on the SIM to load, which can be the case with an
                 *    eSIM/soft SIM.
                 */
            setExternalState(IccCardConstants.State.NOT_READY);
            break;
        case APPSTATE_SUBSCRIPTION_PERSO:
            if (mUiccApplication.getPersoSubState() == IccCardApplicationStatus.PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
                setExternalState(IccCardConstants.State.NETWORK_LOCKED);
            }
            // Otherwise don't change external SIM state.
            break;
        case APPSTATE_READY:
            if (areAllApplicationsReady()) {
                if (areAllRecordsLoaded() && areCarrierPriviligeRulesLoaded()) {
                    setExternalState(IccCardConstants.State.LOADED);
                } else {
                    setExternalState(IccCardConstants.State.READY);
                }
            }
            break;
    }
}
#method_after
private void updateExternalState() {
    if (mUiccCard.getCardState() == IccCardStatus.CardState.CARDSTATE_ERROR) {
        setExternalState(IccCardConstants.State.CARD_IO_ERROR);
        return;
    }
    if (mUiccCard.getCardState() == IccCardStatus.CardState.CARDSTATE_RESTRICTED) {
        setExternalState(IccCardConstants.State.CARD_RESTRICTED);
        return;
    }
    if (mUiccApplication == null || !areAllApplicationsReady()) {
        setExternalState(IccCardConstants.State.NOT_READY);
        return;
    }
    // By process of elimination, the UICC Card State = PRESENT
    switch(mUiccApplication.getState()) {
        case APPSTATE_UNKNOWN:
            /*
                 * APPSTATE_UNKNOWN is a catch-all state reported whenever the app
                 * is not explicitly in one of the other states. To differentiate the
                 * case where we know that there is a card present, but the APP is not
                 * ready, we choose NOT_READY here instead of unknown. This is possible
                 * in at least two cases:
                 * 1) A transient during the process of the SIM bringup
                 * 2) There is no valid App on the SIM to load, which can be the case with an
                 *    eSIM/soft SIM.
                 */
            setExternalState(IccCardConstants.State.NOT_READY);
            break;
        case APPSTATE_SUBSCRIPTION_PERSO:
            if (mUiccApplication.getPersoSubState() == IccCardApplicationStatus.PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
                setExternalState(IccCardConstants.State.NETWORK_LOCKED);
            }
            // Otherwise don't change external SIM state.
            break;
        case APPSTATE_READY:
            if (areAllApplicationsReady()) {
                if (areAllRecordsLoaded() && areCarrierPriviligeRulesLoaded()) {
                    setExternalState(IccCardConstants.State.LOADED);
                } else {
                    setExternalState(IccCardConstants.State.READY);
                }
            } else {
                setExternalState(IccCardConstants.State.NOT_READY);
            }
            break;
    }
}
#end_block

#method_before
private void setExternalState(IccCardConstants.State newState, boolean override) {
    synchronized (mLock) {
        if (!SubscriptionManager.isValidSlotIndex(mPhoneId)) {
            loge("setExternalState: mPhoneId=" + mPhoneId + " is invalid; Return!!");
            return;
        }
        if (!override && newState == mExternalState) {
            log("setExternalState: !override and newstate unchanged from " + newState);
            return;
        }
        mExternalState = newState;
        if (mExternalState == IccCardConstants.State.LOADED) {
            // Update the MCC/MNC.
            if (mIccRecords != null) {
                String operator = mIccRecords.getOperatorNumeric();
                log("operator=" + operator + " mPhoneId=" + mPhoneId);
                if (!TextUtils.isEmpty(operator)) {
                    mTelephonyManager.setSimOperatorNumericForPhone(mPhoneId, operator);
                    String countryCode = operator.substring(0, 3);
                    if (countryCode != null) {
                        mTelephonyManager.setSimCountryIsoForPhone(mPhoneId, MccTable.countryCodeForMcc(Integer.parseInt(countryCode)));
                    } else {
                        loge("EVENT_RECORDS_LOADED Country code is null");
                    }
                } else {
                    loge("EVENT_RECORDS_LOADED Operator name is null");
                }
            }
        }
        log("setExternalState: set mPhoneId=" + mPhoneId + " mExternalState=" + mExternalState);
        mTelephonyManager.setSimStateForPhone(mPhoneId, getState().toString());
        broadcastInternalIccStateChangedIntent(getIccStateIntentString(mExternalState), getIccStateReason(mExternalState), mPhoneId);
    }
}
#method_after
private void setExternalState(IccCardConstants.State newState, boolean override) {
    synchronized (mLock) {
        if (!SubscriptionManager.isValidSlotIndex(mPhoneId)) {
            loge("setExternalState: mPhoneId=" + mPhoneId + " is invalid; Return!!");
            return;
        }
        if (!override && newState == mExternalState) {
            log("setExternalState: !override and newstate unchanged from " + newState);
            return;
        }
        mExternalState = newState;
        log("setExternalState: set mPhoneId=" + mPhoneId + " mExternalState=" + mExternalState);
        mTelephonyManager.setSimStateForPhone(mPhoneId, getState().toString());
        broadcastInternalIccStateChangedIntent(getIccStateIntentString(mExternalState), getIccStateReason(mExternalState), mPhoneId);
    }
}
#end_block

#method_before
private void updateExternalState() {
    // First check if card state is IO_ERROR or RESTRICTED
    if (mUiccCard.getCardState() == IccCardStatus.CardState.CARDSTATE_ERROR) {
        setExternalState(IccCardConstants.State.CARD_IO_ERROR);
        return;
    }
    if (mUiccCard.getCardState() == IccCardStatus.CardState.CARDSTATE_RESTRICTED) {
        setExternalState(IccCardConstants.State.CARD_RESTRICTED);
        return;
    }
    // based on apps
    if (mUiccApplication == null) {
        loge("updateExternalState: setting state to NOT_READY because mUiccApplication is " + "null");
        setExternalState(IccCardConstants.State.NOT_READY);
        return;
    }
    // Check if SIM is locked
    boolean cardLocked = false;
    IccCardConstants.State lockedState = null;
    PinState pin1State = mUiccApplication.getPin1State();
    if (pin1State == PinState.PINSTATE_ENABLED_PERM_BLOCKED) {
        if (VDBG)
            log("updateExternalState: PERM_DISABLED");
        cardLocked = true;
        lockedState = IccCardConstants.State.PERM_DISABLED;
    }
    IccCardApplicationStatus.AppState appState = mUiccApplication.getState();
    if (appState == IccCardApplicationStatus.AppState.APPSTATE_PIN) {
        if (VDBG)
            log("updateExternalState: PIN_REQUIRED");
        cardLocked = true;
        lockedState = IccCardConstants.State.PIN_REQUIRED;
    } else if (appState == IccCardApplicationStatus.AppState.APPSTATE_PUK) {
        if (VDBG)
            log("updateExternalState: PUK_REQUIRED");
        cardLocked = true;
        lockedState = IccCardConstants.State.PUK_REQUIRED;
    } else if (appState == IccCardApplicationStatus.AppState.APPSTATE_SUBSCRIPTION_PERSO) {
        if (mUiccApplication.getPersoSubState() == IccCardApplicationStatus.PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
            if (VDBG)
                log("updateExternalState: PERSOSUBSTATE_SIM_NETWORK");
            cardLocked = true;
            lockedState = IccCardConstants.State.NETWORK_LOCKED;
        }
    }
    // If SIM is locked, broadcast state as NOT_READY/LOCKED depending on if records are loaded
    if (cardLocked) {
        if (mIccRecords != null && (mIccRecords.getLockedRecordsLoaded() || mIccRecords.getNetworkLockedRecordsLoaded())) {
            // locked records loaded
            if (VDBG) {
                log("updateExternalState: card locked and records loaded; " + "setting state to locked");
            }
            setExternalState(lockedState);
        } else {
            if (VDBG) {
                log("updateExternalState: card locked but records not loaded; " + "setting state to NOT_READY");
            }
            setExternalState(IccCardConstants.State.NOT_READY);
        }
        return;
    }
    // Check for remaining app states
    switch(appState) {
        case APPSTATE_UNKNOWN:
            /*
                 * APPSTATE_UNKNOWN is a catch-all state reported whenever the app
                 * is not explicitly in one of the other states. To differentiate the
                 * case where we know that there is a card present, but the APP is not
                 * ready, we choose NOT_READY here instead of unknown. This is possible
                 * in at least two cases:
                 * 1) A transient during the process of the SIM bringup
                 * 2) There is no valid App on the SIM to load, which can be the case with an
                 *    eSIM/soft SIM.
                 */
            if (VDBG) {
                log("updateExternalState: app state is unknown; setting state to NOT_READY");
            }
            setExternalState(IccCardConstants.State.NOT_READY);
            break;
        case APPSTATE_READY:
            if (areAllApplicationsReady()) {
                if (areAllRecordsLoaded() && areCarrierPriviligeRulesLoaded()) {
                    if (VDBG)
                        log("updateExternalState: setting state to LOADED");
                    setExternalState(IccCardConstants.State.LOADED);
                } else {
                    if (VDBG) {
                        log("updateExternalState: setting state to READY; records loaded " + areAllRecordsLoaded() + ", carrier privilige rules loaded " + areCarrierPriviligeRulesLoaded());
                    }
                    setExternalState(IccCardConstants.State.READY);
                }
            } else {
                if (VDBG) {
                    log("updateExternalState: app state is READY but not for all apps; " + "not changing the state");
                }
            }
            break;
    }
}
#method_after
private void updateExternalState() {
    // First check if card state is IO_ERROR or RESTRICTED
    if (mUiccCard.getCardState() == IccCardStatus.CardState.CARDSTATE_ERROR) {
        setExternalState(IccCardConstants.State.CARD_IO_ERROR);
        return;
    }
    if (mUiccCard.getCardState() == IccCardStatus.CardState.CARDSTATE_RESTRICTED) {
        setExternalState(IccCardConstants.State.CARD_RESTRICTED);
        return;
    }
    // based on apps
    if (mUiccApplication == null) {
        loge("updateExternalState: setting state to NOT_READY because mUiccApplication is " + "null");
        setExternalState(IccCardConstants.State.NOT_READY);
        return;
    }
    // Check if SIM is locked
    boolean cardLocked = false;
    IccCardConstants.State lockedState = null;
    IccCardApplicationStatus.AppState appState = mUiccApplication.getState();
    PinState pin1State = mUiccApplication.getPin1State();
    if (pin1State == PinState.PINSTATE_ENABLED_PERM_BLOCKED) {
        if (VDBG)
            log("updateExternalState: PERM_DISABLED");
        cardLocked = true;
        lockedState = IccCardConstants.State.PERM_DISABLED;
    } else {
        if (appState == IccCardApplicationStatus.AppState.APPSTATE_PIN) {
            if (VDBG)
                log("updateExternalState: PIN_REQUIRED");
            cardLocked = true;
            lockedState = IccCardConstants.State.PIN_REQUIRED;
        } else if (appState == IccCardApplicationStatus.AppState.APPSTATE_PUK) {
            if (VDBG)
                log("updateExternalState: PUK_REQUIRED");
            cardLocked = true;
            lockedState = IccCardConstants.State.PUK_REQUIRED;
        } else if (appState == IccCardApplicationStatus.AppState.APPSTATE_SUBSCRIPTION_PERSO) {
            if (mUiccApplication.getPersoSubState() == IccCardApplicationStatus.PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
                if (VDBG)
                    log("updateExternalState: PERSOSUBSTATE_SIM_NETWORK");
                cardLocked = true;
                lockedState = IccCardConstants.State.NETWORK_LOCKED;
            }
        }
    }
    // If SIM is locked, broadcast state as NOT_READY/LOCKED depending on if records are loaded
    if (cardLocked) {
        if (mIccRecords != null && (mIccRecords.getLockedRecordsLoaded() || mIccRecords.getNetworkLockedRecordsLoaded())) {
            // locked records loaded
            if (VDBG) {
                log("updateExternalState: card locked and records loaded; " + "setting state to locked");
            }
            setExternalState(lockedState);
        } else {
            if (VDBG) {
                log("updateExternalState: card locked but records not loaded; " + "setting state to NOT_READY");
            }
            setExternalState(IccCardConstants.State.NOT_READY);
        }
        return;
    }
    // Check for remaining app states
    switch(appState) {
        case APPSTATE_UNKNOWN:
            /*
                 * APPSTATE_UNKNOWN is a catch-all state reported whenever the app
                 * is not explicitly in one of the other states. To differentiate the
                 * case where we know that there is a card present, but the APP is not
                 * ready, we choose NOT_READY here instead of unknown. This is possible
                 * in at least two cases:
                 * 1) A transient during the process of the SIM bringup
                 * 2) There is no valid App on the SIM to load, which can be the case with an
                 *    eSIM/soft SIM.
                 */
            if (VDBG) {
                log("updateExternalState: app state is unknown; setting state to NOT_READY");
            }
            setExternalState(IccCardConstants.State.NOT_READY);
            break;
        case APPSTATE_READY:
            if (areAllApplicationsReady()) {
                if (areAllRecordsLoaded() && areCarrierPriviligeRulesLoaded()) {
                    if (VDBG)
                        log("updateExternalState: setting state to LOADED");
                    setExternalState(IccCardConstants.State.LOADED);
                } else {
                    if (VDBG) {
                        log("updateExternalState: setting state to READY; records loaded " + areAllRecordsLoaded() + ", carrier privilige rules loaded " + areCarrierPriviligeRulesLoaded());
                    }
                    setExternalState(IccCardConstants.State.READY);
                }
            } else {
                if (VDBG) {
                    log("updateExternalState: app state is READY but not for all apps; " + "setting state to NOT_READY");
                }
                setExternalState(IccCardConstants.State.NOT_READY);
            }
            break;
    }
}
#end_block

#method_before
public static boolean readInstallPolicy() {
    // Temp structure to hold the rules while we parse the xml file
    List<Policy> policies = new ArrayList<>();
    FileReader policyFile = null;
    XmlPullParser parser = Xml.newPullParser();
    synchronized (sMacPermissions) {
        // Only initialize it once.
        if (sMacPermissions.isEmpty()) {
            // Platform mac permissions.
            sMacPermissions.add(new File(Environment.getRootDirectory(), "/etc/selinux/plat_mac_permissions.xml"));
            // Vendor mac permissions.
            // The filename has been renamed from nonplat_mac_permissions to
            // vendor_mac_permissions. Either of them should exist.
            File vendorMacPermission = new File(Environment.getVendorDirectory(), "/etc/selinux/vendor_mac_permissions.xml");
            if (vendorMacPermission.exists()) {
                sMacPermissions.add(vendorMacPermission);
            } else {
                // For backward compatibility.
                sMacPermissions.add(new File(Environment.getVendorDirectory(), "/etc/selinux/nonplat_mac_permissions.xml"));
            }
            // ODM mac permissions (optional).
            File odmMacPermission = new File(Environment.getOdmDirectory(), "/etc/selinux/odm_mac_permissions.xml");
            if (odmMacPermission.exists()) {
                sMacPermissions.add(odmMacPermission);
            }
        }
    }
    final int count = sMacPermissions.size();
    for (int i = 0; i < count; ++i) {
        File macPermission = sMacPermissions.get(i);
        try {
            policyFile = new FileReader(macPermission);
            Slog.d(TAG, "Using policy file " + macPermission);
            parser.setInput(policyFile);
            parser.nextTag();
            parser.require(XmlPullParser.START_TAG, null, "policy");
            while (parser.next() != XmlPullParser.END_TAG) {
                if (parser.getEventType() != XmlPullParser.START_TAG) {
                    continue;
                }
                switch(parser.getName()) {
                    case "signer":
                        policies.add(readSignerOrThrow(parser));
                        break;
                    default:
                        skip(parser);
                }
            }
        } catch (IllegalStateException | IllegalArgumentException | XmlPullParserException ex) {
            StringBuilder sb = new StringBuilder("Exception @");
            sb.append(parser.getPositionDescription());
            sb.append(" while parsing ");
            sb.append(macPermission);
            sb.append(":");
            sb.append(ex);
            Slog.w(TAG, sb.toString());
            return false;
        } catch (IOException ioe) {
            Slog.w(TAG, "Exception parsing " + macPermission, ioe);
            return false;
        } finally {
            IoUtils.closeQuietly(policyFile);
        }
    }
    // Now sort the policy stanzas
    PolicyComparator policySort = new PolicyComparator();
    Collections.sort(policies, policySort);
    if (policySort.foundDuplicate()) {
        Slog.w(TAG, "ERROR! Duplicate entries found parsing mac_permissions.xml files");
        return false;
    }
    synchronized (sPolicies) {
        sPolicies = policies;
        if (DEBUG_POLICY_ORDER) {
            for (Policy policy : sPolicies) {
                Slog.d(TAG, "Policy: " + policy.toString());
            }
        }
    }
    return true;
}
#method_after
public static boolean readInstallPolicy() {
    // Temp structure to hold the rules while we parse the xml file
    List<Policy> policies = new ArrayList<>();
    FileReader policyFile = null;
    XmlPullParser parser = Xml.newPullParser();
    final int count = sMacPermissions.size();
    for (int i = 0; i < count; ++i) {
        final File macPermission = sMacPermissions.get(i);
        try {
            policyFile = new FileReader(macPermission);
            Slog.d(TAG, "Using policy file " + macPermission);
            parser.setInput(policyFile);
            parser.nextTag();
            parser.require(XmlPullParser.START_TAG, null, "policy");
            while (parser.next() != XmlPullParser.END_TAG) {
                if (parser.getEventType() != XmlPullParser.START_TAG) {
                    continue;
                }
                switch(parser.getName()) {
                    case "signer":
                        policies.add(readSignerOrThrow(parser));
                        break;
                    default:
                        skip(parser);
                }
            }
        } catch (IllegalStateException | IllegalArgumentException | XmlPullParserException ex) {
            StringBuilder sb = new StringBuilder("Exception @");
            sb.append(parser.getPositionDescription());
            sb.append(" while parsing ");
            sb.append(macPermission);
            sb.append(":");
            sb.append(ex);
            Slog.w(TAG, sb.toString());
            return false;
        } catch (IOException ioe) {
            Slog.w(TAG, "Exception parsing " + macPermission, ioe);
            return false;
        } finally {
            IoUtils.closeQuietly(policyFile);
        }
    }
    // Now sort the policy stanzas
    PolicyComparator policySort = new PolicyComparator();
    Collections.sort(policies, policySort);
    if (policySort.foundDuplicate()) {
        Slog.w(TAG, "ERROR! Duplicate entries found parsing mac_permissions.xml files");
        return false;
    }
    synchronized (sPolicies) {
        sPolicies = policies;
        if (DEBUG_POLICY_ORDER) {
            for (Policy policy : sPolicies) {
                Slog.d(TAG, "Policy: " + policy.toString());
            }
        }
    }
    return true;
}
#end_block

#method_before
private IpSecTransform createTransportModeTransform(InetAddress addr, SecurityParameterIndex inSpi, SecurityParameterIndex outSpi, byte[] cryptKey, byte[] authKey) {
    Builder builder = new Builder(mContext);
    builder = builder.setSpi(IpSecTransform.DIRECTION_OUT, outSpi);
    builder = builder.setEncryption(IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, cryptKey));
    builder = builder.setAuthentication(IpSecTransform.DIRECTION_OUT, new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256, authKey, authKey.length * 8));
    builder = builder.setSpi(IpSecTransform.DIRECTION_IN, inSpi);
    builder = builder.setEncryption(IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, cryptKey));
    builder = builder.setAuthentication(IpSecTransform.DIRECTION_IN, new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256, authKey, authKey.length * 8));
    try {
        return builder.buildTransportModeTransform(addr);
    } catch (SpiUnavailableException | IOException | ResourceUnavailableException e) {
        Log.e("IpSec: Cannot create Transport mode transform");
    }
    return null;
}
#method_after
private IpSecTransform createTransportModeTransform(String encAlgo, byte[] cryptKey, String authAlgo, byte[] authKey, Integer truncBits, SecurityParameterIndex spi, InetAddress addr) {
    Builder builder = new Builder(mContext);
    builder = builder.setEncryption(new IpSecAlgorithm(encAlgo, cryptKey));
    builder = builder.setAuthentication(new IpSecAlgorithm(authAlgo, authKey, truncBits.intValue()));
    try {
        return builder.buildTransportModeTransform(addr, spi);
    } catch (SpiUnavailableException | IOException | ResourceUnavailableException e) {
        Log.e("IpSec: Cannot create Transport mode transform" + e.toString());
    }
    return null;
}
#end_block

#method_before
private String getSpiId(SpiContainer spiContainerObj) {
    if (spiContainerObj == null || spiContainerObj.spi == null)
        return "";
    return "SPI:" + spiContainerObj.hashCode();
}
#method_after
private String getSpiId(SecurityParameterIndex spi) {
    return "SPI:" + spi.hashCode();
}
#end_block

#method_before
private String getTransformId(TransformContainer transformContainerObj) {
    if (transformContainerObj == null || transformContainerObj.transform == null)
        return "";
    return "TRANSFORM:" + transformContainerObj.hashCode();
}
#method_after
private String getTransformId(IpSecTransform transform) {
    return "TRANSFORM:" + transform.hashCode();
}
#end_block

#method_before
@Rpc(description = "Apply Tranform to socket")
public Boolean ipSecApplyTransformToSocket(Integer socketFd, String id) {
    FileDescriptor fd = new FileDescriptor();
    fd.setInt$(socketFd.intValue());
    IpSecTransform transform = mTransformContainerMap.get(id).transform;
    if (transform == null)
        return false;
    try {
        mIpSecManager.applyTransportModeTransform(fd, transform);
    } catch (IOException e) {
        Log.e("IpSec: Cannot apply transform to socket " + e.toString());
        return false;
    }
    return true;
}
#method_after
@Rpc(description = "Apply Tranform to socket", returns = "True if transform is applied")
public Boolean ipSecApplyTransformToSocket(Integer socketFd, Integer direction, String id) {
    FileDescriptor fd = new FileDescriptor();
    fd.setInt$(socketFd.intValue());
    IpSecTransform transform = mTransformHashMap.get(id);
    if (transform == null) {
        Log.e("IpSec: Transform does not exist for the requested id");
        return false;
    }
    try {
        mIpSecManager.applyTransportModeTransform(fd, direction.intValue(), transform);
    } catch (IOException e) {
        Log.e("IpSec: Cannot apply transform to socket " + e.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
@Rpc(description = "Remove Tranform to socket")
public Boolean ipSecRemoveTransformToSocket(Integer socketFd, String id) {
    FileDescriptor fd = new FileDescriptor();
    fd.setInt$(socketFd.intValue());
    IpSecTransform transform = mTransformContainerMap.get(id).transform;
    if (transform == null)
        return false;
    try {
        mIpSecManager.removeTransportModeTransform(fd, transform);
    } catch (IOException e) {
        Log.e("IpSec: Cannot remove transform to socket " + e.toString());
        return false;
    }
    return true;
}
#method_after
@Rpc(description = "Remove Tranform to socket", returns = "True if transform is removed")
public Boolean ipSecRemoveTransformToSocket(Integer socketFd) {
    FileDescriptor fd = new FileDescriptor();
    fd.setInt$(socketFd.intValue());
    try {
        mIpSecManager.removeTransportModeTransforms(fd);
        return true;
    } catch (IOException e) {
        Log.e("IpSec: Failed to remove transform " + e.toString());
    }
    return false;
}
#end_block

#method_before
// TODO: Arguments to this function should be passed as IpSecConfig
@Rpc(description = "Create a transform mode transform")
public String ipSecCreateTransportModeTransform(String addr, String inSpiId, String outSpiId, String cryptKeyString, String authKeyString) {
    TransformContainer transformContainerObj = null;
    InetAddress inetAddr = NetworkUtils.numericToInetAddress(addr);
    SpiContainer inSpiContainerObj = mSpiContainerMap.get(inSpiId);
    SpiContainer outSpiContainerObj = mSpiContainerMap.get(outSpiId);
    if (inSpiContainerObj == null || outSpiContainerObj == null)
        return "";
    byte[] cryptKey = cryptKeyString.getBytes();
    byte[] authKey = authKeyString.getBytes();
    transformContainerObj = new TransformContainer(inetAddr, inSpiContainerObj.spi, outSpiContainerObj.spi, cryptKey, authKey);
    String id = getTransformId(transformContainerObj);
    if (id != null)
        mTransformContainerMap.put(id, transformContainerObj);
    return id;
}
#method_after
@Rpc(description = "Create a transform mode transform", returns = "Hash of transform object")
public String ipSecCreateTransportModeTransform(String encAlgo, String cryptKeyString, String authAlgo, String authKeyString, Integer truncBits, String spiId, String addr) {
    IpSecTransform transform = null;
    InetAddress inetAddr = NetworkUtils.numericToInetAddress(addr);
    SecurityParameterIndex spi = mSpiHashMap.get(spiId);
    if (spi == null) {
        Log.e("IpSec: SPI does not exist for the requested spiId");
        return null;
    }
    byte[] cryptKey = cryptKeyString.getBytes();
    byte[] authKey = authKeyString.getBytes();
    transform = createTransportModeTransform(encAlgo, cryptKey, authAlgo, authKey, truncBits, spi, inetAddr);
    if (transform == null)
        return null;
    String id = getTransformId(transform);
    mTransformHashMap.put(id, transform);
    return id;
}
#end_block

#method_before
@Rpc(description = "Destroy transport mode transform")
public void ipSecDestroyTransportModeTransform(String id) {
    TransformContainer transformContainerObj = mTransformContainerMap.get(id);
    if (transformContainerObj != null)
        transformContainerObj.transform.close();
    mTransformContainerMap.remove(id);
}
#method_after
@Rpc(description = "Destroy transport mode transform")
public void ipSecDestroyTransportModeTransform(String id) {
    IpSecTransform transform = mTransformHashMap.get(id);
    if (transform == null) {
        Log.e("IpSec: Transform does not exist for the requested id");
        return;
    }
    transform.close();
    mTransformHashMap.remove(id);
}
#end_block

#method_before
@Rpc(description = "Get Security Parameter Index")
public Integer ipSecGetSecurityParameterIndex(String id) {
    SpiContainer spiContainerObj = mSpiContainerMap.get(id);
    if (spiContainerObj == null)
        return 0;
    return spiContainerObj.spi.getSpi();
}
#method_after
@Rpc(description = "Get Security Parameter Index", returns = "Returns SPI value")
public Integer ipSecGetSecurityParameterIndex(String id) {
    SecurityParameterIndex spi = mSpiHashMap.get(id);
    if (spi == null) {
        Log.d("IpSec: SPI does not exist for the requested id");
        return 0;
    }
    return spi.getSpi();
}
#end_block

#method_before
@Rpc(description = "Release a Security Parameter Index")
public void ipSecReleaseSecurityParameterIndex(String id) {
    SpiContainer spiContainerObj = mSpiContainerMap.get(id);
    if (spiContainerObj != null)
        spiContainerObj.spi.close();
    mSpiContainerMap.remove(id);
}
#method_after
@Rpc(description = "Release a Security Parameter Index")
public void ipSecReleaseSecurityParameterIndex(String id) {
    SecurityParameterIndex spi = mSpiHashMap.get(id);
    if (spi == null) {
        Log.d("IpSec: SPI does not exist for the requested id");
        return;
    }
    spi.close();
    mSpiHashMap.remove(id);
}
#end_block

#method_before
@Rpc(description = "Open socket")
public Integer ipSecOpenSocket(Integer domain, Integer type, String addr, Integer port) {
    try {
        FileDescriptor fd = Os.socket(domain, type, 0);
        InetAddress localAddr = NetworkUtils.numericToInetAddress(addr);
        Os.bind(fd, localAddr, port.intValue());
        return fd.getInt$();
    } catch (SocketException | ErrnoException e) {
        Log.e("IpSec: Failed to open socket " + e.toString());
    }
    return -1;
}
#method_after
@Rpc(description = "Open socket", returns = "File descriptor of the socket")
public Integer ipSecOpenSocket(Integer domain, Integer type, String addr, Integer port) {
    try {
        FileDescriptor fd = Os.socket(domain, type, 0);
        InetAddress localAddr = NetworkUtils.numericToInetAddress(addr);
        Os.bind(fd, localAddr, port.intValue());
        return fd.getInt$();
    } catch (SocketException | ErrnoException e) {
        Log.e("IpSec: Failed to open socket " + e.toString());
    }
    return -1;
}
#end_block

#method_before
@Rpc(description = "Close socket")
public Integer ipSecCloseSocket(Integer socketFd) {
    FileDescriptor fd = new FileDescriptor();
    fd.setInt$(socketFd.intValue());
    try {
        Os.close(fd);
        return 0;
    } catch (ErrnoException e) {
        Log.e("IpSec: Failed to close socket " + e.toString());
    }
    return -1;
}
#method_after
@Rpc(description = "Close socket", returns = "True if socket is closed")
public Boolean ipSecCloseSocket(Integer socketFd) {
    FileDescriptor fd = new FileDescriptor();
    fd.setInt$(socketFd.intValue());
    try {
        Os.close(fd);
        return true;
    } catch (ErrnoException e) {
        Log.e("IpSec: Failed to close socket " + e.toString());
    }
    return false;
}
#end_block

#method_before
@Override
public void getDataCallList(int slotId, IDataServiceCallback callback) {
    if (callback == null) {
        loge("Callback is null");
        return;
    }
    mHandler.obtainMessage(DATA_SERVICE_REQUEST_GET_DATA_CALL_LIST, slotId, 0, callback).sendToTarget();
}
#method_after
@Override
public void getDataCallList(int slotId, IDataServiceCallback callback) {
    if (callback == null) {
        loge("getDataCallList: callback is null");
        return;
    }
    mHandler.obtainMessage(DATA_SERVICE_REQUEST_GET_DATA_CALL_LIST, slotId, 0, callback).sendToTarget();
}
#end_block

#method_before
@Override
public void registerForDataCallListChanged(int slotId, IDataServiceCallback callback) {
    if (callback == null) {
        loge("Callback is null");
        return;
    }
    mHandler.obtainMessage(DATA_SERVICE_REQUEST_REGISTER_DATA_CALL_LIST_CHANGED, slotId, 0, callback).sendToTarget();
}
#method_after
@Override
public void registerForDataCallListChanged(int slotId, IDataServiceCallback callback) {
    if (callback == null) {
        loge("registerForDataCallListChanged: callback is null");
        return;
    }
    mHandler.obtainMessage(DATA_SERVICE_REQUEST_REGISTER_DATA_CALL_LIST_CHANGED, slotId, 0, callback).sendToTarget();
}
#end_block

#method_before
@Override
public void unregisterForDataCallListChanged(int slotId, IDataServiceCallback callback) {
    if (callback == null) {
        loge("Callback is null");
        return;
    }
    mHandler.obtainMessage(DATA_SERVICE_REQUEST_UNREGISTER_DATA_CALL_LIST_CHANGED, slotId, 0, callback).sendToTarget();
}
#method_after
@Override
public void unregisterForDataCallListChanged(int slotId, IDataServiceCallback callback) {
    if (callback == null) {
        loge("unregisterForDataCallListChanged: callback is null");
        return;
    }
    mHandler.obtainMessage(DATA_SERVICE_REQUEST_UNREGISTER_DATA_CALL_LIST_CHANGED, slotId, 0, callback).sendToTarget();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj, msg.arg1);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_TIMEOUT_MSG:
            {
                mServices.serviceForegroundTimeout((ServiceRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_CRASH_MSG:
            {
                mServices.serviceForegroundCrash((ProcessRecord) msg.obj);
            }
            break;
        case DISPATCH_PENDING_INTENT_CANCEL_MSG:
            {
                RemoteCallbackList<IResultReceiver> callbacks = (RemoteCallbackList<IResultReceiver>) msg.obj;
                int N = callbacks.beginBroadcast();
                for (int i = 0; i < N; i++) {
                    try {
                        callbacks.getBroadcastItem(i).send(Activity.RESULT_CANCELED, null);
                    } catch (RemoteException e) {
                    }
                }
                callbacks.finishBroadcast();
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                ProxyInfo proxy = (ProxyInfo) msg.obj;
                String host = "";
                String port = "";
                String exclList = "";
                Uri pacFileUrl = Uri.EMPTY;
                if (proxy != null) {
                    host = proxy.getHost();
                    port = Integer.toString(proxy.getPort());
                    exclList = proxy.getExclusionListAsString();
                    pacFileUrl = proxy.getPacFileUrl();
                }
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.setHttpProxy(host, port, exclList, pacFileUrl);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    mActivityStarter.doPendingActivityLaunchesLocked(true);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    final int appId = msg.arg1;
                    final int userId = msg.arg2;
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appId, false, false, true, false, false, userId, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context, SystemNotificationChannels.DEVELOPER).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, notification, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_POWER_USE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked();
                    removeMessages(CHECK_EXCESSIVE_POWER_USE_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
                    sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case START_USER_SWITCH_FG_MSG:
            {
                mUserController.startUserInForeground(msg.arg1);
                break;
            }
        case REPORT_USER_SWITCH_MSG:
            {
                mUserController.dispatchUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case CONTINUE_USER_SWITCH_MSG:
            {
                mUserController.continueUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case USER_SWITCH_TIMEOUT_MSG:
            {
                mUserController.timeoutUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case REQUEST_ALL_PSS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
                break;
            }
        case START_PROFILES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    mUserController.startProfilesLocked();
                }
                break;
            }
        case UPDATE_TIME_PREFERENCE_MSG:
            {
                // For convenience we re-use the Intent extra values.
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case SYSTEM_USER_START_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.startUser(msg.arg1);
                break;
            }
        case SYSTEM_USER_UNLOCK_MSG:
            {
                final int userId = msg.arg1;
                mSystemServiceManager.unlockUser(userId);
                synchronized (ActivityManagerService.this) {
                    mRecentTasks.loadUserRecentsLocked(userId);
                }
                if (userId == UserHandle.USER_SYSTEM) {
                    startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_UNAWARE);
                }
                installEncryptionUnawareProviders(userId);
                mUserController.finishUserUnlocked((UserState) msg.obj);
                break;
            }
        case SYSTEM_USER_CURRENT_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_FINISH, Integer.toString(msg.arg2), msg.arg2);
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.switchUser(msg.arg1);
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "FinishBooting");
                    finishBooting();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    storageManager.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext, SystemNotificationChannels.DEVELOPER).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.SYSTEM)).build();
                try {
                    inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_DUMP_HEAP_NOTIFICATION, notification, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), null, DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case FOREGROUND_PROFILE_CHANGED_MSG:
            {
                mUserController.dispatchForegroundProfileChanged(msg.arg1);
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case REPORT_USER_SWITCH_COMPLETE_MSG:
            {
                mUserController.dispatchUserSwitchComplete(msg.arg1);
            }
            break;
        case REPORT_LOCKED_BOOT_COMPLETE_MSG:
            {
                mUserController.dispatchLockedBootComplete(msg.arg1);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case IDLE_UIDS_MSG:
            {
                idleUids();
            }
            break;
        case VR_MODE_CHANGE_MSG:
            {
                if (!mVrController.onVrModeChanged((ActivityRecord) msg.obj)) {
                    return;
                }
                synchronized (ActivityManagerService.this) {
                    final boolean disableNonVrUi = mVrController.shouldDisableNonVrUiLocked();
                    mWindowManager.disableNonVrUi(disableNonVrUi);
                    if (disableNonVrUi) {
                        // If we are in a VR mode where Picture-in-Picture mode is unsupported,
                        // then remove the pinned stack.
                        final PinnedActivityStack pinnedStack = mStackSupervisor.getStack(PINNED_STACK_ID);
                        if (pinnedStack != null) {
                            mStackSupervisor.removeStackLocked(PINNED_STACK_ID);
                        }
                    }
                }
            }
            break;
        case NOTIFY_VR_SLEEPING_MSG:
            {
                notifyVrManagerOfSleepState(msg.arg1 != 0);
            }
            break;
        case NOTIFY_VR_KEYGUARD_MSG:
            {
                notifyVrManagerOfKeyguardState(msg.arg1 != 0);
            }
            break;
        case HANDLE_TRUST_STORAGE_UPDATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.handleTrustStorageUpdate();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to handle trust storage update for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj, msg.arg1);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_TIMEOUT_MSG:
            {
                mServices.serviceForegroundTimeout((ServiceRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_CRASH_MSG:
            {
                mServices.serviceForegroundCrash((ProcessRecord) msg.obj);
            }
            break;
        case DISPATCH_PENDING_INTENT_CANCEL_MSG:
            {
                RemoteCallbackList<IResultReceiver> callbacks = (RemoteCallbackList<IResultReceiver>) msg.obj;
                int N = callbacks.beginBroadcast();
                for (int i = 0; i < N; i++) {
                    try {
                        callbacks.getBroadcastItem(i).send(Activity.RESULT_CANCELED, null);
                    } catch (RemoteException e) {
                    }
                }
                callbacks.finishBroadcast();
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                ProxyInfo proxy = (ProxyInfo) msg.obj;
                String host = "";
                String port = "";
                String exclList = "";
                Uri pacFileUrl = Uri.EMPTY;
                if (proxy != null) {
                    host = proxy.getHost();
                    port = Integer.toString(proxy.getPort());
                    exclList = proxy.getExclusionListAsString();
                    pacFileUrl = proxy.getPacFileUrl();
                }
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.setHttpProxy(host, port, exclList, pacFileUrl);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    mActivityStarter.doPendingActivityLaunchesLocked(true);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    final int appId = msg.arg1;
                    final int userId = msg.arg2;
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appId, false, false, true, false, false, userId, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context, SystemNotificationChannels.DEVELOPER).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, notification, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_POWER_USE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked();
                    removeMessages(CHECK_EXCESSIVE_POWER_USE_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
                    sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case START_USER_SWITCH_FG_MSG:
            {
                mUserController.startUserInForeground(msg.arg1);
                break;
            }
        case REPORT_USER_SWITCH_MSG:
            {
                mUserController.dispatchUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case CONTINUE_USER_SWITCH_MSG:
            {
                mUserController.continueUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case USER_SWITCH_TIMEOUT_MSG:
            {
                mUserController.timeoutUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case REQUEST_ALL_PSS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
                break;
            }
        case START_PROFILES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    mUserController.startProfilesLocked();
                }
                break;
            }
        case UPDATE_TIME_PREFERENCE_MSG:
            {
                // For convenience we re-use the Intent extra values.
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case SYSTEM_USER_START_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.startUser(msg.arg1);
                break;
            }
        case SYSTEM_USER_UNLOCK_MSG:
            {
                final int userId = msg.arg1;
                mSystemServiceManager.unlockUser(userId);
                synchronized (ActivityManagerService.this) {
                    mRecentTasks.loadUserRecentsLocked(userId);
                }
                if (userId == UserHandle.USER_SYSTEM) {
                    startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_UNAWARE);
                }
                installEncryptionUnawareProviders(userId);
                mUserController.finishUserUnlocked((UserState) msg.obj);
                break;
            }
        case SYSTEM_USER_CURRENT_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_FINISH, Integer.toString(msg.arg2), msg.arg2);
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.switchUser(msg.arg1);
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "FinishBooting");
                    finishBooting();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    storageManager.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext, SystemNotificationChannels.DEVELOPER).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.SYSTEM)).build();
                try {
                    inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_DUMP_HEAP_NOTIFICATION, notification, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), null, DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case FOREGROUND_PROFILE_CHANGED_MSG:
            {
                mUserController.dispatchForegroundProfileChanged(msg.arg1);
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case REPORT_USER_SWITCH_COMPLETE_MSG:
            {
                mUserController.dispatchUserSwitchComplete(msg.arg1);
            }
            break;
        case REPORT_LOCKED_BOOT_COMPLETE_MSG:
            {
                mUserController.dispatchLockedBootComplete(msg.arg1);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case IDLE_UIDS_MSG:
            {
                idleUids();
            }
            break;
        case VR_MODE_CHANGE_MSG:
            {
                if (!mVrController.onVrModeChanged((ActivityRecord) msg.obj)) {
                    return;
                }
                synchronized (ActivityManagerService.this) {
                    final boolean disableNonVrUi = mVrController.shouldDisableNonVrUiLocked();
                    mWindowManager.disableNonVrUi(disableNonVrUi);
                    if (disableNonVrUi) {
                        // If we are in a VR mode where Picture-in-Picture mode is unsupported,
                        // then remove the pinned stack.
                        final PinnedActivityStack pinnedStack = mStackSupervisor.getStack(PINNED_STACK_ID);
                        if (pinnedStack != null) {
                            mStackSupervisor.removeStackLocked(PINNED_STACK_ID);
                        }
                    }
                }
            }
            break;
        case DISPATCH_SCREEN_AWAKE_MSG:
            {
                final boolean isAwake = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onAwakeStateChanged(isAwake);
                }
            }
            break;
        case DISPATCH_SCREEN_KEYGUARD_MSG:
            {
                final boolean isShowing = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onKeyguardStateChanged(isShowing);
                }
            }
            break;
        case HANDLE_TRUST_STORAGE_UPDATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.handleTrustStorageUpdate();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to handle trust storage update for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
    }
}
#end_block

#method_before
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            final int userId = UserHandle.getUserId(app.uid);
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                StorageManagerInternal storageManagerInternal = LocalServices.getService(StorageManagerInternal.class);
                mountExternal = storageManagerInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[3];
            } else {
                gids = new int[permGids.length + 3];
                System.arraycopy(permGids, 0, gids, 3, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
            gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));
            // Replace any invalid GIDs
            if (gids[0] == UserHandle.ERR_GID)
                gids[0] = gids[2];
            if (gids[1] == UserHandle.ERR_GID)
                gids[1] = gids[2];
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int runtimeFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;
            runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            runtimeFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            runtimeFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        if (app.info.isPrivilegedApp() && !SystemProperties.getBoolean("pm.dexopt.priv-apps", true)) {
            runtimeFlags |= Zygote.DISABLE_VERIFIER;
            runtimeFlags |= Zygote.ONLY_USE_SYSTEM_OAT_FILES;
        }
        String invokeWith = null;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            // Debuggable apps may include a wrapper script with their library directory.
            String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh";
            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
            try {
                if (new File(wrapperFileName).exists()) {
                    invokeWith = "/system/bin/logwrapper " + wrapperFileName;
                }
            } finally {
                StrictMode.setThreadPolicy(oldPolicy);
            }
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // the per-user SELinux context must be set
        if (TextUtils.isEmpty(app.info.seInfoUser)) {
            Slog.wtf(TAG, "SELinux tag not defined", new IllegalStateException("SELinux tag not defined for " + app.info.packageName + " (uid " + app.uid + ")"));
        }
        final String seInfo = app.info.seInfo + (TextUtils.isEmpty(app.info.seInfoUser) ? "" : app.info.seInfoUser);
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        ProcessStartResult startResult;
        if (hostingType.equals("webview_service")) {
            startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, entryPointArgs);
        } else {
            startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs);
        }
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, seInfo, app.info.sourceDir, startResult.pid);
        } catch (RemoteException ex) {
        // Ignore
        }
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(startResult.pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        Slog.e(TAG, "Failure starting process " + app.processName, e);
        // Something went very wrong while trying to start this process; one
        // common case is when the package is frozen due to an active
        // upgrade. To recover, clean up any active bookkeeping related to
        // starting this process. (We already invoked this method once when
        // the package was initially frozen through KILL_APPLICATION_MSG, so
        // it doesn't hurt to use it again.)
        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
    }
}
#method_after
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            final int userId = UserHandle.getUserId(app.uid);
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                StorageManagerInternal storageManagerInternal = LocalServices.getService(StorageManagerInternal.class);
                mountExternal = storageManagerInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[3];
            } else {
                gids = new int[permGids.length + 3];
                System.arraycopy(permGids, 0, gids, 3, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
            gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));
            // Replace any invalid GIDs
            if (gids[0] == UserHandle.ERR_GID)
                gids[0] = gids[2];
            if (gids[1] == UserHandle.ERR_GID)
                gids[1] = gids[2];
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int runtimeFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;
            runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            runtimeFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            runtimeFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        if (app.info.isPrivilegedApp() && !SystemProperties.getBoolean("pm.dexopt.priv-apps", true)) {
            runtimeFlags |= Zygote.DISABLE_VERIFIER;
            runtimeFlags |= Zygote.ONLY_USE_SYSTEM_OAT_FILES;
        }
        if (app.info.isAllowedToUseHiddenApi()) {
            // This app is allowed to use undocumented and private APIs. Set
            // up its runtime with the appropriate flag.
            runtimeFlags |= Zygote.DISABLE_HIDDEN_API_CHECKS;
        }
        String invokeWith = null;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            // Debuggable apps may include a wrapper script with their library directory.
            String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh";
            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
            try {
                if (new File(wrapperFileName).exists()) {
                    invokeWith = "/system/bin/logwrapper " + wrapperFileName;
                }
            } finally {
                StrictMode.setThreadPolicy(oldPolicy);
            }
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // the per-user SELinux context must be set
        if (TextUtils.isEmpty(app.info.seInfoUser)) {
            Slog.wtf(TAG, "SELinux tag not defined", new IllegalStateException("SELinux tag not defined for " + app.info.packageName + " (uid " + app.uid + ")"));
        }
        final String seInfo = app.info.seInfo + (TextUtils.isEmpty(app.info.seInfoUser) ? "" : app.info.seInfoUser);
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        ProcessStartResult startResult;
        if (hostingType.equals("webview_service")) {
            startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, entryPointArgs);
        } else {
            startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs);
        }
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, seInfo, app.info.sourceDir, startResult.pid);
        } catch (RemoteException ex) {
        // Ignore
        }
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(startResult.pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        Slog.e(TAG, "Failure starting process " + app.processName, e);
        // Something went very wrong while trying to start this process; one
        // common case is when the package is frozen due to an active
        // upgrade. To recover, clean up any active bookkeeping related to
        // starting this process. (We already invoked this method once when
        // the package was initially frozen through KILL_APPLICATION_MSG, so
        // it doesn't hurt to use it again.)
        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
    }
}
#end_block

#method_before
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    long startTime = SystemClock.uptimeMillis();
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToImportant = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;
    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    checkTime(startTime, "attachApplicationLocked: before bindApplication");
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = ApplicationThreadConstants.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? ApplicationThreadConstants.DEBUG_WAIT : ApplicationThreadConstants.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        ProfilerInfo profilerInfo = null;
        String agent = null;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            profilerInfo = (mProfilerInfo != null && mProfilerInfo.profileFile != null) ? new ProfilerInfo(mProfilerInfo) : null;
            agent = mProfilerInfo != null ? mProfilerInfo.agent : null;
        } else if (app.instr != null && app.instr.mProfileFile != null) {
            profilerInfo = new ProfilerInfo(app.instr.mProfileFile, null, 0, false, false, null);
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = mBackupTarget.appInfo.uid >= FIRST_APPLICATION_UID && ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));
        }
        if (app.instr != null) {
            notifyPackageUse(app.instr.mClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + getGlobalConfiguration());
        ApplicationInfo appInfo = app.instr != null ? app.instr.mTargetInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        if (profilerInfo != null && profilerInfo.profileFd != null) {
            profilerInfo.profileFd = profilerInfo.profileFd.dup();
        }
        // We deprecated Build.SERIAL and it is not accessible to
        // apps that target the v2 security sandbox. Since access to
        // the serial is now behind a permission we push down the value.
        String buildSerial = appInfo.targetSandboxVersion < 2 ? sTheRealBuildSerial : Build.UNKNOWN;
        // instrumentation process.)
        if (mActiveInstrumentation.size() > 0 && app.instr == null) {
            for (int i = mActiveInstrumentation.size() - 1; i >= 0 && app.instr == null; i--) {
                ActiveInstrumentation aInstr = mActiveInstrumentation.get(i);
                if (!aInstr.mFinished && aInstr.mTargetInfo.uid == app.uid) {
                    if (aInstr.mTargetProcesses.length == 0) {
                        // the target instrumentation should be included.
                        if (aInstr.mTargetInfo.packageName.equals(app.info.packageName)) {
                            app.instr = aInstr;
                            aInstr.mRunningProcesses.add(app);
                        }
                    } else {
                        for (String proc : aInstr.mTargetProcesses) {
                            if (proc.equals(app.processName)) {
                                app.instr = aInstr;
                                aInstr.mRunningProcesses.add(app);
                                break;
                            }
                        }
                    }
                }
            }
        }
        // application code.
        if (agent != null) {
            thread.attachAgent(agent);
        }
        checkTime(startTime, "attachApplicationLocked: immediately before bindApplication");
        mStackSupervisor.mActivityMetricsLogger.notifyBindApplication(app);
        if (app.instr != null) {
            thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        } else {
            thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        }
        checkTime(startTime, "attachApplicationLocked: immediately after bindApplication");
        updateLruProcessLocked(app, false, null);
        checkTime(startTime, "attachApplicationLocked: after updateLruProcessLocked");
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
            checkTime(startTime, "attachApplicationLocked: after mServices.attachApplicationLocked");
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
            checkTime(startTime, "attachApplicationLocked: after sendPendingBroadcastsLocked");
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.app == app) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
        checkTime(startTime, "attachApplicationLocked: after updateOomAdjLocked");
    }
    return true;
}
#method_after
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    long startTime = SystemClock.uptimeMillis();
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToImportant = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;
    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    checkTime(startTime, "attachApplicationLocked: before bindApplication");
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = ApplicationThreadConstants.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? ApplicationThreadConstants.DEBUG_WAIT : ApplicationThreadConstants.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = mBackupTarget.appInfo.uid >= FIRST_APPLICATION_UID && ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));
        }
        if (app.instr != null) {
            notifyPackageUse(app.instr.mClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + getGlobalConfiguration());
        ApplicationInfo appInfo = app.instr != null ? app.instr.mTargetInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        ProfilerInfo profilerInfo = null;
        String preBindAgent = null;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            if (mProfilerInfo != null) {
                // Send a profiler info object to the app if either a file is given, or
                // an agent should be loaded at bind-time.
                boolean needsInfo = mProfilerInfo.profileFile != null || mProfilerInfo.attachAgentDuringBind;
                profilerInfo = needsInfo ? new ProfilerInfo(mProfilerInfo) : null;
                if (mProfilerInfo.agent != null) {
                    preBindAgent = mProfilerInfo.agent;
                }
            }
        } else if (app.instr != null && app.instr.mProfileFile != null) {
            profilerInfo = new ProfilerInfo(app.instr.mProfileFile, null, 0, false, false, null, false);
        }
        if (mAppAgentMap != null && mAppAgentMap.containsKey(processName)) {
            // postponed to here.
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                String agent = mAppAgentMap.get(processName);
                // Do not overwrite already requested agent.
                if (profilerInfo == null) {
                    profilerInfo = new ProfilerInfo(null, null, 0, false, false, mAppAgentMap.get(processName), true);
                } else if (profilerInfo.agent == null) {
                    profilerInfo = profilerInfo.setAgent(mAppAgentMap.get(processName), true);
                }
            }
        }
        if (profilerInfo != null && profilerInfo.profileFd != null) {
            profilerInfo.profileFd = profilerInfo.profileFd.dup();
        }
        // We deprecated Build.SERIAL and it is not accessible to
        // apps that target the v2 security sandbox. Since access to
        // the serial is now behind a permission we push down the value.
        String buildSerial = appInfo.targetSandboxVersion < 2 ? sTheRealBuildSerial : Build.UNKNOWN;
        // instrumentation process.)
        if (mActiveInstrumentation.size() > 0 && app.instr == null) {
            for (int i = mActiveInstrumentation.size() - 1; i >= 0 && app.instr == null; i--) {
                ActiveInstrumentation aInstr = mActiveInstrumentation.get(i);
                if (!aInstr.mFinished && aInstr.mTargetInfo.uid == app.uid) {
                    if (aInstr.mTargetProcesses.length == 0) {
                        // the target instrumentation should be included.
                        if (aInstr.mTargetInfo.packageName.equals(app.info.packageName)) {
                            app.instr = aInstr;
                            aInstr.mRunningProcesses.add(app);
                        }
                    } else {
                        for (String proc : aInstr.mTargetProcesses) {
                            if (proc.equals(app.processName)) {
                                app.instr = aInstr;
                                aInstr.mRunningProcesses.add(app);
                                break;
                            }
                        }
                    }
                }
            }
        }
        // application code.
        if (preBindAgent != null) {
            thread.attachAgent(preBindAgent);
        }
        checkTime(startTime, "attachApplicationLocked: immediately before bindApplication");
        mStackSupervisor.mActivityMetricsLogger.notifyBindApplication(app);
        if (app.instr != null) {
            thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        } else {
            thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        }
        checkTime(startTime, "attachApplicationLocked: immediately after bindApplication");
        updateLruProcessLocked(app, false, null);
        checkTime(startTime, "attachApplicationLocked: after updateLruProcessLocked");
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
            checkTime(startTime, "attachApplicationLocked: after mServices.attachApplicationLocked");
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
            checkTime(startTime, "attachApplicationLocked: after sendPendingBroadcastsLocked");
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.app == app) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
        checkTime(startTime, "attachApplicationLocked: after updateOomAdjLocked");
    }
    return true;
}
#end_block

#method_before
void onWakefulnessChanged(int wakefulness) {
    synchronized (this) {
        boolean wasAwake = mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE;
        boolean isAwake = wakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE;
        mWakefulness = wakefulness;
        if (wasAwake != isAwake) {
            // Also update state in a special way for running foreground services UI.
            mServices.updateScreenStateLocked(isAwake);
            sendNotifyVrManagerOfSleepState(!isAwake);
        }
    }
}
#method_after
void onWakefulnessChanged(int wakefulness) {
    synchronized (this) {
        boolean wasAwake = mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE;
        boolean isAwake = wakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE;
        mWakefulness = wakefulness;
        if (wasAwake != isAwake) {
            // Also update state in a special way for running foreground services UI.
            mServices.updateScreenStateLocked(isAwake);
            mHandler.obtainMessage(DISPATCH_SCREEN_AWAKE_MSG, isAwake ? 1 : 0, 0).sendToTarget();
        }
    }
}
#end_block

#method_before
@Override
public void setLockScreenShown(boolean showing, int secondaryDisplayShowing) {
    if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("Requires permission " + android.Manifest.permission.DEVICE_POWER);
    }
    synchronized (this) {
        long ident = Binder.clearCallingIdentity();
        try {
            mKeyguardController.setKeyguardShown(showing, secondaryDisplayShowing);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
    sendNotifyVrManagerOfKeyguardState(showing);
}
#method_after
@Override
public void setLockScreenShown(boolean showing, int secondaryDisplayShowing) {
    if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("Requires permission " + android.Manifest.permission.DEVICE_POWER);
    }
    synchronized (this) {
        long ident = Binder.clearCallingIdentity();
        try {
            mKeyguardController.setKeyguardShown(showing, secondaryDisplayShowing);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
    mHandler.obtainMessage(DISPATCH_SCREEN_KEYGUARD_MSG, showing ? 1 : 0, 0).sendToTarget();
}
#end_block

#method_before
protected boolean isAvailable() {
    return mProfileStarted && !mCleaningUp;
}
#method_after
protected boolean isAvailable() {
    return mProfileStarted;
}
#end_block

#method_before
@Override
public void onCreate() {
    if (DBG) {
        log("onCreate");
    }
    super.onCreate();
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    mBinder = initBinder();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    BroadcastReceiver userSwitchedReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);
            if (userId == UserHandle.USER_NULL) {
                Log.e(mName, "userChangeReceiver received an invalid EXTRA_USER_HANDLE");
                return;
            }
            if (Intent.ACTION_USER_SWITCHED.equals(action)) {
                Log.d(mName, "User switched to userId " + userId);
                setCurrentUser(userId);
            } else if (Intent.ACTION_USER_UNLOCKED.equals(intent.getAction())) {
                Log.d(mName, "Unlocked userId " + userId);
                setUserUnlocked(userId);
            }
        }
    };
    getApplicationContext().registerReceiver(userSwitchedReceiver, filter);
    int currentUserId = ActivityManager.getCurrentUser();
    setCurrentUser(currentUserId);
    UserManager userManager = UserManager.get(getApplicationContext());
    if (userManager.isUserUnlocked(currentUserId)) {
        setUserUnlocked(currentUserId);
    }
    create();
}
#method_after
@Override
public void onCreate() {
    if (DBG) {
        log("onCreate");
    }
    super.onCreate();
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    mBinder = initBinder();
    create();
}
#end_block

#method_before
@Override
public void onDestroy() {
    if (mCleaningUp) {
        log("Cleanup already started... Skipping cleanup()...");
        return;
    }
    mCleaningUp = true;
    if (mAdapterService != null) {
        mAdapterService.removeProfile(this);
    }
    cleanup();
    if (mBinder != null) {
        mBinder.cleanup();
        mBinder = null;
    }
    super.onDestroy();
    mAdapter = null;
}
#method_after
@Override
public void onDestroy() {
    if (mAdapterService != null) {
        mAdapterService.removeProfile(this);
    }
    cleanup();
    if (mBinder != null) {
        mBinder.cleanup();
        mBinder = null;
    }
    super.onDestroy();
    mAdapter = null;
}
#end_block

#method_before
private void doStart() {
    if (mAdapter == null) {
        Log.w(mName, "Can't start profile service: device does not have BT");
        return;
    }
    mAdapterService = AdapterService.getAdapterService();
    if (mAdapterService == null) {
        Log.w(TAG, "Could not add this profile because AdapterService is null.");
        return;
    }
    mAdapterService.addProfile(this);
    mProfileStarted = start();
    if (!mProfileStarted) {
        Log.e(mName, "Error starting profile. start() returned false.");
        return;
    }
    mAdapterService.onProfileServiceStateChanged(getClass().getName(), BluetoothAdapter.STATE_ON);
}
#method_after
private void doStart() {
    if (mAdapter == null) {
        Log.w(mName, "Can't start profile service: device does not have BT");
        return;
    }
    mAdapterService = AdapterService.getAdapterService();
    if (mAdapterService == null) {
        Log.w(mName, "Could not add this profile because AdapterService is null.");
        return;
    }
    mAdapterService.addProfile(this);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_UNLOCKED);
    mUserSwitchedReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);
            if (userId == UserHandle.USER_NULL) {
                Log.e(mName, "userChangeReceiver received an invalid EXTRA_USER_HANDLE");
                return;
            }
            if (Intent.ACTION_USER_SWITCHED.equals(action)) {
                Log.d(mName, "User switched to userId " + userId);
                setCurrentUser(userId);
            } else if (Intent.ACTION_USER_UNLOCKED.equals(intent.getAction())) {
                Log.d(mName, "Unlocked userId " + userId);
                setUserUnlocked(userId);
            }
        }
    };
    getApplicationContext().registerReceiver(mUserSwitchedReceiver, filter);
    int currentUserId = ActivityManager.getCurrentUser();
    setCurrentUser(currentUserId);
    UserManager userManager = UserManager.get(getApplicationContext());
    if (userManager.isUserUnlocked(currentUserId)) {
        setUserUnlocked(currentUserId);
    }
    mProfileStarted = start();
    if (!mProfileStarted) {
        Log.e(mName, "Error starting profile. start() returned false.");
        return;
    }
    mAdapterService.onProfileServiceStateChanged(getClass().getName(), BluetoothAdapter.STATE_ON);
}
#end_block

#method_before
private void doStop() {
    if (!mProfileStarted) {
        Log.w(mName, "doStop() called but the profile is not running.");
    }
    mProfileStarted = false;
    if (!stop()) {
        Log.e(mName, "Unable to stop profile");
    }
    if (mAdapterService != null) {
        mAdapterService.onProfileServiceStateChanged(getClass().getName(), BluetoothAdapter.STATE_OFF);
    }
    stopSelf();
}
#method_after
private void doStop() {
    if (!mProfileStarted) {
        Log.w(mName, "doStop() called, but the profile is not running.");
    }
    mProfileStarted = false;
    if (mAdapterService != null) {
        mAdapterService.onProfileServiceStateChanged(getClass().getName(), BluetoothAdapter.STATE_OFF);
    }
    if (!stop()) {
        Log.e(mName, "Unable to stop profile");
    }
    if (mUserSwitchedReceiver != null) {
        getApplicationContext().unregisterReceiver(mUserSwitchedReceiver);
        mUserSwitchedReceiver = null;
    }
    stopSelf();
}
#end_block

#method_before
public static synchronized TestDump getTestDump() throws IOException {
    return getTestDump("test-dump.hprof", "test-dump-base.hprof", "proguard_dictionary");
}
#method_after
public static synchronized TestDump getTestDump() throws IOException {
    return getTestDump("test-dump.hprof", "test-dump-base.hprof", "test-dump.map");
}
#end_block

#method_before
public void test_powDD() {
    // Test for method double java.lang.Math.pow(double, double)
    double NZERO = longTodouble(doubleTolong(0.0) ^ 0x8000000000000000L);
    double p1 = 1.0;
    double p2 = 2.0;
    double p3 = 3.0;
    double p4 = 4.0;
    double p5 = 5.0;
    double p6 = 6.0;
    double p7 = 7.0;
    double p8 = 8.0;
    double p9 = 9.0;
    double p10 = 10.0;
    double p11 = 11.0;
    double p12 = 12.0;
    double p13 = 13.0;
    double p14 = 14.0;
    double p15 = 15.0;
    double p16 = 16.0;
    double[] values = { p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16 };
    for (int x = 0; x < values.length; x++) {
        double dval = values[x];
        double nagateDval = negateDouble(dval);
        if (Double.isNaN(nagateDval)) {
            continue;
        }
        // If the second argument is positive or negative zero, then the
        // result is 1.0.
        assertEquals("Result should be Math.pow(" + dval + ",-0.0)=+1.0", 1.0, Math.pow(dval, NZERO));
        assertEquals("Result should be Math.pow(" + nagateDval + ",-0.0)=+1.0", 1.0, Math.pow(nagateDval, NZERO));
        assertEquals("Result should be Math.pow(" + dval + ",+0.0)=+1.0", 1.0, Math.pow(dval, +0.0));
        assertEquals("Result should be Math.pow(" + nagateDval + ",+0.0)=+1.0", 1.0, Math.pow(nagateDval, +0.0));
        // If the second argument is 1.0, then the result is the same as the
        // first argument.
        assertEquals("Result should be Math.pow(" + dval + "," + 1.0 + ")=" + dval, dval, Math.pow(dval, 1.0));
        assertEquals("Result should be Math.pow(" + nagateDval + "," + 1.0 + ")=" + nagateDval, nagateDval, Math.pow(nagateDval, 1.0));
        // If the second argument is NaN, then the result is NaN.
        assertEquals("Result should be Math.pow(" + dval + "," + Double.NaN + ")=" + Double.NaN, Double.NaN, Math.pow(dval, Double.NaN));
        assertEquals("Result should be Math.pow(" + nagateDval + "," + Double.NaN + ")=" + Double.NaN, Double.NaN, Math.pow(nagateDval, Double.NaN));
        if (dval > 1) {
            // If the first argument is NaN and the second argument is
            // nonzero,
            // then the result is NaN.
            assertEquals("Result should be Math.pow(" + Double.NaN + "," + dval + ")=" + Double.NaN, Double.NaN, Math.pow(Double.NaN, dval));
            assertEquals("Result should be Math.pow(" + Double.NaN + "," + nagateDval + ")=" + Double.NaN, Double.NaN, Math.pow(Double.NaN, nagateDval));
            /*
                 * If the first argument is positive zero and the second
                 * argument is greater than zero, or the first argument is
                 * positive infinity and the second argument is less than zero,
                 * then the result is positive zero.
                 */
            assertEquals("Result should be Math.pow(" + 0.0 + "," + dval + ")=" + 0.0, +0.0, Math.pow(0.0, dval));
            assertEquals("Result should be Math.pow(" + Double.POSITIVE_INFINITY + "," + nagateDval + ")=" + 0.0, +0.0, Math.pow(Double.POSITIVE_INFINITY, nagateDval));
            /*
                 * If the first argument is positive zero and the second
                 * argument is less than zero, or the first argument is positive
                 * infinity and the second argument is greater than zero, then
                 * the result is positive infinity.
                 */
            assertEquals("Result should be Math.pow(" + 0.0 + "," + nagateDval + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(0.0, nagateDval));
            assertEquals("Result should be Math.pow(" + Double.POSITIVE_INFINITY + "," + dval + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(Double.POSITIVE_INFINITY, dval));
            // Not a finite odd integer
            if (dval % 2 == 0) {
                /*
                     * If the first argument is negative zero and the second
                     * argument is greater than zero but not a finite odd
                     * integer, or the first argument is negative infinity and
                     * the second argument is less than zero but not a finite
                     * odd integer, then the result is positive zero.
                     */
                assertEquals("Result should be Math.pow(" + NZERO + "," + dval + ")=" + 0.0, +0.0, Math.pow(NZERO, dval));
                assertEquals("Result should be Math.pow(" + Double.NEGATIVE_INFINITY + "," + nagateDval + ")=" + 0.0, +0.0, Math.pow(Double.NEGATIVE_INFINITY, nagateDval));
                /*
                     * If the first argument is negative zero and the second
                     * argument is less than zero but not a finite odd integer,
                     * or the first argument is negative infinity and the second
                     * argument is greater than zero but not a finite odd
                     * integer, then the result is positive infinity.
                     */
                assertEquals("Result should be Math.pow(" + NZERO + "," + nagateDval + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(NZERO, nagateDval));
                assertEquals("Result should be Math.pow(" + Double.NEGATIVE_INFINITY + "," + dval + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(Double.NEGATIVE_INFINITY, dval));
            }
            // finite odd integer
            if (dval % 2 != 0) {
                /*
                     * If the first argument is negative zero and the second
                     * argument is a positive finite odd integer, or the first
                     * argument is negative infinity and the second argument is
                     * a negative finite odd integer, then the result is
                     * negative zero.
                     */
                assertEquals("Result should be Math.pow(" + NZERO + "," + dval + ")=" + NZERO, NZERO, Math.pow(NZERO, dval));
                assertEquals("Result should be Math.pow(" + Double.NEGATIVE_INFINITY + "," + nagateDval + ")=" + NZERO, NZERO, Math.pow(Double.NEGATIVE_INFINITY, nagateDval));
                /*
                     * If the first argument is negative zero and the second
                     * argument is a negative finite odd integer, or the first
                     * argument is negative infinity and the second argument is
                     * a positive finite odd integer then the result is negative
                     * infinity.
                     */
                assertEquals("Result should be Math.pow(" + NZERO + "," + nagateDval + ")=" + Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Math.pow(NZERO, nagateDval));
                assertEquals("Result should be Math.pow(" + Double.NEGATIVE_INFINITY + "," + dval + ")=" + Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Math.pow(Double.NEGATIVE_INFINITY, dval));
            }
            /**
             * 1. If the first argument is finite and less than zero if the
             * second argument is a finite even integer, the result is equal
             * to the result of raising the absolute value of the first
             * argument to the power of the second argument
             *
             * 2. if the second argument is a finite odd integer, the result is equal to the
             * negative of the result of raising the absolute value of the
             * first argument to the power of the second argument
             *
             * 3. if the second argument is finite and not an integer, then the result
             * is NaN.
             */
            for (int j = 1; j < values.length; j++) {
                double jval = values[j];
                if (jval % 2.0 == 0.0) {
                    assertEquals("" + nagateDval + " " + jval, Math.pow(dval, jval), Math.pow(nagateDval, jval));
                } else {
                    assertEquals("" + nagateDval + " " + jval, -1.0 * Math.pow(dval, jval), Math.pow(nagateDval, jval));
                }
                assertEquals(Double.NaN, Math.pow(nagateDval, jval / 0.5467));
                assertEquals(Double.NaN, Math.pow(nagateDval, -1.0 * jval / 0.5467));
            }
        }
        // second argument is infinite, then the result is NaN.
        if (dval == 1) {
            assertEquals("Result should be Math.pow(" + dval + "," + Double.POSITIVE_INFINITY + ")=" + Double.NaN, Double.NaN, Math.pow(dval, Double.POSITIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + dval + "," + Double.NEGATIVE_INFINITY + ")=" + Double.NaN, Double.NaN, Math.pow(dval, Double.NEGATIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + nagateDval + "," + Double.POSITIVE_INFINITY + ")=" + Double.NaN, Double.NaN, Math.pow(nagateDval, Double.POSITIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + nagateDval + "," + Double.NEGATIVE_INFINITY + ")=" + Double.NaN, Double.NaN, Math.pow(nagateDval, Double.NEGATIVE_INFINITY));
        }
        if (dval > 1) {
            /*
                 * If the absolute value of the first argument is greater than 1
                 * and the second argument is positive infinity, or the absolute
                 * value of the first argument is less than 1 and the second
                 * argument is negative infinity, then the result is positive
                 * infinity.
                 */
            assertEquals("Result should be Math.pow(" + dval + "," + Double.POSITIVE_INFINITY + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(dval, Double.POSITIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + nagateDval + "," + Double.NEGATIVE_INFINITY + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(-0.13456, Double.NEGATIVE_INFINITY));
            /*
                 * If the absolute value of the first argument is greater than 1
                 * and the second argument is negative infinity, or the absolute
                 * value of the first argument is less than 1 and the second
                 * argument is positive infinity, then the result is positive
                 * zero.
                 */
            assertEquals("Result should be Math.pow(" + dval + "," + Double.NEGATIVE_INFINITY + ")= +0.0", +0.0, Math.pow(dval, Double.NEGATIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + nagateDval + "," + Double.POSITIVE_INFINITY + ")= +0.0", +0.0, Math.pow(-0.13456, Double.POSITIVE_INFINITY));
        }
        assertEquals("Result should be Math.pow(" + 0.0 + "," + dval + ")=" + 0.0, 0.0, Math.pow(0.0, dval));
        assertEquals("Result should be Math.pow(" + Double.NaN + "," + dval + ")=" + Double.NaN, Double.NaN, Math.pow(Double.NaN, dval));
    }
    assertTrue("pow returned incorrect value", (long) Math.pow(2, 8) == 256l);
    assertTrue("pow returned incorrect value", Math.pow(2, -8) == 0.00390625d);
    assertEquals("Incorrect root returned1", 2, Math.sqrt(Math.pow(Math.sqrt(2), 4)), 0);
    assertEquals(Double.NEGATIVE_INFINITY, Math.pow(-10.0, 3.093403029238847E15));
    assertEquals(Double.POSITIVE_INFINITY, Math.pow(10.0, 3.093403029238847E15));
}
#method_after
public void test_powDD() {
    // Test for method double java.lang.Math.pow(double, double)
    double NZERO = longTodouble(doubleTolong(0.0) ^ 0x8000000000000000L);
    double p1 = 1.0;
    double p2 = 2.0;
    double p3 = 3.0;
    double p4 = 4.0;
    double p5 = 5.0;
    double p6 = 6.0;
    double p7 = 7.0;
    double p8 = 8.0;
    double p9 = 9.0;
    double p10 = 10.0;
    double p11 = 11.0;
    double p12 = 12.0;
    double p13 = 13.0;
    double p14 = 14.0;
    double p15 = 15.0;
    double p16 = 16.0;
    double[] values = { p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16 };
    for (int x = 0; x < values.length; x++) {
        double dval = values[x];
        double negateDval = negateDouble(dval);
        // If the second argument is positive or negative zero, then the
        // result is 1.0.
        assertEquals("Result should be Math.pow(" + dval + ",-0.0)=+1.0", 1.0, Math.pow(dval, NZERO));
        assertEquals("Result should be Math.pow(" + negateDval + ",-0.0)=+1.0", 1.0, Math.pow(negateDval, NZERO));
        assertEquals("Result should be Math.pow(" + dval + ",+0.0)=+1.0", 1.0, Math.pow(dval, +0.0));
        assertEquals("Result should be Math.pow(" + negateDval + ",+0.0)=+1.0", 1.0, Math.pow(negateDval, +0.0));
        // If the second argument is 1.0, then the result is the same as the
        // first argument.
        assertEquals("Result should be Math.pow(" + dval + "," + 1.0 + ")=" + dval, dval, Math.pow(dval, 1.0));
        assertEquals("Result should be Math.pow(" + negateDval + "," + 1.0 + ")=" + negateDval, negateDval, Math.pow(negateDval, 1.0));
        // If the second argument is NaN, then the result is NaN.
        assertEquals("Result should be Math.pow(" + dval + "," + Double.NaN + ")=" + Double.NaN, Double.NaN, Math.pow(dval, Double.NaN));
        assertEquals("Result should be Math.pow(" + negateDval + "," + Double.NaN + ")=" + Double.NaN, Double.NaN, Math.pow(negateDval, Double.NaN));
        if (dval > 1) {
            // If the first argument is NaN and the second argument is
            // nonzero,
            // then the result is NaN.
            assertEquals("Result should be Math.pow(" + Double.NaN + "," + dval + ")=" + Double.NaN, Double.NaN, Math.pow(Double.NaN, dval));
            assertEquals("Result should be Math.pow(" + Double.NaN + "," + negateDval + ")=" + Double.NaN, Double.NaN, Math.pow(Double.NaN, negateDval));
            /*
                 * If the first argument is positive zero and the second
                 * argument is greater than zero, or the first argument is
                 * positive infinity and the second argument is less than zero,
                 * then the result is positive zero.
                 */
            assertEquals("Result should be Math.pow(" + 0.0 + "," + dval + ")=" + 0.0, +0.0, Math.pow(0.0, dval));
            assertEquals("Result should be Math.pow(" + Double.POSITIVE_INFINITY + "," + negateDval + ")=" + 0.0, +0.0, Math.pow(Double.POSITIVE_INFINITY, negateDval));
            /*
                 * If the first argument is positive zero and the second
                 * argument is less than zero, or the first argument is positive
                 * infinity and the second argument is greater than zero, then
                 * the result is positive infinity.
                 */
            assertEquals("Result should be Math.pow(" + 0.0 + "," + negateDval + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(0.0, negateDval));
            assertEquals("Result should be Math.pow(" + Double.POSITIVE_INFINITY + "," + dval + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(Double.POSITIVE_INFINITY, dval));
            // Not a finite odd integer
            if (dval % 2 == 0) {
                /*
                     * If the first argument is negative zero and the second
                     * argument is greater than zero but not a finite odd
                     * integer, or the first argument is negative infinity and
                     * the second argument is less than zero but not a finite
                     * odd integer, then the result is positive zero.
                     */
                assertEquals("Result should be Math.pow(" + NZERO + "," + dval + ")=" + 0.0, +0.0, Math.pow(NZERO, dval));
                assertEquals("Result should be Math.pow(" + Double.NEGATIVE_INFINITY + "," + negateDval + ")=" + 0.0, +0.0, Math.pow(Double.NEGATIVE_INFINITY, negateDval));
                /*
                     * If the first argument is negative zero and the second
                     * argument is less than zero but not a finite odd integer,
                     * or the first argument is negative infinity and the second
                     * argument is greater than zero but not a finite odd
                     * integer, then the result is positive infinity.
                     */
                assertEquals("Result should be Math.pow(" + NZERO + "," + negateDval + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(NZERO, negateDval));
                assertEquals("Result should be Math.pow(" + Double.NEGATIVE_INFINITY + "," + dval + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(Double.NEGATIVE_INFINITY, dval));
            }
            // finite odd integer
            if (dval % 2 != 0) {
                /*
                     * If the first argument is negative zero and the second
                     * argument is a positive finite odd integer, or the first
                     * argument is negative infinity and the second argument is
                     * a negative finite odd integer, then the result is
                     * negative zero.
                     */
                assertEquals("Result should be Math.pow(" + NZERO + "," + dval + ")=" + NZERO, NZERO, Math.pow(NZERO, dval));
                assertEquals("Result should be Math.pow(" + Double.NEGATIVE_INFINITY + "," + negateDval + ")=" + NZERO, NZERO, Math.pow(Double.NEGATIVE_INFINITY, negateDval));
                /*
                     * If the first argument is negative zero and the second
                     * argument is a negative finite odd integer, or the first
                     * argument is negative infinity and the second argument is
                     * a positive finite odd integer then the result is negative
                     * infinity.
                     */
                assertEquals("Result should be Math.pow(" + NZERO + "," + negateDval + ")=" + Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Math.pow(NZERO, negateDval));
                assertEquals("Result should be Math.pow(" + Double.NEGATIVE_INFINITY + "," + dval + ")=" + Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Math.pow(Double.NEGATIVE_INFINITY, dval));
            }
            /**
             * 1. If the first argument is finite and less than zero if the
             * second argument is a finite even integer, the result is equal
             * to the result of raising the absolute value of the first
             * argument to the power of the second argument
             *
             * 2. if the second argument is a finite odd integer, the result is equal to the
             * negative of the result of raising the absolute value of the
             * first argument to the power of the second argument
             *
             * 3. if the second argument is finite and not an integer, then the result
             * is NaN.
             */
            for (int j = 1; j < values.length; j++) {
                double jval = values[j];
                if (jval % 2.0 == 0.0) {
                    assertEquals("" + negateDval + " " + jval, Math.pow(dval, jval), Math.pow(negateDval, jval));
                } else {
                    assertEquals("" + negateDval + " " + jval, -1.0 * Math.pow(dval, jval), Math.pow(negateDval, jval));
                }
                assertEquals(Double.NaN, Math.pow(negateDval, jval / 0.5467));
                assertEquals(Double.NaN, Math.pow(negateDval, -1.0 * jval / 0.5467));
            }
        }
        // second argument is infinite, then the result is NaN.
        if (dval == 1) {
            assertEquals("Result should be Math.pow(" + dval + "," + Double.POSITIVE_INFINITY + ")=" + Double.NaN, Double.NaN, Math.pow(dval, Double.POSITIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + dval + "," + Double.NEGATIVE_INFINITY + ")=" + Double.NaN, Double.NaN, Math.pow(dval, Double.NEGATIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + negateDval + "," + Double.POSITIVE_INFINITY + ")=" + Double.NaN, Double.NaN, Math.pow(negateDval, Double.POSITIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + negateDval + "," + Double.NEGATIVE_INFINITY + ")=" + Double.NaN, Double.NaN, Math.pow(negateDval, Double.NEGATIVE_INFINITY));
        }
        if (dval > 1) {
            /*
                 * If the absolute value of the first argument is greater than 1
                 * and the second argument is positive infinity, or the absolute
                 * value of the first argument is less than 1 and the second
                 * argument is negative infinity, then the result is positive
                 * infinity.
                 */
            assertEquals("Result should be Math.pow(" + dval + "," + Double.POSITIVE_INFINITY + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(dval, Double.POSITIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + negateDval + "," + Double.NEGATIVE_INFINITY + ")=" + Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Math.pow(-0.13456, Double.NEGATIVE_INFINITY));
            /*
                 * If the absolute value of the first argument is greater than 1
                 * and the second argument is negative infinity, or the absolute
                 * value of the first argument is less than 1 and the second
                 * argument is positive infinity, then the result is positive
                 * zero.
                 */
            assertEquals("Result should be Math.pow(" + dval + "," + Double.NEGATIVE_INFINITY + ")= +0.0", +0.0, Math.pow(dval, Double.NEGATIVE_INFINITY));
            assertEquals("Result should be Math.pow(" + negateDval + "," + Double.POSITIVE_INFINITY + ")= +0.0", +0.0, Math.pow(-0.13456, Double.POSITIVE_INFINITY));
        }
        assertEquals("Result should be Math.pow(" + 0.0 + "," + dval + ")=" + 0.0, 0.0, Math.pow(0.0, dval));
        assertEquals("Result should be Math.pow(" + Double.NaN + "," + dval + ")=" + Double.NaN, Double.NaN, Math.pow(Double.NaN, dval));
    }
    assertTrue("pow returned incorrect value", (long) Math.pow(2, 8) == 256l);
    assertTrue("pow returned incorrect value", Math.pow(2, -8) == 0.00390625d);
    assertEquals("Incorrect root returned1", 2, Math.sqrt(Math.pow(Math.sqrt(2), 4)), 0);
    assertEquals(Double.NEGATIVE_INFINITY, Math.pow(-10.0, 3.093403029238847E15));
    assertEquals(Double.POSITIVE_INFINITY, Math.pow(10.0, 3.093403029238847E15));
}
#end_block

#method_before
public void testJvmtiAgentAppInternal() throws Exception {
    runJvmtiAgentLoadTest((ITestDevice device, String pkg, String apk, String abiName) -> {
        try {
            String setAgentAppCmd = "cmd activity set-agent-app " + pkg + " " + AGENT;
            String setAgentAppReply = device.executeShellCommand(setAgentAppCmd);
            if (setAgentAppReply != null && !setAgentAppReply.trim().isEmpty()) {
                CLog.e(setAgentAppReply);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed running set-agent-app", e);
        }
        try {
            runAttachTestCmd(device, pkg, "");
        } catch (Exception e) {
            throw new RuntimeException("Failed agent-app attaching", e);
        }
    });
}
#method_after
public void testJvmtiAgentAppInternal() throws Exception {
    runJvmtiAgentLoadTest((ITestDevice device, String pkg, String apk, String abiName) -> {
        try {
            String setAgentAppCmd = "cmd activity set-agent-app " + pkg + " " + AGENT;
            device.executeShellCommand(setAgentAppCmd);
        } catch (Exception e) {
            throw new RuntimeException("Failed running set-agent-app", e);
        }
        try {
            runAttachTestCmd(device, pkg, "");
            // And again.
            runAttachTestCmd(device, pkg, "");
        } catch (Exception e) {
            throw new RuntimeException("Failed agent-app attaching", e);
        }
    });
}
#end_block

#method_before
public void testJvmtiAgentAppExternal() throws Exception {
    runJvmtiAgentLoadTest((ITestDevice device, String pkg, String apk, String abiName) -> {
        try {
            String pwd = device.executeShellCommand("run-as " + pkg + " pwd");
            if (pwd == null) {
                throw new RuntimeException("pwd failed");
            }
            pwd = pwd.trim();
            if (pwd.isEmpty()) {
                throw new RuntimeException("pwd failed");
            }
            // Give it a different name, so we do not have "contamination" from
            // the test APK.
            String libInDataData = AGENT.substring(0, AGENT.length() - ".so".length()) + "2.so";
            String agentInDataData = installLibToDataData(device, pkg, abiName, apk, pwd, AGENT, libInDataData);
            String setAgentAppCmd = "cmd activity set-agent-app " + pkg + " " + agentInDataData;
            String setAgentAppReply = device.executeShellCommand(setAgentAppCmd);
            if (setAgentAppReply != null && !setAgentAppReply.trim().isEmpty()) {
                CLog.e(setAgentAppReply);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed running set-agent-app", e);
        }
        try {
            runAttachTestCmd(device, pkg, "");
        } catch (Exception e) {
            throw new RuntimeException("Failed agent-app attaching", e);
        }
    });
}
#method_after
public void testJvmtiAgentAppExternal() throws Exception {
    runJvmtiAgentLoadTest((ITestDevice device, String pkg, String apk, String abiName) -> {
        try {
            String pwd = device.executeShellCommand("run-as " + pkg + " pwd");
            if (pwd == null) {
                throw new RuntimeException("pwd failed");
            }
            pwd = pwd.trim();
            if (pwd.isEmpty()) {
                throw new RuntimeException("pwd failed");
            }
            // Give it a different name, so we do not have "contamination" from
            // the test APK.
            String libInDataData = AGENT.substring(0, AGENT.length() - ".so".length()) + "2.so";
            String agentInDataData = installLibToDataData(device, pkg, abiName, apk, pwd, AGENT, libInDataData);
            String setAgentAppCmd = "cmd activity set-agent-app " + pkg + " " + agentInDataData;
            device.executeShellCommand(setAgentAppCmd);
        } catch (Exception e) {
            throw new RuntimeException("Failed running set-agent-app", e);
        }
        try {
            runAttachTestCmd(device, pkg, "");
            // And again.
            runAttachTestCmd(device, pkg, "");
        } catch (Exception e) {
            throw new RuntimeException("Failed agent-app attaching", e);
        }
    });
}
#end_block

#method_before
private static void runAttachTestCmd(ITestDevice device, String pkg, String agentParams) throws Exception {
    String attachCmd = "cmd activity start -S -W " + agentParams + " -n " + pkg + "/android.jvmti.JvmtiActivity";
    String attachReply = device.executeShellCommand(attachCmd);
    // work.
    if (attachReply != null && !attachReply.trim().isEmpty()) {
        CLog.e(attachReply);
    }
}
#method_after
private static void runAttachTestCmd(ITestDevice device, String pkg, String agentParams) throws Exception {
    String attachCmd = "cmd activity start -S -W " + agentParams + " -n " + pkg + "/android.jvmti.JvmtiActivity";
    // Don't try to parse the output. The test will time out anyways if this didn't
    // work.
    device.executeShellCommand(attachCmd, NullOutputReceiver.getReceiver(), 10, TimeUnit.SECONDS, 1);
}
#end_block

#method_before
private String installLibToDataData(ITestDevice device, String pkg, String abiName, String apk, String dataData, String library, String newLibName) throws Exception {
    ZipFile zf = null;
    File tmpFile = null;
    String libInTmp = null;
    try {
        String libInDataData = dataData + "/" + newLibName;
        File apkFile = mBuildHelper.getTestFile(apk);
        zf = new ZipFile(apkFile);
        String libPathInApk = "lib/" + abiName + "/" + library;
        CLog.e(libPathInApk);
        tmpFile = ZipUtil.extractFileFromZip(zf, libPathInApk);
        libInTmp = "/data/local/tmp/" + tmpFile.getName();
        if (!device.pushFile(tmpFile, libInTmp)) {
            throw new RuntimeException("Could not push library " + library + " to device");
        }
        String runAsCp = device.executeShellCommand("run-as " + pkg + " cp " + libInTmp + " " + libInDataData);
        if (runAsCp != null && !runAsCp.trim().isEmpty()) {
            throw new RuntimeException(runAsCp.trim());
        }
        String runAsChmod = device.executeShellCommand("run-as " + pkg + " chmod a+x " + libInDataData);
        if (runAsChmod != null && !runAsChmod.trim().isEmpty()) {
            throw new RuntimeException(runAsChmod.trim());
        }
        return libInDataData;
    } finally {
        FileUtil.deleteFile(tmpFile);
        ZipUtil.closeZip(zf);
        if (libInTmp != null) {
            try {
                device.executeShellCommand("rm " + libInTmp);
            } catch (Exception e) {
                CLog.e("Failed cleaning up library on device");
            }
        }
    }
}
#method_after
private String installLibToDataData(ITestDevice device, String pkg, String abiName, String apk, String dataData, String library, String newLibName) throws Exception {
    ZipFile zf = null;
    File tmpFile = null;
    String libInTmp = null;
    try {
        String libInDataData = dataData + "/" + newLibName;
        File apkFile = mBuildHelper.getTestFile(apk);
        zf = new ZipFile(apkFile);
        String libPathInApk = "lib/" + abiName + "/" + library;
        tmpFile = ZipUtil.extractFileFromZip(zf, libPathInApk);
        libInTmp = "/data/local/tmp/" + tmpFile.getName();
        if (!device.pushFile(tmpFile, libInTmp)) {
            throw new RuntimeException("Could not push library " + library + " to device");
        }
        String runAsCp = device.executeShellCommand("run-as " + pkg + " cp " + libInTmp + " " + libInDataData);
        if (runAsCp != null && !runAsCp.trim().isEmpty()) {
            throw new RuntimeException(runAsCp.trim());
        }
        String runAsChmod = device.executeShellCommand("run-as " + pkg + " chmod a+x " + libInDataData);
        if (runAsChmod != null && !runAsChmod.trim().isEmpty()) {
            throw new RuntimeException(runAsChmod.trim());
        }
        return libInDataData;
    } finally {
        FileUtil.deleteFile(tmpFile);
        ZipUtil.closeZip(zf);
        if (libInTmp != null) {
            try {
                device.executeShellCommand("rm " + libInTmp);
            } catch (Exception e) {
                CLog.e("Failed cleaning up library on device");
            }
        }
    }
}
#end_block

#method_before
int runSetAgentApp(PrintWriter pw) throws RemoteException {
    String pkg = getNextArgRequired();
    String agent = getNextArgRequired();
    mInterface.setAgentApp(pkg, agent);
    return 0;
}
#method_after
int runSetAgentApp(PrintWriter pw) throws RemoteException {
    String pkg = getNextArgRequired();
    String agent = getNextArg();
    mInterface.setAgentApp(pkg, agent);
    return 0;
}
#end_block

#method_before
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    long startTime = SystemClock.uptimeMillis();
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToImportant = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;
    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    checkTime(startTime, "attachApplicationLocked: before bindApplication");
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = ApplicationThreadConstants.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? ApplicationThreadConstants.DEBUG_WAIT : ApplicationThreadConstants.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = mBackupTarget.appInfo.uid >= FIRST_APPLICATION_UID && ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));
        }
        if (app.instr != null) {
            notifyPackageUse(app.instr.mClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + getGlobalConfiguration());
        ApplicationInfo appInfo = app.instr != null ? app.instr.mTargetInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        ProfilerInfo profilerInfo = null;
        String preBindAgent = null;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            if (mProfilerInfo != null) {
                // Send a profiler info object to the app if either a file is given, or
                // an agent should be loaded at bind-time.
                boolean needsInfo = mProfilerInfo.profileFile != null || mProfilerInfo.attachAgentDuringBind;
                profilerInfo = needsInfo ? new ProfilerInfo(mProfilerInfo) : null;
                if (mProfilerInfo.agent != null) {
                    // We need to do a debuggable check here.
                    if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                        if (!mProfilerInfo.attachAgentDuringBind) {
                            preBindAgent = mProfilerInfo.agent;
                        }
                    } else {
                        // Suppress the profiling request.
                        profilerInfo = null;
                    }
                }
            }
        } else if (app.instr != null && app.instr.mProfileFile != null) {
            profilerInfo = new ProfilerInfo(app.instr.mProfileFile, null, 0, false, false, null, false);
        }
        if (profilerInfo != null && profilerInfo.profileFd != null) {
            profilerInfo.profileFd = profilerInfo.profileFd.dup();
        }
        // We deprecated Build.SERIAL and it is not accessible to
        // apps that target the v2 security sandbox. Since access to
        // the serial is now behind a permission we push down the value.
        String buildSerial = appInfo.targetSandboxVersion < 2 ? sTheRealBuildSerial : Build.UNKNOWN;
        // instrumentation process.)
        if (mActiveInstrumentation.size() > 0 && app.instr == null) {
            for (int i = mActiveInstrumentation.size() - 1; i >= 0 && app.instr == null; i--) {
                ActiveInstrumentation aInstr = mActiveInstrumentation.get(i);
                if (!aInstr.mFinished && aInstr.mTargetInfo.uid == app.uid) {
                    if (aInstr.mTargetProcesses.length == 0) {
                        // the target instrumentation should be included.
                        if (aInstr.mTargetInfo.packageName.equals(app.info.packageName)) {
                            app.instr = aInstr;
                            aInstr.mRunningProcesses.add(app);
                        }
                    } else {
                        for (String proc : aInstr.mTargetProcesses) {
                            if (proc.equals(app.processName)) {
                                app.instr = aInstr;
                                aInstr.mRunningProcesses.add(app);
                                break;
                            }
                        }
                    }
                }
            }
        }
        // application code.
        if (preBindAgent != null) {
            thread.attachAgent(preBindAgent);
        }
        checkTime(startTime, "attachApplicationLocked: immediately before bindApplication");
        mStackSupervisor.mActivityMetricsLogger.notifyBindApplication(app);
        if (app.instr != null) {
            thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        } else {
            thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        }
        checkTime(startTime, "attachApplicationLocked: immediately after bindApplication");
        updateLruProcessLocked(app, false, null);
        checkTime(startTime, "attachApplicationLocked: after updateLruProcessLocked");
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
            checkTime(startTime, "attachApplicationLocked: after mServices.attachApplicationLocked");
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
            checkTime(startTime, "attachApplicationLocked: after sendPendingBroadcastsLocked");
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.app == app) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
        checkTime(startTime, "attachApplicationLocked: after updateOomAdjLocked");
    }
    return true;
}
#method_after
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    long startTime = SystemClock.uptimeMillis();
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToImportant = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;
    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    checkTime(startTime, "attachApplicationLocked: before bindApplication");
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = ApplicationThreadConstants.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? ApplicationThreadConstants.DEBUG_WAIT : ApplicationThreadConstants.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = mBackupTarget.appInfo.uid >= FIRST_APPLICATION_UID && ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));
        }
        if (app.instr != null) {
            notifyPackageUse(app.instr.mClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + getGlobalConfiguration());
        ApplicationInfo appInfo = app.instr != null ? app.instr.mTargetInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        ProfilerInfo profilerInfo = null;
        String preBindAgent = null;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            if (mProfilerInfo != null) {
                // Send a profiler info object to the app if either a file is given, or
                // an agent should be loaded at bind-time.
                boolean needsInfo = mProfilerInfo.profileFile != null || mProfilerInfo.attachAgentDuringBind;
                profilerInfo = needsInfo ? new ProfilerInfo(mProfilerInfo) : null;
                if (mProfilerInfo.agent != null) {
                    preBindAgent = mProfilerInfo.agent;
                }
            }
        } else if (app.instr != null && app.instr.mProfileFile != null) {
            profilerInfo = new ProfilerInfo(app.instr.mProfileFile, null, 0, false, false, null, false);
        }
        if (mAppAgentMap != null && mAppAgentMap.containsKey(processName)) {
            // postponed to here.
            if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                String agent = mAppAgentMap.get(processName);
                // Do not overwrite already requested agent.
                if (profilerInfo == null) {
                    profilerInfo = new ProfilerInfo(null, null, 0, false, false, mAppAgentMap.get(processName), true);
                } else if (profilerInfo.agent == null) {
                    profilerInfo = profilerInfo.setAgent(mAppAgentMap.get(processName), true);
                }
            }
        }
        if (profilerInfo != null && profilerInfo.profileFd != null) {
            profilerInfo.profileFd = profilerInfo.profileFd.dup();
        }
        // We deprecated Build.SERIAL and it is not accessible to
        // apps that target the v2 security sandbox. Since access to
        // the serial is now behind a permission we push down the value.
        String buildSerial = appInfo.targetSandboxVersion < 2 ? sTheRealBuildSerial : Build.UNKNOWN;
        // instrumentation process.)
        if (mActiveInstrumentation.size() > 0 && app.instr == null) {
            for (int i = mActiveInstrumentation.size() - 1; i >= 0 && app.instr == null; i--) {
                ActiveInstrumentation aInstr = mActiveInstrumentation.get(i);
                if (!aInstr.mFinished && aInstr.mTargetInfo.uid == app.uid) {
                    if (aInstr.mTargetProcesses.length == 0) {
                        // the target instrumentation should be included.
                        if (aInstr.mTargetInfo.packageName.equals(app.info.packageName)) {
                            app.instr = aInstr;
                            aInstr.mRunningProcesses.add(app);
                        }
                    } else {
                        for (String proc : aInstr.mTargetProcesses) {
                            if (proc.equals(app.processName)) {
                                app.instr = aInstr;
                                aInstr.mRunningProcesses.add(app);
                                break;
                            }
                        }
                    }
                }
            }
        }
        // application code.
        if (preBindAgent != null) {
            thread.attachAgent(preBindAgent);
        }
        checkTime(startTime, "attachApplicationLocked: immediately before bindApplication");
        mStackSupervisor.mActivityMetricsLogger.notifyBindApplication(app);
        if (app.instr != null) {
            thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        } else {
            thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        }
        checkTime(startTime, "attachApplicationLocked: immediately after bindApplication");
        updateLruProcessLocked(app, false, null);
        checkTime(startTime, "attachApplicationLocked: after updateLruProcessLocked");
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
            checkTime(startTime, "attachApplicationLocked: after mServices.attachApplicationLocked");
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
            checkTime(startTime, "attachApplicationLocked: after sendPendingBroadcastsLocked");
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.app == app) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
        checkTime(startTime, "attachApplicationLocked: after updateOomAdjLocked");
    }
    return true;
}
#end_block

#method_before
@Override
public void setAgentApp(String packageName, String agent) {
    synchronized (this) {
        // its own permission.
        if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
            throw new SecurityException("Requires permission " + android.Manifest.permission.SET_ACTIVITY_WATCHER);
        }
        // Stop any active profiling, as we have to replace the profilerInfo.
        stopProfilerLocked(null, 0);
        // We cannot check the debuggability, yet. This will be done in bindApplication
        // once the process is known.
        setProfileAppUnchecked(packageName, new ProfilerInfo(null, /* filename */
        null, /* fd */
        0, /* interval */
        false, /* autostop */
        false, /* streaming */
        agent, true));
        mProfileProc = null;
    }
}
#method_after
@Override
public void setAgentApp(@NonNull String packageName, @Nullable String agent) {
    synchronized (this) {
        // its own permission.
        if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
            throw new SecurityException("Requires permission " + android.Manifest.permission.SET_ACTIVITY_WATCHER);
        }
        if (agent == null) {
            if (mAppAgentMap != null) {
                mAppAgentMap.remove(packageName);
                if (mAppAgentMap.isEmpty()) {
                    mAppAgentMap = null;
                }
            }
        } else {
            if (mAppAgentMap == null) {
                mAppAgentMap = new HashMap<>();
            }
            if (mAppAgentMap.size() >= 100) {
                // Limit the size of the map, to avoid OOMEs.
                Slog.e(TAG, "App agent map has too many entries, cannot add " + packageName + "/" + agent);
                return;
            }
            mAppAgentMap.put(packageName, agent);
        }
    }
}
#end_block

#method_before
void setProfileApp(ApplicationInfo app, String processName, ProfilerInfo profilerInfo) {
    synchronized (this) {
        boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
        if (!isDebuggable) {
            if ((app.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
                throw new SecurityException("Process not debuggable: " + app.packageName);
            }
        }
        setProfileAppUnchecked(processName, profilerInfo);
    }
}
#method_after
void setProfileApp(ApplicationInfo app, String processName, ProfilerInfo profilerInfo) {
    synchronized (this) {
        boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
        if (!isDebuggable) {
            if ((app.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
                throw new SecurityException("Process not debuggable: " + app.packageName);
            }
        }
        mProfileApp = processName;
        if (mProfilerInfo != null) {
            if (mProfilerInfo.profileFd != null) {
                try {
                    mProfilerInfo.profileFd.close();
                } catch (IOException e) {
                }
            }
        }
        mProfilerInfo = new ProfilerInfo(profilerInfo);
        mProfileType = 0;
    }
}
#end_block

#method_before
public void timeCheckCastLevel1ToLevel1(int count) {
    for (int i = 0; i < count; ++i) {
        Level1 l1 = (Level1) o1;
    }
}
#method_after
public void timeCheckCastLevel1ToLevel1(int count) {
    Object[] arr = arr1;
    for (int i = 0; i < count; ++i) {
        Level1 l1 = (Level1) arr[i & 1023];
    }
}
#end_block

#method_before
public void timeCheckCastLevel2ToLevel1(int count) {
    for (int i = 0; i < count; ++i) {
        Level1 l1 = (Level1) o2;
    }
}
#method_after
public void timeCheckCastLevel2ToLevel1(int count) {
    Object[] arr = arr2;
    for (int i = 0; i < count; ++i) {
        Level1 l1 = (Level1) arr[i & 1023];
    }
}
#end_block

#method_before
public void timeCheckCastLevel3ToLevel1(int count) {
    for (int i = 0; i < count; ++i) {
        Level1 l1 = (Level1) o3;
    }
}
#method_after
public void timeCheckCastLevel3ToLevel1(int count) {
    Object[] arr = arr3;
    for (int i = 0; i < count; ++i) {
        Level1 l1 = (Level1) arr[i & 1023];
    }
}
#end_block

#method_before
public void timeCheckCastLevel9ToLevel1(int count) {
    for (int i = 0; i < count; ++i) {
        Level1 l1 = (Level1) o9;
    }
}
#method_after
public void timeCheckCastLevel9ToLevel1(int count) {
    Object[] arr = arr9;
    for (int i = 0; i < count; ++i) {
        Level1 l1 = (Level1) arr[i & 1023];
    }
}
#end_block

#method_before
public void timeCheckCastLevel9ToLevel2(int count) {
    for (int i = 0; i < count; ++i) {
        Level2 l2 = (Level2) o9;
    }
}
#method_after
public void timeCheckCastLevel9ToLevel2(int count) {
    Object[] arr = arr9;
    for (int i = 0; i < count; ++i) {
        Level2 l2 = (Level2) arr[i & 1023];
    }
}
#end_block

#method_before
public void timeInstanceOfLevel1ToLevel1(int count) {
    int sum = 0;
    for (int i = 0; i < count; ++i) {
        if (o1 instanceof Level1) {
            ++sum;
        }
    }
    result = sum;
}
#method_after
public void timeInstanceOfLevel1ToLevel1(int count) {
    int sum = 0;
    Object[] arr = arr1;
    for (int i = 0; i < count; ++i) {
        if (arr[i & 1023] instanceof Level1) {
            ++sum;
        }
    }
    result = sum;
}
#end_block

#method_before
public void timeInstanceOfLevel2ToLevel1(int count) {
    int sum = 0;
    for (int i = 0; i < count; ++i) {
        if (o2 instanceof Level1) {
            ++sum;
        }
    }
    result = sum;
}
#method_after
public void timeInstanceOfLevel2ToLevel1(int count) {
    int sum = 0;
    Object[] arr = arr2;
    for (int i = 0; i < count; ++i) {
        if (arr[i & 1023] instanceof Level1) {
            ++sum;
        }
    }
    result = sum;
}
#end_block

#method_before
public void timeInstanceOfLevel3ToLevel1(int count) {
    int sum = 0;
    for (int i = 0; i < count; ++i) {
        if (o3 instanceof Level1) {
            ++sum;
        }
    }
    result = sum;
}
#method_after
public void timeInstanceOfLevel3ToLevel1(int count) {
    int sum = 0;
    Object[] arr = arr3;
    for (int i = 0; i < count; ++i) {
        if (arr[i & 1023] instanceof Level1) {
            ++sum;
        }
    }
    result = sum;
}
#end_block

#method_before
public void timeInstanceOfLevel9ToLevel1(int count) {
    int sum = 0;
    for (int i = 0; i < count; ++i) {
        if (o9 instanceof Level1) {
            ++sum;
        }
    }
    result = sum;
}
#method_after
public void timeInstanceOfLevel9ToLevel1(int count) {
    int sum = 0;
    Object[] arr = arr9;
    for (int i = 0; i < count; ++i) {
        if (arr[i & 1023] instanceof Level1) {
            ++sum;
        }
    }
    result = sum;
}
#end_block

#method_before
public void timeInstanceOfLevel9ToLevel2(int count) {
    int sum = 0;
    for (int i = 0; i < count; ++i) {
        if (o9 instanceof Level2) {
            ++sum;
        }
    }
    result = sum;
}
#method_after
public void timeInstanceOfLevel9ToLevel2(int count) {
    int sum = 0;
    Object[] arr = arr9;
    for (int i = 0; i < count; ++i) {
        if (arr[i & 1023] instanceof Level2) {
            ++sum;
        }
    }
    result = sum;
}
#end_block

#method_before
@Override
public void getIccSlotsStatus(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        android.hardware.radio.V1_2.IRadio radioProxy12 = android.hardware.radio.V1_2.IRadio.castFrom(radioProxy);
        if (radioProxy12 == null) {
            if (result != null) {
                AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
                result.sendToTarget();
            }
        } else {
            RILRequest rr = obtainRequest(RIL_REQUEST_GET_SLOT_STATUS, result, mRILDefaultWorkSource);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
            }
            try {
                radioProxy12.getSimSlotsStatus(rr.mSerial);
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "getIccSlotStatus", e);
            }
        }
    }
}
#method_after
@Override
public void getIccSlotsStatus(Message result) {
    if (result != null) {
        AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
        result.sendToTarget();
    }
}
#end_block

#method_before
@Override
public void setLogicalToPhysicalSlotMapping(int[] physicalSlots, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        android.hardware.radio.V1_2.IRadio radioProxy12 = android.hardware.radio.V1_2.IRadio.castFrom(radioProxy);
        if (radioProxy12 == null) {
            if (result != null) {
                AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
                result.sendToTarget();
            }
        } else {
            ArrayList<Integer> mapping = new ArrayList<>();
            for (int slot : physicalSlots) {
                mapping.add(new Integer(slot));
            }
            RILRequest rr = obtainRequest(RIL_REQUEST_SET_LOGICAL_TO_PHYSICAL_SLOT_MAPPING, result, mRILDefaultWorkSource);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
            }
            try {
                radioProxy12.setSimSlotsMapping(rr.mSerial, mapping);
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "setLogicalToPhysicalSlotMapping", e);
            }
        }
    }
}
#method_after
@Override
public void setLogicalToPhysicalSlotMapping(int[] physicalSlots, Message result) {
    if (result != null) {
        AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
        result.sendToTarget();
    }
}
#end_block

#method_before
static DataCallResponse convertDataCallResult(SetupDataCallResult dcResult) {
    // Process address
    String[] addresses = null;
    if (!TextUtils.isEmpty(dcResult.addresses)) {
        addresses = dcResult.addresses.split(" ");
    }
    List<LinkAddress> laList = new ArrayList<>();
    if (addresses != null) {
        for (String address : addresses) {
            address = address.trim();
            if (address.isEmpty())
                continue;
            try {
                LinkAddress la = new LinkAddress(address);
                laList.add(la);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown address: " + address + ", exception = " + e);
            }
        }
    }
    // Process dns
    String[] dnses = null;
    if (!TextUtils.isEmpty(dcResult.dnses)) {
        dnses = dcResult.dnses.split(" ");
    }
    List<InetAddress> dnsList = new ArrayList<>();
    if (dnses != null) {
        for (String dns : dnses) {
            dns = dns.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(dns);
                dnsList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown dns: " + dns + ", exception = " + e);
            }
        }
    }
    // Process gateway
    String[] gateways = null;
    if (!TextUtils.isEmpty(dcResult.gateways)) {
        gateways = dcResult.gateways.split(" ");
    }
    List<InetAddress> gatewayList = new ArrayList<>();
    if (gateways != null) {
        for (String gateway : gateways) {
            gateway = gateway.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(gateway);
                gatewayList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown gateway: " + gateway + ", exception = " + e);
            }
        }
    }
    return new DataCallResponse(dcResult.status, dcResult.suggestedRetryTime, dcResult.cid, dcResult.active, dcResult.type, dcResult.ifname, laList, dnsList, gatewayList, new ArrayList<>(Arrays.asList(dcResult.pcscf.trim().split("\\s*,\\s*"))), dcResult.mtu);
}
#method_after
static DataCallResponse convertDataCallResult(SetupDataCallResult dcResult) {
    // Process address
    String[] addresses = null;
    if (!TextUtils.isEmpty(dcResult.addresses)) {
        addresses = dcResult.addresses.split("\\s+");
    }
    List<LinkAddress> laList = new ArrayList<>();
    if (addresses != null) {
        for (String address : addresses) {
            address = address.trim();
            if (address.isEmpty())
                continue;
            try {
                LinkAddress la;
                // can parse that.
                if (address.split("/").length == 2) {
                    la = new LinkAddress(address);
                } else {
                    InetAddress ia = NetworkUtils.numericToInetAddress(address);
                    la = new LinkAddress(ia, (ia instanceof Inet4Address) ? 32 : 128);
                }
                laList.add(la);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown address: " + address + ", " + e);
            }
        }
    }
    // Process dns
    String[] dnses = null;
    if (!TextUtils.isEmpty(dcResult.dnses)) {
        dnses = dcResult.dnses.split("\\s+");
    }
    List<InetAddress> dnsList = new ArrayList<>();
    if (dnses != null) {
        for (String dns : dnses) {
            dns = dns.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(dns);
                dnsList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown dns: " + dns + ", exception = " + e);
            }
        }
    }
    // Process gateway
    String[] gateways = null;
    if (!TextUtils.isEmpty(dcResult.gateways)) {
        gateways = dcResult.gateways.split("\\s+");
    }
    List<InetAddress> gatewayList = new ArrayList<>();
    if (gateways != null) {
        for (String gateway : gateways) {
            gateway = gateway.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(gateway);
                gatewayList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown gateway: " + gateway + ", exception = " + e);
            }
        }
    }
    return new DataCallResponse(dcResult.status, dcResult.suggestedRetryTime, dcResult.cid, dcResult.active, dcResult.type, dcResult.ifname, laList, dnsList, gatewayList, new ArrayList<>(Arrays.asList(dcResult.pcscf.trim().split("\\s+"))), dcResult.mtu);
}
#end_block

#method_before
@VisibleForTesting
public static ArrayList<CellInfo> convertHalCellInfoList(ArrayList<android.hardware.radio.V1_0.CellInfo> records) {
    ArrayList<CellInfo> response = new ArrayList<CellInfo>(records.size());
    for (android.hardware.radio.V1_0.CellInfo record : records) {
        // first convert RIL CellInfo to Parcel
        Parcel p = Parcel.obtain();
        p.writeInt(record.cellInfoType);
        p.writeInt(record.registered ? 1 : 0);
        p.writeInt(record.timeStampType);
        p.writeLong(record.timeStamp);
        p.writeInt(CellInfo.CONNECTION_UNSUPPORTED);
        switch(record.cellInfoType) {
            case CellInfoType.GSM:
                {
                    CellInfoGsm cellInfoGsm = record.gsm.get(0);
                    writeToParcelForGsm(p, cellInfoGsm.cellIdentityGsm.lac, cellInfoGsm.cellIdentityGsm.cid, cellInfoGsm.cellIdentityGsm.arfcn, Byte.toUnsignedInt(cellInfoGsm.cellIdentityGsm.bsic), cellInfoGsm.cellIdentityGsm.mcc, cellInfoGsm.cellIdentityGsm.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoGsm.signalStrengthGsm.signalStrength, cellInfoGsm.signalStrengthGsm.bitErrorRate, cellInfoGsm.signalStrengthGsm.timingAdvance);
                    break;
                }
            case CellInfoType.CDMA:
                {
                    CellInfoCdma cellInfoCdma = record.cdma.get(0);
                    writeToParcelForCdma(p, cellInfoCdma.cellIdentityCdma.networkId, cellInfoCdma.cellIdentityCdma.systemId, cellInfoCdma.cellIdentityCdma.baseStationId, cellInfoCdma.cellIdentityCdma.longitude, cellInfoCdma.cellIdentityCdma.latitude, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoCdma.signalStrengthCdma.dbm, cellInfoCdma.signalStrengthCdma.ecio, cellInfoCdma.signalStrengthEvdo.dbm, cellInfoCdma.signalStrengthEvdo.ecio, cellInfoCdma.signalStrengthEvdo.signalNoiseRatio);
                    break;
                }
            case CellInfoType.LTE:
                {
                    CellInfoLte cellInfoLte = record.lte.get(0);
                    writeToParcelForLte(p, cellInfoLte.cellIdentityLte.ci, cellInfoLte.cellIdentityLte.pci, cellInfoLte.cellIdentityLte.tac, cellInfoLte.cellIdentityLte.earfcn, Integer.MAX_VALUE, cellInfoLte.cellIdentityLte.mcc, cellInfoLte.cellIdentityLte.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoLte.signalStrengthLte.signalStrength, cellInfoLte.signalStrengthLte.rsrp, cellInfoLte.signalStrengthLte.rsrq, cellInfoLte.signalStrengthLte.rssnr, cellInfoLte.signalStrengthLte.cqi, cellInfoLte.signalStrengthLte.timingAdvance);
                    break;
                }
            case CellInfoType.WCDMA:
                {
                    CellInfoWcdma cellInfoWcdma = record.wcdma.get(0);
                    writeToParcelForWcdma(p, cellInfoWcdma.cellIdentityWcdma.lac, cellInfoWcdma.cellIdentityWcdma.cid, cellInfoWcdma.cellIdentityWcdma.psc, cellInfoWcdma.cellIdentityWcdma.uarfcn, cellInfoWcdma.cellIdentityWcdma.mcc, cellInfoWcdma.cellIdentityWcdma.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoWcdma.signalStrengthWcdma.signalStrength, cellInfoWcdma.signalStrengthWcdma.bitErrorRate);
                    break;
                }
            default:
                throw new RuntimeException("unexpected cellinfotype: " + record.cellInfoType);
        }
        p.setDataPosition(0);
        CellInfo InfoRec = CellInfo.CREATOR.createFromParcel(p);
        p.recycle();
        response.add(InfoRec);
    }
    return response;
}
#method_after
@VisibleForTesting
public static ArrayList<CellInfo> convertHalCellInfoList(ArrayList<android.hardware.radio.V1_0.CellInfo> records) {
    ArrayList<CellInfo> response = new ArrayList<CellInfo>(records.size());
    for (android.hardware.radio.V1_0.CellInfo record : records) {
        // first convert RIL CellInfo to Parcel
        Parcel p = Parcel.obtain();
        p.writeInt(record.cellInfoType);
        p.writeInt(record.registered ? 1 : 0);
        p.writeInt(record.timeStampType);
        p.writeLong(record.timeStamp);
        p.writeInt(CellInfo.CONNECTION_UNKNOWN);
        switch(record.cellInfoType) {
            case CellInfoType.GSM:
                {
                    CellInfoGsm cellInfoGsm = record.gsm.get(0);
                    writeToParcelForGsm(p, cellInfoGsm.cellIdentityGsm.lac, cellInfoGsm.cellIdentityGsm.cid, cellInfoGsm.cellIdentityGsm.arfcn, Byte.toUnsignedInt(cellInfoGsm.cellIdentityGsm.bsic), cellInfoGsm.cellIdentityGsm.mcc, cellInfoGsm.cellIdentityGsm.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoGsm.signalStrengthGsm.signalStrength, cellInfoGsm.signalStrengthGsm.bitErrorRate, cellInfoGsm.signalStrengthGsm.timingAdvance);
                    break;
                }
            case CellInfoType.CDMA:
                {
                    CellInfoCdma cellInfoCdma = record.cdma.get(0);
                    writeToParcelForCdma(p, cellInfoCdma.cellIdentityCdma.networkId, cellInfoCdma.cellIdentityCdma.systemId, cellInfoCdma.cellIdentityCdma.baseStationId, cellInfoCdma.cellIdentityCdma.longitude, cellInfoCdma.cellIdentityCdma.latitude, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoCdma.signalStrengthCdma.dbm, cellInfoCdma.signalStrengthCdma.ecio, cellInfoCdma.signalStrengthEvdo.dbm, cellInfoCdma.signalStrengthEvdo.ecio, cellInfoCdma.signalStrengthEvdo.signalNoiseRatio);
                    break;
                }
            case CellInfoType.LTE:
                {
                    CellInfoLte cellInfoLte = record.lte.get(0);
                    writeToParcelForLte(p, cellInfoLte.cellIdentityLte.ci, cellInfoLte.cellIdentityLte.pci, cellInfoLte.cellIdentityLte.tac, cellInfoLte.cellIdentityLte.earfcn, Integer.MAX_VALUE, cellInfoLte.cellIdentityLte.mcc, cellInfoLte.cellIdentityLte.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoLte.signalStrengthLte.signalStrength, cellInfoLte.signalStrengthLte.rsrp, cellInfoLte.signalStrengthLte.rsrq, cellInfoLte.signalStrengthLte.rssnr, cellInfoLte.signalStrengthLte.cqi, cellInfoLte.signalStrengthLte.timingAdvance);
                    break;
                }
            case CellInfoType.WCDMA:
                {
                    CellInfoWcdma cellInfoWcdma = record.wcdma.get(0);
                    writeToParcelForWcdma(p, cellInfoWcdma.cellIdentityWcdma.lac, cellInfoWcdma.cellIdentityWcdma.cid, cellInfoWcdma.cellIdentityWcdma.psc, cellInfoWcdma.cellIdentityWcdma.uarfcn, cellInfoWcdma.cellIdentityWcdma.mcc, cellInfoWcdma.cellIdentityWcdma.mnc, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT, cellInfoWcdma.signalStrengthWcdma.signalStrength, cellInfoWcdma.signalStrengthWcdma.bitErrorRate);
                    break;
                }
            default:
                throw new RuntimeException("unexpected cellinfotype: " + record.cellInfoType);
        }
        p.setDataPosition(0);
        CellInfo InfoRec = CellInfo.CREATOR.createFromParcel(p);
        p.recycle();
        response.add(InfoRec);
    }
    return response;
}
#end_block

#method_before
static SignalStrength convertHalSignalStrength(android.hardware.radio.V1_0.SignalStrength signalStrength) {
    return new SignalStrength(signalStrength.gw.signalStrength, signalStrength.gw.bitErrorRate, signalStrength.cdma.dbm, signalStrength.cdma.ecio, signalStrength.evdo.dbm, signalStrength.evdo.ecio, signalStrength.evdo.signalNoiseRatio, signalStrength.lte.signalStrength, signalStrength.lte.rsrp, signalStrength.lte.rsrq, signalStrength.lte.rssnr, signalStrength.lte.cqi, signalStrength.tdScdma.rscp, false);
}
#method_after
static SignalStrength convertHalSignalStrength(android.hardware.radio.V1_0.SignalStrength signalStrength) {
    return new SignalStrength(signalStrength.gw.signalStrength, signalStrength.gw.bitErrorRate, signalStrength.cdma.dbm, signalStrength.cdma.ecio, signalStrength.evdo.dbm, signalStrength.evdo.ecio, signalStrength.evdo.signalNoiseRatio, signalStrength.lte.signalStrength, signalStrength.lte.rsrp, signalStrength.lte.rsrq, signalStrength.lte.rssnr, signalStrength.lte.cqi, signalStrength.tdScdma.rscp);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoListForLTE() throws Exception {
    android.hardware.radio.V1_0.CellInfoLte lte = new android.hardware.radio.V1_0.CellInfoLte();
    lte.cellIdentityLte.ci = CI;
    lte.cellIdentityLte.pci = PCI;
    lte.cellIdentityLte.tac = TAC;
    lte.cellIdentityLte.earfcn = EARFCN;
    lte.cellIdentityLte.mcc = MCC_STR;
    lte.cellIdentityLte.mnc = MNC_STR;
    lte.signalStrengthLte.signalStrength = SIGNAL_STRENGTH;
    lte.signalStrengthLte.rsrp = RSRP;
    lte.signalStrengthLte.rsrq = RSRQ;
    lte.signalStrengthLte.rssnr = RSSNR;
    lte.signalStrengthLte.cqi = CQI;
    lte.signalStrengthLte.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_LTE;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.lte.add(lte);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, Integer.MAX_VALUE, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    assertEquals(expected, cellInfoLte);
}
#method_after
@Test
public void testConvertHalCellInfoListForLTE() throws Exception {
    android.hardware.radio.V1_0.CellInfoLte lte = new android.hardware.radio.V1_0.CellInfoLte();
    lte.cellIdentityLte.ci = CI;
    lte.cellIdentityLte.pci = PCI;
    lte.cellIdentityLte.tac = TAC;
    lte.cellIdentityLte.earfcn = EARFCN;
    lte.cellIdentityLte.mcc = MCC_STR;
    lte.cellIdentityLte.mnc = MNC_STR;
    lte.signalStrengthLte.signalStrength = SIGNAL_STRENGTH;
    lte.signalStrengthLte.rsrp = RSRP;
    lte.signalStrengthLte.rsrq = RSRQ;
    lte.signalStrengthLte.rssnr = RSSNR;
    lte.signalStrengthLte.cqi = CQI;
    lte.signalStrengthLte.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_LTE;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.lte.add(lte);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, Integer.MAX_VALUE, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    assertEquals(expected, cellInfoLte);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoListForGSM() throws Exception {
    android.hardware.radio.V1_0.CellInfoGsm cellinfo = new android.hardware.radio.V1_0.CellInfoGsm();
    cellinfo.cellIdentityGsm.lac = LAC;
    cellinfo.cellIdentityGsm.cid = CID;
    cellinfo.cellIdentityGsm.bsic = BSIC;
    cellinfo.cellIdentityGsm.arfcn = ARFCN;
    cellinfo.cellIdentityGsm.mcc = MCC_STR;
    cellinfo.cellIdentityGsm.mnc = MNC_STR;
    cellinfo.signalStrengthGsm.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthGsm.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_GSM;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.gsm.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm();
    cs.initialize(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoGsm);
}
#method_after
@Test
public void testConvertHalCellInfoListForGSM() throws Exception {
    android.hardware.radio.V1_0.CellInfoGsm cellinfo = new android.hardware.radio.V1_0.CellInfoGsm();
    cellinfo.cellIdentityGsm.lac = LAC;
    cellinfo.cellIdentityGsm.cid = CID;
    cellinfo.cellIdentityGsm.bsic = BSIC;
    cellinfo.cellIdentityGsm.arfcn = ARFCN;
    cellinfo.cellIdentityGsm.mcc = MCC_STR;
    cellinfo.cellIdentityGsm.mnc = MNC_STR;
    cellinfo.signalStrengthGsm.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthGsm.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_GSM;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.gsm.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm();
    cs.initialize(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    assertEquals(expected, cellInfoGsm);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoListForWcdma() throws Exception {
    android.hardware.radio.V1_0.CellInfoWcdma cellinfo = new android.hardware.radio.V1_0.CellInfoWcdma();
    cellinfo.cellIdentityWcdma.lac = LAC;
    cellinfo.cellIdentityWcdma.cid = CID;
    cellinfo.cellIdentityWcdma.psc = PSC;
    cellinfo.cellIdentityWcdma.uarfcn = UARFCN;
    cellinfo.cellIdentityWcdma.mcc = MCC_STR;
    cellinfo.cellIdentityWcdma.mnc = MNC_STR;
    cellinfo.signalStrengthWcdma.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthWcdma.bitErrorRate = BIT_ERROR_RATE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_WCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.wcdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoWcdma);
}
#method_after
@Test
public void testConvertHalCellInfoListForWcdma() throws Exception {
    android.hardware.radio.V1_0.CellInfoWcdma cellinfo = new android.hardware.radio.V1_0.CellInfoWcdma();
    cellinfo.cellIdentityWcdma.lac = LAC;
    cellinfo.cellIdentityWcdma.cid = CID;
    cellinfo.cellIdentityWcdma.psc = PSC;
    cellinfo.cellIdentityWcdma.uarfcn = UARFCN;
    cellinfo.cellIdentityWcdma.mcc = MCC_STR;
    cellinfo.cellIdentityWcdma.mnc = MNC_STR;
    cellinfo.signalStrengthWcdma.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthWcdma.bitErrorRate = BIT_ERROR_RATE;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_WCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.wcdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    assertEquals(expected, cellInfoWcdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoListForCdma() throws Exception {
    android.hardware.radio.V1_0.CellInfoCdma cellinfo = new android.hardware.radio.V1_0.CellInfoCdma();
    cellinfo.cellIdentityCdma.networkId = NETWORK_ID;
    cellinfo.cellIdentityCdma.systemId = SYSTEM_ID;
    cellinfo.cellIdentityCdma.baseStationId = BASESTATION_ID;
    cellinfo.cellIdentityCdma.longitude = LONGITUDE;
    cellinfo.cellIdentityCdma.latitude = LATITUDE;
    cellinfo.signalStrengthCdma.dbm = DBM;
    cellinfo.signalStrengthCdma.ecio = ECIO;
    cellinfo.signalStrengthEvdo.dbm = DBM;
    cellinfo.signalStrengthEvdo.ecio = ECIO;
    cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOICE_RATIO;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_CDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.cdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
    CellInfoCdma expected = new CellInfoCdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityCdma ci = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthCdma cs = new CellSignalStrengthCdma(-DBM, -ECIO, -DBM, -ECIO, SIGNAL_NOICE_RATIO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoCdma);
}
#method_after
@Test
public void testConvertHalCellInfoListForCdma() throws Exception {
    android.hardware.radio.V1_0.CellInfoCdma cellinfo = new android.hardware.radio.V1_0.CellInfoCdma();
    cellinfo.cellIdentityCdma.networkId = NETWORK_ID;
    cellinfo.cellIdentityCdma.systemId = SYSTEM_ID;
    cellinfo.cellIdentityCdma.baseStationId = BASESTATION_ID;
    cellinfo.cellIdentityCdma.longitude = LONGITUDE;
    cellinfo.cellIdentityCdma.latitude = LATITUDE;
    cellinfo.signalStrengthCdma.dbm = DBM;
    cellinfo.signalStrengthCdma.ecio = ECIO;
    cellinfo.signalStrengthEvdo.dbm = DBM;
    cellinfo.signalStrengthEvdo.ecio = ECIO;
    cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOICE_RATIO;
    android.hardware.radio.V1_0.CellInfo record = new android.hardware.radio.V1_0.CellInfo();
    record.cellInfoType = TYPE_CDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.cdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_0.CellInfo> records = new ArrayList<android.hardware.radio.V1_0.CellInfo>();
    records.add(record);
    ArrayList<CellInfo> ret = RIL.convertHalCellInfoList(records);
    assertEquals(1, ret.size());
    CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
    CellInfoCdma expected = new CellInfoCdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityCdma ci = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthCdma cs = new CellSignalStrengthCdma(-DBM, -ECIO, -DBM, -ECIO, SIGNAL_NOICE_RATIO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_UNKNOWN);
    assertEquals(expected, cellInfoCdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForLTE() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForLTE(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    assertEquals(expected, cellInfoLte);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForLTE() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForLTE(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoLte);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2_ForLTEWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForLTE(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    assertEquals(expected, cellInfoLte);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2_ForLTEWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForLTE(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoLte);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForLTEWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForLTE(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    assertEquals(expected, cellInfoLte);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForLTEWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForLTE(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoLte cellInfoLte = (CellInfoLte) ret.get(0);
    CellInfoLte expected = new CellInfoLte();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityLte cil = new CellIdentityLte(CI, PCI, TAC, EARFCN, BANDWIDTH, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthLte css = new CellSignalStrengthLte(SIGNAL_STRENGTH, -RSRP, -RSRQ, RSSNR, CQI, TIME_ADVANCE);
    expected.setCellIdentity(cil);
    expected.setCellSignalStrength(css);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoLte);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForGSM() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForGSM(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm();
    cs.initialize(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoGsm);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForGSM() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForGSM(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm();
    cs.initialize(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoGsm);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForGSMWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForGSM(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm();
    cs.initialize(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoGsm);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForGSMWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForGSM(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm();
    cs.initialize(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoGsm);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForGSMWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForGSM(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm();
    cs.initialize(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoGsm);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForGSMWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForGSM(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoGsm cellInfoGsm = (CellInfoGsm) ret.get(0);
    CellInfoGsm expected = new CellInfoGsm();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityGsm ci = new CellIdentityGsm(LAC, CID, ARFCN, BSIC, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthGsm cs = new CellSignalStrengthGsm();
    cs.initialize(SIGNAL_STRENGTH, BIT_ERROR_RATE, TIME_ADVANCE);
    expected.setCellIdentity(ci);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoGsm);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForWcdma() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoWcdma);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForWcdma() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoWcdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoWcdma);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyOperatorInfo() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, MCC_STR, MNC_STR, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoWcdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoWcdma);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForWcdmaWithEmptyMccMnc() throws Exception {
    // MCC/MNC will be set as INT_MAX if unknown
    ArrayList<CellInfo> ret = getCellInfoListForWcdma(String.valueOf(Integer.MAX_VALUE), String.valueOf(Integer.MAX_VALUE), ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ret.get(0);
    CellInfoWcdma expected = new CellInfoWcdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityWcdma ci = new CellIdentityWcdma(LAC, CID, PSC, UARFCN, null, null, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthWcdma cs = new CellSignalStrengthWcdma(SIGNAL_STRENGTH, BIT_ERROR_RATE);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoWcdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForCdma() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForCdma(ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
    CellInfoCdma expected = new CellInfoCdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityCdma ci = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthCdma cs = new CellSignalStrengthCdma(-DBM, -ECIO, -DBM, -ECIO, SIGNAL_NOICE_RATIO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoCdma);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForCdma() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForCdma(ALPHA_LONG, ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
    CellInfoCdma expected = new CellInfoCdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityCdma ci = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE, ALPHA_LONG, ALPHA_SHORT);
    CellSignalStrengthCdma cs = new CellSignalStrengthCdma(-DBM, -ECIO, -DBM, -ECIO, SIGNAL_NOICE_RATIO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoCdma);
}
#end_block

#method_before
@Test
public void testConvertHalCellInfoList_1_2ForCdmaWithEmptyOperatorInfd() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForCdma(EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
    CellInfoCdma expected = new CellInfoCdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityCdma ci = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthCdma cs = new CellSignalStrengthCdma(-DBM, -ECIO, -DBM, -ECIO, SIGNAL_NOICE_RATIO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    assertEquals(expected, cellInfoCdma);
}
#method_after
@Test
public void testConvertHalCellInfoList_1_2ForCdmaWithEmptyOperatorInfd() throws Exception {
    ArrayList<CellInfo> ret = getCellInfoListForCdma(EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    assertEquals(1, ret.size());
    CellInfoCdma cellInfoCdma = (CellInfoCdma) ret.get(0);
    CellInfoCdma expected = new CellInfoCdma();
    expected.setRegistered(false);
    expected.setTimeStamp(TIMESTAMP);
    expected.setTimeStampType(RIL_TIMESTAMP_TYPE_OEM_RIL);
    CellIdentityCdma ci = new CellIdentityCdma(NETWORK_ID, SYSTEM_ID, BASESTATION_ID, LONGITUDE, LATITUDE, EMPTY_ALPHA_LONG, EMPTY_ALPHA_SHORT);
    CellSignalStrengthCdma cs = new CellSignalStrengthCdma(-DBM, -ECIO, -DBM, -ECIO, SIGNAL_NOICE_RATIO);
    expected.setCellIdentity(ci);
    expected.setCellSignalStrength(cs);
    expected.setCellConnectionStatus(CellInfo.CONNECTION_NONE);
    assertEquals(expected, cellInfoCdma);
}
#end_block

#method_before
private ArrayList<CellInfo> getCellInfoListForLTE(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoLte lte = new android.hardware.radio.V1_2.CellInfoLte();
    lte.cellIdentityLte.base.ci = CI;
    lte.cellIdentityLte.base.pci = PCI;
    lte.cellIdentityLte.base.tac = TAC;
    lte.cellIdentityLte.base.earfcn = EARFCN;
    lte.cellIdentityLte.base.mcc = mcc;
    lte.cellIdentityLte.base.mnc = mnc;
    lte.cellIdentityLte.operatorNames.alphaLong = alphaLong;
    lte.cellIdentityLte.operatorNames.alphaShort = alphaShort;
    lte.signalStrengthLte.signalStrength = SIGNAL_STRENGTH;
    lte.signalStrengthLte.rsrp = RSRP;
    lte.signalStrengthLte.rsrq = RSRQ;
    lte.signalStrengthLte.rssnr = RSSNR;
    lte.signalStrengthLte.cqi = CQI;
    lte.signalStrengthLte.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_LTE;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.lte.add(lte);
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#method_after
private ArrayList<CellInfo> getCellInfoListForLTE(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoLte lte = new android.hardware.radio.V1_2.CellInfoLte();
    lte.cellIdentityLte.base.ci = CI;
    lte.cellIdentityLte.base.pci = PCI;
    lte.cellIdentityLte.base.tac = TAC;
    lte.cellIdentityLte.base.earfcn = EARFCN;
    lte.cellIdentityLte.bandwidth = BANDWIDTH;
    lte.cellIdentityLte.base.mcc = mcc;
    lte.cellIdentityLte.base.mnc = mnc;
    lte.cellIdentityLte.operatorNames.alphaLong = alphaLong;
    lte.cellIdentityLte.operatorNames.alphaShort = alphaShort;
    lte.signalStrengthLte.signalStrength = SIGNAL_STRENGTH;
    lte.signalStrengthLte.rsrp = RSRP;
    lte.signalStrengthLte.rsrq = RSRQ;
    lte.signalStrengthLte.rssnr = RSSNR;
    lte.signalStrengthLte.cqi = CQI;
    lte.signalStrengthLte.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_LTE;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.lte.add(lte);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#end_block

#method_before
private ArrayList<CellInfo> getCellInfoListForGSM(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoGsm cellinfo = new android.hardware.radio.V1_2.CellInfoGsm();
    cellinfo.cellIdentityGsm.base.lac = LAC;
    cellinfo.cellIdentityGsm.base.cid = CID;
    cellinfo.cellIdentityGsm.base.bsic = BSIC;
    cellinfo.cellIdentityGsm.base.arfcn = ARFCN;
    cellinfo.cellIdentityGsm.base.mcc = mcc;
    cellinfo.cellIdentityGsm.base.mnc = mnc;
    cellinfo.cellIdentityGsm.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityGsm.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthGsm.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthGsm.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_GSM;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.gsm.add(cellinfo);
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#method_after
private ArrayList<CellInfo> getCellInfoListForGSM(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoGsm cellinfo = new android.hardware.radio.V1_2.CellInfoGsm();
    cellinfo.cellIdentityGsm.base.lac = LAC;
    cellinfo.cellIdentityGsm.base.cid = CID;
    cellinfo.cellIdentityGsm.base.bsic = BSIC;
    cellinfo.cellIdentityGsm.base.arfcn = ARFCN;
    cellinfo.cellIdentityGsm.base.mcc = mcc;
    cellinfo.cellIdentityGsm.base.mnc = mnc;
    cellinfo.cellIdentityGsm.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityGsm.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthGsm.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthGsm.bitErrorRate = BIT_ERROR_RATE;
    cellinfo.signalStrengthGsm.timingAdvance = TIME_ADVANCE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_GSM;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.gsm.add(cellinfo);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#end_block

#method_before
private ArrayList<CellInfo> getCellInfoListForWcdma(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoWcdma cellinfo = new android.hardware.radio.V1_2.CellInfoWcdma();
    cellinfo.cellIdentityWcdma.base.lac = LAC;
    cellinfo.cellIdentityWcdma.base.cid = CID;
    cellinfo.cellIdentityWcdma.base.psc = PSC;
    cellinfo.cellIdentityWcdma.base.uarfcn = UARFCN;
    cellinfo.cellIdentityWcdma.base.mcc = mcc;
    cellinfo.cellIdentityWcdma.base.mnc = mnc;
    cellinfo.cellIdentityWcdma.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityWcdma.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthWcdma.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthWcdma.bitErrorRate = BIT_ERROR_RATE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_WCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.wcdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#method_after
private ArrayList<CellInfo> getCellInfoListForWcdma(String mcc, String mnc, String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoWcdma cellinfo = new android.hardware.radio.V1_2.CellInfoWcdma();
    cellinfo.cellIdentityWcdma.base.lac = LAC;
    cellinfo.cellIdentityWcdma.base.cid = CID;
    cellinfo.cellIdentityWcdma.base.psc = PSC;
    cellinfo.cellIdentityWcdma.base.uarfcn = UARFCN;
    cellinfo.cellIdentityWcdma.base.mcc = mcc;
    cellinfo.cellIdentityWcdma.base.mnc = mnc;
    cellinfo.cellIdentityWcdma.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityWcdma.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthWcdma.signalStrength = SIGNAL_STRENGTH;
    cellinfo.signalStrengthWcdma.bitErrorRate = BIT_ERROR_RATE;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_WCDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.wcdma.add(cellinfo);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#end_block

#method_before
private ArrayList<CellInfo> getCellInfoListForCdma(String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoCdma cellinfo = new android.hardware.radio.V1_2.CellInfoCdma();
    cellinfo.cellIdentityCdma.base.networkId = NETWORK_ID;
    cellinfo.cellIdentityCdma.base.systemId = SYSTEM_ID;
    cellinfo.cellIdentityCdma.base.baseStationId = BASESTATION_ID;
    cellinfo.cellIdentityCdma.base.longitude = LONGITUDE;
    cellinfo.cellIdentityCdma.base.latitude = LATITUDE;
    cellinfo.cellIdentityCdma.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityCdma.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthCdma.dbm = DBM;
    cellinfo.signalStrengthCdma.ecio = ECIO;
    cellinfo.signalStrengthEvdo.dbm = DBM;
    cellinfo.signalStrengthEvdo.ecio = ECIO;
    cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOICE_RATIO;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_CDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.cdma.add(cellinfo);
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#method_after
private ArrayList<CellInfo> getCellInfoListForCdma(String alphaLong, String alphaShort) {
    android.hardware.radio.V1_2.CellInfoCdma cellinfo = new android.hardware.radio.V1_2.CellInfoCdma();
    cellinfo.cellIdentityCdma.base.networkId = NETWORK_ID;
    cellinfo.cellIdentityCdma.base.systemId = SYSTEM_ID;
    cellinfo.cellIdentityCdma.base.baseStationId = BASESTATION_ID;
    cellinfo.cellIdentityCdma.base.longitude = LONGITUDE;
    cellinfo.cellIdentityCdma.base.latitude = LATITUDE;
    cellinfo.cellIdentityCdma.operatorNames.alphaLong = alphaLong;
    cellinfo.cellIdentityCdma.operatorNames.alphaShort = alphaShort;
    cellinfo.signalStrengthCdma.dbm = DBM;
    cellinfo.signalStrengthCdma.ecio = ECIO;
    cellinfo.signalStrengthEvdo.dbm = DBM;
    cellinfo.signalStrengthEvdo.ecio = ECIO;
    cellinfo.signalStrengthEvdo.signalNoiseRatio = SIGNAL_NOICE_RATIO;
    android.hardware.radio.V1_2.CellInfo record = new android.hardware.radio.V1_2.CellInfo();
    record.cellInfoType = TYPE_CDMA;
    record.registered = false;
    record.timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
    record.timeStamp = TIMESTAMP;
    record.cdma.add(cellinfo);
    record.connectionStatus = 0;
    ArrayList<android.hardware.radio.V1_2.CellInfo> records = new ArrayList<android.hardware.radio.V1_2.CellInfo>();
    records.add(record);
    return RIL.convertHalCellInfoList_1_2(records);
}
#end_block

#method_before
public int getCellConnectionStatus() {
    return mCellConnectionStatus;
}
#method_after
@CellConnectionStatus
public int getCellConnectionStatus() {
    return mCellConnectionStatus;
}
#end_block

#method_before
public void setCellConnectionStatus(int cellConnectionStatus) {
    mCellConnectionStatus = cellConnectionStatus;
}
#method_after
public void setCellConnectionStatus(@CellConnectionStatus int cellConnectionStatus) {
    mCellConnectionStatus = cellConnectionStatus;
}
#end_block

#method_before
@Override
public int hashCode() {
    int primeNum = 31;
    return ((mRegistered ? 0 : 1) * primeNum) + ((int) (mTimeStamp / 1000) * primeNum) + (mTimeStampType * primeNum);
}
#method_after
@Override
public int hashCode() {
    int primeNum = 31;
    return ((mRegistered ? 0 : 1) * primeNum) + ((int) (mTimeStamp / 1000) * primeNum) + (mTimeStampType * primeNum) + (mCellConnectionStatus * primeNum);
}
#end_block

#method_before
@Override
public boolean equals(Object other) {
    if (other == null) {
        return false;
    }
    if (this == other) {
        return true;
    }
    try {
        CellInfo o = (CellInfo) other;
        return mRegistered == o.mRegistered && mTimeStamp == o.mTimeStamp && mTimeStampType == o.mTimeStampType;
    } catch (ClassCastException e) {
        return false;
    }
}
#method_after
@Override
public boolean equals(Object other) {
    if (other == null) {
        return false;
    }
    if (this == other) {
        return true;
    }
    try {
        CellInfo o = (CellInfo) other;
        return mRegistered == o.mRegistered && mTimeStamp == o.mTimeStamp && mTimeStampType == o.mTimeStampType && mCellConnectionStatus == o.mCellConnectionStatus;
    } catch (ClassCastException e) {
        return false;
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringBuffer sb = new StringBuffer();
    String timeStampType;
    sb.append("mRegistered=").append(mRegistered ? "YES" : "NO");
    timeStampType = timeStampTypeToString(mTimeStampType);
    sb.append(" mTimeStampType=").append(timeStampType);
    sb.append(" mTimeStamp=").append(mTimeStamp).append("ns");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuffer sb = new StringBuffer();
    String timeStampType;
    sb.append("mRegistered=").append(mRegistered ? "YES" : "NO");
    timeStampType = timeStampTypeToString(mTimeStampType);
    sb.append(" mTimeStampType=").append(timeStampType);
    sb.append(" mTimeStamp=").append(mTimeStamp).append("ns");
    sb.append(" mCellConnectionStatus=").append(mCellConnectionStatus);
    return sb.toString();
}
#end_block

#method_before
@Override
public void dump(StringBuilder sb) {
    super.dump(sb);
    if (mShares.size() > 0) {
        println(sb, "Shares:");
        for (BluetoothOppShareInfo info : mShares) {
            String dir = info.mDirection == BluetoothShare.DIRECTION_OUTBOUND ? "->" : "<-";
            SimpleDateFormat format = new SimpleDateFormat("MM'.'dd'@'HH':'mm':'ss", Locale.US);
            Date date = new Date(info.mTimestamp);
            println(sb, "  " + format.format(date) + ": " + dir + " " + info.mCurrentBytes + "/" + info.mTotalBytes + "B ");
        }
    }
}
#method_after
@Override
public void dump(StringBuilder sb) {
    super.dump(sb);
    if (mShares.size() > 0) {
        println(sb, "Shares:");
        for (BluetoothOppShareInfo info : mShares) {
            String dir = info.mDirection == BluetoothShare.DIRECTION_OUTBOUND ? " -> " : " <- ";
            SimpleDateFormat format = new SimpleDateFormat("MM-dd HH:mm:ss", Locale.US);
            Date date = new Date(info.mTimestamp);
            println(sb, "  " + format.format(date) + dir + info.mCurrentBytes + "/" + info.mTotalBytes);
        }
    }
}
#end_block

#method_before
private void startSocketListener() {
    if (D) {
        Log.d(TAG, "start Socket Listeners");
    }
    stopListeners();
    mServerSocket = ObexServerSockets.createInsecure(this);
    SdpManager sdpManager = SdpManager.getDefaultManager();
    if (sdpManager == null || mServerSocket == null) {
        Log.e(TAG, "ERROR:serversocket object is NULL  sdp manager :" + sdpManager + " mServerSocket:" + mServerSocket);
        return;
    }
    mOppSdpHandle = sdpManager.createOppOpsRecord("OBEX Object Push", mServerSocket.getRfcommChannel(), mServerSocket.getL2capPsm(), 0x0102, SUPPORTED_OPP_FORMAT);
    if (D) {
        Log.d(TAG, "mOppSdpHandle :" + mOppSdpHandle);
    }
}
#method_after
private void startSocketListener() {
    if (D) {
        Log.d(TAG, "start Socket Listeners");
    }
    stopListeners();
    mServerSocket = ObexServerSockets.createInsecure(this);
    acceptNewConnections();
    SdpManager sdpManager = SdpManager.getDefaultManager();
    if (sdpManager == null || mServerSocket == null) {
        Log.e(TAG, "ERROR:serversocket object is NULL  sdp manager :" + sdpManager + " mServerSocket:" + mServerSocket);
        return;
    }
    mOppSdpHandle = sdpManager.createOppOpsRecord("OBEX Object Push", mServerSocket.getRfcommChannel(), mServerSocket.getL2capPsm(), 0x0102, SUPPORTED_OPP_FORMAT);
    if (D) {
        Log.d(TAG, "mOppSdpHandle :" + mOppSdpHandle);
    }
}
#end_block

#method_before
private void createServerSession(ObexTransport transport) {
    mServerSession = new BluetoothOppObexServerSession(this, transport, mServerSocket);
    mServerSession.preStart();
    if (D) {
        Log.d(TAG, "Get ServerSession " + mServerSession.toString() + " for incoming connection" + transport.toString());
    }
}
#method_after
private void createServerSession(ObexTransport transport) {
    mServerSession = new BluetoothOppObexServerSession(this, transport, this);
    mServerSession.preStart();
    if (D) {
        Log.d(TAG, "Get ServerSession " + mServerSession.toString() + " for incoming connection" + transport.toString());
    }
}
#end_block

#method_before
@Override
public boolean onConnect(BluetoothDevice device, BluetoothSocket socket) {
    if (D) {
        Log.d(TAG, " onConnect BluetoothSocket :" + socket + " \n :device :" + device);
    }
    BluetoothObexTransport transport = new BluetoothObexTransport(socket);
    Message msg = mHandler.obtainMessage(MSG_INCOMING_BTOPP_CONNECTION);
    msg.obj = transport;
    msg.sendToTarget();
    return true;
}
#method_after
@Override
public boolean onConnect(BluetoothDevice device, BluetoothSocket socket) {
    if (D) {
        Log.d(TAG, " onConnect BluetoothSocket :" + socket + " \n :device :" + device);
    }
    if (!mAcceptNewConnections) {
        Log.d(TAG, " onConnect BluetoothSocket :" + socket + " rejected");
        return false;
    }
    BluetoothObexTransport transport = new BluetoothObexTransport(socket);
    Message msg = mHandler.obtainMessage(MSG_INCOMING_BTOPP_CONNECTION);
    msg.obj = transport;
    msg.sendToTarget();
    mAcceptNewConnections = false;
    return true;
}
#end_block

#method_before
protected void copyFrom(ServiceState s) {
    mVoiceRegState = s.mVoiceRegState;
    mDataRegState = s.mDataRegState;
    mVoiceRoamingType = s.mVoiceRoamingType;
    mDataRoamingType = s.mDataRoamingType;
    mVoiceOperatorAlphaLong = s.mVoiceOperatorAlphaLong;
    mVoiceOperatorAlphaShort = s.mVoiceOperatorAlphaShort;
    mVoiceOperatorNumeric = s.mVoiceOperatorNumeric;
    mDataOperatorAlphaLong = s.mDataOperatorAlphaLong;
    mDataOperatorAlphaShort = s.mDataOperatorAlphaShort;
    mDataOperatorNumeric = s.mDataOperatorNumeric;
    mIsManualNetworkSelection = s.mIsManualNetworkSelection;
    mRilVoiceRadioTechnology = s.mRilVoiceRadioTechnology;
    mRilDataRadioTechnology = s.mRilDataRadioTechnology;
    mCssIndicator = s.mCssIndicator;
    mNetworkId = s.mNetworkId;
    mSystemId = s.mSystemId;
    mCdmaRoamingIndicator = s.mCdmaRoamingIndicator;
    mCdmaDefaultRoamingIndicator = s.mCdmaDefaultRoamingIndicator;
    mCdmaEriIconIndex = s.mCdmaEriIconIndex;
    mCdmaEriIconMode = s.mCdmaEriIconMode;
    mIsEmergencyOnly = s.mIsEmergencyOnly;
    mIsDataRoamingFromRegistration = s.mIsDataRoamingFromRegistration;
    mIsUsingCarrierAggregation = s.mIsUsingCarrierAggregation;
    mLteEarfcnRsrpBoost = s.mLteEarfcnRsrpBoost;
}
#method_after
protected void copyFrom(ServiceState s) {
    mVoiceRegState = s.mVoiceRegState;
    mDataRegState = s.mDataRegState;
    mVoiceRoamingType = s.mVoiceRoamingType;
    mDataRoamingType = s.mDataRoamingType;
    mVoiceOperatorAlphaLong = s.mVoiceOperatorAlphaLong;
    mVoiceOperatorAlphaShort = s.mVoiceOperatorAlphaShort;
    mVoiceOperatorNumeric = s.mVoiceOperatorNumeric;
    mDataOperatorAlphaLong = s.mDataOperatorAlphaLong;
    mDataOperatorAlphaShort = s.mDataOperatorAlphaShort;
    mDataOperatorNumeric = s.mDataOperatorNumeric;
    mIsManualNetworkSelection = s.mIsManualNetworkSelection;
    mRilVoiceRadioTechnology = s.mRilVoiceRadioTechnology;
    mRilDataRadioTechnology = s.mRilDataRadioTechnology;
    mCssIndicator = s.mCssIndicator;
    mNetworkId = s.mNetworkId;
    mSystemId = s.mSystemId;
    mCdmaRoamingIndicator = s.mCdmaRoamingIndicator;
    mCdmaDefaultRoamingIndicator = s.mCdmaDefaultRoamingIndicator;
    mCdmaEriIconIndex = s.mCdmaEriIconIndex;
    mCdmaEriIconMode = s.mCdmaEriIconMode;
    mIsEmergencyOnly = s.mIsEmergencyOnly;
    mIsDataRoamingFromRegistration = s.mIsDataRoamingFromRegistration;
    mIsUsingCarrierAggregation = s.mIsUsingCarrierAggregation;
    mLteEarfcnRsrpBoost = s.mLteEarfcnRsrpBoost;
    mNetworkRegistrationStates = new ArrayList<>(s.mNetworkRegistrationStates);
}
#end_block

#method_before
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(mVoiceRegState);
    out.writeInt(mDataRegState);
    out.writeInt(mVoiceRoamingType);
    out.writeInt(mDataRoamingType);
    out.writeString(mVoiceOperatorAlphaLong);
    out.writeString(mVoiceOperatorAlphaShort);
    out.writeString(mVoiceOperatorNumeric);
    out.writeString(mDataOperatorAlphaLong);
    out.writeString(mDataOperatorAlphaShort);
    out.writeString(mDataOperatorNumeric);
    out.writeInt(mIsManualNetworkSelection ? 1 : 0);
    out.writeInt(mRilVoiceRadioTechnology);
    out.writeInt(mRilDataRadioTechnology);
    out.writeInt(mCssIndicator ? 1 : 0);
    out.writeInt(mNetworkId);
    out.writeInt(mSystemId);
    out.writeInt(mCdmaRoamingIndicator);
    out.writeInt(mCdmaDefaultRoamingIndicator);
    out.writeInt(mCdmaEriIconIndex);
    out.writeInt(mCdmaEriIconMode);
    out.writeInt(mIsEmergencyOnly ? 1 : 0);
    out.writeInt(mIsDataRoamingFromRegistration ? 1 : 0);
    out.writeInt(mIsUsingCarrierAggregation ? 1 : 0);
    out.writeInt(mLteEarfcnRsrpBoost);
    out.writeInt(mChannelNumber);
    out.writeIntArray(mCellBandwidths);
}
#method_after
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(mVoiceRegState);
    out.writeInt(mDataRegState);
    out.writeInt(mVoiceRoamingType);
    out.writeInt(mDataRoamingType);
    out.writeString(mVoiceOperatorAlphaLong);
    out.writeString(mVoiceOperatorAlphaShort);
    out.writeString(mVoiceOperatorNumeric);
    out.writeString(mDataOperatorAlphaLong);
    out.writeString(mDataOperatorAlphaShort);
    out.writeString(mDataOperatorNumeric);
    out.writeInt(mIsManualNetworkSelection ? 1 : 0);
    out.writeInt(mRilVoiceRadioTechnology);
    out.writeInt(mRilDataRadioTechnology);
    out.writeInt(mCssIndicator ? 1 : 0);
    out.writeInt(mNetworkId);
    out.writeInt(mSystemId);
    out.writeInt(mCdmaRoamingIndicator);
    out.writeInt(mCdmaDefaultRoamingIndicator);
    out.writeInt(mCdmaEriIconIndex);
    out.writeInt(mCdmaEriIconMode);
    out.writeInt(mIsEmergencyOnly ? 1 : 0);
    out.writeInt(mIsDataRoamingFromRegistration ? 1 : 0);
    out.writeInt(mIsUsingCarrierAggregation ? 1 : 0);
    out.writeInt(mLteEarfcnRsrpBoost);
    out.writeList(mNetworkRegistrationStates);
    out.writeInt(mChannelNumber);
    out.writeIntArray(mCellBandwidths);
}
#end_block

#method_before
public int getDuplexMode() {
    // 5.7.3-1 and 5.5-1
    return DUPLEX_MODE_UNKNOWN;
}
#method_after
@DuplexMode
public int getDuplexMode() {
    // 5.7.3-1 and 5.5-1
    return DUPLEX_MODE_UNKNOWN;
}
#end_block

#method_before
public int[] getCellBandwidths() {
    return mCellBandwidths;
}
#method_after
@Nullable
public int[] getCellBandwidths() {
    return mCellBandwidths;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    ServiceState s;
    try {
        s = (ServiceState) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mVoiceRegState == s.mVoiceRegState && mDataRegState == s.mDataRegState && mIsManualNetworkSelection == s.mIsManualNetworkSelection && mVoiceRoamingType == s.mVoiceRoamingType && mDataRoamingType == s.mDataRoamingType && mChannelNumber == s.mChannelNumber && Arrays.equals(mCellBandwidths, s.mCellBandwidths) && equalsHandlesNulls(mVoiceOperatorAlphaLong, s.mVoiceOperatorAlphaLong) && equalsHandlesNulls(mVoiceOperatorAlphaShort, s.mVoiceOperatorAlphaShort) && equalsHandlesNulls(mVoiceOperatorNumeric, s.mVoiceOperatorNumeric) && equalsHandlesNulls(mDataOperatorAlphaLong, s.mDataOperatorAlphaLong) && equalsHandlesNulls(mDataOperatorAlphaShort, s.mDataOperatorAlphaShort) && equalsHandlesNulls(mDataOperatorNumeric, s.mDataOperatorNumeric) && equalsHandlesNulls(mRilVoiceRadioTechnology, s.mRilVoiceRadioTechnology) && equalsHandlesNulls(mRilDataRadioTechnology, s.mRilDataRadioTechnology) && equalsHandlesNulls(mCssIndicator, s.mCssIndicator) && equalsHandlesNulls(mNetworkId, s.mNetworkId) && equalsHandlesNulls(mSystemId, s.mSystemId) && equalsHandlesNulls(mCdmaRoamingIndicator, s.mCdmaRoamingIndicator) && equalsHandlesNulls(mCdmaDefaultRoamingIndicator, s.mCdmaDefaultRoamingIndicator) && mIsEmergencyOnly == s.mIsEmergencyOnly && mIsDataRoamingFromRegistration == s.mIsDataRoamingFromRegistration && mIsUsingCarrierAggregation == s.mIsUsingCarrierAggregation);
}
#method_after
@Override
public boolean equals(Object o) {
    ServiceState s;
    try {
        s = (ServiceState) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mVoiceRegState == s.mVoiceRegState && mDataRegState == s.mDataRegState && mIsManualNetworkSelection == s.mIsManualNetworkSelection && mVoiceRoamingType == s.mVoiceRoamingType && mDataRoamingType == s.mDataRoamingType && mChannelNumber == s.mChannelNumber && Arrays.equals(mCellBandwidths, s.mCellBandwidths) && equalsHandlesNulls(mVoiceOperatorAlphaLong, s.mVoiceOperatorAlphaLong) && equalsHandlesNulls(mVoiceOperatorAlphaShort, s.mVoiceOperatorAlphaShort) && equalsHandlesNulls(mVoiceOperatorNumeric, s.mVoiceOperatorNumeric) && equalsHandlesNulls(mDataOperatorAlphaLong, s.mDataOperatorAlphaLong) && equalsHandlesNulls(mDataOperatorAlphaShort, s.mDataOperatorAlphaShort) && equalsHandlesNulls(mDataOperatorNumeric, s.mDataOperatorNumeric) && equalsHandlesNulls(mRilVoiceRadioTechnology, s.mRilVoiceRadioTechnology) && equalsHandlesNulls(mRilDataRadioTechnology, s.mRilDataRadioTechnology) && equalsHandlesNulls(mCssIndicator, s.mCssIndicator) && equalsHandlesNulls(mNetworkId, s.mNetworkId) && equalsHandlesNulls(mSystemId, s.mSystemId) && equalsHandlesNulls(mCdmaRoamingIndicator, s.mCdmaRoamingIndicator) && equalsHandlesNulls(mCdmaDefaultRoamingIndicator, s.mCdmaDefaultRoamingIndicator) && mIsEmergencyOnly == s.mIsEmergencyOnly && mIsDataRoamingFromRegistration == s.mIsDataRoamingFromRegistration && mIsUsingCarrierAggregation == s.mIsUsingCarrierAggregation) && mNetworkRegistrationStates.containsAll(s.mNetworkRegistrationStates);
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append("{mVoiceRegState=").append(mVoiceRegState).append("(" + rilServiceStateToString(mVoiceRegState) + ")").append(", mDataRegState=").append(mDataRegState).append("(" + rilServiceStateToString(mDataRegState) + ")").append(", mChannelNumber=").append(mChannelNumber).append(", mCellBandwidths=").append(Arrays.toString(mCellBandwidths)).append(", mVoiceRoamingType=").append(getRoamingLogString(mVoiceRoamingType)).append(", mDataRoamingType=").append(getRoamingLogString(mDataRoamingType)).append(", mVoiceOperatorAlphaLong=").append(mVoiceOperatorAlphaLong).append(", mVoiceOperatorAlphaShort=").append(mVoiceOperatorAlphaShort).append(", mDataOperatorAlphaLong=").append(mDataOperatorAlphaLong).append(", mDataOperatorAlphaShort=").append(mDataOperatorAlphaShort).append(", isManualNetworkSelection=").append(mIsManualNetworkSelection).append(mIsManualNetworkSelection ? "(manual)" : "(automatic)").append(", mRilVoiceRadioTechnology=").append(mRilVoiceRadioTechnology).append("(" + rilRadioTechnologyToString(mRilVoiceRadioTechnology) + ")").append(", mRilDataRadioTechnology=").append(mRilDataRadioTechnology).append("(" + rilRadioTechnologyToString(mRilDataRadioTechnology) + ")").append(", mCssIndicator=").append(mCssIndicator ? "supported" : "unsupported").append(", mNetworkId=").append(mNetworkId).append(", mSystemId=").append(mSystemId).append(", mCdmaRoamingIndicator=").append(mCdmaRoamingIndicator).append(", mCdmaDefaultRoamingIndicator=").append(mCdmaDefaultRoamingIndicator).append(", mIsEmergencyOnly=").append(mIsEmergencyOnly).append(", mIsDataRoamingFromRegistration=").append(mIsDataRoamingFromRegistration).append(", mIsUsingCarrierAggregation=").append(mIsUsingCarrierAggregation).append(", mLteEarfcnRsrpBoost=").append(mLteEarfcnRsrpBoost).append("}").toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append("{mVoiceRegState=").append(mVoiceRegState).append("(" + rilServiceStateToString(mVoiceRegState) + ")").append(", mDataRegState=").append(mDataRegState).append("(" + rilServiceStateToString(mDataRegState) + ")").append(", mChannelNumber=").append(mChannelNumber).append(", mCellBandwidths=").append(Arrays.toString(mCellBandwidths)).append(", mVoiceRoamingType=").append(getRoamingLogString(mVoiceRoamingType)).append(", mDataRoamingType=").append(getRoamingLogString(mDataRoamingType)).append(", mVoiceOperatorAlphaLong=").append(mVoiceOperatorAlphaLong).append(", mVoiceOperatorAlphaShort=").append(mVoiceOperatorAlphaShort).append(", mDataOperatorAlphaLong=").append(mDataOperatorAlphaLong).append(", mDataOperatorAlphaShort=").append(mDataOperatorAlphaShort).append(", isManualNetworkSelection=").append(mIsManualNetworkSelection).append(mIsManualNetworkSelection ? "(manual)" : "(automatic)").append(", mRilVoiceRadioTechnology=").append(mRilVoiceRadioTechnology).append("(" + rilRadioTechnologyToString(mRilVoiceRadioTechnology) + ")").append(", mRilDataRadioTechnology=").append(mRilDataRadioTechnology).append("(" + rilRadioTechnologyToString(mRilDataRadioTechnology) + ")").append(", mCssIndicator=").append(mCssIndicator ? "supported" : "unsupported").append(", mNetworkId=").append(mNetworkId).append(", mSystemId=").append(mSystemId).append(", mCdmaRoamingIndicator=").append(mCdmaRoamingIndicator).append(", mCdmaDefaultRoamingIndicator=").append(mCdmaDefaultRoamingIndicator).append(", mIsEmergencyOnly=").append(mIsEmergencyOnly).append(", mIsDataRoamingFromRegistration=").append(mIsDataRoamingFromRegistration).append(", mIsUsingCarrierAggregation=").append(mIsUsingCarrierAggregation).append(", mLteEarfcnRsrpBoost=").append(mLteEarfcnRsrpBoost).append(", mNetworkRegistrationStates=").append(mNetworkRegistrationStates).append("}").toString();
}
#end_block

#method_before
private void setNullState(int state) {
    if (DBG)
        Rlog.d(LOG_TAG, "[ServiceState] setNullState=" + state);
    mVoiceRegState = state;
    mDataRegState = state;
    mVoiceRoamingType = ROAMING_TYPE_NOT_ROAMING;
    mDataRoamingType = ROAMING_TYPE_NOT_ROAMING;
    mChannelNumber = -1;
    mCellBandwidths = new int[0];
    mVoiceOperatorAlphaLong = null;
    mVoiceOperatorAlphaShort = null;
    mVoiceOperatorNumeric = null;
    mDataOperatorAlphaLong = null;
    mDataOperatorAlphaShort = null;
    mDataOperatorNumeric = null;
    mIsManualNetworkSelection = false;
    mRilVoiceRadioTechnology = 0;
    mRilDataRadioTechnology = 0;
    mCssIndicator = false;
    mNetworkId = -1;
    mSystemId = -1;
    mCdmaRoamingIndicator = -1;
    mCdmaDefaultRoamingIndicator = -1;
    mCdmaEriIconIndex = -1;
    mCdmaEriIconMode = -1;
    mIsEmergencyOnly = false;
    mIsDataRoamingFromRegistration = false;
    mIsUsingCarrierAggregation = false;
    mLteEarfcnRsrpBoost = 0;
}
#method_after
private void setNullState(int state) {
    if (DBG)
        Rlog.d(LOG_TAG, "[ServiceState] setNullState=" + state);
    mVoiceRegState = state;
    mDataRegState = state;
    mVoiceRoamingType = ROAMING_TYPE_NOT_ROAMING;
    mDataRoamingType = ROAMING_TYPE_NOT_ROAMING;
    mChannelNumber = -1;
    mCellBandwidths = new int[0];
    mVoiceOperatorAlphaLong = null;
    mVoiceOperatorAlphaShort = null;
    mVoiceOperatorNumeric = null;
    mDataOperatorAlphaLong = null;
    mDataOperatorAlphaShort = null;
    mDataOperatorNumeric = null;
    mIsManualNetworkSelection = false;
    mRilVoiceRadioTechnology = 0;
    mRilDataRadioTechnology = 0;
    mCssIndicator = false;
    mNetworkId = -1;
    mSystemId = -1;
    mCdmaRoamingIndicator = -1;
    mCdmaDefaultRoamingIndicator = -1;
    mCdmaEriIconIndex = -1;
    mCdmaEriIconMode = -1;
    mIsEmergencyOnly = false;
    mIsDataRoamingFromRegistration = false;
    mIsUsingCarrierAggregation = false;
    mLteEarfcnRsrpBoost = 0;
    mNetworkRegistrationStates = new ArrayList<>();
}
#end_block

#method_before
@SystemApi
public void startNattKeepalive(NattKeepaliveCallback userCallback, int intervalSeconds) throws IOException {
    if (mResourceId == INVALID_RESOURCE_ID) {
        throw new IllegalStateException("Packet keepalive cannot be started for an inactive transform");
    }
    synchronized (mKeepaliveCallback) {
        if (mKeepaliveCallback != null) {
            throw new IllegalStateException("Keepalive already active");
        }
        mUserKeepaliveCallback = userCallback;
        ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
        mKeepalive = cm.startNattKeepalive(mConfig.getNetwork(), intervalSeconds, mKeepaliveCallback, NetworkUtils.numericToInetAddress(mConfig.getSourceAddress()), // FIXME urgently, we need to get the port number from the Encap socket
        4500, NetworkUtils.numericToInetAddress(mConfig.getDestinationAddress()));
    }
}
#method_after
@SystemApi
public void startNattKeepalive(@NonNull NattKeepaliveCallback userCallback, int intervalSeconds, @NonNull Handler handler) throws IOException {
    checkNotNull(userCallback);
    if (intervalSeconds < 20 || intervalSeconds > 3600) {
        throw new IllegalArgumentException("Invalid NAT-T keepalive interval");
    }
    checkNotNull(handler);
    if (mResourceId == INVALID_RESOURCE_ID) {
        throw new IllegalStateException("Packet keepalive cannot be started for an inactive transform");
    }
    synchronized (mKeepaliveCallback) {
        if (mKeepaliveCallback != null) {
            throw new IllegalStateException("Keepalive already active");
        }
        mUserKeepaliveCallback = userCallback;
        ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
        mKeepalive = cm.startNattKeepalive(mConfig.getNetwork(), intervalSeconds, mKeepaliveCallback, NetworkUtils.numericToInetAddress(mConfig.getSourceAddress()), // FIXME urgently, we need to get the port number from the Encap socket
        4500, NetworkUtils.numericToInetAddress(mConfig.getDestinationAddress()));
        mCallbackHandler = handler;
    }
}
#end_block

#method_before
public void getRulesAuthTable(AsyncResultCallback<EuiccRat> callback, Handler handler) {
// TODO: to be implemented.
}
#method_after
public void getRulesAuthTable(AsyncResultCallback<EuiccRulesAuthTable> callback, Handler handler) {
// TODO: to be implemented.
}
#end_block

#method_before
private static String stripTrailingFs(byte[] iccId) {
    String iccIdString = IccUtils.bcdToString(iccId);
    if (iccIdString.endsWith("F")) {
        iccIdString = iccIdString.substring(0, iccIdString.indexOf('F'));
    }
    return iccIdString;
}
#method_after
private static String stripTrailingFs(byte[] iccId) {
    return IccUtils.stripTrailingFs(IccUtils.bchToString(iccId, 0, iccId.length));
}
#end_block

#method_before
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            final int userId = UserHandle.getUserId(app.uid);
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                StorageManagerInternal storageManagerInternal = LocalServices.getService(StorageManagerInternal.class);
                mountExternal = storageManagerInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[3];
            } else {
                gids = new int[permGids.length + 3];
                System.arraycopy(permGids, 0, gids, 3, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
            gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));
            // Replace any invalid GIDs
            if (gids[0] == UserHandle.ERR_GID)
                gids[0] = gids[2];
            if (gids[1] == UserHandle.ERR_GID)
                gids[1] = gids[2];
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int runtimeFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;
            runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            runtimeFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            runtimeFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        if (app.info.isPrivilegedApp() && !SystemProperties.getBoolean("pm.dexopt.priv-apps", true)) {
            runtimeFlags |= Zygote.DISABLE_VERIFIER;
            runtimeFlags |= Zygote.ONLY_USE_SYSTEM_OAT_FILES;
        }
        if (app.info.isSystemApp()) {
            runtimeFlags |= Zygote.DISABLE_HIDDEN_API_CHECKS;
        }
        String invokeWith = null;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            // Debuggable apps may include a wrapper script with their library directory.
            String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh";
            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
            try {
                if (new File(wrapperFileName).exists()) {
                    invokeWith = "/system/bin/logwrapper " + wrapperFileName;
                }
            } finally {
                StrictMode.setThreadPolicy(oldPolicy);
            }
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // the per-user SELinux context must be set
        if (TextUtils.isEmpty(app.info.seInfoUser)) {
            Slog.wtf(TAG, "SELinux tag not defined", new IllegalStateException("SELinux tag not defined for " + app.info.packageName + " (uid " + app.uid + ")"));
        }
        final String seInfo = app.info.seInfo + (TextUtils.isEmpty(app.info.seInfoUser) ? "" : app.info.seInfoUser);
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        ProcessStartResult startResult;
        if (hostingType.equals("webview_service")) {
            startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, entryPointArgs);
        } else {
            startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs);
        }
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, seInfo, app.info.sourceDir, startResult.pid);
        } catch (RemoteException ex) {
        // Ignore
        }
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(startResult.pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        Slog.e(TAG, "Failure starting process " + app.processName, e);
        // Something went very wrong while trying to start this process; one
        // common case is when the package is frozen due to an active
        // upgrade. To recover, clean up any active bookkeeping related to
        // starting this process. (We already invoked this method once when
        // the package was initially frozen through KILL_APPLICATION_MSG, so
        // it doesn't hurt to use it again.)
        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
    }
}
#method_after
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            final int userId = UserHandle.getUserId(app.uid);
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                StorageManagerInternal storageManagerInternal = LocalServices.getService(StorageManagerInternal.class);
                mountExternal = storageManagerInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[3];
            } else {
                gids = new int[permGids.length + 3];
                System.arraycopy(permGids, 0, gids, 3, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
            gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));
            // Replace any invalid GIDs
            if (gids[0] == UserHandle.ERR_GID)
                gids[0] = gids[2];
            if (gids[1] == UserHandle.ERR_GID)
                gids[1] = gids[2];
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int runtimeFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;
            runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            runtimeFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            runtimeFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            runtimeFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        if (app.info.isPrivilegedApp() && !SystemProperties.getBoolean("pm.dexopt.priv-apps", true)) {
            runtimeFlags |= Zygote.DISABLE_VERIFIER;
            runtimeFlags |= Zygote.ONLY_USE_SYSTEM_OAT_FILES;
        }
        if (app.info.isAllowedToUseHiddenApi()) {
            // This app is allowed to use undocumented and private APIs. Set
            // up its runtime with the appropriate flag.
            runtimeFlags |= Zygote.DISABLE_HIDDEN_API_CHECKS;
        }
        String invokeWith = null;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            // Debuggable apps may include a wrapper script with their library directory.
            String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh";
            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
            try {
                if (new File(wrapperFileName).exists()) {
                    invokeWith = "/system/bin/logwrapper " + wrapperFileName;
                }
            } finally {
                StrictMode.setThreadPolicy(oldPolicy);
            }
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // the per-user SELinux context must be set
        if (TextUtils.isEmpty(app.info.seInfoUser)) {
            Slog.wtf(TAG, "SELinux tag not defined", new IllegalStateException("SELinux tag not defined for " + app.info.packageName + " (uid " + app.uid + ")"));
        }
        final String seInfo = app.info.seInfo + (TextUtils.isEmpty(app.info.seInfoUser) ? "" : app.info.seInfoUser);
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        ProcessStartResult startResult;
        if (hostingType.equals("webview_service")) {
            startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, entryPointArgs);
        } else {
            startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs);
        }
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, seInfo, app.info.sourceDir, startResult.pid);
        } catch (RemoteException ex) {
        // Ignore
        }
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(startResult.pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        Slog.e(TAG, "Failure starting process " + app.processName, e);
        // Something went very wrong while trying to start this process; one
        // common case is when the package is frozen due to an active
        // upgrade. To recover, clean up any active bookkeeping related to
        // starting this process. (We already invoked this method once when
        // the package was initially frozen through KILL_APPLICATION_MSG, so
        // it doesn't hurt to use it again.)
        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
    }
}
#end_block

#method_before
public static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
    VM_HOOKS.preFork();
    // Resets nice priority for zygote process.
    resetNicePriority();
    int pid = nativeForkSystemServer(uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities);
    // Enable tracing as soon as we enter the system_server.
    if (pid == 0) {
        Trace.setTracingEnabled(true, runtimeFlags);
    }
    VM_HOOKS.postForkCommon();
    return pid;
}
#method_after
public static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
    // SystemServer is always allowed to use hidden APIs.
    runtimeFlags |= DISABLE_HIDDEN_API_CHECKS;
    VM_HOOKS.preFork();
    // Resets nice priority for zygote process.
    resetNicePriority();
    int pid = nativeForkSystemServer(uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities);
    // Enable tracing as soon as we enter the system_server.
    if (pid == 0) {
        Trace.setTracingEnabled(true, runtimeFlags);
    }
    VM_HOOKS.postForkCommon();
    return pid;
}
#end_block

