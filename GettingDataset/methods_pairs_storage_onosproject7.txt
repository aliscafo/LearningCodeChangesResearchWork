468
#method_before
public CarrierEthernetUni addGlobalUni(CarrierEthernetUni uni) {
    // Add UNI only if it's not already there. If corresponding LTP already exists, link them, otherwise create it
    if (!uniMap.containsKey(uni.id())) {
        // FIXME: Assumes LTP and UNI id are the same
        if (!ltpMap.containsKey(uni.id())) {
            ltpMap.put(uni.id(), new CarrierEthernetLogicalTerminationPoint(uni.id(), uni));
            // Remove LTP from deleted set
            if (removedLtpSet.contains(uni.id())) {
                removedLtpSet.remove(uni.id());
            }
        }
        uniMap.put(uni.id(), uni);
        // Remove UNI from deleted set
        if (removedUniSet.contains(uni.id())) {
            removedUniSet.remove(uni.id());
        }
        return uni;
    } else {
        return null;
    }
}
#method_after
public CarrierEthernetUni addGlobalUni(CarrierEthernetUni uni) {
    // Add UNI only if it's not already there. If corresponding LTP already exists, link them, otherwise create it
    if (!uniMap.containsKey(uni.id())) {
        // FIXME: Assumes LTP and UNI id are the same
        if (!ltpMap.containsKey(uni.id())) {
            ltpMap.put(uni.id(), new CarrierEthernetLogicalTerminationPoint(uni.id(), uni));
            // Remove LTP from deleted set
            removedLtpSet.remove(uni.id());
        }
        uniMap.put(uni.id(), uni);
        // Remove UNI from deleted set
        removedUniSet.remove(uni.id());
        return uni;
    } else {
        return null;
    }
}
#end_block

#method_before
private CarrierEthernetNetworkInterface.Type validateLtpType(ConnectPoint cp, CarrierEthernetNetworkInterface.Type ltpType) {
    log.info("Validating LTP type for {}, type {}", cp, ltpType.name());
    if (linkService.getEgressLinks(cp).isEmpty() && linkService.getIngressLinks(cp).isEmpty()) {
        log.info("CP is attached to a link!");
        // A connect point can be a UNI only if it doesn't belong to any link
        if (ltpType == null) {
            // If provided type is null, decide about the LTP type based on connectivity
            return CarrierEthernetNetworkInterface.Type.UNI;
        } else if (ltpType.equals(CarrierEthernetNetworkInterface.Type.UNI)) {
            // Validate type
            return ltpType;
        } else {
            return null;
        }
    } else {
        log.info("CP is not attached to a link!");
        // A connect point can be an INNI or ENNI only if it belongs to a link
        if (ltpType == null) {
            // If provided type is null, decide about the LTP type based on connectivity
            return CarrierEthernetNetworkInterface.Type.INNI;
        } else if (ltpType.equals(CarrierEthernetNetworkInterface.Type.INNI) || ltpType.equals(CarrierEthernetNetworkInterface.Type.ENNI)) {
            // Validate type
            return ltpType;
        } else {
            return null;
        }
    }
}
#method_after
private CarrierEthernetNetworkInterface.Type validateLtpType(ConnectPoint cp, CarrierEthernetNetworkInterface.Type ltpType) {
    if (linkService.getEgressLinks(cp).isEmpty() && linkService.getIngressLinks(cp).isEmpty()) {
        // A connect point can be a UNI only if it doesn't belong to any link
        if (ltpType == null) {
            // If provided type is null, decide about the LTP type based on connectivity
            return CarrierEthernetNetworkInterface.Type.UNI;
        } else if (ltpType.equals(CarrierEthernetNetworkInterface.Type.UNI)) {
            // Validate type
            return ltpType;
        } else {
            return null;
        }
    } else {
        // A connect point can be an INNI or ENNI only if it belongs to a link
        if (ltpType == null) {
            // If provided type is null, decide about the LTP type based on connectivity
            return CarrierEthernetNetworkInterface.Type.INNI;
        } else if (ltpType.equals(CarrierEthernetNetworkInterface.Type.INNI) || ltpType.equals(CarrierEthernetNetworkInterface.Type.ENNI)) {
            // Validate type
            return ltpType;
        } else {
            return null;
        }
    }
}
#end_block

#method_before
public CarrierEthernetLogicalTerminationPoint addGlobalLtp(CarrierEthernetLogicalTerminationPoint ltp) {
    // FIXME: Assumes LTP and UNI id are the same
    if (ltp.ni() != null && ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
        if (!uniMap.containsKey(ltp.ni().id())) {
            uniMap.put(ltp.ni().id(), (CarrierEthernetUni) ltp.ni());
            // Remove UNI from deleted set
            if (removedUniSet.contains(ltp.id())) {
                removedUniSet.remove(ltp.id());
            }
        } else {
            ltp.setNi(uniMap.get(ltp.ni().id()));
        }
    }
    // Add LTP only if it's not already there
    if (!ltpMap.containsKey(ltp.id())) {
        // Try to create and add INNI LTP at other end of link as well
        if (ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.INNI)) {
            Link link = linkService.getEgressLinks(ltp.ni().cp()).iterator().next();
            CarrierEthernetLogicalTerminationPoint pairLtp = generateLtp(link.dst(), CarrierEthernetNetworkInterface.Type.INNI);
            if (pairLtp == null) {
                return null;
            }
            if (!ltpMap.containsKey(pairLtp.id())) {
                ltpMap.put(pairLtp.id(), pairLtp);
            } else {
                return null;
            }
        }
        ltpMap.put(ltp.id(), ltp);
        // Remove LTP from deleted set
        if (removedLtpSet.contains(ltp.id())) {
            removedLtpSet.remove(ltp.id());
        }
        return ltp;
    } else {
        return null;
    }
}
#method_after
public CarrierEthernetLogicalTerminationPoint addGlobalLtp(CarrierEthernetLogicalTerminationPoint ltp) {
    // FIXME: Assumes LTP and UNI id are the same
    if (ltp.ni() != null && ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
        if (!uniMap.containsKey(ltp.ni().id())) {
            uniMap.put(ltp.ni().id(), (CarrierEthernetUni) ltp.ni());
            // Remove UNI from deleted set
            removedUniSet.remove(ltp.id());
        } else {
            ltp.setNi(uniMap.get(ltp.ni().id()));
        }
    }
    // Add LTP only if it's not already there
    if (!ltpMap.containsKey(ltp.id())) {
        // Try to create and add INNI LTP at other end of link as well
        if (ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.INNI)) {
            Link link = linkService.getEgressLinks(ltp.ni().cp()).iterator().next();
            CarrierEthernetLogicalTerminationPoint pairLtp = generateLtp(link.dst(), CarrierEthernetNetworkInterface.Type.INNI);
            if (pairLtp == null) {
                return null;
            }
            if (!ltpMap.containsKey(pairLtp.id())) {
                ltpMap.put(pairLtp.id(), pairLtp);
            } else {
                return null;
            }
        }
        ltpMap.put(ltp.id(), ltp);
        // Remove LTP from deleted set
        removedLtpSet.remove(ltp.id());
        return ltp;
    } else {
        return null;
    }
}
#end_block

#method_before
public void setupConnectivity(CarrierEthernetForwardingConstruct fc) {
    boolean allPairsConnected = true;
    HashMap<CarrierEthernetNetworkInterface, HashSet<CarrierEthernetNetworkInterface>> ingressEgressNiMap = new HashMap<>();
    // Temporary set for iterating through LTP pairs
    Set<CarrierEthernetLogicalTerminationPoint> tempLtpSet = new HashSet<>(fc.ltpSet());
    // Temporary set for indicating which LTPs were finally included
    Set<CarrierEthernetLogicalTerminationPoint> usedLtpSet = new HashSet<>();
    Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt1 = tempLtpSet.iterator();
    while (ltpIt1.hasNext()) {
        CarrierEthernetLogicalTerminationPoint ltp1 = ltpIt1.next();
        // Iterate through all the remaining NIs
        Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt2 = tempLtpSet.iterator();
        while (ltpIt2.hasNext()) {
            CarrierEthernetLogicalTerminationPoint ltp2 = ltpIt2.next();
            // Skip equals
            if (ltp1.equals(ltp2)) {
                continue;
            }
            // FIXME: Use proper LTP roles
            if (ltp1.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF) && ltp2.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF)) {
                continue;
            }
            OpticalConnectivityId opticalConnectId = null;
            if (pktOpticalTopo) {
                Bandwidth reqBw;
                if (ltp1.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ltp1.ni()).bwp().cir();
                } else if (ltp2.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ltp2.ni()).bwp().cir();
                } else {
                    reqBw = Bandwidth.bps((double) 0);
                }
                opticalConnectId = setupOpticalConnectivity(ltp1.ni().cp(), ltp2.ni().cp(), reqBw, fc.maxLatency());
                if (opticalConnectId == null || opticalConnectStatusMap.get(opticalConnectId) != OpticalPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish optical connectivity between {} and {}" + " (optical id and status: {}, {})", ltp1.ni().cp(), ltp2.ni().cp(), opticalConnectId, (opticalConnectId == null ? "null" : opticalConnectStatusMap.get(opticalConnectId)));
                    allPairsConnected = false;
                    continue;
                }
                if (opticalConnectId != null) {
                    fc.setMetroConnectivityId(opticalConnectId);
                    fc.setMetroConnectivityStatus(opticalConnectStatusMap.get(opticalConnectId));
                }
                log.info("Metro connectivity id and status for FC {}: {}, {}", fc.id(), fc.metroConnectivity().id(), fc.metroConnectivity().status());
                if (opticalConnectId != null) {
                    // TODO: find vlanIds for both CO and store to service
                    opticalPathService.getPath(opticalConnectId).ifPresent(links -> {
                        getVlanTag(links).ifPresent(vlan -> {
                            log.info("VLAN ID {} is assigned to CE service {}", vlan, fc.id());
                            fc.setVlanId(vlan);
                        });
                        getTransportVlanTag(links).ifPresent(vlan -> {
                            log.info("Transport VLAN ID {} is assigned to CE service {}", vlan, fc.id());
                            fc.setTransportVlanId(vlan);
                        });
                    });
                }
            }
            // Update the ingress-egress NI map based on the calculated paths
            if (!updateIngressEgressNiMap(ltp1.ni(), ltp2.ni(), ingressEgressNiMap, fc.congruentPaths(), fc.type())) {
                removeOpticalConnectivity(opticalConnectId);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one NI pair has been established
            fc.setState(CarrierEthernetForwardingConstruct.State.ACTIVE);
            // Add NIs to the set of NIs used by the EVC
            usedLtpSet.add(ltp1);
            usedLtpSet.add(ltp2);
        }
        // Remove NI from temporary set so that each pair is visited only once
        ltpIt1.remove();
    }
    // Establish connectivity using the ingressEgressNiMap
    ingressEgressNiMap.keySet().forEach(srcNi -> {
        // Set forwarding only on packet switches
        if (deviceService.getDevice(srcNi.cp().deviceId()).type().equals(Device.Type.SWITCH)) {
            ceOfPktNodeManager.setNodeForwarding(fc, srcNi, ingressEgressNiMap.get(srcNi));
        }
    });
    // Update the NI set, based on the NIs actually used
    fc.setLtpSet(usedLtpSet);
    if (fc.isActive()) {
        if (!allPairsConnected) {
            fc.setState(CarrierEthernetConnection.State.PARTIAL);
        }
    }
}
#method_after
public void setupConnectivity(CarrierEthernetForwardingConstruct fc) {
    boolean allPairsConnected = true;
    HashMap<CarrierEthernetNetworkInterface, HashSet<CarrierEthernetNetworkInterface>> ingressEgressNiMap = new HashMap<>();
    // Temporary set for iterating through LTP pairs
    Set<CarrierEthernetLogicalTerminationPoint> tempLtpSet = new HashSet<>(fc.ltpSet());
    // Temporary set for indicating which LTPs were finally included
    Set<CarrierEthernetLogicalTerminationPoint> usedLtpSet = new HashSet<>();
    Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt1 = tempLtpSet.iterator();
    while (ltpIt1.hasNext()) {
        CarrierEthernetLogicalTerminationPoint ltp1 = ltpIt1.next();
        // Iterate through all the remaining NIs
        Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt2 = tempLtpSet.iterator();
        while (ltpIt2.hasNext()) {
            CarrierEthernetLogicalTerminationPoint ltp2 = ltpIt2.next();
            // Skip equals
            if (ltp1.equals(ltp2)) {
                continue;
            }
            // FIXME: Use proper LTP roles
            if (ltp1.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF) && ltp2.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF)) {
                continue;
            }
            OpticalConnectivityId opticalConnectId = null;
            if (pktOpticalTopo) {
                Bandwidth reqBw;
                if (ltp1.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ltp1.ni()).bwp().cir();
                } else if (ltp2.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ltp2.ni()).bwp().cir();
                } else {
                    reqBw = Bandwidth.bps((double) 0);
                }
                opticalConnectId = setupOpticalConnectivity(ltp1.ni().cp(), ltp2.ni().cp(), reqBw, fc.maxLatency());
                if (opticalConnectId == null || opticalConnectStatusMap.get(opticalConnectId) != OpticalPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish optical connectivity between {} and {}" + " (optical id and status: {}, {})", ltp1.ni().cp(), ltp2.ni().cp(), opticalConnectId, (opticalConnectId == null ? "null" : opticalConnectStatusMap.get(opticalConnectId)));
                    allPairsConnected = false;
                    continue;
                }
                if (opticalConnectId != null) {
                    fc.setMetroConnectivityId(opticalConnectId);
                    fc.setMetroConnectivityStatus(opticalConnectStatusMap.get(opticalConnectId));
                }
                log.info("Metro connectivity id and status for FC {}: {}, {}", fc.id(), fc.metroConnectivity().id(), fc.metroConnectivity().status());
                if (opticalConnectId != null) {
                    // TODO: find vlanIds for both CO and store to service
                    opticalPathService.getPath(opticalConnectId).ifPresent(links -> {
                        getVlanTag(links).ifPresent(vlan -> {
                            log.info("VLAN ID {} is assigned to CE service {}", vlan, fc.id());
                            fc.setVlanId(vlan);
                        });
                        getTransportVlanTag(links).ifPresent(vlan -> {
                            log.info("Transport VLAN ID {} is assigned to CE service {}", vlan, fc.id());
                            fc.setTransportVlanId(vlan);
                        });
                    });
                }
            }
            // Update the ingress-egress NI map based on the calculated paths
            if (!updateIngressEgressNiMap(ltp1.ni(), ltp2.ni(), ingressEgressNiMap, fc.congruentPaths(), fc.type())) {
                removeOpticalConnectivity(opticalConnectId);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one NI pair has been established
            fc.setState(CarrierEthernetForwardingConstruct.State.ACTIVE);
            // Add NIs to the set of NIs used by the EVC
            usedLtpSet.add(ltp1);
            usedLtpSet.add(ltp2);
        }
        // Remove NI from temporary set so that each pair is visited only once
        ltpIt1.remove();
    }
    // Establish connectivity using the ingressEgressNiMap
    ingressEgressNiMap.keySet().forEach(srcNi -> {
        // Set forwarding only on packet switches
        if (deviceService.getDevice(srcNi.cp().deviceId()).type().equals(Device.Type.SWITCH)) {
            cePktNodeService.setNodeForwarding(fc, srcNi, ingressEgressNiMap.get(srcNi));
        }
    });
    // Update the NI set, based on the NIs actually used
    fc.setLtpSet(usedLtpSet);
    if (fc.isActive()) {
        if (!allPairsConnected) {
            fc.setState(CarrierEthernetConnection.State.PARTIAL);
        }
    }
}
#end_block

#method_before
public void removeConnectivity(CarrierEthernetForwardingConstruct fc) {
    // TODO: Add here the same call for all node manager types
    ceOfPktNodeManager.removeAllForwardingResources(fc);
    removeOpticalConnectivity(fc.metroConnectivity().id());
}
#method_after
public void removeConnectivity(CarrierEthernetForwardingConstruct fc) {
    // TODO: Add here the same call for all node manager types
    cePktNodeService.removeAllForwardingResources(fc);
    removeOpticalConnectivity(fc.metroConnectivity().id());
}
#end_block

#method_before
public void createBandwidthProfiles(CarrierEthernetForwardingConstruct fc) {
    // TODO: Select node manager depending on device protocol
    fc.uniSet().forEach(uni -> ceOfPktNodeManager.createBandwidthProfileResources(fc, uni));
}
#method_after
public void createBandwidthProfiles(CarrierEthernetForwardingConstruct fc) {
    // TODO: Select node manager depending on device protocol
    fc.uniSet().forEach(uni -> cePktNodeService.createBandwidthProfileResources(fc, uni));
}
#end_block

#method_before
public void applyBandwidthProfiles(CarrierEthernetForwardingConstruct fc) {
    // TODO: Select node manager depending on device protocol
    fc.uniSet().forEach(uni -> ceOfPktNodeManager.applyBandwidthProfileResources(fc, uni));
}
#method_after
public void applyBandwidthProfiles(CarrierEthernetForwardingConstruct fc) {
    // TODO: Select node manager depending on device protocol
    fc.uniSet().forEach(uni -> cePktNodeService.applyBandwidthProfileResources(fc, uni));
}
#end_block

#method_before
public void removeBandwidthProfiles(CarrierEthernetForwardingConstruct fc) {
    // TODO: Select node manager depending on device protocol
    fc.ltpSet().forEach((ltp -> {
        if (ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
            ceOfPktNodeManager.removeBandwidthProfileResources(fc.id(), (CarrierEthernetUni) ltp.ni());
        }
    }));
}
#method_after
public void removeBandwidthProfiles(CarrierEthernetForwardingConstruct fc) {
    // TODO: Select node manager depending on device protocol
    fc.ltpSet().forEach((ltp -> {
        if (ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
            cePktNodeService.removeBandwidthProfileResources(fc.id(), (CarrierEthernetUni) ltp.ni());
        }
    }));
}
#end_block

#method_before
@Test
public void testInvalidRebootOnuInput() throws Exception {
    String reply;
    String target;
    for (Integer key : INVALID_REBOOT_TCS.keySet()) {
        target = INVALID_REBOOT_TCS.get(key);
        reply = voltConfig.rebootOnu(target);
        assertNull("Incorrect response for " + target, reply);
    }
}
#method_after
@Test
public void testInvalidRebootOnuInput() throws Exception {
    String reply;
    String target;
    for (int i = ZERO; i < INVALID_REBOOT_TCS.length; i++) {
        target = INVALID_REBOOT_TCS[i];
        reply = voltConfig.rebootOnu(target);
        assertNull("Incorrect response for INVALID_REBOOT_TCS", reply);
    }
}
#end_block

#method_before
@Test
public void testValidRebootOnu() throws Exception {
    String reply;
    String target;
    for (Integer key : VALID_REBOOT_TCS.keySet()) {
        target = VALID_REBOOT_TCS.get(key);
        currentKey = key;
        reply = voltConfig.rebootOnu(target);
        assertNotNull("Incorrect response for " + target, reply);
    }
}
#method_after
@Test
public void testValidRebootOnu() throws Exception {
    String reply;
    String target;
    for (int i = ZERO; i < VALID_REBOOT_TCS.length; i++) {
        target = VALID_REBOOT_TCS[i];
        currentKey = i;
        reply = voltConfig.rebootOnu(target);
        assertNotNull("Incorrect response for VALID_REBOOT_TCS", reply);
    }
}
#end_block

#method_before
@Test
public void testInvalidEthLoopbackOnuInput() throws Exception {
    String target;
    String reply;
    for (Integer key : INVALID_ETHPORT_LOOPBACK_TCS.keySet()) {
        target = INVALID_ETHPORT_LOOPBACK_TCS.get(key);
        reply = voltConfig.loopbackEthOnu(target);
        assertNull("Incorrect response for " + target, reply);
    }
}
#method_after
@Test
public void testInvalidEthLoopbackOnuInput() throws Exception {
    String target;
    String reply;
    for (int i = ZERO; i < INVALID_ETHPORT_LOOPBACK_TCS.length; i++) {
        target = INVALID_ETHPORT_LOOPBACK_TCS[i];
        reply = voltConfig.loopbackEthOnu(target);
        assertNull("Incorrect response for INVALID_ETHPORT_LOOPBACK_TCS", reply);
    }
}
#end_block

#method_before
@Test
public void testValidLoopbackEthOnu() throws Exception {
    String target;
    String reply;
    for (Integer key : VALID_ETHPORT_LOOPBACK_TCS.keySet()) {
        target = VALID_ETHPORT_LOOPBACK_TCS.get(key);
        currentKey = key;
        reply = voltConfig.loopbackEthOnu(target);
        assertNotNull("Incorrect response for " + target, reply);
    }
}
#method_after
@Test
public void testValidLoopbackEthOnu() throws Exception {
    String target;
    String reply;
    for (int i = ZERO; i < VALID_ETHPORT_LOOPBACK_TCS.length; i++) {
        target = VALID_ETHPORT_LOOPBACK_TCS[i];
        currentKey = i;
        reply = voltConfig.loopbackEthOnu(target);
        assertNotNull("Incorrect response for VALID_ETHPORT_LOOPBACK_TCS", reply);
    }
}
#end_block

#method_before
private boolean verifyWrappedRpcRequestForReboot(String request) {
    StringBuilder rpc = new StringBuilder();
    String target = VALID_REBOOT_TCS.get(currentKey);
    String[] data = target.split(TEST_COLON);
    String[] onuId = data[FIRST_PART].split(TEST_HYPHEN);
    rpc.append(TEST_ANGLE_LEFT).append(TEST_ONU_REBOOT).append(TEST_SPACE);
    rpc.append(TEST_VOLT_NE_NAMESPACE).append(TEST_ANGLE_RIGHT).append(TEST_NEW_LINE);
    rpc.append(startTag(TEST_PONLINK_ID, false));
    rpc.append(onuId[FIRST_PART]);
    rpc.append(endTag(TEST_PONLINK_ID));
    rpc.append(startTag(TEST_ONU_ID, false));
    rpc.append(onuId[SECOND_PART]);
    rpc.append(endTag(TEST_ONU_ID));
    rpc.append(endTag(TEST_ONU_REBOOT));
    String testRequest = rpc.toString();
    testRequest = testRequest.replaceAll(TEST_WHITESPACES_REGEX, TEST_EMPTY_STRING);
    request = request.replaceAll(TEST_WHITESPACES_REGEX, TEST_EMPTY_STRING);
    boolean result = request.equals(testRequest);
    assertTrue("Does not match with generated string", result);
    return result;
}
#method_after
private boolean verifyWrappedRpcRequestForReboot(String request) {
    StringBuilder rpc = new StringBuilder();
    String target = VALID_REBOOT_TCS[currentKey];
    String[] data = target.split(TEST_COLON);
    String[] onuId = data[FIRST_PART].split(TEST_HYPHEN);
    rpc.append(TEST_ANGLE_LEFT + TEST_ONU_REBOOT + TEST_SPACE);
    rpc.append(TEST_VOLT_NE_NAMESPACE + TEST_ANGLE_RIGHT + TEST_NEW_LINE);
    rpc.append(startTag(TEST_PONLINK_ID, false)).append(onuId[FIRST_PART]).append(endTag(TEST_PONLINK_ID)).append(startTag(TEST_ONU_ID, false)).append(onuId[SECOND_PART]).append(endTag(TEST_ONU_ID)).append(endTag(TEST_ONU_REBOOT));
    String testRequest = rpc.toString();
    String regex = TEST_WHITESPACES_REGEX;
    int index = rpc.indexOf(regex);
    while (index >= ZERO) {
        testRequest = rpc.replace(index, index + regex.length(), TEST_EMPTY_STRING).toString();
        request = request.replaceAll(regex, TEST_EMPTY_STRING);
    }
    boolean result = request.equals(testRequest);
    assertTrue("Does not match with generated string", result);
    return result;
}
#end_block

#method_before
private boolean verifyWrappedRpcRequestForEthLoopback(String request) {
    StringBuilder rpc = new StringBuilder();
    String target = VALID_ETHPORT_LOOPBACK_TCS.get(currentKey);
    String[] data = target.split(TEST_COLON);
    String[] ethId = data[FIRST_PART].split(TEST_HYPHEN);
    rpc.append(TEST_ANGLE_LEFT).append(TEST_ONU_ETHPORT_LOOPBACK).append(TEST_SPACE);
    rpc.append(TEST_VOLT_NE_NAMESPACE).append(TEST_ANGLE_RIGHT).append(TEST_NEW_LINE);
    rpc.append(startTag(TEST_PONLINK_ID, false));
    rpc.append(ethId[FIRST_PART]);
    rpc.append(endTag(TEST_PONLINK_ID));
    rpc.append(startTag(TEST_ONU_ID, false));
    rpc.append(ethId[SECOND_PART]);
    rpc.append(endTag(TEST_ONU_ID));
    rpc.append(startTag(TEST_ETHPORT_ID, false));
    rpc.append(ethId[THIRD_PART]);
    rpc.append(endTag(TEST_ETHPORT_ID));
    if (data.length > SECOND_PART) {
        rpc.append(startTag(TEST_LOOPBACK_MODE, false));
        rpc.append(data[SECOND_PART]);
        rpc.append(endTag(TEST_LOOPBACK_MODE));
    }
    rpc.append(endTag(TEST_ONU_ETHPORT_LOOPBACK));
    String testRequest = rpc.toString();
    testRequest = testRequest.replaceAll(TEST_WHITESPACES_REGEX, TEST_EMPTY_STRING);
    request = request.replaceAll(TEST_WHITESPACES_REGEX, TEST_EMPTY_STRING);
    boolean result = request.equals(testRequest);
    assertTrue("Does not match with generated string", result);
    return result;
}
#method_after
private boolean verifyWrappedRpcRequestForEthLoopback(String request) {
    StringBuilder rpc = new StringBuilder();
    String target = VALID_ETHPORT_LOOPBACK_TCS[currentKey];
    String[] data = target.split(TEST_COLON);
    String[] ethId = data[FIRST_PART].split(TEST_HYPHEN);
    rpc.append(TEST_ANGLE_LEFT + TEST_ONU_ETHPORT_LOOPBACK + TEST_SPACE);
    rpc.append(TEST_VOLT_NE_NAMESPACE + TEST_ANGLE_RIGHT + TEST_NEW_LINE);
    rpc.append(startTag(TEST_PONLINK_ID, false)).append(ethId[FIRST_PART]).append(endTag(TEST_PONLINK_ID)).append(startTag(TEST_ONU_ID, false)).append(ethId[SECOND_PART]).append(endTag(TEST_ONU_ID)).append(startTag(TEST_ETHPORT_ID, false)).append(ethId[THIRD_PART]).append(endTag(TEST_ETHPORT_ID));
    if (data.length > SECOND_PART) {
        rpc.append(startTag(TEST_LOOPBACK_MODE, false)).append(data[SECOND_PART]).append(endTag(TEST_LOOPBACK_MODE));
    }
    rpc.append(endTag(TEST_ONU_ETHPORT_LOOPBACK));
    String testRequest = rpc.toString();
    String regex = TEST_WHITESPACES_REGEX;
    int index = rpc.indexOf(regex);
    while (index >= ZERO) {
        testRequest = rpc.replace(index, index + regex.length(), TEST_EMPTY_STRING).toString();
        request = request.replaceAll(regex, TEST_EMPTY_STRING);
    }
    boolean result = request.equals(testRequest);
    assertTrue("Does not match with generated string", result);
    return result;
}
#end_block

#method_before
@Override
public String rebootOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    String[] onuId = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return null;
    }
    onuId = checkIdString(target, TWO);
    if (onuId == null) {
        log.error("Invalid ONU identifier {}", target);
        return null;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT).append(ONU_REBOOT).append(SPACE);
        request.append(VOLT_NE_NAMESPACE).append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(onuId[FIRST_PART]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(ONU_ID, false));
        request.append(onuId[SECOND_PART]);
        request.append(buildEndTag(ONU_ID));
        request.append(buildEndTag(ONU_REBOOT));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doWrappedRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception {}", ncDeviceId, e);
    }
    return reply;
}
#method_after
@Override
public String rebootOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    String[] onuId = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return null;
    }
    onuId = checkIdString(target, TWO);
    if (onuId == null) {
        log.error("Invalid ONU identifier {}", target);
        return null;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT + ONU_REBOOT + SPACE);
        request.append(VOLT_NE_NAMESPACE + ANGLE_RIGHT + NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false)).append(onuId[FIRST_PART]).append(buildEndTag(PONLINK_ID)).append(buildStartTag(ONU_ID, false)).append(onuId[SECOND_PART]).append(buildEndTag(ONU_ID)).append(buildEndTag(ONU_REBOOT));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doWrappedRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception {}", ncDeviceId, e);
    }
    return reply;
}
#end_block

#method_before
@Override
public String loopbackEthOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    String[] data = null;
    String[] ethId = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return null;
    }
    data = target.split(COLON);
    if (data.length > TWO) {
        log.error("Invalid number of parameters {}", target);
        return null;
    }
    ethId = checkIdString(data[FIRST_PART], THREE);
    if (ethId == null) {
        log.error("Invalid ETH port identifier {}", data[FIRST_PART]);
        return null;
    }
    if (data.length > ONE) {
        if (!LOOPBACKMODES.contains(data[SECOND_PART])) {
            log.error("Unsupported parameter: {}", data[SECOND_PART]);
            return null;
        }
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT).append(ONU_ETHPORT_LOOPBACK).append(SPACE);
        request.append(VOLT_NE_NAMESPACE).append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(ethId[FIRST_PART]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(ONU_ID, false));
        request.append(ethId[SECOND_PART]);
        request.append(buildEndTag(ONU_ID));
        request.append(buildStartTag(ETHPORT_ID, false));
        request.append(ethId[THIRD_PART]);
        request.append(buildEndTag(ETHPORT_ID));
        if (data.length > ONE) {
            request.append(buildStartTag(LOOPBACK_MODE, false));
            request.append(data[SECOND_PART]);
            request.append(buildEndTag(LOOPBACK_MODE));
        }
        request.append(buildEndTag(ONU_ETHPORT_LOOPBACK));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doWrappedRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception {}", ncDeviceId, e);
    }
    return reply;
}
#method_after
@Override
public String loopbackEthOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    String[] data = null;
    String[] ethId = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return null;
    }
    data = target.split(COLON);
    if (data.length > TWO) {
        log.error("Invalid number of parameters {}", target);
        return null;
    }
    ethId = checkIdString(data[FIRST_PART], THREE);
    if (ethId == null) {
        log.error("Invalid ETH port identifier {}", data[FIRST_PART]);
        return null;
    }
    if (data.length > ONE) {
        if (!LOOPBACKMODES.contains(data[SECOND_PART])) {
            log.error("Unsupported parameter: {}", data[SECOND_PART]);
            return null;
        }
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT + ONU_ETHPORT_LOOPBACK + SPACE);
        request.append(VOLT_NE_NAMESPACE + ANGLE_RIGHT + NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false)).append(ethId[FIRST_PART]).append(buildEndTag(PONLINK_ID)).append(buildStartTag(ONU_ID, false)).append(ethId[SECOND_PART]).append(buildEndTag(ONU_ID)).append(buildStartTag(ETHPORT_ID, false)).append(ethId[THIRD_PART]).append(buildEndTag(ETHPORT_ID));
        if (data.length > ONE) {
            request.append(buildStartTag(LOOPBACK_MODE, false)).append(data[SECOND_PART]).append(buildEndTag(LOOPBACK_MODE));
        }
        request.append(buildEndTag(ONU_ETHPORT_LOOPBACK));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doWrappedRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception {}", ncDeviceId, e);
    }
    return reply;
}
#end_block

#method_before
@POST
@Path("{deviceId}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createMeter(@PathParam("deviceId") String deviceId, InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode specifiedDeviceId = jsonTree.get("deviceId");
        if (specifiedDeviceId != null && !specifiedDeviceId.asText().equals(deviceId)) {
            throw new IllegalArgumentException(DEVICE_INVALID);
        }
        jsonTree.put("deviceId", deviceId);
        final MeterRequest meterRequest = codec(MeterRequest.class).decode(jsonTree, this);
        if (get(DeviceService.class).getDevice(meterRequest.deviceId()) == null) {
            throw new IllegalArgumentException(DEVICE_INVALID);
        }
        final Meter meter = meterService.submit(meterRequest);
        UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path("meters").path(deviceId).path(Long.toString(meter.id().id()));
        return Response.created(locationBuilder.build()).build();
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
}
#method_after
@POST
@Path("{deviceId}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createMeter(@PathParam("deviceId") String deviceId, InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode specifiedDeviceId = jsonTree.get("deviceId");
        if ((specifiedDeviceId != null && !specifiedDeviceId.asText().equals(deviceId)) || get(DeviceService.class).getDevice(DeviceId.deviceId(deviceId)) == null) {
            throw new IllegalArgumentException(DEVICE_INVALID);
        }
        jsonTree.put("deviceId", deviceId);
        final MeterRequest meterRequest = codec(MeterRequest.class).decode(jsonTree, this);
        final Meter meter = meterService.submit(meterRequest);
        UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path("meters").path(deviceId).path(Long.toString(meter.id().id()));
        return Response.created(locationBuilder.build()).build();
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
}
#end_block

#method_before
// Sets flag at execution to indicate there is currently a scheduled rebalancing. As soon
private void scheduleBalance() {
    if (isLeader.get() && nextTask.get() == null) {
        Future task = executorService.schedule(new BalanceTask(), schedulePeriod, TimeUnit.SECONDS);
        if (!nextTask.compareAndSet(null, task)) {
            task.cancel(false);
        }
    }
}
#method_after
// Sets flag at execution to indicate there is currently a scheduled
// rebalancing. As soon as it starts running, the flag is set back to
private void scheduleBalance() {
    if (isLeader.get() && nextTask.get() == null) {
        Future task = executorService.schedule(new BalanceTask(), schedulePeriod, TimeUnit.SECONDS);
        if (!nextTask.compareAndSet(null, task)) {
            task.cancel(false);
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    // nextTask is now running, free the spot for queueing an upcoming one.
    nextTask.set(null);
    mastershipAdminService.balanceRoles();
    log.info("Completed balance roles");
}
#method_after
@Override
public void run() {
    // nextTask is now running, free the spot so that it is possible
    // to queue up another upcoming task.
    nextTask.set(null);
    mastershipAdminService.balanceRoles();
    log.info("Completed balance roles");
}
#end_block

#method_before
@Override
public int hashCode() {
    return id;
}
#method_after
@Override
public int hashCode() {
    return identifier;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof DefaultGroupId)) {
        return false;
    }
    final DefaultGroupId other = (DefaultGroupId) obj;
    return Objects.equals(this.id, other.id);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof DefaultGroupId)) {
        return false;
    }
    final DefaultGroupId other = (DefaultGroupId) obj;
    return Objects.equals(this.identifier, other.identifier);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("id", "0x" + Integer.toHexString(id)).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("id", "0x" + Integer.toHexString(identifier)).toString();
}
#end_block

#method_before
@Override
public ObjectNode encode(Group group, CodecContext context) {
    checkNotNull(group, "Group cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put(ID, group.id().id().toString()).put(STATE, group.state().toString()).put(LIFE, group.life()).put(PACKETS, group.packets()).put(BYTES, group.bytes()).put(REFERENCE_COUNT, group.referenceCount()).put(TYPE, group.type().toString()).put(DEVICE_ID, group.deviceId().toString());
    if (group.appId() != null) {
        result.put(APP_ID, group.appId().name().toString());
    }
    if (group.appCookie() != null) {
        result.put(APP_COOKIE, group.appCookie().toString());
    }
    if (group.givenGroupId() != null) {
        result.put(GIVEN_GROUP_ID, group.givenGroupId().toString());
    }
    ArrayNode buckets = context.mapper().createArrayNode();
    group.buckets().buckets().forEach(bucket -> {
        ObjectNode bucketJson = context.codec(GroupBucket.class).encode(bucket, context);
        buckets.add(bucketJson);
    });
    result.set(BUCKETS, buckets);
    return result;
}
#method_after
@Override
public ObjectNode encode(Group group, CodecContext context) {
    checkNotNull(group, "Group cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put(ID, group.id().id().toString()).put(STATE, group.state().toString()).put(LIFE, group.life()).put(PACKETS, group.packets()).put(BYTES, group.bytes()).put(REFERENCE_COUNT, group.referenceCount()).put(TYPE, group.type().toString()).put(DEVICE_ID, group.deviceId().toString());
    if (group.appId() != null) {
        result.put(APP_ID, group.appId().name());
    }
    if (group.appCookie() != null) {
        result.put(APP_COOKIE, group.appCookie().toString());
    }
    if (group.givenGroupId() != null) {
        result.put(GIVEN_GROUP_ID, group.givenGroupId().toString());
    }
    ArrayNode buckets = context.mapper().createArrayNode();
    group.buckets().buckets().forEach(bucket -> {
        ObjectNode bucketJson = context.codec(GroupBucket.class).encode(bucket, context);
        buckets.add(bucketJson);
    });
    result.set(BUCKETS, buckets);
    return result;
}
#end_block

#method_before
@Override
public ExtensionTreatmentType type() {
    return null;
}
#method_after
@Override
public ExtensionTreatmentType type() {
    return ExtensionTreatmentType.ExtensionTreatmentTypes.UNRESOLVED_TYPE.type();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("bytes", bytes).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("bytes", bytes).add("unresolvedTreatmentType", unresolvedTreatmentType).toString();
}
#end_block

#method_before
@Override
public ExtensionCriterion read(Kryo kryo, Input input, Class<ExtensionCriterion> type) {
    ExtensionSelectorType exType = (ExtensionSelectorType) kryo.readClassAndObject(input);
    DeviceId deviceId = (DeviceId) kryo.readClassAndObject(input);
    DriverService driverService = DefaultServiceDirectory.getService(DriverService.class);
    boolean unresolved = false;
    try {
        driverService.getDriver(deviceId);
    } catch (ItemNotFoundException e) {
        unresolved = true;
    }
    byte[] bytes = (byte[]) kryo.readClassAndObject(input);
    ExtensionSelector selector;
    if (!unresolved) {
        DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driverService.getDriver(deviceId), deviceId));
        ExtensionSelectorResolver resolver = handler.behaviour(ExtensionSelectorResolver.class);
        selector = resolver.getExtensionSelector(exType);
        selector.deserialize(bytes);
    } else {
        selector = new UnresolvedExtensionSelector(bytes);
    }
    return Criteria.extension(selector, deviceId);
}
#method_after
@Override
public ExtensionCriterion read(Kryo kryo, Input input, Class<ExtensionCriterion> type) {
    ExtensionSelectorType exType = (ExtensionSelectorType) kryo.readClassAndObject(input);
    DeviceId deviceId = (DeviceId) kryo.readClassAndObject(input);
    DriverService driverService = DefaultServiceDirectory.getService(DriverService.class);
    byte[] bytes = (byte[]) kryo.readClassAndObject(input);
    ExtensionSelector selector;
    try {
        DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driverService.getDriver(deviceId), deviceId));
        ExtensionSelectorResolver resolver = handler.behaviour(ExtensionSelectorResolver.class);
        selector = resolver.getExtensionSelector(exType);
        selector.deserialize(bytes);
    } catch (ItemNotFoundException | IllegalArgumentException e) {
        selector = new UnresolvedExtensionSelector(bytes, exType);
    }
    return Criteria.extension(selector, deviceId);
}
#end_block

#method_before
@Override
public ExtensionSelectorType type() {
    return null;
}
#method_after
@Override
public ExtensionSelectorType type() {
    return ExtensionSelectorType.ExtensionSelectorTypes.UNRESOLVED_TYPE.type();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(type(), bytes);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(bytes);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(type().toString()).add("bytes", bytes).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(type().toString()).add("bytes", bytes).add("unresolvedSelectorType", unresolvedSelectorType).toString();
}
#end_block

#method_before
@Override
public Instructions.ExtensionInstructionWrapper read(Kryo kryo, Input input, Class<Instructions.ExtensionInstructionWrapper> type) {
    ExtensionTreatmentType exType = (ExtensionTreatmentType) kryo.readClassAndObject(input);
    DeviceId deviceId = (DeviceId) kryo.readClassAndObject(input);
    DriverService driverService = DefaultServiceDirectory.getService(DriverService.class);
    boolean unresolved = false;
    try {
        driverService.getDriver(deviceId);
    } catch (ItemNotFoundException e) {
        unresolved = true;
    }
    byte[] bytes = (byte[]) kryo.readClassAndObject(input);
    ExtensionTreatment instruction;
    if (!unresolved) {
        DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driverService.getDriver(deviceId), deviceId));
        ExtensionTreatmentResolver resolver = handler.behaviour(ExtensionTreatmentResolver.class);
        instruction = resolver.getExtensionInstruction(exType);
        instruction.deserialize(bytes);
    } else {
        instruction = new UnresolvedExtensionTreatment(bytes);
    }
    return Instructions.extension(instruction, deviceId);
}
#method_after
@Override
public Instructions.ExtensionInstructionWrapper read(Kryo kryo, Input input, Class<Instructions.ExtensionInstructionWrapper> type) {
    ExtensionTreatmentType exType = (ExtensionTreatmentType) kryo.readClassAndObject(input);
    DeviceId deviceId = (DeviceId) kryo.readClassAndObject(input);
    DriverService driverService = DefaultServiceDirectory.getService(DriverService.class);
    byte[] bytes = (byte[]) kryo.readClassAndObject(input);
    ExtensionTreatment instruction;
    try {
        DriverHandler handler = new DefaultDriverHandler(new DefaultDriverData(driverService.getDriver(deviceId), deviceId));
        ExtensionTreatmentResolver resolver = handler.behaviour(ExtensionTreatmentResolver.class);
        instruction = resolver.getExtensionInstruction(exType);
        instruction.deserialize(bytes);
    } catch (ItemNotFoundException | IllegalArgumentException e) {
        instruction = new UnresolvedExtensionTreatment(bytes, exType);
    }
    return Instructions.extension(instruction, deviceId);
}
#end_block

#method_before
public boolean none() {
    return devices().size() == 0 && hosts().size() == 0 && links().size() == 0;
}
#method_after
public boolean none() {
    return devices().isEmpty() && hosts().isEmpty() && links().isEmpty();
}
#end_block

#method_before
private Set<String> findLinks(Set<String> ids) {
    Set<String> unmatched = new HashSet<>();
    ConnectPoint cpSrc, cpDst;
    Link link;
    for (String id : ids) {
        try {
            String[] connectPoints = id.split("-");
            if (connectPoints == null || connectPoints.length != 2) {
                unmatched.add(id);
                continue;
            }
            cpSrc = ConnectPoint.deviceConnectPoint(connectPoints[0]);
            cpDst = ConnectPoint.deviceConnectPoint(connectPoints[1]);
            link = linkService.getLink(cpSrc, cpDst);
            if (link != null) {
                links.add(link);
            } else {
                unmatched.add(id);
            }
        } catch (Exception e) {
            unmatched.add(id);
        }
    }
    return unmatched;
}
#method_after
private Set<String> findLinks(Set<String> ids) {
    Set<String> unmatched = new HashSet<>();
    ConnectPoint cpSrc, cpDst;
    Link link;
    for (String id : ids) {
        try {
            String[] connectPoints = id.split(LINK_ID_DELIM);
            if (connectPoints.length != 2) {
                unmatched.add(id);
                continue;
            }
            cpSrc = deviceConnectPoint(connectPoints[0]);
            cpDst = deviceConnectPoint(connectPoints[1]);
            link = linkService.getLink(cpSrc, cpDst);
            if (link != null) {
                links.add(link);
            } else {
                unmatched.add(id);
            }
        } catch (Exception e) {
            unmatched.add(id);
        }
    }
    return unmatched;
}
#end_block

#method_before
@Override
public void addListener(DocumentPath path, DocumentTreeListener<V> listener) {
    backingMap.addListener(path, listener);
}
#method_after
@Override
public void addListener(DocumentPath path, DocumentTreeListener<V> listener) {
    complete(backingMap.addListener(path, listener));
}
#end_block

#method_before
@Override
public void removeListener(DocumentTreeListener<V> listener) {
    backingMap.removeListener(listener);
}
#method_after
@Override
public void removeListener(DocumentTreeListener<V> listener) {
    complete(backingMap.removeListener(listener));
}
#end_block

#method_before
@Override
public void addListener(DocumentTreeListener<V> listener) {
    backingMap.addListener(listener);
}
#method_after
@Override
public void addListener(DocumentTreeListener<V> listener) {
    complete(backingMap.addListener(listener));
}
#end_block

#method_before
@Override
public void notify(GroupEvent event) {
    assertEquals(expectedEvent, event.type());
    assertEquals(Group.Type.SELECT, event.subject().type());
    assertEquals(D1, event.subject().deviceId());
    assertEquals(createdGroupKey, event.subject().appCookie());
    assertEquals(createdBuckets.buckets(), event.subject().buckets().buckets());
    if (expectedEvent == GroupEvent.Type.GROUP_ADD_REQUESTED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_ADD, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_ADDED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.ADDED, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATED) {
        createdGroupId = event.subject().id();
        assertEquals(true, event.subject().buckets().buckets().containsAll(createdBuckets.buckets()));
        assertEquals(true, createdBuckets.buckets().containsAll(event.subject().buckets().buckets()));
        for (GroupBucket bucket : event.subject().buckets().buckets()) {
            Optional<GroupBucket> matched = createdBuckets.buckets().stream().filter((expected) -> expected.equals(bucket)).findFirst();
            assertEquals(matched.get().packets(), bucket.packets());
            assertEquals(matched.get().bytes(), bucket.bytes());
        }
        assertEquals(Group.GroupState.ADDED, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATE_REQUESTED) {
        assertEquals(Group.GroupState.PENDING_UPDATE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVE_REQUESTED) {
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_ADD_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_ADD, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATE_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_UPDATE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVE_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    }
}
#method_after
@Override
public void notify(GroupEvent event) {
    assertEquals(expectedEvent, event.type());
    assertEquals(Group.Type.SELECT, event.subject().type());
    assertEquals(D1, event.subject().deviceId());
    assertEquals(createdGroupKey, event.subject().appCookie());
    assertEquals(createdBuckets.buckets(), event.subject().buckets().buckets());
    if (expectedEvent == GroupEvent.Type.GROUP_ADD_REQUESTED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_ADD, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_ADDED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.ADDED, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATED) {
        createdGroupId = event.subject().id();
        assertEquals(true, event.subject().buckets().buckets().containsAll(createdBuckets.buckets()));
        assertEquals(true, createdBuckets.buckets().containsAll(event.subject().buckets().buckets()));
        for (GroupBucket bucket : event.subject().buckets().buckets()) {
            Optional<GroupBucket> matched = createdBuckets.buckets().stream().filter((expected) -> expected.equals(bucket)).findFirst();
            assertEquals(matched.get().packets(), bucket.packets());
            assertEquals(matched.get().bytes(), bucket.bytes());
        }
        assertEquals(Group.GroupState.ADDED, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATE_REQUESTED) {
        assertEquals(Group.GroupState.PENDING_UPDATE, event.subject().state());
        for (GroupBucket bucket : event.subject().buckets().buckets()) {
            Optional<GroupBucket> matched = createdBuckets.buckets().stream().filter((expected) -> expected.equals(bucket)).findFirst();
            assertEquals(matched.get().weight(), bucket.weight());
            assertEquals(matched.get().watchGroup(), bucket.watchGroup());
            assertEquals(matched.get().watchPort(), bucket.watchPort());
        }
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVE_REQUESTED) {
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_ADD_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_ADD, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_UPDATE_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_UPDATE, event.subject().state());
    } else if (expectedEvent == GroupEvent.Type.GROUP_REMOVE_FAILED) {
        createdGroupId = event.subject().id();
        assertEquals(Group.GroupState.PENDING_DELETE, event.subject().state());
    }
}
#end_block

#method_before
private void testAddBuckets(GroupKey currKey, GroupKey addKey) {
    Group existingGroup = simpleGroupStore.getGroup(D1, currKey);
    List<GroupBucket> buckets = new ArrayList<>();
    buckets.addAll(existingGroup.buckets().buckets());
    PortNumber[] newNeighborPorts = { PortNumber.portNumber(41), PortNumber.portNumber(42) };
    List<PortNumber> newOutPorts = new ArrayList<>();
    newOutPorts.addAll(Collections.singletonList(newNeighborPorts[0]));
    List<GroupBucket> toAddBuckets = new ArrayList<>();
    for (PortNumber portNumber : newOutPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:03")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(MplsLabel.mplsLabel(106));
        toAddBuckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets toAddGroupBuckets = new GroupBuckets(toAddBuckets);
    buckets.addAll(toAddBuckets);
    GroupBuckets updatedGroupBuckets = new GroupBuckets(buckets);
    InternalGroupStoreDelegate updateGroupDescDelegate = new InternalGroupStoreDelegate(addKey, updatedGroupBuckets, GroupEvent.Type.GROUP_UPDATE_REQUESTED);
    simpleGroupStore.setDelegate(updateGroupDescDelegate);
    simpleGroupStore.updateGroupDescription(D1, currKey, UpdateType.ADD, toAddGroupBuckets, addKey);
    simpleGroupStore.unsetDelegate(updateGroupDescDelegate);
}
#method_after
private void testAddBuckets(GroupKey currKey, GroupKey addKey) {
    Group existingGroup = simpleGroupStore.getGroup(D1, currKey);
    List<GroupBucket> buckets = new ArrayList<>();
    buckets.addAll(existingGroup.buckets().buckets());
    PortNumber[] newNeighborPorts = { PortNumber.portNumber(41), PortNumber.portNumber(42) };
    List<PortNumber> newOutPorts = new ArrayList<>();
    newOutPorts.addAll(Collections.singletonList(newNeighborPorts[0]));
    List<GroupBucket> toAddBuckets = new ArrayList<>();
    for (PortNumber portNumber : newOutPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:03")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(MplsLabel.mplsLabel(106));
        toAddBuckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets toAddGroupBuckets = new GroupBuckets(toAddBuckets);
    buckets.addAll(toAddBuckets);
    GroupBuckets updatedGroupBuckets = new GroupBuckets(buckets);
    InternalGroupStoreDelegate updateGroupDescDelegate = new InternalGroupStoreDelegate(addKey, updatedGroupBuckets, GroupEvent.Type.GROUP_UPDATE_REQUESTED);
    simpleGroupStore.setDelegate(updateGroupDescDelegate);
    simpleGroupStore.updateGroupDescription(D1, currKey, UpdateType.ADD, toAddGroupBuckets, addKey);
    simpleGroupStore.unsetDelegate(updateGroupDescDelegate);
    short weight = 5;
    toAddBuckets = new ArrayList<>();
    for (PortNumber portNumber : newOutPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:03")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(MplsLabel.mplsLabel(106));
        toAddBuckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build(), weight));
    }
    toAddGroupBuckets = new GroupBuckets(toAddBuckets);
    buckets = new ArrayList<>();
    buckets.addAll(existingGroup.buckets().buckets());
    buckets.addAll(toAddBuckets);
    updatedGroupBuckets = new GroupBuckets(buckets);
    updateGroupDescDelegate = new InternalGroupStoreDelegate(addKey, updatedGroupBuckets, GroupEvent.Type.GROUP_UPDATE_REQUESTED);
    simpleGroupStore.setDelegate(updateGroupDescDelegate);
    simpleGroupStore.updateGroupDescription(D1, addKey, UpdateType.ADD, toAddGroupBuckets, addKey);
    simpleGroupStore.unsetDelegate(updateGroupDescDelegate);
}
#end_block

#method_before
private List<GroupBucket> getUpdatedBucketList(Group oldGroup, UpdateType type, GroupBuckets buckets) {
    GroupBuckets oldBuckets = oldGroup.buckets();
    List<GroupBucket> newBucketList = new ArrayList<>(oldBuckets.buckets());
    boolean groupDescUpdated = false;
    if (type == UpdateType.ADD) {
        // the old bucket list
        for (GroupBucket addBucket : buckets.buckets()) {
            if (!newBucketList.contains(addBucket)) {
                newBucketList.add(addBucket);
                groupDescUpdated = true;
            }
        }
    } else if (type == UpdateType.REMOVE) {
        // old bucket list
        for (GroupBucket removeBucket : buckets.buckets()) {
            if (newBucketList.contains(removeBucket)) {
                newBucketList.remove(removeBucket);
                groupDescUpdated = true;
            }
        }
    }
    if (groupDescUpdated) {
        return newBucketList;
    } else {
        return null;
    }
}
#method_after
private List<GroupBucket> getUpdatedBucketList(Group oldGroup, UpdateType type, GroupBuckets buckets) {
    List<GroupBucket> oldBuckets = oldGroup.buckets().buckets();
    List<GroupBucket> updatedBucketList = new ArrayList<>();
    boolean groupDescUpdated = false;
    if (type == UpdateType.ADD) {
        List<GroupBucket> newBuckets = buckets.buckets();
        // Add old buckets that will not be updated and check if any will be updated.
        for (GroupBucket oldBucket : oldBuckets) {
            int newBucketIndex = newBuckets.indexOf(oldBucket);
            if (newBucketIndex != -1) {
                GroupBucket newBucket = newBuckets.get(newBucketIndex);
                if (!newBucket.hasSameParameters(oldBucket)) {
                    // Bucket will be updated
                    groupDescUpdated = true;
                }
            } else {
                // Old bucket will remain the same - add it.
                updatedBucketList.add(oldBucket);
            }
        }
        // Add all new buckets
        updatedBucketList.addAll(newBuckets);
        if (!oldBuckets.containsAll(newBuckets)) {
            groupDescUpdated = true;
        }
    } else if (type == UpdateType.REMOVE) {
        List<GroupBucket> bucketsToRemove = buckets.buckets();
        // Check which old buckets should remain
        for (GroupBucket oldBucket : oldBuckets) {
            if (!bucketsToRemove.contains(oldBucket)) {
                updatedBucketList.add(oldBucket);
            } else {
                groupDescUpdated = true;
            }
        }
    }
    if (groupDescUpdated) {
        return updatedBucketList;
    } else {
        return null;
    }
}
#end_block

#method_before
private List<GroupBucket> getUpdatedBucketList(Group oldGroup, UpdateType type, GroupBuckets buckets) {
    GroupBuckets oldBuckets = oldGroup.buckets();
    List<GroupBucket> newBucketList = new ArrayList<>(oldBuckets.buckets());
    boolean groupDescUpdated = false;
    if (type == UpdateType.ADD) {
        // the old bucket list
        for (GroupBucket addBucket : buckets.buckets()) {
            if (!newBucketList.contains(addBucket)) {
                newBucketList.add(addBucket);
                groupDescUpdated = true;
            }
        }
    } else if (type == UpdateType.REMOVE) {
        // old bucket list
        for (GroupBucket removeBucket : buckets.buckets()) {
            if (newBucketList.contains(removeBucket)) {
                newBucketList.remove(removeBucket);
                groupDescUpdated = true;
            }
        }
    }
    if (groupDescUpdated) {
        return newBucketList;
    } else {
        return null;
    }
}
#method_after
private List<GroupBucket> getUpdatedBucketList(Group oldGroup, UpdateType type, GroupBuckets buckets) {
    List<GroupBucket> oldBuckets = oldGroup.buckets().buckets();
    List<GroupBucket> updatedBucketList = new ArrayList<>();
    boolean groupDescUpdated = false;
    if (type == UpdateType.ADD) {
        List<GroupBucket> newBuckets = buckets.buckets();
        // Add old buckets that will not be updated and check if any will be updated.
        for (GroupBucket oldBucket : oldBuckets) {
            int newBucketIndex = newBuckets.indexOf(oldBucket);
            if (newBucketIndex != -1) {
                GroupBucket newBucket = newBuckets.get(newBucketIndex);
                if (!newBucket.hasSameParameters(oldBucket)) {
                    // Bucket will be updated
                    groupDescUpdated = true;
                }
            } else {
                // Old bucket will remain the same - add it.
                updatedBucketList.add(oldBucket);
            }
        }
        // Add all new buckets
        updatedBucketList.addAll(newBuckets);
        if (!oldBuckets.containsAll(newBuckets)) {
            groupDescUpdated = true;
        }
    } else if (type == UpdateType.REMOVE) {
        List<GroupBucket> bucketsToRemove = buckets.buckets();
        // Check which old buckets should remain
        for (GroupBucket oldBucket : oldBuckets) {
            if (!bucketsToRemove.contains(oldBucket)) {
                updatedBucketList.add(oldBucket);
            } else {
                groupDescUpdated = true;
            }
        }
    }
    if (groupDescUpdated) {
        return updatedBucketList;
    } else {
        return null;
    }
}
#end_block

#method_before
private void purgeGroupEntries(Set<Entry<GroupStoreKeyMapKey, StoredGroupEntry>> entries) {
    entries.forEach(entry -> {
        groupStoreEntriesByKey.remove(entry.getKey());
        notifyDelegate(new GroupEvent(Type.GROUP_REMOVED, entry.getValue()));
    });
}
#method_after
private void purgeGroupEntries(Set<Entry<GroupStoreKeyMapKey, StoredGroupEntry>> entries) {
    entries.forEach(entry -> {
        groupStoreEntriesByKey.remove(entry.getKey());
    });
}
#end_block

#method_before
@Test
public void testUpdateGroupDescription() {
    GroupBuckets buckets = new GroupBuckets(ImmutableList.of(failoverGroupBucket));
    groupStore.deviceInitialAuditCompleted(deviceId1, true);
    groupStore.storeGroupDescription(groupDescription1);
    GroupKey newKey = new DefaultGroupKey("123".getBytes());
    groupStore.updateGroupDescription(deviceId1, groupKey1, ADD, buckets, newKey);
    Group group1 = groupStore.getGroup(deviceId1, groupId1);
    assertThat(group1.appCookie(), is(newKey));
    assertThat(group1.buckets().buckets(), hasSize(2));
}
#method_after
@Test
public void testUpdateGroupDescription() {
    GroupBuckets buckets = new GroupBuckets(ImmutableList.of(failoverGroupBucket, selectGroupBucket));
    groupStore.deviceInitialAuditCompleted(deviceId1, true);
    groupStore.storeGroupDescription(groupDescription1);
    GroupKey newKey = new DefaultGroupKey("123".getBytes());
    groupStore.updateGroupDescription(deviceId1, groupKey1, ADD, buckets, newKey);
    Group group1 = groupStore.getGroup(deviceId1, groupId1);
    assertThat(group1.appCookie(), is(newKey));
    assertThat(group1.buckets().buckets(), hasSize(2));
    short weight = 5;
    GroupBucket selectGroupBucketWithWeight = DefaultGroupBucket.createSelectGroupBucket(treatment, weight);
    buckets = new GroupBuckets(ImmutableList.of(failoverGroupBucket, selectGroupBucketWithWeight));
    groupStore.updateGroupDescription(deviceId1, newKey, ADD, buckets, newKey);
    group1 = groupStore.getGroup(deviceId1, groupId1);
    assertThat(group1.appCookie(), is(newKey));
    assertThat(group1.buckets().buckets(), hasSize(2));
    for (GroupBucket bucket : group1.buckets().buckets()) {
        if (bucket.type() == SELECT) {
            assertEquals(weight, bucket.weight());
        }
    }
}
#end_block

#method_before
@Override
public void createPort(String bridgeName, String portName) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.error("Can't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return;
    }
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    String portUuid = getPortUuid(portName, bridgeUuid);
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    port.setName(portName);
    /**
     * there is nothing for updates to do in this interface.
     */
    if (portUuid == null) {
        insertConfig(PORT, UUID, BRIDGE, PORTS, bridgeUuid, port.getRow());
    }
}
#method_after
@Override
public void createPort(String bridgeName, String portName) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.error("Can't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return;
    }
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    String portUuid = getPortUuid(portName, bridgeUuid);
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    port.setName(portName);
    if (portUuid == null) {
        insertConfig(PORT, UUID, BRIDGE, PORTS, bridgeUuid, port.getRow());
    }
}
#end_block

#method_before
private TrafficSelector buildSelector(MacAddress ingressMac, MacAddress egressMac, Short ethertype, VlanId ingresstag) {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthSrc(ingressMac);
    selectorBuilder.matchEthDst(egressMac);
    if (ethertype != null) {
        selectorBuilder.matchEthType(ethertype);
    }
    if (ingresstag != null) {
        selectorBuilder.matchVlanId(ingresstag);
    }
    return selectorBuilder.build();
}
#method_after
protected TrafficSelector buildSelector(MacAddress ingressMac, MacAddress egressMac, Short etherType, VlanId ingressTag) {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthSrc(ingressMac);
    selectorBuilder.matchEthDst(egressMac);
    if (etherType != null) {
        selectorBuilder.matchEthType(etherType);
    }
    if (ingressTag != null) {
        selectorBuilder.matchVlanId(ingressTag);
    }
    return selectorBuilder.build();
}
#end_block

#method_before
private Key generateIntentKey(String sdxl2, SdxL2ConnectionPoint cpOne, SdxL2ConnectionPoint cpTwo, String index) {
    String cps = format(NAME_FORMAT, sdxl2, cpOne.name(), cpTwo.name());
    String key = format(KEY_FORMAT, cps, index);
    return Key.of(key, APPID);
}
#method_after
private Key generateIntentKey(String sdxl2, SdxL2ConnectionPoint cpOne, SdxL2ConnectionPoint cpTwo, String index) {
    return manager.generateIntentKey(sdxl2, cpOne, cpTwo, index);
}
#end_block

#method_before
@Test
public void testRemoveVCbyCP() {
    testConnectionSetup();
    List<PointToPointIntent> removedIntents = new ArrayList<>();
    SdxL2ConnectionPoint cpone = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST1", CP1, VLANS1);
    removedIntents.addAll(setupConnectionPoints1To2());
    SdxL2ConnectionPoint cpsix = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST6", CP6, VLANS6);
    removedIntents.addAll(setupConnectionPoints5To6());
    SdxL2ConnectionPoint cpseven = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST7", CP7, VLANS7);
    removedIntents.addAll(setupConnectionPoints7To8());
    SdxL2ConnectionPoint cpten = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST10", CP10, VLANS10);
    removedIntents.addAll(setupConnectionPoints9To10());
    manager.removeVC(cpone);
    manager.removeVC(cpsix);
    manager.removeVC(cpseven);
    manager.removeVC(cpten);
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.ofNullable(null)));
    assertEquals(0, manager.intentService.getIntentCount());
    for (Intent removedIntent : removedIntents) {
        boolean found = false;
        for (Intent existingIntent : manager.intentService.getIntents()) {
            if (removedIntent.key().equals(existingIntent.key())) {
                found = true;
                assertTrue(format("Intent %s equal %s", removedIntent, existingIntent), !IntentUtils.intentsAreEqual(removedIntent, existingIntent));
                break;
            }
        }
        assertTrue(!found);
    }
}
#method_after
@Test
public void testRemoveVCbyCP() {
    testConnectionSetup();
    List<PointToPointIntent> removedIntents = new ArrayList<>();
    SdxL2ConnectionPoint cpone = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST1", CP1, VLANS1);
    removedIntents.addAll(setupConnectionPoints1To2());
    SdxL2ConnectionPoint cpsix = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST6", CP6, VLANS6);
    removedIntents.addAll(setupConnectionPoints5To6());
    SdxL2ConnectionPoint cpseven = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST7", CP7, VLANS7);
    removedIntents.addAll(setupConnectionPoints7To8());
    SdxL2ConnectionPoint cpten = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST10", CP10, VLANS10);
    removedIntents.addAll(setupConnectionPoints9To10());
    manager.removeVC(cpone);
    manager.removeVC(cpsix);
    manager.removeVC(cpseven);
    manager.removeVC(cpten);
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.empty()));
    assertEquals(0, manager.intentService.getIntentCount());
    for (Intent removedIntent : removedIntents) {
        boolean found = false;
        for (Intent existingIntent : manager.intentService.getIntents()) {
            if (removedIntent.key().equals(existingIntent.key())) {
                found = true;
                assertTrue(format("Intent %s equal %s", removedIntent, existingIntent), !IntentUtils.intentsAreEqual(removedIntent, existingIntent));
                break;
            }
        }
        assertTrue(!found);
    }
}
#end_block

#method_before
@Test
public void testRemoveVCbySdx() {
    testConnectionSetup();
    List<PointToPointIntent> removedIntents = new ArrayList<>();
    removedIntents.addAll(setupConnectionPoints1To2());
    removedIntents.addAll(setupConnectionPoints5To6());
    removedIntents.addAll(setupConnectionPoints7To8());
    removedIntents.addAll(setupConnectionPoints9To10());
    manager.removeVCs(SDXL2_2);
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.ofNullable(null)));
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.of(SDXL2_2)));
    for (Intent removedIntent : removedIntents) {
        boolean found = false;
        for (Intent existingIntent : manager.intentService.getIntents()) {
            if (removedIntent.key().equals(existingIntent.key())) {
                found = true;
                assertTrue(format("Intent %s equal %s", removedIntent, existingIntent), !IntentUtils.intentsAreEqual(removedIntent, existingIntent));
                break;
            }
        }
        assertTrue(!found);
    }
}
#method_after
@Test
public void testRemoveVCbySdx() {
    testConnectionSetup();
    List<PointToPointIntent> removedIntents = new ArrayList<>();
    removedIntents.addAll(setupConnectionPoints1To2());
    removedIntents.addAll(setupConnectionPoints5To6());
    removedIntents.addAll(setupConnectionPoints7To8());
    removedIntents.addAll(setupConnectionPoints9To10());
    manager.removeVCs(SDXL2_2);
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.empty()));
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.of(SDXL2_2)));
    for (Intent removedIntent : removedIntents) {
        boolean found = false;
        for (Intent existingIntent : manager.intentService.getIntents()) {
            if (removedIntent.key().equals(existingIntent.key())) {
                found = true;
                assertTrue(format("Intent %s equal %s", removedIntent, existingIntent), !IntentUtils.intentsAreEqual(removedIntent, existingIntent));
                break;
            }
        }
        assertTrue(!found);
    }
}
#end_block

#method_before
private Key generateIntentKey(String sdxl2, SdxL2ConnectionPoint cpone, SdxL2ConnectionPoint cptwo, String index) {
    String cps = format(NAME_FORMAT, sdxl2, cpone.name(), cptwo.name());
    String key = format(KEY_FORMAT, cps, index);
    return Key.of(key, APPID);
}
#method_after
private Key generateIntentKey(String sdxl2, SdxL2ConnectionPoint cpOne, SdxL2ConnectionPoint cpTwo, String index) {
    return manager.generateIntentKey(sdxl2, cpOne, cpTwo, index);
}
#end_block

#method_before
@Test
public void testRemoveVCbyCP() {
    testConnectionSetup();
    List<PointToPointIntent> removedIntents = new ArrayList<>();
    SdxL2ConnectionPoint cpone = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST1", CP1, VLANS1);
    removedIntents.addAll(setupConnectionPoints1To2());
    SdxL2ConnectionPoint cpsix = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST6", CP6, VLANS6);
    removedIntents.addAll(setupConnectionPoints5To6());
    SdxL2ConnectionPoint cpseven = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST7", CP7, VLANS7);
    removedIntents.addAll(setupConnectionPoints7To8());
    SdxL2ConnectionPoint cpten = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST10", CP10, VLANS10);
    removedIntents.addAll(setupConnectionPoints9To10());
    manager.removeVC(cpone);
    manager.removeVC(cpsix);
    manager.removeVC(cpseven);
    manager.removeVC(cpten);
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.ofNullable(null)));
    assertEquals(0, manager.intentService.getIntentCount());
    for (Intent removedIntent : removedIntents) {
        boolean found = false;
        for (Intent existingIntent : manager.intentService.getIntents()) {
            if (removedIntent.key().equals(existingIntent.key())) {
                found = true;
                assertTrue(format("Intent %s equal %s", removedIntent, existingIntent), !IntentUtils.intentsAreEqual(removedIntent, existingIntent));
                break;
            }
        }
        assertTrue(!found);
    }
}
#method_after
@Test
public void testRemoveVCbyCP() {
    testConnectionSetup();
    List<PointToPointIntent> removedIntents = new ArrayList<>();
    SdxL2ConnectionPoint cpone = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST1", CP1, VLANS1);
    removedIntents.addAll(setupConnectionPoints1To2());
    SdxL2ConnectionPoint cpsix = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST6", CP6, VLANS6);
    removedIntents.addAll(setupConnectionPoints5To6());
    SdxL2ConnectionPoint cpseven = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST7", CP7, VLANS7);
    removedIntents.addAll(setupConnectionPoints7To8());
    SdxL2ConnectionPoint cpten = SdxL2ConnectionPoint.sdxl2ConnectionPoint("TEST10", CP10, VLANS10);
    removedIntents.addAll(setupConnectionPoints9To10());
    manager.removeVC(cpone);
    manager.removeVC(cpsix);
    manager.removeVC(cpseven);
    manager.removeVC(cpten);
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.empty()));
    assertEquals(0, manager.intentService.getIntentCount());
    for (Intent removedIntent : removedIntents) {
        boolean found = false;
        for (Intent existingIntent : manager.intentService.getIntents()) {
            if (removedIntent.key().equals(existingIntent.key())) {
                found = true;
                assertTrue(format("Intent %s equal %s", removedIntent, existingIntent), !IntentUtils.intentsAreEqual(removedIntent, existingIntent));
                break;
            }
        }
        assertTrue(!found);
    }
}
#end_block

#method_before
@Test
public void testremoveVCbySdx() {
    testConnectionSetup();
    List<PointToPointIntent> removedIntents = new ArrayList<>();
    removedIntents.addAll(setupConnectionPoints1To2());
    removedIntents.addAll(setupConnectionPoints5To6());
    removedIntents.addAll(setupConnectionPoints7To8());
    removedIntents.addAll(setupConnectionPoints9To10());
    manager.removeVCs(SDXL2_2);
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.ofNullable(null)));
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.of(SDXL2_2)));
    for (Intent removedIntent : removedIntents) {
        boolean found = false;
        for (Intent existingIntent : manager.intentService.getIntents()) {
            if (removedIntent.key().equals(existingIntent.key())) {
                found = true;
                assertTrue(format("Intent %s equal %s", removedIntent, existingIntent), !IntentUtils.intentsAreEqual(removedIntent, existingIntent));
                break;
            }
        }
        assertTrue(!found);
    }
}
#method_after
@Test
public void testremoveVCbySdx() {
    testConnectionSetup();
    List<PointToPointIntent> removedIntents = new ArrayList<>();
    removedIntents.addAll(setupConnectionPoints1To2());
    removedIntents.addAll(setupConnectionPoints5To6());
    removedIntents.addAll(setupConnectionPoints7To8());
    removedIntents.addAll(setupConnectionPoints9To10());
    manager.removeVCs(SDXL2_2);
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.empty()));
    assertEquals(Collections.emptySet(), manager.getVCs(Optional.of(SDXL2_2)));
    for (Intent removedIntent : removedIntents) {
        boolean found = false;
        for (Intent existingIntent : manager.intentService.getIntents()) {
            if (removedIntent.key().equals(existingIntent.key())) {
                found = true;
                assertTrue(format("Intent %s equal %s", removedIntent, existingIntent), !IntentUtils.intentsAreEqual(removedIntent, existingIntent));
                break;
            }
        }
        assertTrue(!found);
    }
}
#end_block

#method_before
@Test
public /**
 * Tests proper cleaning of all SDX-L2 related information.
 */
void testCleanSdxL2s() {
    manager.createSdxL2(SDXL2);
    SdxL2ConnectionPoint one = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint two = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM2", CP2, VLANS2, CEMAC2);
    manager.addSdxL2ConnectionPoint(SDXL2, one);
    manager.addSdxL2ConnectionPoint(SDXL2, two);
    manager.getSdxL2ConnectionPoint("ROM1");
    assertTrue(manager.getSdxL2s().contains(SDXL2));
    assertEquals(one, manager.getSdxL2ConnectionPoint(one.name()));
    assertEquals(two, manager.getSdxL2ConnectionPoint(two.name()));
    manager.cleanSdxL2();
    assertFalse(manager.getSdxL2s().contains(SDXL2));
    assertEquals(null, manager.getSdxL2ConnectionPoint(one.name()));
    assertEquals(null, manager.getSdxL2ConnectionPoint(two.name()));
}
#method_after
@Test
public void testCleanSdxL2s() {
    manager.createSdxL2(SDXL2);
    SdxL2ConnectionPoint one = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint two = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM2", CP2, VLANS2, CEMAC2);
    manager.addSdxL2ConnectionPoint(SDXL2, one);
    manager.addSdxL2ConnectionPoint(SDXL2, two);
    manager.getSdxL2ConnectionPoint("ROM1");
    assertTrue(manager.getSdxL2s().contains(SDXL2));
    assertEquals(one, manager.getSdxL2ConnectionPoint(one.name()));
    assertEquals(two, manager.getSdxL2ConnectionPoint(two.name()));
    manager.cleanSdxL2();
    assertFalse(manager.getSdxL2s().contains(SDXL2));
    assertEquals(null, manager.getSdxL2ConnectionPoint(one.name()));
    assertEquals(null, manager.getSdxL2ConnectionPoint(two.name()));
}
#end_block

#method_before
@Test
public void testGetVC() {
    manager.createSdxL2(SDXL2);
    manager.createSdxL2(SDXL2_2);
    SdxL2ConnectionPoint one = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint two = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM2", CP2, VLANS2, CEMAC2);
    SdxL2ConnectionPoint three = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM3", CP1, VLANS7, CEMAC3);
    SdxL2ConnectionPoint four = SdxL2ConnectionPoint.sdxl2ConnectionPoint("MI3", CP3, VLANS3, CEMAC4);
    SdxL2ConnectionPoint five = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP4, VLANS8, CEMAC5);
    SdxL2ConnectionPoint six = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI2", CP5, VLANS2, CEMAC6);
    SdxL2ConnectionPoint seven = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI23", CP6, VLANS6, CEMAC7);
    SdxL2ConnectionPoint eight = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI24", CP7, VLANS5, CEMAC8);
    SdxL2ConnectionPoint nine = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI25", CP8, VLANS5, CEMAC8);
    String vc;
    VirtualCircuit expectedVC;
    VirtualCircuit actualVC;
    manager.addSdxL2ConnectionPoint(SDXL2, one);
    manager.addSdxL2ConnectionPoint(SDXL2, two);
    manager.addSdxL2ConnectionPoint(SDXL2_2, three);
    manager.addSdxL2ConnectionPoint(SDXL2, four);
    manager.addSdxL2ConnectionPoint(SDXL2_2, five);
    manager.addSdxL2ConnectionPoint(SDXL2, six);
    manager.addSdxL2ConnectionPoint(SDXL2, seven);
    manager.addSdxL2ConnectionPoint(SDXL2, eight);
    manager.addSdxL2ConnectionPoint(SDXL2, nine);
    // VC created using the manager, check against manually generates
    manager.addVC(SDXL2, two.name(), six.name());
    vc = two.name().compareTo(six.name()) < 0 ? format(SdxL2VCManager.NAME_FORMAT, SDXL2, two.name(), six.name()) : format(SdxL2VCManager.NAME_FORMAT, SDXL2, six.name(), two.name());
    expectedVC = new VirtualCircuit(two, six);
    actualVC = manager.getVirtualCircuit(vc);
    assertEquals(expectedVC, actualVC);
    // VC not created, check that getVC returns null if VC does not exist
    vc = one.name().compareTo(two.name()) < 0 ? format(SdxL2VCManager.NAME_FORMAT, SDXL2, one.name(), two.name()) : format(SdxL2VCManager.NAME_FORMAT, SDXL2, two.name(), one.name());
    expectedVC = new VirtualCircuit(one, two);
    actualVC = manager.getVirtualCircuit(vc);
    assertNotEquals(expectedVC, actualVC);
    assertNull(actualVC);
    // Testing illegal character
    exceptionGetVC.expect(IllegalStateException.class);
    manager.getVirtualCircuit(":A");
    manager.getVirtualCircuit("A:B");
}
#method_after
@Test
public void testGetVC() {
    manager.createSdxL2(SDXL2);
    manager.createSdxL2(SDXL2_2);
    SdxL2ConnectionPoint one = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint two = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM2", CP2, VLANS2, CEMAC2);
    SdxL2ConnectionPoint three = SdxL2ConnectionPoint.sdxl2ConnectionPoint("ROM3", CP1, VLANS7, CEMAC3);
    SdxL2ConnectionPoint four = SdxL2ConnectionPoint.sdxl2ConnectionPoint("MI3", CP3, VLANS3, CEMAC4);
    SdxL2ConnectionPoint five = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP4, VLANS8, CEMAC5);
    SdxL2ConnectionPoint six = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI2", CP5, VLANS2, CEMAC6);
    SdxL2ConnectionPoint seven = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI23", CP6, VLANS6, CEMAC7);
    SdxL2ConnectionPoint eight = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI24", CP7, VLANS5, CEMAC8);
    SdxL2ConnectionPoint nine = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI25", CP8, VLANS5, CEMAC8);
    String vc;
    VirtualCircuit expectedVC;
    VirtualCircuit actualVC;
    manager.addSdxL2ConnectionPoint(SDXL2, one);
    manager.addSdxL2ConnectionPoint(SDXL2, two);
    manager.addSdxL2ConnectionPoint(SDXL2_2, three);
    manager.addSdxL2ConnectionPoint(SDXL2, four);
    manager.addSdxL2ConnectionPoint(SDXL2_2, five);
    manager.addSdxL2ConnectionPoint(SDXL2, six);
    manager.addSdxL2ConnectionPoint(SDXL2, seven);
    manager.addSdxL2ConnectionPoint(SDXL2, eight);
    manager.addSdxL2ConnectionPoint(SDXL2, nine);
    // VC created using the manager, check against manually generated
    manager.addVC(SDXL2, two.name(), six.name());
    vc = two.name().compareTo(six.name()) < 0 ? format(SdxL2VCManager.NAME_FORMAT, SDXL2, two.name(), six.name()) : format(SdxL2VCManager.NAME_FORMAT, SDXL2, six.name(), two.name());
    expectedVC = new VirtualCircuit(two, six);
    actualVC = manager.getVirtualCircuit(vc);
    assertEquals(expectedVC, actualVC);
    // VC not created, check that getVC returns null if VC does not exist
    vc = one.name().compareTo(two.name()) < 0 ? format(SdxL2VCManager.NAME_FORMAT, SDXL2, one.name(), two.name()) : format(SdxL2VCManager.NAME_FORMAT, SDXL2, two.name(), one.name());
    expectedVC = new VirtualCircuit(one, two);
    actualVC = manager.getVirtualCircuit(vc);
    assertNotEquals(expectedVC, actualVC);
    assertNull(actualVC);
    // Testing illegal character
    exceptionGetVC.expect(IllegalStateException.class);
    manager.getVirtualCircuit(":A");
    manager.getVirtualCircuit("A:B");
}
#end_block

#method_before
@Override
protected void execute() {
    SdxL2Service sdxl2Service = get(SdxL2Service.class);
    VirtualCircuit virtualCircuit;
    SdxL2ConnectionPoint sdxl2ConnectionPoint;
    SdxL2State state;
    virtualCircuit = sdxl2Service.getVirtualCircuit(sdxl2vcname);
    if (virtualCircuit == null) {
        return;
    }
    print(HEADER_CP);
    print(SEPARATOR_CP);
    sdxl2ConnectionPoint = virtualCircuit.lhs();
    state = sdxl2Service.getEdgePortState(sdxl2ConnectionPoint.connectPoint());
    if (state == SdxL2State.ONLINE) {
        print(FORMAT_SDXL2CP_ONLINE, "ONLINE", sdxl2ConnectionPoint.connectPoint().elementId(), sdxl2ConnectionPoint.connectPoint().port(), sdxl2ConnectionPoint.name(), sdxl2ConnectionPoint.vlanIds(), sdxl2ConnectionPoint.macAddress());
    } else if (state == SdxL2State.OFFLINE) {
        print(FORMAT_SDXL2CP_OFFLINE, "OFFLINE", sdxl2ConnectionPoint.connectPoint().elementId(), sdxl2ConnectionPoint.connectPoint().port(), sdxl2ConnectionPoint.name(), sdxl2ConnectionPoint.vlanIds(), sdxl2ConnectionPoint.macAddress());
    }
    sdxl2ConnectionPoint = virtualCircuit.rhs();
    state = sdxl2Service.getEdgePortState(sdxl2ConnectionPoint.connectPoint());
    if (state == SdxL2State.ONLINE) {
        print(FORMAT_SDXL2CP_ONLINE, "ONLINE", sdxl2ConnectionPoint.connectPoint().elementId(), sdxl2ConnectionPoint.connectPoint().port(), sdxl2ConnectionPoint.name(), sdxl2ConnectionPoint.vlanIds(), sdxl2ConnectionPoint.macAddress());
    } else if (state == SdxL2State.OFFLINE) {
        print(FORMAT_SDXL2CP_OFFLINE, "OFFLINE", sdxl2ConnectionPoint.connectPoint().elementId(), sdxl2ConnectionPoint.connectPoint().port(), sdxl2ConnectionPoint.name(), sdxl2ConnectionPoint.vlanIds(), sdxl2ConnectionPoint.macAddress());
    }
    print("");
    print(HEADER_VC);
    print(SEPARATOR_VC);
    IntentService intentService = get(IntentService.class);
    Iterator<Intent> intents = Iterables.filter(intentService.getIntents(), intent -> (sdxl2Service.matchesIntent(virtualCircuit.lhs(), virtualCircuit.rhs(), intent) || (sdxl2Service.matchesIntent(virtualCircuit.rhs(), virtualCircuit.lhs(), intent)))).iterator();
    Intent intent;
    Key key;
    while (intents.hasNext()) {
        intent = intents.next();
        key = intent.key();
        state = sdxl2Service.getIntentState(key);
        if (state == SdxL2State.ONLINE) {
            print(FORMAT_SDXL2VC_ONLINE, "ONLINE", key);
        } else if (state == SdxL2State.OFFLINE) {
            print(FORMAT_SDXL2VC_OFFLINE, "OFFLINE", key);
        } else {
            print(FORMAT_SDXL2VC_CHECK, "CHECK", key);
        }
    }
    print("");
}
#method_after
@Override
protected void execute() {
    SdxL2Service sdxl2Service = get(SdxL2Service.class);
    SdxL2ConnectionPointMatcher matcher = new SdxL2ConnectionPointMatcher();
    VirtualCircuit virtualCircuit;
    SdxL2ConnectionPoint sdxl2ConnectionPoint;
    SdxL2State state;
    virtualCircuit = sdxl2Service.getVirtualCircuit(sdxl2vcname);
    if (virtualCircuit == null) {
        return;
    }
    print(HEADER_CP);
    print(SEPARATOR_CP);
    sdxl2ConnectionPoint = virtualCircuit.lhs();
    state = sdxl2Service.getEdgePortState(sdxl2ConnectionPoint.connectPoint());
    if (state == SdxL2State.ONLINE) {
        print(FORMAT_SDXL2CP_ONLINE, "ONLINE", sdxl2ConnectionPoint.connectPoint().elementId(), sdxl2ConnectionPoint.connectPoint().port(), sdxl2ConnectionPoint.name(), sdxl2ConnectionPoint.vlanIds(), sdxl2ConnectionPoint.macAddress());
    } else if (state == SdxL2State.OFFLINE) {
        print(FORMAT_SDXL2CP_OFFLINE, "OFFLINE", sdxl2ConnectionPoint.connectPoint().elementId(), sdxl2ConnectionPoint.connectPoint().port(), sdxl2ConnectionPoint.name(), sdxl2ConnectionPoint.vlanIds(), sdxl2ConnectionPoint.macAddress());
    }
    sdxl2ConnectionPoint = virtualCircuit.rhs();
    state = sdxl2Service.getEdgePortState(sdxl2ConnectionPoint.connectPoint());
    if (state == SdxL2State.ONLINE) {
        print(FORMAT_SDXL2CP_ONLINE, "ONLINE", sdxl2ConnectionPoint.connectPoint().elementId(), sdxl2ConnectionPoint.connectPoint().port(), sdxl2ConnectionPoint.name(), sdxl2ConnectionPoint.vlanIds(), sdxl2ConnectionPoint.macAddress());
    } else if (state == SdxL2State.OFFLINE) {
        print(FORMAT_SDXL2CP_OFFLINE, "OFFLINE", sdxl2ConnectionPoint.connectPoint().elementId(), sdxl2ConnectionPoint.connectPoint().port(), sdxl2ConnectionPoint.name(), sdxl2ConnectionPoint.vlanIds(), sdxl2ConnectionPoint.macAddress());
    }
    print("");
    print(HEADER_VC);
    print(SEPARATOR_VC);
    IntentService intentService = get(IntentService.class);
    Iterator<Intent> intents = Iterables.filter(intentService.getIntents(), intent -> (matcher.matches(virtualCircuit.lhs(), virtualCircuit.rhs(), intent) || (matcher.matches(virtualCircuit.rhs(), virtualCircuit.lhs(), intent)))).iterator();
    Intent intent;
    Key key;
    while (intents.hasNext()) {
        intent = intents.next();
        key = intent.key();
        state = sdxl2Service.getIntentState(key);
        if (state == SdxL2State.ONLINE) {
            print(FORMAT_SDXL2VC_ONLINE, "ONLINE", key);
        } else if (state == SdxL2State.OFFLINE) {
            print(FORMAT_SDXL2VC_OFFLINE, "OFFLINE", key);
        } else {
            print(FORMAT_SDXL2VC_CHECK, "CHECK", key);
        }
    }
    print("");
}
#end_block

#method_before
@Override
public void removeSdxL2(String sdxl2) throws SdxL2Exception {
    boolean removed = sdxL2s.remove(sdxl2);
    if (!removed) {
        throw new SdxL2Exception(String.format(ERROR_SDX_REMOVE, sdxl2));
    }
    Set<Map.Entry<SdxL2ConnectionPoint, String>> toRemove = sdxL2CPs.entrySet().parallelStream().filter(key_value -> {
        String sdxl2Temp = key_value.getValue();
        return sdxl2Temp.equals(sdxl2);
    }).collect(Collectors.toSet());
    toRemove.forEach(key_value -> sdxL2CPs.remove(key_value.getKey()));
}
#method_after
@Override
public void removeSdxL2(String sdxl2) throws SdxL2Exception {
    boolean removed = sdxL2s.remove(sdxl2);
    if (!removed) {
        throw new SdxL2Exception(String.format(ERROR_SDX_REMOVE, sdxl2));
    }
    // Removes CPs
    Set<Map.Entry<SdxL2ConnectionPoint, String>> cpsToRemove = sdxL2CPs.entrySet().parallelStream().filter(key_value -> {
        String sdxl2Temp = key_value.getValue();
        return sdxl2Temp.equals(sdxl2);
    }).collect(Collectors.toSet());
    cpsToRemove.forEach(key_value -> sdxL2CPs.remove(key_value.getKey()));
}
#end_block

#method_before
@Override
public void addSdxL2ConnectionPoint(String sdxl2, SdxL2ConnectionPoint connectionPoint) throws SdxL2Exception {
    boolean exist = sdxL2s.contains(sdxl2);
    String errorMissingSdxL2 = String.format(ERROR_SDX_ADD_CP_MISSING, connectionPoint.name(), sdxl2);
    if (!exist) {
        throw new SdxL2Exception(errorMissingSdxL2);
    }
    Set<SdxL2ConnectionPoint> sdxl2cpsTemp = ImmutableSet.copyOf(sdxL2CPs.keySet());
    Set<SdxL2ConnectionPoint> sdxl2cpsTempByName = sdxl2cpsTemp.parallelStream().filter(sdxl2cpTemp -> sdxl2cpTemp.name().equals(connectionPoint.name())).collect(Collectors.toSet());
    if (sdxl2cpsTempByName.size() != 0) {
        throw new SdxL2Exception(String.format(ERROR_SDX_ADD_CP_NAME, connectionPoint.name()));
    }
    Set<SdxL2ConnectionPoint> sdxl2cpsByCP = sdxl2cpsTemp.parallelStream().filter(sdxl2cpTemp -> sdxl2cpTemp.connectPoint().equals(connectionPoint.connectPoint())).collect(Collectors.toSet());
    String tempName;
    List<VlanId> vlans = connectionPoint.vlanIds();
    for (VlanId vlanId : vlans) {
        Set<SdxL2ConnectionPoint> sdxl2cpsByVlan = sdxl2cpsByCP.parallelStream().filter(sdxl2cp_by_vlan -> (sdxl2cp_by_vlan.vlanIds().contains(vlanId) || sdxl2cp_by_vlan.vlanIds().size() == 0)).collect(Collectors.toSet());
        tempName = sdxl2cpsByVlan.iterator().hasNext() ? sdxl2cpsByVlan.iterator().next().name() : null;
        if (sdxl2cpsByVlan.size() != 0) {
            throw new SdxL2Exception(String.format(ERROR_SDX_ADD_CP_VLANS, connectionPoint.name(), tempName));
        }
    }
    tempName = sdxl2cpsByCP.iterator().hasNext() ? sdxl2cpsByCP.iterator().next().name() : null;
    if (sdxl2cpsByCP.size() != 0 && vlans.size() == 0) {
        throw new SdxL2Exception(String.format(ERROR_SDX_ADD_CP_EXISTING, connectionPoint.name(), tempName));
    }
    sdxL2CPs.put(connectionPoint, sdxl2);
}
#method_after
@Override
public void addSdxL2ConnectionPoint(String sdxl2, SdxL2ConnectionPoint connectionPoint) throws SdxL2Exception {
    boolean exist = sdxL2s.contains(sdxl2);
    String errorMissingSdxL2 = String.format(ERROR_SDX_ADD_CP_MISSING, connectionPoint.name(), sdxl2);
    if (!exist) {
        throw new SdxL2Exception(errorMissingSdxL2);
    }
    Set<SdxL2ConnectionPoint> sdxl2cpsTemp = ImmutableSet.copyOf(sdxL2CPs.keySet());
    Set<SdxL2ConnectionPoint> sdxl2cpsTempByName = sdxl2cpsTemp.parallelStream().filter(sdxl2cpTemp -> sdxl2cpTemp.name().equals(connectionPoint.name())).collect(Collectors.toSet());
    if (!sdxl2cpsTempByName.isEmpty()) {
        throw new SdxL2Exception(String.format(ERROR_SDX_ADD_CP_NAME, connectionPoint.name()));
    }
    Set<SdxL2ConnectionPoint> sdxl2cpsByCP = sdxl2cpsTemp.parallelStream().filter(sdxl2cpTemp -> sdxl2cpTemp.connectPoint().equals(connectionPoint.connectPoint())).collect(Collectors.toSet());
    String tempName;
    List<VlanId> vlans = connectionPoint.vlanIds();
    for (VlanId vlanId : vlans) {
        Set<SdxL2ConnectionPoint> sdxl2cpsByVlan = sdxl2cpsByCP.parallelStream().filter(sdxl2cp_by_vlan -> (sdxl2cp_by_vlan.vlanIds().contains(vlanId) || sdxl2cp_by_vlan.vlanIds().size() == 0)).collect(Collectors.toSet());
        tempName = sdxl2cpsByVlan.iterator().hasNext() ? sdxl2cpsByVlan.iterator().next().name() : null;
        if (!sdxl2cpsByVlan.isEmpty()) {
            throw new SdxL2Exception(String.format(ERROR_SDX_ADD_CP_VLANS, connectionPoint.name(), tempName));
        }
    }
    tempName = sdxl2cpsByCP.iterator().hasNext() ? sdxl2cpsByCP.iterator().next().name() : null;
    if (!sdxl2cpsByCP.isEmpty() && vlans.size() == 0) {
        throw new SdxL2Exception(String.format(ERROR_SDX_ADD_CP_EXISTING, connectionPoint.name(), tempName));
    }
    sdxL2CPs.put(connectionPoint, sdxl2);
}
#end_block

#method_before
@Override
public void removeSdxL2ConnectionPoint(String sdxl2cp) throws SdxL2Exception {
    Set<SdxL2ConnectionPoint> sdxl2cpsTemp = ImmutableSet.copyOf(sdxL2CPs.keySet());
    Set<SdxL2ConnectionPoint> sdxl2cpsTempByName = sdxl2cpsTemp.parallelStream().filter(sdxl2cpTemp -> sdxl2cpTemp.name().equals(sdxl2cp)).collect(Collectors.toSet());
    if (sdxl2cpsTempByName.size() == 0) {
        throw new SdxL2Exception(String.format(ERROR_SDX_REMOVE_CP_MISSING, sdxl2cp));
    }
    for (SdxL2ConnectionPoint sdxl2cpTemp : sdxl2cpsTempByName) {
        sdxL2CPs.remove(sdxl2cpTemp);
    }
}
#method_after
@Override
public void removeSdxL2ConnectionPoint(String sdxl2cp) throws SdxL2Exception {
    Set<SdxL2ConnectionPoint> sdxl2cpsTemp = ImmutableSet.copyOf(sdxL2CPs.keySet());
    Set<SdxL2ConnectionPoint> sdxl2cpsTempByName = sdxl2cpsTemp.parallelStream().filter(sdxl2cpTemp -> sdxl2cpTemp.name().equals(sdxl2cp)).collect(Collectors.toSet());
    if (sdxl2cpsTempByName.size() == 0) {
        throw new SdxL2Exception(String.format(ERROR_SDX_REMOVE_CP_MISSING, sdxl2cp));
    }
    sdxl2cpsTempByName.forEach(sdxl2cpTemp -> sdxL2CPs.remove(sdxl2cpTemp));
}
#end_block

#method_before
private static String isTunnelEnabled(Dictionary<?, ?> properties, String propertyName) {
    String value = null;
    try {
        String s = (String) properties.get(propertyName);
        value = isNullOrEmpty(s) ? null : s.trim();
        if (value != null && !value.equals("MAC") && !value.equals("VLAN") && !value.equals("MPLS")) {
            value = null;
        }
    } catch (ClassCastException e) {
    // No propertyName defined.
    }
    return value;
}
#method_after
private static String isTunnelEnabled(Dictionary<?, ?> properties, String propertyName) {
    String value = null;
    try {
        String s = (String) properties.get(propertyName);
        value = isNullOrEmpty(s) ? null : s.trim();
        if (value != null && !value.equals(VirtualCircuitMechanism.MAC) && !value.equals(VirtualCircuitMechanism.VLAN) && !value.equals(VirtualCircuitMechanism.MPLS)) {
            value = null;
        }
    } catch (ClassCastException e) {
    // No propertyName defined.
    }
    return value;
}
#end_block

#method_before
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    String tunnel;
    tunnel = isTunnelEnabled(properties, "VirtualCircuitType");
    if (tunnel == null) {
        log.info("Tunnel mechanism for VC is not configured, " + "using current value {}", vcType);
    } else {
        vcType = tunnel;
        log.info("Configured. Tunnel mechanism is {}", vcType);
    }
}
#method_after
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    String tunnel;
    tunnel = isTunnelEnabled(properties, "VirtualCircuitType");
    if (tunnel == null) {
        log.info("Tunnel mechanism for VC is not configured, " + "using current value {}", vcType);
    } else {
        vcType = tunnel;
        log.info("Configured. Tunnel mechanism set to {}", vcType);
    }
}
#end_block

#method_before
private void changeVCTunnel() {
    if (previousvcType.equals(vcType)) {
        log.info("Tunnel mechanism has not been changed");
        return;
    } else {
        if (isCircuitActive()) {
            log.info("Change of tunnels not allowed - there are active circuits");
            vcType = previousvcType;
            return;
        }
    }
    previousvcType = vcType;
    SdxL2ArpNdpHandler.setVcType(vcType);
    vcManager = buildVCManager();
}
#method_after
private void changeVCTunnel() {
    if (previousvcType.equals(vcType)) {
        log.info("Tunnel mechanism has not been changed");
        return;
    }
    previousvcType = vcType;
    SdxL2ArpNdpHandler.setVcType(vcType);
    vcManager = buildVCManager();
}
#end_block

#method_before
private SdxL2VCService buildVCManager() {
    SdxL2VCService manager;
    switch(vcType) {
        default:
        case "MAC":
            manager = new SdxL2MacVCManager(appId, sdxL2Store, intentService);
            break;
        case "MPLS":
            manager = new SdxL2MplsVCManager(appId, sdxL2Store, intentService);
            break;
        case "VLAN":
            manager = new SdxL2VlanVCManager(appId, sdxL2Store, intentService);
            break;
    }
    return manager;
}
#method_after
private SdxL2VCService buildVCManager() {
    SdxL2VCService manager;
    switch(vcType) {
        case VirtualCircuitMechanism.MPLS:
            manager = new SdxL2MplsVCManager(appId, sdxL2Store, intentService);
            break;
        case VirtualCircuitMechanism.VLAN:
            manager = new SdxL2VlanVCManager(appId, sdxL2Store, intentService);
            break;
        default:
            log.info(String.format("Chosen tunnel mechanism does not exist. " + "Switching to %s", VirtualCircuitMechanism.MAC));
        case VirtualCircuitMechanism.MAC:
            manager = new SdxL2MacVCManager(appId, sdxL2Store, intentService);
            break;
    }
    return manager;
}
#end_block

#method_before
@Override
public void deleteSdxL2(String sdxl2) {
    checkNotNull(sdxl2, "sdxl2 name cannot be null");
    try {
        this.sdxL2Store.removeSdxL2(sdxl2);
    } catch (SdxL2Exception e) {
        log.info(e.getMessage());
    }
}
#method_after
@Override
public void deleteSdxL2(String sdxl2) {
    checkNotNull(sdxl2, "sdxl2 name cannot be null");
    this.vcManager.removeVCs(sdxl2);
    try {
        this.sdxL2Store.removeSdxL2(sdxl2);
    } catch (SdxL2Exception e) {
        log.info(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void removeSdxL2ConnectionPoint(String sdxl2cp) {
    checkNotNull(sdxl2cp, "SdxL2ConnectionPoint name cannot be null");
    try {
        // If the CP is removed, the VC will not be active anymore -> delete
        SdxL2ConnectionPoint cp = this.getSdxL2ConnectionPoint(sdxl2cp);
        this.vcManager.removeVC(cp);
    } catch (NullPointerException e) {
    }
    try {
        this.sdxL2Store.removeSdxL2ConnectionPoint(sdxl2cp);
    } catch (SdxL2Exception e) {
        log.info(e.getMessage());
    }
}
#method_after
@Override
public void removeSdxL2ConnectionPoint(String sdxl2cp) {
    checkNotNull(sdxl2cp, "SdxL2ConnectionPoint name cannot be null");
    // If the CP is removed, the VC will not be active anymore -> delete
    SdxL2ConnectionPoint cp = this.getSdxL2ConnectionPoint(sdxl2cp);
    if (cp != null) {
        this.vcManager.removeVC(cp);
    }
    try {
        this.sdxL2Store.removeSdxL2ConnectionPoint(sdxl2cp);
    } catch (SdxL2Exception e) {
        log.info(e.getMessage());
    }
}
#end_block

#method_before
private TrafficTreatment buildTreatment(VlanId setVlan, VlanId pushVlan, boolean popVlan) {
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    if (setVlan != null) {
        treatmentBuilder.setVlanId(setVlan);
    }
    if (pushVlan != null) {
        treatmentBuilder.pushVlan();
        treatmentBuilder.setVlanId(pushVlan);
    }
    if (popVlan) {
        treatmentBuilder.popVlan();
    }
    return treatmentBuilder.build();
}
#method_after
private TrafficTreatment buildTreatment(VlanId setVlan, VlanId pushVlan, boolean popVlan) {
    return manager.buildTreatment(setVlan, pushVlan, popVlan);
}
#end_block

#method_before
private TrafficSelector buildSelector(MacAddress ingressMac, MacAddress egressMac, Short etherType, VlanId ingressTag) {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthSrc(ingressMac);
    selectorBuilder.matchEthDst(egressMac);
    if (etherType != null) {
        selectorBuilder.matchEthType(etherType);
    }
    if (ingressTag != null) {
        selectorBuilder.matchVlanId(ingressTag);
    }
    return selectorBuilder.build();
}
#method_after
private TrafficSelector buildSelector(MacAddress ingressMac, MacAddress egressMac, Short etherType, VlanId ingressTag) {
    return manager.buildSelector(ingressMac, egressMac, etherType, ingressTag);
}
#end_block

#method_before
private Key generateIntentKey(String sdxl2, SdxL2ConnectionPoint cpOne, SdxL2ConnectionPoint cpTwo, String index) {
    String cps = format(NAME_FORMAT, sdxl2, cpOne.name(), cpTwo.name());
    String key = format(KEY_FORMAT, cps, index);
    return Key.of(key, APPID);
}
#method_after
private Key generateIntentKey(String sdxl2, SdxL2ConnectionPoint cpOne, SdxL2ConnectionPoint cpTwo, String index) {
    return manager.generateIntentKey(sdxl2, cpOne, cpTwo, index);
}
#end_block

#method_before
@Override
protected void execute() {
    SdxL2Service sdxl2Service = get(SdxL2Service.class);
    Optional<String> sdxl2name = Optional.ofNullable(sdxl2);
    Set<String> result = sdxl2Service.getSdxL2ConnectionPoints(sdxl2name);
    SdxL2ConnectionPoint sdxl2ConnectionPoint;
    SdxL2State sdxl2cpState;
    print(HEADER);
    print(SEPARATOR);
    if (result.size() > 0) {
        for (String sdxl2cp : result) {
            sdxl2ConnectionPoint = sdxl2Service.getSdxL2ConnectionPoint(sdxl2cp);
            if (sdxl2ConnectionPoint == null) {
                return;
            }
            sdxl2cpState = sdxl2Service.getEdgePortState(sdxl2ConnectionPoint.connectPoint());
            if (sdxl2cpState == SdxL2State.ONLINE) {
                print(FORMAT_SDXL2CP_ONLINE, "ONLINE", sdxl2cp);
            } else if (sdxl2cpState == SdxL2State.OFFLINE) {
                print(FORMAT_SDXL2CP_OFFLINE, "OFFLINE", sdxl2cp);
            }
        }
        print("");
    }
}
#method_after
@Override
protected void execute() {
    SdxL2Service sdxl2Service = get(SdxL2Service.class);
    Optional<String> sdxl2name = Optional.ofNullable(sdxl2);
    Set<String> result = sdxl2Service.getSdxL2ConnectionPoints(sdxl2name);
    SdxL2ConnectionPoint sdxl2ConnectionPoint;
    SdxL2State sdxl2cpState;
    if (!result.isEmpty()) {
        print(HEADER);
        print(SEPARATOR);
        for (String sdxl2cp : result) {
            sdxl2ConnectionPoint = sdxl2Service.getSdxL2ConnectionPoint(sdxl2cp);
            if (sdxl2ConnectionPoint == null) {
                return;
            }
            sdxl2cpState = sdxl2Service.getEdgePortState(sdxl2ConnectionPoint.connectPoint());
            if (sdxl2cpState == SdxL2State.ONLINE) {
                print(FORMAT_SDXL2CP_ONLINE, "ONLINE", sdxl2cp);
            } else if (sdxl2cpState == SdxL2State.OFFLINE) {
                print(FORMAT_SDXL2CP_OFFLINE, "OFFLINE", sdxl2cp);
            }
        }
        print("");
    }
}
#end_block

#method_before
private boolean partialequals(TrafficSelector generated, TrafficSelector fromIntent) {
    Set<Criterion> criteria = generated.criteria();
    for (Criterion criterion : criteria) {
        if (!vcType.equals("MAC") && criterion.type().equals(Type.ETH_SRC)) {
            continue;
        }
        if (!fromIntent.criteria().contains(criterion)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean partialequals(TrafficSelector generated, TrafficSelector fromIntent) {
    Set<Criterion> criteria = generated.criteria();
    for (Criterion criterion : criteria) {
        if (!vcType.equals(VirtualCircuitMechanism.MAC) && criterion.type().equals(Type.ETH_SRC)) {
            continue;
        }
        if (!fromIntent.criteria().contains(criterion)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public TrafficSelector selector() {
    switch(vcType) {
        case "MPLS":
        case "VLAN":
        default:
    }
    return buildMacSelector(this.srcMac(), this.vlan());
}
#method_after
public TrafficSelector selector() {
    switch(vcType) {
        case VirtualCircuitMechanism.MPLS:
        case VirtualCircuitMechanism.VLAN:
        default:
    }
    return buildMacSelector(this.srcMac(), this.vlan());
}
#end_block

#method_before
@Override
public void removeVC(SdxL2ConnectionPoint sdxl2cplhs, SdxL2ConnectionPoint sdxl2cprhs) {
    try {
        this.sdxL2Store.removeVC(sdxl2cplhs, sdxl2cprhs);
        Iterables.filter(intentService.getIntents(), intent -> (matches(sdxl2cplhs, sdxl2cprhs, intent) || (matches(sdxl2cprhs, sdxl2cplhs, intent)))).forEach(intentService::withdraw);
    } catch (SdxL2Exception e) {
        log.error(e.getMessage());
    }
}
#method_after
@Override
public void removeVC(SdxL2ConnectionPoint sdxl2cplhs, SdxL2ConnectionPoint sdxl2cprhs) {
    try {
        this.sdxL2Store.removeVC(sdxl2cplhs, sdxl2cprhs);
        Iterables.filter(intentService.getIntents(), intent -> (matcher.matches(sdxl2cplhs, sdxl2cprhs, intent) || (matcher.matches(sdxl2cprhs, sdxl2cplhs, intent)))).forEach(intentService::withdraw);
    } catch (SdxL2Exception e) {
        log.error(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void removeVC(SdxL2ConnectionPoint cp) {
    try {
        this.sdxL2Store.removeVC(cp);
        Iterables.filter(intentService.getIntents(), intent -> (matches(cp, intent))).forEach(intentService::withdraw);
    } catch (SdxL2Exception e) {
        log.error(e.getMessage());
    }
}
#method_after
@Override
public void removeVC(SdxL2ConnectionPoint cp) {
    try {
        this.sdxL2Store.removeVC(cp);
        Iterables.filter(intentService.getIntents(), intent -> (matcher.matches(cp, intent))).forEach(intentService::withdraw);
    } catch (SdxL2Exception e) {
        log.error(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void removeVCs(String sdxl2) {
    this.sdxL2Store.removeVCs(sdxl2);
    Iterables.filter(intentService.getIntents(), intent -> (matches(sdxl2, intent))).forEach(intentService::withdraw);
}
#method_after
@Override
public void removeVCs(String sdxl2) {
    this.sdxL2Store.removeVCs(sdxl2);
    Iterables.filter(intentService.getIntents(), intent -> (matcher.matches(sdxl2, intent))).forEach(intentService::withdraw);
}
#end_block

#method_before
protected Key generateIntentKey(String sdxl2, SdxL2ConnectionPoint cpone, SdxL2ConnectionPoint cptwo, String index) {
    String cps = format(NAME_FORMAT, sdxl2, cpone.name(), cptwo.name());
    String key = format(KEY_FORMAT, cps, index);
    return Key.of(key, appId);
}
#method_after
protected Key generateIntentKey(String sdxl2, SdxL2ConnectionPoint cpOne, SdxL2ConnectionPoint cpTwo, String index) {
    String cps = format(NAME_FORMAT, sdxl2, cpOne.name(), cpTwo.name());
    String key = format(KEY_FORMAT, cps, index);
    return Key.of(key, appId);
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint1() {
    SdxL2ConnectionPoint scp1 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("RO1", CP1, VLANS1, CEMAC1);
    assertNotEquals(scp1, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint1() {
    SdxL2ConnectionPoint scp1 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("RO1", CP1, VLANS1, CEMAC1);
    // scp1 != null
    new EqualsTester().addEqualityGroup(scp1).addEqualityGroup().testEquals();
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint2() {
    SdxL2ConnectionPoint scp2 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("RO2", CP2, VLANS2);
    assertNotEquals(scp2, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint2() {
    SdxL2ConnectionPoint scp2 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("RO2", CP2, VLANS2);
    // scp2 != null
    new EqualsTester().addEqualityGroup(scp2).addEqualityGroup().testEquals();
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint3() {
    SdxL2ConnectionPoint scp3 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("MI1", CP3, VLANS3);
    assertNotEquals(scp3, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint3() {
    SdxL2ConnectionPoint scp3 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("MI1", CP3, VLANS3);
    // scp3 != null
    new EqualsTester().addEqualityGroup(scp3).addEqualityGroup().testEquals();
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint4() {
    SdxL2ConnectionPoint scp4 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("RO3", CP4, VLANS4);
    assertNotEquals(scp4, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint4() {
    SdxL2ConnectionPoint scp4 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("RO3", CP4, VLANS4);
    // scp4 != null
    new EqualsTester().addEqualityGroup(scp4).addEqualityGroup().testEquals();
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint5() {
    exceptionconnectionpoint.expect(IllegalArgumentException.class);
    exceptionconnectionpoint.expectMessage("Connect point must be in \"deviceUri/portNumber\" format");
    SdxL2ConnectionPoint scp5 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("MI2", CP5, VLANS5, CEMAC5);
    assertEquals(scp5, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint5() {
    exceptionconnectionpoint.expect(IllegalArgumentException.class);
    exceptionconnectionpoint.expectMessage("Connect point must be in \"deviceUri/portNumber\" format");
    SdxL2ConnectionPoint.sdxl2ConnectionPoint("MI2", CP5, VLANS5, CEMAC5);
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint6() {
    SdxL2ConnectionPoint scp6 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("MI3", CP6, VLANS6, CEMAC6);
    assertNotEquals(scp6, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint6() {
    SdxL2ConnectionPoint scp6 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("MI3", CP6, VLANS6, CEMAC6);
    // scp6 != null
    new EqualsTester().addEqualityGroup(scp6).addEqualityGroup().testEquals();
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint7() {
    exceptionmac.expect(IllegalArgumentException.class);
    exceptionmac.expectMessage("Specified MAC Address must contain");
    SdxL2ConnectionPoint scp7 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("RO4", CP7, VLANS7, CEMAC7);
    assertNotEquals(scp7, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint7() {
    exceptionmac.expect(IllegalArgumentException.class);
    exceptionmac.expectMessage("Specified MAC Address must contain");
    SdxL2ConnectionPoint.sdxl2ConnectionPoint("RO4", CP7, VLANS7, CEMAC7);
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint8() {
    SdxL2ConnectionPoint scp8 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("", CP4, VLANS2, CEMAC6);
    assertNotEquals(scp8, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint8() {
    SdxL2ConnectionPoint scp8 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("", CP4, VLANS2, CEMAC6);
    // scp8 != null
    new EqualsTester().addEqualityGroup(scp8).addEqualityGroup().testEquals();
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint10() {
    exceptionVlans.expect(NumberFormatException.class);
    SdxL2ConnectionPoint scp10 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("VE1", CP1, VLANS10, CEMAC7);
    assertNotEquals(scp10, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint10() {
    exceptionVlans.expect(NumberFormatException.class);
    SdxL2ConnectionPoint.sdxl2ConnectionPoint("VE1", CP1, VLANS10, CEMAC7);
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint11() {
    exceptionVlans.expect(IllegalArgumentException.class);
    exceptionVlans.expectMessage("value exceeds allowed maximum VLAN ID value (4095)");
    SdxL2ConnectionPoint scp11 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("VE2", CP2, VLANS11, CEMAC6);
    assertNotEquals(scp11, null);
}
#method_after
@Test
public void testSdxL2ConnectionPoint11() {
    exceptionVlans.expect(IllegalArgumentException.class);
    exceptionVlans.expectMessage("value exceeds allowed maximum VLAN ID value (4095)");
    SdxL2ConnectionPoint.sdxl2ConnectionPoint("VE2", CP2, VLANS11, CEMAC6);
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPointEquality() {
    SdxL2ConnectionPoint scp1 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint scp2 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP1, VLANS1, CEMAC6);
    assertEquals(scp1, scp2);
    SdxL2ConnectionPoint scp3 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("GE4", CP2, VLANS3, CEMAC6);
    assertNotEquals(scp1, scp3);
    SdxL2ConnectionPoint scp4 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("GE4", CP2, VLANS8, CEMAC6);
    assertNotEquals(scp3, scp4);
}
#method_after
@Test
public void testSdxL2ConnectionPointEquality() {
    SdxL2ConnectionPoint scp1 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint scp2 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP1, VLANS1, CEMAC6);
    SdxL2ConnectionPoint scp3 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("GE4", CP2, VLANS3, CEMAC6);
    SdxL2ConnectionPoint scp4 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("GE4", CP2, VLANS8, CEMAC6);
    // scp1 == scp2, but those are different from scp3 and scp4
    new EqualsTester().addEqualityGroup(scp1, scp2).addEqualityGroup(scp3).addEqualityGroup(scp4).testEquals();
}
#end_block

#method_before
@Override
protected void execute() {
    SdxL2Service sdxl2Service = get(SdxL2Service.class);
    Optional<String> sdxl2name = Optional.ofNullable(sdxl2vcname);
    Set<String> result = sdxl2Service.getVirtualCircuits(sdxl2name);
    VirtualCircuit vc;
    SdxL2State state;
    print(HEADER);
    print(SEPARATOR);
    if (result.size() > 0) {
        String[] sdxl2VC;
        for (String sdxl2vc : result) {
            sdxl2VC = sdxl2vc.split(":");
            vc = sdxl2Service.getVirtualCircuit(sdxl2vc);
            if (vc == null) {
                break;
            }
            state = this.getVirtualCircuitState(vc);
            if (state == SdxL2State.ONLINE) {
                print(FORMAT_SDXL2VC_ONLINE, "ONLINE", sdxl2VC[1]);
            } else if (state == SdxL2State.OFFLINE) {
                print(FORMAT_SDXL2VC_OFFLINE, "OFFLINE", sdxl2VC[1]);
            } else {
                print(FORMAT_SDXL2VC_CHECK, "CHECK", sdxl2VC[1]);
            }
        }
        print("");
    }
}
#method_after
@Override
protected void execute() {
    SdxL2Service sdxl2Service = get(SdxL2Service.class);
    Optional<String> sdxl2name = Optional.ofNullable(sdxl2vcname);
    Set<String> result = sdxl2Service.getVirtualCircuits(sdxl2name);
    VirtualCircuit vc;
    SdxL2State state;
    if (!result.isEmpty()) {
        print(HEADER);
        print(SEPARATOR);
        String[] sdxl2VC;
        for (String sdxl2vc : result) {
            sdxl2VC = sdxl2vc.split(":");
            vc = sdxl2Service.getVirtualCircuit(sdxl2vc);
            if (vc == null) {
                break;
            }
            state = this.getVirtualCircuitState(vc);
            if (state == SdxL2State.ONLINE) {
                print(FORMAT_SDXL2VC_ONLINE, "ONLINE", sdxl2VC[1]);
            } else if (state == SdxL2State.OFFLINE) {
                print(FORMAT_SDXL2VC_OFFLINE, "OFFLINE", sdxl2VC[1]);
            } else {
                print(FORMAT_SDXL2VC_CHECK, "CHECK", sdxl2VC[1]);
            }
        }
        print("");
    }
}
#end_block

#method_before
private SdxL2State getVirtualCircuitState(VirtualCircuit vc) {
    IntentService intentService = get(IntentService.class);
    SdxL2Service sdxl2Service = get(SdxL2Service.class);
    SdxL2State intentState = SdxL2State.ONLINE;
    SdxL2State lhsState;
    SdxL2State rhsstate;
    Iterator<Intent> intents = Iterables.filter(intentService.getIntents(), intent -> (sdxl2Service.matchesIntent(vc.lhs(), vc.rhs(), intent) || (sdxl2Service.matchesIntent(vc.rhs(), vc.lhs(), intent)))).iterator();
    Intent intent;
    Key key;
    int numIntents = 0;
    int numIntentsOffline = 0;
    while (intents.hasNext()) {
        intent = intents.next();
        key = intent.key();
        intentState = sdxl2Service.getIntentState(key);
        if (intentState == SdxL2State.OFFLINE || intentState == SdxL2State.CHECK) {
            numIntentsOffline += 1;
        }
        numIntents += 1;
    }
    if (numIntents == numIntentsOffline) {
        return SdxL2State.OFFLINE;
    }
    lhsState = sdxl2Service.getEdgePortState(vc.lhs().connectPoint());
    if (lhsState == SdxL2State.OFFLINE) {
        return SdxL2State.OFFLINE;
    }
    rhsstate = sdxl2Service.getEdgePortState(vc.rhs().connectPoint());
    if (rhsstate == SdxL2State.OFFLINE) {
        return SdxL2State.OFFLINE;
    }
    if (intentState == SdxL2State.ONLINE && lhsState == SdxL2State.ONLINE && rhsstate == SdxL2State.ONLINE) {
        return SdxL2State.ONLINE;
    }
    return SdxL2State.CHECK;
}
#method_after
private SdxL2State getVirtualCircuitState(VirtualCircuit vc) {
    IntentService intentService = get(IntentService.class);
    SdxL2Service sdxl2Service = get(SdxL2Service.class);
    SdxL2ConnectionPointMatcher matcher = new SdxL2ConnectionPointMatcher();
    SdxL2State intentState = SdxL2State.ONLINE;
    SdxL2State lhsState;
    SdxL2State rhsstate;
    Iterator<Intent> intents = Iterables.filter(intentService.getIntents(), intent -> (matcher.matches(vc.lhs(), vc.rhs(), intent) || (matcher.matches(vc.rhs(), vc.lhs(), intent)))).iterator();
    Intent intent;
    Key key;
    int numIntents = 0;
    int numIntentsOffline = 0;
    while (intents.hasNext()) {
        intent = intents.next();
        key = intent.key();
        intentState = sdxl2Service.getIntentState(key);
        if (intentState == SdxL2State.OFFLINE || intentState == SdxL2State.CHECK) {
            numIntentsOffline += 1;
        }
        numIntents += 1;
    }
    if (numIntents == numIntentsOffline) {
        return SdxL2State.OFFLINE;
    }
    lhsState = sdxl2Service.getEdgePortState(vc.lhs().connectPoint());
    if (lhsState == SdxL2State.OFFLINE) {
        return SdxL2State.OFFLINE;
    }
    rhsstate = sdxl2Service.getEdgePortState(vc.rhs().connectPoint());
    if (rhsstate == SdxL2State.OFFLINE) {
        return SdxL2State.OFFLINE;
    }
    if (intentState == SdxL2State.ONLINE && lhsState == SdxL2State.ONLINE && rhsstate == SdxL2State.ONLINE) {
        return SdxL2State.ONLINE;
    }
    return SdxL2State.CHECK;
}
#end_block

#method_before
@Test
public void testVC1() {
    SdxL2ConnectionPoint scp1 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint scp2 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("GE4", CP2, VLANS3, CEMAC6);
    VirtualCircuit vc1 = new VirtualCircuit(scp1, scp2);
    assertNotEquals(vc1, null);
}
#method_after
@Test
public void testVC1() {
    SdxL2ConnectionPoint scp1 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint scp2 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("GE4", CP2, VLANS3, CEMAC6);
    VirtualCircuit vc1 = new VirtualCircuit(scp1, scp2);
    assertNotEquals(null, vc1);
}
#end_block

#method_before
@Test
public void testVCEquality() {
    SdxL2ConnectionPoint scp1 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint scp2 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("GE4", CP2, VLANS3, CEMAC6);
    VirtualCircuit vc1 = new VirtualCircuit(scp1, scp2);
    VirtualCircuit vc2 = new VirtualCircuit(scp2, scp1);
    assertEquals(vc1, vc2);
    SdxL2ConnectionPoint scp3 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI2", CP1, VLANS1, CEMAC1);
    VirtualCircuit vc3 = new VirtualCircuit(scp1, scp3);
    assertNotEquals(vc1, vc3);
}
#method_after
@Test
public void testVCEquality() {
    SdxL2ConnectionPoint scp1 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint scp2 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("GE4", CP2, VLANS3, CEMAC6);
    VirtualCircuit vc1 = new VirtualCircuit(scp1, scp2);
    VirtualCircuit vc2 = new VirtualCircuit(scp2, scp1);
    SdxL2ConnectionPoint scp3 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("FI2", CP1, VLANS1, CEMAC1);
    VirtualCircuit vc3 = new VirtualCircuit(scp1, scp3);
    // vc1 == vc2, but those are different from vc3
    new EqualsTester().addEqualityGroup(vc1, vc2).addEqualityGroup(vc3).testEquals();
}
#end_block

#method_before
@Override
public boolean verifyEditConfig(String target, String mode, String request) {
    boolean result;
    assertTrue("Incorrect target", target.equals(TEST_RUNNING));
    assertNull("Incorrect mode", mode);
    request = request.replaceAll(TEST_DUPLICATE_SPACES_REGEX, TEST_SPACE);
    assertTrue("Does not contain:" + TEST_VOLT_NAMESPACE, request.contains(TEST_VOLT_NAMESPACE));
    result = verifyEditConfigRequestWithString(request);
    assertTrue("XML verification failure", result);
    return result;
}
#method_after
@Override
public boolean verifyEditConfig(String target, String mode, String request) {
    boolean result;
    assertTrue("Incorrect target", target.equals(TEST_RUNNING));
    assertNull("Incorrect mode", mode);
    request = request.replaceAll(TEST_DUPLICATE_SPACES_REGEX, TEST_SPACE);
    assertTrue("Does not contain:" + TEST_VOLT_NAMESPACE, request.contains(TEST_VOLT_NAMESPACE));
    result = verifyEditConfigRequest(request);
    assertTrue("XML verification failure", result);
    return result;
}
#end_block

#method_before
@Override
public boolean verifyGet(String filterSchema, String withDefaultsMode) {
    boolean result;
    assertTrue("Incorrect withDefaultsMode", withDefaultsMode.equals(TEST_REPORT_ALL));
    filterSchema = filterSchema.replaceAll(TEST_DUPLICATE_SPACES_REGEX, TEST_SPACE);
    assertTrue("Does not contain:" + TEST_VOLT_NAMESPACE, filterSchema.contains(TEST_VOLT_NAMESPACE));
    result = verifyGetRequestWithString(filterSchema);
    assertTrue("XML verification failure", result);
    return result;
}
#method_after
@Override
public boolean verifyGet(String filterSchema, String withDefaultsMode) {
    boolean result;
    assertTrue("Incorrect withDefaultsMode", withDefaultsMode.equals(TEST_REPORT_ALL));
    filterSchema = filterSchema.replaceAll(TEST_DUPLICATE_SPACES_REGEX, TEST_SPACE);
    assertTrue("Does not contain:" + TEST_VOLT_NAMESPACE, filterSchema.contains(TEST_VOLT_NAMESPACE));
    result = verifyGetRequest(filterSchema);
    assertTrue("XML verification failure", result);
    return result;
}
#end_block

#method_before
@Override
public String getPonLinks(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN).append(VOLT_NE_NAMESPACE);
        request.append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(VOLT_PORTS));
        if (target != null) {
            try {
                pon = Integer.parseInt(target);
                if (pon <= PARSEINT_VALUE_ZERO) {
                    log.error("Invalid integer for ponlink-id:{}", target);
                    return reply;
                }
            } catch (NumberFormatException e) {
                log.error("Non-number input for ponlink-id:{}", target);
                return reply;
            }
            request.append(buildStartTag(GPON_PONLINK_PORTS));
            request.append(buildStartTag(GPON_PONLINK_PORT));
            request.append(buildStartTag(PONLINK_ID, false));
            request.append(target);
            request.append(buildEndTag(PONLINK_ID));
            request.append(buildEndTag(GPON_PONLINK_PORT));
            request.append(buildEndTag(GPON_PONLINK_PORTS));
        } else {
            request.append(buildEmptyTag(GPON_PONLINK_PORTS));
        }
        request.append(buildEndTag(VOLT_PORTS));
        request.append(VOLT_NE_CLOSE);
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().get(request.toString(), REPORT_ALL);
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
    return reply;
}
#method_after
@Override
public String getPonLinks(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN).append(VOLT_NE_NAMESPACE);
        request.append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(VOLT_PORTS));
        if (target != null) {
            int pon;
            try {
                pon = Integer.parseInt(target);
                if (pon <= ZERO) {
                    log.error("Invalid integer for ponlink-id:{}", target);
                    return reply;
                }
            } catch (NumberFormatException e) {
                log.error("Non-number input for ponlink-id:{}", target);
                return reply;
            }
            request.append(buildStartTag(GPON_PONLINK_PORTS));
            request.append(buildStartTag(GPON_PONLINK_PORT));
            request.append(buildStartTag(PONLINK_ID, false));
            request.append(target);
            request.append(buildEndTag(PONLINK_ID));
            request.append(buildEndTag(GPON_PONLINK_PORT));
            request.append(buildEndTag(GPON_PONLINK_PORTS));
        } else {
            request.append(buildEmptyTag(GPON_PONLINK_PORTS));
        }
        request.append(buildEndTag(VOLT_PORTS));
        request.append(VOLT_NE_CLOSE);
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().get(request.toString(), REPORT_ALL);
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception {}", ncDeviceId, e);
    }
    return reply;
}
#end_block

#method_before
@Override
public boolean setPonLink(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return false;
    }
    String[] data = verifySetInput(target);
    if (data == null) {
        log.error("Failed to verify input: " + target);
        return false;
    }
    boolean result = false;
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN).append(VOLT_NE_NAMESPACE);
        request.append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(VOLT_PORTS));
        request.append(buildStartTag(GPON_PONLINK_PORTS));
        request.append(buildStartTag(GPON_PONLINK_PORT));
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(data[FIRST_PART_OF_VERIFY_SET_INPUT_SPLIT_COLON]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(data[SECOND_PART_OF_VERIFY_SET_INPUT_SPLIT_COLON], false));
        request.append(data[THIRD_PART_OF_VERIFY_SET_INPUT_SPLIT_COLON]);
        request.append(buildEndTag(data[SECOND_PART_OF_VERIFY_SET_INPUT_SPLIT_COLON]));
        request.append(buildEndTag(GPON_PONLINK_PORT));
        request.append(buildEndTag(GPON_PONLINK_PORTS));
        request.append(buildEndTag(VOLT_PORTS));
        request.append(VOLT_NE_CLOSE);
        result = controller.getDevicesMap().get(ncDeviceId).getSession().editConfig(RUNNING, null, request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
    return result;
}
#method_after
@Override
public boolean setPonLink(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return false;
    }
    String[] data = checkSetInput(target);
    if (data == null) {
        log.error("Failed to check input: {}", target);
        return false;
    }
    boolean result = false;
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN).append(VOLT_NE_NAMESPACE);
        request.append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(VOLT_PORTS));
        request.append(buildStartTag(GPON_PONLINK_PORTS));
        request.append(buildStartTag(GPON_PONLINK_PORT));
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(data[FIRST_PART]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(data[SECOND_PART], false));
        request.append(data[THIRD_PART]);
        request.append(buildEndTag(data[SECOND_PART]));
        request.append(buildEndTag(GPON_PONLINK_PORT));
        request.append(buildEndTag(GPON_PONLINK_PORTS));
        request.append(buildEndTag(VOLT_PORTS));
        request.append(VOLT_NE_CLOSE);
        result = controller.getDevicesMap().get(ncDeviceId).getSession().editConfig(RUNNING, null, request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception {}", ncDeviceId, e);
    }
    return result;
}
#end_block

#method_before
public static final ProtectedConstraint useProtectedLink() {
    return PROTECTED_CONSTRAINT;
}
#method_after
public static ProtectedConstraint useProtectedLink() {
    return PROTECTED_CONSTRAINT;
}
#end_block

#method_before
private static String getParseFromStringMethod(String targetDataType, YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE_WRAPPER + PERIOD + PARSE_BYTE;
        case INT16:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case INT32:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case INT64:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT8:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case UINT16:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case UINT32:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT64:
            return NEW + SPACE + BIG_INTEGER;
        case DECIMAL64:
            return NEW + SPACE + BIG_DECIMAL;
        case STRING:
        case IDENTITYREF:
            return EMPTY_STRING;
        case EMPTY:
        case BOOLEAN:
            return BOOLEAN_WRAPPER + PERIOD + PARSE_BOOLEAN;
        case BITS:
        case UNION:
        case ENUMERATION:
        case DERIVED:
            return targetDataType + PERIOD + FROM_STRING_METHOD_NAME;
        default:
            throw new TranslatorException("given data type is not supported. " + yangType.getDataTypeName() + " in " + yangType.getLineNumber() + " at " + yangType.getCharPosition() + " in " + yangType.getFileName());
    }
}
#method_after
private static String getParseFromStringMethod(String targetDataType, YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE_WRAPPER + PERIOD + PARSE_BYTE;
        case INT16:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case INT32:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case INT64:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT8:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case UINT16:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case UINT32:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT64:
            return NEW + SPACE + BIG_INTEGER;
        case DECIMAL64:
            return NEW + SPACE + BIG_DECIMAL;
        case STRING:
        case IDENTITYREF:
            return EMPTY_STRING;
        case EMPTY:
        case BOOLEAN:
            return BOOLEAN_WRAPPER + PERIOD + PARSE_BOOLEAN;
        case BITS:
        case UNION:
        case ENUMERATION:
        case DERIVED:
            return targetDataType + PERIOD + FROM_STRING_METHOD_NAME;
        default:
            throw new TranslatorException("given data type is not " + "supported. " + yangType.getDataTypeName() + " in " + yangType.getLineNumber() + " at " + yangType.getCharPosition() + " in " + yangType.getFileName());
    }
}
#end_block

#method_before
static void addCurNodeInfoInParentTempFile(YangNode curNode, boolean isList, YangPluginConfig pluginConfig) throws IOException {
    YangNode parent = getParentNodeInGenCode(curNode);
    if (!(parent instanceof JavaCodeGenerator)) {
        throw new TranslatorException("missing parent node to contain current node info in " + "generated file " + parent.getName() + " in " + parent.getLineNumber() + " at " + parent.getCharPosition() + " in " + parent.getFileName());
    }
    if (parent instanceof YangJavaGroupingTranslator) {
        /*
             * In case of grouping, there is no need to add the information, it
             * will be taken care in uses
             */
        return;
    }
    TempJavaBeanFragmentFiles tempJavaBeanFragmentFiles = ((JavaCodeGeneratorInfo) parent).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    JavaAttributeInfo javaAttributeInfo = getCurNodeAsAttributeInTarget(curNode, parent, isList, tempJavaBeanFragmentFiles);
    tempJavaBeanFragmentFiles.addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo, pluginConfig);
}
#method_after
protected static void addCurNodeInfoInParentTempFile(YangNode curNode, boolean isList, YangPluginConfig config) throws IOException {
    YangNode parent = getParentNodeInGenCode(curNode);
    if (!(parent instanceof JavaCodeGenerator)) {
        throw new TranslatorException(getErrorMsg(MISSING_PARENT_NODE, curNode));
    }
    if (parent instanceof YangJavaGroupingTranslator) {
        /*
             * In case of grouping, there is no need to add the information, it
             * will be taken care in uses.
             */
        return;
    }
    TempJavaBeanFragmentFiles tempFiles = getBeanFiles((JavaCodeGeneratorInfo) parent);
    JavaAttributeInfo attr = getCurNodeAsAttributeInTarget(curNode, parent, isList, tempFiles);
    tempFiles.addJavaSnippetInfoToApplicableTempFiles(attr, config);
}
#end_block

#method_before
public static JavaAttributeInfo getCurNodeAsAttributeInTarget(YangNode curNode, YangNode targetNode, boolean isListNode, TempJavaFragmentFiles tempJavaFragmentFiles) {
    String curNodeName = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName();
    if (curNodeName == null) {
        updateJavaFileInfo(curNode, null);
        curNodeName = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName();
    }
    /*
         * Get the import info corresponding to the attribute for import in
         * generated java files or qualified access
         */
    JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase(curNodeName));
    if (!(targetNode instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException("Parent node does not have file info " + targetNode.getName() + " in " + targetNode.getLineNumber() + " at " + targetNode.getCharPosition() + " in " + targetNode.getFileName());
    }
    JavaImportData parentImportData = tempJavaFragmentFiles.getJavaImportData();
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) targetNode).getJavaFileInfo();
    boolean isQualified;
    if ((tempJavaFragmentFiles instanceof TempJavaServiceFragmentFiles) && (qualifiedTypeInfo.getClassInfo().contentEquals(SERVICE)) || qualifiedTypeInfo.getClassInfo().contentEquals(getCapitalCase(fileInfo.getJavaName() + SERVICE))) {
        isQualified = true;
    } else {
        String className;
        if (tempJavaFragmentFiles instanceof TempJavaServiceFragmentFiles) {
            className = getCapitalCase(fileInfo.getJavaName()) + SERVICE;
        } else {
            className = getCapitalCase(fileInfo.getJavaName());
        }
        isQualified = parentImportData.addImportInfo(qualifiedTypeInfo, className, fileInfo.getPackage());
    }
    boolean collectionSetFlag = false;
    if (curNode instanceof YangList) {
        YangList yangList = (YangList) curNode;
        if (yangList.getCompilerAnnotation() != null && yangList.getCompilerAnnotation().getYangAppDataStructure() != null) {
            switch(yangList.getCompilerAnnotation().getYangAppDataStructure().getDataStructure()) {
                case QUEUE:
                    {
                        parentImportData.setQueueToImport(true);
                        collectionSetFlag = true;
                        break;
                    }
                case SET:
                    {
                        parentImportData.setSetToImport(true);
                        collectionSetFlag = true;
                        break;
                    }
                default:
                    {
                    // TODO : to be implemented
                    }
            }
        }
    }
    if (isListNode && !(collectionSetFlag)) {
        parentImportData.setIfListImported(true);
    }
    if (curNode instanceof YangList) {
        return getAttributeInfoForTheData(qualifiedTypeInfo, curNodeName, null, isQualified, isListNode, ((YangList) curNode).getCompilerAnnotation());
    }
    return getAttributeInfoForTheData(qualifiedTypeInfo, curNodeName, null, isQualified, isListNode);
}
#method_after
public static JavaAttributeInfo getCurNodeAsAttributeInTarget(YangNode curNode, YangNode targetNode, boolean listNode, TempJavaFragmentFiles tempFiles) {
    JavaFileInfoTranslator translator = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String curNodeName = translator.getJavaName();
    if (curNodeName == null) {
        updateJavaFileInfo(curNode, null);
        curNodeName = translator.getJavaName();
    }
    /*
         * Get the import info corresponding to the attribute for import in
         * generated java files or qualified access.
         */
    JavaQualifiedTypeInfoTranslator typeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase(curNodeName));
    if (!(targetNode instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException(getErrorMsg(INVALID_PARENT_NODE, curNode));
    }
    JavaImportData parentImportData = tempFiles.getJavaImportData();
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) targetNode).getJavaFileInfo();
    boolean qualified;
    if ((tempFiles instanceof TempJavaServiceFragmentFiles) && (typeInfo.getClassInfo().contentEquals(SERVICE)) || typeInfo.getClassInfo().contentEquals(getCapitalCase(fileInfo.getJavaName() + SERVICE))) {
        qualified = true;
    } else {
        String className;
        if (tempFiles instanceof TempJavaServiceFragmentFiles) {
            className = getCapitalCase(fileInfo.getJavaName()) + SERVICE;
        } else {
            className = getCapitalCase(fileInfo.getJavaName());
        }
        qualified = parentImportData.addImportInfo(typeInfo, className, fileInfo.getPackage());
    }
    boolean collectionSet = false;
    if (curNode instanceof YangList) {
        YangList yangList = (YangList) curNode;
        if (yangList.getCompilerAnnotation() != null && yangList.getCompilerAnnotation().getYangAppDataStructure() != null) {
            switch(yangList.getCompilerAnnotation().getYangAppDataStructure().getDataStructure()) {
                case QUEUE:
                    {
                        parentImportData.setQueueToImport(true);
                        collectionSet = true;
                        break;
                    }
                case SET:
                    {
                        parentImportData.setSetToImport(true);
                        collectionSet = true;
                        break;
                    }
                default:
                    {
                    // TODO : to be implemented
                    }
            }
        }
    }
    if (listNode && !(collectionSet)) {
        parentImportData.setIfListImported(true);
    }
    if (curNode instanceof YangList) {
        return getAttributeInfoForTheData(typeInfo, curNodeName, null, qualified, listNode, ((YangList) curNode).getCompilerAnnotation());
    }
    return getAttributeInfoForTheData(typeInfo, curNodeName, null, qualified, listNode);
}
#end_block

#method_before
private static JavaAttributeInfo getJavaAttributeOfLeaf(TempJavaFragmentFiles tempJavaFragmentFiles, YangLeaf leaf, YangPluginConfig yangPluginConfig) {
    JavaLeafInfoContainer javaLeaf = (JavaLeafInfoContainer) leaf;
    javaLeaf.setConflictResolveConfig(yangPluginConfig.getConflictResolver());
    javaLeaf.updateJavaQualifiedInfo();
    return getAttributeInfoForTheData(javaLeaf.getJavaQualifiedInfo(), javaLeaf.getJavaName(yangPluginConfig.getConflictResolver()), javaLeaf.getDataType(), tempJavaFragmentFiles.getIsQualifiedAccessOrAddToImportList(javaLeaf.getJavaQualifiedInfo()), false);
}
#method_after
private static JavaAttributeInfo getJavaAttributeOfLeaf(TempJavaFragmentFiles tempFiles, JavaLeafInfoContainer container, YangPluginConfig config, boolean leafList) {
    if (leafList) {
        tempFiles.getJavaImportData().setIfListImported(true);
        return getAttributeOfLeafInfoContainer(tempFiles, container, config, true);
    }
    return getAttributeOfLeafInfoContainer(tempFiles, container, config, false);
}
#end_block

#method_before
void setAbsoluteDirPath(String absoluteDirPath) {
    this.absoluteDirPath = absoluteDirPath;
}
#method_after
protected void setAbsoluteDirPath(String absoluteDirPath) {
    this.absoluteDirPath = absoluteDirPath;
}
#end_block

#method_before
public JavaFileInfoTranslator getJavaFileInfo() {
    return javaFileInfo;
}
#method_after
protected JavaFileInfoTranslator getJavaFileInfo() {
    return javaFileInfo;
}
#end_block

#method_before
public void setJavaFileInfo(JavaFileInfoTranslator javaFileInfo) {
    this.javaFileInfo = javaFileInfo;
}
#method_after
protected void setJavaFileInfo(JavaFileInfoTranslator javaFileInfo) {
    this.javaFileInfo = javaFileInfo;
}
#end_block

#method_before
int getGeneratedTempFiles() {
    return generatedTempFiles;
}
#method_after
protected int getGeneratedTempFiles() {
    return tempFilesFlagSet;
}
#end_block

#method_before
void addGeneratedTempFile(int generatedTempFile) {
    generatedTempFiles |= generatedTempFile;
    setGeneratedTempFiles(generatedTempFiles);
}
#method_after
protected void addGeneratedTempFile(int flags) {
    tempFilesFlagSet |= flags;
}
#end_block

#method_before
int getGeneratedJavaFiles() {
    return getJavaFileInfo().getGeneratedFileTypes();
}
#method_after
protected int getGeneratedJavaFiles() {
    return javaFileInfo.getGeneratedFileTypes();
}
#end_block

#method_before
String getGeneratedJavaClassName() {
    return getCapitalCase(getJavaFileInfo().getJavaName());
}
#method_after
protected String getGeneratedJavaClassName() {
    return getCapitalCase(javaFileInfo.getJavaName());
}
#end_block

#method_before
void setJavaImportData(JavaImportData javaImportData) {
    this.javaImportData = javaImportData;
}
#method_after
protected void setJavaImportData(JavaImportData data) {
    javaImportData = data;
}
#end_block

#method_before
boolean isAttributePresent() {
    return isAttributePresent;
}
#method_after
protected boolean isAttributePresent() {
    return isAttributePresent;
}
#end_block

#method_before
void setJavaExtendsListHolder(JavaExtendsListHolder javaExtendsListHolder) {
    this.javaExtendsListHolder = javaExtendsListHolder;
}
#method_after
protected void setJavaExtendsListHolder(JavaExtendsListHolder holder) {
    javaExtendsListHolder = holder;
}
#end_block

#method_before
private void addSubTreeFilteringForLeaf(JavaAttributeInfo attr) throws IOException {
    appendToFile(getSubtreeFilteringForLeafTempFileHandle(), getSubtreeFilteringForLeaf(attr, attr.getAttributeType()) + NEW_LINE);
}
#method_after
private void addSubTreeFilteringForLeaf(JavaAttributeInfo attr) throws IOException {
    appendToFile(subtreeFilteringForLeafTempFileHandle, getSubtreeFilteringForLeaf(attr, attr.getAttributeType()) + NEW_LINE);
}
#end_block

#method_before
private void addSubtreeFilteringForLeafList(JavaAttributeInfo attr) throws IOException {
    appendToFile(getGetSubtreeFilteringForListTempFileHandle(), getSubtreeFilteringForLeafList(attr) + NEW_LINE);
}
#method_after
private void addSubtreeFilteringForLeafList(JavaAttributeInfo attr) throws IOException {
    appendToFile(getSubtreeFilteringForListTempFileHandle, getSubtreeFilteringForLeafList(attr) + NEW_LINE);
}
#end_block

#method_before
private void addSubtreeFilteringForChildNode(JavaAttributeInfo attr) throws IOException {
    appendToFile(getGetSubtreeFilteringForChildNodeTempFileHandle(), getSubtreeFilteringForNode(attr) + NEW_LINE);
}
#method_after
private void addSubtreeFilteringForChildNode(JavaAttributeInfo attr) throws IOException {
    appendToFile(getSubtreeFilteringForChildNodeTempFileHandle, getSubtreeFilteringForNode(attr) + NEW_LINE);
}
#end_block

#method_before
private void addAttribute(JavaAttributeInfo attr, YangPluginConfig yangPluginConfig) throws IOException {
    appendToFile(getAttributesTempFileHandle(), parseAttribute(attr, yangPluginConfig) + FOUR_SPACE_INDENTATION);
}
#method_after
private void addAttribute(JavaAttributeInfo attr, YangPluginConfig config) throws IOException {
    appendToFile(attributesTempFileHandle, parseAttribute(attr, config) + FOUR_SPACE_INDENTATION);
}
#end_block

#method_before
private void addGetterForInterface(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {
    appendToFile(getGetterInterfaceTempFileHandle(), getGetterString(attr, getGeneratedJavaFiles(), pluginConfig) + NEW_LINE);
}
#method_after
private void addGetterForInterface(JavaAttributeInfo attr, YangPluginConfig config) throws IOException {
    appendToFile(getterInterfaceTempFileHandle, getGetterString(attr, getGeneratedJavaFiles(), config) + NEW_LINE);
}
#end_block

#method_before
private void addSetterForInterface(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {
    appendToFile(getSetterInterfaceTempFileHandle(), getSetterString(attr, getGeneratedJavaClassName(), getGeneratedJavaFiles(), pluginConfig) + NEW_LINE);
}
#method_after
private void addSetterForInterface(JavaAttributeInfo attr, YangPluginConfig config) throws IOException {
    appendToFile(setterInterfaceTempFileHandle, getSetterString(attr, getGeneratedJavaClassName(), getGeneratedJavaFiles(), config) + NEW_LINE);
}
#end_block

#method_before
private void addSetterImpl(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {
    if (isRooNode()) {
        appendToFile(getSetterImplTempFileHandle(), getJavaDoc(SETTER_METHOD, attr.getAttributeName(), attr.isListAttr(), pluginConfig, null) + getSetterForClass(attr, getGeneratedJavaClassName(), getGeneratedJavaFiles()) + NEW_LINE);
    } else {
        appendToFile(getSetterImplTempFileHandle(), getOverRideString() + getSetterForClass(attr, getGeneratedJavaClassName(), getGeneratedJavaFiles()) + NEW_LINE);
    }
}
#method_after
private void addSetterImpl(JavaAttributeInfo attr, YangPluginConfig config) throws IOException {
    String setter = getSetterForClass(attr, getGeneratedJavaClassName(), getGeneratedJavaFiles()) + NEW_LINE;
    if (rootNode) {
        appendToFile(setterImplTempFileHandle, getJavaDoc(SETTER_METHOD, attr.getAttributeName(), attr.isListAttr(), config, null) + setter);
    } else {
        appendToFile(setterImplTempFileHandle, getOverRideString() + setter);
    }
}
#end_block

#method_before
void addGetterImpl(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0 || (getGeneratedJavaFiles() & GENERATE_SERVICE_AND_MANAGER) != 0) {
        if (!isRooNode()) {
            appendToFile(getGetterImplTempFileHandle(), getOverRideString() + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
        } else {
            appendToFile(getGetterImplTempFileHandle(), getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
        }
    } else {
        String appDataStructure = null;
        if (attr.getCompilerAnnotation() != null) {
            appDataStructure = attr.getCompilerAnnotation().getYangAppDataStructure().getDataStructure().name();
        }
        appendToFile(getGetterImplTempFileHandle(), getJavaDoc(GETTER_METHOD, getCapitalCase(attr.getAttributeName()), false, pluginConfig, appDataStructure) + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
    }
}
#method_after
protected void addGetterImpl(JavaAttributeInfo attr, YangPluginConfig config) throws IOException {
    String getter = getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE;
    if (javaFlagSet(BUILDER_CLASS_MASK | GENERATE_SERVICE_AND_MANAGER)) {
        if (!rootNode) {
            appendToFile(getterImplTempFileHandle, getOverRideString() + getter);
        } else {
            appendToFile(getterImplTempFileHandle, getter);
        }
    } else {
        String appDataStructure = null;
        if (attr.getCompilerAnnotation() != null) {
            appDataStructure = attr.getCompilerAnnotation().getYangAppDataStructure().getDataStructure().name();
        }
        appendToFile(getterImplTempFileHandle, getJavaDoc(GETTER_METHOD, getCapitalCase(attr.getAttributeName()), false, config, appDataStructure) + getter);
    }
}
#end_block

#method_before
private void addAddToListInterface(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {
    appendToFile(getAddToListInterfaceTempFileHandle(), getJavaDoc(ADD_TO_LIST, getCapitalCase(attr.getAttributeName()), false, pluginConfig, null) + getAddToListMethodInterface(attr, getGeneratedJavaClassName()) + NEW_LINE);
}
#method_after
private void addAddToListInterface(JavaAttributeInfo attr, YangPluginConfig config) throws IOException {
    appendToFile(addToListInterfaceTempFileHandle, getJavaDoc(ADD_TO_LIST, getCapitalCase(attr.getAttributeName()), false, config, null) + getAddToListMethodInterface(attr, getGeneratedJavaClassName()) + NEW_LINE);
}
#end_block

#method_before
private void addAddToListImpl(JavaAttributeInfo attr) throws IOException {
    appendToFile(getAddToListImplTempFileHandle(), getAddToListMethodImpl(attr, getGeneratedJavaClassName(), isRooNode()) + NEW_LINE);
}
#method_after
private void addAddToListImpl(JavaAttributeInfo attr) throws IOException {
    appendToFile(addToListImplTempFileHandle, getAddToListMethodImpl(attr, getGeneratedJavaClassName(), rootNode) + NEW_LINE);
}
#end_block

#method_before
private void addLeafIdAttributes(JavaAttributeInfo attr, int value, YangPluginConfig yangPluginConfig) throws IOException {
    appendToFile(getLeafIdAttributeTempFileHandle(), FOUR_SPACE_INDENTATION + generateEnumAttributeString(attr.getAttributeName(), value));
}
#method_after
private void addLeafIdAttributes(JavaAttributeInfo attr, int value) throws IOException {
    appendToFile(leafIdAttributeTempFileHandle, FOUR_SPACE_INDENTATION + generateEnumAttributeString(attr.getAttributeName(), value));
}
#end_block

#method_before
String addBuildMethodForInterface(YangPluginConfig pluginConfig) throws IOException {
    return parseBuilderInterfaceBuildMethodString(getGeneratedJavaClassName(), pluginConfig);
}
#method_after
protected String addBuildMethodForInterface(YangPluginConfig config) throws IOException {
    return parseBuilderInterfaceBuildMethodString(getGeneratedJavaClassName(), config);
}
#end_block

#method_before
String addBuildMethodImpl() throws IOException {
    return getBuildString(getGeneratedJavaClassName(), isRooNode()) + NEW_LINE;
}
#method_after
protected String addBuildMethodImpl() throws IOException {
    return getBuildString(getGeneratedJavaClassName(), rootNode) + NEW_LINE;
}
#end_block

#method_before
String addDefaultConstructor(String modifier, String toAppend, YangPluginConfig pluginConfig, boolean isSuffix) throws IOException {
    String name = getGeneratedJavaClassName();
    if (isRooNode() && !toAppend.equals(BUILDER)) {
        name = name + OP_PARAM;
        return NEW_LINE + getDefaultConstructorString(name, modifier, pluginConfig);
    }
    if (isSuffix) {
        return NEW_LINE + getDefaultConstructorString(name + toAppend, modifier, pluginConfig);
    }
    String appended;
    if (toAppend.equals(DEFAULT)) {
        appended = getCapitalCase(toAppend);
    } else {
        appended = toAppend;
    }
    return NEW_LINE + getDefaultConstructorString(appended + name, modifier, pluginConfig);
}
#method_after
protected String addDefaultConstructor(String modifier, String toAppend, YangPluginConfig config, boolean suffix) throws IOException {
    StringBuilder name = new StringBuilder();
    name.append(getGeneratedJavaClassName());
    String constructor = NEW_LINE + getDefaultConstructorString(name.toString(), modifier, config);
    if (rootNode && !toAppend.equals(BUILDER)) {
        name.append(OP_PARAM);
        return constructor;
    }
    if (suffix) {
        name.append(toAppend);
        return constructor;
    }
    StringBuilder appended = new StringBuilder();
    if (toAppend.equals(DEFAULT)) {
        appended.append(getCapitalCase(toAppend));
    } else {
        appended.append(toAppend);
    }
    return NEW_LINE + getDefaultConstructorString(appended.append(name.toString()).toString(), modifier, config);
// TODO getDefaultConstructorString to handle new line.
}
#end_block

#method_before
private void addHashCodeMethod(JavaAttributeInfo attr) throws IOException {
    appendToFile(getHashCodeImplTempFileHandle(), getHashCodeMethod(attr) + NEW_LINE);
}
#method_after
private void addHashCodeMethod(JavaAttributeInfo attr) throws IOException {
    appendToFile(hashCodeImplTempFileHandle, getHashCodeMethod(attr) + NEW_LINE);
}
#end_block

#method_before
private void addEqualsMethod(JavaAttributeInfo attr) throws IOException {
    appendToFile(getEqualsImplTempFileHandle(), getEqualsMethod(attr) + NEW_LINE);
}
#method_after
private void addEqualsMethod(JavaAttributeInfo attr) throws IOException {
    appendToFile(equalsImplTempFileHandle, getEqualsMethod(attr) + NEW_LINE);
}
#end_block

#method_before
private void addToStringMethod(JavaAttributeInfo attr) throws IOException {
    appendToFile(getToStringImplTempFileHandle(), getToStringMethod(attr) + NEW_LINE);
}
#method_after
private void addToStringMethod(JavaAttributeInfo attr) throws IOException {
    appendToFile(toStringImplTempFileHandle, getToStringMethod(attr) + NEW_LINE);
}
#end_block

#method_before
void addFromStringMethod(JavaAttributeInfo javaAttributeInfo, JavaAttributeInfo fromStringAttributeInfo) throws IOException {
    appendToFile(getFromStringImplTempFileHandle(), getFromStringMethod(javaAttributeInfo, fromStringAttributeInfo) + NEW_LINE);
}
#method_after
void addFromStringMethod(JavaAttributeInfo attr, JavaAttributeInfo fromStringAttr) throws IOException {
    appendToFile(fromStringImplTempFileHandle, getFromStringMethod(attr, fromStringAttr) + NEW_LINE);
}
#end_block

#method_before
File getTemporaryFileHandle(String fileName) throws IOException {
    String path = getTempDirPath(getAbsoluteDirPath());
    File dir = new File(path);
    boolean isCreated;
    if (!dir.exists()) {
        isCreated = dir.mkdirs();
        if (!isCreated) {
            throw new IOException("failed to create temporary directory for " + fileName);
        }
    }
    File file = new File(path + fileName + TEMP_FILE_EXTENSION);
    if (!file.exists()) {
        isCreated = file.createNewFile();
        if (!isCreated) {
            throw new IOException("failed to create temporary file for " + fileName);
        }
    } else {
        throw new IOException(fileName + " is reused due to YANG naming. probably your previous build would have " + "failed");
    }
    return file;
}
#method_after
protected File getTemporaryFileHandle(String fileName) throws IOException {
    String path = getTempDirPath(absoluteDirPath);
    File dir = new File(path);
    boolean isCreated;
    if (!dir.exists()) {
        isCreated = dir.mkdirs();
        if (!isCreated) {
            throw new IOException("failed to create temporary directory " + "for " + fileName);
        }
    }
    File file = new File(path + fileName + TEMP_FILE_EXTENSION);
    if (!file.exists()) {
        isCreated = file.createNewFile();
        if (!isCreated) {
            throw new IOException("failed to create temporary file for " + fileName);
        }
    } else {
        throw new IOException(fileName + " is reused due to YANG naming. " + "probably your previous build " + "would have failed");
    }
    return file;
}
#end_block

#method_before
File getJavaFileHandle(String fileName) throws IOException {
    return getFileObject(getDirPath(), fileName, JAVA_FILE_EXTENSION, getJavaFileInfo());
}
#method_after
protected File getJavaFileHandle(String fileName) throws IOException {
    return getFileObject(getDirPath(), fileName, JAVA_FILE_EXTENSION, javaFileInfo);
}
#end_block

#method_before
public String getTemporaryDataFromFileHandle(File file, String absolutePath) throws IOException {
    String path = getTempDirPath(absolutePath);
    if (new File(path + file.getName()).exists()) {
        return readAppendFile(path + file.getName(), EMPTY_STRING);
    } else {
        throw new IOException("Unable to get data from the given " + file.getName() + " file for " + getGeneratedJavaClassName() + PERIOD);
    }
}
#method_after
public String getTemporaryDataFromFileHandle(File file, String absolutePath) throws IOException {
    String path = getTempDirPath(absolutePath);
    if (new File(path + file.getName()).exists()) {
        return readAppendFile(path + file.getName(), EMPTY_STRING);
    }
    throw new IOException("Unable to get data from the given " + file.getName() + " file for " + getGeneratedJavaClassName() + PERIOD);
}
#end_block

#method_before
private String getTempDirPath(String absolutePath) {
    return getPackageDirPathFromJavaJPackage(absolutePath) + SLASH + getGeneratedJavaClassName() + TEMP_FOLDER_NAME_SUFFIX + SLASH;
}
#method_after
private String getTempDirPath(String path) {
    return getPackageDirPathFromJavaJPackage(path) + SLASH + getGeneratedJavaClassName() + TEMP_FOLDER_NAME_SUFFIX + SLASH;
}
#end_block

#method_before
String parseAttribute(JavaAttributeInfo attr, YangPluginConfig pluginConfig) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attributeName = getCamelCase(attr.getAttributeName(), pluginConfig.getConflictResolver());
    String attributeAccessType = PRIVATE;
    if ((javaFileInfo.getGeneratedFileTypes() & GENERATE_INTERFACE_WITH_BUILDER) != 0) {
        attributeAccessType = PROTECTED;
    }
    if (attr.isQualifiedName()) {
        return getJavaAttributeDefinition(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr(), attributeAccessType, attr.getCompilerAnnotation());
    } else {
        return getJavaAttributeDefinition(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr(), attributeAccessType, attr.getCompilerAnnotation());
    }
}
#method_after
protected String parseAttribute(JavaAttributeInfo attr, YangPluginConfig config) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attrName = getCamelCase(attr.getAttributeName(), config.getConflictResolver());
    String attrAccessType = PRIVATE;
    if ((javaFileInfo.getGeneratedFileTypes() & GENERATE_INTERFACE_WITH_BUILDER) != 0) {
        attrAccessType = PROTECTED;
    }
    String pkg = null;
    if (attr.isQualifiedName()) {
        pkg = attr.getImportInfo().getPkgInfo();
    }
    return getJavaAttributeDefinition(pkg, attr.getImportInfo().getClassInfo(), attrName, attr.isListAttr(), attrAccessType, attr.getCompilerAnnotation());
}
#end_block

#method_before
void appendToFile(File file, String data) throws IOException {
    try {
        insertDataIntoJavaFile(file, data);
    } catch (IOException ex) {
        throw new IOException("failed to write in temp file.");
    }
}
#method_after
protected void appendToFile(File file, String data) throws IOException {
    try {
        insertDataIntoJavaFile(file, data);
    } catch (IOException ex) {
        throw new IOException("failed to write in temp file.");
    }
}
#end_block

#method_before
void addParentInfoInCurNodeTempFile(YangNode curNode, YangPluginConfig pluginConfig) {
    JavaQualifiedTypeInfoTranslator caseImportInfo = new JavaQualifiedTypeInfoTranslator();
    YangNode parent = getParentNodeInGenCode(curNode);
    if (curNode instanceof YangCase && parent instanceof YangAugment) {
        return;
    }
    if (!(parent instanceof JavaCodeGenerator)) {
        throw new TranslatorException("missing parent node to contain current node info in generated file");
    }
    if (!(curNode instanceof JavaFileInfoContainer)) {
        throw new TranslatorException("missing java file information to get the package details " + "of attribute corresponding to child node " + curNode.getName() + " in " + curNode.getLineNumber() + " at " + curNode.getCharPosition() + " in " + curNode.getFileName());
    }
    caseImportInfo.setClassInfo(getCapitalCase(getCamelCase(parent.getName(), pluginConfig.getConflictResolver())));
    caseImportInfo.setPkgInfo(((JavaFileInfoContainer) parent).getJavaFileInfo().getPackage());
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData().addImportInfo(caseImportInfo, getCapitalCase(fileInfo.getJavaName()), fileInfo.getPackage());
}
#method_after
protected void addParentInfoInCurNodeTempFile(YangNode curNode, YangPluginConfig config) {
    JavaQualifiedTypeInfoTranslator caseImportInfo = new JavaQualifiedTypeInfoTranslator();
    YangNode parent = getParentNodeInGenCode(curNode);
    if (curNode instanceof YangCase && parent instanceof YangAugment) {
        return;
    }
    if (!(parent instanceof JavaCodeGenerator)) {
        throw new TranslatorException(getErrorMsg(INVALID_PARENT_NODE, curNode));
    }
    if (!(curNode instanceof JavaFileInfoContainer)) {
        throw new TranslatorException(getErrorMsg(INVALID_NODE, curNode));
    }
    caseImportInfo.setClassInfo(getCapitalCase(getCamelCase(parent.getName(), config.getConflictResolver())));
    caseImportInfo.setPkgInfo(((JavaFileInfoContainer) parent).getJavaFileInfo().getPackage());
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    getBeanFiles(curNode).getJavaImportData().addImportInfo(caseImportInfo, getCapitalCase(fileInfo.getJavaName()), fileInfo.getPackage());
}
#end_block

#method_before
void addCurNodeLeavesInfoToTempFiles(YangNode curNode, YangPluginConfig yangPluginConfig) throws IOException {
    if (!(curNode instanceof YangLeavesHolder)) {
        throw new TranslatorException("Data model node does not have any leaves " + curNode.getName() + " in " + curNode.getLineNumber() + " at " + curNode.getCharPosition() + " in " + curNode.getFileName());
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
    addLeavesInfoToTempFiles(leavesHolder.getListOfLeaf(), yangPluginConfig, curNode);
    addLeafListInfoToTempFiles(leavesHolder.getListOfLeafList(), yangPluginConfig, curNode);
}
#method_after
protected void addCurNodeLeavesInfoToTempFiles(YangNode curNode, YangPluginConfig config) throws IOException {
    if (!(curNode instanceof YangLeavesHolder)) {
        throw new TranslatorException(getErrorMsg(INVALID_LEAF_HOLDER, curNode));
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
    for (YangLeaf leaf : leavesHolder.getListOfLeaf()) {
        addLeafInfoToTempFiles((JavaLeafInfoContainer) leaf, config, curNode, false);
    }
    for (YangLeafList leafList : leavesHolder.getListOfLeafList()) {
        addLeafInfoToTempFiles((JavaLeafInfoContainer) leafList, config, curNode, true);
    }
}
#end_block

#method_before
void addOperationTypeToTempFiles(YangNode curNode, YangPluginConfig yangPluginConfig) throws IOException {
    JavaQualifiedTypeInfoTranslator javaQualifiedTypeInfo = new JavaQualifiedTypeInfoTranslator();
    javaQualifiedTypeInfo.setClassInfo(OPERATION_TYPE_CLASS);
    javaQualifiedTypeInfo.setPkgInfo(((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackage());
    JavaAttributeInfo attributeInfo = getAttributeInfoForTheData(javaQualifiedTypeInfo, OPERATION_TYPE_ATTRIBUTE, null, false, false);
    addJavaSnippetInfoToApplicableTempFiles(attributeInfo, yangPluginConfig);
}
#method_after
protected void addOperationTypeToTempFiles(YangNode curNode, YangPluginConfig config) throws IOException {
    JavaQualifiedTypeInfoTranslator typeInfo = new JavaQualifiedTypeInfoTranslator();
    typeInfo.setClassInfo(OPERATION_TYPE_CLASS);
    typeInfo.setPkgInfo(((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackage());
    JavaAttributeInfo attributeInfo = getAttributeInfoForTheData(typeInfo, YANG + getCapitalCase(curNode.getJavaClassNameOrBuiltInType()) + OPERATION_TYPE_ATTRIBUTE, null, false, false);
    addJavaSnippetInfoToApplicableTempFiles(attributeInfo, config);
}
#end_block

#method_before
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo, YangPluginConfig pluginConfig) throws IOException {
    setAttributePresent(true);
    if ((getGeneratedTempFiles() & ATTRIBUTES_MASK) != 0) {
        addAttribute(newAttrInfo, pluginConfig);
    }
    if ((getGeneratedTempFiles() & GETTER_FOR_INTERFACE_MASK) != 0) {
        addGetterForInterface(newAttrInfo, pluginConfig);
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_INTERFACE_MASK) != 0) {
        addSetterForInterface(newAttrInfo, pluginConfig);
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_CLASS_MASK) != 0) {
        addSetterImpl(newAttrInfo, pluginConfig);
    }
    if ((getGeneratedTempFiles() & HASH_CODE_IMPL_MASK) != 0) {
        addHashCodeMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & EQUALS_IMPL_MASK) != 0) {
        addEqualsMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & TO_STRING_IMPL_MASK) != 0) {
        addToStringMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & EDIT_CONTENT_MASK) != 0) {
    // TODO: add implementation for edit content match.
    }
    if ((getGeneratedTempFiles() & ADD_TO_LIST_IMPL_MASK) != 0 && newAttrInfo.isListAttr()) {
        addAddToListImpl(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & ADD_TO_LIST_INTERFACE_MASK) != 0 && newAttrInfo.isListAttr()) {
        addAddToListInterface(newAttrInfo, pluginConfig);
    }
    if ((getGeneratedTempFiles() & FILTER_CONTENT_MATCH_FOR_NODES_MASK) != 0 && newAttrInfo.getAttributeType() == null && !newAttrInfo.getAttributeName().equals(OPERATION_TYPE_ATTRIBUTE)) {
        addSubtreeFilteringForChildNode(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & FILTER_CONTENT_MATCH_FOR_LEAF_MASK) != 0 && !newAttrInfo.isListAttr() && newAttrInfo.getAttributeType() != null) {
        addSubTreeFilteringForLeaf(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & FILTER_CONTENT_MATCH_FOR_LEAF_LIST_MASK) != 0 && newAttrInfo.isListAttr() && newAttrInfo.getAttributeType() != null) {
        addSubtreeFilteringForLeafList(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK) != 0 && !newAttrInfo.isListAttr() && newAttrInfo.getAttributeType() != null) {
        leafCount++;
        addLeafIdAttributes(newAttrInfo, leafCount, pluginConfig);
    }
    if (!newAttrInfo.isIntConflict() && !newAttrInfo.isLongConflict() && !newAttrInfo.isShortConflict()) {
        if ((getGeneratedTempFiles() & GETTER_FOR_CLASS_MASK) != 0) {
            addGetterImpl(newAttrInfo, pluginConfig);
        }
        if ((getGeneratedTempFiles() & FROM_STRING_IMPL_MASK) != 0) {
            JavaQualifiedTypeInfoTranslator qualifiedInfoOfFromString = getQualifiedInfoOfFromString(newAttrInfo, pluginConfig.getConflictResolver());
            /*
             * Create a new java attribute info with qualified information of
             * wrapper classes.
             */
            JavaAttributeInfo fromStringAttributeInfo = getAttributeInfoForTheData(qualifiedInfoOfFromString, newAttrInfo.getAttributeName(), newAttrInfo.getAttributeType(), getIsQualifiedAccessOrAddToImportList(qualifiedInfoOfFromString), false);
            addFromStringMethod(newAttrInfo, fromStringAttributeInfo);
        }
    }
}
#method_after
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo, YangPluginConfig pluginConfig) throws IOException {
    isAttributePresent = true;
    if (tempFlagSet(ATTRIBUTES_MASK)) {
        addAttribute(newAttrInfo, pluginConfig);
    }
    if (tempFlagSet(GETTER_FOR_INTERFACE_MASK)) {
        addGetterForInterface(newAttrInfo, pluginConfig);
    }
    if (tempFlagSet(SETTER_FOR_INTERFACE_MASK)) {
        addSetterForInterface(newAttrInfo, pluginConfig);
    }
    if (tempFlagSet(SETTER_FOR_CLASS_MASK)) {
        addSetterImpl(newAttrInfo, pluginConfig);
    }
    if (tempFlagSet(HASH_CODE_IMPL_MASK)) {
        addHashCodeMethod(newAttrInfo);
    }
    if (tempFlagSet(EQUALS_IMPL_MASK)) {
        addEqualsMethod(newAttrInfo);
    }
    if (tempFlagSet(TO_STRING_IMPL_MASK)) {
        addToStringMethod(newAttrInfo);
    }
    if (tempFlagSet(EDIT_CONTENT_MASK)) {
    // TODO: add implementation for edit content match.
    }
    boolean listAttr = newAttrInfo.isListAttr();
    if (tempFlagSet(ADD_TO_LIST_IMPL_MASK) && listAttr) {
        addAddToListImpl(newAttrInfo);
    }
    if (tempFlagSet(ADD_TO_LIST_INTERFACE_MASK) && listAttr) {
        addAddToListInterface(newAttrInfo, pluginConfig);
    }
    YangType attrType = newAttrInfo.getAttributeType();
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_NODES_MASK) && attrType == null && !newAttrInfo.getAttributeName().equals(OPERATION_TYPE_ATTRIBUTE)) {
        addSubtreeFilteringForChildNode(newAttrInfo);
    }
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_LEAF_MASK) && !listAttr && attrType != null) {
        addSubTreeFilteringForLeaf(newAttrInfo);
    }
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_LEAF_LIST_MASK) && listAttr && attrType != null) {
        addSubtreeFilteringForLeafList(newAttrInfo);
    }
    if (tempFlagSet(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK) && !listAttr && attrType != null) {
        leafCount++;
        addLeafIdAttributes(newAttrInfo, leafCount);
    }
    if (!newAttrInfo.isIntConflict() && !newAttrInfo.isLongConflict() && !newAttrInfo.isShortConflict()) {
        if (tempFlagSet(GETTER_FOR_CLASS_MASK)) {
            addGetterImpl(newAttrInfo, pluginConfig);
        }
        if (tempFlagSet(FROM_STRING_IMPL_MASK)) {
            JavaQualifiedTypeInfoTranslator typeInfo = getQualifiedInfoOfFromString(newAttrInfo, pluginConfig.getConflictResolver());
            /*
             * Create a new java attribute info with qualified information of
             * wrapper classes.
             */
            JavaAttributeInfo fromStringAttributeInfo = getAttributeInfoForTheData(typeInfo, newAttrInfo.getAttributeName(), attrType, getIsQualifiedAccessOrAddToImportList(typeInfo), false);
            addFromStringMethod(newAttrInfo, fromStringAttributeInfo);
        }
    }
}
#end_block

#method_before
String getJavaClassName(String suffix) {
    return getCapitalCase(getJavaFileInfo().getJavaName()) + suffix;
}
#method_after
protected String getJavaClassName(String suffix) {
    return getCapitalCase(javaFileInfo.getJavaName()) + suffix;
}
#end_block

#method_before
private String getImplClassName(YangNode node) {
    if (node instanceof YangModule || node instanceof YangSubModule) {
        return getCapitalCase(getJavaFileInfo().getJavaName()) + OP_PARAM;
    }
    return getCapitalCase(DEFAULT) + getCapitalCase(getJavaFileInfo().getJavaName());
}
#method_after
private String getImplClassName(YangNode node) {
    if (node instanceof RpcNotificationContainer) {
        return getCapitalCase(javaFileInfo.getJavaName()) + OP_PARAM;
    }
    return getCapitalCase(DEFAULT) + getCapitalCase(javaFileInfo.getJavaName());
}
#end_block

#method_before
private String getDirPath() {
    return getJavaFileInfo().getPackageFilePath();
}
#method_after
private String getDirPath() {
    return javaFileInfo.getPackageFilePath();
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData().getImports();
    if (curNode instanceof YangAugmentableNode) {
        addImportsForAugmentableClass(imports, true, true, curNode);
    }
    createPackage(curNode);
    // Generate java code.
    if ((fileType & INTERFACE_MASK) != 0 || (fileType & BUILDER_INTERFACE_MASK) != 0) {
        // Create interface file.
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent()));
        if (!(curNode instanceof YangModule) && !(curNode instanceof YangSubModule)) {
            // Create builder interface file.
            if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
                setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
                setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent()));
                // Append builder interface file to interface file and
                // close it.
                mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
            }
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        validateLineLength(getInterfaceJavaFileHandle());
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, false, true, curNode);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 || (fileType & DEFAULT_CLASS_MASK) != 0) {
        if (isAttributePresent()) {
            addImportsToStringAndHasCodeMethods(imports, true);
            addArrayListImport(imports);
        }
        boolean isLeavesPresent;
        if (curNode instanceof YangLeavesHolder) {
            YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
            isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
            if (isLeavesPresent) {
                addBitsetImport(imports);
            }
        }
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, true, false, curNode);
            addInvocationExceptionImport(imports);
        }
        sortImports(imports);
        // Create impl class file.
        setImplClassJavaFileHandle(getJavaFileHandle(getImplClassName(curNode)));
        setImplClassJavaFileHandle(generateDefaultClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent(), imports));
        // Create builder class file.
        if ((fileType & BUILDER_CLASS_MASK) != 0) {
            setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
            setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), curNode, isAttributePresent()));
            // Append impl class to builder class and close it.
            mergeJavaFiles(getBuilderClassJavaFileHandle(), getImplClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getImplClassJavaFileHandle(), getJavaClassDefClose());
        validateLineLength(getImplClassJavaFileHandle());
    }
    // Close all the file handles.
    freeTemporaryResources(false);
}
#method_after
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = getBeanFiles(curNode).getJavaImportData().getImports();
    if (curNode instanceof YangAugmentableNode) {
        addImportsForAugmentableClass(imports, true, true, curNode);
    }
    createPackage(curNode);
    // Generate java code.
    if ((fileType & INTERFACE_MASK) != 0 || (fileType & BUILDER_INTERFACE_MASK) != 0) {
        // Create interface file.
        interfaceJavaFileHandle = getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX));
        interfaceJavaFileHandle = generateInterfaceFile(interfaceJavaFileHandle, imports, curNode, isAttributePresent);
        if (!(curNode instanceof RpcNotificationContainer)) {
            // Create builder interface file.
            if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
                builderInterfaceJavaFileHandle = getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX));
                builderInterfaceJavaFileHandle = generateBuilderInterfaceFile(builderInterfaceJavaFileHandle, curNode, isAttributePresent);
                /*
                     * Append builder interface file to interface file and
                     * close it.
                     */
                mergeJavaFiles(builderInterfaceJavaFileHandle, interfaceJavaFileHandle);
            }
        }
        insertDataIntoJavaFile(interfaceJavaFileHandle, getJavaClassDefClose());
        validateLineLength(interfaceJavaFileHandle);
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, false, true, curNode);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 || (fileType & DEFAULT_CLASS_MASK) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(imports, true);
            addArrayListImport(imports);
        }
        boolean leavesPresent;
        if (curNode instanceof YangLeavesHolder) {
            YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
            leavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
            if (leavesPresent) {
                addBitsetImport(imports);
            }
        }
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, true, false, curNode);
            addInvocationExceptionImport(imports);
        }
        sortImports(imports);
        // Create impl class file.
        implClassJavaFileHandle = getJavaFileHandle(getImplClassName(curNode));
        implClassJavaFileHandle = generateDefaultClassFile(implClassJavaFileHandle, curNode, isAttributePresent, imports);
        // Create builder class file.
        if ((fileType & BUILDER_CLASS_MASK) != 0) {
            builderClassJavaFileHandle = getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX));
            builderClassJavaFileHandle = generateBuilderClassFile(builderClassJavaFileHandle, curNode, isAttributePresent);
            // Append impl class to builder class and close it.
            mergeJavaFiles(builderClassJavaFileHandle, implClassJavaFileHandle);
        }
        insertDataIntoJavaFile(implClassJavaFileHandle, getJavaClassDefClose());
        validateLineLength(implClassJavaFileHandle);
    }
    // Close all the file handles.
    freeTemporaryResources(false);
}
#end_block

#method_before
private void addArrayListImport(List<String> imports) {
    if (imports.contains(getJavaImportData().getImportForList())) {
        imports.add(ARRAY_LIST_IMPORT);
    }
}
#method_after
private void addArrayListImport(List<String> imports) {
    if (imports.contains(javaImportData.getImportForList())) {
        imports.add(ARRAY_LIST_IMPORT);
    }
}
#end_block

#method_before
private void addBitsetImport(List<String> imports) {
    imports.add(getJavaImportData().getImportForToBitSet());
}
#method_after
private void addBitsetImport(List<String> imports) {
    imports.add(javaImportData.getImportForToBitSet());
}
#end_block

#method_before
void addImportsToStringAndHasCodeMethods(List<String> imports, boolean operation) {
    if (operation) {
        imports.add(getJavaImportData().getImportForHashAndEquals());
        imports.add(getJavaImportData().getImportForToString());
    } else {
        imports.remove(getJavaImportData().getImportForHashAndEquals());
        imports.remove(getJavaImportData().getImportForToString());
    }
}
#method_after
protected void addImportsToStringAndHasCodeMethods(List<String> imports, boolean operation) {
    if (operation) {
        imports.add(javaImportData.getImportForHashAndEquals());
        imports.add(javaImportData.getImportForToString());
    } else {
        imports.remove(javaImportData.getImportForHashAndEquals());
        imports.remove(javaImportData.getImportForToString());
    }
// TODO change boolean to OPERATION, in all related places.
}
#end_block

#method_before
private void addImportsForAugmentableClass(List<String> imports, boolean operations, boolean isInterfaceFile, YangNode curNode) {
    if (operations) {
        if (!isInterfaceFile) {
            imports.add(getJavaImportData().getHashMapImport());
        }
        // Add import for hash map only if node is not a YANG choice.
        if (!(curNode instanceof YangChoice)) {
            imports.add(getJavaImportData().getMapImport());
        }
    } else {
        if (!isInterfaceFile) {
            imports.remove(getJavaImportData().getHashMapImport());
        }
        imports.remove(getJavaImportData().getMapImport());
    }
    sortImports(imports);
}
#method_after
private void addImportsForAugmentableClass(List<String> imports, boolean operations, boolean isInterfaceFile, YangNode curNode) {
    if (operations) {
        if (!isInterfaceFile) {
            imports.add(javaImportData.getHashMapImport());
        }
        // Add import for hash map only if node is not a YANG choice.
        if (!(curNode instanceof YangChoice)) {
            imports.add(javaImportData.getMapImport());
        }
    } else {
        if (!isInterfaceFile) {
            imports.remove(javaImportData.getHashMapImport());
        }
        imports.remove(javaImportData.getMapImport());
    }
    sortImports(imports);
}
#end_block

#method_before
public void freeTemporaryResources(boolean isErrorOccurred) throws IOException {
    /*
         * Close all java file handles and when error occurs delete the files.
         */
    if ((getGeneratedJavaFiles() & INTERFACE_MASK) != 0) {
        closeFile(getInterfaceJavaFileHandle(), isErrorOccurred);
    }
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0) {
        closeFile(getBuilderClassJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & BUILDER_INTERFACE_MASK) != 0) {
        closeFile(getBuilderInterfaceJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & DEFAULT_CLASS_MASK) != 0) {
        closeFile(getImplClassJavaFileHandle(), isErrorOccurred);
    }
    /*
         * Close all temporary file handles and delete the files.
         */
    if ((getGeneratedTempFiles() & GETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getGetterImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & ATTRIBUTES_MASK) != 0) {
        closeFile(getAttributesTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & HASH_CODE_IMPL_MASK) != 0) {
        closeFile(getHashCodeImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & TO_STRING_IMPL_MASK) != 0) {
        closeFile(getToStringImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & EQUALS_IMPL_MASK) != 0) {
        closeFile(getEqualsImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & FROM_STRING_IMPL_MASK) != 0) {
        closeFile(getFromStringImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & ADD_TO_LIST_IMPL_MASK) != 0) {
        closeFile(getAddToListImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & ADD_TO_LIST_INTERFACE_MASK) != 0) {
        closeFile(getAddToListInterfaceTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK) != 0) {
        closeFile(getLeafIdAttributeTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & FILTER_CONTENT_MATCH_FOR_LEAF_MASK) != 0) {
        closeFile(getSubtreeFilteringForLeafTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & FILTER_CONTENT_MATCH_FOR_LEAF_LIST_MASK) != 0) {
        closeFile(getGetSubtreeFilteringForListTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & FILTER_CONTENT_MATCH_FOR_NODES_MASK) != 0) {
        closeFile(getGetSubtreeFilteringForChildNodeTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & EDIT_CONTENT_MASK) != 0) {
        closeFile(getEditContentTempFileHandle(), true);
    }
}
#method_after
public void freeTemporaryResources(boolean errorOccurred) throws IOException {
    /*
         * Close all java file handles and when error occurs delete the files.
         */
    if (javaFlagSet(INTERFACE_MASK)) {
        closeFile(interfaceJavaFileHandle, errorOccurred);
    }
    if (javaFlagSet(BUILDER_CLASS_MASK)) {
        closeFile(builderClassJavaFileHandle);
    }
    if (javaFlagSet(BUILDER_INTERFACE_MASK)) {
        closeFile(builderInterfaceJavaFileHandle);
    }
    if (javaFlagSet(DEFAULT_CLASS_MASK)) {
        closeFile(implClassJavaFileHandle, errorOccurred);
    }
    /*
         * Close all temporary file handles and delete the files.
         */
    if (tempFlagSet(GETTER_FOR_CLASS_MASK)) {
        closeFile(getterImplTempFileHandle);
    }
    if (tempFlagSet(ATTRIBUTES_MASK)) {
        closeFile(attributesTempFileHandle);
    }
    if (tempFlagSet(HASH_CODE_IMPL_MASK)) {
        closeFile(hashCodeImplTempFileHandle);
    }
    if (tempFlagSet(TO_STRING_IMPL_MASK)) {
        closeFile(toStringImplTempFileHandle);
    }
    if (tempFlagSet(EQUALS_IMPL_MASK)) {
        closeFile(equalsImplTempFileHandle);
    }
    if (tempFlagSet(FROM_STRING_IMPL_MASK)) {
        closeFile(fromStringImplTempFileHandle);
    }
    if (tempFlagSet(ADD_TO_LIST_IMPL_MASK)) {
        closeFile(addToListImplTempFileHandle);
    }
    if (tempFlagSet(ADD_TO_LIST_INTERFACE_MASK)) {
        closeFile(addToListInterfaceTempFileHandle);
    }
    if (tempFlagSet(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK)) {
        closeFile(leafIdAttributeTempFileHandle);
    }
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_LEAF_MASK)) {
        closeFile(subtreeFilteringForLeafTempFileHandle);
    }
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_LEAF_LIST_MASK)) {
        closeFile(getSubtreeFilteringForListTempFileHandle);
    }
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_NODES_MASK)) {
        closeFile(getSubtreeFilteringForChildNodeTempFileHandle);
    }
    if (tempFlagSet(EDIT_CONTENT_MASK)) {
        closeFile(editContentTempFileHandle);
    }
}
#end_block

#method_before
boolean getIsQualifiedAccessOrAddToImportList(JavaQualifiedTypeInfo importInfo) {
    return getJavaImportData().addImportInfo((JavaQualifiedTypeInfoTranslator) importInfo, getGeneratedJavaClassName(), getJavaFileInfo().getPackage());
}
#method_after
protected boolean getIsQualifiedAccessOrAddToImportList(JavaQualifiedTypeInfo importInfo) {
    return javaImportData.addImportInfo((JavaQualifiedTypeInfoTranslator) importInfo, getGeneratedJavaClassName(), javaFileInfo.getPackage());
}
#end_block

#method_before
@Override
public JavaFileInfoTranslator getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName());
    }
    return (JavaFileInfoTranslator) javaFileInfo;
}
#method_after
@Override
public JavaFileInfoTranslator getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException(getErrorMsg(INVALID_NODE, this));
    }
    return (JavaFileInfoTranslator) javaFileInfo;
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    // with builder class.
    try {
        generateCodeOfAugmentableNode(this, yangPlugin);
        addNotificationToExtendsList();
    } catch (IOException e) {
        throw new TranslatorException("Failed to prepare generate code entry for notification node " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + " " + e.getLocalizedMessage());
    }
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    // with builder class.
    try {
        generateCodeOfAugmentableNode(this, yangPlugin);
        addNotificationToExtendsList();
    } catch (IOException e) {
        throw new TranslatorException(getErrorMsg(FAIL_AT_ENTRY, this, e.getLocalizedMessage()));
    }
}
#end_block

#method_before
private void addNotificationToExtendsList() {
    YangNode parent = getParent();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((TempJavaCodeFragmentFilesContainer) parent).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    JavaExtendsListHolder holder = tempJavaServiceFragmentFiles.getJavaExtendsListHolder();
    JavaQualifiedTypeInfoTranslator event = new JavaQualifiedTypeInfoTranslator();
    String parentInfo = getCapitalCase(((JavaFileInfoContainer) parent).getJavaFileInfo().getJavaName());
    event.setClassInfo(parentInfo + EVENT_STRING);
    event.setPkgInfo(getJavaFileInfo().getPackage());
    holder.addToExtendsList(event, parent, tempJavaServiceFragmentFiles);
    JavaQualifiedTypeInfoTranslator eventListener = new JavaQualifiedTypeInfoTranslator();
    eventListener.setClassInfo(parentInfo + EVENT_LISTENER_STRING);
    eventListener.setPkgInfo(getJavaFileInfo().getPackage());
    holder.addToExtendsList(eventListener, parent, tempJavaServiceFragmentFiles);
}
#method_after
private void addNotificationToExtendsList() {
    YangNode parent = getParent();
    TempJavaServiceFragmentFiles tempFiles = ((TempJavaCodeFragmentFilesContainer) parent).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    JavaExtendsListHolder holder = tempFiles.getJavaExtendsListHolder();
    JavaQualifiedTypeInfoTranslator event = new JavaQualifiedTypeInfoTranslator();
    String parentInfo = getCapitalCase(((JavaFileInfoContainer) parent).getJavaFileInfo().getJavaName());
    event.setClassInfo(parentInfo + EVENT_STRING);
    event.setPkgInfo(getJavaFileInfo().getPackage());
    holder.addToExtendsList(event, parent, tempFiles);
    JavaQualifiedTypeInfoTranslator eventListener = new JavaQualifiedTypeInfoTranslator();
    eventListener.setClassInfo(parentInfo + EVENT_LISTENER_STRING);
    eventListener.setPkgInfo(getJavaFileInfo().getPackage());
    holder.addToExtendsList(eventListener, parent, tempFiles);
}
#end_block

#method_before
@Override
public void generateCodeExit() throws TranslatorException {
    try {
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
    } catch (IOException e) {
        throw new TranslatorException("Failed to generate code for notification node " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + " " + e.getLocalizedMessage());
    }
}
#method_after
@Override
public void generateCodeExit() throws TranslatorException {
    try {
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
    } catch (IOException e) {
        throw new TranslatorException(getErrorMsg(FAIL_AT_EXIT, this, e.getLocalizedMessage()));
    }
}
#end_block

#method_before
@Override
public void setNameSpaceAndAddToParentSchemaMap() {
    // Get parent namespace.
    if (this.getParent() != null) {
        String nameSpace = this.getParent().getNameSpace();
        // Set namespace for self node.
        setNameSpace(nameSpace);
        // Process addition of leaf to the child schema map of parent.
        processAdditionOfSchemaNodeToParentMap(getName(), getNameSpace());
        // Obtain the notification name as per enum in notification.
        String enumName = getEnumJavaAttribute(getName().toUpperCase());
        ((RpcNotificationContainer) this.getParent()).addToNotificationEnumMap(enumName, this);
    }
    /*
         * Check if node contains leaf/leaf-list, if yes add namespace for leaf
         * and leaf list.
         */
    this.setLeafNameSpaceAndAddToParentSchemaMap();
}
#method_after
@Override
public void setNameSpaceAndAddToParentSchemaMap() {
    // Get parent namespace.
    if (getParent() != null) {
        String nameSpace = getParent().getNameSpace();
        // Set namespace for self node.
        setNameSpace(nameSpace);
        // Process addition of leaf to the child schema map of parent.
        processAdditionOfSchemaNodeToParentMap(getName(), getNameSpace());
        // Obtain the notification name as per enum in notification.
        String enumName = getEnumJavaAttribute(getName().toUpperCase());
        ((RpcNotificationContainer) getParent()).addToNotificationEnumMap(enumName, this);
    }
    /*
         * Check if node contains leaf/leaf-list, if yes add namespace for leaf
         * and leaf list.
         */
    setLeafNameSpaceAndAddToParentSchemaMap();
}
#end_block

#method_before
public static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangJavaAugmentTranslator) {
        updatePackageForAugmentInfo(javaCodeGeneratorInfo, yangPluginConfig);
    } else {
        javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName(), yangPluginConfig.getConflictResolver()));
        javaCodeGeneratorInfo.getJavaFileInfo().setJavaAttributeName(javaCodeGeneratorInfo.getJavaFileInfo().getJavaName());
        javaCodeGeneratorInfo.getJavaFileInfo().setPackage(getCurNodePackage((YangNode) javaCodeGeneratorInfo));
    }
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPluginConfig.getCodeGenDir());
    javaCodeGeneratorInfo.getJavaFileInfo().setPluginConfig(yangPluginConfig);
}
#method_after
public static void updatePackageInfo(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    JavaFileInfoTranslator translator = info.getJavaFileInfo();
    if (info instanceof YangJavaAugmentTranslator) {
        updatePackageForAugmentInfo(info, config);
    } else {
        translator.setJavaName(getCamelCase(((YangNode) info).getName(), config.getConflictResolver()));
        translator.setJavaAttributeName(info.getJavaFileInfo().getJavaName());
        translator.setPackage(getCurNodePackage((YangNode) info));
    }
    updateCommonPackageInfo(translator, info, config);
}
#end_block

#method_before
private static void updatePackageForAugmentInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getAugmentClassName((YangJavaAugmentTranslator) javaCodeGeneratorInfo, yangPluginConfig));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(getAugmentsNodePackage((YangNode) javaCodeGeneratorInfo, yangPluginConfig));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPluginConfig.getCodeGenDir());
    javaCodeGeneratorInfo.getJavaFileInfo().setPluginConfig(yangPluginConfig);
}
#method_after
private static void updatePackageForAugmentInfo(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    JavaFileInfoTranslator translator = info.getJavaFileInfo();
    translator.setJavaName(getAugmentClassName((YangJavaAugmentTranslator) info, config));
    translator.setPackage(getAugmentsNodePackage((YangNode) info, config));
    updateCommonPackageInfo(translator, info, config);
}
#end_block

#method_before
private static String getAugmentsNodePackage(YangNode yangNode, YangPluginConfig yangPluginConfig) {
    YangAugment augment = (YangAugment) yangNode;
    StringBuilder augmentPkg = new StringBuilder();
    augmentPkg.append(getCurNodePackage(augment));
    String pkg = PERIOD;
    for (YangAtomicPath atomicPath : augment.getTargetNode()) {
        pkg = pkg + getCamelCase(atomicPath.getNodeIdentifier().getName(), yangPluginConfig.getConflictResolver()) + PERIOD;
    }
    pkg = trimAtLast(pkg, PERIOD);
    augmentPkg.append(pkg.toLowerCase());
    return augmentPkg.toString();
}
#method_after
private static String getAugmentsNodePackage(YangNode yangNode, YangPluginConfig config) {
    YangAugment augment = (YangAugment) yangNode;
    StringBuilder augmentPkg = new StringBuilder();
    augmentPkg.append(getCurNodePackage(augment));
    StringBuilder pkg = new StringBuilder();
    pkg.append(PERIOD);
    for (YangAtomicPath atomicPath : augment.getTargetNode()) {
        pkg.append(getCamelCase(atomicPath.getNodeIdentifier().getName(), config.getConflictResolver())).append(PERIOD);
    }
    augmentPkg.append(trimAtLast(pkg.toString(), PERIOD).toLowerCase());
    return augmentPkg.toString();
}
#end_block

#method_before
private static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, String pkg) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName(), yangPlugin.getConflictResolver()));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(pkg);
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPlugin.getCodeGenDir());
    javaCodeGeneratorInfo.getJavaFileInfo().setPluginConfig(yangPlugin);
}
#method_after
private static void updatePackageInfo(JavaCodeGeneratorInfo info, YangPluginConfig config, String pkg) {
    JavaFileInfoTranslator translator = info.getJavaFileInfo();
    translator.setJavaName(getCamelCase(((YangNode) info).getName(), config.getConflictResolver()));
    translator.setPackage(pkg);
    updateCommonPackageInfo(translator, info, config);
}
#end_block

#method_before
private static void createTempFragmentFile(JavaCodeGeneratorInfo javaCodeGeneratorInfo) throws IOException {
    javaCodeGeneratorInfo.setTempJavaCodeFragmentFiles(new TempJavaCodeFragmentFiles(javaCodeGeneratorInfo.getJavaFileInfo()));
}
#method_after
private static void createTempFragmentFile(JavaCodeGeneratorInfo info) throws IOException {
    info.setTempJavaCodeFragmentFiles(new TempJavaCodeFragmentFiles(info.getJavaFileInfo()));
}
#end_block

#method_before
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (javaCodeGeneratorInfo instanceof RpcNotificationContainer) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().setRooNode(true);
        /*
             * Module / sub module node code generation.
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
        if (javaCodeGeneratorInfo instanceof YangJavaModuleTranslator) {
            if (!((YangJavaModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(javaCodeGeneratorInfo, yangPluginConfig);
            }
        } else if (javaCodeGeneratorInfo instanceof YangJavaSubModuleTranslator) {
            if (!((YangJavaSubModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(javaCodeGeneratorInfo, yangPluginConfig);
            }
        }
    }
    if (javaCodeGeneratorInfo instanceof YangLeavesHolder) {
        /*
             * Container
             * Case
             * Grouping
             * Input
             * List
             * Notification
             * Output
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
        // Add operation type as an attribute.
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().addOperationTypeToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangTypeHolder) {
        /*
             * Typedef
             * Union
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addTypeInfoToTempFiles((YangTypeHolder) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangJavaEnumerationTranslator) {
        /*
             * Enumeration
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles().addEnumAttributeToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangChoice) {
    /*Do nothing, only the interface needs to be generated*/
    } else {
        throw new TranslatorException("Unsupported Node Translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
}
#method_after
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    TempJavaCodeFragmentFiles translator = info.getTempJavaCodeFragmentFiles();
    if (info instanceof RpcNotificationContainer) {
        getBeanFiles(info).setRootNode(true);
        /*
             * Module / sub module node code generation.
             */
        translator.getServiceTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) info, config);
        if (info instanceof YangJavaModuleTranslator) {
            if (!((YangJavaModuleTranslator) info).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(info, config);
            }
        } else if (info instanceof YangJavaSubModuleTranslator) {
            if (!((YangJavaSubModuleTranslator) info).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(info, config);
            }
        }
    }
    if (info instanceof YangLeavesHolder) {
        /*
             * Container
             * Case
             * Grouping
             * Input
             * List
             * Notification
             * Output
             */
        getBeanFiles(info).addCurNodeLeavesInfoToTempFiles((YangNode) info, config);
        // Add operation type as an attribute.
        getBeanFiles(info).addOperationTypeToTempFiles((YangNode) info, config);
    } else if (info instanceof YangTypeHolder) {
        /*
             * Typedef
             * Union
             */
        translator.addTypeInfoToTempFiles((YangTypeHolder) info, config);
    } else if (info instanceof YangJavaEnumerationTranslator) {
        /*
             * Enumeration
             */
        translator.getEnumerationTempFiles().addEnumAttributeToTempFiles((YangNode) info, config);
    } else if (info instanceof YangChoice) {
    /*Do nothing, only the interface needs to be generated*/
    } else {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
}
#end_block

#method_before
private static void generateTempFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("translation is not supported for the node " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    createTempFragmentFile(javaCodeGeneratorInfo);
    updateTempFragmentFiles(javaCodeGeneratorInfo, yangPluginConfig);
}
#method_after
private static void generateTempFiles(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    createTempFragmentFile(info);
    updateTempFragmentFiles(info, config);
}
#end_block

#method_before
private static void updateNotificationNodeInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangJavaModuleTranslator) {
        for (YangNode notification : ((YangJavaModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes()) {
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getEventFragmentFiles().addJavaSnippetOfEvent(notification, yangPluginConfig);
        }
    }
    if (javaCodeGeneratorInfo instanceof YangJavaSubModuleTranslator) {
        for (YangNode notification : ((YangJavaSubModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes()) {
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getEventFragmentFiles().addJavaSnippetOfEvent(notification, yangPluginConfig);
        }
    }
}
#method_after
private static void updateNotificationNodeInfo(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    TempJavaCodeFragmentFiles translator = info.getTempJavaCodeFragmentFiles();
    if (info instanceof YangJavaModuleTranslator) {
        for (YangNode notification : ((YangJavaModuleTranslator) info).getNotificationNodes()) {
            translator.getEventFragmentFiles().addJavaSnippetOfEvent(notification, config);
        }
    }
    if (info instanceof YangJavaSubModuleTranslator) {
        for (YangNode notification : ((YangJavaSubModuleTranslator) info).getNotificationNodes()) {
            translator.getEventFragmentFiles().addJavaSnippetOfEvent(notification, config);
        }
    }
}
#end_block

#method_before
public static void generateCodeAndUpdateInParent(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("Invalid node for translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    /*
         * Generate the Java files corresponding to the current node.
         */
    generateCodeOfAugmentableNode(javaCodeGeneratorInfo, yangPlugin);
    /*
         * Update the current nodes info in its parent nodes generated files.
         */
    addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance, yangPlugin);
}
#method_after
public static void generateCodeAndUpdateInParent(JavaCodeGeneratorInfo info, YangPluginConfig config, boolean isMultiInstance) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    /*
         * Generate the Java files corresponding to the current node.
         */
    generateCodeOfAugmentableNode(info, config);
    /*
         * Update the current nodes info in its parent nodes generated files.
         */
    addCurNodeInfoInParentTempFile((YangNode) info, isMultiInstance, config);
}
#end_block

#method_before
public static void generateCodeOfAugmentableNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("invalid node for translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    generateCodeOfNode(javaCodeGeneratorInfo, yangPlugin);
    TempJavaCodeFragmentFiles tempJavaCodeFragmentFiles = javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles();
    if (javaCodeGeneratorInfo instanceof YangCase) {
        YangNode parent = ((YangCase) javaCodeGeneratorInfo).getParent();
        JavaQualifiedTypeInfoTranslator parentsInfo = getQualifierInfoForCasesParent(parent, yangPlugin);
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaExtendsListHolder().addToExtendsList(parentsInfo, (YangNode) javaCodeGeneratorInfo, tempJavaCodeFragmentFiles.getBeanTempFiles());
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().addParentInfoInCurNodeTempFile((YangNode) javaCodeGeneratorInfo, yangPlugin);
    }
}
#method_after
public static void generateCodeOfAugmentableNode(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    generateCodeOfNode(info, config);
    TempJavaCodeFragmentFiles tempFiles = info.getTempJavaCodeFragmentFiles();
    if (info instanceof YangCase) {
        YangNode parent = ((YangCase) info).getParent();
        JavaQualifiedTypeInfoTranslator typeInfo = getQualifierInfoForCasesParent(parent, config);
        getBeanFiles(info).getJavaExtendsListHolder().addToExtendsList(typeInfo, (YangNode) info, tempFiles.getBeanTempFiles());
        getBeanFiles(info).addParentInfoInCurNodeTempFile((YangNode) info, config);
    }
}
#end_block

#method_before
public static JavaQualifiedTypeInfoTranslator getQualifierInfoForCasesParent(YangNode parent, YangPluginConfig yangPluginConfig) {
    String parentName;
    String parentPkg;
    JavaQualifiedTypeInfoTranslator parentsInfo = new JavaQualifiedTypeInfoTranslator();
    JavaFileInfoTranslator parentInfo;
    if (parent instanceof YangChoice) {
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    } else {
        parent = ((YangAugment) parent).getAugmentedNode();
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    }
    if (parentInfo.getPackage() != null) {
        parentName = getCapitalCase(parentInfo.getJavaName());
        parentPkg = parentInfo.getPackage();
    } else {
        parentName = getCapitalCase(getCamelCase(parent.getName(), yangPluginConfig.getConflictResolver()));
        parentPkg = getNodesPackage(parent, yangPluginConfig);
    }
    parentsInfo.setClassInfo(parentName);
    parentsInfo.setPkgInfo(parentPkg);
    return parentsInfo;
}
#method_after
public static JavaQualifiedTypeInfoTranslator getQualifierInfoForCasesParent(YangNode parent, YangPluginConfig config) {
    String parentName;
    String parentPkg;
    JavaFileInfoTranslator parentInfo;
    if (parent instanceof YangChoice) {
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    } else {
        parent = ((YangAugment) parent).getAugmentedNode();
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    }
    if (parentInfo.getPackage() != null) {
        parentName = getCapitalCase(parentInfo.getJavaName());
        parentPkg = parentInfo.getPackage();
    } else {
        parentName = getCapitalCase(getCamelCase(parent.getName(), config.getConflictResolver()));
        parentPkg = getNodesPackage(parent, config);
    }
    JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = new JavaQualifiedTypeInfoTranslator();
    qualifiedTypeInfo.setClassInfo(parentName);
    qualifiedTypeInfo.setPkgInfo(parentPkg);
    return qualifiedTypeInfo;
}
#end_block

#method_before
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("invalid node for translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPluginConfig);
    generateTempFiles(javaCodeGeneratorInfo, yangPluginConfig);
}
#method_after
public static void generateCodeOfNode(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    updatePackageInfo(info, config);
    generateTempFiles(info, config);
}
#end_block

#method_before
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig, String rootPkg) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("invalid node for translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPluginConfig, rootPkg);
    if (isRpcChildNodePresent((YangNode) javaCodeGeneratorInfo)) {
        javaCodeGeneratorInfo.getJavaFileInfo().addGeneratedFileTypes(GENERATE_SERVICE_AND_MANAGER);
    }
    generateTempFiles(javaCodeGeneratorInfo, yangPluginConfig);
}
#method_after
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo info, YangPluginConfig config, String rootPkg) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    updatePackageInfo(info, config, rootPkg);
    if (isRpcChildNodePresent((YangNode) info)) {
        info.getJavaFileInfo().addGeneratedFileTypes(GENERATE_SERVICE_AND_MANAGER);
    }
    generateTempFiles(info, config);
}
#end_block

#method_before
public static String getCurNodePackage(YangNode curNode) {
    String pkg;
    if (!(curNode instanceof JavaFileInfoContainer) || curNode.getParent() == null) {
        throw new TranslatorException("missing parent node to get current node's package " + curNode.getName() + " in " + curNode.getLineNumber() + " at " + curNode.getCharPosition() + " in " + curNode.getFileName());
    }
    YangNode parentNode = DataModelUtils.getParentNodeInGenCode(curNode);
    if (!(parentNode instanceof JavaFileInfoContainer)) {
        throw new TranslatorException("missing parent java node to get current node's package " + curNode.getName() + " in " + curNode.getLineNumber() + " at " + curNode.getCharPosition() + " in " + curNode.getFileName());
    }
    JavaFileInfoTranslator parentJavaFileHandle = ((JavaFileInfoContainer) parentNode).getJavaFileInfo();
    pkg = parentJavaFileHandle.getPackage() + PERIOD + parentJavaFileHandle.getJavaName();
    return pkg.toLowerCase();
}
#method_after
public static String getCurNodePackage(YangNode curNode) throws TranslatorException {
    String pkg;
    if (!(curNode instanceof JavaFileInfoContainer) || curNode.getParent() == null) {
        throw new TranslatorException(getErrorMsg(INVALID_NODE, curNode));
    }
    YangNode parentNode = DataModelUtils.getParentNodeInGenCode(curNode);
    if (!(parentNode instanceof JavaFileInfoContainer)) {
        throw new TranslatorException(getErrorMsg(INVALID_PARENT_NODE, curNode));
    }
    JavaFileInfoTranslator handle = ((JavaFileInfoContainer) parentNode).getJavaFileInfo();
    pkg = handle.getPackage() + PERIOD + handle.getJavaName();
    return pkg.toLowerCase();
}
#end_block

#method_before
public static boolean isRootNodesCodeGenRequired(YangNode node) {
    YangLeavesHolder holder = (YangLeavesHolder) node;
    if (holder.getListOfLeaf().isEmpty()) {
        if (holder.getListOfLeafList().isEmpty()) {
            YangNode tempNode = node.getChild();
            if (tempNode == null) {
                return false;
            }
            while (tempNode != null) {
                if (!(tempNode instanceof YangTranslatorOperatorNode)) {
                    return true;
                }
                tempNode = tempNode.getNextSibling();
            }
            return false;
        } else {
            return true;
        }
    } else {
        return true;
    }
}
#method_after
public static boolean isRootNodesCodeGenRequired(YangNode node) {
    return isNodeCodeGenRequired(node, true);
}
#end_block

#method_before
public static boolean isGetSetOfRootNodeRequired(YangNode curNode) {
    YangLeavesHolder holder = (YangLeavesHolder) curNode;
    if (holder.getListOfLeaf().isEmpty()) {
        if (holder.getListOfLeafList().isEmpty()) {
            curNode = curNode.getChild();
            if (curNode == null) {
                return false;
            }
            while (curNode != null) {
                if (!(curNode instanceof YangAugment)) {
                    return true;
                }
                curNode = curNode.getNextSibling();
            }
            return false;
        } else {
            return true;
        }
    } else {
        return true;
    }
}
#method_after
public static boolean isGetSetOfRootNodeRequired(YangNode node) {
    return isNodeCodeGenRequired(node, false);
}
#end_block

#method_before
public static String getNodesPackage(YangNode node, YangPluginConfig yangPluginConfig) {
    List<String> clsInfo = new ArrayList<>();
    while (node.getParent() != null) {
        if (node instanceof YangJavaAugmentTranslator) {
            clsInfo.add(getAugmentClassName((YangAugment) node, yangPluginConfig));
        } else {
            clsInfo.add(getCamelCase(node.getName(), yangPluginConfig.getConflictResolver()));
        }
        node = node.getParent();
    }
    StringBuilder pkg = new StringBuilder();
    if (node instanceof YangJavaModuleTranslator) {
        YangJavaModuleTranslator module = (YangJavaModuleTranslator) node;
        pkg.append(getRootPackage(module.getVersion(), module.getNameSpace(), module.getRevision(), yangPluginConfig.getConflictResolver()));
    } else if (node instanceof YangJavaSubModuleTranslator) {
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        pkg.append(getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(), subModule.getRevision(), yangPluginConfig.getConflictResolver()));
    }
    String concat = "";
    for (int i = 1; i <= clsInfo.size(); i++) {
        concat = concat + "." + clsInfo.get(clsInfo.size() - i);
    }
    pkg.append(concat);
    return pkg.toString().toLowerCase();
}
#method_after
public static String getNodesPackage(YangNode node, YangPluginConfig config) {
    List<String> clsInfo = new ArrayList<>();
    while (node.getParent() != null) {
        if (node instanceof YangJavaAugmentTranslator) {
            clsInfo.add(getAugmentClassName((YangAugment) node, config));
        } else {
            clsInfo.add(getCamelCase(node.getName(), config.getConflictResolver()));
        }
        node = node.getParent();
    }
    StringBuilder pkg = new StringBuilder();
    if (node instanceof YangJavaModuleTranslator) {
        YangJavaModuleTranslator module = (YangJavaModuleTranslator) node;
        pkg.append(getRootPackage(module.getVersion(), module.getNameSpace(), module.getRevision(), config.getConflictResolver()));
    } else if (node instanceof YangJavaSubModuleTranslator) {
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        pkg.append(getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(), subModule.getRevision(), config.getConflictResolver()));
    }
    pkg.append(EMPTY_STRING);
    int size = clsInfo.size();
    for (int i = size - 1; i >= 0; i--) {
        pkg.append(PERIOD).append(clsInfo.get(i));
    }
    return pkg.toString().toLowerCase();
}
#end_block

#method_before
private static String getAugmentClassName(YangAugment augment, YangPluginConfig yangPluginConfig) {
    YangNodeIdentifier yangNodeIdentifier = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier();
    String name = getCapitalCase(getCamelCase(yangNodeIdentifier.getName(), yangPluginConfig.getConflictResolver()));
    if (yangNodeIdentifier.getPrefix() != null) {
        return AUGMENTED + getCapitalCase(getCamelCase(yangNodeIdentifier.getPrefix(), yangPluginConfig.getConflictResolver())) + name;
    } else {
        return AUGMENTED + name;
    }
}
#method_after
private static String getAugmentClassName(YangAugment augment, YangPluginConfig config) {
    YangNodeIdentifier identifier = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier();
    String name = getCapitalCase(getCamelCase(identifier.getName(), config.getConflictResolver()));
    if (identifier.getPrefix() != null) {
        return AUGMENTED + getCapitalCase(getCamelCase(identifier.getPrefix(), config.getConflictResolver())) + name;
    }
    return AUGMENTED + name;
}
#end_block

#method_before
public static String getJavaAttributeDefinition(String javaAttributeTypePkg, String javaAttributeType, String javaAttributeName, boolean isList, String attributeAccessType, YangCompilerAnnotation compilerAnnotation) {
    String attributeDefinition = attributeAccessType + SPACE;
    if (!isList) {
        if (javaAttributeTypePkg != null) {
            attributeDefinition = attributeDefinition + javaAttributeTypePkg + PERIOD;
        }
        attributeDefinition = attributeDefinition + javaAttributeType + SPACE + javaAttributeName + SEMI_COLAN + NEW_LINE;
    } else {
        if (compilerAnnotation != null && compilerAnnotation.getYangAppDataStructure() != null) {
            switch(compilerAnnotation.getYangAppDataStructure().getDataStructure()) {
                case QUEUE:
                    {
                        attributeDefinition = attributeDefinition + QUEUE + DIAMOND_OPEN_BRACKET;
                        break;
                    }
                case SET:
                    {
                        attributeDefinition = attributeDefinition + SET + DIAMOND_OPEN_BRACKET;
                        break;
                    }
                default:
                    {
                        attributeDefinition = attributeDefinition + LIST + DIAMOND_OPEN_BRACKET;
                    }
            }
        } else {
            attributeDefinition = attributeDefinition + LIST + DIAMOND_OPEN_BRACKET;
        }
        if (javaAttributeTypePkg != null) {
            attributeDefinition = attributeDefinition + javaAttributeTypePkg + PERIOD;
        }
        attributeDefinition = attributeDefinition + javaAttributeType;
        if (compilerAnnotation != null && compilerAnnotation.getYangAppDataStructure() != null) {
            switch(compilerAnnotation.getYangAppDataStructure().getDataStructure()) {
                default:
                    {
                        attributeDefinition = attributeDefinition + DIAMOND_CLOSE_BRACKET + SPACE + javaAttributeName + SEMI_COLAN + NEW_LINE;
                    }
            }
        } else {
            attributeDefinition = attributeDefinition + DIAMOND_CLOSE_BRACKET + SPACE + javaAttributeName + SPACE + EQUAL + SPACE + NEW + SPACE + ARRAY_LIST + SEMI_COLAN + NEW_LINE;
        }
    }
    return attributeDefinition;
}
#method_after
public static String getJavaAttributeDefinition(String typePkg, String attrType, String attrName, boolean isList, String accessType, YangCompilerAnnotation annotation) {
    StringBuilder attrDef = new StringBuilder();
    attrDef.append(accessType).append(SPACE);
    if (!isList) {
        if (typePkg != null) {
            attrDef.append(typePkg).append(PERIOD);
        }
        attrDef.append(attrType).append(SPACE).append(attrName).append(SEMI_COLAN).append(NEW_LINE);
    } else {
        // Add starting definition.
        addAttrStartDef(annotation, attrDef);
        if (typePkg != null) {
            attrDef.append(typePkg).append(PERIOD);
        }
        attrDef.append(attrType);
        // Add ending definition.
        addAttrEndDef(annotation, attrDef, attrName);
    }
    return attrDef.toString();
}
#end_block

#method_before
public static String generateEnumAttributeStringWithSchemaName(String name, int value, YangPluginConfig pluginConfig) {
    String enumName = getEnumJavaAttribute(name);
    return NEW_LINE + getJavaDoc(ENUM_ATTRIBUTE, name, false, pluginConfig, null) + FOUR_SPACE_INDENTATION + enumName.toUpperCase() + OPEN_PARENTHESIS + value + COMMA + SPACE + QUOTES + name + QUOTES + CLOSE_PARENTHESIS + COMMA + NEW_LINE;
}
#method_after
public static String generateEnumAttributeStringWithSchemaName(String name, int value, YangPluginConfig config) {
    String enumName = getEnumJavaAttribute(name);
    return NEW_LINE + getJavaDoc(ENUM_ATTRIBUTE, name, false, config, null) + FOUR_SPACE_INDENTATION + enumName.toUpperCase() + OPEN_PARENTHESIS + value + COMMA + SPACE + QUOTES + name + QUOTES + CLOSE_PARENTHESIS + COMMA + NEW_LINE;
}
#end_block

#method_before
public static void addListenersImport(YangNode curNode, List<String> imports, boolean operation, String classInfo) {
    String thisImport;
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    if (classInfo.equals(LISTENER_SERVICE)) {
        thisImport = tempJavaServiceFragmentFiles.getJavaImportData().getListenerServiceImport();
        performOperationOnImports(imports, thisImport, operation);
    } else {
        thisImport = tempJavaServiceFragmentFiles.getJavaImportData().getListenerRegistryImport();
        performOperationOnImports(imports, thisImport, operation);
    }
}
#method_after
public static void addListenersImport(YangNode curNode, List<String> imports, Operation operation, String classInfo) {
    String thisImport;
    TempJavaServiceFragmentFiles tempFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    if (classInfo.equals(LISTENER_SERVICE)) {
        thisImport = tempFiles.getJavaImportData().getListenerServiceImport();
        performOperationOnImports(imports, thisImport, operation);
    } else {
        thisImport = tempFiles.getJavaImportData().getListenerRegistryImport();
        performOperationOnImports(imports, thisImport, operation);
    }
}
#end_block

#method_before
private static List<String> performOperationOnImports(List<String> imports, String curImport, boolean operation) {
    if (operation) {
        imports.add(curImport);
    } else {
        imports.remove(curImport);
    }
    sortImports(imports);
    return imports;
}
#method_after
private static List<String> performOperationOnImports(List<String> imports, String curImport, Operation operation) {
    switch(operation) {
        case ADD:
            imports.add(curImport);
            break;
        case REMOVE:
            imports.remove(curImport);
            break;
        default:
            throw new TranslatorException("Invalid operation type");
    }
    sortImports(imports);
    return imports;
}
#end_block

#method_before
static String addStaticAttributeIntRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + INT_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + INT_MAX_RANGE_ATTR;
    } else {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT_MAX_RANGE_ATTR;
    }
}
#method_after
static String addStaticAttributeIntRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + INT_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + INT_MAX_RANGE_ATTR;
    }
    return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT_MAX_RANGE_ATTR;
}
#end_block

#method_before
static String addStaticAttributeLongRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + LONG_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + LONG_MAX_RANGE_ATTR;
    } else {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + ULONG_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + ULONG_MAX_RANGE_ATTR;
    }
}
#method_after
static String addStaticAttributeLongRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + LONG_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + LONG_MAX_RANGE_ATTR;
    }
    return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + ULONG_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + ULONG_MAX_RANGE_ATTR;
}
#end_block

#method_before
static String addStaticAttributeShortRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + SHORT_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + SHORT_MAX_RANGE_ATTR;
    } else {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT8_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT8_MAX_RANGE_ATTR;
    }
}
#method_after
static String addStaticAttributeShortRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + SHORT_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + SHORT_MAX_RANGE_ATTR;
    }
    return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT8_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT8_MAX_RANGE_ATTR;
}
#end_block

#method_before
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    // Generate ENUM interface
    insertDataIntoJavaFile(file, getOperationTypeEnum());
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (isLeavesPresent) {
                insertDataIntoJavaFile(file, NEW_LINE + getInterfaceLeafIdEnumSignature(className) + NEW_LINE + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path), COMMA, SEMI_COLAN), NEW_LINE) + NEW_LINE + NEW_LINE + getInterfaceLeafIdEnumMethods());
            }
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, javaFileInfo.getPluginConfig());
        methods.add(NEW_LINE + processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(NEW_LINE + processSubtreeFilteringInterface(className));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + isLeafValueSetInterface());
        methods.add(NEW_LINE + isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    // Generate ENUM interface
    insertDataIntoJavaFile(file, getOperationTypeEnum());
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (leavesPresent) {
                insertDataIntoJavaFile(file, NEW_LINE + getInterfaceLeafIdEnumSignature(className) + NEW_LINE + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, getBeanFiles(curNode), path), COMMA, SEMI_COLAN), NEW_LINE) + NEW_LINE + NEW_LINE + getInterfaceLeafIdEnumMethods());
            }
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, INTERFACE));
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(fileInfo.getPluginConfig()));
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, fileInfo.getPluginConfig());
        methods.add(NEW_LINE + processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(NEW_LINE + processSubtreeFilteringInterface(className));
    }
    if (leavesPresent) {
        methods.add(NEW_LINE + isLeafValueSetInterface());
        methods.add(NEW_LINE + isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            // Getter methods.
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list method.
            methods.add(NEW_LINE);
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ADD_TO_LIST_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getAddAugmentInfoMethodInterface());
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + setSelectLeafSetInterface(className));
    }
    // Add build method to builder interface file.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    // Add getters and setters in builder interface.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = fileInfo.getPluginConfig();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        try {
            // Getter methods.
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, getBeanFiles(curNode), path));
            // Setter methods.
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, getBeanFiles(curNode), path));
            // Add to list method.
            methods.add(NEW_LINE);
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ADD_TO_LIST_INTERFACE_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_INTERFACE));
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getAddAugmentInfoMethodInterface());
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(fileInfo.getPluginConfig()));
    }
    if (leavesPresent) {
        methods.add(NEW_LINE + setSelectLeafSetInterface(className));
    }
    // Add build method to builder interface file.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    // Add getters and setters in builder interface.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
/**
 * Returns generated builder class file for current node.
 *
 * @param file          file
 * @param curNode       current YANG node
 * @param isAttrPresent if any attribute is present or not
 * @return builder class file
 * @throws IOException when fails to write in file
 */
public static File generateBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isRootNode = false;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder class file generation");
        }
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            // Add operation attribute methods.
            if (isLeavesPresent) {
                methods.add(getOperationAttributesGetters() + NEW_LINE);
                methods.add(getSetterForSelectLeaf(className, isRootNode));
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl(curNode));
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER, pluginConfig, curNode));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#method_after
public static File generateBuilderClassFile(File file, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    boolean isRootNode = false;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        isRootNode = true;
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (attrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_CLASS));
        }
        if (leavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, getBeanFiles(curNode), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, getBeanFiles(curNode), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, getBeanFiles(curNode), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            // Add operation attribute methods.
            if (leavesPresent) {
                methods.add(getOperationAttributesGetters() + NEW_LINE);
                methods.add(getSetterForSelectLeaf(className, isRootNode));
            }
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_CLASS));
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl(curNode));
    methods.add(addDefaultConstructor(curNode, PUBLIC, BUILDER, config, curNode));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#end_block

#method_before
public static File generateDefaultClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    boolean isRootNode = false;
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        opParamClassName = className + OP_PARAM;
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while impl class file generation");
        }
        // Add operation attributes
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Hash code method.
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            // Equals method.
            if (isRootNode) {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(opParamClassName) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            } else {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            }
            // To string method.
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, pluginConfig, isRootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        if (isLeavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        if (curNode instanceof YangAugmentableNode) {
            constructor = constructor + getYangAugmentedMapObjectForConstruct();
        }
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        // add is filter content match.
        String augmentableSubTreeFiltering = "";
        if (curNode instanceof YangAugmentableNode) {
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(getProcessSubtreeFilteringStart(curNode, pluginConfig) + getProcessSubtreeFunctionBody(curNode) + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd());
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
                methods.add(getProcessLeafSubtreeFiltering(curNode, pluginConfig, path));
            }
        }
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
                methods.add(getProcessLeafListSubtreeFiltering(curNode, pluginConfig, path));
            }
        }
        if (curNode.getChild() != null) {
            methods.add(getProcessChildNodeSubtreeFiltering(curNode, pluginConfig, path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PROTECTED, DEFAULT, pluginConfig, curNode));
    methods.add(builderMethod(className) + NEW_LINE);
    if (isLeavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateDefaultClassFile(File file, YangNode curNode, boolean attrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    boolean rootNode = false;
    String className = getCapitalCase(fileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        opParamClassName = className + OP_PARAM;
        rootNode = true;
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (attrPresent) {
        addDefaultClassAttributeInfo(file, curNode, className, opParamClassName, path, methods, leavesPresent, rootNode);
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, config, rootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, getBeanFiles(curNode), path);
        if (leavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        if (curNode instanceof YangAugmentableNode) {
            constructor = constructor + getYangAugmentedMapObjectForConstruct();
        }
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        // add is filter content match.
        String augmentableSubTreeFiltering = EMPTY_STRING;
        if (curNode instanceof YangAugmentableNode) {
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(getProcessSubtreeFilteringStart(curNode, config) + getProcessSubtreeFunctionBody(curNode) + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd());
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
                methods.add(getProcessLeafSubtreeFiltering(curNode, config, path));
            }
        }
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
                methods.add(getProcessLeafListSubtreeFiltering(curNode, config, path));
            }
        }
        if (curNode.getChild() != null) {
            methods.add(getProcessChildNodeSubtreeFiltering(curNode, config, path));
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, IMPL_CLASS));
    }
    methods.add(addDefaultConstructor(curNode, PROTECTED, DEFAULT, config, curNode));
    methods.add(builderMethod(className) + NEW_LINE);
    if (leavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        if (type.getDataType().equals(BINARY)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(BITS)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if ((type.getDataType().equals(YangDataTypes.DERIVED)) && (((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType().equals(YangDataTypes.IDENTITYREF))) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (type.getDataType().equals(YangDataTypes.IDENTITYREF)) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (!yangDataTypes.equals(YangDataTypes.IDENTITYREF)) {
            methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(fileInfo.getJavaName());
    String path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, config);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, getTypeFiles(curNode), path));
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, TYPEDEF_CLASS));
    }
    // Default constructor.
    methods.add(addDefaultConstructor(curNode, PRIVATE, EMPTY_STRING, config, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, getTypeFiles(curNode), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, getTypeFiles(curNode), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, getTypeFiles(curNode), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, getTypeFiles(curNode), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, getTypeFiles(curNode), path)));
        // To string method.
        addTypedefToString(curNode, methods, path, type);
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if ((type.getDataType().equals(YangDataTypes.DERIVED)) && (((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType().equals(YangDataTypes.IDENTITYREF))) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (type.getDataType().equals(YangDataTypes.IDENTITYREF)) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (!yangDataTypes.equals(YangDataTypes.IDENTITYREF)) {
            methods.add(getFromStringMethodSignature(className, config) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, TYPEDEF_CLASS));
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    TempJavaTypeFragmentFiles tempJavaTypeFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles();
    boolean isIntConflict = false;
    boolean isLongConflict = false;
    boolean isShortConflict = false;
    JavaAttributeInfo intAttr = tempJavaTypeFragmentFiles.getIntAttribute();
    if (intAttr == null) {
        intAttr = tempJavaTypeFragmentFiles.getUIntAttribute();
    }
    JavaAttributeInfo longAttr = tempJavaTypeFragmentFiles.getLongAttribute();
    if (longAttr == null) {
        longAttr = tempJavaTypeFragmentFiles.getULongAttribute();
    }
    JavaAttributeInfo shortAttr = tempJavaTypeFragmentFiles.getShortAttribute();
    if (shortAttr == null) {
        shortAttr = tempJavaTypeFragmentFiles.getUInt8Attribute();
    }
    if (intAttr != null) {
        isIntConflict = intAttr.isIntConflict();
    }
    if (longAttr != null) {
        isLongConflict = longAttr.isLongConflict();
    }
    if (shortAttr != null) {
        isShortConflict = shortAttr.isShortConflict();
    }
    if (isLongConflict) {
        imports.add(tempJavaTypeFragmentFiles.getJavaImportData().getBigIntegerImport());
        sort(imports);
    }
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        if (isIntConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeIntRange(PRIVATE, tempJavaTypeFragmentFiles.getIntIndex() < tempJavaTypeFragmentFiles.getUIntIndex()));
        }
        if (isLongConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeLongRange(PRIVATE, tempJavaTypeFragmentFiles.getLongIndex() < tempJavaTypeFragmentFiles.getULongIndex()));
        }
        if (isShortConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeShortRange(PRIVATE, tempJavaTypeFragmentFiles.getShortIndex() < tempJavaTypeFragmentFiles.getUInt8Index()));
        }
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of string method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        // From string method.
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        if (isIntConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
        if (isLongConflict) {
            methods.add(getRangeValidatorMethodForUnion(BIG_INTEGER));
        }
        if (isShortConflict && !isIntConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    String className = getCapitalCase(fileInfo.getJavaName());
    String path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    TempJavaTypeFragmentFiles tempFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles();
    boolean intConflict = false;
    boolean longConflict = false;
    boolean shortConflict = false;
    JavaAttributeInfo intAttr = tempFiles.getIntAttribute();
    if (intAttr == null) {
        intAttr = tempFiles.getUIntAttribute();
    }
    JavaAttributeInfo longAttr = tempFiles.getLongAttribute();
    if (longAttr == null) {
        longAttr = tempFiles.getULongAttribute();
    }
    JavaAttributeInfo shortAttr = tempFiles.getShortAttribute();
    if (shortAttr == null) {
        shortAttr = tempFiles.getUInt8Attribute();
    }
    if (intAttr != null) {
        intConflict = intAttr.isIntConflict();
    }
    if (longAttr != null) {
        longConflict = longAttr.isLongConflict();
    }
    if (shortAttr != null) {
        shortConflict = shortAttr.isShortConflict();
    }
    if (longConflict) {
        imports.add(tempFiles.getJavaImportData().getBigIntegerImport());
        sort(imports);
    }
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path, config);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        addUnionClassAttributeInfo(file, curNode, intConflict, longConflict, shortConflict, path, tempFiles);
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, UNION_CLASS));
    }
    // Default constructor.
    methods.add(addDefaultConstructor(curNode, PRIVATE, EMPTY_STRING, config, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, getTypeFiles(curNode), path));
        // Of string method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, getTypeFiles(curNode), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, getTypeFiles(curNode), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, getTypeFiles(curNode), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, getTypeFiles(curNode), path)));
        // To string method.
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, getTypeFiles(curNode), path) + getToStringMethodClose());
        // From string method.
        methods.add(getFromStringMethodSignature(className, config) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, getTypeFiles(curNode), path) + getFromStringMethodClose());
        if (intConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
        if (longConflict) {
            methods.add(getRangeValidatorMethodForUnion(BIG_INTEGER));
        }
        if (shortConflict && !intConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, UNION_CLASS));
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    // Add attribute strings.
    try {
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class " + "file generation");
    }
    // Add an attribute to get the enum's values.
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    // Add a constructor for enum.
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig, null) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    insertDataIntoJavaFile(file, getEnumsOfValueMethod(className, (YangEnumeration) curNode, pluginConfig) + NEW_LINE);
    insertDataIntoJavaFile(file, getEnumValueOfSchemaNameMethod(className, pluginConfig, (YangEnumeration) curNode));
    // Add a getter method for enum.
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig, null) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, SCHEMA_NAME, false, pluginConfig, null) + getGetter(STRING_DATA_TYPE, SCHEMA_NAME, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    String className = fileInfo.getJavaName();
    String path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, config);
    // Add attribute strings.
    try {
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException(getErrorMsg(getCapitalCase(className), ENUM_CLASS));
    }
    // Add an attribute to get the enum's values.
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    // Add a constructor for enum.
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, config, null) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    insertDataIntoJavaFile(file, getEnumsOfValueMethod(className, (YangEnumeration) curNode, config) + NEW_LINE);
    insertDataIntoJavaFile(file, getEnumValueOfSchemaNameMethod(className, config, (YangEnumeration) curNode));
    // Add a getter method for enum.
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, config, null) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, SCHEMA_NAME, false, config, null) + getGetter(STRING_DATA_TYPE, SCHEMA_NAME, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), config) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException(getErrorMsg(getCapitalCase(className), ENUM_CLASS));
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        if (isGetSetOfRootNodeRequired(curNode)) {
            // Getter methods.
            methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
            // Setter methods.
            methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        }
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(fileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempFiles);
    try {
        if (isGetSetOfRootNodeRequired(curNode)) {
            // Getter methods.
            methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER, fileInfo.getPluginConfig()) + NEW_LINE);
            // Setter methods.
            methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER, fileInfo.getPluginConfig()) + NEW_LINE);
        }
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, RPC_CLASS));
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static void generateEventFile(File file, YangNode curNode, List<String> imports) throws IOException {
    String className = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName()) + EVENT_STRING;
    TempJavaEventFragmentFiles tempFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEventFragmentFiles();
    String path = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getBaseCodeGenPath() + ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_EVENT_CLASS, imports, curNode, className);
    try {
        insertDataIntoJavaFile(file, NEW_LINE + getEventEnumTypeStart() + trimAtLast(getDataFromTempFileHandle(EVENT_ENUM_MASK, tempFiles, path), COMMA) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_METHOD_MASK, tempFiles, path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while event class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    validateLineLength(file);
}
#method_after
public static void generateEventFile(File file, YangNode curNode, List<String> imports) throws IOException {
    String className = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName()) + EVENT_STRING;
    TempJavaEventFragmentFiles tempFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEventFragmentFiles();
    String path = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getBaseCodeGenPath() + ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_EVENT_CLASS, imports, curNode, className);
    try {
        insertDataIntoJavaFile(file, NEW_LINE + getEventEnumTypeStart() + trimAtLast(getDataFromTempFileHandle(EVENT_ENUM_MASK, tempFiles, path), COMMA) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_METHOD_MASK, tempFiles, path));
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, EVENT_CLASS));
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    validateLineLength(file);
}
#end_block

#method_before
public static void generateEventSubjectFile(File file, YangNode curNode) throws IOException {
    String className = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName()) + EVENT_SUBJECT_NAME_SUFFIX;
    initiateJavaFileGeneration(file, GENERATE_EVENT_SUBJECT_CLASS, null, curNode, className);
    String path = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getBaseCodeGenPath() + ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackageFilePath();
    TempJavaEventFragmentFiles tempFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEventFragmentFiles();
    insertDataIntoJavaFile(file, NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_ATTRIBUTE_MASK, tempFiles, path));
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_GETTER_MASK, tempFiles, path));
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_SETTER_MASK, tempFiles, path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while event class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    validateLineLength(file);
}
#method_after
public static void generateEventSubjectFile(File file, YangNode curNode) throws IOException {
    String className = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName()) + EVENT_SUBJECT_NAME_SUFFIX;
    initiateJavaFileGeneration(file, GENERATE_EVENT_SUBJECT_CLASS, null, curNode, className);
    String path = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getBaseCodeGenPath() + ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackageFilePath();
    TempJavaEventFragmentFiles tempFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEventFragmentFiles();
    insertDataIntoJavaFile(file, NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_ATTRIBUTE_MASK, tempFiles, path));
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_GETTER_MASK, tempFiles, path));
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_SETTER_MASK, tempFiles, path));
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, EVENT_CLASS));
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    validateLineLength(file);
}
#end_block

#method_before
public void handlePacket(PacketContext context) {
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    NeighbourMessageContext msgContext = DefaultNeighbourMessageContext.createContext(ethPkt, pkt.receivedFrom(), actions);
    if (msgContext == null) {
        return;
    }
    if (handleMessage(msgContext)) {
        context.block();
    }
    return;
}
#method_after
public void handlePacket(PacketContext context) {
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    NeighbourMessageContext msgContext = DefaultNeighbourMessageContext.createContext(ethPkt, pkt.receivedFrom(), actions);
    if (msgContext == null) {
        return;
    }
    if (handleMessage(msgContext)) {
        context.block();
    }
}
#end_block

#method_before
private boolean handleMessage(NeighbourMessageContext context) {
    Collection<NeighbourHandlerRegistration> handlers = packetHandlers.get(context.inPort());
    Collection<NeighbourHandlerRegistration> handled = handlers.stream().filter(registration -> registration.intf() == null || matches(context, registration.intf())).collect(Collectors.toSet());
    handled.forEach(registration -> registration.handler().handleMessage(context, hostService));
    return handled.isEmpty() ? false : true;
}
#method_after
private boolean handleMessage(NeighbourMessageContext context) {
    Collection<NeighbourHandlerRegistration> handlers = packetHandlers.get(context.inPort());
    Collection<NeighbourHandlerRegistration> handled = handlers.stream().filter(registration -> registration.intf() == null || matches(context, registration.intf())).collect(Collectors.toSet());
    handled.forEach(registration -> registration.handler().handleMessage(context, hostService));
    return !handled.isEmpty();
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(VPLS_APP);
    components.forEach(name -> componentService.activate(appId, name));
    log.info("VPLS started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(VPLS_APP);
    intentInstaller = new IntentInstaller(appId, intentService, intentSynchronizer);
    applicationService.registerDeactivateHook(appId, () -> {
        intentSynchronizer.removeIntentsByAppId(appId);
    });
    hostService.addListener(hostListener);
    interfaceService.addListener(interfaceListener);
    setupConnectivity();
    log.debug("Activated");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    components.forEach(name -> componentService.deactivate(appId, name));
    log.info("VPLS stopped");
}
#method_after
@Deactivate
public void deactivate() {
    intentSynchronizer.removeIntentsByAppId(appId);
    log.debug("Deactivated");
}
#end_block

#method_before
protected void installIntents(SetMultimap<VlanId, Pair<ConnectPoint, MacAddress>> confHostPresentCPoint) {
    List<Intent> intents = new ArrayList<>();
    confHostPresentCPoint.keySet().stream().filter(vlanId -> confHostPresentCPoint.get(vlanId) != null).forEach(vlanId -> {
        Set<Pair<ConnectPoint, MacAddress>> cPoints = confHostPresentCPoint.get(vlanId);
        cPoints.forEach(cPoint -> {
            MacAddress mac = cPoint.getValue();
            ConnectPoint src = cPoint.getKey();
            Set<ConnectPoint> dsts = cPoints.stream().map(Pair::getKey).filter(cp -> !cp.equals(src)).collect(Collectors.toSet());
            Key brcKey = buildKey(PREFIX_BROADCAST, src, vlanId);
            if (intentService.getIntent(brcKey) == null && dsts.size() != 0) {
                intents.add(buildBrcIntent(brcKey, src, dsts, vlanId));
            }
            if (mac != null && countMacInCPoints(cPoints) > 1 && dsts.size() != 0) {
                Key uniKey = buildKey(PREFIX_UNICAST, src, vlanId);
                if (intentService.getIntent(uniKey) == null) {
                    MultiPointToSinglePointIntent uniIntent = buildUniIntent(uniKey, dsts, src, vlanId, mac);
                    intents.add(uniIntent);
                }
            }
        });
    });
    submitIntents(intents);
}
#method_after
protected void installIntents(SetMultimap<VlanId, Pair<ConnectPoint, MacAddress>> confHostPresentCPoint) {
    List<Intent> intents = new ArrayList<>();
    confHostPresentCPoint.keySet().stream().filter(vlanId -> confHostPresentCPoint.get(vlanId) != null).forEach(vlanId -> {
        Set<Pair<ConnectPoint, MacAddress>> cPoints = confHostPresentCPoint.get(vlanId);
        cPoints.forEach(cPoint -> {
            MacAddress mac = cPoint.getValue();
            ConnectPoint src = cPoint.getKey();
            Set<ConnectPoint> dsts = cPoints.stream().map(Pair::getKey).filter(cp -> !cp.equals(src)).collect(Collectors.toSet());
            Key brcKey = buildKey(PREFIX_BROADCAST, src, vlanId);
            if (intentService.getIntent(brcKey) == null && dsts.size() > 0) {
                intents.add(buildBrcIntent(brcKey, src, dsts, vlanId));
            }
            if (mac != null && countMacInCPoints(cPoints) > 1 && dsts.size() > 0) {
                Key uniKey = buildKey(PREFIX_UNICAST, src, vlanId);
                if (intentService.getIntent(uniKey) == null) {
                    MultiPointToSinglePointIntent uniIntent = buildUniIntent(uniKey, dsts, src, vlanId, mac);
                    intents.add(uniIntent);
                }
            }
        });
    });
    submitIntents(intents);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    idGenerator = new TestIdGenerator();
    Intent.bindIdGenerator(idGenerator);
    applicationService = createMock(ApplicationService.class);
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(APP_NAME)).andReturn(APPID);
    replay(coreService);
    hostsAvailable = Sets.newHashSet();
    hostService = new TestHostService(hostsAvailable);
    intentService = new TestIntentService();
    TestIntentSynchronizer intentSynchronizer = new TestIntentSynchronizer(intentService);
    interfaceService = createMock(InterfaceService.class);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expectLastCall().anyTimes();
    addIntfConfig();
    vplsFib = new VplsFib();
    vplsFib.applicationService = applicationService;
    vplsFib.coreService = coreService;
    vplsFib.hostService = hostService;
    vplsFib.intentService = intentService;
    vplsFib.interfaceService = interfaceService;
    vplsFib.intentSynchronizer = intentSynchronizer;
}
#method_after
@Before
public void setUp() throws Exception {
    idGenerator = new TestIdGenerator();
    Intent.bindIdGenerator(idGenerator);
    applicationService = createMock(ApplicationService.class);
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(APP_NAME)).andReturn(APPID);
    replay(coreService);
    hostsAvailable = Sets.newHashSet();
    hostService = new TestHostService(hostsAvailable);
    intentService = new TestIntentService();
    TestIntentSynchronizer intentSynchronizer = new TestIntentSynchronizer(intentService);
    interfaceService = createMock(InterfaceService.class);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expectLastCall().anyTimes();
    addIntfConfig();
    vpls = new Vpls();
    vpls.applicationService = applicationService;
    vpls.coreService = coreService;
    vpls.hostService = hostService;
    vpls.intentService = intentService;
    vpls.interfaceService = interfaceService;
    vpls.intentSynchronizer = intentSynchronizer;
}
#end_block

#method_before
@Test
public void testActivateNoHosts() {
    vplsFib.activate();
    List<Intent> expectedIntents = new ArrayList<>();
    expectedIntents.addAll(generateVlanOneBrc());
    expectedIntents.addAll(generateVlanTwoBrc());
    checkIntents(expectedIntents);
}
#method_after
@Test
public void testActivateNoHosts() {
    vpls.activate();
    List<Intent> expectedIntents = Lists.newArrayList();
    expectedIntents.addAll(generateVlanOneBrc());
    expectedIntents.addAll(generateVlanTwoBrc());
    checkIntents(expectedIntents);
}
#end_block

#method_before
@Test
public void testFourInterfacesConfiguredHostsPresent() {
    Host h1 = new DefaultHost(PID, HID1, MAC1, VLAN1, getLocation(1), Collections.singleton(IP1));
    Host h2 = new DefaultHost(PID, HID2, MAC2, VLAN1, getLocation(2), Collections.singleton(IP2));
    Host h3 = new DefaultHost(PID, HID3, MAC3, VLAN1, getLocation(3), Collections.EMPTY_SET);
    Host h4 = new DefaultHost(PID, HID4, MAC4, VLAN2, getLocation(4), Collections.EMPTY_SET);
    Host h5 = new DefaultHost(PID, HID5, MAC5, VLAN2, getLocation(5), Collections.EMPTY_SET);
    Host h6 = new DefaultHost(PID, HID6, MAC6, VLAN2, getLocation(6), Collections.EMPTY_SET);
    hostsAvailable.addAll(Sets.newHashSet(h1, h2, h3, h4, h5, h6));
    vplsFib.activate();
    List<Intent> expectedIntents = new ArrayList<>();
    expectedIntents.addAll(generateVlanOneBrc());
    expectedIntents.addAll(generateVlanOneUni());
    expectedIntents.addAll(generateVlanTwoBrc());
    expectedIntents.addAll(generateVlanTwoUni());
    checkIntents(expectedIntents);
}
#method_after
@Test
public void testFourInterfacesConfiguredHostsPresent() {
    Host h1 = new DefaultHost(PID, HID1, MAC1, VLAN1, getLocation(1), Collections.singleton(IP1));
    Host h2 = new DefaultHost(PID, HID2, MAC2, VLAN1, getLocation(2), Collections.singleton(IP2));
    Host h3 = new DefaultHost(PID, HID3, MAC3, VLAN1, getLocation(3), Collections.EMPTY_SET);
    Host h4 = new DefaultHost(PID, HID4, MAC4, VLAN2, getLocation(4), Collections.EMPTY_SET);
    Host h5 = new DefaultHost(PID, HID5, MAC5, VLAN2, getLocation(5), Collections.EMPTY_SET);
    Host h6 = new DefaultHost(PID, HID6, MAC6, VLAN2, getLocation(6), Collections.EMPTY_SET);
    hostsAvailable.addAll(Sets.newHashSet(h1, h2, h3, h4, h5, h6));
    vpls.activate();
    List<Intent> expectedIntents = Lists.newArrayList();
    expectedIntents.addAll(generateVlanOneBrc());
    expectedIntents.addAll(generateVlanOneUni());
    expectedIntents.addAll(generateVlanTwoBrc());
    expectedIntents.addAll(generateVlanTwoUni());
    checkIntents(expectedIntents);
}
#end_block

#method_before
@Test
public void testFourInterfacesThreeHostEventsSameVlan() {
    vplsFib.activate();
    Host h1 = new DefaultHost(PID, HID1, MAC1, VLAN1, getLocation(1), Collections.singleton(IP1));
    Host h2 = new DefaultHost(PID, HID2, MAC2, VLAN1, getLocation(2), Collections.singleton(IP2));
    Host h3 = new DefaultHost(PID, HID3, MAC3, VLAN1, getLocation(3), Collections.EMPTY_SET);
    Host h7 = new DefaultHost(PID, HID7, MAC7, VLAN1, getLocation(7), Collections.EMPTY_SET);
    hostsAvailable.addAll(Sets.newHashSet(h1, h2, h3, h7));
    hostsAvailable.forEach(host -> hostListener.event(new HostEvent(HostEvent.Type.HOST_ADDED, host)));
    List<Intent> expectedIntents = new ArrayList<>();
    expectedIntents.addAll(generateVlanOneBrc());
    expectedIntents.addAll(generateVlanOneUni());
    expectedIntents.addAll(generateVlanTwoBrc());
    checkIntents(expectedIntents);
}
#method_after
@Test
public void testFourInterfacesThreeHostEventsSameVlan() {
    vpls.activate();
    Host h1 = new DefaultHost(PID, HID1, MAC1, VLAN1, getLocation(1), Collections.singleton(IP1));
    Host h2 = new DefaultHost(PID, HID2, MAC2, VLAN1, getLocation(2), Collections.singleton(IP2));
    Host h3 = new DefaultHost(PID, HID3, MAC3, VLAN1, getLocation(3), Collections.EMPTY_SET);
    Host h7 = new DefaultHost(PID, HID7, MAC7, VLAN1, getLocation(7), Collections.EMPTY_SET);
    hostsAvailable.addAll(Sets.newHashSet(h1, h2, h3, h7));
    hostsAvailable.forEach(host -> hostListener.event(new HostEvent(HostEvent.Type.HOST_ADDED, host)));
    List<Intent> expectedIntents = Lists.newArrayList();
    expectedIntents.addAll(generateVlanOneBrc());
    expectedIntents.addAll(generateVlanOneUni());
    expectedIntents.addAll(generateVlanTwoBrc());
    checkIntents(expectedIntents);
}
#end_block

#method_before
@Test
public void testFourInterfacesTwoHostEventsDifferentVlan() {
    vplsFib.activate();
    Host h1 = new DefaultHost(PID, HID1, MAC1, VLAN1, getLocation(1), Collections.singleton(IP1));
    Host h4 = new DefaultHost(PID, HID4, MAC4, VLAN2, getLocation(4), Collections.EMPTY_SET);
    hostsAvailable.addAll(Sets.newHashSet(h1, h4));
    hostsAvailable.forEach(host -> {
        hostListener.event(new HostEvent(HostEvent.Type.HOST_ADDED, host));
    });
    List<Intent> expectedIntents = new ArrayList<>();
    expectedIntents.addAll(generateVlanOneBrc());
    expectedIntents.addAll(generateVlanTwoBrc());
    checkIntents(expectedIntents);
}
#method_after
@Test
public void testFourInterfacesTwoHostEventsDifferentVlan() {
    vpls.activate();
    Host h1 = new DefaultHost(PID, HID1, MAC1, VLAN1, getLocation(1), Collections.singleton(IP1));
    Host h4 = new DefaultHost(PID, HID4, MAC4, VLAN2, getLocation(4), Collections.EMPTY_SET);
    hostsAvailable.addAll(Sets.newHashSet(h1, h4));
    hostsAvailable.forEach(host -> {
        hostListener.event(new HostEvent(HostEvent.Type.HOST_ADDED, host));
    });
    List<Intent> expectedIntents = Lists.newArrayList();
    expectedIntents.addAll(generateVlanOneBrc());
    expectedIntents.addAll(generateVlanTwoBrc());
    checkIntents(expectedIntents);
}
#end_block

#method_before
private List<SinglePointToMultiPointIntent> generateVlanOneBrc() {
    Key key = null;
    List<SinglePointToMultiPointIntent> intents = new ArrayList<>();
    // Building sp2mp intent for H1 - VLAN1
    key = Key.of((PREFIX_BROADCAST + "-" + DID1 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildBrcIntent(key, C1, Sets.newHashSet(C2, C3), VLAN1));
    // Building sp2mp intent for H2 - VLAN1
    key = Key.of((PREFIX_BROADCAST + "-" + DID2 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildBrcIntent(key, C2, Sets.newHashSet(C1, C3), VLAN1));
    // Building sp2mp intent for H3 - VLAN1
    key = Key.of((PREFIX_BROADCAST + "-" + DID3 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildBrcIntent(key, C3, Sets.newHashSet(C1, C2), VLAN1));
    return intents;
}
#method_after
private List<SinglePointToMultiPointIntent> generateVlanOneBrc() {
    Key key = null;
    List<SinglePointToMultiPointIntent> intents = Lists.newArrayList();
    // Building sp2mp intent for H1 - VLAN1
    key = Key.of((PREFIX_BROADCAST + "-" + DID1 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildBrcIntent(key, C1, Sets.newHashSet(C2, C3), VLAN1));
    // Building sp2mp intent for H2 - VLAN1
    key = Key.of((PREFIX_BROADCAST + "-" + DID2 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildBrcIntent(key, C2, Sets.newHashSet(C1, C3), VLAN1));
    // Building sp2mp intent for H3 - VLAN1
    key = Key.of((PREFIX_BROADCAST + "-" + DID3 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildBrcIntent(key, C3, Sets.newHashSet(C1, C2), VLAN1));
    return intents;
}
#end_block

#method_before
private List<MultiPointToSinglePointIntent> generateVlanOneUni() {
    Key key = null;
    List<MultiPointToSinglePointIntent> intents = new ArrayList<>();
    // Building mp2sp intent for H1 - VLAN1
    key = Key.of((PREFIX_UNICAST + "-" + DID1 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C2, C3), C1, VLAN1, MAC1));
    // Building mp2sp intent for H2 - VLAN1
    key = Key.of((PREFIX_UNICAST + "-" + DID2 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C1, C3), C2, VLAN1, MAC2));
    // Building mp2sp intent for H3 - VLAN1
    key = Key.of((PREFIX_UNICAST + "-" + DID3 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C1, C2), C3, VLAN1, MAC3));
    return intents;
}
#method_after
private List<MultiPointToSinglePointIntent> generateVlanOneUni() {
    Key key = null;
    List<MultiPointToSinglePointIntent> intents = Lists.newArrayList();
    // Building mp2sp intent for H1 - VLAN1
    key = Key.of((PREFIX_UNICAST + "-" + DID1 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C2, C3), C1, VLAN1, MAC1));
    // Building mp2sp intent for H2 - VLAN1
    key = Key.of((PREFIX_UNICAST + "-" + DID2 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C1, C3), C2, VLAN1, MAC2));
    // Building mp2sp intent for H3 - VLAN1
    key = Key.of((PREFIX_UNICAST + "-" + DID3 + "-" + P1 + "-" + VLAN1), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C1, C2), C3, VLAN1, MAC3));
    return intents;
}
#end_block

#method_before
private List<SinglePointToMultiPointIntent> generateVlanTwoBrc() {
    Key key = null;
    List<SinglePointToMultiPointIntent> intents = new ArrayList<>();
    // Building sp2mp intent for H4 - VLAN2
    key = Key.of((PREFIX_BROADCAST + "-" + DID4 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildBrcIntent(key, C4, Sets.newHashSet(C5, C6), VLAN2));
    // Building sp2mp intent for H5 - VLAN2
    key = Key.of((PREFIX_BROADCAST + "-" + DID5 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildBrcIntent(key, C5, Sets.newHashSet(C4, C6), VLAN2));
    // Building sp2mp intent for H6 - VLAN2
    key = Key.of((PREFIX_BROADCAST + "-" + DID6 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildBrcIntent(key, C6, Sets.newHashSet(C4, C5), VLAN2));
    return intents;
}
#method_after
private List<SinglePointToMultiPointIntent> generateVlanTwoBrc() {
    Key key = null;
    List<SinglePointToMultiPointIntent> intents = Lists.newArrayList();
    // Building sp2mp intent for H4 - VLAN2
    key = Key.of((PREFIX_BROADCAST + "-" + DID4 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildBrcIntent(key, C4, Sets.newHashSet(C5, C6), VLAN2));
    // Building sp2mp intent for H5 - VLAN2
    key = Key.of((PREFIX_BROADCAST + "-" + DID5 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildBrcIntent(key, C5, Sets.newHashSet(C4, C6), VLAN2));
    // Building sp2mp intent for H6 - VLAN2
    key = Key.of((PREFIX_BROADCAST + "-" + DID6 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildBrcIntent(key, C6, Sets.newHashSet(C4, C5), VLAN2));
    return intents;
}
#end_block

#method_before
private List<MultiPointToSinglePointIntent> generateVlanTwoUni() {
    Key key = null;
    List<MultiPointToSinglePointIntent> intents = new ArrayList<>();
    // Building mp2sp intent for H4 - VLAN2
    key = Key.of((PREFIX_UNICAST + "-" + DID4 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C5, C6), C4, VLAN2, MAC4));
    // Building mp2sp intent for H5 - VLAN2
    key = Key.of((PREFIX_UNICAST + "-" + DID5 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C4, C6), C5, VLAN2, MAC5));
    // Building mp2sp intent for H6 - VLAN2
    key = Key.of((PREFIX_UNICAST + "-" + DID6 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C4, C5), C6, VLAN2, MAC6));
    return intents;
}
#method_after
private List<MultiPointToSinglePointIntent> generateVlanTwoUni() {
    Key key = null;
    List<MultiPointToSinglePointIntent> intents = Lists.newArrayList();
    // Building mp2sp intent for H4 - VLAN2
    key = Key.of((PREFIX_UNICAST + "-" + DID4 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C5, C6), C4, VLAN2, MAC4));
    // Building mp2sp intent for H5 - VLAN2
    key = Key.of((PREFIX_UNICAST + "-" + DID5 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C4, C6), C5, VLAN2, MAC5));
    // Building mp2sp intent for H6 - VLAN2
    key = Key.of((PREFIX_UNICAST + "-" + DID6 + "-" + P1 + "-" + VLAN2), APPID);
    intents.add(buildUniIntent(key, Sets.newHashSet(C4, C5), C6, VLAN2, MAC6));
    return intents;
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(Vpls.VPLS_APP);
    interfaceService.addListener(interfaceListener);
    interfaceService.getInterfaces().stream().forEach(intf -> {
        neighbourHandlers.put(intf, neighbourHandler);
        neighbourService.registerNeighbourHandler(intf, neighbourHandler);
    });
    log.info("VplsNeighbourHandler activated");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(Vpls.VPLS_APP);
    interfaceService.addListener(interfaceListener);
    interfaceService.getInterfaces().forEach(intf -> {
        neighbourHandlers.put(intf, neighbourHandler);
        neighbourService.registerNeighbourHandler(intf, neighbourHandler, appId);
    });
    log.debug("Activated");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    interfaceService.removeListener(interfaceListener);
    neighbourHandlers.entrySet().stream().forEach(e -> {
        neighbourService.unregisterNeighbourHandler(e.getKey(), e.getValue());
    });
    log.info("VplsNeighbourHandler deactivated");
}
#method_after
@Deactivate
protected void deactivate() {
    interfaceService.removeListener(interfaceListener);
    neighbourHandlers.entrySet().forEach(e -> {
        neighbourService.unregisterNeighbourHandler(e.getKey(), e.getValue(), appId);
    });
    log.debug("Deactivated");
}
#end_block

#method_before
protected void configNeighbourHandler(Interface intf, NeighbourMessageHandler handler, InterfaceEvent.Type eventType) {
    switch(eventType) {
        case INTERFACE_ADDED:
            neighbourHandlers.put(intf, handler);
            neighbourService.registerNeighbourHandler(intf, handler);
            break;
        case INTERFACE_REMOVED:
            neighbourHandlers.remove(intf, handler);
            neighbourService.unregisterNeighbourHandler(intf, handler);
            break;
        case INTERFACE_UPDATED:
            break;
        default:
            break;
    }
}
#method_after
private void configNeighbourHandler(Interface intf, NeighbourMessageHandler handler, InterfaceEvent.Type eventType) {
    switch(eventType) {
        case INTERFACE_ADDED:
            neighbourHandlers.put(intf, handler);
            neighbourService.registerNeighbourHandler(intf, handler, appId);
            break;
        case INTERFACE_REMOVED:
            neighbourHandlers.remove(intf, handler);
            neighbourService.unregisterNeighbourHandler(intf, handler, appId);
            break;
        case INTERFACE_UPDATED:
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void handleMessage(NeighbourMessageContext context, HostService hostService) {
    switch(context.type()) {
        case REQUEST:
            Set<Host> hostsInVlan = hostService.getHostsByVlan(context.vlan());
            Set<Host> hostsMatched = hostsInVlan.stream().filter(host -> host.ipAddresses().contains(context.target())).collect(Collectors.toSet());
            if (hostsMatched.isEmpty()) {
                hostsInVlan.stream().map(host -> host.location()).forEach(context::proxy);
            } else {
                hostsMatched.stream().map(host -> host.mac()).forEach(context::reply);
            }
            break;
        case REPLY:
            hostService.getHostsByIp(context.target()).stream().filter(host -> host.vlan().equals(context.vlan())).map(host -> host.location()).forEach(context::proxy);
            break;
        default:
            log.warn("Unknown context type: {}", context.type());
            break;
    }
}
#method_after
@Override
public void handleMessage(NeighbourMessageContext context, HostService hostService) {
    switch(context.type()) {
        case REQUEST:
            interfaceService.getInterfacesByVlan(context.vlan()).stream().map(Interface::connectPoint).forEach(context::proxy);
            break;
        case REPLY:
            hostService.getHostsByMac(context.dstMac()).stream().filter(host -> host.vlan().equals(context.vlan())).map(Host::location).forEach(context::proxy);
            break;
        default:
            log.warn("Unknown context type: {}", context.type());
            break;
    }
}
#end_block

#method_before
private Intent findIntentByPayload(ObjectNode payload) {
    int appId = Integer.parseInt(string(payload, APP_ID));
    String appName = string(payload, APP_NAME);
    ApplicationId applicId = new DefaultApplicationId(appId, appName);
    long intentKey = Long.decode(string(payload, KEY));
    Key key = Key.of(intentKey, applicId);
    log.debug("Attempting to select intent by key={}", key);
    Intent intent = intentService.getIntent(key);
    return intent;
}
#method_after
private Intent findIntentByPayload(ObjectNode payload) {
    int appId = Integer.parseInt(string(payload, APP_ID));
    String appName = string(payload, APP_NAME);
    ApplicationId applicId = new DefaultApplicationId(appId, appName);
    long intentKey = Long.decode(string(payload, KEY));
    Key key = Key.of(intentKey, applicId);
    log.debug("Attempting to select intent by key={}", key);
    return intentService.getIntent(key);
}
#end_block

#method_before
@Override
public Optional<Range<Long>> getTargetPowerRange(PortNumber port, Object component) {
    Range<Long> range = null;
    switch(getType(component)) {
        case PORT:
            range = getTargetPortPowerRange(port);
            break;
        case CHANNEL:
            range = getChannelAttenuationRange(port);
            break;
    }
    return Optional.ofNullable(range);
}
#method_after
@Override
public Optional<Range<Long>> getTargetPowerRange(PortNumber port, Object component) {
    Range<Long> range = null;
    switch(getType(component)) {
        case PORT:
            range = getTargetPortPowerRange(port);
            break;
        case CHANNEL:
            range = getChannelAttenuationRange(port);
            break;
        default:
            break;
    }
    return Optional.ofNullable(range);
}
#end_block

#method_before
@Override
public Optional<Range<Long>> getInputPowerRange(PortNumber port, Object component) {
    Range<Long> range = null;
    switch(getType(component)) {
        case PORT:
            range = getInputPortPowerRange(port);
            break;
    }
    return Optional.ofNullable(range);
}
#method_after
@Override
public Optional<Range<Long>> getInputPowerRange(PortNumber port, Object component) {
    Range<Long> range = null;
    switch(getType(component)) {
        case PORT:
            range = getInputPortPowerRange(port);
            break;
        default:
            break;
    }
    return Optional.ofNullable(range);
}
#end_block

#method_before
private Range<Long> getTargetPortPowerRange(PortNumber port) {
    Range<Long> range = null;
    long num = port.toLong();
    if (num == 2) {
        range = Range.closed(100L, 2040L);
    } else if (num >= 3 && num <= 11) {
        range = Range.closed(-680L, 1530L);
    }
    return range;
}
#method_after
private Range<Long> getTargetPortPowerRange(PortNumber port) {
    Range<Long> range = null;
    long num = port.toLong();
    if (num == LINE_OUT) {
        range = Range.closed(100L, 2040L);
    } else if (num >= AUX_OUT_1 && num <= EXPRESS_OUT_7) {
        range = Range.closed(-680L, 1530L);
    }
    return range;
}
#end_block

#method_before
private Range<Long> getChannelAttenuationRange(PortNumber port) {
    Range<Long> range = null;
    long num = port.toLong();
    if (num == 2 || num >= 12 && num <= 20) {
        range = Range.closed(0L, 2550L);
    }
    return range;
}
#method_after
// Returns the acceptable attenuation range for a connection (represented as
// a flow with attenuation instruction). Port can be either the input or
// output port of the connection. Returns null if the connection does not
private Range<Long> getChannelAttenuationRange(PortNumber port) {
    Range<Long> range = null;
    long num = port.toLong();
    // attenuation.
    if (num == LINE_OUT || num >= AUX_IN_1 && num <= EXPRESS_IN_7) {
        range = Range.closed(0L, 2550L);
    }
    return range;
}
#end_block

#method_before
private Range<Long> getInputPortPowerRange(PortNumber port) {
    Range<Long> range = null;
    long portNum = port.toLong();
    if (portNum == 1) {
        // only gives LR right now
        range = Range.closed(-2600L, 540L);
    } else if (portNum == 12 || portNum == 13) {
        range = Range.closed(-1250L, 1590L);
    } else if (portNum >= 14 && portNum <= 20) {
        range = Range.closed(-1420L, 1420L);
    }
    return range;
}
#method_after
// Returns the working input power range for an input port, null if the port
private Range<Long> getInputPortPowerRange(PortNumber port) {
    Range<Long> range = null;
    long portNum = port.toLong();
    if (portNum == LINE_IN) {
        // TODO implement support for IR and ER range
        // only supports LR right now
        range = Range.closed(-2600L, 540L);
    } else if (portNum == AUX_IN_1 || portNum == AUX_IN_2) {
        range = Range.closed(-1250L, 1590L);
    } else if (portNum >= EXPRESS_IN_1 && portNum <= EXPRESS_IN_7) {
        range = Range.closed(-1420L, 1420L);
    }
    return range;
}
#end_block

#method_before
public FujitsuDriverHandlerMock setUp(FujitsuNetconfSessionListenerTest listener) throws NetconfException {
    try {
        NetconfDeviceInfo deviceInfo = new NetconfDeviceInfo(VOLT_DEVICE_USERNAME, VOLT_DEVICE_PASSWORD, IpAddress.valueOf(VOLT_DEVICE_IP), VOLT_DEVICE_PORT);
        NetconfDevice netconfDevice = connectDevice(deviceInfo.getDeviceId());
        FujitsuNetconfSessionMock session = (FujitsuNetconfSessionMock) netconfDevice.getSession();
        session.setListener(listener);
        DeviceId deviceId = deviceInfo.getDeviceId();
        DefaultDriver driver = new DefaultDriver(VOLT_DRIVER_NAME, new ArrayList<>(), "Fujitsu", "1.0", "1.0", ImmutableMap.of(), ImmutableMap.of());
        DefaultDriverData driverData = new DefaultDriverData(driver, deviceId);
        FujitsuDriverHandlerMock driverHandler;
        driverHandler = new FujitsuDriverHandlerMock(driverData);
        driverHandler.setUp(this);
        return driverHandler;
    } catch (NetconfException e) {
        throw new NetconfException("Cannot create a device ", e);
    }
}
#method_after
public FujitsuDriverHandlerAdapter setUp(FujitsuNetconfSessionListenerTest listener) throws NetconfException {
    try {
        NetconfDeviceInfo deviceInfo = new NetconfDeviceInfo(VOLT_DEVICE_USERNAME, VOLT_DEVICE_PASSWORD, IpAddress.valueOf(VOLT_DEVICE_IP), VOLT_DEVICE_PORT);
        NetconfDevice netconfDevice = connectDevice(deviceInfo.getDeviceId());
        FujitsuNetconfSessionMock session = (FujitsuNetconfSessionMock) netconfDevice.getSession();
        session.setListener(listener);
        DeviceId deviceId = deviceInfo.getDeviceId();
        DefaultDriver driver = new DefaultDriver(VOLT_DRIVER_NAME, new ArrayList<>(), "Fujitsu", "1.0", "1.0", ImmutableMap.of(), ImmutableMap.of());
        DefaultDriverData driverData = new DefaultDriverData(driver, deviceId);
        FujitsuDriverHandlerAdapter driverHandler;
        driverHandler = new FujitsuDriverHandlerAdapter(driverData);
        driverHandler.setUp(this);
        return driverHandler;
    } catch (NetconfException e) {
        throw new NetconfException("Cannot create a device ", e);
    }
}
#end_block

#method_before
private static Optional<Integer> getMsgId(String reply) {
    if (reply.contains(HELLO)) {
        return Optional.of(0);
    }
    Pattern pattern = Pattern.compile("(" + MESSAGE_ID + "\"\\d+)");
    Matcher matcher = pattern.matcher(reply);
    if (matcher.find()) {
        String messageID = matcher.group(1).replace(MESSAGE_ID + "\"", "");
        Preconditions.checkNotNull(Integer.parseInt(messageID), "Error in retrieving the message id");
        return Optional.of(Integer.parseInt(messageID));
    }
    return Optional.empty();
}
#method_after
private static Optional<Integer> getMsgId(String reply) {
    Matcher matcher = MSGID_PATTERN.matcher(reply);
    if (matcher.find()) {
        Integer messageId = Integer.parseInt(matcher.group(1));
        Preconditions.checkNotNull(messageId, "Error in retrieving the message id");
        return Optional.of(messageId);
    }
    if (reply.contains(HELLO)) {
        return Optional.of(0);
    }
    return Optional.empty();
}
#end_block

#method_before
private boolean isEdgePort(ConnectPoint point) {
    return !point.port().isLogical() && linkService.getLinks(point).isEmpty();
}
#method_after
private boolean isEdgePort(ConnectPoint point) {
    // ports. Ports that have only edge links are considered edge ports.
    return !point.port().isLogical() && linkService.getLinks(point).stream().allMatch(link -> link.type() == Type.EDGE);
}
#end_block

#method_before
private Pipeliner getDevicePipeliner(DeviceId deviceId) {
    return pipeliners.compute(deviceId, (deviceIdValue, pipelinerValue) -> {
        if (pipelinerValue != null) {
            pipelinerValue.init(deviceId, context);
            return pipelinerValue;
        }
        return this.initPipelineHandler(deviceId);
    });
}
#method_after
private Pipeliner getDevicePipeliner(DeviceId deviceId) {
    return pipeliners.computeIfAbsent(deviceId, this::initPipelineHandler);
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.debug("Device either added or availability changed {}", event.subject().id());
            if (deviceService.isAvailable(event.subject().id())) {
                log.debug("Device is now available {}", event.subject().id());
                getDevicePipeliner(event.subject().id());
            } else {
                log.debug("Device is no longer available {}", event.subject().id());
            }
            break;
        case DEVICE_UPDATED:
            break;
        case DEVICE_REMOVED:
            // evict Pipeliner and Handler cache, when
            // the Device was administratively removed.
            // 
            // System expect the user to clear all existing flows,
            // before removing device, especially if they intend to
            // replace driver/pipeliner assigned to the device.
            driverHandlers.remove(event.subject().id());
            pipeliners.remove(event.subject().id());
            break;
        case DEVICE_SUSPENDED:
            break;
        case PORT_ADDED:
            break;
        case PORT_UPDATED:
            break;
        case PORT_REMOVED:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.debug("Device either added or availability changed {}", event.subject().id());
            if (deviceService.isAvailable(event.subject().id())) {
                log.debug("Device is now available {}", event.subject().id());
                getAndInitDevicePipeliner(event.subject().id());
            } else {
                log.debug("Device is no longer available {}", event.subject().id());
            }
            break;
        case DEVICE_UPDATED:
            break;
        case DEVICE_REMOVED:
            // evict Pipeliner and Handler cache, when
            // the Device was administratively removed.
            // 
            // System expect the user to clear all existing flows,
            // before removing device, especially if they intend to
            // replace driver/pipeliner assigned to the device.
            driverHandlers.remove(event.subject().id());
            pipeliners.remove(event.subject().id());
            break;
        case DEVICE_SUSPENDED:
            break;
        case PORT_ADDED:
            break;
        case PORT_UPDATED:
            break;
        case PORT_REMOVED:
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void cleanUp() {
    // clean up the routes.
    for (Map.Entry<IpPrefix, IpAddress> routes : prefixToNextHop.entrySet()) {
        deleteRoute(new ResolvedRoute(routes.getKey(), null, null));
    }
    // clean up the filtering objective for interfaces.
    Set<Interface> intfs = getInterfaces();
    if (!intfs.isEmpty()) {
        processIntfFilters(false, intfs);
    }
}
#method_after
private void cleanUp() {
    // remove the route listener
    routeService.removeListener(routeListener);
    // clean up the routes.
    for (Map.Entry<IpPrefix, IpAddress> routes : prefixToNextHop.entrySet()) {
        deleteRoute(new ResolvedRoute(routes.getKey(), null, null));
    }
    // clean up the filtering objective for interfaces.
    Set<Interface> intfs = getInterfaces();
    if (!intfs.isEmpty()) {
        processIntfFilters(false, intfs);
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (event.configClass().equals(RoutingService.ROUTER_CONFIG_CLASS)) {
        switch(event.type()) {
            case CONFIG_ADDED:
            case CONFIG_UPDATED:
                updateConfig();
                if (event.prevConfig().isPresent()) {
                    updateFilteringObjectives(event);
                }
                break;
            case CONFIG_REGISTERED:
            case CONFIG_UNREGISTERED:
            case CONFIG_REMOVED:
                cleanUp();
            default:
                break;
        }
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (event.configClass().equals(RoutingService.ROUTER_CONFIG_CLASS)) {
        switch(event.type()) {
            case CONFIG_ADDED:
            case CONFIG_UPDATED:
                updateConfig();
                if (event.prevConfig().isPresent()) {
                    removeFilteringObjectives(event);
                }
                break;
            case CONFIG_REGISTERED:
                break;
            case CONFIG_UNREGISTERED:
                break;
            case CONFIG_REMOVED:
                cleanUp();
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
@POST
@Path("configuration")
@Produces(MediaType.APPLICATION_JSON)
public Response formCluster(InputStream config) throws IOException {
    JsonCodec<ControllerNode> codec = codec(ControllerNode.class);
    ObjectNode root = (ObjectNode) mapper().readTree(config);
    List<ControllerNode> nodes = codec.decode((ArrayNode) root.path("nodes"), this);
    JsonNode partitionSizeNode = root.get("partition-size");
    if (partitionSizeNode != null) {
        int partitionSize = partitionSizeNode.asInt();
        if (partitionSize == 0) {
            return Response.notAcceptable(null).build();
        }
        get(ClusterAdminService.class).formCluster(new HashSet<>(nodes), partitionSize);
    } else {
        get(ClusterAdminService.class).formCluster(new HashSet<>(nodes));
    }
    return Response.ok().build();
}
#method_after
@POST
@Path("configuration")
@Produces(MediaType.APPLICATION_JSON)
public Response formCluster(InputStream config) throws IOException {
    JsonCodec<ControllerNode> codec = codec(ControllerNode.class);
    ObjectNode root = (ObjectNode) mapper().readTree(config);
    List<ControllerNode> nodes = codec.decode((ArrayNode) root.path("nodes"), this);
    JsonNode partitionSizeNode = root.get("partitionSize");
    if (partitionSizeNode != null) {
        int partitionSize = partitionSizeNode.asInt();
        if (partitionSize == 0) {
            return Response.notAcceptable(null).build();
        }
        get(ClusterAdminService.class).formCluster(new HashSet<>(nodes), partitionSize);
    } else {
        get(ClusterAdminService.class).formCluster(new HashSet<>(nodes));
    }
    return Response.ok().build();
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(RBQ_LISTENER_APP);
    mqService = new MQServiceImpl(context);
    eventExecutor = newSingleThreadScheduledExecutor(groupedThreads("onos/deviceevents", "events-%d", log));
    deviceListener = new InternalDeviceListener();
    deviceService.addListener(deviceListener);
    packetService.addProcessor(packetProcessor, PacketProcessor.advisor(0));
    linkService.addListener(linkListener);
    topologyService.addListener(topologyListener);
    log.info("MQEventHandler started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    mqService = new MQServiceImpl(context);
    eventExecutor = newSingleThreadScheduledExecutor(groupedThreads("onos/deviceevents", "events-%d", log));
    deviceListener = new InternalDeviceListener();
    deviceService.addListener(deviceListener);
    packetService.addProcessor(packetProcessor, PacketProcessor.advisor(PKT_PROC_PRIO));
    linkService.addListener(linkListener);
    topologyService.addListener(topologyListener);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    deviceService.removeListener(deviceListener);
    packetService.removeProcessor(packetProcessor);
    eventExecutor.shutdownNow();
    eventExecutor = null;
    linkService.removeListener(linkListener);
    topologyService.removeListener(topologyListener);
    log.info("MQEventHandler stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    deviceService.removeListener(deviceListener);
    packetService.removeProcessor(packetProcessor);
    eventExecutor.shutdownNow();
    eventExecutor = null;
    linkService.removeListener(linkListener);
    topologyService.removeListener(topologyListener);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Runnable deviceEventProcessor = new DeviceEventProcessor(event);
    eventExecutor.execute(deviceEventProcessor);
}
#method_after
@Override
public void event(DeviceEvent event) {
    if (event == null) {
        log.error("Device event is null.");
        return;
    }
    mqService.publish(event);
}
#end_block

#method_before
@Override
public void event(LinkEvent event) {
    if (event == null) {
        log.error("Link is null.");
        return;
    }
    mqService.publish(event);
}
#method_after
@Override
public void event(LinkEvent event) {
    if (event == null) {
        log.error("Link event is null.");
        return;
    }
    mqService.publish(event);
}
#end_block

#method_before
@Override
public void event(TopologyEvent event) {
    if (event == null) {
        log.error("Topology is null.");
        return;
    }
    mqService.publish(event);
}
#method_after
@Override
public void event(TopologyEvent event) {
    if (event == null) {
        log.error("Topology event is null.");
        return;
    }
    mqService.publish(event);
}
#end_block

#method_before
@Override
public Manageable registerProducer(BrokerHost host, Map<String, String> channelConf, BlockingQueue<MessageContext> queue) {
    String exchangeName = (String) channelConf.get(MQConstants.EXCHANGE_NAME_PROPERTY);
    String routingKey = (String) channelConf.get(MQConstants.ROUTING_KEY_PROPERTY);
    String queueName = (String) channelConf.get(MQConstants.QUEUE_NAME_PROPERTY);
    MQSender sender = new MQSender(queue, exchangeName, routingKey, queueName, host.getUrl());
    return sender;
}
#method_after
@Override
public Manageable registerProducer(BrokerHost host, Map<String, String> channelConf, BlockingQueue<MessageContext> queue) {
    String exchangeName = channelConf.get(EXCHANGE_NAME_PROPERTY);
    String routingKey = channelConf.get(ROUTING_KEY_PROPERTY);
    String queueName = channelConf.get(QUEUE_NAME_PROPERTY);
    return new MQSender(queue, exchangeName, routingKey, queueName, host.getUrl());
}
#end_block

#method_before
private void initializeProducers(ComponentContext context) {
    prop = MQUtil.getProp(context);
    if (prop == null) {
        log.error("RabbitMQ configuration file not found.So failing initializing application..");
        return;
    }
    try {
        correlationId = prop.getProperty(MQConstants.SENDER_COR_ID);
        rfHost = new BrokerHost(MQUtil.getMqUrl(prop.getProperty(MQConstants.SERVER_PROTO), prop.getProperty(MQConstants.SERVER_UNAME), prop.getProperty(MQConstants.SERVER_PWD), prop.getProperty(MQConstants.SERVER_ADDR), prop.getProperty(MQConstants.SERVER_PORT), prop.getProperty(MQConstants.SERVER_VHOST)));
        manageSender = registerProducer(rfHost, MQUtil.rfProducerChannelConf(prop.getProperty(MQConstants.SENDER_EXCHG), prop.getProperty(MQConstants.ROUTE_KEY), prop.getProperty(MQConstants.SENDER_QUEUE)), msgOutQueue);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    manageSender.start();
}
#method_after
private void initializeProducers(ComponentContext context) {
    BrokerHost rfHost;
    Properties prop = MQUtil.getProp(context);
    if (prop == null) {
        log.error("RabbitMQ configuration file not found...");
        return;
    }
    try {
        correlationId = prop.getProperty(SENDER_COR_ID);
        rfHost = new BrokerHost(MQUtil.getMqUrl(prop.getProperty(SERVER_PROTO), prop.getProperty(SERVER_UNAME), prop.getProperty(SERVER_PWD), prop.getProperty(SERVER_ADDR), prop.getProperty(SERVER_PORT), prop.getProperty(SERVER_VHOST)));
        manageSender = registerProducer(rfHost, MQUtil.rfProducerChannelConf(prop.getProperty(SENDER_EXCHG), prop.getProperty(ROUTE_KEY), prop.getProperty(SENDER_QUEUE)), msgOutQueue);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    manageSender.start();
}
#end_block

#method_before
@Override
public void publish(PacketContext context) {
    byte[] body = MQUtil.constructPacketRequestJsonMsg(context).toString().getBytes();
    processAndPublishMessage(body);
}
#method_after
@Override
public void publish(Event<? extends Enum, ?> event) {
    byte[] body = null;
    if (null == event) {
        log.error("Captured event is null...");
        return;
    }
    if (event instanceof DeviceEvent) {
        body = bytesOf(MQUtil.json((DeviceEvent) event));
    } else if (event instanceof TopologyEvent) {
        body = bytesOf(MQUtil.json((TopologyEvent) event));
    } else if (event instanceof LinkEvent) {
        body = bytesOf(MQUtil.json((LinkEvent) event));
    } else {
        log.error("Invalid event: '{}'", event);
    }
    processAndPublishMessage(body);
}
#end_block

#method_before
@Override
public void publish(PacketContext context) {
    byte[] body = MQUtil.constructPacketRequestJsonMsg(context).toString().getBytes();
    processAndPublishMessage(body);
}
#method_after
@Override
public void publish(PacketContext context) {
    byte[] body = bytesOf(MQUtil.json(context));
    processAndPublishMessage(body);
}
#end_block

#method_before
public void processAndPublishMessage(byte[] body) {
    Map<String, Object> props = Maps.newHashMap();
    props.put(MQConstants.CORRELATION_ID, correlationId);
    MessageContext mc = new MessageContext(body, props);
    try {
        msgOutQueue.put(mc);
        String message;
        message = new String(body, "UTF-8");
        log.info(" [x] Sent '" + message + "'");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
    manageSender.publish();
}
#method_after
private void processAndPublishMessage(byte[] body) {
    Map<String, Object> props = Maps.newHashMap();
    props.put(CORRELATION_ID, correlationId);
    MessageContext mc = new MessageContext(body, props);
    try {
        msgOutQueue.put(mc);
        String message = new String(body, "UTF-8");
        log.debug(" [x] Sent '{}'", message);
    } catch (InterruptedException | UnsupportedEncodingException e) {
        log.error(ExceptionUtils.getFullStackTrace(e));
    }
    manageSender.publish();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    BrokerHost that = (BrokerHost) o;
    if (url != null ? !url.equals(that.url) : that.url != null) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    BrokerHost that = (BrokerHost) o;
    return url != null ? url.equals(that.url) : that.url == null;
}
#end_block

#method_before
public Map<String, Object> getProperties() {
    return properties;
}
#method_after
/**
 * Returns the Message Properties Map.
 *
 * @return Map of the Message Queue properties
 */
public Map<String, Object> getProperties() {
    return properties;
}
#end_block

#method_before
public void start() {
    ConnectionFactory factory = new ConnectionFactory();
    factory.setAutomaticRecoveryEnabled(true);
    factory.setNetworkRecoveryInterval(15000);
    try {
        factory.setUri(url);
        if (executorService != null) {
            conn = factory.newConnection(executorService);
        } else {
            conn = factory.newConnection();
        }
        channel = conn.createChannel();
        channel.exchangeDeclare(exchangeName, MQConstants.TOPIC, true);
        channel.queueDeclare(this.queueName, true, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);
    } catch (IOException e) {
        String msg = "Error creating the RabbitMQ channel";
        log.error(msg, e);
    } catch (Exception e) {
        String msg = "Error creating the RabbitMQ channel";
        log.error(msg, e);
    }
}
#method_after
@Override
public void start() {
    ConnectionFactory factory = new ConnectionFactory();
    factory.setAutomaticRecoveryEnabled(true);
    factory.setNetworkRecoveryInterval(RECOVERY_INTERVAL);
    try {
        factory.setUri(url);
        if (executorService != null) {
            conn = factory.newConnection(executorService);
        } else {
            conn = factory.newConnection();
        }
        channel = conn.createChannel();
        channel.exchangeDeclare(exchangeName, TOPIC, true);
        /*
             * Setting the following parameters to queue
             * durable    - true
             * exclusive  - false
             * autoDelete - false
             * arguments  - null
             */
        channel.queueDeclare(this.queueName, true, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);
    } catch (Exception e) {
        log.error(E_CREATE_CHAN, e);
    }
}
#end_block

#method_before
public void publish() {
    int errorCount = 0;
    try {
        try {
            MessageContext input = outQueue.poll();
            Map<String, Object> props = new HashMap<String, Object>();
            for (Map.Entry<String, Object> e : input.getProperties().entrySet()) {
                props.put(e.getKey(), e.getValue());
            }
            channel.basicPublish(exchangeName, routingKey, new AMQP.BasicProperties.Builder().correlationId(MQConstants.COR_ID).build(), input.getBody());
            String message1 = new String(input.getBody(), "UTF-8");
            log.info(" [x] Sent '" + "':'" + message1 + "'");
        } catch (Exception e) {
            log.error("Exception occurred in the worker listening for consumer changes", e);
        }
    } catch (Throwable t) {
        errorCount++;
        if (errorCount <= 3) {
            log.error("Error occurred " + errorCount + " times.. trying to continue the worker", t);
        } else {
            log.error("Error occurred " + errorCount + " times.. terminating the worker", t);
        }
    }
}
#method_after
@Override
public void publish() {
    try {
        MessageContext input = outQueue.poll();
        channel.basicPublish(exchangeName, routingKey, new AMQP.BasicProperties.Builder().correlationId(COR_ID).build(), input.getBody());
        String message1 = new String(input.getBody(), "UTF-8");
        log.debug(" [x] Sent: '{}'", message1);
    } catch (Exception e) {
        log.error(E_PUBLISH_CHAN, e);
    }
}
#end_block

#method_before
public void stop() {
    try {
        channel.close();
        conn.close();
    } catch (IOException e) {
        log.error("Error closing the rabbit MQ connection", e);
    } catch (TimeoutException e) {
        e.printStackTrace();
    }
}
#method_after
@Override
public void stop() {
    try {
        channel.close();
        conn.close();
    } catch (IOException e) {
        log.error("Error closing the rabbit MQ connection", e);
    } catch (TimeoutException e) {
        log.error("Timeout exception in closing the rabbit MQ connection", e);
    }
}
#end_block

#method_before
@Before
public void setUp() {
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(appId.name())).andReturn(appId).anyTimes();
    replay(coreService);
    mqEventHandler.coreService = coreService;
    mqEventHandler.deviceService = deviceService;
    mqEventHandler.packetService = packetService;
    mqEventHandler.eventExecutor = MoreExecutors.newDirectExecutorService();
    linkService.addListener(testLinkListener);
    mqEventHandler.linkService = linkService;
    mqEventHandler.topologyService = service;
    mqEventHandler.activate(context);
}
#method_after
@Before
public void setUp() {
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(appId.name())).andReturn(appId).anyTimes();
    replay(coreService);
    mqEventHandler.deviceService = deviceService;
    mqEventHandler.packetService = packetService;
    mqEventHandler.eventExecutor = MoreExecutors.newDirectExecutorService();
    linkService.addListener(testLinkListener);
    mqEventHandler.linkService = linkService;
    mqEventHandler.topologyService = service;
    mqEventHandler.activate(context);
}
#end_block

#method_before
@After
public void tearDown() {
    mqEventHandler.deactivate();
    mqEventHandler.coreService = null;
    mqEventHandler.deviceService = null;
    mqEventHandler.packetService = null;
}
#method_after
@After
public void tearDown() {
    mqEventHandler.deactivate();
    mqEventHandler.deviceService = null;
    mqEventHandler.packetService = null;
}
#end_block

#method_before
private Port port(DeviceId did, long port, boolean enabled) {
    return new DefaultPort(deviceService.getDevice(did), PortNumber.portNumber(port), enabled);
}
#method_after
private Port port(DeviceId did, long port, boolean enabled) {
    return new DefaultPort(deviceService.getDevice(did), portNumber(port), enabled);
}
#end_block

#method_before
@Test
public void switchAdd() {
    DeviceEvent de = deviceEvent(DeviceEvent.Type.DEVICE_ADDED, DID1);
    deviceListener.event(de);
}
#method_after
@Test
public void switchAdd() {
    DeviceEvent de = deviceEvent(DEVICE_ADDED, DID1);
    deviceListener.event(de);
}
#end_block

#method_before
@Test
public void switchRemove() {
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_ADDED, DID1));
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_REMOVED, DID1));
}
#method_after
@Test
public void switchRemove() {
    deviceListener.event(deviceEvent(DEVICE_ADDED, DID1));
    deviceListener.event(deviceEvent(DEVICE_REMOVED, DID1));
}
#end_block

#method_before
@Test
public void switchUpdate() {
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_UPDATED, DID1));
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_REMOVED, DID1));
}
#method_after
@Test
public void switchUpdate() {
    deviceListener.event(deviceEvent(DEVICE_UPDATED, DID1));
    deviceListener.event(deviceEvent(DEVICE_REMOVED, DID1));
}
#end_block

#method_before
@Test
public void switchSuspend() {
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_SUSPENDED, DID1));
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_REMOVED, DID1));
}
#method_after
@Test
public void switchSuspend() {
    deviceListener.event(deviceEvent(DEVICE_SUSPENDED, DID1));
    deviceListener.event(deviceEvent(DEVICE_REMOVED, DID1));
}
#end_block

#method_before
@Test
public void portUp() {
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_ADDED, DID1));
    deviceListener.event(portEvent(DeviceEvent.Type.PORT_ADDED, DID1, port(DID1, 3, true)));
}
#method_after
@Test
public void portUp() {
    deviceListener.event(deviceEvent(DEVICE_ADDED, DID1));
    deviceListener.event(portEvent(PORT_ADDED, DID1, port(DID1, 3, true)));
}
#end_block

#method_before
@Test
public void portDown() {
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_ADDED, DID1));
    deviceListener.event(portEvent(DeviceEvent.Type.PORT_ADDED, DID1, port(DID1, 1, false)));
}
#method_after
@Test
public void portDown() {
    deviceListener.event(deviceEvent(DEVICE_ADDED, DID1));
    deviceListener.event(portEvent(PORT_ADDED, DID1, port(DID1, 1, false)));
}
#end_block

#method_before
@Test
public void portRemoved() {
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_ADDED, DID1));
    deviceListener.event(portEvent(DeviceEvent.Type.PORT_ADDED, DID1, port(DID1, 3, true)));
    deviceListener.event(portEvent(DeviceEvent.Type.PORT_REMOVED, DID1, port(DID1, 3, true)));
}
#method_after
@Test
public void portRemoved() {
    deviceListener.event(deviceEvent(DEVICE_ADDED, DID1));
    deviceListener.event(portEvent(PORT_ADDED, DID1, port(DID1, 3, true)));
    deviceListener.event(portEvent(PORT_REMOVED, DID1, port(DID1, 3, true)));
}
#end_block

#method_before
private DefaultDevice device1(DeviceId did) {
    return new DefaultDevice(ProviderId.NONE, did, Device.Type.SWITCH, "TESTMF", "TESTHW", "TESTSW", "TESTSN", new ChassisId());
}
#method_after
private DefaultDevice device1(DeviceId did) {
    return new DefaultDevice(ProviderId.NONE, did, SWITCH, "TESTMF", "TESTHW", "TESTSW", "TESTSN", new ChassisId());
}
#end_block

#method_before
@Test
public void knownPktCtx() {
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_ADDED, DID1));
    deviceListener.event(deviceEvent(DeviceEvent.Type.DEVICE_ADDED, DID2));
    PacketContext pktCtx = new TestPacketContext(deviceService.getDevice(DID2));
    /*
         * EasyMock.expectLastCall(); EasyMock.replay(manageSender);
         */
    testProcessor.process(pktCtx);
}
#method_after
@Test
public void knownPktCtx() {
    deviceListener.event(deviceEvent(DEVICE_ADDED, DID1));
    deviceListener.event(deviceEvent(DEVICE_ADDED, DID2));
    PacketContext pktCtx = new TestPacketContext(deviceService.getDevice(DID2));
    /*
         * EasyMock.expectLastCall(); EasyMock.replay(manageSender);
         */
    testProcessor.process(pktCtx);
}
#end_block

#method_before
@Test
public void testAddLink() throws Exception {
    Link link = createLink();
    LinkEvent event = new LinkEvent(LinkEvent.Type.LINK_ADDED, link, 123L);
    validateEvent(event, LinkEvent.Type.LINK_ADDED, link, 123L);
}
#method_after
@Test
public void testAddLink() throws Exception {
    Link link = createLink();
    LinkEvent event = new LinkEvent(LINK_ADDED, link, 123L);
    validateEvent(event, LINK_ADDED, link, 123L);
}
#end_block

#method_before
@Test
public void testUpdateLink() throws Exception {
    Link link = createLink();
    LinkEvent event = new LinkEvent(LinkEvent.Type.LINK_UPDATED, link, 123L);
    validateEvent(event, LinkEvent.Type.LINK_UPDATED, link, 123L);
}
#method_after
@Test
public void testUpdateLink() throws Exception {
    Link link = createLink();
    LinkEvent event = new LinkEvent(LINK_UPDATED, link, 123L);
    validateEvent(event, LINK_UPDATED, link, 123L);
}
#end_block

#method_before
@Test
public void testRemoveLink() throws Exception {
    Link link = createLink();
    LinkEvent event = new LinkEvent(LinkEvent.Type.LINK_ADDED, link, 123L);
    validateEvent(event, LinkEvent.Type.LINK_ADDED, link, 123L);
    LinkEvent event1 = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link, 123L);
    validateEvent(event1, LinkEvent.Type.LINK_REMOVED, link, 123L);
}
#method_after
@Test
public void testRemoveLink() throws Exception {
    Link link = createLink();
    LinkEvent event = new LinkEvent(LINK_ADDED, link, 123L);
    validateEvent(event, LINK_ADDED, link, 123L);
    LinkEvent event1 = new LinkEvent(LINK_REMOVED, link, 123L);
    validateEvent(event1, LINK_REMOVED, link, 123L);
}
#end_block

#method_before
public static String getMqUrl(String proto, String userName, String password, String ipAddr, String port, String vhost) {
    StringBuilder urlBuilder = new StringBuilder();
    try {
        urlBuilder.append(proto).append("://").append(userName).append(":").append(password).append("@").append(ipAddr).append(":").append(port).append("/").append(URLEncoder.encode(vhost, "UTF-8"));
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
    return urlBuilder.toString().replaceAll("\\s+", "");
}
#method_after
public static String getMqUrl(String proto, String userName, String password, String ipAddr, String port, String vhost) {
    StringBuilder urlBuilder = new StringBuilder();
    try {
        urlBuilder.append(proto).append(CDFS).append(userName).append(COLON).append(password).append(AT).append(ipAddr).append(COLON).append(port).append(FS).append(URLEncoder.encode(vhost, UTF8));
    } catch (UnsupportedEncodingException e) {
        log.error(ExceptionUtils.getFullStackTrace(e));
    }
    return urlBuilder.toString().replaceAll("\\s+", "");
}
#end_block

#method_before
public static Map<String, String> rfProducerChannelConf(final String exchange, final String routingKey, final String queueName) {
    Map<String, String> channelConf = new HashMap<String, String>();
    channelConf.put(MQConstants.EXCHANGE_NAME_PROPERTY, exchange);
    channelConf.put(MQConstants.ROUTING_KEY_PROPERTY, routingKey);
    channelConf.put(MQConstants.QUEUE_NAME_PROPERTY, queueName);
    return channelConf;
}
#method_after
public static Map<String, String> rfProducerChannelConf(String exchange, String routingKey, String queueName) {
    Map<String, String> channelConf = new HashMap<>();
    channelConf.put(EXCHANGE_NAME_PROPERTY, exchange);
    channelConf.put(ROUTING_KEY_PROPERTY, routingKey);
    channelConf.put(QUEUE_NAME_PROPERTY, queueName);
    return channelConf;
}
#end_block

#method_before
public static Properties getProp(ComponentContext context) {
    URL configUrl = null;
    try {
        configUrl = context.getBundleContext().getBundle().getResource(MQConstants.MQ_PROP_NAME);
    } catch (Exception ex) {
        // This will be used only during junit test case since bundle
        // context will be available during runtime only.
        File file = new File(MQUtil.class.getClassLoader().getResource(MQConstants.MQ_PROP_NAME).getFile());
        try {
            configUrl = file.toURL();
        } catch (MalformedURLException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
    Properties properties = null;
    try {
        InputStream is = configUrl.openStream();
        properties = new Properties();
        properties.load(is);
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException(e);
    }
    return properties;
}
#method_after
public static Properties getProp(ComponentContext context) {
    URL configUrl;
    try {
        configUrl = context.getBundleContext().getBundle().getResource(MQ_PROP_NAME);
    } catch (Exception ex) {
        // This will be used only during junit test case since bundle
        // context will be available during runtime only.
        File file = new File(MQUtil.class.getClassLoader().getResource(MQ_PROP_NAME).getFile());
        try {
            configUrl = file.toURL();
        } catch (MalformedURLException e) {
            log.error(ExceptionUtils.getFullStackTrace(e));
            throw new RuntimeException(e);
        }
    }
    Properties properties;
    try {
        InputStream is = configUrl.openStream();
        properties = new Properties();
        properties.load(is);
    } catch (Exception e) {
        log.error(ExceptionUtils.getFullStackTrace(e));
        throw new RuntimeException(e);
    }
    return properties;
}
#end_block

#method_before
public static void removeEmptyDirectory(String path) {
    File dir = new File(path);
    boolean isDeleted;
    if (dir.isDirectory()) {
        File[] files = dir.listFiles();
        if (files != null && files.length == 0) {
            isDeleted = dir.delete();
        } else if (files != null && files.length == 1) {
            if (files[0].getName().equals("package-info.java")) {
                isDeleted = dir.delete();
            }
        }
    }
}
#method_after
public static void removeEmptyDirectory(String path) {
    int index;
    while (path != null && !path.equals("")) {
        if (!removeDirectory(path)) {
            break;
        } else {
            index = path.lastIndexOf(SLASH);
            path = path.substring(0, index);
        }
    }
}
#end_block

#method_before
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangModule || javaCodeGeneratorInfo instanceof YangSubModule) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().setRooNode(true);
    }
    if (javaCodeGeneratorInfo instanceof RpcNotificationContainer) {
        /*
             * Module / sub module node code generation.
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
        if (javaCodeGeneratorInfo instanceof YangJavaModuleTranslator) {
            if (!((YangJavaModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(javaCodeGeneratorInfo, yangPluginConfig);
            }
        } else if (javaCodeGeneratorInfo instanceof YangJavaSubModuleTranslator) {
            if (!((YangJavaSubModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(javaCodeGeneratorInfo, yangPluginConfig);
            }
        }
    }
    if (javaCodeGeneratorInfo instanceof YangLeavesHolder) {
        /*
             * Container
             * Case
             * Grouping
             * Input
             * List
             * Notification
             * Output
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangTypeHolder) {
        /*
             * Typedef
             * Union
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addTypeInfoToTempFiles((YangTypeHolder) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangJavaEnumerationTranslator) {
        /*
             * Enumeration
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles().addEnumAttributeToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangChoice) {
    /*Do nothing, only the interface needs to be generated*/
    } else {
        throw new TranslatorException("Unsupported Node Translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
}
#method_after
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (javaCodeGeneratorInfo instanceof RpcNotificationContainer) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().setRooNode(true);
        /*
             * Module / sub module node code generation.
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
        if (javaCodeGeneratorInfo instanceof YangJavaModuleTranslator) {
            if (!((YangJavaModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(javaCodeGeneratorInfo, yangPluginConfig);
            }
        } else if (javaCodeGeneratorInfo instanceof YangJavaSubModuleTranslator) {
            if (!((YangJavaSubModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(javaCodeGeneratorInfo, yangPluginConfig);
            }
        }
    }
    if (javaCodeGeneratorInfo instanceof YangLeavesHolder) {
        /*
             * Container
             * Case
             * Grouping
             * Input
             * List
             * Notification
             * Output
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangTypeHolder) {
        /*
             * Typedef
             * Union
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addTypeInfoToTempFiles((YangTypeHolder) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangJavaEnumerationTranslator) {
        /*
             * Enumeration
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles().addEnumAttributeToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangChoice) {
    /*Do nothing, only the interface needs to be generated*/
    } else {
        throw new TranslatorException("Unsupported Node Translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
}
#end_block

#method_before
public static boolean isRootNodesCodeGenRequired(YangNode node) {
    List<YangNode> childNodes = new ArrayList<>();
    YangLeavesHolder holder = (YangLeavesHolder) node;
    if (holder.getListOfLeaf().isEmpty()) {
        if (holder.getListOfLeafList().isEmpty()) {
            YangNode tempNode = node.getChild();
            while (tempNode != null) {
                childNodes.add(tempNode);
                tempNode = tempNode.getNextSibling();
            }
            if (childNodes.isEmpty()) {
                return false;
            }
            List<Boolean> booleanData = new ArrayList<>();
            for (YangNode child : childNodes) {
                if (child instanceof YangTranslatorOperatorNode) {
                    booleanData.add(false);
                } else {
                    booleanData.add(true);
                }
            }
            return booleanData.contains(true);
        } else {
            return true;
        }
    } else {
        return true;
    }
}
#method_after
public static boolean isRootNodesCodeGenRequired(YangNode node) {
    YangLeavesHolder holder = (YangLeavesHolder) node;
    if (holder.getListOfLeaf().isEmpty()) {
        if (holder.getListOfLeafList().isEmpty()) {
            YangNode tempNode = node.getChild();
            if (tempNode == null) {
                return false;
            }
            while (tempNode != null) {
                if (!(tempNode instanceof YangTranslatorOperatorNode)) {
                    return true;
                }
                tempNode = tempNode.getNextSibling();
            }
            return false;
        } else {
            return true;
        }
    } else {
        return true;
    }
}
#end_block

#method_before
public static String getNodesPackage(YangNode node, YangPluginConfig yangPluginConfig) {
    List<String> clsInfo = new ArrayList<>();
    while (node.getParent() != null) {
        if (node instanceof YangJavaAugmentTranslator) {
            clsInfo.add(getAugmentClassName((YangAugment) node, yangPluginConfig));
        } else {
            clsInfo.add(getCamelCase(node.getName(), yangPluginConfig.getConflictResolver()));
        }
        node = node.getParent();
    }
    StringBuilder pkg = new StringBuilder();
    if (node instanceof YangJavaModuleTranslator) {
        YangJavaModuleTranslator module = (YangJavaModuleTranslator) node;
        pkg.append(getRootPackage(module.getVersion(), module.getNameSpace(), module.getRevision().getRevDate(), yangPluginConfig.getConflictResolver()));
    } else if (node instanceof YangJavaSubModuleTranslator) {
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        pkg.append(getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(subModule.getBelongsTo()), subModule.getRevision().getRevDate(), yangPluginConfig.getConflictResolver()));
    }
    String concat = "";
    for (int i = 1; i <= clsInfo.size(); i++) {
        concat = concat + "." + clsInfo.get(clsInfo.size() - i);
    }
    pkg.append(concat);
    return pkg.toString().toLowerCase();
}
#method_after
public static String getNodesPackage(YangNode node, YangPluginConfig yangPluginConfig) {
    List<String> clsInfo = new ArrayList<>();
    while (node.getParent() != null) {
        if (node instanceof YangJavaAugmentTranslator) {
            clsInfo.add(getAugmentClassName((YangAugment) node, yangPluginConfig));
        } else {
            clsInfo.add(getCamelCase(node.getName(), yangPluginConfig.getConflictResolver()));
        }
        node = node.getParent();
    }
    StringBuilder pkg = new StringBuilder();
    if (node instanceof YangJavaModuleTranslator) {
        YangJavaModuleTranslator module = (YangJavaModuleTranslator) node;
        pkg.append(getRootPackage(module.getVersion(), module.getNameSpace(), module.getRevision(), yangPluginConfig.getConflictResolver()));
    } else if (node instanceof YangJavaSubModuleTranslator) {
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        pkg.append(getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(), subModule.getRevision(), yangPluginConfig.getConflictResolver()));
    }
    String concat = "";
    for (int i = 1; i <= clsInfo.size(); i++) {
        concat = concat + "." + clsInfo.get(clsInfo.size() - i);
    }
    pkg.append(concat);
    return pkg.toString().toLowerCase();
}
#end_block

#method_before
static String getAugmentClassName(YangAugment augment, YangPluginConfig yangPluginConfig) {
    YangNodeIdentifier yangNodeIdentifier = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier();
    String name = getCapitalCase(getCamelCase(yangNodeIdentifier.getName(), yangPluginConfig.getConflictResolver()));
    if (yangNodeIdentifier.getPrefix() != null) {
        return AUGMENTED + getCapitalCase(getCamelCase(yangNodeIdentifier.getPrefix(), yangPluginConfig.getConflictResolver())) + name;
    } else {
        return AUGMENTED + name;
    }
}
#method_after
private static String getAugmentClassName(YangAugment augment, YangPluginConfig yangPluginConfig) {
    YangNodeIdentifier yangNodeIdentifier = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier();
    String name = getCapitalCase(getCamelCase(yangNodeIdentifier.getName(), yangPluginConfig.getConflictResolver()));
    if (yangNodeIdentifier.getPrefix() != null) {
        return AUGMENTED + getCapitalCase(getCamelCase(yangNodeIdentifier.getPrefix(), yangPluginConfig.getConflictResolver())) + name;
    } else {
        return AUGMENTED + name;
    }
}
#end_block

#method_before
public Set<YangNode> getYangNodeSet() {
    return yangNodeSet;
}
#method_after
Set<YangNode> getYangNodeSet() {
    return yangNodeSet;
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    String modulePkg = getRootPackage(getVersion(), getNameSpace(), getRevision().getRevDate(), yangPlugin.getConflictResolver());
    if (isNotificationChildNodePresent(this)) {
        getJavaFileInfo().setGeneratedFileTypes(getJavaFileInfo().getGeneratedFileTypes() | GENERATE_ALL_EVENT_CLASS_MASK);
    }
    try {
        generateCodeOfRootNode(this, yangPlugin, modulePkg);
    } catch (IOException e) {
        throw new TranslatorException("Failed to prepare generate code entry for module node " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + " " + e.getLocalizedMessage());
    }
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    String modulePkg = getRootPackage(getVersion(), getNameSpace(), getRevision(), yangPlugin.getConflictResolver());
    if (isNotificationChildNodePresent(this)) {
        getJavaFileInfo().setGeneratedFileTypes(getJavaFileInfo().getGeneratedFileTypes() | GENERATE_ALL_EVENT_CLASS_MASK);
    }
    try {
        generateCodeOfRootNode(this, yangPlugin, modulePkg);
    } catch (IOException e) {
        throw new TranslatorException("Failed to prepare generate code entry for module node " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + " " + e.getLocalizedMessage());
    }
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        if (type.getDataType().equals(BINARY)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(BITS)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if ((type.getDataType().equals(YangDataTypes.DERIVED)) && (((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType().equals(YangDataTypes.IDENTITYREF))) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (type.getDataType().equals(YangDataTypes.IDENTITYREF)) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (!yangDataTypes.equals(YangDataTypes.IDENTITYREF)) {
            methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    if (type.getDataType().equals(BINARY)) {
        imports.add(IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_IMPORT_BASE64_CLASS);
    }
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        if (type.getDataType().equals(BINARY)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(BITS)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if ((type.getDataType().equals(YangDataTypes.DERIVED)) && (((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType().equals(YangDataTypes.IDENTITYREF))) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (type.getDataType().equals(YangDataTypes.IDENTITYREF)) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (!yangDataTypes.equals(YangDataTypes.IDENTITYREF)) {
            methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        if (isOnlyAugmentNodeInRoot(curNode)) {
            // Getter methods.
            methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
            // Setter methods.
            methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        }
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        if (isGetSetOfRootNodeRequired(curNode)) {
            // Getter methods.
            methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
            // Setter methods.
            methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        }
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public String getNameSpaceFromModule(YangBelongsTo belongsToInfo) {
    return (belongsToInfo.getModuleNode()).getNameSpace();
}
#method_after
public String getNameSpaceFromModule() {
    return (getBelongsTo().getModuleNode()).getNameSpace();
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    String subModulePkg = getRootPackage(getVersion(), getNameSpaceFromModule(getBelongsTo()), getRevision().getRevDate(), yangPlugin.getConflictResolver());
    if (isNotificationChildNodePresent(this)) {
        getJavaFileInfo().setGeneratedFileTypes(getJavaFileInfo().getGeneratedFileTypes() | GENERATE_ALL_EVENT_CLASS_MASK);
    }
    try {
        generateCodeOfRootNode(this, yangPlugin, subModulePkg);
    } catch (IOException e) {
        throw new TranslatorException("failed to prepare generate code entry for submodule node " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + " " + e.getLocalizedMessage());
    }
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    String subModulePkg = getRootPackage(getVersion(), getNameSpaceFromModule(), getRevision(), yangPlugin.getConflictResolver());
    if (isNotificationChildNodePresent(this)) {
        getJavaFileInfo().setGeneratedFileTypes(getJavaFileInfo().getGeneratedFileTypes() | GENERATE_ALL_EVENT_CLASS_MASK);
    }
    try {
        generateCodeOfRootNode(this, yangPlugin, subModulePkg);
    } catch (IOException e) {
        throw new TranslatorException("failed to prepare generate code entry for submodule node " + getName() + " in " + getLineNumber() + " at " + getCharPosition() + " in " + getFileName() + " " + e.getLocalizedMessage());
    }
}
#end_block

#method_before
public static void processAugmentEntry(TreeWalkListener listener, GeneratedYangParser.AugmentStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, AUGMENT_DATA, ctx.augment().getText(), ENTRY);
    // Validate augment argument string
    List<YangAtomicPath> targetNodes = getValidAbsoluteSchemaNodeId(ctx.augment().getText(), AUGMENT_DATA, ctx);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    // Check for identifier collision
    int line = ctx.getStart().getLine();
    int charPositionInLine = ctx.getStart().getCharPositionInLine();
    detectCollidingChildUtil(listener, line, charPositionInLine, "", AUGMENT_DATA);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangModule || curData instanceof YangSubModule) {
        YangNode curNode = (YangNode) curData;
        YangAugment yangAugment = getYangAugmentNode(JAVA_GENERATION);
        yangAugment.setLineNumber(line);
        yangAugment.setCharPosition(charPositionInLine);
        yangAugment.setFileName(listener.getFileName());
        // validateTargetNodePath(targetNodes, curNode, ctx);
        // TODO: handle in linker.
        yangAugment.setTargetNode(targetNodes);
        yangAugment.setName(removeQuotesAndHandleConcat(ctx.augment().getText()));
        try {
            curNode.addChild(yangAugment);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, AUGMENT_DATA, ctx.augment().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangAugment);
        // Add resolution information to the list
        YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangAugment>(yangAugment, curNode, line, charPositionInLine);
        addToResolutionList(resolutionInfo, ctx);
    } else if (curData instanceof YangUses) {
        handleUnsupportedYangConstruct(USES_AUGMENT_DATA, ctx, CURRENTLY_UNSUPPORTED, listener.getFileName());
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, AUGMENT_DATA, ctx.augment().getText(), ENTRY));
    }
}
#method_after
public static void processAugmentEntry(TreeWalkListener listener, GeneratedYangParser.AugmentStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, AUGMENT_DATA, ctx.augment().getText(), ENTRY);
    // Validate augment argument string
    List<YangAtomicPath> targetNodes = getValidAbsoluteSchemaNodeId(ctx.augment().getText(), AUGMENT_DATA, ctx);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    // Check for identifier collision
    int line = ctx.getStart().getLine();
    int charPositionInLine = ctx.getStart().getCharPositionInLine();
    detectCollidingChildUtil(listener, line, charPositionInLine, "", AUGMENT_DATA);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangModule || curData instanceof YangSubModule) {
        YangNode curNode = (YangNode) curData;
        YangAugment yangAugment = getYangAugmentNode(JAVA_GENERATION);
        yangAugment.setLineNumber(line);
        yangAugment.setCharPosition(charPositionInLine);
        yangAugment.setFileName(listener.getFileName());
        // validateTargetNodePath(targetNodes, curNode, ctx);
        // TODO: handle in linker.
        yangAugment.setTargetNode(targetNodes);
        yangAugment.setName(removeQuotesAndHandleConcat(ctx.augment().getText()));
        try {
            curNode.addChild(yangAugment);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, AUGMENT_DATA, ctx.augment().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangAugment);
        // Add resolution information to the list
        YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangAugment>(yangAugment, curNode, line, charPositionInLine);
        addToResolutionList(resolutionInfo, ctx);
    } else if (curData instanceof YangUses) {
        throw new ParserException(constructListenerErrorMessage(UNHANDLED_PARSED_DATA, AUGMENT_DATA, ctx.augment().getText(), ENTRY));
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, AUGMENT_DATA, ctx.augment().getText(), ENTRY));
    }
}
#end_block

#method_before
protected void installIntents(SetMultimap<VlanId, Pair<ConnectPoint, MacAddress>> confHostPresentCPoint) {
    List<Intent> intents = new ArrayList<>();
    Set<VlanId> vlanIds = confHostPresentCPoint.keySet();
    vlanIds.forEach(vlanId -> {
        Set<Pair<ConnectPoint, MacAddress>> cPoints = confHostPresentCPoint.get(vlanId);
        if (cPoints == null) {
            return;
        }
        cPoints.forEach(cPoint -> {
            Set<Pair<ConnectPoint, MacAddress>> otherCPoints = new HashSet<>();
            otherCPoints.addAll(cPoints);
            otherCPoints.remove(cPoint);
            MacAddress mac = cPoint.getValue();
            ConnectPoint src = cPoint.getKey();
            Set<ConnectPoint> dsts = otherCPoints.stream().map(e -> e.getKey()).collect(Collectors.toSet());
            Key brcKey = buildKey(PREFIX_BROADCAST, src, vlanId);
            if (intentService.getIntent(brcKey) == null) {
                SinglePointToMultiPointIntent brcIntent = buildBrcIntent(brcKey, src, dsts, vlanId);
                intents.add(brcIntent);
            }
            if (mac != null && countMacInCPoints(cPoints) > 1) {
                Key uniKey = buildKey(PREFIX_UNICAST, src, vlanId);
                if (intentService.getIntent(uniKey) == null) {
                    MultiPointToSinglePointIntent uniIntent = buildUniIntent(uniKey, dsts, src, vlanId, mac);
                    intents.add(uniIntent);
                }
            }
        });
    });
    submitIntents(intents);
}
#method_after
protected void installIntents(SetMultimap<VlanId, Pair<ConnectPoint, MacAddress>> confHostPresentCPoint) {
    List<Intent> intents = new ArrayList<>();
    confHostPresentCPoint.keySet().stream().filter(vlanId -> confHostPresentCPoint.get(vlanId) != null).forEach(vlanId -> {
        Set<Pair<ConnectPoint, MacAddress>> cPoints = confHostPresentCPoint.get(vlanId);
        cPoints.forEach(cPoint -> {
            MacAddress mac = cPoint.getValue();
            ConnectPoint src = cPoint.getKey();
            Set<ConnectPoint> dsts = cPoints.stream().map(Pair::getKey).filter(cp -> !cp.equals(src)).collect(Collectors.toSet());
            Key brcKey = buildKey(PREFIX_BROADCAST, src, vlanId);
            if (intentService.getIntent(brcKey) == null) {
                SinglePointToMultiPointIntent brcIntent = buildBrcIntent(brcKey, src, dsts, vlanId);
                intents.add(brcIntent);
            }
            if (mac != null && countMacInCPoints(cPoints) > 1) {
                Key uniKey = buildKey(PREFIX_UNICAST, src, vlanId);
                if (intentService.getIntent(uniKey) == null) {
                    MultiPointToSinglePointIntent uniIntent = buildUniIntent(uniKey, dsts, src, vlanId, mac);
                    intents.add(uniIntent);
                }
            }
        });
    });
    submitIntents(intents);
}
#end_block

#method_before
protected ForwardingInstructions createForwardingInstructions(LinkCollectionIntent intent, PortNumber inPort, DeviceId deviceId, Set<PortNumber> outPorts, Set<PortNumber> ingressPorts, Set<PortNumber> egressPorts) {
    TrafficTreatment.Builder defaultTreatmentBuilder = DefaultTrafficTreatment.builder();
    outPorts.forEach(defaultTreatmentBuilder::setOutput);
    TrafficTreatment outputOnlyTreatment = defaultTreatmentBuilder.build();
    TrafficSelector.Builder selectorBuilder;
    TrafficTreatment treatment;
    TrafficTreatment intentTreatment;
    if (!intent.applyTreatmentOnEgress()) {
        TrafficTreatment.Builder ingressTreatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
        outPorts.forEach(ingressTreatmentBuilder::setOutput);
        intentTreatment = ingressTreatmentBuilder.build();
        if (ingressPorts.contains(inPort)) {
            if (intent.ingressSelectors() != null && !intent.ingressSelectors().isEmpty()) {
                Optional<ConnectPoint> connectPoint = intent.ingressPoints().parallelStream().filter(ingressPoint -> ingressPoint.port().equals(inPort) && ingressPoint.deviceId().equals(deviceId)).findFirst();
                if (connectPoint.isPresent()) {
                    selectorBuilder = DefaultTrafficSelector.builder(intent.ingressSelectors().get(connectPoint.get()));
                } else {
                    throw new IntentCompilationException("Multiple Selectors, inPort not in IngressPoints");
                }
            } else if (intent.selector() != null) {
                selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
            } else {
                throw new IntentCompilationException("No selector and no Multiple Selectors");
            }
            treatment = this.updateTreatment(intentTreatment, selectorBuilder.build());
        } else {
            selectorBuilder = this.createSelectorFromFwdInstructions(new ForwardingInstructions(intentTreatment, intent.selector()));
            treatment = outputOnlyTreatment;
        }
    } else {
        if (outPorts.stream().allMatch(egressPorts::contains)) {
            TrafficTreatment.Builder egressTreatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
            outPorts.forEach(egressTreatmentBuilder::setOutput);
            selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
            treatment = egressTreatmentBuilder.build();
        } else {
            selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
            treatment = outputOnlyTreatment;
        }
    }
    TrafficSelector selector = selectorBuilder.matchInPort(inPort).build();
    return new ForwardingInstructions(treatment, selector);
}
#method_after
protected ForwardingInstructions createForwardingInstructions(LinkCollectionIntent intent, PortNumber inPort, DeviceId deviceId, Set<PortNumber> outPorts, Set<PortNumber> ingressPorts, Set<PortNumber> egressPorts) {
    TrafficTreatment.Builder defaultTreatmentBuilder = DefaultTrafficTreatment.builder();
    outPorts.forEach(defaultTreatmentBuilder::setOutput);
    TrafficTreatment outputOnlyTreatment = defaultTreatmentBuilder.build();
    TrafficSelector.Builder selectorBuilder;
    TrafficTreatment treatment;
    TrafficTreatment intentTreatment;
    if (!intent.applyTreatmentOnEgress()) {
        TrafficTreatment.Builder ingressTreatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
        outPorts.forEach(ingressTreatmentBuilder::setOutput);
        intentTreatment = ingressTreatmentBuilder.build();
        if (ingressPorts.contains(inPort)) {
            if (intent.ingressSelectors() != null && !intent.ingressSelectors().isEmpty()) {
                /**
                 * We iterate on the ingress points looking for the connect point
                 * associated to inPort.
                 */
                Optional<ConnectPoint> connectPoint = intent.ingressPoints().stream().filter(ingressPoint -> ingressPoint.port().equals(inPort) && ingressPoint.deviceId().equals(deviceId)).findFirst();
                if (connectPoint.isPresent()) {
                    selectorBuilder = DefaultTrafficSelector.builder(intent.ingressSelectors().get(connectPoint.get()));
                } else {
                    throw new IntentCompilationException("Looking for connect point associated to the selector." + "inPort not in IngressPoints");
                }
            } else {
                selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
            }
            treatment = this.updateBuilder(ingressTreatmentBuilder, selectorBuilder.build()).build();
        } else {
            selectorBuilder = this.createSelectorFromFwdInstructions(new ForwardingInstructions(intentTreatment, intent.selector()));
            treatment = outputOnlyTreatment;
        }
    } else {
        if (outPorts.stream().allMatch(egressPorts::contains)) {
            TrafficTreatment.Builder egressTreatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
            outPorts.forEach(egressTreatmentBuilder::setOutput);
            selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
            treatment = egressTreatmentBuilder.build();
        } else {
            selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
            treatment = outputOnlyTreatment;
        }
    }
    TrafficSelector selector = selectorBuilder.matchInPort(inPort).build();
    return new ForwardingInstructions(treatment, selector);
}
#end_block

#method_before
private void updateBuilder(TrafficSelector.Builder builder, L4ModificationInstruction l4instruction) {
    if (l4instruction instanceof ModTransportPortInstruction) {
        // TODO check IP proto
        ModTransportPortInstruction l4mod = (ModTransportPortInstruction) l4instruction;
        switch(l4mod.subtype()) {
            case TCP_SRC:
                builder.matchTcpSrc(l4mod.port());
                break;
            case TCP_DST:
                builder.matchTcpDst(l4mod.port());
                break;
            case UDP_SRC:
                builder.matchUdpSrc(l4mod.port());
                break;
            case UDP_DST:
                builder.matchUdpDst(l4mod.port());
                break;
            default:
                throw new IntentCompilationException("Unknown L4 Modification instruction");
        }
    } else {
        throw new IntentCompilationException("Unknown L4 Modification instruction");
    }
}
#method_after
private TrafficTreatment.Builder updateBuilder(TrafficTreatment.Builder treatmentBuilder, TrafficSelector intentSelector) {
    return treatmentBuilder;
}
#end_block

#method_before
@Test
public void multipleSelectors() {
    MultiPointToSinglePointIntent intent = createFirstMultiple();
    assertEquals("incorrect id", APPID, intent.appId());
    assertEquals("incorrect match", MATCH, intent.selector());
    assertEquals("incorrect ingress", PS1, intent.ingressPoints());
    assertEquals("incorrect egress", P2, intent.egressPoint());
    assertEquals("incorrect selectors", MATCHES, intent.ingressSelectors());
    intent = createFirstMultiple();
    assertEquals("incorrect id", APPID, intent.appId());
    assertEquals("incorrect match", MATCH, intent.selector());
    assertEquals("incorrect ingress", PS1, intent.ingressPoints());
    assertEquals("incorrect egress", P2, intent.egressPoint());
    assertEquals("incorrect selectors", MATCHES, intent.ingressSelectors());
    intent = createSecondMultiple();
    assertEquals("incorrect id", APPID, intent.appId());
    assertEquals("incorrect match", VLANMATCH1, intent.selector());
    assertEquals("incorrect ingress", PS1, intent.ingressPoints());
    assertEquals("incorrect egress", P2, intent.egressPoint());
    assertEquals("incorrect selectors", MATCHES, intent.ingressSelectors());
    intent = createThirdMultiple();
    assertEquals("incorrect id", APPID, intent.appId());
    assertEquals("incorrect match", MATCH, intent.selector());
    assertEquals("incorrect ingress", PS1, intent.ingressPoints());
    assertEquals("incorrect egress", P2, intent.egressPoint());
    assertEquals("incorrect selectors", VLANMATCHES, intent.ingressSelectors());
    wrongMultiple.expect(IllegalArgumentException.class);
    wrongMultiple.expectMessage("Selector and Multiple Selectors are both set");
    intent = createWrongMultiple();
}
#method_after
@Test
public void multipleSelectors() {
    MultiPointToSinglePointIntent intent = createFirstMultiple();
    assertEquals("incorrect id", APPID, intent.appId());
    assertEquals("incorrect match", MATCH, intent.selector());
    assertEquals("incorrect ingress", PS1, intent.ingressPoints());
    assertEquals("incorrect egress", P2, intent.egressPoint());
    assertEquals("incorrect selectors", MATCHES, intent.ingressSelectors());
    intent = createSecondMultiple();
    assertEquals("incorrect id", APPID, intent.appId());
    assertEquals("incorrect match", VLANMATCH1, intent.selector());
    assertEquals("incorrect ingress", PS1, intent.ingressPoints());
    assertEquals("incorrect egress", P2, intent.egressPoint());
    assertEquals("incorrect selectors", MATCHES, intent.ingressSelectors());
    intent = createThirdMultiple();
    assertEquals("incorrect id", APPID, intent.appId());
    assertEquals("incorrect match", MATCH, intent.selector());
    assertEquals("incorrect ingress", PS1, intent.ingressPoints());
    assertEquals("incorrect egress", P2, intent.egressPoint());
    assertEquals("incorrect selectors", VLANMATCHES, intent.ingressSelectors());
    wrongMultiple.expect(IllegalArgumentException.class);
    wrongMultiple.expectMessage("Selector and Multiple Selectors are both set");
    intent = createWrongMultiple();
}
#end_block

#method_before
@Override
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#method_after
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#end_block

#method_before
@Override
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#method_after
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#end_block

#method_before
@Override
public YangSchemaNode getNotificationSchemaNode(String notificationNameInEnum) throws DataModelException {
    throw new DataModelException("Method called for schema node other then module/sub-module");
}
#method_after
@Override
public YangSchemaNode getNotificationSchemaNode(String notificationNameInEnum) throws DataModelException {
    throw new DataModelException("Method called for schema node other " + "then module/sub-module");
}
#end_block

#method_before
private void linkAndResolvePartialResolvedStack() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        /*
             * Current node to resolve, it can be a YANG type or YANG uses or
             * YANG if-feature or YANG leafref or YANG base or YANG identityref.
             */
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                         * If the entity is already resolved in the stack, then pop
                         * it and continue with the remaining stack elements to
                         * resolve
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case LINKED:
                    {
                        /*
                         * If the top of the stack is already linked then resolve
                         * the references and pop the entity and continue with
                         * remaining stack elements to resolve.
                         */
                        resolveTopOfStack(INTRA_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                         * Pop the top of the stack.
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case UNRESOLVED:
                    {
                        linkTopOfStackReferenceUpdateStack();
                        if (resolvable.getResolvableStatus() == UNRESOLVED) {
                            // If current entity is still not resolved, then
                            // linking/resolution has failed.
                            String errorInfo;
                            if (resolvable instanceof YangType) {
                                errorInfo = TYPEDEF_LINKER_ERROR;
                            } else if (resolvable instanceof YangUses) {
                                errorInfo = GROUPING_LINKER_ERROR;
                            } else if (resolvable instanceof YangIfFeature) {
                                errorInfo = FEATURE_LINKER_ERROR;
                            } else if (resolvable instanceof YangBase) {
                                errorInfo = BASE_LINKER_ERROR;
                            } else if (resolvable instanceof YangIdentityRef) {
                                errorInfo = IDENTITYREF_LINKER_ERROR;
                            } else {
                                errorInfo = LEAFREF_LINKER_ERROR;
                            }
                            DataModelException dataModelException = new DataModelException(errorInfo);
                            dataModelException.setLine(getLineNumber());
                            dataModelException.setCharPosition(getCharPosition());
                            throw dataModelException;
                        }
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state ");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses/if-feature" + "/leafref/base/identityref");
        }
    }
}
#method_after
private void linkAndResolvePartialResolvedStack() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        /*
             * Current node to resolve, it can be a YANG type or YANG uses or
             * YANG if-feature or YANG leafref or YANG base or YANG identityref.
             */
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                         * If the entity is already resolved in the stack, then pop
                         * it and continue with the remaining stack elements to
                         * resolve
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case LINKED:
                    {
                        /*
                         * If the top of the stack is already linked then resolve
                         * the references and pop the entity and continue with
                         * remaining stack elements to resolve.
                         */
                        resolveTopOfStack(INTRA_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                         * Pop the top of the stack.
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case UNRESOLVED:
                    {
                        linkTopOfStackReferenceUpdateStack();
                        if (resolvable.getResolvableStatus() == UNRESOLVED) {
                            // If current entity is still not resolved, then
                            // linking/resolution has failed.
                            String errorInfo;
                            if (resolvable instanceof YangType) {
                                errorInfo = TYPEDEF_LINKER_ERROR;
                            } else if (resolvable instanceof YangUses) {
                                errorInfo = GROUPING_LINKER_ERROR;
                            } else if (resolvable instanceof YangIfFeature) {
                                errorInfo = FEATURE_LINKER_ERROR;
                            } else if (resolvable instanceof YangBase) {
                                errorInfo = BASE_LINKER_ERROR;
                            } else if (resolvable instanceof YangIdentityRef) {
                                errorInfo = IDENTITYREF_LINKER_ERROR;
                            } else {
                                errorInfo = LEAFREF_LINKER_ERROR;
                            }
                            DataModelException dataModelException = new DataModelException(errorInfo);
                            dataModelException.setLine(getLineNumber());
                            dataModelException.setCharPosition(getCharPosition());
                            throw dataModelException;
                        }
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses/if-feature" + "/leafref/base/identityref");
        }
    }
}
#end_block

#method_before
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (isLeavesPresent) {
                insertDataIntoJavaFile(file, NEW_LINE + getInterfaceLeafIdEnumSignature(className) + NEW_LINE + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path), COMMA, SEMI_COLAN), NEW_LINE) + NEW_LINE + NEW_LINE + getInterfaceLeafIdEnumMethods());
            }
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, javaFileInfo.getPluginConfig());
        methods.add(NEW_LINE + processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(NEW_LINE + processSubtreeFilteringInterface(className));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + isLeafValueSetInterface());
        methods.add(NEW_LINE + isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (isLeavesPresent) {
                insertDataIntoJavaFile(file, NEW_LINE + getInterfaceLeafIdEnumSignature(className) + NEW_LINE + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path), COMMA, SEMI_COLAN), NEW_LINE) + NEW_LINE + NEW_LINE + getInterfaceLeafIdEnumMethods());
            }
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, javaFileInfo.getPluginConfig());
        methods.add(NEW_LINE + processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(NEW_LINE + processSubtreeFilteringInterface(className));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + isLeafValueSetInterface());
        methods.add(NEW_LINE + isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            // Getter methods.
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list method.
            methods.add(NEW_LINE);
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ADD_TO_LIST_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getAddAugmentInfoMethodInterface());
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + setSelectLeafSetInterface(className));
    }
    // Add build method to builder interface file.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    // Add getters and setters in builder interface.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            // Getter methods.
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list method.
            methods.add(NEW_LINE);
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ADD_TO_LIST_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getAddAugmentInfoMethodInterface());
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + setSelectLeafSetInterface(className));
    }
    // Add build method to builder interface file.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    // Add getters and setters in builder interface.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
/**
 * Returns generated builder class file for current node.
 *
 * @param file          file
 * @param curNode       current YANG node
 * @param isAttrPresent if any attribute is present or not
 * @return builder class file
 * @throws IOException when fails to write in file
 */
public static File generateBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isRootNode = false;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            methods.add(getGetterForOperationType());
            methods.add(getSetterForOperationType(className));
            // Add operation attribute methods.
            if (isLeavesPresent) {
                methods.add(getOperationAttributesGetters() + NEW_LINE);
                methods.add(getSetterForSelectLeaf(className, isRootNode));
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl(curNode));
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER, pluginConfig, curNode));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#method_after
/**
 * Returns generated builder class file for current node.
 *
 * @param file          file
 * @param curNode       current YANG node
 * @param isAttrPresent if any attribute is present or not
 * @return builder class file
 * @throws IOException when fails to write in file
 */
public static File generateBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isRootNode = false;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder class file generation");
        }
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            methods.add(getGetterForOperationType());
            methods.add(getSetterForOperationType(className));
            // Add operation attribute methods.
            if (isLeavesPresent) {
                methods.add(getOperationAttributesGetters() + NEW_LINE);
                methods.add(getSetterForSelectLeaf(className, isRootNode));
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl(curNode));
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER, pluginConfig, curNode));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#end_block

#method_before
public static File generateDefaultClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    boolean isRootNode = false;
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        opParamClassName = className + OP_PARAM;
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        // Add operation attributes
        insertDataIntoJavaFile(file, getOperationTypeEnum());
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            methods.add(getGetterForOperationType());
            // Hash code method.
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            // Equals method.
            if (isRootNode) {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(opParamClassName) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            } else {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            }
            // To string method.
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, pluginConfig, isRootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        if (isAttrPresent) {
            constructor = constructor + getOperationTypeForConstructor();
        }
        if (isLeavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        // add is filter content match.
        String augmentableSubTreeFiltering = "";
        if (curNode instanceof YangAugmentableNode) {
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(getProcessSubtreeFilteringStart(curNode, pluginConfig) + getProcessSubtreeFunctionBody() + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd() + getProcessLeafSubtreeFiltering(curNode, pluginConfig, path) + getProcessLeafListSubtreeFiltering(curNode, pluginConfig, path) + getProcessChildNodeSubtreeFiltering(curNode, pluginConfig, path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PROTECTED, DEFAULT, pluginConfig, curNode));
    methods.add(builderMethod(className) + NEW_LINE);
    if (isLeavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateDefaultClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    boolean isRootNode = false;
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        opParamClassName = className + OP_PARAM;
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while impl class file generation");
        }
        // Add operation attributes
        insertDataIntoJavaFile(file, getOperationTypeEnum());
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            methods.add(getGetterForOperationType());
            // Hash code method.
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            // Equals method.
            if (isRootNode) {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(opParamClassName) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            } else {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            }
            // To string method.
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, pluginConfig, isRootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        if (isAttrPresent) {
            constructor = constructor + getOperationTypeForConstructor();
        }
        if (isLeavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        if (curNode instanceof YangAugmentableNode) {
            constructor = constructor + getYangAugmentedMapObjectForConstruct();
        }
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        // add is filter content match.
        String augmentableSubTreeFiltering = "";
        if (curNode instanceof YangAugmentableNode) {
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(getProcessSubtreeFilteringStart(curNode, pluginConfig) + getProcessSubtreeFunctionBody(curNode) + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd());
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
                methods.add(getProcessLeafSubtreeFiltering(curNode, pluginConfig, path));
            }
        }
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
                methods.add(getProcessLeafListSubtreeFiltering(curNode, pluginConfig, path));
            }
        }
        if (curNode.getChild() != null) {
            methods.add(getProcessChildNodeSubtreeFiltering(curNode, pluginConfig, path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PROTECTED, DEFAULT, pluginConfig, curNode));
    methods.add(builderMethod(className) + NEW_LINE);
    if (isLeavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    if (type.getDataType().equals(BINARY)) {
        imports.add(IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_IMPORT_BASE64_CLASS);
    }
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        if (type.getDataType().equals(BINARY)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(BITS)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if ((type.getDataType().equals(YangDataTypes.DERIVED)) && (((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType().equals(YangDataTypes.IDENTITYREF))) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (type.getDataType().equals(YangDataTypes.IDENTITYREF)) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (!yangDataTypes.equals(YangDataTypes.IDENTITYREF)) {
            methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    if (type.getDataType().equals(BINARY)) {
        imports.add(IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_IMPORT_BASE64_CLASS);
    }
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        if (type.getDataType().equals(BINARY)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(BITS)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if ((type.getDataType().equals(YangDataTypes.DERIVED)) && (((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType().equals(YangDataTypes.IDENTITYREF))) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (type.getDataType().equals(YangDataTypes.IDENTITYREF)) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (!yangDataTypes.equals(YangDataTypes.IDENTITYREF)) {
            methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    // Add attribute strings.
    try {
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    // Add an attribute to get the enum's values.
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    // Add a constructor for enum.
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig, null) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    TempJavaEnumerationFragmentFiles enumFragFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles();
    insertDataIntoJavaFile(file, getEnumsOfMethod(className, enumFragFiles.getJavaAttributeForEnum(pluginConfig), enumFragFiles.getEnumSetJavaMap(), enumFragFiles.getEnumStringList(), pluginConfig) + NEW_LINE);
    // Add a getter method for enum.
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig, null) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    // Add attribute strings.
    try {
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class " + "file generation");
    }
    // Add an attribute to get the enum's values.
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    // Add a constructor for enum.
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig, null) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    TempJavaEnumerationFragmentFiles enumFragFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles();
    insertDataIntoJavaFile(file, getEnumsOfMethod(className, enumFragFiles.getJavaAttributeForEnum(pluginConfig), enumFragFiles.getEnumSetJavaMap(), enumFragFiles.getEnumStringList(), pluginConfig) + NEW_LINE);
    // Add a getter method for enum.
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig, null) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        if (!isOnlyAugmentNodeInRoot(curNode)) {
            // Getter methods.
            methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
            // Setter methods.
            methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        }
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    // TODO: throw exception
    return null;
}
#method_after
@Override
public String getJavaAttributeName() {
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
public static Range getRange(int fractionDigit) throws DataModelException {
    if (!((fractionDigit >= 1) && (fractionDigit <= 18))) {
        throw new DataModelException("YANG file error : given fraction-digit is not in its range (1..18). ");
    }
    return getDecimal64ValueRange().get(fractionDigit - 1);
}
#method_after
public static Range getRange(int fractionDigit) throws DataModelException {
    if (!((fractionDigit >= 1) && (fractionDigit <= 18))) {
        throw new DataModelException("YANG file error : given fraction-digit is not in its range (1..18).");
    }
    return getDecimal64ValueRange().get(fractionDigit - 1);
}
#end_block

#method_before
public static void cloneSubTree(YangNode srcRootNode, YangNode dstRootNode, YangUses yangUses) throws DataModelException {
    YangNode nextNodeToClone = srcRootNode;
    TraversalType curTraversal;
    YangNode clonedTreeCurNode = dstRootNode;
    YangNode newNode = null;
    nextNodeToClone = nextNodeToClone.getChild();
    if (nextNodeToClone == null) {
        return;
    } else {
        /*
             * Root level cloning is taken care in the caller.
             */
        curTraversal = CHILD;
    }
    /*
         * Caller ensures the cloning of the root nodes
         */
    try {
        while (nextNodeToClone != srcRootNode) {
            if (nextNodeToClone == null) {
                throw new DataModelException("Internal error: Cloning failed, source tree null pointer reached " + nextNodeToClone.getName() + " in " + nextNodeToClone.getLineNumber() + " at " + nextNodeToClone.getCharPosition() + " in " + nextNodeToClone.getFileName() + "\"");
            }
            if (curTraversal != PARENT) {
                newNode = nextNodeToClone.clone(yangUses);
                detectCollisionWhileCloning(clonedTreeCurNode, newNode, curTraversal);
            }
            if (curTraversal == CHILD) {
                /*
                     * add the new node to the cloned tree.
                     */
                clonedTreeCurNode.addChild(newNode);
                /*
                     * update the cloned tree's traversal current node as the
                     * new node.
                     */
                clonedTreeCurNode = newNode;
            } else if (curTraversal == SIBILING) {
                clonedTreeCurNode.addNextSibling(newNode);
                clonedTreeCurNode = newNode;
            } else if (curTraversal == PARENT) {
                if (clonedTreeCurNode instanceof YangLeavesHolder) {
                    updateClonedLeavesUnionEnumRef((YangLeavesHolder) clonedTreeCurNode);
                }
                clonedTreeCurNode = clonedTreeCurNode.getParent();
            }
            if (curTraversal != PARENT && nextNodeToClone.getChild() != null) {
                curTraversal = CHILD;
                /*
                     * update the traversal's current node.
                     */
                nextNodeToClone = nextNodeToClone.getChild();
            } else if (nextNodeToClone.getNextSibling() != null) {
                curTraversal = SIBILING;
                nextNodeToClone = nextNodeToClone.getNextSibling();
            } else {
                curTraversal = PARENT;
                nextNodeToClone = nextNodeToClone.getParent();
            }
        }
    } catch (CloneNotSupportedException e) {
        throw new DataModelException("Failed to clone the tree " + nextNodeToClone.getName() + " in " + nextNodeToClone.getLineNumber() + " at " + nextNodeToClone.getCharPosition() + " in " + nextNodeToClone.getFileName() + "\"");
    }
}
#method_after
public static void cloneSubTree(YangNode srcRootNode, YangNode dstRootNode, YangUses yangUses) throws DataModelException {
    YangNode nextNodeToClone = srcRootNode;
    TraversalType curTraversal;
    YangNode clonedTreeCurNode = dstRootNode;
    YangNode newNode = null;
    nextNodeToClone = nextNodeToClone.getChild();
    if (nextNodeToClone == null) {
        return;
    } else {
        /*
             * Root level cloning is taken care in the caller.
             */
        curTraversal = CHILD;
    }
    /*
         * Caller ensures the cloning of the root nodes
         */
    try {
        while (nextNodeToClone != srcRootNode) {
            if (nextNodeToClone == null) {
                throw new DataModelException("Internal error: Cloning failed, source tree null pointer reached " + nextNodeToClone.getName() + " in " + nextNodeToClone.getLineNumber() + " at " + nextNodeToClone.getCharPosition() + " in " + nextNodeToClone.getFileName() + "\"");
            }
            if (curTraversal != PARENT) {
                newNode = nextNodeToClone.clone(yangUses);
                detectCollisionWhileCloning(clonedTreeCurNode, newNode, curTraversal);
            }
            if (curTraversal == CHILD) {
                /*
                     * add the new node to the cloned tree.
                     */
                clonedTreeCurNode.addChild(newNode);
                /*
                     * update the cloned tree's traversal current node as the
                     * new node.
                     */
                clonedTreeCurNode = newNode;
            } else if (curTraversal == SIBILING) {
                clonedTreeCurNode.addNextSibling(newNode);
                clonedTreeCurNode = newNode;
            } else {
                if (clonedTreeCurNode instanceof YangLeavesHolder) {
                    updateClonedLeavesUnionEnumRef((YangLeavesHolder) clonedTreeCurNode);
                }
                clonedTreeCurNode = clonedTreeCurNode.getParent();
            }
            if (curTraversal != PARENT && nextNodeToClone.getChild() != null) {
                curTraversal = CHILD;
                /*
                     * update the traversal's current node.
                     */
                nextNodeToClone = nextNodeToClone.getChild();
            } else if (nextNodeToClone.getNextSibling() != null) {
                curTraversal = SIBILING;
                nextNodeToClone = nextNodeToClone.getNextSibling();
            } else {
                curTraversal = PARENT;
                nextNodeToClone = nextNodeToClone.getParent();
            }
        }
    } catch (CloneNotSupportedException e) {
        throw new DataModelException("Failed to clone the tree " + nextNodeToClone.getName() + " in " + nextNodeToClone.getLineNumber() + " at " + nextNodeToClone.getCharPosition() + " in " + nextNodeToClone.getFileName() + "\"");
    }
}
#end_block

#method_before
@Override
public YangSchemaNode getNotificationSchemaNode(String notificationNameInEnum) throws DataModelException {
    throw new DataModelException("Method called for schema node other then module/sub-module");
}
#method_after
@Override
public YangSchemaNode getNotificationSchemaNode(String notificationNameInEnum) throws DataModelException {
    throw new DataModelException("Method called for schema node other " + "then module/sub-module");
}
#end_block

#method_before
private static void addResolvableLeavesToResolutionList(YangLeavesHolder leavesHolder) {
    if (leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty()) {
        for (YangLeaf leaf : leavesHolder.getListOfLeaf()) {
            YangType type = leaf.getDataType();
            if (type.getDataType() == DERIVED) {
                type.setTypeForInterFileGroupingResolution(true);
                // Add resolution information to the list
                YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<>(type, (YangNode) leavesHolder, type.getLineNumber(), type.getCharPosition());
                try {
                    addResolutionInfo(resolutionInfo);
                } catch (DataModelException e) {
                    throw new LinkerException("Failed to add leaf type info in grouping, to resolution ");
                }
            } else if (type.getDataType() == IDENTITYREF) {
                YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
                identityRef.setIdentityForInterFileGroupingResolution(true);
                // Add resolution information to the list
                YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) leavesHolder, identityRef.getLineNumber(), identityRef.getCharPosition());
                try {
                    addResolutionInfo(resolutionInfo);
                } catch (DataModelException e) {
                    throw new LinkerException("Failed to add leaf identity ref info in grouping, to resolution");
                }
            }
        }
    }
    if (leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty()) {
        for (YangLeafList leafList : leavesHolder.getListOfLeafList()) {
            YangType type = leafList.getDataType();
            if (type.getDataType() == DERIVED) {
                type.setTypeForInterFileGroupingResolution(true);
                // Add resolution information to the list
                YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangType>(type, (YangNode) leavesHolder, type.getLineNumber(), type.getCharPosition());
                try {
                    addResolutionInfo(resolutionInfo);
                } catch (DataModelException e) {
                    throw new LinkerException("Failed to add leaf type info in grouping, to resolution ");
                }
            } else if (type.getDataType() == IDENTITYREF) {
                YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
                identityRef.setIdentityForInterFileGroupingResolution(true);
                // Add resolution information to the list
                YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) leavesHolder, identityRef.getLineNumber(), identityRef.getCharPosition());
                try {
                    addResolutionInfo(resolutionInfo);
                } catch (DataModelException e) {
                    throw new LinkerException("Failed to add leaf identity ref info in grouping, to resolution ");
                }
            }
        }
    }
}
#method_after
private static void addResolvableLeavesToResolutionList(YangLeavesHolder leavesHolder) {
    if (leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty()) {
        for (YangLeaf leaf : leavesHolder.getListOfLeaf()) {
            YangType type = leaf.getDataType();
            if (type.getDataType() == DERIVED) {
                type.setTypeForInterFileGroupingResolution(true);
                // Add resolution information to the list
                YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<>(type, (YangNode) leavesHolder, type.getLineNumber(), type.getCharPosition());
                try {
                    addResolutionInfo(resolutionInfo);
                } catch (DataModelException e) {
                    throw new LinkerException("Failed to add leaf type info in grouping, to resolution ");
                }
            } else if (type.getDataType() == IDENTITYREF) {
                YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
                identityRef.setIdentityForInterFileGroupingResolution(true);
                // Add resolution information to the list
                YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) leavesHolder, identityRef.getLineNumber(), identityRef.getCharPosition());
                try {
                    addResolutionInfo(resolutionInfo);
                } catch (DataModelException e) {
                    throw new LinkerException("Failed to add leaf identity ref info in grouping, to resolution ");
                }
            }
        }
    }
    if (leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty()) {
        for (YangLeafList leafList : leavesHolder.getListOfLeafList()) {
            YangType type = leafList.getDataType();
            if (type.getDataType() == DERIVED) {
                type.setTypeForInterFileGroupingResolution(true);
                // Add resolution information to the list
                YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangType>(type, (YangNode) leavesHolder, type.getLineNumber(), type.getCharPosition());
                try {
                    addResolutionInfo(resolutionInfo);
                } catch (DataModelException e) {
                    throw new LinkerException("Failed to add leaf type info in grouping, to resolution ");
                }
            } else if (type.getDataType() == IDENTITYREF) {
                YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
                identityRef.setIdentityForInterFileGroupingResolution(true);
                // Add resolution information to the list
                YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) leavesHolder, identityRef.getLineNumber(), identityRef.getCharPosition());
                try {
                    addResolutionInfo(resolutionInfo);
                } catch (DataModelException e) {
                    throw new LinkerException("Failed to add leaf identity ref info in grouping, to resolution ");
                }
            }
        }
    }
}
#end_block

#method_before
public static void addResolutionInfo(YangResolutionInfo resolutionInfo) throws DataModelException {
    /* get the module node to add maintain the list of nested reference */
    YangNode curNode = resolutionInfo.getEntityToResolveInfo().getHolderOfEntityToResolve();
    while (!(curNode instanceof YangReferenceResolver)) {
        curNode = curNode.getParent();
        if (curNode == null) {
            throw new DataModelException("Internal datamodel error: Datamodel tree is not correct ");
        }
    }
    YangReferenceResolver resolutionNode = (YangReferenceResolver) curNode;
    if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangType) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_DERIVED_DATA_TYPE);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangUses) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_USES);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangAugment) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_AUGMENT);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangIfFeature) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_IF_FEATURE);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangLeafRef) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_LEAFREF);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangBase) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_BASE);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangIdentityRef) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_IDENTITYREF);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangCompilerAnnotation) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_COMPILER_ANNOTATION);
    }
}
#method_after
public static void addResolutionInfo(YangResolutionInfo resolutionInfo) throws DataModelException {
    /* get the module node to add maintain the list of nested reference */
    YangNode curNode = resolutionInfo.getEntityToResolveInfo().getHolderOfEntityToResolve();
    while (!(curNode instanceof YangReferenceResolver)) {
        curNode = curNode.getParent();
        if (curNode == null) {
            throw new DataModelException("Internal datamodel error: Datamodel tree is not correct");
        }
    }
    YangReferenceResolver resolutionNode = (YangReferenceResolver) curNode;
    if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangType) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_DERIVED_DATA_TYPE);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangUses) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_USES);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangAugment) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_AUGMENT);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangIfFeature) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_IF_FEATURE);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangLeafRef) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_LEAFREF);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangBase) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_BASE);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangIdentityRef) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_IDENTITYREF);
    } else if (resolutionInfo.getEntityToResolveInfo().getEntityToResolve() instanceof YangCompilerAnnotation) {
        resolutionNode.addToResolutionList(resolutionInfo, ResolvableType.YANG_COMPILER_ANNOTATION);
    }
}
#end_block

#method_before
@Override
public JavaFileInfoTranslator getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return (JavaFileInfoTranslator) javaFileInfo;
}
#method_after
@Override
public JavaFileInfoTranslator getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java " + "datamodel node");
    }
    return (JavaFileInfoTranslator) javaFileInfo;
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    // with builder class.
    try {
        generateCodeOfAugmentableNode(this, yangPlugin);
        addNotificationToExtendsList();
    } catch (IOException e) {
        throw new TranslatorException("Failed to prepare generate code entry for notification node " + getName());
    }
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    // with builder class.
    try {
        generateCodeOfAugmentableNode(this, yangPlugin);
        addNotificationToExtendsList();
    } catch (IOException e) {
        throw new TranslatorException("Failed to prepare generate code entry for notification " + "node " + getName());
    }
}
#end_block

#method_before
@Override
public void generateCodeExit() throws TranslatorException {
    try {
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
    } catch (IOException e) {
        throw new TranslatorException("Failed to generate code for notification node " + getName());
    }
}
#method_after
@Override
public void generateCodeExit() throws TranslatorException {
    try {
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
    } catch (IOException e) {
        throw new TranslatorException("Failed to generate code for " + "notification node " + getName());
    }
}
#end_block

#method_before
public void addChild(YangNode newChild) throws DataModelException {
    if (newChild.getNodeType() == null) {
        throw new DataModelException("Abstract node cannot be inserted into a tree");
    }
    if (newChild.getParent() == null) {
        newChild.setParent(this);
    } else if (newChild.getParent() != this) {
        throw new DataModelException("Node is already part of a tree");
    }
    if (newChild.getChild() != null) {
        throw new DataModelException("Child to be added is not atomic, it already has a child");
    }
    if (newChild.getNextSibling() != null) {
        throw new DataModelException("Child to be added is not atomic, it already has a next sibling");
    }
    if (newChild.getPreviousSibling() != null) {
        throw new DataModelException("Child to be added is not atomic, it already has a previous sibling");
    }
    /* First child to be added */
    if (getChild() == null) {
        setChild(newChild);
    } else {
        YangNode curNode;
        curNode = getChild();
        // Get the predecessor child of new child
        while (curNode.getNextSibling() != null) {
            curNode = curNode.getNextSibling();
        }
        // If the new node needs to be the last child
        if (curNode.getNextSibling() == null) {
            curNode.setNextSibling(newChild);
            newChild.setPreviousSibling(curNode);
        }
    }
}
#method_after
public void addChild(YangNode newChild) throws DataModelException {
    if (newChild.getNodeType() == null) {
        throw new DataModelException("Abstract node cannot be inserted " + "into a tree");
    }
    if (newChild.getParent() == null) {
        newChild.setParent(this);
    } else if (newChild.getParent() != this) {
        throw new DataModelException("Node is already part of a tree");
    }
    if (newChild.getChild() != null) {
        throw new DataModelException("Child to be added is not atomic, " + "it already has a child");
    }
    if (newChild.getNextSibling() != null) {
        throw new DataModelException("Child to be added is not atomic, " + "it already has a next " + "sibling");
    }
    if (newChild.getPreviousSibling() != null) {
        throw new DataModelException("Child to be added is not atomic, " + "it already has a previous " + "sibling");
    }
    /* First child to be added */
    if (getChild() == null) {
        setChild(newChild);
    } else {
        YangNode curNode;
        curNode = getChild();
        // Get the predecessor child of new child
        while (curNode.getNextSibling() != null) {
            curNode = curNode.getNextSibling();
        }
        // If the new node needs to be the last child
        if (curNode.getNextSibling() == null) {
            curNode.setNextSibling(newChild);
            newChild.setPreviousSibling(curNode);
        }
    }
}
#end_block

#method_before
public static void cloneSubTree(YangNode srcRootNode, YangNode dstRootNode, YangUses yangUses) throws DataModelException {
    YangNode nextNodeToClone = srcRootNode;
    TraversalType curTraversal;
    YangNode clonedTreeCurNode = dstRootNode;
    YangNode newNode = null;
    nextNodeToClone = nextNodeToClone.getChild();
    if (nextNodeToClone == null) {
        return;
    } else {
        /*
             * Root level cloning is taken care in the caller.
             */
        curTraversal = CHILD;
    }
    /*
         * Caller ensures the cloning of the root nodes
         */
    try {
        while (nextNodeToClone != srcRootNode) {
            if (nextNodeToClone == null) {
                throw new DataModelException("Internal error: Cloning failed, source tree null pointer reached");
            }
            if (curTraversal != PARENT) {
                newNode = nextNodeToClone.clone(yangUses);
                detectCollisionWhileCloning(clonedTreeCurNode, newNode, curTraversal);
            }
            if (curTraversal == CHILD) {
                /*
                     * add the new node to the cloned tree.
                     */
                clonedTreeCurNode.addChild(newNode);
                /*
                     * update the cloned tree's traversal current node as the
                     * new node.
                     */
                clonedTreeCurNode = newNode;
            } else if (curTraversal == SIBILING) {
                clonedTreeCurNode.addNextSibling(newNode);
                clonedTreeCurNode = newNode;
            } else if (curTraversal == PARENT) {
                if (clonedTreeCurNode instanceof YangLeavesHolder) {
                    updateClonedLeavesUnionEnumRef((YangLeavesHolder) clonedTreeCurNode);
                }
                clonedTreeCurNode = clonedTreeCurNode.getParent();
            }
            if (curTraversal != PARENT && nextNodeToClone.getChild() != null) {
                curTraversal = CHILD;
                /*
                     * update the traversal's current node.
                     */
                nextNodeToClone = nextNodeToClone.getChild();
            } else if (nextNodeToClone.getNextSibling() != null) {
                curTraversal = SIBILING;
                nextNodeToClone = nextNodeToClone.getNextSibling();
            } else {
                curTraversal = PARENT;
                nextNodeToClone = nextNodeToClone.getParent();
            }
        }
    } catch (CloneNotSupportedException e) {
        throw new DataModelException("Failed to clone the tree");
    }
}
#method_after
public static void cloneSubTree(YangNode srcRootNode, YangNode dstRootNode, YangUses yangUses) throws DataModelException {
    YangNode nextNodeToClone = srcRootNode;
    TraversalType curTraversal;
    YangNode clonedTreeCurNode = dstRootNode;
    YangNode newNode = null;
    nextNodeToClone = nextNodeToClone.getChild();
    if (nextNodeToClone == null) {
        return;
    } else {
        /*
             * Root level cloning is taken care in the caller.
             */
        curTraversal = CHILD;
    }
    /*
         * Caller ensures the cloning of the root nodes
         */
    try {
        while (nextNodeToClone != srcRootNode) {
            if (nextNodeToClone == null) {
                throw new DataModelException("Internal error: Cloning " + "failed, source tree " + "null pointer reached");
            }
            if (curTraversal != PARENT) {
                newNode = nextNodeToClone.clone(yangUses);
                detectCollisionWhileCloning(clonedTreeCurNode, newNode, curTraversal);
            }
            if (curTraversal == CHILD) {
                /*
                     * add the new node to the cloned tree.
                     */
                clonedTreeCurNode.addChild(newNode);
                /*
                     * update the cloned tree's traversal current node as the
                     * new node.
                     */
                clonedTreeCurNode = newNode;
            } else if (curTraversal == SIBILING) {
                clonedTreeCurNode.addNextSibling(newNode);
                clonedTreeCurNode = newNode;
            } else {
                if (clonedTreeCurNode instanceof YangLeavesHolder) {
                    updateClonedLeavesUnionEnumRef((YangLeavesHolder) clonedTreeCurNode);
                }
                clonedTreeCurNode = clonedTreeCurNode.getParent();
            }
            if (curTraversal != PARENT && nextNodeToClone.getChild() != null) {
                curTraversal = CHILD;
                /*
                     * update the traversal's current node.
                     */
                nextNodeToClone = nextNodeToClone.getChild();
            } else if (nextNodeToClone.getNextSibling() != null) {
                curTraversal = SIBILING;
                nextNodeToClone = nextNodeToClone.getNextSibling();
            } else {
                curTraversal = PARENT;
                nextNodeToClone = nextNodeToClone.getParent();
            }
        }
    } catch (CloneNotSupportedException e) {
        throw new DataModelException("Failed to clone the tree");
    }
}
#end_block

#method_before
private static void detectCollisionWhileCloning(YangNode currentNode, YangNode newNode, TraversalType addAs) throws DataModelException {
    if (!(currentNode instanceof CollisionDetector) || !(newNode instanceof Parsable)) {
        throw new DataModelException("Node in data model tree does not support collision detection");
    }
    CollisionDetector collisionDetector = (CollisionDetector) currentNode;
    Parsable parsable = (Parsable) newNode;
    if (addAs == TraversalType.CHILD) {
        collisionDetector.detectCollidingChild(newNode.getName(), parsable.getYangConstructType());
    } else if (addAs == TraversalType.SIBILING) {
        currentNode = currentNode.getParent();
        if (!(currentNode instanceof CollisionDetector)) {
            throw new DataModelException("Node in data model tree does not support collision detection");
        }
        collisionDetector = (CollisionDetector) currentNode;
        collisionDetector.detectCollidingChild(newNode.getName(), parsable.getYangConstructType());
    } else {
        throw new DataModelException("Errored tree cloning");
    }
}
#method_after
private static void detectCollisionWhileCloning(YangNode currentNode, YangNode newNode, TraversalType addAs) throws DataModelException {
    if (!(currentNode instanceof CollisionDetector) || !(newNode instanceof Parsable)) {
        throw new DataModelException("Node in data model tree does not " + "support collision detection");
    }
    CollisionDetector collisionDetector = (CollisionDetector) currentNode;
    Parsable parsable = (Parsable) newNode;
    if (addAs == TraversalType.CHILD) {
        collisionDetector.detectCollidingChild(newNode.getName(), parsable.getYangConstructType());
    } else if (addAs == TraversalType.SIBILING) {
        currentNode = currentNode.getParent();
        if (!(currentNode instanceof CollisionDetector)) {
            throw new DataModelException("Node in data model tree does " + "not support collision " + "detection");
        }
        collisionDetector = (CollisionDetector) currentNode;
        collisionDetector.detectCollidingChild(newNode.getName(), parsable.getYangConstructType());
    } else {
        throw new DataModelException("Errored tree cloning");
    }
}
#end_block

#method_before
private void addNextSibling(YangNode newSibling) throws DataModelException {
    if (newSibling.getNodeType() == null) {
        throw new DataModelException("Cloned abstract node cannot be inserted into a tree");
    }
    if (newSibling.getParent() == null) {
        /**
         * Since the siblings needs to have a common parent, set the parent
         * as the current node's parent
         */
        newSibling.setParent(getParent());
    } else {
        throw new DataModelException("Node is already part of a tree, and cannot be added as a sibling");
    }
    if (newSibling.getPreviousSibling() == null) {
        newSibling.setPreviousSibling(this);
        setNextSibling(newSibling);
    } else {
        throw new DataModelException("New sibling to be added is not atomic, it already has a previous sibling");
    }
    if (newSibling.getChild() != null) {
        throw new DataModelException("Sibling to be added is not atomic, it already has a child");
    }
    if (newSibling.getNextSibling() != null) {
        throw new DataModelException("Sibling to be added is not atomic, it already has a next sibling");
    }
}
#method_after
private void addNextSibling(YangNode newSibling) throws DataModelException {
    if (newSibling.getNodeType() == null) {
        throw new DataModelException("Cloned abstract node cannot be " + "inserted into a tree");
    }
    if (newSibling.getParent() == null) {
        /**
         * Since the siblings needs to have a common parent, set the parent
         * as the current node's parent
         */
        newSibling.setParent(getParent());
    } else {
        throw new DataModelException("Node is already part of a tree, " + "and cannot be added as a " + "sibling");
    }
    if (newSibling.getPreviousSibling() == null) {
        newSibling.setPreviousSibling(this);
        setNextSibling(newSibling);
    } else {
        throw new DataModelException("New sibling to be added is not " + "atomic, it already has a " + "previous sibling");
    }
    if (newSibling.getChild() != null) {
        throw new DataModelException("Sibling to be added is not atomic, " + "it already has a child");
    }
    if (newSibling.getNextSibling() != null) {
        throw new DataModelException("Sibling to be added is not atomic, " + "it already has a next sibling");
    }
}
#end_block

#method_before
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#method_after
@Override
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#end_block

#method_before
@Override
public YangSchemaNode getNotificationSchemaNode(String notificationNameInEnum) throws DataModelException {
    throw new DataModelException("Method called for schema node other then module/sub-module");
}
#method_after
@Override
public YangSchemaNode getNotificationSchemaNode(String notificationNameInEnum) throws DataModelException {
    throw new DataModelException("Method called for schema node other " + "then module/sub-module");
}
#end_block

#method_before
@Override
public YangSchemaNode getNotificationSchemaNode(String notificationNameInEnum) throws DataModelException {
    throw new DataModelException("Method called for schema node other then module/sub-module");
}
#method_after
@Override
public YangSchemaNode getNotificationSchemaNode(String notificationNameInEnum) throws DataModelException {
    throw new DataModelException("Method called for schema node other " + "then module/sub-module");
}
#end_block

#method_before
public Map<String, YangSchemaNode> getNotificationEnumMap() {
    return notificationEnumMap;
}
#method_after
private Map<String, YangSchemaNode> getNotificationEnumMap() {
    return notificationEnumMap;
}
#end_block

#method_before
@Override
public void setNotificationPresenceFlag(boolean notificationPresent) {
    isNotificationPresent = notificationPresent;
}
#method_after
@Override
public void setNotificationPresenceFlag(boolean notificationPresent) {
    this.isNotificationPresent = notificationPresent;
}
#end_block

#method_before
public Map<String, YangSchemaNode> getNotificationEnumMap() {
    return notificationEnumMap;
}
#method_after
private Map<String, YangSchemaNode> getNotificationEnumMap() {
    return notificationEnumMap;
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    // TODO: throw exception
    return null;
}
#method_after
@Override
public String getJavaAttributeName() {
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
static String processSubtreeFilteringInterface(String name) {
    String method = "    /**\n" + "     * Checks if the passed " + name + " maps the content match query condition.\n" + "     *\n" + "     * @param " + getSmallCase(name) + SPACE + getSmallCase(name) + SPACE + "being passed to check" + " for" + " content match\n" + "     * @return match result\n" + "     */\n";
    return method + FOUR_SPACE_INDENTATION + name + SPACE + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + name + SPACE + getSmallCase(name) + COMMA + SPACE + BOOLEAN_DATA_TYPE + SPACE + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String processSubtreeFilteringInterface(String name) {
    String method = "    /**\n" + "     * Checks if the passed " + name + " maps the content match query condition.\n" + "     *\n" + "     * @param " + getSmallCase(name) + SPACE + getSmallCase(name) + SPACE + "being passed to check" + " for" + " content match\n" + "     * @param isSelectAllSchemaChild is select all schema child\n" + "     * @return match result\n" + "     */\n";
    return method + FOUR_SPACE_INDENTATION + name + SPACE + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + name + SPACE + getSmallCase(name) + COMMA + SPACE + BOOLEAN_DATA_TYPE + SPACE + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#end_block

#method_before
static String setSelectLeafSetInterface(String name) {
    String method = "    /**\n" + "     * Set a leaf to be selected.\n" + "     *\n" + "     * @param leaf leaf needs to be selected\n" + "     */\n";
    return method + FOUR_SPACE_INDENTATION + name + BUILDER + SPACE + SET_SELECT_LEAF + OPEN_PARENTHESIS + LEAF_IDENTIFIER + SPACE + "leaf" + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String setSelectLeafSetInterface(String name) {
    String method = "    /**\n" + "     * Set a leaf to be selected.\n" + "     *\n" + "     * @param leaf leaf needs to be selected\n" + "     * @return builder object for select leaf\n" + "     */\n";
    return method + FOUR_SPACE_INDENTATION + name + BUILDER + SPACE + SET_SELECT_LEAF + OPEN_PARENTHESIS + LEAF_IDENTIFIER + SPACE + "leaf" + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#end_block

#method_before
static String getSetterForOperationType(String name) {
    return "    /**\n" + "     * Set node operation type.\n" + "     *\n" + "     * @param operationType node operation type\n" + "     */\n" + "    public " + name + BUILDER + " onosYangNodeOperationType(OnosYangNodeOperationType " + "onosYangNodeOperationType) {\n" + "       this.onosYangNodeOperationType = onosYangNodeOperationType;\n" + "       return this;\n" + "    }\n\n";
}
#method_after
static String getSetterForOperationType(String name) {
    return "    /**\n" + "     * Set node operation type.\n" + "     *\n" + "     * @param onosYangNodeOperationType node operation type\n" + "     * @return builder object for node operation type\n" + "     */\n" + "    public " + name + BUILDER + " onosYangNodeOperationType(OnosYangNodeOperationType " + "onosYangNodeOperationType) {\n" + "       this.onosYangNodeOperationType = onosYangNodeOperationType;\n" + "       return this;\n" + "    }\n\n";
}
#end_block

#method_before
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#method_after
@Override
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    return getJavaFileInfo().getJavaAttributeName();
}
#method_after
@Override
public String getJavaAttributeName() {
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (isLeavesPresent) {
                insertDataIntoJavaFile(file, NEW_LINE + getInterfaceLeafIdEnumSignature(className) + NEW_LINE + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path), COMMA, SEMI_COLAN), NEW_LINE) + NEW_LINE + NEW_LINE + getInterfaceLeafIdEnumMethods());
            }
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, javaFileInfo.getPluginConfig());
        methods.add(NEW_LINE + processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(NEW_LINE + processSubtreeFilteringInterface(className));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + isLeafValueSetInterface());
        methods.add(NEW_LINE + isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (isLeavesPresent) {
                insertDataIntoJavaFile(file, NEW_LINE + getInterfaceLeafIdEnumSignature(className) + NEW_LINE + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path), COMMA, SEMI_COLAN), NEW_LINE) + NEW_LINE + NEW_LINE + getInterfaceLeafIdEnumMethods());
            }
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, javaFileInfo.getPluginConfig());
        methods.add(NEW_LINE + processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(NEW_LINE + processSubtreeFilteringInterface(className));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + isLeafValueSetInterface());
        methods.add(NEW_LINE + isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            // Getter methods.
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list method.
            methods.add(NEW_LINE);
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ADD_TO_LIST_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getAddAugmentInfoMethodInterface());
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + setSelectLeafSetInterface(className));
    }
    // Add build method to builder interface file.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    // Add getters and setters in builder interface.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            // Getter methods.
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list method.
            methods.add(NEW_LINE);
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ADD_TO_LIST_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getAddAugmentInfoMethodInterface());
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + setSelectLeafSetInterface(className));
    }
    // Add build method to builder interface file.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    // Add getters and setters in builder interface.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
/**
 * Returns generated builder class file for current node.
 *
 * @param file          file
 * @param curNode       current YANG node
 * @param isAttrPresent if any attribute is present or not
 * @return builder class file
 * @throws IOException when fails to write in file
 */
public static File generateBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isRootNode = false;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, JavaCodeSnippetGen.addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            methods.add(getGetterForOperationType());
            methods.add(getSetterForOperationType(className));
            // Add operation attribute methods.
            if (isLeavesPresent) {
                methods.add(getOperationAttributesGetters() + NEW_LINE);
                methods.add(getSetterForSelectLeaf(className, isRootNode));
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl(curNode));
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER, pluginConfig, curNode));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#method_after
/**
 * Returns generated builder class file for current node.
 *
 * @param file          file
 * @param curNode       current YANG node
 * @param isAttrPresent if any attribute is present or not
 * @return builder class file
 * @throws IOException when fails to write in file
 */
public static File generateBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isRootNode = false;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder class file generation");
        }
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            methods.add(getGetterForOperationType());
            methods.add(getSetterForOperationType(className));
            // Add operation attribute methods.
            if (isLeavesPresent) {
                methods.add(getOperationAttributesGetters() + NEW_LINE);
                methods.add(getSetterForSelectLeaf(className, isRootNode));
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl(curNode));
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER, pluginConfig, curNode));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#end_block

#method_before
public static File generateDefaultClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    boolean isRootNode = false;
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        opParamClassName = className + OP_PARAM;
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, JavaCodeSnippetGen.addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        // Add operation attributes
        insertDataIntoJavaFile(file, getOperationTypeEnum());
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            methods.add(getGetterForOperationType());
            // Hash code method.
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            // Equals method.
            if (isRootNode) {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(opParamClassName) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            } else {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            }
            // To string method.
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, pluginConfig, isRootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        if (isAttrPresent) {
            constructor = constructor + getOperationTypeForConstructor();
        }
        if (isLeavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        // add is filter content match.
        String augmentableSubTreeFiltering = "";
        if (curNode instanceof YangAugmentableNode) {
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(getProcessSubtreeFilteringStart(curNode, pluginConfig) + getProcessSubtreeFunctionBody() + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd() + getProcessLeafSubtreeFiltering(curNode, pluginConfig, path) + getProcessLeafListSubtreeFiltering(curNode, pluginConfig, path) + getProcessChildNodeSubtreeFiltering(curNode, pluginConfig, path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PROTECTED, DEFAULT, pluginConfig, curNode));
    methods.add(builderMethod(className) + NEW_LINE);
    if (isLeavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateDefaultClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    boolean isRootNode = false;
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        opParamClassName = className + OP_PARAM;
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while impl class file generation");
        }
        // Add operation attributes
        insertDataIntoJavaFile(file, getOperationTypeEnum());
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            methods.add(getGetterForOperationType());
            // Hash code method.
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            // Equals method.
            if (isRootNode) {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(opParamClassName) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            } else {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            }
            // To string method.
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, pluginConfig, isRootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        if (isAttrPresent) {
            constructor = constructor + getOperationTypeForConstructor();
        }
        if (isLeavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        // add is filter content match.
        String augmentableSubTreeFiltering = "";
        if (curNode instanceof YangAugmentableNode) {
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(getProcessSubtreeFilteringStart(curNode, pluginConfig) + getProcessSubtreeFunctionBody(curNode) + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd());
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
                methods.add(getProcessLeafSubtreeFiltering(curNode, pluginConfig, path));
            }
        }
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
                methods.add(getProcessLeafListSubtreeFiltering(curNode, pluginConfig, path));
            }
        }
        if (curNode.getChild() != null) {
            methods.add(getProcessChildNodeSubtreeFiltering(curNode, pluginConfig, path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PROTECTED, DEFAULT, pluginConfig, curNode));
    methods.add(builderMethod(className) + NEW_LINE);
    if (isLeavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    if (type.getDataType().equals(BINARY)) {
        imports.add(IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_IMPORT_BASE64_CLASS);
    }
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        if (type.getDataType().equals(BINARY)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(BITS)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if ((type.getDataType().equals(YangDataTypes.DERIVED)) && (((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType().equals(YangDataTypes.IDENTITYREF))) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (type.getDataType().equals(YangDataTypes.IDENTITYREF)) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (!yangDataTypes.equals(YangDataTypes.IDENTITYREF)) {
            methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    if (type.getDataType().equals(BINARY)) {
        imports.add(IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_IMPORT_BASE64_CLASS);
    }
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        if (type.getDataType().equals(BINARY)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(BITS)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if ((type.getDataType().equals(YangDataTypes.DERIVED)) && (((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType().equals(YangDataTypes.IDENTITYREF))) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (type.getDataType().equals(YangDataTypes.IDENTITYREF)) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (!yangDataTypes.equals(YangDataTypes.IDENTITYREF)) {
            methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    TempJavaTypeFragmentFiles tempJavaTypeFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles();
    boolean isIntConflict = false;
    boolean isLongConflict = false;
    boolean isShortConflict = false;
    JavaAttributeInfo intAttr = tempJavaTypeFragmentFiles.getIntAttribute();
    if (intAttr == null) {
        intAttr = tempJavaTypeFragmentFiles.getUIntAttribute();
    }
    JavaAttributeInfo longAttr = tempJavaTypeFragmentFiles.getLongAttribute();
    if (longAttr == null) {
        longAttr = tempJavaTypeFragmentFiles.getULongAttribute();
    }
    JavaAttributeInfo shortAttr = tempJavaTypeFragmentFiles.getShortAttribute();
    if (shortAttr == null) {
        shortAttr = tempJavaTypeFragmentFiles.getUInt8Attribute();
    }
    if (intAttr != null) {
        isIntConflict = intAttr.isIntConflict();
    }
    if (longAttr != null) {
        isLongConflict = longAttr.isLongConflict();
    }
    if (shortAttr != null) {
        isShortConflict = shortAttr.isShortConflict();
    }
    if (isLongConflict) {
        imports.add(tempJavaTypeFragmentFiles.getJavaImportData().getBigIntegerImport());
        sort(imports);
    }
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        if (isIntConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeIntRange(PRIVATE, tempJavaTypeFragmentFiles.getIntIndex() < tempJavaTypeFragmentFiles.getUIntIndex()));
        }
        if (isLongConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeLongRange(PRIVATE, tempJavaTypeFragmentFiles.getLongIndex() < tempJavaTypeFragmentFiles.getULongIndex()));
        }
        if (isShortConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeShortRange(PRIVATE, tempJavaTypeFragmentFiles.getShortIndex() < tempJavaTypeFragmentFiles.getUInt8Index()));
        }
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of string method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        // From string method.
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        if (isIntConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
        if (isLongConflict) {
            methods.add(getRangeValidatorMethodForUnion(BIG_INTEGER));
        }
        if (isShortConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    TempJavaTypeFragmentFiles tempJavaTypeFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles();
    boolean isIntConflict = false;
    boolean isLongConflict = false;
    boolean isShortConflict = false;
    JavaAttributeInfo intAttr = tempJavaTypeFragmentFiles.getIntAttribute();
    if (intAttr == null) {
        intAttr = tempJavaTypeFragmentFiles.getUIntAttribute();
    }
    JavaAttributeInfo longAttr = tempJavaTypeFragmentFiles.getLongAttribute();
    if (longAttr == null) {
        longAttr = tempJavaTypeFragmentFiles.getULongAttribute();
    }
    JavaAttributeInfo shortAttr = tempJavaTypeFragmentFiles.getShortAttribute();
    if (shortAttr == null) {
        shortAttr = tempJavaTypeFragmentFiles.getUInt8Attribute();
    }
    if (intAttr != null) {
        isIntConflict = intAttr.isIntConflict();
    }
    if (longAttr != null) {
        isLongConflict = longAttr.isLongConflict();
    }
    if (shortAttr != null) {
        isShortConflict = shortAttr.isShortConflict();
    }
    if (isLongConflict) {
        imports.add(tempJavaTypeFragmentFiles.getJavaImportData().getBigIntegerImport());
        sort(imports);
    }
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        if (isIntConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeIntRange(PRIVATE, tempJavaTypeFragmentFiles.getIntIndex() < tempJavaTypeFragmentFiles.getUIntIndex()));
        }
        if (isLongConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeLongRange(PRIVATE, tempJavaTypeFragmentFiles.getLongIndex() < tempJavaTypeFragmentFiles.getULongIndex()));
        }
        if (isShortConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeShortRange(PRIVATE, tempJavaTypeFragmentFiles.getShortIndex() < tempJavaTypeFragmentFiles.getUInt8Index()));
        }
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of string method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        // From string method.
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        if (isIntConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
        if (isLongConflict) {
            methods.add(getRangeValidatorMethodForUnion(BIG_INTEGER));
        }
        if (isShortConflict && !isIntConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    // Add attribute strings.
    try {
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    // Add an attribute to get the enum's values.
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    // Add a constructor for enum.
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig, null) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    TempJavaEnumerationFragmentFiles enumFragFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles();
    insertDataIntoJavaFile(file, getEnumsOfMethod(className, enumFragFiles.getJavaAttributeForEnum(pluginConfig), enumFragFiles.getEnumSetJavaMap(), enumFragFiles.getEnumStringList(), pluginConfig) + NEW_LINE);
    // Add a getter method for enum.
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig, null) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    // Add attribute strings.
    try {
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class " + "file generation");
    }
    // Add an attribute to get the enum's values.
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    // Add a constructor for enum.
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig, null) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    TempJavaEnumerationFragmentFiles enumFragFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles();
    insertDataIntoJavaFile(file, getEnumsOfMethod(className, enumFragFiles.getJavaAttributeForEnum(pluginConfig), enumFragFiles.getEnumSetJavaMap(), enumFragFiles.getEnumStringList(), pluginConfig) + NEW_LINE);
    // Add a getter method for enum.
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig, null) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        // Getter methods.
        methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        // Setter methods.
        methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    return getJavaFileInfo().getJavaAttributeName();
}
#method_after
@Override
public String getJavaAttributeName() {
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#method_after
@Override
public String getName() {
    return yangSchemaNodeIdentifier.getName();
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    return getJavaFileInfo().getJavaAttributeName();
}
#method_after
@Override
public String getJavaAttributeName() {
    YangNode parent = getParent();
    if (parent instanceof YangJavaChoice) {
        return ((YangJavaChoice) parent).getJavaFileInfo().getJavaAttributeName();
    }
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    return getJavaFileInfo().getJavaAttributeName();
}
#method_after
@Override
public String getJavaAttributeName() {
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    return getJavaFileInfo().getJavaAttributeName();
}
#method_after
@Override
public String getJavaAttributeName() {
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    return null;
}
#method_after
@Override
public String getJavaAttributeName() {
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    return null;
}
#method_after
@Override
public String getJavaAttributeName() {
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
@Override
public String getJavaAttributeName() {
    return null;
}
#method_after
@Override
public String getJavaAttributeName() {
    throw new RuntimeException("Attribute name is not applicable ");
}
#end_block

#method_before
@Override
public FlowRule.Builder withHardTimeout(int timeout) {
    this.hardTimeout = timeout;
    return this;
}
#method_after
@Override
public FlowRule.Builder withHardTimeout(int timeout) {
    this.permanent = false;
    this.hardTimeout = timeout;
    this.timeout = timeout;
    return this;
}
#end_block

#method_before
@Override
public FlowRule build() {
    FlowId localFlowId;
    checkArgument((flowId != null) ^ (appId != null), "Either an application" + " id or a cookie must be supplied");
    checkNotNull(selector, "Traffic selector cannot be null");
    checkArgument(timeout != null || permanent != null, "Must either have " + "a timeout or be permanent");
    checkNotNull(deviceId, "Must refer to a device");
    checkNotNull(priority, "Priority cannot be null");
    checkArgument(priority >= MIN_PRIORITY, "Priority cannot be less than " + MIN_PRIORITY);
    checkArgument(priority <= MAX_PRIORITY, "Priority cannot be greater than " + MAX_PRIORITY);
    // the flow ID directly
    if (appId != null) {
        localFlowId = computeFlowId(appId);
    } else {
        localFlowId = flowId;
    }
    return new DefaultFlowRule(deviceId, selector, treatment, priority, localFlowId, permanent, timeout, hardTimeout, tableId);
}
#method_after
@Override
public FlowRule build() {
    FlowId localFlowId;
    checkArgument((flowId != null) ^ (appId != null), "Either an application" + " id or a cookie must be supplied");
    checkNotNull(selector, "Traffic selector cannot be null");
    checkArgument(timeout != null || permanent != null, "Must either have " + "a timeout or be permanent");
    checkNotNull(deviceId, "Must refer to a device");
    checkNotNull(priority, "Priority cannot be null");
    checkArgument(priority >= MIN_PRIORITY, "Priority cannot be less than " + MIN_PRIORITY);
    checkArgument(priority <= MAX_PRIORITY, "Priority cannot be greater than " + MAX_PRIORITY);
    // the flow ID directly
    if (appId != null) {
        localFlowId = computeFlowId(appId);
    } else {
        localFlowId = flowId;
    }
    return new DefaultFlowRule(deviceId, selector, treatment, priority, localFlowId, permanent, timeout, hardTimeout, reason, tableId);
}
#end_block

#method_before
private int hash() {
    Funnel<TrafficSelector> selectorFunnel = (from, into) -> from.criteria().stream().forEach(c -> into.putString(c.toString(), Charsets.UTF_8));
    HashFunction hashFunction = Hashing.murmur3_32();
    HashCode hashCode = hashFunction.newHasher().putString(deviceId.toString(), Charsets.UTF_8).putObject(selector, selectorFunnel).putInt(priority).putInt(tableId).hash();
    return hashCode.asInt();
}
#method_after
private int hash() {
    Funnel<TrafficSelector> selectorFunnel = (from, into) -> from.criteria().forEach(c -> into.putString(c.toString(), Charsets.UTF_8));
    HashFunction hashFunction = Hashing.murmur3_32();
    HashCode hashCode = hashFunction.newHasher().putString(deviceId.toString(), Charsets.UTF_8).putObject(selector, selectorFunnel).putInt(priority).putInt(tableId).hash();
    return hashCode.asInt();
}
#end_block

#method_before
@Override
public List<ResourceAllocation> allocate(ResourceConsumer consumer, List<Resource> resources) {
    return null;
}
#method_after
@Override
public List<ResourceAllocation> allocate(ResourceConsumer consumer, List<? extends Resource> resources) {
    return null;
}
#end_block

#method_before
@Override
public long life() {
    return baseValue + 11;
}
#method_after
@Override
public long life() {
    return life(SECONDS);
}
#end_block

#method_before
@Override
public long life() {
    return baseValue + 11;
}
#method_after
@Override
public long life(TimeUnit timeUnit) {
    return SECONDS.convert(baseValue + 11, timeUnit);
}
#end_block

#method_before
@Before
public void setup() {
    RequestBuilder builder1 = new DefaultRequestBuilder();
    LispIpv4Address ipv4Eid1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    LispIpv4Address ipv4Rloc1 = new LispIpv4Address(IpAddress.valueOf("10.1.1.1"));
    LispIpv4Address ipv4Rloc2 = new LispIpv4Address(IpAddress.valueOf("10.1.1.2"));
    List<LispAfiAddress> rlocs1 = ImmutableList.of(ipv4Rloc1, ipv4Rloc2);
    List<LispEidRecord> records1 = ImmutableList.of(getEidRecord(), getEidRecord());
    request1 = builder1.withIsAuthoritative(true).withIsMapDataPresent(true).withIsPitr(false).withIsProbe(false).withIsSmr(true).withIsSmrInvoked(false).withSourceEid(ipv4Eid1).withItrRlocs(rlocs1).withEidRecords(records1).withNonce(1L).build();
    RequestBuilder builder2 = new DefaultRequestBuilder();
    List<LispEidRecord> records2 = ImmutableList.of(getEidRecord(), getEidRecord());
    sameAsRequest1 = builder2.withIsAuthoritative(true).withIsMapDataPresent(true).withIsPitr(false).withIsProbe(false).withIsSmr(true).withIsSmrInvoked(false).withSourceEid(ipv4Eid1).withItrRlocs(rlocs1).withEidRecords(records2).withNonce(1L).build();
    RequestBuilder builder3 = new DefaultRequestBuilder();
    LispIpv4Address ipv4Eid2 = new LispIpv4Address(IpAddress.valueOf("192.168.1.2"));
    LispIpv4Address ipv4Rloc3 = new LispIpv4Address(IpAddress.valueOf("10.1.1.1"));
    LispIpv4Address ipv4Rloc4 = new LispIpv4Address(IpAddress.valueOf("10.1.1.2"));
    List<LispAfiAddress> rlocs2 = ImmutableList.of(ipv4Rloc3, ipv4Rloc4);
    request2 = builder3.withIsAuthoritative(false).withIsMapDataPresent(false).withIsPitr(true).withIsProbe(true).withIsSmr(false).withIsSmrInvoked(true).withSourceEid(ipv4Eid2).withItrRlocs(rlocs2).withNonce(2L).build();
}
#method_after
@Before
public void setup() {
    RequestBuilder builder1 = new DefaultRequestBuilder();
    LispIpv4Address ipv4Eid1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    LispIpv4Address ipv4Rloc1 = new LispIpv4Address(IpAddress.valueOf("10.1.1.1"));
    LispIpv4Address ipv4Rloc2 = new LispIpv4Address(IpAddress.valueOf("10.1.1.2"));
    List<LispAfiAddress> rlocs1 = ImmutableList.of(ipv4Rloc1, ipv4Rloc2);
    List<LispEidRecord> records1 = ImmutableList.of(getEidRecord(), getEidRecord());
    request1 = builder1.withIsAuthoritative(true).withIsMapDataPresent(true).withIsPitr(false).withIsProbe(false).withIsSmr(true).withIsSmrInvoked(false).withSourceEid(ipv4Eid1).withItrRlocs(rlocs1).withEidRecords(records1).withNonce(1L).build();
    RequestBuilder builder2 = new DefaultRequestBuilder();
    List<LispEidRecord> records2 = ImmutableList.of(getEidRecord(), getEidRecord());
    sameAsRequest1 = builder2.withIsAuthoritative(true).withIsMapDataPresent(true).withIsPitr(false).withIsProbe(false).withIsSmr(true).withIsSmrInvoked(false).withSourceEid(ipv4Eid1).withItrRlocs(rlocs1).withEidRecords(records2).withNonce(1L).build();
    RequestBuilder builder3 = new DefaultRequestBuilder();
    LispIpv4Address ipv4Eid2 = new LispIpv4Address(IpAddress.valueOf("192.168.1.2"));
    LispIpv4Address ipv4Rloc3 = new LispIpv4Address(IpAddress.valueOf("20.1.1.1"));
    LispIpv4Address ipv4Rloc4 = new LispIpv4Address(IpAddress.valueOf("20.1.1.2"));
    List<LispAfiAddress> rlocs2 = ImmutableList.of(ipv4Rloc3, ipv4Rloc4);
    request2 = builder3.withIsAuthoritative(false).withIsMapDataPresent(false).withIsPitr(true).withIsProbe(true).withIsSmr(false).withIsSmrInvoked(true).withSourceEid(ipv4Eid2).withItrRlocs(rlocs2).withNonce(2L).build();
}
#end_block

#method_before
private boolean checkAddressValidity(List<LispAfiAddress> addresses) {
    if (addresses == null || addresses.size() != 2) {
        return false;
    }
    LispAfiAddress ipv4 = addresses.get(0);
    LispAfiAddress ipv6 = addresses.get(1);
    if (ipv4.getAfi() != AddressFamilyIdentifierEnum.IP) {
        return false;
    }
    if (ipv6.getAfi() != AddressFamilyIdentifierEnum.IP6) {
        return false;
    }
    return true;
}
#method_after
private boolean checkAddressValidity(List<LispAfiAddress> addresses) {
    if (addresses == null || addresses.size() != 2) {
        return false;
    }
    LispAfiAddress ipv4 = addresses.get(0);
    LispAfiAddress ipv6 = addresses.get(1);
    if (ipv4.getAfi() != AddressFamilyIdentifierEnum.IP4) {
        return false;
    }
    if (ipv6.getAfi() != AddressFamilyIdentifierEnum.IP6) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testInstallLoadBalancedFlowRules() {
    ApplicationId appId = new DefaultApplicationId(1, "test");
    SfcFlowRuleInstallerImpl flowRuleInstaller = new SfcFlowRuleInstallerImpl();
    flowRuleInstaller.virtualPortService = virtualPortService;
    flowRuleInstaller.vtnRscService = vtnRscService;
    flowRuleInstaller.portPairService = portPairService;
    flowRuleInstaller.portPairGroupService = portPairGroupService;
    flowRuleInstaller.flowClassifierService = flowClassifierService;
    flowRuleInstaller.driverService = driverService;
    flowRuleInstaller.deviceService = deviceService;
    flowRuleInstaller.hostService = hostService;
    flowRuleInstaller.flowObjectiveService = flowObjectiveService;
    flowRuleInstaller.tenantNetworkService = tenantNetworkService;
    flowRuleInstaller.appId = appId;
    final PortChain portChain = createPortChain();
    final String ppName1 = "PortPair1";
    final String ppDescription1 = "PortPair1";
    final String ingress1 = "d3333333-24fc-4fae-af4b-321c5e2eb3d1";
    final String egress1 = "a4444444-4a56-2a6e-cd3a-9dee4e2ec345";
    DefaultPortPair.Builder portPairBuilder = new DefaultPortPair.Builder();
    PortPair portPair1 = portPairBuilder.setId(portPairId1).setName(ppName1).setTenantId(tenantId).setDescription(ppDescription1).setIngress(ingress1).setEgress(egress1).build();
    final String ppName2 = "PortPair2";
    final String ppDescription2 = "PortPair2";
    final String ingress2 = "d5555555-24fc-4fae-af4b-321c5e2eb3d1";
    final String egress2 = "a6666666-4a56-2a6e-cd3a-9dee4e2ec345";
    PortPair portPair2 = portPairBuilder.setId(portPairId2).setName(ppName2).setTenantId(tenantId).setDescription(ppDescription2).setIngress(ingress2).setEgress(egress2).build();
    portPairService.createPortPair(portPair1);
    portPairService.createPortPair(portPair2);
    FlowClassifier fc1 = createFlowClassifier(flowClassifierId1);
    FlowClassifier fc2 = createFlowClassifier(flowClassifierId2);
    flowClassifierService.createFlowClassifier(fc1);
    flowClassifierService.createFlowClassifier(fc2);
    NshServicePathId nshSpiId = NshServicePathId.of(10);
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(IpAddress.valueOf("3.3.3.3")).setIpDst(IpAddress.valueOf("4.4.4.4")).setPortSrc(PortNumber.portNumber(1500)).setPortDst(PortNumber.portNumber(2000)).setProtocol(IPv4.PROTOCOL_UDP).setTenantId(TenantId.tenantId("bbb")).build();
    LoadBalanceId id = LoadBalanceId.of((byte) 1);
    List<PortPairId> path = Lists.newArrayList();
    path.add(portPairId1);
    path.add(portPairId2);
    List<VirtualPort> virtualPortList = Lists.newArrayList();
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(ingress1)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(egress1)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(ingress2)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(egress2)));
    virtualPortService.createPorts(virtualPortList);
    portChain.addLoadBalancePath(fiveTuple, id, path);
    String physicalNetworkStr = "1234";
    String segmentationIdStr = "1";
    SegmentationId segmentationID = SegmentationId.segmentationId(segmentationIdStr);
    TenantNetworkId networkid1 = TenantNetworkId.networkId(networkIdStr);
    PhysicalNetwork physicalNetwork = PhysicalNetwork.physicalNetwork(physicalNetworkStr);
    TenantNetwork p1 = new DefaultTenantNetwork(networkid1, name, false, TenantNetwork.State.ACTIVE, false, tenantId, false, TenantNetwork.Type.LOCAL, physicalNetwork, segmentationID);
    tenantNetworkService.createNetworks(Collections.singletonList(p1));
    expect(driverService.createHandler(deviceId)).andReturn(driverHandler).anyTimes();
    replay(driverService);
    flowRuleInstaller.installLoadBalancedFlowRules(portChain, fiveTuple, nshSpiId);
    ForwardingObjective forObj = ((FlowObjectiveAdapter) flowObjectiveService).forwardingObjective();
    // Check for Selector
    assertThat(forObj.selector().getCriterion(Criterion.Type.IN_PORT), instanceOf(PortCriterion.class));
    // Check for treatment
    List<Instruction> instructions = forObj.treatment().allInstructions();
    for (Instruction instruction : instructions) {
        if (instruction.type() == Instruction.Type.OUTPUT) {
            assertThat(((OutputInstruction) instruction).port(), is(PortNumber.P0));
        }
    }
}
#method_after
@Test
public void testInstallLoadBalancedFlowRules() {
    ApplicationId appId = new DefaultApplicationId(1, "test");
    SfcFlowRuleInstallerImpl flowRuleInstaller = new SfcFlowRuleInstallerImpl();
    flowRuleInstaller.virtualPortService = virtualPortService;
    flowRuleInstaller.vtnRscService = vtnRscService;
    flowRuleInstaller.portPairService = portPairService;
    flowRuleInstaller.portPairGroupService = portPairGroupService;
    flowRuleInstaller.flowClassifierService = flowClassifierService;
    flowRuleInstaller.driverService = driverService;
    flowRuleInstaller.deviceService = deviceService;
    flowRuleInstaller.hostService = hostService;
    flowRuleInstaller.flowObjectiveService = flowObjectiveService;
    flowRuleInstaller.tenantNetworkService = tenantNetworkService;
    flowRuleInstaller.appId = appId;
    final PortChain portChain = createPortChain();
    final String ppName1 = "PortPair1";
    final String ppDescription1 = "PortPair1";
    final String ingress1 = "d3333333-24fc-4fae-af4b-321c5e2eb3d1";
    final String egress1 = "a4444444-4a56-2a6e-cd3a-9dee4e2ec345";
    DefaultPortPair.Builder portPairBuilder = new DefaultPortPair.Builder();
    PortPair portPair1 = portPairBuilder.setId(portPairId1).setName(ppName1).setTenantId(tenantId).setDescription(ppDescription1).setIngress(ingress1).setEgress(egress1).build();
    final String ppName2 = "PortPair2";
    final String ppDescription2 = "PortPair2";
    final String ingress2 = "d5555555-24fc-4fae-af4b-321c5e2eb3d1";
    final String egress2 = "a6666666-4a56-2a6e-cd3a-9dee4e2ec345";
    PortPair portPair2 = portPairBuilder.setId(portPairId2).setName(ppName2).setTenantId(tenantId).setDescription(ppDescription2).setIngress(ingress2).setEgress(egress2).build();
    portPairService.createPortPair(portPair1);
    portPairService.createPortPair(portPair2);
    FlowClassifier fc1 = createFlowClassifier(flowClassifierId1);
    FlowClassifier fc2 = createFlowClassifier(flowClassifierId2);
    flowClassifierService.createFlowClassifier(fc1);
    flowClassifierService.createFlowClassifier(fc2);
    NshServicePathId nshSpiId = NshServicePathId.of(10);
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(IpAddress.valueOf("3.3.3.3")).setIpDst(IpAddress.valueOf("4.4.4.4")).setPortSrc(PortNumber.portNumber(1500)).setPortDst(PortNumber.portNumber(2000)).setProtocol(IPv4.PROTOCOL_UDP).setTenantId(TenantId.tenantId("bbb")).build();
    LoadBalanceId id = LoadBalanceId.of((byte) 1);
    List<PortPairId> path = Lists.newArrayList();
    path.add(portPairId1);
    path.add(portPairId2);
    List<VirtualPort> virtualPortList = Lists.newArrayList();
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(ingress1)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(egress1)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(ingress2)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(egress2)));
    virtualPortService.createPorts(virtualPortList);
    portChain.addLoadBalancePath(fiveTuple, id, path);
    String physicalNetworkStr = "1234";
    String segmentationIdStr = "1";
    SegmentationId segmentationID = SegmentationId.segmentationId(segmentationIdStr);
    TenantNetworkId networkid1 = TenantNetworkId.networkId(networkIdStr);
    PhysicalNetwork physicalNetwork = PhysicalNetwork.physicalNetwork(physicalNetworkStr);
    TenantNetwork p1 = new DefaultTenantNetwork(networkid1, name, false, TenantNetwork.State.ACTIVE, false, tenantId, false, TenantNetwork.Type.LOCAL, physicalNetwork, segmentationID);
    tenantNetworkService.createNetworks(Collections.singletonList(p1));
    expect(driverService.createHandler(deviceId)).andReturn(driverHandler).anyTimes();
    replay(driverService);
    flowRuleInstaller.installLoadBalancedFlowRules(portChain, fiveTuple, nshSpiId);
    ForwardingObjective forObj = ((FlowObjectiveServiceAdapter) flowObjectiveService).forwardingObjective();
    // Check for Selector
    assertThat(forObj.selector().getCriterion(Criterion.Type.IN_PORT), instanceOf(PortCriterion.class));
    // Check for treatment
    List<Instruction> instructions = forObj.treatment().allInstructions();
    for (Instruction instruction : instructions) {
        if (instruction.type() == Instruction.Type.OUTPUT) {
            assertThat(((OutputInstruction) instruction).port(), is(PortNumber.P0));
        }
    }
}
#end_block

#method_before
@Deprecated
@DELETE
@Path("{deviceId}/{flowId}")
public Response deleteFlowByDeviceIdAndFlowId(@PathParam("deviceId") String deviceId, @PathParam("flowId") long flowId) {
    final Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (!flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    StreamSupport.stream(flowEntries.spliterator(), false).filter(entry -> entry.id().value() == flowId).forEach(service::removeFlowRules);
    return Response.noContent().build();
}
#method_after
@DELETE
@Path("{deviceId}/{flowId}")
public Response deleteFlowByDeviceIdAndFlowId(@PathParam("deviceId") String deviceId, @PathParam("flowId") long flowId) {
    final Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (!flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    StreamSupport.stream(flowEntries.spliterator(), false).filter(entry -> entry.id().value() == flowId).forEach(service::removeFlowRules);
    return Response.noContent().build();
}
#end_block

#method_before
@DELETE
@Path("{appId}/{deviceId}/{flowId}")
public Response deleteFlowByAppIdDeviceIdAndFlowId(@PathParam("appId") String appId, @PathParam("deviceId") String deviceId, @PathParam("flowId") long flowId) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    final Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (!flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    StreamSupport.stream(flowEntries.spliterator(), false).filter(entry -> entry.id().value() == flowId).forEach(entry -> service.removeFlowRules(idInstant, entry));
    return Response.noContent().build();
}
#method_after
@DELETE
@Path("{appId}/{deviceId}/{flowId}")
public Response deleteFlowByAppIdDeviceIdAndFlowId(@PathParam("appId") String appId, @PathParam("deviceId") String deviceId, @PathParam("flowId") long flowId) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    final Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (!flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    StreamSupport.stream(flowEntries.spliterator(), false).filter(entry -> (entry.id().value() == flowId) && (entry.appId() == idInstant.id())).forEach(service::removeFlowRules);
    return Response.noContent().build();
}
#end_block

#method_before
@Deprecated
@DELETE
public Response deleteFlows(InputStream stream) {
    ListMultimap<DeviceId, Long> deviceMap = ArrayListMultimap.create();
    List<FlowEntry> rulesToRemove = new ArrayList<>();
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode jsonFlows = jsonTree.get("flows");
        jsonFlows.forEach(node -> {
            DeviceId deviceId = DeviceId.deviceId(nullIsNotFound(node.get(DEVICE_ID), DEVICE_NOT_FOUND).asText());
            long flowId = nullIsNotFound(node.get(FLOW_ID), FLOW_NOT_FOUND).asLong();
            deviceMap.put(deviceId, flowId);
        });
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    deviceMap.keySet().forEach(deviceId -> {
        List<Long> flowIds = deviceMap.get(deviceId);
        Iterable<FlowEntry> entries = service.getFlowEntries(deviceId);
        flowIds.forEach(flowId -> {
            StreamSupport.stream(entries.spliterator(), false).filter(entry -> flowId == entry.id().value()).forEach(rulesToRemove::add);
        });
    });
    service.removeFlowRules(rulesToRemove.toArray(new FlowEntry[0]));
    return Response.noContent().build();
}
#method_after
@DELETE
public Response deleteFlows(InputStream stream) {
    ListMultimap<DeviceId, Long> deviceMap = ArrayListMultimap.create();
    List<FlowEntry> rulesToRemove = new ArrayList<>();
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode jsonFlows = jsonTree.get("flows");
        jsonFlows.forEach(node -> {
            DeviceId deviceId = DeviceId.deviceId(nullIsNotFound(node.get(DEVICE_ID), DEVICE_NOT_FOUND).asText());
            long flowId = nullIsNotFound(node.get(FLOW_ID), FLOW_NOT_FOUND).asLong();
            deviceMap.put(deviceId, flowId);
        });
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    deviceMap.keySet().forEach(deviceId -> {
        List<Long> flowIds = deviceMap.get(deviceId);
        Iterable<FlowEntry> entries = service.getFlowEntries(deviceId);
        flowIds.forEach(flowId -> {
            StreamSupport.stream(entries.spliterator(), false).filter(entry -> flowId == entry.id().value()).forEach(rulesToRemove::add);
        });
    });
    service.removeFlowRules(rulesToRemove.toArray(new FlowEntry[0]));
    return Response.noContent().build();
}
#end_block

#method_before
@DELETE
@Path("{appId}")
public Response deleteFlowsByAppId(@PathParam("appId") String appId, InputStream stream) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    ListMultimap<DeviceId, Long> deviceMap = ArrayListMultimap.create();
    List<FlowEntry> rulesToRemove = new ArrayList<>();
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode jsonFlows = jsonTree.get("flows");
        jsonFlows.forEach(node -> {
            DeviceId deviceId = DeviceId.deviceId(nullIsNotFound(node.get(DEVICE_ID), DEVICE_NOT_FOUND).asText());
            long flowId = nullIsNotFound(node.get(FLOW_ID), FLOW_NOT_FOUND).asLong();
            deviceMap.put(deviceId, flowId);
        });
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    deviceMap.keySet().forEach(deviceId -> {
        List<Long> flowIds = deviceMap.get(deviceId);
        Iterable<FlowEntry> entries = service.getFlowEntries(deviceId);
        flowIds.forEach(flowId -> {
            StreamSupport.stream(entries.spliterator(), false).filter(entry -> flowId == entry.id().value()).forEach(rulesToRemove::add);
        });
    });
    service.removeFlowRules(idInstant, rulesToRemove.toArray(new FlowEntry[0]));
    return Response.noContent().build();
}
#method_after
@DELETE
@Path("{appId}")
public Response deleteFlowsByAppId(@PathParam("appId") String appId, InputStream stream) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    ListMultimap<DeviceId, Long> deviceMap = ArrayListMultimap.create();
    List<FlowEntry> rulesToRemove = new ArrayList<>();
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode jsonFlows = jsonTree.get("flows");
        jsonFlows.forEach(node -> {
            DeviceId deviceId = DeviceId.deviceId(nullIsNotFound(node.get(DEVICE_ID), DEVICE_NOT_FOUND).asText());
            long flowId = nullIsNotFound(node.get(FLOW_ID), FLOW_NOT_FOUND).asLong();
            deviceMap.put(deviceId, flowId);
        });
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    deviceMap.keySet().forEach(deviceId -> {
        List<Long> flowIds = deviceMap.get(deviceId);
        Iterable<FlowEntry> entries = service.getFlowEntries(deviceId);
        flowIds.forEach(flowId -> {
            StreamSupport.stream(entries.spliterator(), false).filter(entry -> (entry.id().value() == flowId) && (entry.appId() == idInstant.id())).forEach(rulesToRemove::add);
        });
    });
    service.removeFlowRules(rulesToRemove.toArray(new FlowEntry[0]));
    return Response.noContent().build();
}
#end_block

#method_before
@Override
public short appId() {
    return 2;
}
#method_after
@Override
public short appId() {
    return (short) Objects.hash("foo");
}
#end_block

#method_before
@Test
public void testRemoveFlowByAppIdDeviceIdAndFlowId() {
    setupMockFlows();
    expect(mockApplicationService.getId(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockApplicationService);
    mockFlowService.removeFlowRules(anyObject(), anyObject());
    expectLastCall();
    replay(mockFlowService);
    WebTarget wt = target();
    String location = "/flows/4/1/155";
    Response deleteResponse = wt.path(location).request(MediaType.APPLICATION_JSON_TYPE).delete();
    assertThat(deleteResponse.getStatus(), is(HttpURLConnection.HTTP_NO_CONTENT));
}
#method_after
@Test
public void testRemoveFlowByAppIdDeviceIdAndFlowId() {
    setupMockFlows();
    expect(mockApplicationService.getId(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockApplicationService);
    mockFlowService.removeFlowRules(anyObject());
    expectLastCall();
    replay(mockFlowService);
    WebTarget wt = target();
    String location = "/flows/4/1/155";
    Response deleteResponse = wt.path(location).request(MediaType.APPLICATION_JSON_TYPE).delete();
    assertThat(deleteResponse.getStatus(), is(HttpURLConnection.HTTP_NO_CONTENT));
}
#end_block

#method_before
@Override
public ExtensionTreatment mapAction(OFAction action) throws UnsupportedOperationException {
    if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter actionExp = (OFActionExperimenter) action;
        if (actionExp.getExperimenter() == 0xff000088L) {
            OFActionOplinkAtt actionAtt = (OFActionOplinkAtt) action;
            return new OplinkAttenuation(((OFOxm<U32>) actionAtt.getField()).getValue().getRaw());
        }
    }
    return null;
}
#method_after
@Override
public ExtensionTreatment mapAction(OFAction action) throws UnsupportedOperationException {
    if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter actionExp = (OFActionExperimenter) action;
        if (actionExp.getExperimenter() == ATTENUATION_EXP) {
            OFActionOplinkAtt actionAtt = (OFActionOplinkAtt) action;
            return new OplinkAttenuation(((OFOxm<U32>) actionAtt.getField()).getValue().getRaw());
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void setPermissions(ApplicationId appId, Set<Permission> permissions) {
    AtomicBoolean permissionsChanged = new AtomicBoolean(false);
    Versioned<InternalApplicationHolder> appHolder = apps.computeIf(appId, v -> v != null && !Sets.symmetricDifference(v.permissions(), permissions).isEmpty(), (k, v) -> {
        permissionsChanged.set(true);
        return new InternalApplicationHolder(v.app(), v.state(), ImmutableSet.copyOf(permissions));
    });
    if (permissionsChanged.get()) {
        delegate.notify(new ApplicationEvent(APP_PERMISSIONS_CHANGED, appHolder.value().app()));
    }
}
#method_after
@Override
public void setPermissions(ApplicationId appId, Set<Permission> permissions) {
    AtomicBoolean permissionsChanged = new AtomicBoolean(false);
    Versioned<InternalApplicationHolder> appHolder = apps.computeIf(appId, v -> v != null && !Sets.symmetricDifference(v.permissions(), permissions).isEmpty(), (k, v) -> {
        permissionsChanged.set(true);
        return new InternalApplicationHolder(v.app(), v.state(), ImmutableSet.copyOf(permissions));
    });
    if (permissionsChanged.get()) {
        notifyDelegate(new ApplicationEvent(APP_PERMISSIONS_CHANGED, appHolder.value().app()));
    }
}
#end_block

#method_before
@Override
public void accept(Application app) {
    String appName = app.id().name();
    installAppIfNeeded(app);
    setActive(appName);
    if (delegate != null) {
        delegate.notify(new ApplicationEvent(APP_ACTIVATED, app));
    }
}
#method_after
@Override
public void accept(Application app) {
    String appName = app.id().name();
    installAppIfNeeded(app);
    setActive(appName);
    notifyDelegate(new ApplicationEvent(APP_ACTIVATED, app));
}
#end_block

#method_before
@Override
public void event(MapEvent<ApplicationId, InternalApplicationHolder> event) {
    if (delegate == null) {
        return;
    }
    ApplicationId appId = event.key();
    InternalApplicationHolder newApp = event.newValue() == null ? null : event.newValue().value();
    InternalApplicationHolder oldApp = event.oldValue() == null ? null : event.oldValue().value();
    if (event.type() == MapEvent.Type.INSERT || event.type() == MapEvent.Type.UPDATE) {
        if (event.type() == MapEvent.Type.UPDATE && newApp.state() == oldApp.state()) {
            return;
        }
        setupApplicationAndNotify(appId, newApp.app(), newApp.state());
    } else if (event.type() == MapEvent.Type.REMOVE) {
        delegate.notify(new ApplicationEvent(APP_UNINSTALLED, oldApp.app()));
        purgeApplication(appId.name());
    }
}
#method_after
@Override
public void event(MapEvent<ApplicationId, InternalApplicationHolder> event) {
    if (delegate == null) {
        return;
    }
    ApplicationId appId = event.key();
    InternalApplicationHolder newApp = event.newValue() == null ? null : event.newValue().value();
    InternalApplicationHolder oldApp = event.oldValue() == null ? null : event.oldValue().value();
    if (event.type() == MapEvent.Type.INSERT || event.type() == MapEvent.Type.UPDATE) {
        if (event.type() == MapEvent.Type.UPDATE && newApp.state() == oldApp.state()) {
            return;
        }
        setupApplicationAndNotify(appId, newApp.app(), newApp.state());
    } else if (event.type() == MapEvent.Type.REMOVE) {
        notifyDelegate(new ApplicationEvent(APP_UNINSTALLED, oldApp.app()));
        purgeApplication(appId.name());
    }
}
#end_block

#method_before
private void setupApplicationAndNotify(ApplicationId appId, Application app, InternalState state) {
    // ACTIVATED state is handled separately in NextAppToActivateValueListener
    if (state == INSTALLED) {
        fetchBitsIfNeeded(app);
        delegate.notify(new ApplicationEvent(APP_INSTALLED, app));
    } else if (state == DEACTIVATED) {
        clearActive(appId.name());
        delegate.notify(new ApplicationEvent(APP_DEACTIVATED, app));
    }
}
#method_after
private void setupApplicationAndNotify(ApplicationId appId, Application app, InternalState state) {
    // ACTIVATED state is handled separately in NextAppToActivateValueListener
    if (state == INSTALLED) {
        fetchBitsIfNeeded(app);
        notifyDelegate(new ApplicationEvent(APP_INSTALLED, app));
    } else if (state == DEACTIVATED) {
        clearActive(appId.name());
        notifyDelegate(new ApplicationEvent(APP_DEACTIVATED, app));
    }
}
#end_block

#method_before
private void installAppIfNeeded(Application app) {
    if (!appBitsAvailable(app)) {
        fetchBits(app);
        delegate.notify(new ApplicationEvent(APP_INSTALLED, app));
    }
}
#method_after
private void installAppIfNeeded(Application app) {
    if (!appBitsAvailable(app)) {
        fetchBits(app);
        notifyDelegate(new ApplicationEvent(APP_INSTALLED, app));
    }
}
#end_block

#method_before
private boolean shouldUpdate(DefaultHost existingHost, ProviderId providerId, HostId hostId, HostDescription hostDescription, boolean replaceIPs) {
    if (existingHost == null) {
        return true;
    }
    log.info("existingHost.version() {}  hostDescription.version() {}", existingHost, hostDescription);
    if (!Objects.equals(existingHost.providerId(), providerId) || !Objects.equals(existingHost.mac(), hostDescription.hwAddress()) || !Objects.equals(existingHost.vlan(), hostDescription.vlan()) || !Objects.equals(existingHost.location(), hostDescription.location()) || hostDescription.timeStamp() == null || hostDescription.timeStamp().isNewerThan(existingHost.timeStamp())) {
        return true;
    }
    if (replaceIPs) {
        if (!Objects.equals(hostDescription.ipAddress(), existingHost.ipAddresses())) {
            return true;
        }
    } else {
        if (!existingHost.ipAddresses().containsAll(hostDescription.ipAddress())) {
            return true;
        }
    }
    // differ from those in the existing host
    return hostDescription.annotations().keys().stream().anyMatch(k -> !Objects.equals(hostDescription.annotations().value(k), existingHost.annotations().value(k)));
}
#method_after
private boolean shouldUpdate(DefaultHost existingHost, ProviderId providerId, HostId hostId, HostDescription hostDescription, boolean replaceIPs) {
    if (existingHost == null) {
        return true;
    }
    if (!Objects.equals(existingHost.providerId(), providerId) || !Objects.equals(existingHost.mac(), hostDescription.hwAddress()) || !Objects.equals(existingHost.vlan(), hostDescription.vlan()) || !Objects.equals(existingHost.location(), hostDescription.location()) || hostDescription.timestamp() == null || hostDescription.timestamp().isNewerThan(existingHost.timestamp())) {
        return true;
    }
    if (replaceIPs) {
        if (!Objects.equals(hostDescription.ipAddress(), existingHost.ipAddresses())) {
            return true;
        }
    } else {
        if (!existingHost.ipAddresses().containsAll(hostDescription.ipAddress())) {
            return true;
        }
    }
    // differ from those in the existing host
    return hostDescription.annotations().keys().stream().anyMatch(k -> !Objects.equals(hostDescription.annotations().value(k), existingHost.annotations().value(k)));
}
#end_block

#method_before
@Override
public HostEvent createOrUpdateHost(ProviderId providerId, HostId hostId, HostDescription hostDescription, boolean replaceIPs) {
    hostsConsistentMap.computeIf(hostId, existingHost -> shouldUpdate(existingHost, providerId, hostId, hostDescription, replaceIPs), (id, existingHost) -> {
        HostLocation location = hostDescription.location();
        final Set<IpAddress> addresses;
        if (existingHost == null || replaceIPs) {
            addresses = ImmutableSet.copyOf(hostDescription.ipAddress());
        } else {
            addresses = Sets.newHashSet(existingHost.ipAddresses());
            addresses.addAll(hostDescription.ipAddress());
        }
        final Annotations annotations;
        if (existingHost != null) {
            annotations = merge((DefaultAnnotations) existingHost.annotations(), hostDescription.annotations());
        } else {
            annotations = hostDescription.annotations();
        }
        return new DefaultHost(providerId, hostId, hostDescription.hwAddress(), hostDescription.vlan(), location, addresses, hostDescription.timeStamp(), annotations);
    });
    return null;
}
#method_after
@Override
public HostEvent createOrUpdateHost(ProviderId providerId, HostId hostId, HostDescription hostDescription, boolean replaceIPs) {
    hostsConsistentMap.computeIf(hostId, existingHost -> shouldUpdate(existingHost, providerId, hostId, hostDescription, replaceIPs), (id, existingHost) -> {
        HostLocation location = hostDescription.location();
        final Set<IpAddress> addresses;
        if (existingHost == null || replaceIPs) {
            addresses = ImmutableSet.copyOf(hostDescription.ipAddress());
        } else {
            addresses = Sets.newHashSet(existingHost.ipAddresses());
            addresses.addAll(hostDescription.ipAddress());
        }
        final Annotations annotations;
        if (existingHost != null) {
            annotations = merge((DefaultAnnotations) existingHost.annotations(), hostDescription.annotations());
        } else {
            annotations = hostDescription.annotations();
        }
        return new DefaultHost(providerId, hostId, hostDescription.hwAddress(), hostDescription.vlan(), location, addresses, hostDescription.timestamp(), annotations);
    });
    return null;
}
#end_block

#method_before
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = Tools.isPropertyEnabled(properties, "monitorHosts");
    if (flag == null) {
        log.info("monitorHosts is not enabled " + "using current value of {}", monitorHosts);
    } else {
        monitorHosts = flag;
        log.info("Configured. monitorHosts {}", monitorHosts ? "enabled" : "disabled");
    }
    Long longValue = Tools.getLongProperty(properties, "probeRate");
    if (longValue == null || longValue == 0) {
        log.info("probeRate is not set " + "using defalut value of {}", probeRate);
    } else {
        probeRate = longValue;
        log.info("Configured. probeRate {}", probeRate);
    }
}
#method_after
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = Tools.isPropertyEnabled(properties, "monitorHosts");
    if (flag == null) {
        log.info("monitorHosts is not enabled " + "using current value of {}", monitorHosts);
    } else {
        monitorHosts = flag;
        log.info("Configured. monitorHosts {}", monitorHosts ? "enabled" : "disabled");
    }
    Long longValue = Tools.getLongProperty(properties, "probeRate");
    if (longValue == null || longValue == 0) {
        log.info("probeRate is not set sing default value of {}", probeRate);
    } else {
        probeRate = longValue;
        log.info("Configured. probeRate {}", probeRate);
    }
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("id", id()).add("mac", mac()).add("vlan", vlan()).add("location", location()).add("ipAddresses", ipAddresses()).add("annotations", annotations()).add("timeStamp", timeStamp()).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("id", id()).add("mac", mac()).add("vlan", vlan()).add("location", location()).add("ipAddresses", ipAddresses()).add("annotations", annotations()).add("timestamp", timestamp()).toString();
}
#end_block

#method_before
@Override
public ObjectNode encode(Host host, CodecContext context) {
    checkNotNull(host, "Host cannot be null");
    final JsonCodec<HostLocation> locationCodec = context.codec(HostLocation.class);
    final ObjectNode result = context.mapper().createObjectNode().put("id", host.id().toString()).put("mac", host.mac().toString()).put("vlan", host.vlan().toString()).put("timeStamp", ((WallClockTimestamp) host.timeStamp()).unixTimestamp());
    final ArrayNode jsonIpAddresses = result.putArray("ipAddresses");
    for (final IpAddress ipAddress : host.ipAddresses()) {
        jsonIpAddresses.add(ipAddress.toString());
    }
    result.set("ipAddresses", jsonIpAddresses);
    result.set("location", locationCodec.encode(host.location(), context));
    return annotate(result, host, context);
}
#method_after
@Override
public ObjectNode encode(Host host, CodecContext context) {
    checkNotNull(host, "Host cannot be null");
    final JsonCodec<HostLocation> locationCodec = context.codec(HostLocation.class);
    final ObjectNode result = context.mapper().createObjectNode().put("id", host.id().toString()).put("mac", host.mac().toString()).put("vlan", host.vlan().toString()).put("timestamp", host.timestamp().unixTimestamp());
    final ArrayNode jsonIpAddresses = result.putArray("ipAddresses");
    for (final IpAddress ipAddress : host.ipAddresses()) {
        jsonIpAddresses.add(ipAddress.toString());
    }
    result.set("ipAddresses", jsonIpAddresses);
    result.set("location", locationCodec.encode(host.location(), context));
    return annotate(result, host, context);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("mac", mac).add("vlan", vlan).add("location", location).add("ipAddress", ip).add("timeStamp", timeStamp).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("mac", mac).add("vlan", vlan).add("location", location).add("ipAddress", ip).add("timestamp", timestamp).toString();
}
#end_block

#method_before
protected void printHost(Host host) {
    if (shortOnly) {
        print(FMT_SHORT, host.id(), host.mac(), host.location().deviceId(), host.location().port(), host.vlan(), host.ipAddresses(), host.timeStamp());
    } else {
        print(FMT, host.id(), host.mac(), host.location().deviceId(), host.location().port(), host.vlan(), host.ipAddresses(), annotations(host.annotations()), ((WallClockTimestamp) host.timeStamp()).unixTimestamp());
    }
}
#method_after
protected void printHost(Host host) {
    if (shortOnly) {
        print(FMT_SHORT, host.id(), host.mac(), host.location().deviceId(), host.location().port(), host.vlan(), host.ipAddresses());
    } else {
        print(FMT, host.id(), host.mac(), host.location().deviceId(), host.location().port(), host.vlan(), host.ipAddresses(), annotations(host.annotations()), Tools.timeAgo(host.timestamp().unixTimestamp()));
    }
}
#end_block

#method_before
void setProbeRate(Long probeRate) {
    this.probeRate = probeRate;
}
#method_after
void setProbeRate(long probeRate) {
    this.probeRate = probeRate;
}
#end_block

#method_before
@Override
public void triggerProbe(Host host) {
    log.info("Triggering probe on device {} ", host);
    MastershipRole role = deviceService.getRole(host.location().deviceId());
    if (role.equals(MastershipRole.MASTER)) {
        host.ipAddresses().forEach(ip -> {
            log.info("probing ip {}", ip.toString());
            sendProbe(host, ip);
        });
    } else {
        log.info("not the master, master will probe {}");
    }
}
#method_after
@Override
public void triggerProbe(Host host) {
    log.info("Triggering probe on device {} ", host);
    MastershipRole role = deviceService.getRole(host.location().deviceId());
    if (role.equals(MastershipRole.MASTER)) {
        host.ipAddresses().forEach(ip -> {
            sendProbe(host, ip);
        });
    } else {
        log.info("not the master, master will probe {}");
    }
}
#end_block

#method_before
private Ethernet buildArpRequest(IpAddress targetIp, Host host) {
    ARP arp = new ARP();
    arp.setHardwareType(ARP.HW_TYPE_ETHERNET).setHardwareAddressLength((byte) Ethernet.DATALAYER_ADDRESS_LENGTH).setProtocolType(ARP.PROTO_TYPE_IP).setProtocolAddressLength((byte) IpAddress.INET_BYTE_LENGTH).setOpCode(ARP.OP_REQUEST);
    InetAddress address;
    Ethernet ethernet = new Ethernet();
    try {
        address = InetAddress.getByName("0.0.0.0");
        arp.setSenderHardwareAddress(MacAddress.BROADCAST.toBytes()).setSenderProtocolAddress(IpAddress.valueOf(address).toOctets()).setTargetHardwareAddress(MacAddress.BROADCAST.toBytes()).setTargetProtocolAddress(targetIp.toOctets());
        ethernet.setEtherType(Ethernet.TYPE_ARP).setDestinationMACAddress(MacAddress.BROADCAST).setSourceMACAddress(MacAddress.BROADCAST.toBytes()).setPayload(arp);
        ethernet.setPad(true);
    } catch (UnknownHostException e) {
        log.warn("unknow host  {}", e.getMessage());
    }
    return ethernet;
}
#method_after
private Ethernet buildArpRequest(IpAddress targetIp, Host host) {
    ARP arp = new ARP();
    arp.setHardwareType(ARP.HW_TYPE_ETHERNET).setHardwareAddressLength((byte) Ethernet.DATALAYER_ADDRESS_LENGTH).setProtocolType(ARP.PROTO_TYPE_IP).setProtocolAddressLength((byte) IpAddress.INET_BYTE_LENGTH).setOpCode(ARP.OP_REQUEST);
    arp.setSenderHardwareAddress(MacAddress.BROADCAST.toBytes()).setSenderProtocolAddress(SENDER_ADDRESS).setTargetHardwareAddress(MacAddress.BROADCAST.toBytes()).setTargetProtocolAddress(targetIp.toOctets());
    Ethernet ethernet = new Ethernet();
    ethernet.setEtherType(Ethernet.TYPE_ARP).setDestinationMACAddress(MacAddress.BROADCAST).setSourceMACAddress(MacAddress.BROADCAST).setPayload(arp);
    ethernet.setPad(true);
    return ethernet;
}
#end_block

#method_before
@Override
public ObjectNode encode(DisjointPath disjointPath, CodecContext context) {
    checkNotNull(disjointPath, "Path cannot be null");
    JsonCodec<Link> codec = context.codec(Link.class);
    ObjectNode result = context.mapper().createObjectNode();
    ObjectNode primary = context.mapper().createObjectNode().put("cost", disjointPath.primary().cost());
    result.set("Primary", primary);
    ArrayNode jsonLinks = primary.putArray("links");
    for (Link link : disjointPath.primary().links()) {
        jsonLinks.add(codec.encode(link, context));
    }
    if (disjointPath.backup() != null) {
        ObjectNode backup = context.mapper().createObjectNode().put("cost", disjointPath.backup().cost());
        result.set("Backup", backup);
        ArrayNode jsonLinks1 = backup.putArray("links");
        for (Link link1 : disjointPath.backup().links()) {
            jsonLinks1.add(codec.encode(link1, context));
        }
    }
    return annotate(result, disjointPath, context);
}
#method_after
@Override
public ObjectNode encode(DisjointPath disjointPath, CodecContext context) {
    checkNotNull(disjointPath, "Path cannot be null");
    JsonCodec<Link> codec = context.codec(Link.class);
    ObjectNode result = context.mapper().createObjectNode();
    ObjectNode primary = context.mapper().createObjectNode().put("cost", disjointPath.primary().cost());
    result.set("primary", primary);
    ArrayNode jsonLinks = primary.putArray("links");
    for (Link link : disjointPath.primary().links()) {
        jsonLinks.add(codec.encode(link, context));
    }
    if (disjointPath.backup() != null) {
        ObjectNode backup = context.mapper().createObjectNode().put("cost", disjointPath.backup().cost());
        result.set("backup", backup);
        ArrayNode jsonLinks1 = backup.putArray("links");
        for (Link link1 : disjointPath.backup().links()) {
            jsonLinks1.add(codec.encode(link1, context));
        }
    }
    return annotate(result, disjointPath, context);
}
#end_block

#method_before
@Activate
protected void activate() {
    allocationMap = storageService.<HostId, IpAssignment>consistentMapBuilder().withName("onos-dhcp-assignedIP").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(IpAssignment.class, IpAssignment.AssignmentStatus.class, Date.class, long.class, Ip4Address.class).build())).build();
    freeIPPool = storageService.<Ip4Address>setBuilder().withName("onos-dhcp-freeIP").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    allocationMap = storageService.<HostId, IpAssignment>consistentMapBuilder().withName("onos-dhcp-assignedIP").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(IpAssignment.class, IpAssignment.AssignmentStatus.class, Date.class).build("dhcp"))).build();
    freeIPPool = storageService.<Ip4Address>setBuilder().withName("onos-dhcp-freeIP").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
    log.info("Started");
}
#end_block

#method_before
@Override
public Ip4Address releaseIP(HostId hostId) {
    if (allocationMap.containsKey(hostId)) {
        // If the IP has been assigned with Option_RangeNotEnforced,
        // we do not release the IP address nor remove the host from HostService
        // It is because Option_RangeNotEnforced is set by the OpenstackNetworking app,
        // and the IP will be released and the host will be removed from HostService
        // only if the VM has been removed from OpenStack.
        Versioned<IpAssignment> assignmentVersioned = allocationMap.get(hostId);
        if (assignmentVersioned != null && assignmentVersioned.value().assignmentStatus().equals(Option_RangeNotEnforced)) {
            return null;
        }
        IpAssignment newAssignment = IpAssignment.builder(allocationMap.get(hostId).value()).assignmentStatus(IpAssignment.AssignmentStatus.Option_Expired).build();
        Ip4Address freeIP = newAssignment.ipAddress();
        allocationMap.put(hostId, newAssignment);
        if (ipWithinRange(freeIP)) {
            freeIPPool.add(freeIP);
        }
        return freeIP;
    }
    return null;
}
#method_after
@Override
public Ip4Address releaseIP(HostId hostId) {
    if (allocationMap.containsKey(hostId)) {
        // If the IP has been assigned with Option_RangeNotEnforced,
        // we do not release the IP address nor remove the host from HostService.
        // Therefore, if the IP is assigned statically, the IP needs to be released statically.
        Versioned<IpAssignment> assignmentVersioned = allocationMap.get(hostId);
        if (Versioned.valueOrNull(assignmentVersioned) != null && assignmentVersioned.value().assignmentStatus().equals(Option_RangeNotEnforced)) {
            return null;
        }
        IpAssignment newAssignment = IpAssignment.builder(allocationMap.get(hostId).value()).assignmentStatus(IpAssignment.AssignmentStatus.Option_Expired).build();
        Ip4Address freeIP = newAssignment.ipAddress();
        allocationMap.put(hostId, newAssignment);
        if (ipWithinRange(freeIP)) {
            freeIPPool.add(freeIP);
        }
        return freeIP;
    }
    return null;
}
#end_block

#method_before
@Override
public List<String> getPendingNexts() {
    List<String> pendingNexts = new ArrayList<>();
    for (Integer nextId : pendingForwards.keySet()) {
        Set<PendingNext> pnext = pendingForwards.get(nextId);
        StringBuffer pend = new StringBuffer();
        pend.append("Next Id: ").append(Integer.toString(nextId)).append(" :: ");
        for (PendingNext pn : pnext) {
            pend.append(Integer.toString(pn.forwardingObjective().id())).append(" ");
        }
        pendingNexts.add(pend.toString());
    }
    return pendingNexts;
}
#method_after
@Override
public List<String> getPendingNexts() {
    List<String> pendingNexts = new ArrayList<>();
    for (Integer nextId : pendingForwards.keySet()) {
        Set<PendingNext> pnext = pendingForwards.get(nextId);
        StringBuilder pend = new StringBuilder();
        pend.append("Next Id: ").append(Integer.toString(nextId)).append(" :: ");
        for (PendingNext pn : pnext) {
            pend.append(Integer.toString(pn.forwardingObjective().id())).append(" ");
        }
        pendingNexts.add(pend.toString());
    }
    return pendingNexts;
}
#end_block

#method_before
@Override
public LispMacAddress readFrom(ByteBuf byteBuf) throws LispParseError {
    byte[] macByte = new byte[6];
    byteBuf.readBytes(macByte);
    MacAddress macAddress = MacAddress.valueOf(macByte);
    return new LispMacAddress(macAddress);
}
#method_after
@Override
public LispMacAddress readFrom(ByteBuf byteBuf) throws LispParseError {
    byte[] macByte = new byte[SIZE_OF_MAC_ADDRESS];
    byteBuf.readBytes(macByte);
    MacAddress macAddress = MacAddress.valueOf(macByte);
    return new LispMacAddress(macAddress);
}
#end_block

#method_before
@Override
public LispIpv6Address readFrom(ByteBuf byteBuf) throws LispParseError {
    byte[] ipByte = new byte[16];
    byteBuf.readBytes(ipByte);
    IpAddress ipAddress = IpAddress.valueOf(IpAddress.Version.INET6, ipByte);
    return new LispIpv6Address(ipAddress);
}
#method_after
@Override
public LispIpv6Address readFrom(ByteBuf byteBuf) throws LispParseError {
    byte[] ipByte = new byte[SIZE_OF_IPV6_ADDRESS];
    byteBuf.readBytes(ipByte);
    IpAddress ipAddress = IpAddress.valueOf(IpAddress.Version.INET6, ipByte);
    return new LispIpv6Address(ipAddress);
}
#end_block

#method_before
@Override
public LispIpv4Address readFrom(ByteBuf byteBuf) throws LispParseError {
    byte[] ipByte = new byte[4];
    byteBuf.readBytes(ipByte);
    IpAddress ipAddress = IpAddress.valueOf(IpAddress.Version.INET, ipByte);
    return new LispIpv4Address(ipAddress);
}
#method_after
@Override
public LispIpv4Address readFrom(ByteBuf byteBuf) throws LispParseError {
    byte[] ipByte = new byte[SIZE_OF_IPV4_ADDRESS];
    byteBuf.readBytes(ipByte);
    IpAddress ipAddress = IpAddress.valueOf(IpAddress.Version.INET, ipByte);
    return new LispIpv4Address(ipAddress);
}
#end_block

#method_before
private Topic<GroupStoreMessage> getOrCreateGroupTopic(Serializer serializer) {
    if (groupTopic == null) {
        return storageService.getTopic("group", serializer);
    } else {
        return groupTopic;
    }
}
#method_after
private Topic<GroupStoreMessage> getOrCreateGroupTopic(Serializer serializer) {
    if (groupTopic == null) {
        return storageService.getTopic("group-failover-notif", serializer);
    } else {
        return groupTopic;
    }
}
#end_block

#method_before
private void processGroupMessage(GroupStoreMessage message) {
    if (mastershipService.isLocalMaster(message.deviceId()) && message.type() == GroupStoreMessage.Type.FAILOVER) {
        Group group = getGroupIdTable(message.deviceId()).values().stream().filter((storedGroup) -> (storedGroup.appCookie().equals(message.appCookie()))).findFirst().get();
        notifyDelegate(new GroupEvent(Type.GROUP_BUCKET_FAILOVER, group));
    }
}
#method_after
private void processGroupMessage(GroupStoreMessage message) {
    if (message.type() == GroupStoreMessage.Type.FAILOVER) {
        // FIXME: groupStoreEntriesByKey inaccessible here
        getGroupIdTable(message.deviceId()).values().stream().filter((storedGroup) -> (storedGroup.appCookie().equals(message.appCookie()))).findFirst().ifPresent(group -> notifyDelegate(new GroupEvent(Type.GROUP_BUCKET_FAILOVER, group)));
    }
}
#end_block

#method_before
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (isLeavesPresent) {
                insertDataIntoJavaFile(file, NEW_LINE + getInterfaceLeafIdEnumSignature(className) + NEW_LINE + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path), COMMA, SEMI_COLAN), NEW_LINE) + NEW_LINE + NEW_LINE + getInterfaceLeafIdEnumMethods());
            }
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        // Add to list method.
        /*insertDataIntoJavaFile(file, getDataFromTempFileHandle(ADD_TO_LIST_INTERFACE_MASK,
                        ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles()
                                .getBeanTempFiles(), path));*/
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        // methods.add(getAddAugmentInfoMethodInterface());
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, javaFileInfo.getPluginConfig());
        methods.add(NEW_LINE + processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(NEW_LINE + processSubtreeFilteringInterface(className));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + isLeafValueSetInterface());
        methods.add(NEW_LINE + isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (isLeavesPresent) {
                insertDataIntoJavaFile(file, NEW_LINE + getInterfaceLeafIdEnumSignature(className) + NEW_LINE + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path), COMMA, SEMI_COLAN), NEW_LINE) + NEW_LINE + NEW_LINE + getInterfaceLeafIdEnumMethods());
            }
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, javaFileInfo.getPluginConfig());
        methods.add(NEW_LINE + processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(NEW_LINE + processSubtreeFilteringInterface(className));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + isLeafValueSetInterface());
        methods.add(NEW_LINE + isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateDefaultClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    boolean isRootNode = false;
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        opParamClassName = className + OP_PARAM;
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, JavaCodeSnippetGen.addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        // Add operation attributes
        insertDataIntoJavaFile(file, getOperationTypeEnum());
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list impl method.
            /*methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK,
                        ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles()
                                .getBeanTempFiles(), path));*/
            // Hash code method.
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            // Equals method.
            if (isRootNode) {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(opParamClassName) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            } else {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            }
            // To string method.
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        // methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, pluginConfig, isRootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        if (isAttrPresent) {
            constructor = constructor + getOperationTypeForConstructor();
        }
        if (isLeavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        // add is filter content match.
        String augmentableSubTreeFiltering = "";
        if (curNode instanceof YangAugmentableNode) {
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(getProcessSubtreeFilteringStart(curNode, pluginConfig) + getProcessSubtreeFunctionBody() + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd() + getProcessLeafSubtreeFiltering(curNode, pluginConfig, path) + getProcessLeafListSubtreeFiltering(curNode, pluginConfig, path) + getProcessChildNodeSubtreeFiltering(curNode, pluginConfig, path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PROTECTED, DEFAULT, pluginConfig, curNode));
    methods.add(builderMethod(className) + NEW_LINE);
    if (isLeavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateDefaultClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    boolean isRootNode = false;
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        opParamClassName = className + OP_PARAM;
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, JavaCodeSnippetGen.addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        // Add operation attributes
        insertDataIntoJavaFile(file, getOperationTypeEnum());
        insertDataIntoJavaFile(file, getOperationTypeAttr());
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Hash code method.
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            // Equals method.
            if (isRootNode) {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(opParamClassName) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            } else {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            }
            // To string method.
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, pluginConfig, isRootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        if (isAttrPresent) {
            constructor = constructor + getOperationTypeForConstructor();
        }
        if (isLeavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        // add is filter content match.
        String augmentableSubTreeFiltering = "";
        if (curNode instanceof YangAugmentableNode) {
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(getProcessSubtreeFilteringStart(curNode, pluginConfig) + getProcessSubtreeFunctionBody() + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd() + getProcessLeafSubtreeFiltering(curNode, pluginConfig, path) + getProcessLeafListSubtreeFiltering(curNode, pluginConfig, path) + getProcessChildNodeSubtreeFiltering(curNode, pluginConfig, path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PROTECTED, DEFAULT, pluginConfig, curNode));
    methods.add(builderMethod(className) + NEW_LINE);
    if (isLeavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
@Override
public ObjectNode encode(DisjointPath disjointPath, CodecContext context) {
    checkNotNull(disjointPath, "Path cannot be null");
    JsonCodec<Link> codec = context.codec(Link.class);
    ObjectNode result = context.mapper().createObjectNode();
    ObjectNode primary = context.mapper().createObjectNode().put("cost", disjointPath.primary().cost());
    ObjectNode backup = context.mapper().createObjectNode();
    result.set("Primary", primary);
    ArrayNode jsonLinks = primary.putArray("links");
    for (Link link : disjointPath.primary().links()) {
        jsonLinks.add(codec.encode(link, context));
    }
    if (disjointPath.useBackup()) {
        backup.put("cost", disjointPath.backup().cost());
        result.set("Backup", backup);
        ArrayNode jsonLinks1 = backup.putArray("links");
        for (Link link1 : disjointPath.backup().links()) {
            jsonLinks1.add(codec.encode(link1, context));
        }
    }
    return annotate(result, disjointPath, context);
}
#method_after
@Override
public ObjectNode encode(DisjointPath disjointPath, CodecContext context) {
    checkNotNull(disjointPath, "Path cannot be null");
    JsonCodec<Link> codec = context.codec(Link.class);
    ObjectNode result = context.mapper().createObjectNode();
    ObjectNode primary = context.mapper().createObjectNode().put("cost", disjointPath.primary().cost());
    result.set("Primary", primary);
    ArrayNode jsonLinks = primary.putArray("links");
    for (Link link : disjointPath.primary().links()) {
        jsonLinks.add(codec.encode(link, context));
    }
    if (disjointPath.backup() != null) {
        ObjectNode backup = context.mapper().createObjectNode().put("cost", disjointPath.backup().cost());
        result.set("Backup", backup);
        ArrayNode jsonLinks1 = backup.putArray("links");
        for (Link link1 : disjointPath.backup().links()) {
            jsonLinks1.add(codec.encode(link1, context));
        }
    }
    return annotate(result, disjointPath, context);
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_REMOVED:
        case DEVICE_AVAILABILITY_CHANGED:
            DeviceId deviceId = event.subject().id();
            if (!deviceService.isAvailable(deviceId)) {
                log.debug("Device {} became un available; clearing initial audit status", event.type(), event.subject().id());
                store.deviceInitialAuditCompleted(event.subject().id(), false);
                if (purgeOnDisconnection) {
                    store.purgeGroupEntry(deviceId);
                }
            }
            break;
        case PORT_UPDATED:
            Port port = event.port();
            DeviceId id = event.subject().id();
            if (!port.isEnabled()) {
                Iterator<Group> iterator = getGroups(id).iterator();
                while (iterator.hasNext()) {
                    Group group = iterator.next();
                    if (group.type() == GroupDescription.Type.FAILOVER) {
                        boolean portReached = false;
                        boolean portEnabled = false;
                        Iterator<GroupBucket> bIterator = group.buckets().buckets().iterator();
                        GroupBucket bucket;
                        while (bIterator.hasNext() && !portReached) {
                            bucket = bIterator.next();
                            if (deviceService.getPort(id, bucket.watchPort()).isEnabled()) {
                                portEnabled = true;
                            }
                            if (bucket.watchPort().equals(port.number())) {
                                portReached = true;
                            }
                        }
                        if (portReached && !portEnabled) {
                            delegate.notify(new GroupEvent(GroupEvent.Type.GROUP_BUCKET_FAILOVER, group));
                        }
                    }
                }
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_REMOVED:
        case DEVICE_AVAILABILITY_CHANGED:
            DeviceId deviceId = event.subject().id();
            if (!deviceService.isAvailable(deviceId)) {
                log.debug("Device {} became un available; clearing initial audit status", event.type(), event.subject().id());
                store.deviceInitialAuditCompleted(event.subject().id(), false);
                if (purgeOnDisconnection) {
                    store.purgeGroupEntry(deviceId);
                }
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
void prepare(Optional<IntentData> toUninstall, Optional<IntentData> toInstall, Consumer<OperationContext> successConsumer, Consumer<OperationContext> errorConsumer) {
    this.toUninstall = toUninstall;
    this.toInstall = toInstall;
    this.successConsumer = successConsumer;
    this.errorConsumer = errorConsumer;
    prepareIntentData(toInstall, toUninstall);
}
#method_after
void prepare(Optional<IntentData> toUninstall, Optional<IntentData> toInstall, Consumer<OperationContext> successConsumer, Consumer<OperationContext> errorConsumer) {
    this.toUninstall = toUninstall;
    this.toInstall = toInstall;
    this.successConsumer = successConsumer;
    this.errorConsumer = errorConsumer;
    prepareIntentData(toUninstall, toInstall);
}
#end_block

#method_before
private void prepareIntentData(Optional<IntentData> installData, Optional<IntentData> uninstallData) {
    if (!installData.isPresent() && !uninstallData.isPresent()) {
        return;
    } else if (!installData.isPresent()) {
        prepareIntentData(uninstallData, Direction.REMOVE);
    } else if (!uninstallData.isPresent()) {
        prepareIntentData(installData, Direction.ADD);
    } else {
        IntentData install = installData.get();
        IntentData uninstall = uninstallData.get();
        List<Intent> installIntents = new ArrayList<>();
        installIntents.addAll(install.installables());
        List<Intent> uninstallIntents = new ArrayList<>();
        uninstallIntents.addAll(uninstall.installables());
        checkState(installIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected");
        checkState(uninstallIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected");
        // Filter out same intents and intents with same flow rules
        Iterator<Intent> iterator = installIntents.iterator();
        while (iterator.hasNext()) {
            Intent installIntent = iterator.next();
            List<Intent> commonIntent = uninstallIntents.stream().filter(uIntent -> {
                if (uIntent.equals(installIntent)) {
                    return true;
                } else if (uIntent instanceof FlowRuleIntent && installIntent instanceof FlowRuleIntent) {
                    return ((FlowRuleIntent) uIntent).flowRules().containsAll(((FlowRuleIntent) installIntent).flowRules());
                } else {
                    return false;
                }
            }).collect(Collectors.toList());
            if (commonIntent.size() > 0) {
                uninstallIntents.remove(commonIntent.get(0));
                iterator.remove();
            }
        }
        final IntentData newInstall = new IntentData(install, installIntents);
        final IntentData newUninstall = new IntentData(uninstall, uninstallIntents);
        trackerService.addTrackedResources(newInstall.key(), newInstall.intent().resources());
        installIntents.forEach(installable -> trackerService.addTrackedResources(newInstall.key(), installable.resources()));
        trackerService.removeTrackedResources(newUninstall.key(), newUninstall.intent().resources());
        uninstallIntents.forEach(installable -> trackerService.removeTrackedResources(newUninstall.intent().key(), installable.resources()));
        prepareIntents(installIntents, Direction.ADD);
        prepareIntents(uninstallIntents, Direction.REMOVE);
    }
}
#method_after
private void prepareIntentData(Optional<IntentData> uninstallData, Optional<IntentData> installData) {
    if (!installData.isPresent() && !uninstallData.isPresent()) {
        return;
    } else if (!installData.isPresent()) {
        prepareIntentData(uninstallData, Direction.REMOVE);
    } else if (!uninstallData.isPresent()) {
        prepareIntentData(installData, Direction.ADD);
    } else {
        IntentData uninstall = uninstallData.get();
        IntentData install = installData.get();
        List<Intent> uninstallIntents = new ArrayList<>();
        uninstallIntents.addAll(uninstall.installables());
        List<Intent> installIntents = new ArrayList<>();
        installIntents.addAll(install.installables());
        checkState(uninstallIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected");
        checkState(installIntents.stream().allMatch(this::isSupported), "Unsupported installable intents detected");
        // TODO: Filter FlowObjective intents
        // Filter out same intents and intents with same flow rules
        Iterator<Intent> iterator = installIntents.iterator();
        while (iterator.hasNext()) {
            Intent installIntent = iterator.next();
            uninstallIntents.stream().filter(uIntent -> {
                if (uIntent.equals(installIntent)) {
                    return true;
                } else if (uIntent instanceof FlowRuleIntent && installIntent instanceof FlowRuleIntent) {
                    return ((FlowRuleIntent) uIntent).flowRules().containsAll(((FlowRuleIntent) installIntent).flowRules());
                } else {
                    return false;
                }
            }).findFirst().ifPresent(common -> {
                uninstallIntents.remove(common);
                iterator.remove();
            });
        }
        final IntentData newUninstall = new IntentData(uninstall, uninstallIntents);
        final IntentData newInstall = new IntentData(install, installIntents);
        trackerService.removeTrackedResources(newUninstall.key(), newUninstall.intent().resources());
        uninstallIntents.forEach(installable -> trackerService.removeTrackedResources(newUninstall.intent().key(), installable.resources()));
        trackerService.addTrackedResources(newInstall.key(), newInstall.intent().resources());
        installIntents.forEach(installable -> trackerService.addTrackedResources(newInstall.key(), installable.resources()));
        prepareIntents(uninstallIntents, Direction.REMOVE);
        prepareIntents(installIntents, Direction.ADD);
    }
}
#end_block

#method_before
@Override
public SinglePointToMultiPointIntent decode(ObjectNode json, CodecContext context) {
    SinglePointToMultiPointIntent.Builder builder = SinglePointToMultiPointIntent.builder();
    IntentCodec.intentAttributes(json, context, builder);
    ConnectivityIntentCodec.intentAttributes(json, context, builder);
    ObjectNode ingressJson = nullIsIllegal(get(json, INGRESS_POINT), INGRESS_POINT + IntentCodec.MISSING_MEMBER_MESSAGE);
    ConnectPoint ingress = context.codec(ConnectPoint.class).decode(ingressJson, context);
    builder.ingressPoint(ingress);
    ObjectNode egressJson = nullIsIllegal(get(json, EGRESS_POINT), EGRESS_POINT + IntentCodec.MISSING_MEMBER_MESSAGE);
    if (egressJson != null) {
        final JsonCodec<ConnectPoint> connectPointCodec = context.codec(ConnectPoint.class);
        JsonNode connectPointsJson = get(json, EGRESS_POINT).get(CP_POINTS);
        Set<ConnectPoint> egressCp = new HashSet<ConnectPoint>();
        if (connectPointsJson != null) {
            for (int i = 0; i < connectPointsJson.size(); i++) {
                log.info("[decode] Reading first ConnectPoint");
                egressCp.add(connectPointCodec.decode(get(connectPointsJson, i), context));
            }
            builder.egressPoints(egressCp);
        }
    }
    return builder.build();
}
#method_after
@Override
public SinglePointToMultiPointIntent decode(ObjectNode json, CodecContext context) {
    SinglePointToMultiPointIntent.Builder builder = SinglePointToMultiPointIntent.builder();
    IntentCodec.intentAttributes(json, context, builder);
    ConnectivityIntentCodec.intentAttributes(json, context, builder);
    ObjectNode ingressJson = nullIsIllegal(get(json, INGRESS_POINT), INGRESS_POINT + IntentCodec.MISSING_MEMBER_MESSAGE);
    ConnectPoint ingress = context.codec(ConnectPoint.class).decode(ingressJson, context);
    builder.ingressPoint(ingress);
    ObjectNode egressJson = nullIsIllegal(get(json, EGRESS_POINT), EGRESS_POINT + IntentCodec.MISSING_MEMBER_MESSAGE);
    if (egressJson != null) {
        final JsonCodec<ConnectPoint> connectPointCodec = context.codec(ConnectPoint.class);
        JsonNode connectPointsJson = get(json, EGRESS_POINT).get(CP_POINTS);
        Set<ConnectPoint> egressCp = new HashSet<ConnectPoint>();
        if (connectPointsJson != null) {
            for (int i = 0; i < connectPointsJson.size(); i++) {
                egressCp.add(connectPointCodec.decode(get(connectPointsJson, i), context));
            }
            builder.egressPoints(egressCp);
        }
    }
    return builder.build();
}
#end_block

#method_before
private Response getResponse(DeviceId device, String request, InputStream payload, String mediaType) {
    WebTarget wt = getWebTarget(device, request);
    String type;
    switch(mediaType) {
        case XML:
            type = MediaType.APPLICATION_XML;
            break;
        case JSON:
            type = MediaType.APPLICATION_JSON;
            break;
        default:
            throw new IllegalArgumentException("Unsupported media type " + mediaType);
    }
    Response response = null;
    if (payload != null) {
        try {
            response = wt.request(type).post(Entity.entity(IOUtils.toString(payload, StandardCharsets.UTF_8), type));
        } catch (IOException e) {
            log.error("Cannot do POST {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = wt.request(type).post(Entity.entity(null, type));
    }
    return response;
}
#method_after
private Response getResponse(DeviceId device, String request, InputStream payload, String mediaType) {
    String type = typeOfMediaType(mediaType);
    WebTarget wt = getWebTarget(device, request);
    Response response = null;
    if (payload != null) {
        try {
            response = wt.request(type).post(Entity.entity(IOUtils.toString(payload, StandardCharsets.UTF_8), type));
        } catch (IOException e) {
            log.error("Cannot do POST {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = wt.request(type).post(Entity.entity(null, type));
    }
    return response;
}
#end_block

#method_before
@Override
public boolean put(DeviceId device, String request, InputStream payload, String mediaType) {
    String type;
    switch(mediaType) {
        case XML:
            type = MediaType.APPLICATION_XML;
            break;
        case JSON:
            type = MediaType.APPLICATION_JSON;
            break;
        default:
            throw new IllegalArgumentException("Unsupported media type " + mediaType);
    }
    WebTarget wt = getWebTarget(device, request);
    Response response = null;
    if (payload != null) {
        try {
            response = wt.request(type).put(Entity.entity(IOUtils.toString(payload, StandardCharsets.UTF_8), type));
        } catch (IOException e) {
            log.error("Cannot do PUT {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = wt.request(type).put(Entity.entity(null, type));
    }
    return checkReply(response);
}
#method_after
@Override
public boolean put(DeviceId device, String request, InputStream payload, String mediaType) {
    String type = typeOfMediaType(mediaType);
    WebTarget wt = getWebTarget(device, request);
    Response response = null;
    if (payload != null) {
        try {
            response = wt.request(type).put(Entity.entity(IOUtils.toString(payload, StandardCharsets.UTF_8), type));
        } catch (IOException e) {
            log.error("Cannot do PUT {} request on device {} because can't read payload", request, device);
        }
    } else {
        response = wt.request(type).put(Entity.entity(null, type));
    }
    return checkReply(response);
}
#end_block

#method_before
@Override
public InputStream get(DeviceId device, String request, String mediaType) {
    WebTarget wt = getWebTarget(device, request);
    String type;
    switch(mediaType) {
        case XML:
            type = MediaType.APPLICATION_XML;
            break;
        case JSON:
            type = MediaType.APPLICATION_JSON;
            break;
        default:
            throw new IllegalArgumentException("Unsupported media type " + mediaType);
    }
    Response s = wt.request(type).get();
    if (checkReply(s)) {
        return new ByteArrayInputStream(s.readEntity((String.class)).getBytes(StandardCharsets.UTF_8));
    }
    return null;
}
#method_after
@Override
public InputStream get(DeviceId device, String request, String mediaType) {
    String type = typeOfMediaType(mediaType);
    WebTarget wt = getWebTarget(device, request);
    Response s = wt.request(type).get();
    if (checkReply(s)) {
        return new ByteArrayInputStream(s.readEntity((String.class)).getBytes(StandardCharsets.UTF_8));
    }
    return null;
}
#end_block

#method_before
@Override
public boolean patch(DeviceId device, String request, InputStream payload, String mediaType) {
    String type;
    switch(mediaType) {
        case XML:
            type = MediaType.APPLICATION_XML;
            break;
        case JSON:
            type = MediaType.APPLICATION_JSON;
            break;
        default:
            throw new IllegalArgumentException("Unsupported media type " + mediaType);
    }
    try {
        log.debug("Url request {} ", getUrlString(device, request));
        HttpPatch httprequest = new HttpPatch(getUrlString(device, request));
        if (deviceMap.get(device).username() != null) {
            String pwd = deviceMap.get(device).password() == null ? "" : COLON + deviceMap.get(device).password();
            String userPassword = deviceMap.get(device).username() + pwd;
            String base64string = Base64.getEncoder().encodeToString(userPassword.getBytes(StandardCharsets.UTF_8));
            httprequest.addHeader(AUTHORIZATION_PROPERTY, BASIC_AUTH_PREFIX + base64string);
        }
        if (payload != null) {
            StringEntity input = new StringEntity(IOUtils.toString(payload, StandardCharsets.UTF_8));
            input.setContentType(type);
            httprequest.setEntity(input);
        }
        CloseableHttpClient httpClient;
        if (deviceMap.containsKey(device) && deviceMap.get(device).protocol().equals(HTTPS)) {
            httpClient = getApacheSslBypassClient();
        } else {
            httpClient = HttpClients.createDefault();
        }
        int responseStatusCode = httpClient.execute(httprequest).getStatusLine().getStatusCode();
        return checkStatusCode(responseStatusCode);
    } catch (IOException | NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {
        log.error("Cannot do PATCH {} request on device {}", request, device, e);
    }
    return false;
}
#method_after
@Override
public boolean patch(DeviceId device, String request, InputStream payload, String mediaType) {
    String type = typeOfMediaType(mediaType);
    try {
        log.debug("Url request {} ", getUrlString(device, request));
        HttpPatch httprequest = new HttpPatch(getUrlString(device, request));
        if (deviceMap.get(device).username() != null) {
            String pwd = deviceMap.get(device).password() == null ? "" : COLON + deviceMap.get(device).password();
            String userPassword = deviceMap.get(device).username() + pwd;
            String base64string = Base64.getEncoder().encodeToString(userPassword.getBytes(StandardCharsets.UTF_8));
            httprequest.addHeader(AUTHORIZATION_PROPERTY, BASIC_AUTH_PREFIX + base64string);
        }
        if (payload != null) {
            StringEntity input = new StringEntity(IOUtils.toString(payload, StandardCharsets.UTF_8));
            input.setContentType(type);
            httprequest.setEntity(input);
        }
        CloseableHttpClient httpClient;
        if (deviceMap.containsKey(device) && deviceMap.get(device).protocol().equals(HTTPS)) {
            httpClient = getApacheSslBypassClient();
        } else {
            httpClient = HttpClients.createDefault();
        }
        int responseStatusCode = httpClient.execute(httprequest).getStatusLine().getStatusCode();
        return checkStatusCode(responseStatusCode);
    } catch (IOException | NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {
        log.error("Cannot do PATCH {} request on device {}", request, device, e);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean delete(DeviceId device, String request, InputStream payload, String mediaType) {
    String type;
    switch(mediaType) {
        case XML:
            type = MediaType.APPLICATION_XML;
            break;
        case JSON:
            type = MediaType.APPLICATION_JSON;
            break;
        default:
            throw new IllegalArgumentException("Unsupported media type " + mediaType);
    }
    WebTarget wt = getWebTarget(device, request);
    // FIXME: do we need to delete an entry by enclosing data in DELETE request?
    // wouldn't it be nice to use PUT to implement the similar concept?
    Response response = wt.request(type).delete();
    return checkReply(response);
}
#method_after
@Override
public boolean delete(DeviceId device, String request, InputStream payload, String mediaType) {
    String type = typeOfMediaType(mediaType);
    WebTarget wt = getWebTarget(device, request);
    // FIXME: do we need to delete an entry by enclosing data in DELETE request?
    // wouldn't it be nice to use PUT to implement the similar concept?
    Response response = wt.request(type).delete();
    return checkReply(response);
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    int appId = Integer.parseInt(string(payload, INTENT_APP_ID));
    String appName = string(payload, INTENT_APP_NAME);
    ApplicationId applicId = new DefaultApplicationId(appId, appName);
    long intentKey = Long.decode(string(payload, INTENT_KEY));
    Key key = Key.of(intentKey, applicId);
    log.debug("Attempting to select intent key={}", key);
    Intent intent = intentService.getIntent(key);
    if (intent == null) {
        log.debug("no such intent found!");
    } else {
        log.debug("Removing intent {}", key);
        intentService.withdraw(intent);
    }
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    Intent intent = findIntentByPayload(payload);
    if (intent == null) {
        log.warn("Unable to find intent from payload {}", payload);
    } else {
        log.debug("Removing intent {}", intent.key());
        intentService.withdraw(intent);
    }
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    int appId = Integer.parseInt(string(payload, APP_ID));
    String appName = string(payload, APP_NAME);
    ApplicationId applicId = new DefaultApplicationId(appId, appName);
    long intentKey = Long.decode(string(payload, KEY));
    Key key = Key.of(intentKey, applicId);
    log.debug("Attempting to select intent key={}", key);
    Intent intent = intentService.getIntent(key);
    if (intent == null) {
        log.debug("no such intent found!");
    } else {
        log.debug("starting to monitor intent {}", key);
        traffic.monitor(intent);
    }
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    Intent intent = findIntentByPayload(payload);
    if (intent == null) {
        log.warn("Unable to find intent from payload {}", payload);
    } else {
        log.debug("starting to monitor intent {}", intent.key());
        traffic.monitor(intent);
    }
}
#end_block

#method_before
public Type type() {
    return type;
}
#method_after
public PathIntent.ProtectionType type() {
    return type;
}
#end_block

#method_before
public Builder setType(FlowRuleIntent.Type type) {
    this.type = type;
    return this;
}
#method_after
public Builder setType(ProtectionType type) {
    this.type = type;
    return this;
}
#end_block

#method_before
public PathIntent build() {
    return new PathIntent(appId, key, selector, treatment, path, constraints, priority, type);
}
#method_after
public PathIntent build() {
    return new PathIntent(appId, key, selector, treatment, path, constraints, priority, type == null ? ProtectionType.PRIMARY : type);
}
#end_block

#method_before
public FlowRuleIntent.Type type() {
    return type;
}
#method_after
public ProtectionType type() {
    return type;
}
#end_block

#method_before
@Override
public List<Intent> compile(PointToPointIntent intent, List<Intent> installable) {
    ConnectPoint ingressPoint = intent.ingressPoint();
    ConnectPoint egressPoint = intent.egressPoint();
    if (ingressPoint.deviceId().equals(egressPoint.deviceId())) {
        List<Link> links = asList(createEdgeLink(ingressPoint, true), createEdgeLink(egressPoint, false));
        return asList(createPathIntent(new DefaultPath(PID, links, DEFAULT_COST), intent, FlowRuleIntent.Type.PRIMARY));
    }
    // proceed with no protected paths
    if (!ProtectionConstraint.createProtectedPath(intent)) {
        List<Link> links = new ArrayList<>();
        Path path = getPath(intent, ingressPoint.deviceId(), egressPoint.deviceId());
        links.add(createEdgeLink(ingressPoint, true));
        links.addAll(path.links());
        links.add(createEdgeLink(egressPoint, false));
        return asList(createPathIntent(new DefaultPath(PID, links, path.cost(), path.annotations()), intent, FlowRuleIntent.Type.PRIMARY));
    }
    // attempt to compute and implement backup paths
    try {
        // FIXME currently getDisjointPath throws NullPointerException when
        // there don't exist two paths. I expect this will be fixed, but
        // catching the exception is my solution for now.
        DisjointPath path = getDisjointPath(intent, ingressPoint.deviceId(), egressPoint.deviceId());
        List<Intent> oldIntentList = new ArrayList<>();
        if (installable != null) {
            oldIntentList.addAll(installable);
            cleanUpInstallables(oldIntentList);
        }
        List<Intent> intentList = new ArrayList<>();
        // primary path intent
        List<Link> links = new ArrayList<>();
        links.addAll(path.links());
        links.add(createEdgeLink(egressPoint, false));
        // backup path intent
        List<Link> backupLinks = new ArrayList<>();
        backupLinks.addAll(path.backup().links());
        backupLinks.add(createEdgeLink(egressPoint, false));
        // and modify the failover group treatment accordingly.
        if (oldIntentList.size() > 1) {
            // entirely disjoint from the old path.
            if (!links.get(0).src().port().equals(primaryPort)) {
                backupPort = links.get(0).src().port();
                oldIntentList.add(createPathIntent(new DefaultPath(PID, links, path.cost(), path.annotations()), intent, FlowRuleIntent.Type.BACKUP));
                updateFailoverGroup(intent, links);
                return oldIntentList;
            } else {
                backupPort = backupLinks.get(0).src().port();
                oldIntentList.add(createPathIntent(new DefaultPath(PID, backupLinks, path.backup().cost(), path.backup().annotations()), intent, FlowRuleIntent.Type.BACKUP));
                updateFailoverGroup(intent, backupLinks);
                return oldIntentList;
            }
        }
        primaryPort = links.get(0).src().port();
        backupPort = backupLinks.get(0).src().port();
        intentList.add(createPathIntent(new DefaultPath(PID, links, path.cost(), path.annotations()), intent, FlowRuleIntent.Type.PRIMARY));
        intentList.add(createPathIntent(new DefaultPath(PID, backupLinks, path.backup().cost(), path.backup().annotations()), intent, FlowRuleIntent.Type.BACKUP));
        if (installable == null) {
            // manufactured fast failover flow rule intent
            createFailoverTreatmentGroup(path.links(), path.backup().links(), intent);
            FlowRuleIntent frIntent = new FlowRuleIntent(intent.appId(), createFlowRules(intent), asList(ingressPoint.deviceId()), FlowRuleIntent.Type.FAILOVER);
            intentList.add(frIntent);
        } else {
            updateFailoverGroup(intent, links);
            updateFailoverGroup(intent, backupLinks);
        }
        return intentList;
    } catch (NullPointerException e) {
        // no disjoint path extant -- maximum one path exists between devices
        List<Link> links = new ArrayList<>();
        Path onlyPath = getPath(intent, ingressPoint.deviceId(), egressPoint.deviceId());
        List<Intent> oldIntentList = new ArrayList<>();
        if (installable != null) {
            oldIntentList.addAll(installable);
            cleanUpInstallables(oldIntentList);
        }
        // return the intents that comprise it.
        if (oldIntentList.size() > 1) {
            return oldIntentList;
        } else {
            links.add(createEdgeLink(ingressPoint, true));
            links.addAll(onlyPath.links());
            links.add(createEdgeLink(egressPoint, false));
            primaryPort = links.get(0).src().port();
            backupPort = null;
            return asList(createPathIntent(new DefaultPath(PID, links, onlyPath.cost(), onlyPath.annotations()), intent, FlowRuleIntent.Type.PRIMARY));
        }
    }
}
#method_after
@Override
public List<Intent> compile(PointToPointIntent intent, List<Intent> installable) {
    ConnectPoint ingressPoint = intent.ingressPoint();
    ConnectPoint egressPoint = intent.egressPoint();
    if (ingressPoint.deviceId().equals(egressPoint.deviceId())) {
        return createZeroHopIntent(ingressPoint, egressPoint, intent);
    }
    // proceed with no protected paths
    if (!ProtectionConstraint.requireProtectedPath(intent)) {
        return createUnprotectedIntent(ingressPoint, egressPoint, intent);
    }
    try {
        // attempt to compute and implement backup path
        return createProtectedIntent(ingressPoint, egressPoint, intent, installable);
    } catch (PathNotFoundException e) {
        // no disjoint path extant -- maximum one path exists between devices
        return createSinglePathIntent(ingressPoint, egressPoint, intent, installable);
    }
}
#end_block

#method_before
private Intent createPathIntent(Path path, PointToPointIntent intent, FlowRuleIntent.Type type) {
    return PathIntent.builder().appId(intent.appId()).selector(intent.selector()).treatment(intent.treatment()).path(path).constraints(intent.constraints()).priority(intent.priority()).setType(type).build();
}
#method_after
private Intent createPathIntent(Path path, PointToPointIntent intent, PathIntent.ProtectionType type) {
    return PathIntent.builder().appId(intent.appId()).selector(intent.selector()).treatment(intent.treatment()).path(path).constraints(intent.constraints()).priority(intent.priority()).setType(type).build();
}
#end_block

#method_before
private GroupKey makeGroupKey(DeviceId deviceId) {
    return new DefaultGroupKey(deviceId.toString().getBytes());
}
#method_after
public static GroupKey makeGroupKey(IntentId intentId) {
    ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
    buffer.putLong(intentId.fingerprint());
    return new DefaultGroupKey(buffer.array());
}
#end_block

#method_before
private void createFailoverTreatmentGroup(List<Link> links, List<Link> backupLinks, PointToPointIntent intent) {
    List<GroupBucket> buckets = new ArrayList<>();
    TrafficTreatment.Builder tBuilderIn = DefaultTrafficTreatment.builder();
    ConnectPoint src = links.get(0).src();
    tBuilderIn.setOutput(src.port());
    TrafficTreatment.Builder tBuilderIn2 = DefaultTrafficTreatment.builder();
    ConnectPoint src2 = backupLinks.get(0).src();
    tBuilderIn2.setOutput(src2.port());
    buckets.add(DefaultGroupBucket.createFailoverGroupBucket(tBuilderIn.build(), src.port(), null));
    buckets.add(DefaultGroupBucket.createFailoverGroupBucket(tBuilderIn2.build(), src2.port(), null));
    GroupBuckets groupBuckets = new GroupBuckets(buckets);
    GroupDescription groupDesc = new DefaultGroupDescription(src.deviceId(), Group.Type.FAILOVER, groupBuckets, makeGroupKey(src.deviceId()), null, intent.appId());
    groupService.addGroup(groupDesc);
}
#method_after
private void createFailoverTreatmentGroup(List<Link> links, List<Link> backupLinks, PointToPointIntent intent) {
    List<GroupBucket> buckets = new ArrayList<>();
    TrafficTreatment.Builder tBuilderIn = DefaultTrafficTreatment.builder();
    ConnectPoint src = links.get(0).src();
    tBuilderIn.setOutput(src.port());
    TrafficTreatment.Builder tBuilderIn2 = DefaultTrafficTreatment.builder();
    ConnectPoint src2 = backupLinks.get(0).src();
    tBuilderIn2.setOutput(src2.port());
    buckets.add(DefaultGroupBucket.createFailoverGroupBucket(tBuilderIn.build(), src.port(), null));
    buckets.add(DefaultGroupBucket.createFailoverGroupBucket(tBuilderIn2.build(), src2.port(), null));
    GroupBuckets groupBuckets = new GroupBuckets(buckets);
    GroupDescription groupDesc = new DefaultGroupDescription(src.deviceId(), Group.Type.FAILOVER, groupBuckets, makeGroupKey(intent.id()), null, intent.appId());
    groupService.addGroup(groupDesc);
}
#end_block

#method_before
private boolean setPathsToRemove(Intent intent) {
    if (intent instanceof FlowRuleIntent) {
        FlowRuleIntent frIntent = (FlowRuleIntent) intent;
        FlowRuleIntent.Type type = frIntent.type();
        if (type == FlowRuleIntent.Type.PRIMARY || type == FlowRuleIntent.Type.FAILOVER) {
            erasePrimary = true;
        }
        if (type == FlowRuleIntent.Type.BACKUP || type == FlowRuleIntent.Type.FAILOVER) {
            eraseBackup = true;
        }
    }
    return erasePrimary && eraseBackup;
}
#method_after
private boolean setPathsToRemove(Intent intent) {
    if (intent instanceof FlowRuleIntent) {
        FlowRuleIntent frIntent = (FlowRuleIntent) intent;
        PathIntent.ProtectionType type = frIntent.type();
        if (type == PathIntent.ProtectionType.PRIMARY || type == PathIntent.ProtectionType.FAILOVER) {
            erasePrimary = true;
        }
        if (type == PathIntent.ProtectionType.BACKUP || type == PathIntent.ProtectionType.FAILOVER) {
            eraseBackup = true;
        }
    }
    return erasePrimary && eraseBackup;
}
#end_block

#method_before
private void removeAndUpdateIntents(List<Intent> cleanUpIntents) {
    Iterator<Intent> iterator = cleanUpIntents.iterator();
    while (iterator.hasNext()) {
        Intent cIntent = iterator.next();
        if (cIntent instanceof FlowRuleIntent) {
            FlowRuleIntent fIntent = (FlowRuleIntent) cIntent;
            if (fIntent.type() == FlowRuleIntent.Type.PRIMARY && erasePrimary) {
                // remove primary path's flow rule intents
                iterator.remove();
                primaryPort = null;
            } else if (fIntent.type() == FlowRuleIntent.Type.BACKUP && eraseBackup) {
                // remove backup path's flow rule intents
                iterator.remove();
                backupPort = null;
            } else if (fIntent.type() == FlowRuleIntent.Type.BACKUP && erasePrimary) {
                // promote backup path's flow rule intents to primary
                fIntent.setType(FlowRuleIntent.Type.PRIMARY);
                primaryPort = backupPort;
                backupPort = null;
            } else if (fIntent.type() == FlowRuleIntent.Type.FAILOVER) {
                updateFailoverGroup(fIntent);
            }
        }
    }
}
#method_after
private void removeAndUpdateIntents(List<Intent> cleanUpIntents, PointToPointIntent pointIntent) {
    ListIterator<Intent> iterator = cleanUpIntents.listIterator();
    while (iterator.hasNext()) {
        Intent cIntent = iterator.next();
        if (cIntent instanceof FlowRuleIntent) {
            FlowRuleIntent fIntent = (FlowRuleIntent) cIntent;
            if (fIntent.type() == PathIntent.ProtectionType.PRIMARY && erasePrimary) {
                // remove primary path's flow rule intents
                iterator.remove();
            } else if (fIntent.type() == PathIntent.ProtectionType.BACKUP && eraseBackup) {
                // remove backup path's flow rule intents
                iterator.remove();
            } else if (fIntent.type() == PathIntent.ProtectionType.BACKUP && erasePrimary) {
                // promote backup path's flow rule intents to primary
                iterator.set(new FlowRuleIntent(fIntent, PathIntent.ProtectionType.PRIMARY));
            }
        }
    }
    // remove buckets whose watchports are disabled if the failover group exists
    Group group = groupService.getGroup(pointIntent.ingressPoint().deviceId(), makeGroupKey(pointIntent.id()));
    if (group != null) {
        updateFailoverGroup(pointIntent);
    }
}
#end_block

#method_before
// Adds failover group bucket with treatment outport determined by the
private void updateFailoverGroup(PointToPointIntent intent, List<Link> links) {
    DeviceId deviceId = intent.ingressPoint().deviceId();
    GroupKey groupKey = new DefaultGroupKey(deviceId.toString().getBytes());
    TrafficTreatment.Builder tBuilderIn = DefaultTrafficTreatment.builder();
    ConnectPoint src = links.get(0).src();
    tBuilderIn.setOutput(src.port());
    GroupBucket bucket = DefaultGroupBucket.createFailoverGroupBucket(tBuilderIn.build(), src.port(), null);
    GroupBuckets addBuckets = new GroupBuckets(Collections.singletonList(bucket));
    groupService.addBucketsToGroup(src.deviceId(), groupKey, addBuckets, groupKey, intent.appId());
    groupKey.key();
}
#method_after
// Removes buckets whose treatments rely on disabled ports from the
private void updateFailoverGroup(PointToPointIntent pointIntent) {
    DeviceId deviceId = pointIntent.ingressPoint().deviceId();
    GroupKey groupKey = makeGroupKey(pointIntent.id());
    Group group = groupService.getGroup(deviceId, groupKey);
    Iterator<GroupBucket> groupIterator = group.buckets().buckets().iterator();
    while (groupIterator.hasNext()) {
        GroupBucket bucket = groupIterator.next();
        Instruction individualInstruction = bucket.treatment().allInstructions().get(0);
        if (individualInstruction instanceof Instructions.OutputInstruction) {
            Instructions.OutputInstruction outInstruction = (Instructions.OutputInstruction) individualInstruction;
            Port port = deviceService.getPort(deviceId, outInstruction.port());
            if (port == null || !port.isEnabled()) {
                GroupBuckets removeBuckets = new GroupBuckets(Collections.singletonList(bucket));
                groupService.removeBucketsFromGroup(deviceId, groupKey, removeBuckets, groupKey, pointIntent.appId());
            }
        }
    }
}
#end_block

#method_before
// Adds failover group bucket with treatment outport determined by the
private void updateFailoverGroup(PointToPointIntent intent, List<Link> links) {
    DeviceId deviceId = intent.ingressPoint().deviceId();
    GroupKey groupKey = new DefaultGroupKey(deviceId.toString().getBytes());
    TrafficTreatment.Builder tBuilderIn = DefaultTrafficTreatment.builder();
    ConnectPoint src = links.get(0).src();
    tBuilderIn.setOutput(src.port());
    GroupBucket bucket = DefaultGroupBucket.createFailoverGroupBucket(tBuilderIn.build(), src.port(), null);
    GroupBuckets addBuckets = new GroupBuckets(Collections.singletonList(bucket));
    groupService.addBucketsToGroup(src.deviceId(), groupKey, addBuckets, groupKey, intent.appId());
    groupKey.key();
}
#method_after
// Adds failover group bucket with treatment outport determined by the
private void updateFailoverGroup(PointToPointIntent intent, List<Link> links) {
    GroupKey groupKey = makeGroupKey(intent.id());
    TrafficTreatment.Builder tBuilderIn = DefaultTrafficTreatment.builder();
    ConnectPoint src = links.get(0).src();
    tBuilderIn.setOutput(src.port());
    GroupBucket bucket = DefaultGroupBucket.createFailoverGroupBucket(tBuilderIn.build(), src.port(), null);
    GroupBuckets addBuckets = new GroupBuckets(Collections.singletonList(bucket));
    groupService.addBucketsToGroup(src.deviceId(), groupKey, addBuckets, groupKey, intent.appId());
}
#end_block

#method_before
@Override
public final void sendMsg(OFMessage m) {
    List<OFMessage> messages = new LinkedList<>();
    messages.add(m);
    if (m.getType() == OFType.STATS_REQUEST) {
        OFStatsRequest sr = (OFStatsRequest) m;
        log.debug("OPLK ROADM rebuilding stats request type {}", sr.getStatsType());
        switch(sr.getStatsType()) {
            case PORT:
                // replace with Oplink experiment stats message to get the port current power
                OFOplinkPortPowerRequest powerRequest = this.factory().buildOplinkPortPowerRequest().setXid(sr.getXid()).setFlags(sr.getFlags()).build();
                messages.add(powerRequest);
                OFExpPortAdjacencyRequest adjacencyRequest = this.factory().buildExpPortAdjacencyRequest().setXid(sr.getXid()).setFlags(sr.getFlags()).build();
                messages.add(adjacencyRequest);
                break;
            default:
                break;
        }
    } else {
        log.debug("OPLK ROADM sends msg:{}, as is", m.getType());
    }
    for (OFMessage message : messages) {
        super.sendMsg(message);
    }
}
#method_after
@Override
public final void sendMsg(OFMessage m) {
    List<OFMessage> messages = new ArrayList<>();
    messages.add(m);
    if (m.getType() == OFType.STATS_REQUEST) {
        OFStatsRequest sr = (OFStatsRequest) m;
        log.debug("OPLK ROADM rebuilding stats request type {}", sr.getStatsType());
        switch(sr.getStatsType()) {
            case PORT:
                // replace with Oplink experiment stats message to get the port current power
                OFOplinkPortPowerRequest powerRequest = this.factory().buildOplinkPortPowerRequest().setXid(sr.getXid()).setFlags(sr.getFlags()).build();
                messages.add(powerRequest);
                OFExpPortAdjacencyRequest adjacencyRequest = this.factory().buildExpPortAdjacencyRequest().setXid(sr.getXid()).setFlags(sr.getFlags()).build();
                messages.add(adjacencyRequest);
                break;
            default:
                break;
        }
    } else {
        log.debug("OPLK ROADM sends msg:{}, as is", m.getType());
    }
    for (OFMessage message : messages) {
        super.sendMsg(message);
    }
}
#end_block

#method_before
private List<PortDescription> buildPortPowerDescriptions(List<OFOplinkPortPower> portPowers) {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    List<Port> ports = deviceService.getPorts(this.data().deviceId());
    HashMap<Long, OFOplinkPortPower> powerMap = new HashMap<>(portPowers.size());
    portPowers.forEach(power -> powerMap.put((long) power.getPort(), power));
    final List<PortDescription> portDescs = new ArrayList<>();
    for (Port port : ports) {
        DefaultAnnotations.Builder builder = DefaultAnnotations.builder();
        builder.putAll(port.annotations());
        OFOplinkPortPower power = powerMap.get(port.number().toLong());
        if (power != null) {
            builder.set(AnnotationKeys.CURRENT_POWER, Long.toString(power.getPowerValue()));
        }
        portDescs.add(new DefaultPortDescription(port.number(), port.isEnabled(), port.type(), port.portSpeed(), builder.build()));
    }
    return portDescs;
}
#method_after
private List<PortDescription> buildPortPowerDescriptions(List<OFOplinkPortPower> portPowers) {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    List<Port> ports = deviceService.getPorts(this.data().deviceId());
    HashMap<Long, OFOplinkPortPower> powerMap = new HashMap<>(portPowers.size());
    portPowers.forEach(power -> powerMap.put((long) power.getPort(), power));
    final List<PortDescription> portDescs = new ArrayList<>();
    for (Port port : ports) {
        DefaultAnnotations.Builder builder = DefaultAnnotations.builder();
        builder.putAll(port.annotations());
        OFOplinkPortPower power = powerMap.get(port.number().toLong());
        if (power != null) {
            builder.set(OpticalAnnotations.CURRENT_POWER, Long.toString(power.getPowerValue()));
        }
        portDescs.add(new DefaultPortDescription(port.number(), port.isEnabled(), port.type(), port.portSpeed(), builder.build()));
    }
    return portDescs;
}
#end_block

#method_before
private OplinkPortAdjacency getNeighbor(OFExpPortAdjacency ad) {
    for (OFExpPortAdjacencyId adid : ad.getProperties()) {
        List<OFExpExtAdId> otns = adid.getAdId();
        if (otns != null && otns.size() > 0) {
            OFExpPortAdidOtn otn = (OFExpPortAdidOtn) otns.get(0);
            // ITU-T G.7714 ETH MAC Format (in second 16 bytes of the following)
            // |---------------------------------------------------------------------------|
            // | Other format (16 bytes)                                                   |
            // |---------------------------------------------------------------------------|
            // | Header (2 bytes) | ID (4 bits) | MAC (6 bytes) | Port (4 bytes) | Unused  |
            // |---------------------------------------------------------------------------|
            ChannelBuffer buffer = ChannelBuffers.buffer(32);
            otn.getOpspec().write32Bytes(buffer);
            long mac = buffer.getLong(18) << 4 >>> 16;
            int port = (int) (buffer.getLong(24) << 4 >>> 32);
            return new OplinkPortAdjacency(mac, port);
        }
    }
    return null;
}
#method_after
private OplinkPortAdjacency getNeighbor(OFExpPortAdjacency ad) {
    for (OFExpPortAdjacencyId adid : ad.getProperties()) {
        List<OFExpExtAdId> otns = adid.getAdId();
        if (otns != null && otns.size() > 0) {
            OFExpPortAdidOtn otn = (OFExpPortAdidOtn) otns.get(0);
            // ITU-T G.7714 ETH MAC Format (in second 16 bytes of the following)
            // |---------------------------------------------------------------------------|
            // | Other format (16 bytes)                                                   |
            // |---------------------------------------------------------------------------|
            // | Header (2 bytes) | ID (4 bits) | MAC (6 bytes) | Port (4 bytes) | Unused  |
            // |---------------------------------------------------------------------------|
            ChannelBuffer buffer = ChannelBuffers.buffer(32);
            otn.getOpspec().write32Bytes(buffer);
            long mac = buffer.getLong(18) << 4 >>> 16;
            int port = (int) (buffer.getLong(24) << 4 >>> 32);
            // constructed from MAC address
            return new OplinkPortAdjacency(DeviceId.deviceId(Dpid.uri(new Dpid(mac))), PortNumber.portNumber(port));
        }
    }
    return null;
}
#end_block

#method_before
private List<PortDescription> buildPortAdjacencyDescriptions(List<OFExpPortAdjacency> portAds) {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    List<Port> ports = deviceService.getPorts(this.data().deviceId());
    // Map port's number with port's adjacency
    HashMap<Long, OFExpPortAdjacency> adMap = new HashMap<>(portAds.size());
    portAds.forEach(ad -> adMap.put((long) ad.getPortNo().getPortNumber(), ad));
    List<PortDescription> portDescs = new ArrayList<>();
    for (Port port : ports) {
        DefaultAnnotations.Builder builder = DefaultAnnotations.builder();
        Annotations oldAnnotations = port.annotations();
        builder.putAll(oldAnnotations);
        OFExpPortAdjacency ad = adMap.get(port.number().toLong());
        if (ad != null) {
            // neighbor discovered, add to port descriptions
            OplinkPortAdjacency neighbor = getNeighbor(ad);
            String newMac = Long.toHexString(neighbor.getMac());
            String newPort = Integer.toString(neighbor.getPort());
            // Check if annotation already exists
            if (!newMac.equals(oldAnnotations.value(AnnotationKeys.NEIGHBOR_MAC)) || !newPort.equals(oldAnnotations.value(AnnotationKeys.NEIGHBOR_PORT))) {
                builder.set(AnnotationKeys.NEIGHBOR_MAC, newMac);
                builder.set(AnnotationKeys.NEIGHBOR_PORT, newPort);
            }
            addLink(port, neighbor);
        } else {
            // no neighbors found
            builder.remove(AnnotationKeys.NEIGHBOR_MAC);
            builder.remove(AnnotationKeys.NEIGHBOR_PORT);
            removeLink(port);
        }
        portDescs.add(new DefaultPortDescription(port.number(), port.isEnabled(), port.type(), port.portSpeed(), builder.build()));
    }
    return portDescs;
}
#method_after
private List<PortDescription> buildPortAdjacencyDescriptions(List<OFExpPortAdjacency> portAds) {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    List<Port> ports = deviceService.getPorts(this.data().deviceId());
    // Map port's number with port's adjacency
    HashMap<Long, OFExpPortAdjacency> adMap = new HashMap<>(portAds.size());
    portAds.forEach(ad -> adMap.put((long) ad.getPortNo().getPortNumber(), ad));
    List<PortDescription> portDescs = new ArrayList<>();
    for (Port port : ports) {
        DefaultAnnotations.Builder builder = DefaultAnnotations.builder();
        Annotations oldAnnotations = port.annotations();
        builder.putAll(oldAnnotations);
        OFExpPortAdjacency ad = adMap.get(port.number().toLong());
        if (ad != null) {
            // neighbor discovered, add to port descriptions
            OplinkPortAdjacency neighbor = getNeighbor(ad);
            String newId = neighbor.getDeviceId().toString();
            String newPort = neighbor.getPort().toString();
            // Check if annotation already exists
            if (!newId.equals(oldAnnotations.value(OpticalAnnotations.NEIGHBOR_ID)) || !newPort.equals(oldAnnotations.value(OpticalAnnotations.NEIGHBOR_PORT))) {
                builder.set(OpticalAnnotations.NEIGHBOR_ID, newId);
                builder.set(OpticalAnnotations.NEIGHBOR_PORT, newPort);
            }
            addLink(port.number(), neighbor);
        } else {
            // no neighbors found
            builder.remove(OpticalAnnotations.NEIGHBOR_ID);
            builder.remove(OpticalAnnotations.NEIGHBOR_PORT);
            removeLink(port.number());
        }
        portDescs.add(new DefaultPortDescription(port.number(), port.isEnabled(), port.type(), port.portSpeed(), builder.build()));
    }
    return portDescs;
}
#end_block

#method_before
private void addLink(Port port, OplinkPortAdjacency neighbor) {
    ConnectPoint dst = new ConnectPoint(handler().data().deviceId(), port.number());
    ConnectPoint src = new ConnectPoint(DeviceId.deviceId(Dpid.uri(new Dpid(neighbor.getMac()))), PortNumber.portNumber(neighbor.getPort()));
    Link link = this.handler().get(LinkService.class).getLink(src, dst);
    // Check if link already exists
    if (link == null) {
        try {
            LinkProviderService linkProviderService = LinkProviderSingleton.getInstance(this.handler()).getService();
            linkProviderService.linkDetected(new DefaultLinkDescription(src, dst, Link.Type.OPTICAL));
        // linkProviderService.linkDetected(
        // new DefaultLinkDescription(dst, src, Link.Type.OPTICAL));
        } catch (IllegalStateException e) {
            // TODO consider moving this
            log.error("OPLK ROADM exception while adding links", e);
        }
    }
}
#method_after
private void addLink(PortNumber portNumber, OplinkPortAdjacency neighbor) {
    ConnectPoint dst = new ConnectPoint(handler().data().deviceId(), portNumber);
    ConnectPoint src = new ConnectPoint(neighbor.getDeviceId(), neighbor.portNumber);
    OpticalAdjacencyLinkService adService = this.handler().get(OpticalAdjacencyLinkService.class);
    adService.linkDetected(new DefaultLinkDescription(src, dst, Link.Type.OPTICAL));
}
#end_block

#method_before
private void removeLink(Port port) {
    ConnectPoint dst = new ConnectPoint(handler().data().deviceId(), port.number());
    Set<Link> links = this.handler().get(LinkService.class).getIngressLinks(dst);
    if (!links.isEmpty()) {
        LinkProviderService linkProviderService = LinkProviderSingleton.getInstance(this.handler()).getService();
        linkProviderService.linksVanished(dst);
    }
}
#method_after
private void removeLink(PortNumber portNumber) {
    ConnectPoint dst = new ConnectPoint(handler().data().deviceId(), portNumber);
    OpticalAdjacencyLinkService adService = this.handler().get(OpticalAdjacencyLinkService.class);
    adService.linksVanished(dst);
}
#end_block

#method_before
public int getPort() {
    return port;
}
#method_after
public PortNumber getPort() {
    return portNumber;
}
#end_block

#method_before
public boolean addImportInfo(JavaQualifiedTypeInfoTranslator newImportInfo, String className, String classPkg) {
    if (newImportInfo.getClassInfo().contentEquals(className)) {
        /*
             * if the current class name is same as the attribute class name,
             * then the attribute must be accessed in a qualified manner.
             */
        return true;
    } else if (newImportInfo.getPkgInfo() == null) {
        /*
             * If the package info is null, then it is not a candidate for import / qualified access
             */
        return false;
    }
    /*
         * If the attribute type is having the package info, it is contender
         * for import list and also need to check if it needs to be a
         * qualified access.
         */
    if (newImportInfo.getPkgInfo().contentEquals(classPkg)) {
        /*
             * Package of the referred attribute and the generated class is same, so no need import
             * or qualified access.
             */
        return false;
    }
    for (JavaQualifiedTypeInfoTranslator curImportInfo : getImportSet()) {
        if (curImportInfo.getClassInfo().contentEquals(newImportInfo.getClassInfo())) {
            return !curImportInfo.getPkgInfo().contentEquals(newImportInfo.getPkgInfo());
        }
    }
    /*
         * import is added, so it is a member for non qualified access
         */
    getImportSet().add(newImportInfo);
    return false;
}
#method_after
public boolean addImportInfo(JavaQualifiedTypeInfoTranslator newImportInfo, String className, String classPkg) {
    if (newImportInfo.getClassInfo().contentEquals(className)) {
        /*
             * If the current class name is same as the attribute class name,
             * then the attribute must be accessed in a qualified manner.
             */
        return true;
    } else if (newImportInfo.getPkgInfo() == null) {
        /*
             * If the package info is null, then it is not a candidate for import / qualified access
             */
        return false;
    }
    /*
         * If the attribute type is having the package info, it is contender
         * for import list and also need to check if it needs to be a
         * qualified access.
         */
    if (newImportInfo.getPkgInfo().contentEquals(classPkg)) {
        /*
             * Package of the referred attribute and the generated class is same, so no need import
             * or qualified access.
             */
        return false;
    }
    for (JavaQualifiedTypeInfoTranslator curImportInfo : getImportSet()) {
        if (curImportInfo.getClassInfo().contentEquals(newImportInfo.getClassInfo())) {
            return !curImportInfo.getPkgInfo().contentEquals(newImportInfo.getPkgInfo());
        }
    }
    /*
         * Import is added, so it is a member for non qualified access
         */
    getImportSet().add(newImportInfo);
    return false;
}
#end_block

#method_before
public void validate(DeviceId expectedDeviceId, List<GroupOperation> expectedGroupOps) {
    if (expectedGroupOps == null) {
        assertTrue("events generated", groupOperations.isEmpty());
        return;
    }
    assertEquals(lastDeviceIdProgrammable, expectedDeviceId);
    assertTrue((groupOperations.containsAll(expectedGroupOps) && expectedGroupOps.containsAll(groupOperations)));
    groupOperations.clear();
    lastDeviceIdProgrammable = null;
}
#method_after
public void validate(DeviceId expectedDeviceId, List<GroupOperation> expectedGroupOps) {
    if (expectedGroupOps == null) {
        assertTrue("events generated", groupOperations.isEmpty());
        return;
    }
    assertEquals(lastDeviceIdProgrammable, expectedDeviceId);
    assertTrue(groupOperations.containsAll(expectedGroupOps) && expectedGroupOps.containsAll(groupOperations));
    groupOperations.clear();
    lastDeviceIdProgrammable = null;
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = Tools.isPropertyEnabled(properties, "removeDupIpEnabled");
    if (flag == null) {
        log.info("Removal of duplicate ip address is not configured, using current value of {}", removeDupIpEnabled);
    } else {
        removeDupIpEnabled = flag;
        log.info("Configured. Removal of duplicate ip address is {}", removeDupIpEnabled ? "enabled" : "disabled");
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = Tools.isPropertyEnabled(properties, "allowDuplicateIps");
    if (flag == null) {
        log.info("Removal of duplicate ip address is not configured");
    } else {
        allowDuplicateIps = flag;
        log.info("Removal of duplicate ip address is {}", allowDuplicateIps ? "disabled" : "enabled");
    }
}
#end_block

#method_before
@Override
public void hostDetected(HostId hostId, HostDescription hostDescription, boolean replaceIps) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    hostDescription = validateHost(hostDescription, hostId);
    if (removeDupIpEnabled) {
        removeDuplicates(hostId, hostDescription);
    }
    store.createOrUpdateHost(provider().id(), hostId, hostDescription, replaceIps);
}
#method_after
@Override
public void hostDetected(HostId hostId, HostDescription hostDescription, boolean replaceIps) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    hostDescription = validateHost(hostDescription, hostId);
    if (!allowDuplicateIps) {
        removeDuplicates(hostId, hostDescription);
    }
    store.createOrUpdateHost(provider().id(), hostId, hostDescription, replaceIps);
}
#end_block

#method_before
private CarrierEthernetVirtualConnection validateEvc(CarrierEthernetVirtualConnection originalEvc) {
    // Make a copy of the provided EVC, since it may be modified
    CarrierEthernetVirtualConnection evc = originalEvc;
    // Try to set a unique numerical id for the EVC unless the EVC is being updated
    // FIXME: Check again the EVC update case
    evc.setShortId(generateEvcShortId());
    if (evc.shortId() == null) {
        log.error("No available EVC id found.");
        return null;
    }
    // Generate and set unique FC id
    evc.setId(generateEvcId(evc));
    // Verify that CE-VLAN ID is provided to either all UNIs or none and set the virtualEvc flag accordingly
    // Note: Checking also that all NIs are UNIs
    boolean isVirtual = false;
    Iterator<CarrierEthernetUni> it = evc.uniSet().iterator();
    while (it.hasNext()) {
        CarrierEthernetUni ni = it.next();
        if (ni.ceVlanId() == VlanId.NONE && isVirtual) {
            log.error("Could not validate the virtual status of the EVC.");
            return null;
        } else if (ni.ceVlanId() != VlanId.NONE) {
            isVirtual = true;
        }
    }
    evc.setIsVirtual(isVirtual);
    // Set unique id for the EVC unless the EVC is being updated
    if (evc.id() == null) {
        evc.setId(generateEvcId(evc));
    }
    Set<CarrierEthernetUni> validatedUniSet = new HashSet<>();
    // TODO: Refactor according to the validateFc method
    // Note: Cannot use the validateFc method here, because FCs can also be standalone
    // Check the UNIs of the EVC, possibly removing UNIs that are incompatible with existing global ones
    it = evc.uniSet().iterator();
    while (it.hasNext()) {
        CarrierEthernetUni uni = it.next();
        // Change the name of the UNI's BWP to the EVC name if it is an EVC BWP
        if (uni.bwp().type().equals(CarrierEthernetBandwidthProfile.Type.EVC)) {
            uni.bwp().setId(evc.id());
        }
        // Check first if corresponding global UNI already exists by checking against the global UNI Map
        if (uniMap.keySet().contains(uni.id())) {
            CarrierEthernetUni existingUni = uniMap.get(uni.id());
            // Check if the EVC-specific UNI is compatible with the global one
            if (!(existingUni.validateNi(uni))) {
                // If EVC is of ROOT_MULTIPOINT type and we have removed the root, return null
                if (evc.type() == CarrierEthernetVirtualConnection.Type.ROOT_MULTIPOINT && uni.role() == CarrierEthernetUni.Role.ROOT) {
                    log.error("Root UNI could not be added to %s EVC.", evc.type().name());
                    return null;
                }
                log.warn("UNI {} could not be added to EVC.", uni.id());
                continue;
            } else {
                // Add UNI to EVC
                validatedUniSet.add(uni);
            }
        } else {
            // Add UNI to EVC
            validatedUniSet.add(uni);
        }
    }
    // Update the EVC UNI set, based on the validated UNIs
    evc.setUniSet(validatedUniSet);
    if (evc.uniSet().size() > evc.maxNumUni()) {
        log.error("{} EVC can have at most {} UNIs.", evc.maxNumUni());
        return null;
    }
    if ((evc.type().equals(CarrierEthernetVirtualConnection.Type.ROOT_MULTIPOINT) || evc.type().equals(CarrierEthernetVirtualConnection.Type.MULTIPOINT_TO_MULTIPOINT)) && (evc.uniSet().size() < 2)) {
        log.error("{} EVC requires at least two UNIs.", evc.type().name());
        return null;
    }
    if (evc.type().equals(CarrierEthernetVirtualConnection.Type.POINT_TO_POINT) && (evc.uniSet().size() != 2)) {
        log.error("{} EVC requires exactly two UNIs.", evc.type().name());
        return null;
    }
    return evc;
}
#method_after
private CarrierEthernetVirtualConnection validateEvc(CarrierEthernetVirtualConnection originalEvc) {
    // Make a copy of the provided EVC, since it may be modified
    CarrierEthernetVirtualConnection evc = originalEvc;
    // Try to set a unique numerical id for the EVC unless the EVC is being updated
    // FIXME: Check again the EVC update case
    evc.setShortId(generateEvcShortId());
    if (evc.shortId() == null) {
        log.error("No available EVC id found.");
        return null;
    }
    // Generate and set unique FC id
    evc.setId(generateEvcId(evc));
    // Verify that CE-VLAN ID is provided to either all UNIs or none and set the virtualEvc flag accordingly
    // Note: Checking also that all NIs are UNIs
    boolean isVirtual = false;
    Iterator<CarrierEthernetUni> it = evc.uniSet().iterator();
    while (it.hasNext()) {
        CarrierEthernetUni ni = it.next();
        if (ni.ceVlanId() == VlanId.NONE && isVirtual) {
            log.error("Could not validate the virtual status of the EVC.");
            return null;
        } else if (ni.ceVlanId() != VlanId.NONE) {
            isVirtual = true;
        }
    }
    evc.setIsVirtual(isVirtual);
    // Set unique id for the EVC unless the EVC is being updated
    if (evc.id() == null) {
        evc.setId(generateEvcId(evc));
    }
    Set<CarrierEthernetUni> validatedUniSet = new HashSet<>();
    // TODO: Refactor according to the validateFc method
    // Note: Cannot use the validateFc method here, because FCs can also be standalone
    // Check the UNIs of the EVC, possibly removing UNIs that are incompatible with existing global ones
    it = evc.uniSet().iterator();
    while (it.hasNext()) {
        CarrierEthernetUni uni = it.next();
        // Change the name of the UNI's BWP to the EVC name if it is an EVC BWP
        if (uni.bwp().type().equals(CarrierEthernetBandwidthProfile.Type.EVC)) {
            uni.bwp().setId(evc.id());
        }
        // Check first if corresponding global UNI already exists by checking against the global UNI Map
        if (uniMap.keySet().contains(uni.id())) {
            CarrierEthernetUni existingUni = uniMap.get(uni.id());
            // Check if the EVC-specific UNI is compatible with the global one
            if (!(existingUni.validateEcNi(uni))) {
                // If EVC is of ROOT_MULTIPOINT type and we have removed the root, return null
                if (evc.type() == CarrierEthernetVirtualConnection.Type.ROOT_MULTIPOINT && uni.role() == CarrierEthernetUni.Role.ROOT) {
                    log.error("Root UNI could not be added to %s EVC.", evc.type().name());
                    return null;
                }
                log.warn("UNI {} could not be added to EVC.", uni.id());
                continue;
            } else {
                // Add UNI to EVC
                validatedUniSet.add(uni);
            }
        } else {
            // Add UNI to EVC
            validatedUniSet.add(uni);
        }
    }
    // Update the EVC UNI set, based on the validated UNIs
    evc.setUniSet(validatedUniSet);
    if (evc.uniSet().size() > evc.maxNumUni()) {
        log.error("{} EVC can have at most {} UNIs.", evc.maxNumUni());
        return null;
    }
    if ((evc.type().equals(CarrierEthernetVirtualConnection.Type.ROOT_MULTIPOINT) || evc.type().equals(CarrierEthernetVirtualConnection.Type.MULTIPOINT_TO_MULTIPOINT)) && (evc.uniSet().size() < 2)) {
        log.error("{} EVC requires at least two UNIs.", evc.type().name());
        return null;
    }
    if (evc.type().equals(CarrierEthernetVirtualConnection.Type.POINT_TO_POINT) && (evc.uniSet().size() != 2)) {
        log.error("{} EVC requires exactly two UNIs.", evc.type().name());
        return null;
    }
    return evc;
}
#end_block

#method_before
public CarrierEthernetVirtualConnection installEvc(CarrierEthernetVirtualConnection evc) {
    // If EVC already exists, remove it and reestablish with new parameters
    if (evc.id() != null && evcMap.containsKey(evc.id())) {
        return updateEvc(evc);
    } else {
        // id will be generated during validation below
        evc.setId(null);
    }
    if (validateEvc(evc) == null) {
        log.error("EVC could not be installed, please check log for details.");
        return null;
    }
    // TODO: Add configurable parameter to determine if fragmentation will take place
    if (evcFragmentationEnabled) {
        evc.setFcSet(fragmentEvc(evc));
    } else {
        evc.setFcSet(Collections.singleton(fcFromEvc(evc)));
    }
    // ////////////////////////////////////////////////////////////////////////////////////////////////
    // Assign VLAN ids to FCs
    // FIXME: This was supposed to be done in the validateFc method
    // TODO: If network configuration is present, get FC vlanIds from corresponding ports
    List<VlanId> tmpVlanIdList = new ArrayList<>();
    evc.fcSet().forEach(fc -> {
        fc.setVlanId(generateVlanId(tmpVlanIdList));
        tmpVlanIdList.add(fc.vlanId());
    });
    // For each INNI/ENNI of each FC, find the paired INNI/ENNI and assign S-TAG according to the other FC's vlanId
    for (CarrierEthernetForwardingConstruct fc : evc.fcSet()) {
        for (CarrierEthernetLogicalTerminationPoint ltp : fc.ltpSet()) {
            if (!ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                // Find the cp at the other end of the link
                Link link = linkService.getEgressLinks(ltp.ni().cp()).iterator().next();
                String ltpId = link.dst().deviceId().toString() + "/" + link.dst().port().toString();
                // Find the corresponding FC - assuming LTP ids are the same as connect point ids
                CarrierEthernetForwardingConstruct neighborFc = getFcFromLtpId(ltpId, evc.fcSet());
                if (neighborFc != null) {
                    if (ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.INNI)) {
                        ((CarrierEthernetInni) ltp.ni()).setSVlanId(neighborFc.vlanId());
                    } else if (ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.ENNI)) {
                        ((CarrierEthernetEnni) ltp.ni()).setSVlanId(neighborFc.vlanId());
                    }
                }
            }
        }
    }
    // Install the constituent FCs
    evc.fcSet().forEach(fc -> {
        // Increment the FC refCount
        fc.refCount().incrementAndGet();
        installFc(fc);
    });
    // Update the EVC UNI set based on the LTPs used during FC connectivity
    Set<CarrierEthernetUni> usedUniSet = new HashSet<>();
    evc.fcSet().forEach(fc -> usedUniSet.addAll(fc.uniSet()));
    evc.setUniSet(usedUniSet);
    // Determine EVC state based on the state of the constituent FCs
    // TODO: Simplify this?
    evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.FULL);
    Iterator<CarrierEthernetForwardingConstruct> fcIt = evc.fcSet().iterator();
    while (fcIt.hasNext()) {
        CarrierEthernetForwardingConstruct fc = fcIt.next();
        evc.setState(CarrierEthernetVirtualConnection.State.valueOf(fc.state().name()));
        if (evc.state().equals(CarrierEthernetVirtualConnection.State.INACTIVE)) {
            break;
        }
        if (fc.activeState().equals(CarrierEthernetConnection.ActiveState.PARTIAL)) {
            evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.valueOf(fc.activeState().name()));
        }
    }
    if (evc.state().equals(CarrierEthernetVirtualConnection.State.ACTIVE)) {
        // If EVC installation was successful, then register the EVC
        evcMap.put(evc.id(), evc);
    } else {
        // If EVC installation was not successful, then do not register the EVC and rollback FC installations
        evc.fcSet().forEach(fc -> {
            // Decrement the FC refCount to make removal possible
            fc.refCount().decrementAndGet();
            removeFc(fc.id());
        });
    }
    return evc;
}
#method_after
public CarrierEthernetVirtualConnection installEvc(CarrierEthernetVirtualConnection evc) {
    // If EVC already exists, remove it and reestablish with new parameters
    if (evc.id() != null && evcMap.containsKey(evc.id())) {
        return updateEvc(evc);
    } else {
        // id will be generated during validation below
        evc.setId(null);
    }
    if (validateEvc(evc) == null) {
        log.error("EVC could not be installed, please check log for details.");
        return null;
    }
    // TODO: Add configurable parameter to determine if fragmentation will take place
    if (evcFragmentationEnabled) {
        evc.setFcSet(fragmentEvc(evc));
    } else {
        evc.setFcSet(Collections.singleton(fcFromEvc(evc)));
    }
    // ////////////////////////////////////////////////////////////////////////////////////////////////
    // Assign VLAN ids to FCs
    // FIXME: This was supposed to be done in the validateFc method
    // FIXME: but we need a vlanId here already, so that S-TAGs can be assigned below among paired INNIs/ENNIs
    // TODO: If network configuration is present, get FC vlanIds from corresponding ports
    List<VlanId> tmpVlanIdList = new ArrayList<>();
    evc.fcSet().forEach(fc -> {
        fc.setVlanId(generateVlanId(tmpVlanIdList));
        tmpVlanIdList.add(fc.vlanId());
    });
    // For each INNI/ENNI of each FC, find the paired INNI/ENNI and assign S-TAG according to the other FC's vlanId
    for (CarrierEthernetForwardingConstruct fc : evc.fcSet()) {
        for (CarrierEthernetLogicalTerminationPoint ltp : fc.ltpSet()) {
            if (!ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                // Find the cp at the other end of the link
                Link link = linkService.getEgressLinks(ltp.ni().cp()).iterator().next();
                String ltpId = link.dst().deviceId().toString() + "/" + link.dst().port().toString();
                // Find the corresponding FC - assuming LTP ids are the same as connect point ids
                CarrierEthernetForwardingConstruct neighborFc = getFcFromLtpId(ltpId, evc.fcSet());
                if (neighborFc != null) {
                    if (ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.INNI)) {
                        ((CarrierEthernetInni) ltp.ni()).setSVlanId(neighborFc.vlanId());
                    } else if (ltp.ni().type().equals(CarrierEthernetNetworkInterface.Type.ENNI)) {
                        ((CarrierEthernetEnni) ltp.ni()).setSVlanId(neighborFc.vlanId());
                    }
                }
            }
        }
    }
    // Install the constituent FCs
    evc.fcSet().forEach(fc -> {
        // Increment the FC refCount
        fc.refCount().incrementAndGet();
        installFc(fc);
    });
    // Update the EVC UNI set based on the LTPs used during FC connectivity
    Set<CarrierEthernetUni> usedUniSet = new HashSet<>();
    evc.fcSet().forEach(fc -> usedUniSet.addAll(fc.uniSet()));
    evc.setUniSet(usedUniSet);
    // Determine EVC state based on the state of the constituent FCs
    evc.setState(CarrierEthernetVirtualConnection.State.ACTIVE);
    Iterator<CarrierEthernetForwardingConstruct> fcIt = evc.fcSet().iterator();
    while (fcIt.hasNext()) {
        CarrierEthernetForwardingConstruct fc = fcIt.next();
        evc.setState(CarrierEthernetVirtualConnection.State.valueOf(fc.state().name()));
        if (!evc.isActive()) {
            break;
        }
    }
    if (evc.isActive()) {
        // If EVC installation was successful, then register the EVC
        evcMap.put(evc.id(), evc);
    } else {
        // If EVC installation was not successful, then do not register the EVC and rollback FC installations
        evc.fcSet().forEach(fc -> {
            // Decrement the FC refCount to make removal possible
            fc.refCount().decrementAndGet();
            removeFc(fc.id());
        });
    }
    return evc;
}
#end_block

#method_before
Set<CarrierEthernetForwardingConstruct> fragmentEvc(CarrierEthernetVirtualConnection evc) {
    Set<CarrierEthernetForwardingConstruct> fcSet = new HashSet<>();
    // Each LTP can only belong to a single FC, hence using LTP_id -> LTP_set map
    Map<String, Set<CarrierEthernetLogicalTerminationPoint>> ltpSetMap = new HashMap<>();
    // Temporary set to browse through all EVC UNI pairs
    Set<CarrierEthernetUni> tempUniSet = new HashSet<>(evc.uniSet());
    Iterator<CarrierEthernetUni> uniIt1 = tempUniSet.iterator();
    while (uniIt1.hasNext()) {
        CarrierEthernetUni uni1 = uniIt1.next();
        // Iterate through all the remaining NIs
        Iterator<CarrierEthernetUni> uniIt2 = tempUniSet.iterator();
        while (uniIt2.hasNext()) {
            CarrierEthernetUni uni2 = uniIt2.next();
            // Skip equals
            if (uni1.equals(uni2)) {
                continue;
            }
            // Do not establish connectivity between leaf NIs (applies to Rooted_Multipoint)
            if (uni1.role().equals(CarrierEthernetUni.Role.LEAF) && uni2.role().equals(CarrierEthernetUni.Role.LEAF)) {
                continue;
            }
            // Calculate path assuming return paths are the same
            // TODO: Handle the congruent paths case?
            // TODO: Handle the case where uni1 and uni2 are on the same device
            Set<Path> paths;
            if (evc.type().equals(CarrierEthernetVirtualConnection.Type.POINT_TO_POINT)) {
                // For point-to-point connectivity use the pre-calculated paths
                // to make sure the shortest paths are chosen
                paths = pathService.getPaths(uni1.cp().deviceId(), uni2.cp().deviceId());
            } else {
                // Recalculate path so that it's over the pre-calculated spanning tree
                // FIXME: Find a more efficient way (avoid recalculating paths)
                paths = pathService.getPaths(uni1.cp().deviceId(), uni2.cp().deviceId(), new CarrierEthernetSpanningTreeWeight(topologyService));
            }
            // Just select any of the returned paths
            // TODO: Select path in more sophisticated way and return null if any of the constraints cannot be met
            Path path = paths.iterator().hasNext() ? paths.iterator().next() : null;
            if (path == null) {
                return null;
            }
            List<Link> links = new ArrayList<>();
            links.add(createEdgeLink(uni1.cp(), true));
            links.addAll(path.links());
            links.add(createEdgeLink(uni2.cp(), false));
            // Get LTP pairs of ingress/egress NIs along the link path
            // Note: INNIs should always appear in pairs
            List<Pair<CarrierEthernetLogicalTerminationPoint, CarrierEthernetLogicalTerminationPoint>> ltpPairList = new ArrayList<>();
            CarrierEthernetLogicalTerminationPoint srcLtp = null, dstLtp = null;
            // These are the roles that will be used for all pairs found below
            CarrierEthernetLogicalTerminationPoint.Role srcLtpRole, dstLtpRole;
            // The sources will always have the same role as the LTP from at the paths starts
            srcLtpRole = CarrierEthernetLogicalTerminationPoint.Role.valueOf((uni1).role().name());
            // The destinations will always have the same role as the LTP at which the path ends
            dstLtpRole = CarrierEthernetLogicalTerminationPoint.Role.valueOf((uni2).role().name());
            for (int i = 0; i < links.size(); i++) {
                // Try to get the destination LTP of a pair
                if (srcLtp != null && i != 0) {
                    // If this is the last, use existing EVC UNI, else create a new FC LTP and set Role
                    dstLtp = (i == links.size() - 1) ? new CarrierEthernetLogicalTerminationPoint(null, uni2) : fcLtpFromCp(links.get(i).src(), dstLtpRole);
                }
                if (dstLtp != null) {
                    // Create a new LTP pair and null the srcLtp so that we can continue searching for a new pair
                    ltpPairList.add(Pair.of(srcLtp, dstLtp));
                    srcLtp = null;
                }
                // Try to get the source LTP of a pair
                if (srcLtp == null && i != links.size() - 1) {
                    // If this is the first, use existing EVC UNI, else create a new FC LTP and set Role
                    srcLtp = (i == 0) ? new CarrierEthernetLogicalTerminationPoint(null, uni1) : fcLtpFromCp(links.get(i).dst(), srcLtpRole);
                }
            }
            // Go through all the LTP pairs found
            ltpPairList.forEach(ltpPair -> {
                CarrierEthernetLogicalTerminationPoint ltp1 = ltpPair.getLeft();
                CarrierEthernetLogicalTerminationPoint ltp2 = ltpPair.getRight();
                if (ltpSetMap.containsKey(ltp1.id()) && !ltpSetMap.containsKey(ltp2.id())) {
                    // If one of the LTPs is already contained in a set, add the other one as well in that set
                    ltpSetMap.get(ltp1.id()).add(ltp2);
                    ltpSetMap.put(ltp2.id(), ltpSetMap.get(ltp1.id()));
                } else if (ltpSetMap.containsKey(ltp2.id()) & !ltpSetMap.containsKey(ltp1.id())) {
                    // If one of the LTPs is already contained in a set, add the other one as well in that set
                    ltpSetMap.get(ltp2.id()).add(ltp1);
                    ltpSetMap.put(ltp1.id(), ltpSetMap.get(ltp2.id()));
                } else if (!ltpSetMap.containsKey(ltp1.id()) && !ltpSetMap.containsKey(ltp2.id())) {
                    // Create a new LTP set containing the two LTPs and map both to it
                    ltpSetMap.put(ltp1.id(), Sets.newHashSet(ltp1, ltp2));
                    ltpSetMap.put(ltp2.id(), ltpSetMap.get(ltp1.id()));
                }
            });
        }
        // Remove UNI from temporary set so that each pair is visited only once
        uniIt1.remove();
    }
    // Go through all unique LTP sets and create the corresponding FCs
    ltpSetMap.values().stream().collect(Collectors.toSet()).forEach(ltpSet -> {
        // Type is determined by number and type of LTPs in each set
        CarrierEthernetVirtualConnection.Type fcType = ltpSet.size() == 2 ? CarrierEthernetVirtualConnection.Type.POINT_TO_POINT : CarrierEthernetConnection.Type.MULTIPOINT_TO_MULTIPOINT;
        CarrierEthernetForwardingConstruct fc = new CarrierEthernetForwardingConstruct(null, null, null, ltpSet, null);
        // If one of the LTPs is LEAF, indicate FC as ROOT_MULTIPOINT
        for (CarrierEthernetLogicalTerminationPoint ltp : fc.ltpSet()) {
            if (ltp.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF)) {
                fcType = CarrierEthernetConnection.Type.ROOT_MULTIPOINT;
                break;
            }
        }
        fc.setType(fcType);
        fcSet.add(fc);
        log.info("Created ForwardingConstruct comprising LogicalTerminationPoints {}", ltpSet.stream().map(ltp -> ltp.id()).collect(Collectors.toList()));
    });
    return fcSet;
}
#method_after
Set<CarrierEthernetForwardingConstruct> fragmentEvc(CarrierEthernetVirtualConnection evc) {
    Set<CarrierEthernetForwardingConstruct> fcSet = new HashSet<>();
    // Each LTP can only belong to a single FC, hence using LTP_id -> LTP_set map
    Map<String, Set<CarrierEthernetLogicalTerminationPoint>> ltpSetMap = new HashMap<>();
    // Temporary set to browse through all EVC UNI pairs
    Set<CarrierEthernetUni> tempUniSet = new HashSet<>(evc.uniSet());
    Iterator<CarrierEthernetUni> uniIt1 = tempUniSet.iterator();
    while (uniIt1.hasNext()) {
        CarrierEthernetUni uni1 = uniIt1.next();
        // Iterate through all the remaining NIs
        Iterator<CarrierEthernetUni> uniIt2 = tempUniSet.iterator();
        while (uniIt2.hasNext()) {
            CarrierEthernetUni uni2 = uniIt2.next();
            // Skip equals
            if (uni1.equals(uni2)) {
                continue;
            }
            // Do not establish connectivity between leaf NIs (applies to Rooted_Multipoint)
            if (uni1.role().equals(CarrierEthernetUni.Role.LEAF) && uni2.role().equals(CarrierEthernetUni.Role.LEAF)) {
                continue;
            }
            // Calculate path assuming return paths are the same
            // TODO: Handle the congruent paths case?
            // TODO: Handle the case where uni1 and uni2 are on the same device
            Set<Path> paths;
            if (evc.type().equals(CarrierEthernetVirtualConnection.Type.POINT_TO_POINT)) {
                // For point-to-point connectivity use the pre-calculated paths
                // to make sure the shortest paths are chosen
                paths = pathService.getPaths(uni1.cp().deviceId(), uni2.cp().deviceId());
            } else {
                // Recalculate path so that it's over the pre-calculated spanning tree
                // FIXME: Find a more efficient way (avoid recalculating paths)
                paths = pathService.getPaths(uni1.cp().deviceId(), uni2.cp().deviceId(), new CarrierEthernetSpanningTreeWeight(topologyService));
            }
            // Just select any of the returned paths
            // TODO: Select path in more sophisticated way and return null if any of the constraints cannot be met
            Path path = paths.iterator().hasNext() ? paths.iterator().next() : null;
            if (path == null) {
                return null;
            }
            List<Link> links = new ArrayList<>();
            links.add(createEdgeLink(uni1.cp(), true));
            links.addAll(path.links());
            links.add(createEdgeLink(uni2.cp(), false));
            // /////////////////////////////////////////////////////////////////////////////////////////////
            // Get LTP pairs of ingress/egress NIs along the link path (non-LTP connect points are ignored)
            // /////////////////////////////////////////////////////////////////////////////////////////////
            // Note: INNIs should always appear in pairs
            List<Pair<CarrierEthernetLogicalTerminationPoint, CarrierEthernetLogicalTerminationPoint>> ltpPairList = new ArrayList<>();
            CarrierEthernetLogicalTerminationPoint srcLtp = null, dstLtp = null;
            // These are the roles that will be used for all pairs found below
            CarrierEthernetLogicalTerminationPoint.Role srcLtpRole, dstLtpRole;
            // The source in any pair will always have the same role as the LTP from which the paths starts
            srcLtpRole = CarrierEthernetLogicalTerminationPoint.Role.valueOf((uni1).role().name());
            // The destination in any pair will always have the same role as the LTP at which the path ends
            dstLtpRole = CarrierEthernetLogicalTerminationPoint.Role.valueOf((uni2).role().name());
            for (int i = 0; i < links.size(); i++) {
                // Try to get the destination LTP of a pair
                if (srcLtp != null && i != 0) {
                    // If this is the last, use existing EVC UNI, else create a new FC LTP and set Role
                    dstLtp = (i == links.size() - 1) ? new CarrierEthernetLogicalTerminationPoint(null, uni2) : fcLtpFromCp(links.get(i).src(), dstLtpRole);
                }
                if (dstLtp != null) {
                    // Create a new LTP pair and null the srcLtp so that we can continue searching for a new pair
                    ltpPairList.add(Pair.of(srcLtp, dstLtp));
                    srcLtp = null;
                }
                // Try to get the source LTP of a pair
                if (srcLtp == null && i != links.size() - 1) {
                    // If this is the first, use existing EVC UNI, else create a new FC LTP and set Role
                    srcLtp = (i == 0) ? new CarrierEthernetLogicalTerminationPoint(null, uni1) : fcLtpFromCp(links.get(i).dst(), srcLtpRole);
                }
            }
            // /////////////////////////////////////////////////////////////////////////////////////////////////////
            // Go through all the LTP pairs found and map each LTP to a set of LTPs (create it if it doesn't exist)
            // /////////////////////////////////////////////////////////////////////////////////////////////////////
            // Note: Each LTP can only belong to a single set, so each set will eventually correspond to an FC
            ltpPairList.forEach(ltpPair -> {
                CarrierEthernetLogicalTerminationPoint ltp1 = ltpPair.getLeft();
                CarrierEthernetLogicalTerminationPoint ltp2 = ltpPair.getRight();
                if (ltpSetMap.containsKey(ltp1.id()) && !ltpSetMap.containsKey(ltp2.id())) {
                    // If one of the LTPs is already contained in a set, add the other one as well in that set
                    ltpSetMap.get(ltp1.id()).add(ltp2);
                    ltpSetMap.put(ltp2.id(), ltpSetMap.get(ltp1.id()));
                } else if (ltpSetMap.containsKey(ltp2.id()) & !ltpSetMap.containsKey(ltp1.id())) {
                    // If one of the LTPs is already contained in a set, add the other one as well in that set
                    ltpSetMap.get(ltp2.id()).add(ltp1);
                    ltpSetMap.put(ltp1.id(), ltpSetMap.get(ltp2.id()));
                } else if (!ltpSetMap.containsKey(ltp1.id()) && !ltpSetMap.containsKey(ltp2.id())) {
                    // Create a new LTP set containing the two LTPs and map both to it
                    ltpSetMap.put(ltp1.id(), Sets.newHashSet(ltp1, ltp2));
                    ltpSetMap.put(ltp2.id(), ltpSetMap.get(ltp1.id()));
                }
            });
        }
        // Remove UNI from temporary set so that each pair is visited only once
        uniIt1.remove();
    }
    // ////////////////////////////////////////////////////////////////////////////////
    // Go through all unique LTP sets generated above and create the corresponding FCs
    // ////////////////////////////////////////////////////////////////////////////////
    ltpSetMap.values().stream().collect(Collectors.toSet()).forEach(ltpSet -> {
        // Type is determined by number and type of LTPs in each set
        CarrierEthernetVirtualConnection.Type fcType = ltpSet.size() == 2 ? CarrierEthernetVirtualConnection.Type.POINT_TO_POINT : CarrierEthernetConnection.Type.MULTIPOINT_TO_MULTIPOINT;
        CarrierEthernetForwardingConstruct fc = new CarrierEthernetForwardingConstruct(null, null, null, ltpSet, null);
        // If one of the LTPs is LEAF, indicate FC as ROOT_MULTIPOINT
        for (CarrierEthernetLogicalTerminationPoint ltp : fc.ltpSet()) {
            if (ltp.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF)) {
                fcType = CarrierEthernetConnection.Type.ROOT_MULTIPOINT;
                break;
            }
        }
        fc.setType(fcType);
        fcSet.add(fc);
        log.info("Created ForwardingConstruct comprising LogicalTerminationPoints {}", ltpSet.stream().map(ltp -> ltp.id()).collect(Collectors.toList()));
    });
    return fcSet;
}
#end_block

#method_before
private void applyFcToGlobalLtps(Set<CarrierEthernetLogicalTerminationPoint> ltpSet) {
    ltpSet.forEach(ltp -> {
        if (!(ltpMap.keySet().contains(ltp.id()))) {
            // Just add the LTP as it appears at the FC
            addGlobalLtp(ltp);
        } else {
            // Add LTP resources (BWP, CE-VLAN ID, S-TAG) to existing global LTP
            ltpMap.get(ltp.id()).ni().addNi(ltp.ni());
            // Update config identifier
            ltpMap.get(ltp.id()).ni().setCfgId(ltp.ni().cfgId());
        }
    });
}
#method_after
private void applyFcToGlobalLtps(Set<CarrierEthernetLogicalTerminationPoint> ltpSet) {
    ltpSet.forEach(ltp -> {
        if (!(ltpMap.keySet().contains(ltp.id()))) {
            // Just add the LTP as it appears at the FC
            addGlobalLtp(ltp);
        } else {
            // Add LTP resources (BWP, CE-VLAN ID, S-TAG) to existing global LTP
            ltpMap.get(ltp.id()).ni().addEcNi(ltp.ni());
            // Update config identifier
            ltpMap.get(ltp.id()).ni().setCfgId(ltp.ni().cfgId());
        }
    });
}
#end_block

#method_before
/**
 * Removes bandwidth profiles from the UNIs of an FC.
 *
 * @param fc the FC representation
 */
private void removeFcFromGlobalLtps(CarrierEthernetForwardingConstruct fc) {
    // TODO: Check if the bandwidth profile really needs to be removed (e.g. may be CoS)
    ceProvisioner.removeBandwidthProfiles(fc);
    // Remove LTP resources (BWP, CE-VLAN ID, S-TAG) from corresponding global LTPs
    fc.ltpSet().forEach(ltp -> ltpMap.get(ltp.id()).ni().removeNi(ltp.ni()));
}
#method_after
/**
 * Removes bandwidth profiles from the UNIs of an FC.
 *
 * @param fc the FC representation
 */
private void removeFcFromGlobalLtps(CarrierEthernetForwardingConstruct fc) {
    // TODO: Check if the bandwidth profile really needs to be removed (e.g. may be CoS)
    ceProvisioner.removeBandwidthProfiles(fc);
    // Remove LTP resources (BWP, CE-VLAN ID, S-TAG) from corresponding global LTPs
    fc.ltpSet().forEach(ltp -> ltpMap.get(ltp.id()).ni().removeEcNi(ltp.ni()));
}
#end_block

#method_before
private CarrierEthernetForwardingConstruct validateFc(CarrierEthernetForwardingConstruct fc) {
    // FIXME: This is an extra check to be able to generate/set VLAN id for FC before calling installFc
    if (fc.vlanId() == null) {
        fc.setVlanId(generateVlanId(null));
    }
    if (fc.vlanId() == null) {
        log.error("No available VLAN id found.");
        return null;
    }
    // Generate and set unique FC id
    fc.setId(generateFcId(fc));
    Set<CarrierEthernetLogicalTerminationPoint> validatedLtpSet = new HashSet<>();
    // Check the NIs of the FC, possibly removing NIs that are incompatible with existing ones
    Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt = fc.ltpSet().iterator();
    while (ltpIt.hasNext()) {
        CarrierEthernetLogicalTerminationPoint ltp = ltpIt.next();
        boolean ltpValidated = true;
        if (ltp.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
            CarrierEthernetUni uni = (CarrierEthernetUni) ltp.ni();
            // Change the name of the UNI's BWP to the FC name if it is an EVC BWP
            if (uni.bwp().type().equals(CarrierEthernetBandwidthProfile.Type.EVC)) {
                // FIXME: Find a way to use the EVC name instead
                uni.bwp().setId(fc.id());
            }
        }
        // Check first if LTP already exists by checking against the global LTP Map
        if (ltpMap.keySet().contains(ltp.id())) {
            CarrierEthernetNetworkInterface existingNi = ltpMap.get(ltp.id()).ni();
            // Check if the FC-specific NI is compatible with the global one
            if (!(existingNi.validateNi(ltp.ni()))) {
                ltpValidated = false;
            }
        }
        if (!ltpValidated) {
            // If EVC is of ROOT_MULTIPOINT type and we have removed the root, return null
            if (fc.type() == CarrierEthernetForwardingConstruct.Type.ROOT_MULTIPOINT && ltp.role() == CarrierEthernetLogicalTerminationPoint.Role.ROOT) {
                log.error("Root LTP could not be added to %s FC.", fc.type().name());
                return null;
            }
            log.warn("LTP {} could not be added to FC.", ltp.id());
            continue;
        } else {
            // Add LTP to FC description
            validatedLtpSet.add(ltp);
        }
    }
    fc.setLtpSet(validatedLtpSet);
    return fc;
}
#method_after
private CarrierEthernetForwardingConstruct validateFc(CarrierEthernetForwardingConstruct fc) {
    // FIXME: This is an extra check to be able to generate/set VLAN id for FC before calling installFc
    if (fc.vlanId() == null) {
        fc.setVlanId(generateVlanId(null));
    }
    if (fc.vlanId() == null) {
        log.error("No available VLAN id found.");
        return null;
    }
    // Generate and set unique FC id
    fc.setId(generateFcId(fc));
    Set<CarrierEthernetLogicalTerminationPoint> validatedLtpSet = new HashSet<>();
    // Check the NIs of the FC, possibly removing NIs that are incompatible with existing ones
    Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt = fc.ltpSet().iterator();
    while (ltpIt.hasNext()) {
        CarrierEthernetLogicalTerminationPoint ltp = ltpIt.next();
        boolean ltpValidated = true;
        if (ltp.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
            CarrierEthernetUni uni = (CarrierEthernetUni) ltp.ni();
            // Change the name of the UNI's BWP to the FC name if it is an EVC BWP
            if (uni.bwp().type().equals(CarrierEthernetBandwidthProfile.Type.EVC)) {
                // FIXME: Find a way to use the EVC name instead
                uni.bwp().setId(fc.id());
            }
        }
        // Check first if LTP already exists by checking against the global LTP Map
        if (ltpMap.keySet().contains(ltp.id())) {
            CarrierEthernetNetworkInterface existingNi = ltpMap.get(ltp.id()).ni();
            // Check if the FC-specific NI is compatible with the global one
            if (!(existingNi.validateEcNi(ltp.ni()))) {
                ltpValidated = false;
            }
        }
        if (!ltpValidated) {
            // If EVC is of ROOT_MULTIPOINT type and we have removed the root, return null
            if (fc.type() == CarrierEthernetForwardingConstruct.Type.ROOT_MULTIPOINT && ltp.role() == CarrierEthernetLogicalTerminationPoint.Role.ROOT) {
                log.error("Root LTP could not be added to %s FC.", fc.type().name());
                return null;
            }
            log.warn("LTP {} could not be added to FC.", ltp.id());
            continue;
        } else {
            // Add LTP to FC description
            validatedLtpSet.add(ltp);
        }
    }
    fc.setLtpSet(validatedLtpSet);
    return fc;
}
#end_block

#method_before
public void setupConnectivity(CarrierEthernetForwardingConstruct fc) {
    boolean allPairsConnected = true;
    HashMap<CarrierEthernetNetworkInterface, HashSet<CarrierEthernetNetworkInterface>> ingressEgressNiMap = new HashMap<>();
    // Temporary set for iterating through LTP pairs
    Set<CarrierEthernetLogicalTerminationPoint> tempLtpSet = new HashSet<>(fc.ltpSet());
    // Temporary set for indicating which LTPs were finally included
    Set<CarrierEthernetLogicalTerminationPoint> usedLtpSet = new HashSet<>();
    Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt1 = tempLtpSet.iterator();
    while (ltpIt1.hasNext()) {
        CarrierEthernetLogicalTerminationPoint ltp1 = ltpIt1.next();
        // Iterate through all the remaining NIs
        Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt2 = tempLtpSet.iterator();
        while (ltpIt2.hasNext()) {
            CarrierEthernetLogicalTerminationPoint ltp2 = ltpIt2.next();
            // Skip equals
            if (ltp1.equals(ltp2)) {
                continue;
            }
            // FIXME: Use proper LTP roles
            if (ltp1.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF) && ltp2.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF)) {
                continue;
            }
            OpticalConnectivityId opticalConnectId = null;
            if (pktOpticalTopo) {
                Bandwidth reqBw;
                if (ltp1.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ltp1.ni()).bwp().cir();
                } else if (ltp2.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ltp2.ni()).bwp().cir();
                } else {
                    reqBw = Bandwidth.bps((double) 0);
                }
                opticalConnectId = setupOpticalConnectivity(ltp1.ni().cp(), ltp2.ni().cp(), reqBw, fc.maxLatency());
                if (opticalConnectId == null || opticalConnectStatusMap.get(opticalConnectId) != OpticalPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish optical connectivity between {} and {}" + " (optical id and status: {}, {})", ltp1.ni().cp(), ltp2.ni().cp(), opticalConnectId, (opticalConnectId == null ? "null" : opticalConnectStatusMap.get(opticalConnectId)));
                    allPairsConnected = false;
                    continue;
                }
                if (opticalConnectId != null) {
                    fc.setMetroConnectivityId(opticalConnectId);
                    fc.setMetroConnectivityStatus(opticalConnectStatusMap.get(opticalConnectId));
                }
                log.info("Metro connectivity id and status for FC {}: {}, {}", fc.id(), fc.metroConnectivity().id(), fc.metroConnectivity().status());
                if (opticalConnectId != null) {
                    // TODO: find vlanIds for both CO and store to service
                    opticalPathService.getPath(opticalConnectId).ifPresent(links -> {
                        getVlanTag(links).ifPresent(vlan -> {
                            log.info("VLAN ID {} is assigned to CE service {}", vlan, fc.id());
                            fc.setVlanId(vlan);
                        });
                        getTransportVlanTag(links).ifPresent(vlan -> {
                            log.info("Transport VLAN ID {} is assigned to CE service {}", vlan, fc.id());
                            fc.setTransportVlanId(vlan);
                        });
                    });
                }
            }
            // Update the ingress-egress NI map based on the calculated paths
            if (!updateIngressEgressNiMap(ltp1.ni(), ltp2.ni(), ingressEgressNiMap, fc.congruentPaths(), fc.type())) {
                removeOpticalConnectivity(opticalConnectId);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one NI pair has been established
            fc.setState(CarrierEthernetForwardingConstruct.State.ACTIVE);
            // Add NIs to the set of NIs used by the EVC
            usedLtpSet.add(ltp1);
            usedLtpSet.add(ltp2);
        }
        // Remove NI from temporary set so that each pair is visited only once
        ltpIt1.remove();
    }
    // Establish connectivity using the ingressEgressNiMap
    ingressEgressNiMap.keySet().forEach(srcNi -> {
        // Set forwarding only on packet switches
        if (deviceService.getDevice(srcNi.cp().deviceId()).type().equals(Device.Type.SWITCH)) {
            ceOfPktNodeManager.setNodeForwarding(fc, srcNi, ingressEgressNiMap.get(srcNi));
        }
    });
    // Update the NI set, based on the NIs actually used
    fc.setLtpSet(usedLtpSet);
    if (fc.state().equals(CarrierEthernetVirtualConnection.State.ACTIVE)) {
        if (allPairsConnected) {
            fc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.FULL);
        } else {
            fc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.PARTIAL);
        }
    }
}
#method_after
public void setupConnectivity(CarrierEthernetForwardingConstruct fc) {
    boolean allPairsConnected = true;
    HashMap<CarrierEthernetNetworkInterface, HashSet<CarrierEthernetNetworkInterface>> ingressEgressNiMap = new HashMap<>();
    // Temporary set for iterating through LTP pairs
    Set<CarrierEthernetLogicalTerminationPoint> tempLtpSet = new HashSet<>(fc.ltpSet());
    // Temporary set for indicating which LTPs were finally included
    Set<CarrierEthernetLogicalTerminationPoint> usedLtpSet = new HashSet<>();
    Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt1 = tempLtpSet.iterator();
    while (ltpIt1.hasNext()) {
        CarrierEthernetLogicalTerminationPoint ltp1 = ltpIt1.next();
        // Iterate through all the remaining NIs
        Iterator<CarrierEthernetLogicalTerminationPoint> ltpIt2 = tempLtpSet.iterator();
        while (ltpIt2.hasNext()) {
            CarrierEthernetLogicalTerminationPoint ltp2 = ltpIt2.next();
            // Skip equals
            if (ltp1.equals(ltp2)) {
                continue;
            }
            // FIXME: Use proper LTP roles
            if (ltp1.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF) && ltp2.role().equals(CarrierEthernetLogicalTerminationPoint.Role.LEAF)) {
                continue;
            }
            OpticalConnectivityId opticalConnectId = null;
            if (pktOpticalTopo) {
                Bandwidth reqBw;
                if (ltp1.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ltp1.ni()).bwp().cir();
                } else if (ltp2.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ltp2.ni()).bwp().cir();
                } else {
                    reqBw = Bandwidth.bps((double) 0);
                }
                opticalConnectId = setupOpticalConnectivity(ltp1.ni().cp(), ltp2.ni().cp(), reqBw, fc.maxLatency());
                if (opticalConnectId == null || opticalConnectStatusMap.get(opticalConnectId) != OpticalPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish optical connectivity between {} and {}" + " (optical id and status: {}, {})", ltp1.ni().cp(), ltp2.ni().cp(), opticalConnectId, (opticalConnectId == null ? "null" : opticalConnectStatusMap.get(opticalConnectId)));
                    allPairsConnected = false;
                    continue;
                }
                if (opticalConnectId != null) {
                    fc.setMetroConnectivityId(opticalConnectId);
                    fc.setMetroConnectivityStatus(opticalConnectStatusMap.get(opticalConnectId));
                }
                log.info("Metro connectivity id and status for FC {}: {}, {}", fc.id(), fc.metroConnectivity().id(), fc.metroConnectivity().status());
                if (opticalConnectId != null) {
                    // TODO: find vlanIds for both CO and store to service
                    opticalPathService.getPath(opticalConnectId).ifPresent(links -> {
                        getVlanTag(links).ifPresent(vlan -> {
                            log.info("VLAN ID {} is assigned to CE service {}", vlan, fc.id());
                            fc.setVlanId(vlan);
                        });
                        getTransportVlanTag(links).ifPresent(vlan -> {
                            log.info("Transport VLAN ID {} is assigned to CE service {}", vlan, fc.id());
                            fc.setTransportVlanId(vlan);
                        });
                    });
                }
            }
            // Update the ingress-egress NI map based on the calculated paths
            if (!updateIngressEgressNiMap(ltp1.ni(), ltp2.ni(), ingressEgressNiMap, fc.congruentPaths(), fc.type())) {
                removeOpticalConnectivity(opticalConnectId);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one NI pair has been established
            fc.setState(CarrierEthernetForwardingConstruct.State.ACTIVE);
            // Add NIs to the set of NIs used by the EVC
            usedLtpSet.add(ltp1);
            usedLtpSet.add(ltp2);
        }
        // Remove NI from temporary set so that each pair is visited only once
        ltpIt1.remove();
    }
    // Establish connectivity using the ingressEgressNiMap
    ingressEgressNiMap.keySet().forEach(srcNi -> {
        // Set forwarding only on packet switches
        if (deviceService.getDevice(srcNi.cp().deviceId()).type().equals(Device.Type.SWITCH)) {
            ceOfPktNodeManager.setNodeForwarding(fc, srcNi, ingressEgressNiMap.get(srcNi));
        }
    });
    // Update the NI set, based on the NIs actually used
    fc.setLtpSet(usedLtpSet);
    if (fc.isActive()) {
        if (!allPairsConnected) {
            fc.setState(CarrierEthernetConnection.State.PARTIAL);
        }
    }
}
#end_block

#method_before
private void printRed(String format, Object... args) {
    System.out.println(ANSI_RED + String.format(format, args) + ANSI_RESET);
}
#method_after
private void printRed(String format, Object... args) {
    print(ANSI_RED + String.format(format, args) + ANSI_RESET);
}
#end_block

#method_before
private void printYellow(String format, Object... args) {
    System.out.println(ANSI_YELLOW + String.format(format, args) + ANSI_RESET);
}
#method_after
private void printYellow(String format, Object... args) {
    print(ANSI_YELLOW + String.format(format, args) + ANSI_RESET);
}
#end_block

#method_before
private void printGreen(String format, Object... args) {
    System.out.println(ANSI_GREEN + String.format(format, args) + ANSI_RESET);
}
#method_after
private void printGreen(String format, Object... args) {
    print(ANSI_GREEN + String.format(format, args) + ANSI_RESET);
}
#end_block

#method_before
@Modified
private void modified(ComponentContext context) {
    if (context == null) {
        bootstrapServers = BOOTSTRAP_SERVERS;
        retries = RETRIES;
        maxInFlightRequestsPerConnection = MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION;
        requestRequiredAcks = REQUEST_REQUIRED_ACKS;
        keySerializer = KEY_SERIALIZER;
        valueSerializer = VALUE_SERIALIZER;
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    String newBootstrapServers;
    int newRetries;
    int newMaxInFlightRequestsPerConnection;
    int newRequestRequiredAcks;
    try {
        String s = get(properties, "bootstrap.servers");
        newBootstrapServers = isNullOrEmpty(s) ? bootstrapServers : s.trim();
        s = get(properties, "retries");
        newRetries = isNullOrEmpty(s) ? retries : Integer.parseInt(s.trim());
        s = get(properties, "max.in.flight.requests.per.connection");
        newMaxInFlightRequestsPerConnection = isNullOrEmpty(s) ? maxInFlightRequestsPerConnection : Integer.parseInt(s.trim());
        s = get(properties, "request.required.acks");
        newRequestRequiredAcks = isNullOrEmpty(s) ? requestRequiredAcks : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        return;
    }
    if (configModified(newBootstrapServers, newRetries, newMaxInFlightRequestsPerConnection, newRequestRequiredAcks)) {
        bootstrapServers = newBootstrapServers;
        kafkaServerIp = bootstrapServers.substring(0, bootstrapServers.indexOf(":"));
        kafkaServerPortNum = bootstrapServers.substring(bootstrapServers.indexOf(":") + 1, bootstrapServers.length());
        retries = newRetries;
        maxInFlightRequestsPerConnection = newMaxInFlightRequestsPerConnection;
        requestRequiredAcks = newRequestRequiredAcks;
        producer.restart(new KafkaServerConfig(kafkaServerIp, kafkaServerPortNum, retries, maxInFlightRequestsPerConnection, requestRequiredAcks, keySerializer, valueSerializer));
        log.info("Kafka Server Config has been Modified - " + "bootstrapServers {}, retries {}, " + "maxInFlightRequestsPerConnection {}, " + "requestRequiredAcks {}", bootstrapServers, retries, maxInFlightRequestsPerConnection, requestRequiredAcks);
    } else {
        return;
    }
}
#method_after
@Modified
private void modified(ComponentContext context) {
    if (context == null) {
        bootstrapServers = BOOTSTRAP_SERVERS;
        retries = RETRIES;
        maxInFlightRequestsPerConnection = MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION;
        requestRequiredAcks = REQUEST_REQUIRED_ACKS;
        keySerializer = KEY_SERIALIZER;
        valueSerializer = VALUE_SERIALIZER;
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    String newBootstrapServers;
    int newRetries;
    int newMaxInFlightRequestsPerConnection;
    int newRequestRequiredAcks;
    try {
        String s = get(properties, "bootstrap.servers");
        newBootstrapServers = isNullOrEmpty(s) ? bootstrapServers : s.trim();
        s = get(properties, "retries");
        newRetries = isNullOrEmpty(s) ? retries : Integer.parseInt(s.trim());
        s = get(properties, "max.in.flight.requests.per.connection");
        newMaxInFlightRequestsPerConnection = isNullOrEmpty(s) ? maxInFlightRequestsPerConnection : Integer.parseInt(s.trim());
        s = get(properties, "request.required.acks");
        newRequestRequiredAcks = isNullOrEmpty(s) ? requestRequiredAcks : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        return;
    }
    if (configModified(newBootstrapServers, newRetries, newMaxInFlightRequestsPerConnection, newRequestRequiredAcks)) {
        bootstrapServers = newBootstrapServers;
        kafkaServerIp = bootstrapServers.substring(0, bootstrapServers.indexOf(":"));
        kafkaServerPortNum = bootstrapServers.substring(bootstrapServers.indexOf(":") + 1, bootstrapServers.length());
        retries = newRetries;
        maxInFlightRequestsPerConnection = newMaxInFlightRequestsPerConnection;
        requestRequiredAcks = newRequestRequiredAcks;
        producer.restart(KafkaServerConfig.builder().ipAddress(kafkaServerIp).port(kafkaServerPortNum).numOfRetries(retries).maxInFlightRequestsPerConnection(maxInFlightRequestsPerConnection).acksRequired(requestRequiredAcks).keySerializer(keySerializer).valueSerializer(valueSerializer).build());
        log.info("Kafka Server Config has been Modified - " + "bootstrapServers {}, retries {}, " + "maxInFlightRequestsPerConnection {}, " + "requestRequiredAcks {}", bootstrapServers, retries, maxInFlightRequestsPerConnection, requestRequiredAcks);
    } else {
        return;
    }
}
#end_block

#method_before
@Override
public KafkaServerConfig getConfigParams() {
    String ipAddr = bootstrapServers.substring(0, bootstrapServers.indexOf(":"));
    String port = bootstrapServers.substring(bootstrapServers.indexOf(":") + 1, bootstrapServers.length());
    return new KafkaServerConfig(ipAddr, port, retries, maxInFlightRequestsPerConnection, requestRequiredAcks, keySerializer, valueSerializer);
}
#method_after
@Override
public KafkaServerConfig getConfigParams() {
    String ipAddr = bootstrapServers.substring(0, bootstrapServers.indexOf(":"));
    String port = bootstrapServers.substring(bootstrapServers.indexOf(":") + 1, bootstrapServers.length());
    return KafkaServerConfig.builder().ipAddress(ipAddr).port(port).numOfRetries(retries).maxInFlightRequestsPerConnection(maxInFlightRequestsPerConnection).acksRequired(requestRequiredAcks).keySerializer(keySerializer).valueSerializer(valueSerializer).build();
}
#end_block

#method_before
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, " + "maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            DeviceDescription updatedDeviceDescription = null;
            if (device.is(DeviceDescriptionDiscovery.class)) {
                DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {}", deviceId);
            }
            if (updatedDeviceDescription == null) {
                updatedDeviceDescription = deviceDescription;
            }
            providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#method_after
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, " + "maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            DeviceDescription updatedDeviceDescription = null;
            if (device.is(DeviceDescriptionDiscovery.class)) {
                if (mastershipService.isLocalMaster(deviceId)) {
                    DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                    updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {}", deviceId);
            }
            if (updatedDeviceDescription == null) {
                updatedDeviceDescription = deviceDescription;
            }
            providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#end_block

#method_before
@Override
public byte[] getAuthenticationData() {
    return authenticationData;
}
#method_after
@Override
public byte[] getAuthenticationData() {
    return ImmutableByteSequence.copyFrom(this.authenticationData).asArray();
}
#end_block

#method_before
@Override
public byte[] getAuthenticationData() {
    return this.authenticationData;
}
#method_after
@Override
public byte[] getAuthenticationData() {
    return ImmutableByteSequence.copyFrom(this.authenticationData).asArray();
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    // process the packet and get the payload
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    if (packet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
            if (udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT || udpPacket.getSourcePort() == UDP.DHCP_SERVER_PORT) {
                // This packet is dhcp.
                processDhcpPacket(context, dhcpPayload);
            }
        }
    } else if (packet.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arpPacket = (ARP) packet.getPayload();
        Set<Interface> serverInterfaces = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom());
        // ignore the packets if dhcp client/server interface is not configured on onos.
        if (serverInterfaces.isEmpty()) {
            log.warn("server virtual interface not configured");
            return;
        }
        if ((arpPacket.getOpCode() == ARP.OP_REQUEST) && Objects.equals(serverInterfaces.iterator().next().ipAddressesList().get(0).ipAddress().getIp4Address(), Ip4Address.valueOf(arpPacket.getTargetProtocolAddress()))) {
            processArpPacket(context, packet);
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    // process the packet and get the payload
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    if (packet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
            if (udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT || udpPacket.getSourcePort() == UDP.DHCP_SERVER_PORT) {
                // This packet is dhcp.
                processDhcpPacket(context, dhcpPayload);
            }
        }
    } else if (packet.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arpPacket = (ARP) packet.getPayload();
        Set<Interface> serverInterfaces = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom());
        // ignore the packets if dhcp server interface is not configured on onos.
        if (serverInterfaces.isEmpty()) {
            log.warn("server virtual interface not configured");
            return;
        }
        if ((arpPacket.getOpCode() == ARP.OP_REQUEST) && checkArpRequestFrmDhcpServ(serverInterfaces, arpPacket)) {
            processArpPacket(context, packet);
        }
    }
}
#end_block

#method_before
private Ethernet processDhcpPacketFrmClient(PacketContext context, Ethernet ethernetPacket, Set<Interface> clientServerInterfaces) {
    // assuming one interface per port for now.
    relayAgentIP = clientServerInterfaces.iterator().next().ipAddressesList().get(0).ipAddress().getIp4Address();
    relayAgentMAC = clientServerInterfaces.iterator().next().mac();
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    etherReply.setSourceMACAddress(relayAgentMAC);
    etherReply.setDestinationMACAddress(dhcpServerMac);
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    ipv4Packet.setSourceAddress(relayAgentIP.toInt());
    ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    dhcpPacket.setGatewayIPAddress(relayAgentIP.toInt());
    udpPacket.setPayload(dhcpPacket);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#method_after
private Ethernet processDhcpPacketFrmClient(PacketContext context, Ethernet ethernetPacket, Set<Interface> clientInterfaces) {
    // assuming one interface per port for now.
    relayAgentIP = clientInterfaces.iterator().next().ipAddressesList().get(0).ipAddress().getIp4Address();
    relayAgentMAC = clientInterfaces.iterator().next().mac();
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    etherReply.setSourceMACAddress(relayAgentMAC);
    etherReply.setDestinationMACAddress(dhcpServerMac);
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    ipv4Packet.setSourceAddress(relayAgentIP.toInt());
    ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    dhcpPacket.setGatewayIPAddress(relayAgentIP.toInt());
    udpPacket.setPayload(dhcpPacket);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#end_block

#method_before
@Override
public void addReferencesToIncludeList(Set<YangNode> yangNodeSet) throws DataModelException {
    // Run through the included list to add references.
    for (YangInclude yangInclude : getIncludeList()) {
        YangSubModule subModule = yangInclude.addReferenceToInclude(yangNodeSet);
        // Check if the referred sub-modules parent is self
        if (!(subModule.getBelongsTo().getModuleNode() == getBelongsTo().getModuleNode())) {
            yangInclude.reportIncludeError();
        }
    }
}
#method_after
@Override
public void addReferencesToIncludeList(Set<YangNode> yangNodeSet) throws DataModelException {
    Iterator<YangInclude> includeInfoIterator = getIncludeList().iterator();
    // Run through the included list to add references.
    while (includeInfoIterator.hasNext()) {
        YangInclude yangInclude = includeInfoIterator.next();
        YangSubModule subModule = null;
        subModule = yangInclude.addReferenceToInclude(yangNodeSet);
        // Check if the referred sub-modules parent is self
        if (!(subModule.getBelongsTo().getModuleNode() == getBelongsTo().getModuleNode())) {
            yangInclude.reportIncludeError();
        }
    }
}
#end_block

#method_before
@Override
public void addReferencesToImportList(Set<YangNode> yangNodeSet) throws DataModelException {
    // Run through the imported list to add references.
    for (YangImport yangImport : getImportList()) {
        yangImport.addReferenceToImport(yangNodeSet);
    }
}
#method_after
@Override
public void addReferencesToImportList(Set<YangNode> yangNodeSet) throws DataModelException {
    Iterator<YangImport> importInfoIterator = getImportList().iterator();
    // Run through the imported list to add references.
    while (importInfoIterator.hasNext()) {
        YangImport yangImport = importInfoIterator.next();
        yangImport.addReferenceToImport(yangNodeSet);
    }
}
#end_block

#method_before
@Override
public void addReferencesToImportList(Set<YangNode> yangNodeSet) throws DataModelException {
    // Run through the imported list to add references.
    for (YangImport yangImport : getImportList()) {
        yangImport.addReferenceToImport(yangNodeSet);
    }
}
#method_after
@Override
public void addReferencesToImportList(Set<YangNode> yangNodeSet) throws DataModelException {
    Iterator<YangImport> importInfoIterator = getImportList().iterator();
    // Run through the imported list to add references.
    while (importInfoIterator.hasNext()) {
        YangImport yangImport = importInfoIterator.next();
        yangImport.addReferenceToImport(yangNodeSet);
    }
}
#end_block

#method_before
@Override
public void addReferencesToIncludeList(Set<YangNode> yangNodeSet) throws DataModelException {
    // Run through the included list to add references.
    for (YangInclude yangInclude : getIncludeList()) {
        YangSubModule subModule = yangInclude.addReferenceToInclude(yangNodeSet);
        // Check if the referred sub-modules parent is self
        if (!(subModule.getBelongsTo().getModuleNode() == this)) {
            yangInclude.reportIncludeError();
        }
    }
}
#method_after
@Override
public void addReferencesToIncludeList(Set<YangNode> yangNodeSet) throws DataModelException {
    Iterator<YangInclude> includeInfoIterator = getIncludeList().iterator();
    // Run through the included list to add references.
    while (includeInfoIterator.hasNext()) {
        YangInclude yangInclude = includeInfoIterator.next();
        YangSubModule subModule = null;
        subModule = yangInclude.addReferenceToInclude(yangNodeSet);
        // Check if the referred sub-modules parent is self
        if (!(subModule.getBelongsTo().getModuleNode() == this)) {
            yangInclude.reportIncludeError();
        }
    }
}
#end_block

#method_before
@Test
public void processAugmentTranslator() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/augmentTranslator";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir("target/augmentTranslator/");
    utilManager.translateToJava(yangPluginConfig);
    deleteDirectory("target/augmentTranslator/");
}
#method_after
@Test
public void processAugmentTranslator() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/augmentTranslator";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir("target/augmentTranslator/");
    utilManager.translateToJava(yangPluginConfig);
    deleteDirectory("target/augmentTranslator1/");
}
#end_block

#method_before
private static YangNode deSerializeDataModel(String serializedFileInfo) throws IOException {
    YangNode node;
    try {
        FileInputStream fileInputStream = new FileInputStream(serializedFileInfo);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        node = (YangNode) objectInputStream.readObject();
        objectInputStream.close();
        fileInputStream.close();
    } catch (IOException | ClassNotFoundException e) {
        throw new IOException(serializedFileInfo + " not found.");
    }
    return node;
}
#method_after
public static YangNode deSerializeDataModel(String serializedFileInfo) throws IOException {
    YangNode node;
    try {
        FileInputStream fileInputStream = new FileInputStream(serializedFileInfo);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        node = (YangNode) objectInputStream.readObject();
        objectInputStream.close();
        fileInputStream.close();
    } catch (IOException | ClassNotFoundException e) {
        throw new IOException(serializedFileInfo + " not found.");
    }
    return node;
}
#end_block

#method_before
private static void assignCurrentLeafedWithNewPrefixes(String importedNodeName, YangAtomicPath atomicPath, YangNode node) throws DataModelException {
    while (!(node instanceof YangReferenceResolver)) {
        node = node.getParent();
        if (node == null) {
            throw new DataModelException("Internal datamodel error: Datamodel tree is not correct");
        }
    }
    if (node instanceof YangModule) {
        List<YangImport> importInUsesList = ((YangModule) node).getImportList();
        if (importInUsesList != null && !importInUsesList.isEmpty()) {
            importInUsesList.stream().filter(importInUsesNode -> importInUsesNode.getModuleName().equals(importedNodeName)).forEach(importInUsesNode -> {
                atomicPath.getNodeIdentifier().setPrefix(importInUsesNode.getPrefixId());
            });
        }
    }
}
#method_after
private static void assignCurrentLeafedWithNewPrefixes(String importedNodeName, YangAtomicPath atomicPath, YangNode node) throws DataModelException {
    while (!(node instanceof YangReferenceResolver)) {
        node = node.getParent();
        if (node == null) {
            throw new DataModelException("Internal datamodel error: Datamodel tree is not correct");
        }
    }
    if (node instanceof YangModule) {
        List<YangImport> importInUsesList = ((YangModule) node).getImportList();
        if (importInUsesList != null && !importInUsesList.isEmpty()) {
            Iterator<YangImport> importInUsesListIterator = importInUsesList.listIterator();
            while (importInUsesListIterator.hasNext()) {
                YangImport importInUsesNode = importInUsesListIterator.next();
                if (importInUsesNode.getModuleName().equals(importedNodeName)) {
                    atomicPath.getNodeIdentifier().setPrefix(importInUsesNode.getPrefixId());
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /*
             * For deleting the generated code in previous build.
             */
        deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        deleteDirectory(getDirectory(baseDir, outputDirectory));
        String searchDir = getDirectory(baseDir, yangFilesDir);
        String codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Creates conflict resolver and set values to it.
        YangToJavaNamingConflictUtil conflictResolver = new YangToJavaNamingConflictUtil();
        conflictResolver.setReplacementForPeriod(replacementForPeriod);
        conflictResolver.setReplacementForHyphen(replacementForHyphen);
        conflictResolver.setReplacementForUnderscore(replacementForUnderscore);
        conflictResolver.setPrefixForIdentifier(prefixForIdentifier);
        yangPlugin.setCodeGenDir(codeGenDir);
        yangPlugin.setConflictResolver(conflictResolver);
        yangPlugin.setCodeGenerateForsbi(generateJavaFileForsbi.toLowerCase());
        /*
             * Obtain the YANG files at a path mentioned in plugin and creates
             * YANG file information set.
             */
        createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
        // Check if there are any file to translate, if not return.
        if (getYangFileInfoSet() == null || getYangFileInfoSet().isEmpty()) {
            // No files to translate
            return;
        }
        // Resolve inter jar dependency.
        resolveInterJarDependency();
        // Carry out the parsing for all the YANG files.
        parseYangFileInfoSet();
        // Resolve dependencies using linker.
        resolveDependenciesUsingLinker();
        // Perform translation to JAVA.
        translateToJava(yangPlugin);
        // Serialize data model.
        serializeDataModel(getDirectory(baseDir, outputDirectory), getYangFileInfoSet(), project, true);
        addToCompilationRoot(codeGenDir, project, context);
        copyYangFilesToTarget(getYangFileInfoSet(), getDirectory(baseDir, outputDirectory), project);
    } catch (IOException | ParserException e) {
        String fileName = "";
        if (getCurYangFileInfo() != null) {
            fileName = getCurYangFileInfo().getYangFileName();
        }
        try {
            translatorErrorHandler(getRootNode(), yangPlugin);
            deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        throw new MojoExecutionException("Exception occured due to " + e.getLocalizedMessage() + " in " + fileName + " YANG file.");
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /*
             * For deleting the generated code in previous build.
             */
        deleteDirectory(getDirectory(baseDir, outputDirectory));
        String searchDir = getDirectory(baseDir, yangFilesDir);
        String codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Creates conflict resolver and set values to it.
        YangToJavaNamingConflictUtil conflictResolver = new YangToJavaNamingConflictUtil();
        conflictResolver.setReplacementForPeriod(replacementForPeriod);
        conflictResolver.setReplacementForHyphen(replacementForHyphen);
        conflictResolver.setReplacementForUnderscore(replacementForUnderscore);
        conflictResolver.setPrefixForIdentifier(prefixForIdentifier);
        yangPlugin.setCodeGenDir(codeGenDir);
        yangPlugin.setConflictResolver(conflictResolver);
        yangPlugin.setCodeGenerateForsbi(generateJavaFileForSbi.toLowerCase());
        /*
             * Obtain the YANG files at a path mentioned in plugin and creates
             * YANG file information set.
             */
        createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
        // Check if there are any file to translate, if not return.
        if (getYangFileInfoSet() == null || getYangFileInfoSet().isEmpty()) {
            // No files to translate
            return;
        }
        // Resolve inter jar dependency.
        resolveInterJarDependency();
        // Carry out the parsing for all the YANG files.
        parseYangFileInfoSet();
        // Resolve dependencies using linker.
        resolveDependenciesUsingLinker();
        // Perform translation to JAVA.
        translateToJava(yangPlugin);
        // Serialize data model.
        serializeDataModel(getDirectory(baseDir, outputDirectory), getYangFileInfoSet(), project, true);
        addToCompilationRoot(codeGenDir, project, context);
        copyYangFilesToTarget(getYangFileInfoSet(), getDirectory(baseDir, outputDirectory), project);
    } catch (IOException | ParserException e) {
        String fileName = "";
        if (getCurYangFileInfo() != null) {
            fileName = getCurYangFileInfo().getYangFileName();
        }
        try {
            translatorErrorHandler(getRootNode(), yangPlugin);
            deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        throw new MojoExecutionException("Exception occurred due to " + e.getLocalizedMessage() + " in " + fileName + " YANG file.");
    }
}
#end_block

#method_before
private void resolveInterJarDependency() throws IOException {
    try {
        List<YangNode> interJarResolvedNodes = resolveInterJarDependencies(project, localRepository, remoteRepository, getDirectory(baseDir, outputDirectory));
        for (YangNode node : interJarResolvedNodes) {
            YangFileInfo dependentFileInfo = new YangFileInfo();
            node.setToTranslate(false);
            dependentFileInfo.setRootNode(node);
            dependentFileInfo.setForTranslator(false);
            dependentFileInfo.setYangFileName(node.getName());
            getYangFileInfoSet().add(dependentFileInfo);
        }
    } catch (IOException e) {
        throw new IOException("failed to resolve in interjar scenario.");
    }
}
#method_after
private void resolveInterJarDependency() throws IOException {
    try {
        List<YangNode> interJarResolvedNodes = resolveInterJarDependencies(project, localRepository, remoteRepository, getDirectory(baseDir, outputDirectory));
        for (YangNode node : interJarResolvedNodes) {
            YangFileInfo dependentFileInfo = new YangFileInfo();
            node.setToTranslate(false);
            dependentFileInfo.setRootNode(node);
            dependentFileInfo.setForTranslator(false);
            dependentFileInfo.setYangFileName(node.getName());
            getYangFileInfoSet().add(dependentFileInfo);
        }
    } catch (IOException e) {
        throw new IOException("failed to resolve in inter-jar scenario.");
    }
}
#end_block

#method_before
public static void addToCompilationRoot(String source, MavenProject project, BuildContext context) {
    project.addCompileSourceRoot(source);
    context.refresh(project.getBasedir());
    log.info("Source directory added to compilation root: " + source);
}
#method_after
static void addToCompilationRoot(String source, MavenProject project, BuildContext context) {
    project.addCompileSourceRoot(source);
    context.refresh(project.getBasedir());
    log.info("Source directory added to compilation root: " + source);
}
#end_block

#method_before
public static void copyYangFilesToTarget(Set<YangFileInfo> yangFileInfo, String outputDir, MavenProject project) throws IOException {
    List<File> files = getListOfFile(yangFileInfo);
    String path = outputDir + TARGET_RESOURCE_PATH;
    File targetDir = new File(path);
    targetDir.mkdirs();
    for (File file : files) {
        Files.copy(file.toPath(), new File(path + file.getName()).toPath(), StandardCopyOption.REPLACE_EXISTING);
    }
    addToProjectResource(outputDir + SLASH + TEMP + SLASH, project);
}
#method_after
static void copyYangFilesToTarget(Set<YangFileInfo> yangFileInfo, String outputDir, MavenProject project) throws IOException {
    List<File> files = getListOfFile(yangFileInfo);
    String path = outputDir + TARGET_RESOURCE_PATH;
    File targetDir = new File(path);
    targetDir.mkdirs();
    for (File file : files) {
        Files.copy(file.toPath(), new File(path + file.getName()).toPath(), StandardCopyOption.REPLACE_EXISTING);
    }
    addToProjectResource(outputDir + SLASH + TEMP + SLASH, project);
}
#end_block

#method_before
public static void serializeDataModel(String directory, Set<YangFileInfo> fileInfoSet, MavenProject project, boolean operation) throws IOException {
    String serFileDirPath = directory + TARGET_RESOURCE_PATH;
    File dir = new File(serFileDirPath);
    dir.mkdirs();
    if (operation) {
        addToProjectResource(directory + SLASH + TEMP + SLASH, project);
    }
    for (YangFileInfo fileInfo : fileInfoSet) {
        String serFileName = serFileDirPath + fileInfo.getRootNode().getName() + SERIALIZED_FILE_EXTENSION;
        fileInfo.setSerializedFile(serFileName);
        FileOutputStream fileOutputStream = new FileOutputStream(serFileName);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(fileInfo.getRootNode());
        objectOutputStream.close();
        fileOutputStream.close();
    }
}
#method_after
static void serializeDataModel(String directory, Set<YangFileInfo> fileInfoSet, MavenProject project, boolean operation) throws IOException {
    String serFileDirPath = directory + TARGET_RESOURCE_PATH;
    File dir = new File(serFileDirPath);
    dir.mkdirs();
    if (operation) {
        addToProjectResource(directory + SLASH + TEMP + SLASH, project);
    }
    for (YangFileInfo fileInfo : fileInfoSet) {
        String serFileName = serFileDirPath + fileInfo.getRootNode().getName() + SERIALIZED_FILE_EXTENSION;
        fileInfo.setSerializedFile(serFileName);
        FileOutputStream fileOutputStream = new FileOutputStream(serFileName);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(fileInfo.getRootNode());
        objectOutputStream.close();
        fileOutputStream.close();
    }
}
#end_block

#method_before
public static List<YangNode> resolveInterJarDependencies(MavenProject project, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepos, String directory) throws IOException {
    List<String> dependenciesJarPaths = resolveDependencyJarPath(project, localRepository, remoteRepos);
    List<YangNode> resolvedDataModelNodes = new ArrayList<>();
    for (String dependecy : dependenciesJarPaths) {
        resolvedDataModelNodes.addAll(DataModelUtils.parseJarFile(dependecy, directory));
    }
    return resolvedDataModelNodes;
}
#method_after
static List<YangNode> resolveInterJarDependencies(MavenProject project, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepos, String directory) throws IOException {
    List<String> dependenciesJarPaths = resolveDependencyJarPath(project, localRepository, remoteRepos);
    List<YangNode> resolvedDataModelNodes = new ArrayList<>();
    for (String dependency : dependenciesJarPaths) {
        resolvedDataModelNodes.addAll(DataModelUtils.parseJarFile(dependency, directory));
    }
    return resolvedDataModelNodes;
}
#end_block

#method_before
@Activate
public void activate() {
    mastershipService.addListener(mastershipListener);
    localId = clusterService.getLocalNode().id();
    leadershipService.addListener(leadershipListener);
    leadershipService.runForLeadership(REBALANCE_MASTERSHIP);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    modified(context);
    mastershipService.addListener(mastershipListener);
    localId = clusterService.getLocalNode().id();
    leadershipService.addListener(leadershipListener);
    leadershipService.runForLeadership(REBALANCE_MASTERSHIP);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    mastershipService.removeListener(mastershipListener);
    leadershipService.withdraw(REBALANCE_MASTERSHIP);
    leadershipService.removeListener(leadershipListener);
    cancelBalance();
    executorService.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    mastershipService.removeListener(mastershipListener);
    leadershipService.withdraw(REBALANCE_MASTERSHIP);
    leadershipService.removeListener(leadershipListener);
    cancelBalance();
    executorService.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
@Override
protected void execute() {
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    VoltFwdlConfig volt = h.behaviour(VoltFwdlConfig.class);
    String reply = volt.upgradeFirmwareOndemand(target);
    if (reply != null) {
        print("%s", reply);
    } else {
        print("No reply from %s", deviceId.toString());
    }
}
#method_after
@Override
protected void execute() {
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    VoltFwdlConfig volt = h.behaviour(VoltFwdlConfig.class);
    String reply = volt.upgradeFirmwareOndemand(target);
    if (reply != null) {
        print("%s", reply);
    } else {
        print("ONU firmware-upgrade failure %s", deviceId.toString());
    }
}
#end_block

#method_before
@Test
public void processRangeRestrictionInRefTypedef() throws IOException, ParserException, DataModelException {
    YangNode node = manager.getDataModel("src/test/resources/RangeRestrictionInRefTypedef.yang");
    // Check whether the data model tree returned is of type module.
    assertThat(node instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) yangNode.getChild();
    Assert.assertThat(topTypedef.getName(), is("Num3"));
    YangType type = topTypedef.getTypeList().iterator().next();
    Assert.assertThat(type.getDataType(), is(YangDataTypes.INT16));
    Assert.assertThat(type.getDataTypeName(), is("int16"));
    // Check for the restriction value.
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) type.getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval1 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval1.getStartValue()).getValue(), is(-32000));
    assertThat((int) ((YangInt16) rangeInterval1.getEndValue()).getValue(), is(4));
    YangRangeInterval rangeInterval2 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval2.getStartValue()).getValue(), is(32767));
    assertThat((int) ((YangInt16) rangeInterval2.getEndValue()).getValue(), is(32767));
    // check referred typedef
    YangTypeDef refTypedef = (YangTypeDef) topTypedef.getNextSibling();
    Assert.assertThat(refTypedef.getName(), is("Num6"));
    YangType refType = refTypedef.getTypeList().iterator().next();
    Assert.assertThat(refType.getDataType(), is(YangDataTypes.DERIVED));
    Assert.assertThat(refType.getDataTypeName(), is("Num3"));
    YangDerivedInfo<YangRangeRestriction> derivedInfo = (YangDerivedInfo<YangRangeRestriction>) refType.getDataTypeExtendedInfo();
    // Check for the restriction value.
    rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    rangeInterval1 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval1.getStartValue()).getValue(), is(-3));
    assertThat((int) ((YangInt16) rangeInterval1.getEndValue()).getValue(), is(-3));
    rangeInterval2 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval2.getStartValue()).getValue(), is(-2));
    assertThat((int) ((YangInt16) rangeInterval2.getEndValue()).getValue(), is(2));
    YangRangeInterval rangeInterval3 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval3.getStartValue()).getValue(), is(3));
    assertThat((int) ((YangInt16) rangeInterval3.getEndValue()).getValue(), is(3));
}
#method_after
@Test
public void processRangeRestrictionInRefTypedef() throws IOException, ParserException, DataModelException {
    YangNode node = manager.getDataModel("src/test/resources/RangeRestrictionInRefTypedef.yang");
    // Check whether the data model tree returned is of type module.
    assertThat(node instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) yangNode.getChild();
    assertThat(topTypedef.getName(), is("Num3"));
    YangType type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.INT16));
    assertThat(type.getDataTypeName(), is("int16"));
    // Check for the restriction value.
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) type.getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval1 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval1.getStartValue()).getValue(), is(-32000));
    assertThat((int) ((YangInt16) rangeInterval1.getEndValue()).getValue(), is(4));
    YangRangeInterval rangeInterval2 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval2.getStartValue()).getValue(), is(32767));
    assertThat((int) ((YangInt16) rangeInterval2.getEndValue()).getValue(), is(32767));
    // check referred typedef
    YangTypeDef refTypedef = (YangTypeDef) topTypedef.getNextSibling();
    assertThat(refTypedef.getName(), is("Num6"));
    YangType refType = refTypedef.getTypeList().iterator().next();
    assertThat(refType.getDataType(), is(YangDataTypes.DERIVED));
    assertThat(refType.getDataTypeName(), is("Num3"));
    YangDerivedInfo<YangRangeRestriction> derivedInfo = (YangDerivedInfo<YangRangeRestriction>) refType.getDataTypeExtendedInfo();
    // Check for the restriction value.
    rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    rangeInterval1 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval1.getStartValue()).getValue(), is(-3));
    assertThat((int) ((YangInt16) rangeInterval1.getEndValue()).getValue(), is(-3));
    rangeInterval2 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval2.getStartValue()).getValue(), is(-2));
    assertThat((int) ((YangInt16) rangeInterval2.getEndValue()).getValue(), is(2));
    YangRangeInterval rangeInterval3 = rangeListIterator.next();
    assertThat((int) ((YangInt16) rangeInterval3.getStartValue()).getValue(), is(3));
    assertThat((int) ((YangInt16) rangeInterval3.getEndValue()).getValue(), is(3));
}
#end_block

#method_before
public void addRangeRestrictionInterval(YangRangeInterval<T> newInterval) throws DataModelException {
    checkNotNull(newInterval);
    checkNotNull(newInterval.getStartValue());
    if (getAscendingRangeIntervals() == null) {
        /*
             * First interval that is being added, and it must be the smallest
             * interval.
             */
        setAscendingRangeIntervals(new LinkedList<YangRangeInterval<T>>());
        getAscendingRangeIntervals().add(newInterval);
        return;
    }
    T curMaxvalue = getMaxRestrictedvalue();
    if (newInterval.getStartValue().compareTo(curMaxvalue) < 0) {
        throw new DataModelException("New added range interval is lesser than the old interval(s)");
    }
    getAscendingRangeIntervals().add(getAscendingRangeIntervals().size(), newInterval);
}
#method_after
public void addRangeRestrictionInterval(YangRangeInterval<T> newInterval) throws DataModelException {
    checkNotNull(newInterval);
    checkNotNull(newInterval.getStartValue());
    if (getAscendingRangeIntervals() == null) {
        /*
             * First interval that is being added, and it must be the smallest
             * interval.
             */
        setAscendingRangeIntervals(new LinkedList<YangRangeInterval<T>>());
        getAscendingRangeIntervals().add(newInterval);
        return;
    }
    T curMaxvalue = getMaxRestrictedvalue();
    if (newInterval.getStartValue().compareTo(curMaxvalue) < 1) {
        throw new DataModelException("New added range interval is lesser than the old interval(s)");
    }
    getAscendingRangeIntervals().add(getAscendingRangeIntervals().size(), newInterval);
}
#end_block

#method_before
public String target() {
    if (type.startsWith("p")) {
        return type + ":" + port + ":" + ip;
    } else {
        if (ofconfigid.isEmpty()) {
            return type + ":" + ip + ":" + port;
        } else {
            return type + ":" + ip + ":" + port + ":" + ofconfigid;
        }
    }
}
#method_after
// TODO Method equivalent to this method
// should probably live in OVSDB, NETCONF package.
@Deprecated
public String target() {
    if (type.startsWith("p")) {
        return type + ":" + port + ":" + ip;
    } else {
        if (annotations.equals(DefaultAnnotations.EMPTY)) {
            return type + ":" + ip + ":" + port;
        } else {
            return type + ":" + ip + ":" + port + ":" + annotations.toString();
        }
    }
}
#end_block

#method_before
@Override
public boolean equals(Object toBeCompared) {
    if (toBeCompared instanceof ControllerInfo) {
        ControllerInfo controllerInfo = (ControllerInfo) toBeCompared;
        if (controllerInfo.type().equals(this.type) && controllerInfo.ip().equals(this.ip()) && controllerInfo.port() == this.port) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object toBeCompared) {
    if (toBeCompared instanceof ControllerInfo) {
        ControllerInfo that = (ControllerInfo) toBeCompared;
        return Objects.equals(this.type, that.type) && Objects.equals(this.ip, that.ip) && Objects.equals(this.port, that.port);
    }
    return false;
}
#end_block

#method_before
@Override
public void setControllers(List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncdeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    if (mastershipService.isLocalMaster(ncdeviceId)) {
        try {
            try {
                NetconfDevice device = controller.getNetconfDevice(ncdeviceId);
                log.debug("provider map {}", controller.getDevicesMap());
                String config = null;
                try {
                    config = createVoltControllersConfig(XmlConfigParser.loadXml(getClass().getResourceAsStream(RESOURCE_XML)), RUNNING, MERGE, controllers);
                } catch (Exception e) {
                    log.error("Cannot communicate to device {} , exception {}", ncdeviceId, e.getMessage());
                }
                device.getSession().editConfig(config.substring(config.indexOf("-->") + 3));
            } catch (NullPointerException e) {
                log.warn("No NETCONF device with requested parameters " + e);
                throw new NullPointerException("No NETCONF device with requested parameters " + e);
            }
        } catch (IOException e) {
            log.error("Cannot communicate to device {} , exception {}", ncdeviceId, e.getMessage());
        }
    } else {
        log.warn("I'm not master for {} please use master, {} to execute command", ncdeviceId, mastershipService.getMasterFor(ncdeviceId));
    }
}
#method_after
@Override
public void setControllers(List<ControllerInfo> controllers) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncdeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    if (mastershipService.isLocalMaster(ncdeviceId)) {
        try {
            NetconfDevice device = controller.getNetconfDevice(ncdeviceId);
            String config = createVoltControllersConfig(XmlConfigParser.loadXml(getClass().getResourceAsStream(RESOURCE_XML)), RUNNING, MERGE, controllers);
            device.getSession().editConfig(config.substring(config.indexOf(END_LICENSE_HEADER) + END_LICENSE_HEADER.length()));
        } catch (NetconfException e) {
            log.error("Cannot communicate to device {} , exception ", ncdeviceId, e);
        }
    } else {
        log.warn("I'm not master for {} please use master, {} to execute command", ncdeviceId, mastershipService.getMasterFor(ncdeviceId));
    }
}
#end_block

#method_before
private List<ControllerInfo> parseStreamVoltControllers(HierarchicalConfiguration cfg) {
    List<ControllerInfo> controllers = new ArrayList<>();
    List<HierarchicalConfiguration> fields = cfg.configurationsAt(VOLT_DATACONFIG);
    for (HierarchicalConfiguration sub : fields) {
        List<HierarchicalConfiguration> childFields = sub.configurationsAt(CONTROLLER_INFO);
        for (HierarchicalConfiguration child : childFields) {
            ControllerInfo controller = new ControllerInfo(IpAddress.valueOf(child.getString(IP_ADDRESS)), Integer.parseInt(child.getString(PORT)), child.getString(PROTOCOL));
            controller.setOfconfigid(sub.getString(OFCONFIG_ID));
            log.debug("VOLT: OFCONTROLLER: PROTOCOL={}, IP={}, PORT={}, ID={} ", controller.type(), controller.ip(), controller.port(), controller.ofconfigid());
            controllers.add(controller);
        }
    }
    return controllers;
}
#method_after
private List<ControllerInfo> parseStreamVoltControllers(HierarchicalConfiguration cfg) {
    List<ControllerInfo> controllers = new ArrayList<>();
    List<HierarchicalConfiguration> fields = cfg.configurationsAt(VOLT_DATACONFIG);
    for (HierarchicalConfiguration sub : fields) {
        List<HierarchicalConfiguration> childFields = sub.configurationsAt(CONTROLLER_INFO);
        for (HierarchicalConfiguration child : childFields) {
            Annotations annotations = DefaultAnnotations.builder().set(OFCONFIG_ID, sub.getString(OFCONFIG_ID)).build();
            ControllerInfo controller = new ControllerInfo(IpAddress.valueOf(child.getString(IP_ADDRESS)), Integer.parseInt(child.getString(PORT)), child.getString(PROTOCOL), annotations);
            log.debug("VOLT: OFCONTROLLER: PROTOCOL={}, IP={}, PORT={}, ID={} ", controller.type(), controller.ip(), controller.port(), controller.annotations().value(OFCONFIG_ID));
            controllers.add(controller);
        }
    }
    return controllers;
}
#end_block

#method_before
public static String createVoltControllersConfig(HierarchicalConfiguration cfg, String target, String netconfOperation, List<ControllerInfo> controllers) {
    cfg.setProperty(EDIT_CONFIG_TG, target);
    cfg.setProperty(EDIT_CONFIG_DO, netconfOperation);
    List<ConfigurationNode> newControllers = new ArrayList<>();
    for (ControllerInfo ci : controllers) {
        XMLConfiguration controller = new XMLConfiguration();
        controller.setRoot(new HierarchicalConfiguration.Node(OF_CONTROLLER));
        controller.setProperty(OFCONFIG_ID, ci.ofconfigid());
        controller.setProperty(CONTROLLER_INFO_IP, ci.ip());
        controller.setProperty(CONTROLLER_INFO_PORT, ci.port());
        controller.setProperty(CONTROLLER_INFO_PROTOCOL, ci.type());
        newControllers.add(controller.getRootNode());
    }
    cfg.addNodes(VOLT_EDITCONFIG, newControllers);
    XMLConfiguration editcfg = (XMLConfiguration) cfg;
    StringWriter stringWriter = new StringWriter();
    try {
        editcfg.save(stringWriter);
    } catch (ConfigurationException e) {
        e.printStackTrace();
    }
    String s = stringWriter.toString();
    s = s.replace(TARGET_OPEN + target + TARGET_CLOSE, TARGET_OPEN + L_ANGLE_BR + target + R_ANGLE_BR + TARGET_CLOSE);
    return s;
}
#method_after
public static String createVoltControllersConfig(HierarchicalConfiguration cfg, String target, String netconfOperation, List<ControllerInfo> controllers) {
    XMLConfiguration editcfg = null;
    cfg.setProperty(EDIT_CONFIG_TG, target);
    cfg.setProperty(EDIT_CONFIG_DO, netconfOperation);
    List<ConfigurationNode> newControllers = new ArrayList<>();
    for (ControllerInfo ci : controllers) {
        XMLConfiguration controller = new XMLConfiguration();
        controller.setRoot(new HierarchicalConfiguration.Node(OF_CONTROLLER));
        controller.setProperty(OFCONFIG_ID, ci.annotations().value(OFCONFIG_ID));
        controller.setProperty(CONTROLLER_INFO_ID, ci.annotations().value(OFCONFIG_ID));
        controller.setProperty(CONTROLLER_INFO_IP, ci.ip());
        controller.setProperty(CONTROLLER_INFO_PORT, ci.port());
        controller.setProperty(CONTROLLER_INFO_PROTOCOL, ci.type());
        newControllers.add(controller.getRootNode());
    }
    cfg.addNodes(VOLT_EDITCONFIG, newControllers);
    try {
        editcfg = (XMLConfiguration) cfg;
    } catch (ClassCastException e) {
        e.printStackTrace();
    }
    StringWriter stringWriter = new StringWriter();
    try {
        editcfg.save(stringWriter);
    } catch (ConfigurationException e) {
        e.printStackTrace();
    }
    String s = stringWriter.toString();
    s = s.replace(TARGET_OPEN + target + TARGET_CLOSE, TARGET_OPEN + L_ANGLE_BR + target + R_ANGLE_BR + TARGET_CLOSE);
    return s;
}
#end_block

#method_before
private ConnectPoint mapVirtualToPhysicalPort(NetworkId networkId, ConnectPoint virtualCp) {
    Set<VirtualPort> ports = store.getPorts(networkId, virtualCp.deviceId());
    for (VirtualPort port : ports) {
        if (port.element().id().equals(virtualCp.elementId()) && port.number().equals(virtualCp.port())) {
            return new ConnectPoint(port.realizedBy().element().id(), port.realizedBy().number());
        }
    }
    return null;
}
#method_after
private ConnectPoint mapVirtualToPhysicalPort(NetworkId networkId, ConnectPoint virtualCp) {
    Set<VirtualPort> ports = store.getPorts(networkId, virtualCp.deviceId());
    for (VirtualPort port : ports) {
        if (port.number().equals(virtualCp.port())) {
            return new ConnectPoint(port.realizedBy().element().id(), port.realizedBy().number());
        }
    }
    return null;
}
#end_block

#method_before
private VnetService create(ServiceKey serviceKey) {
    VirtualNetwork network = getVirtualNetwork(serviceKey.networkId());
    checkNotNull(network, NETWORK_NULL);
    VnetService service;
    if (serviceKey.serviceClass.equals(DeviceService.class)) {
        service = new VirtualNetworkDeviceService(this, network);
    } else if (serviceKey.serviceClass.equals(LinkService.class)) {
        service = new VirtualNetworkLinkService(this, network);
    } else if (serviceKey.serviceClass.equals(TopologyService.class)) {
        service = new VirtualNetworkTopologyService(this, network);
    } else if (serviceKey.serviceClass.equals(IntentService.class)) {
        service = new VirtualNetworkIntentService(this, network, new DefaultServiceDirectory());
    } else {
        return null;
    }
    networkServices.put(serviceKey, service);
    return service;
}
#method_after
private VnetService create(ServiceKey serviceKey) {
    VirtualNetwork network = getVirtualNetwork(serviceKey.networkId());
    checkNotNull(network, NETWORK_NULL);
    VnetService service;
    if (serviceKey.serviceClass.equals(DeviceService.class)) {
        service = new VirtualNetworkDeviceService(this, network);
    } else if (serviceKey.serviceClass.equals(LinkService.class)) {
        service = new VirtualNetworkLinkService(this, network);
    } else if (serviceKey.serviceClass.equals(TopologyService.class)) {
        service = new VirtualNetworkTopologyService(this, network);
    } else if (serviceKey.serviceClass.equals(IntentService.class)) {
        service = new VirtualNetworkIntentService(this, network, new DefaultServiceDirectory());
    } else if (serviceKey.serviceClass.equals(HostService.class)) {
        service = new VirtualNetworkHostService(this, network);
    } else {
        return null;
    }
    networkServices.put(serviceKey, service);
    return service;
}
#end_block

#method_before
@Override
public void topologyChanged(Set<Set<ConnectPoint>> clusters) {
}
#method_after
@Override
public void topologyChanged(Set<Set<ConnectPoint>> clusters) {
    Set<TenantId> tenantIds = getTenantIds();
    tenantIds.forEach(tenantId -> {
        Set<VirtualNetwork> virtualNetworks = getVirtualNetworks(tenantId);
        virtualNetworks.forEach(virtualNetwork -> {
            Set<VirtualLink> virtualLinks = getVirtualLinks(virtualNetwork.id());
            virtualLinks.forEach(virtualLink -> {
                if (isVirtualLinkInCluster(virtualNetwork.id(), virtualLink, clusters)) {
                    store.updateLink(virtualLink, virtualLink.tunnelId(), Link.State.ACTIVE);
                } else {
                    store.updateLink(virtualLink, virtualLink.tunnelId(), Link.State.INACTIVE);
                }
            });
        });
    });
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    virtualNetworkManagerStore = new DistributedVirtualNetworkStore();
    Intent.bindIdGenerator(idGenerator);
    coreService = new TestCoreService();
    virtualNetworkManagerStore.setCoreService(coreService);
    TestUtils.setField(coreService, "coreService", new TestCoreService());
    TestUtils.setField(virtualNetworkManagerStore, "storageService", new TestStorageService());
    virtualNetworkManagerStore.activate();
    manager = new VirtualNetworkManager();
    manager.store = virtualNetworkManagerStore;
    manager.addListener(listener);
    manager.intentService = intentService;
    NetTestTools.injectEventDispatcher(manager, new TestEventDispatcher());
    manager.activate();
    virtualNetworkManagerService = manager;
}
#method_after
@Before
public void setUp() throws Exception {
    virtualNetworkManagerStore = new DistributedVirtualNetworkStore();
    Intent.bindIdGenerator(idGenerator);
    coreService = new TestCoreService();
    virtualNetworkManagerStore.setCoreService(coreService);
    TestUtils.setField(coreService, "coreService", new TestCoreService());
    TestUtils.setField(virtualNetworkManagerStore, "storageService", new TestStorageService());
    virtualNetworkManagerStore.activate();
    manager = new VirtualNetworkManager();
    manager.store = virtualNetworkManagerStore;
    manager.addListener(listener);
    manager.intentService = intentService;
    NetTestTools.injectEventDispatcher(manager, new TestEventDispatcher());
    manager.activate();
}
#end_block

#method_before
@Override
public void event(TopologyEvent event) {
    log.debug("Received event: " + event);
// TODO: add the implementation.
}
#method_after
@Override
public void event(TopologyEvent event) {
    if (!isRelevant(event)) {
        return;
    }
    Topology topology = event.subject();
    providerService.topologyChanged(getConnectPoints(topology));
}
#end_block

#method_before
@Override
public IntentState getIntentState(Key intentKey) {
    checkNotNull(intentKey, KEY_NULL);
    return store.getIntentData(intentKey).state();
}
#method_after
@Override
public IntentState getIntentState(Key intentKey) {
    checkNotNull(intentKey, KEY_NULL);
    return Optional.ofNullable(store.getIntentData(intentKey)).map(IntentData::state).orElse(null);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    virtualNetworkManagerStore = new DistributedVirtualNetworkStore();
    coreService = new VirtualNetworkTopologyProviderTest.TestCoreService();
    virtualNetworkManagerStore.setCoreService(coreService);
    TestUtils.setField(coreService, "coreService", new VirtualNetworkTopologyProviderTest.TestCoreService());
    TestUtils.setField(virtualNetworkManagerStore, "storageService", new TestStorageService());
    virtualNetworkManagerStore.activate();
    manager = new VirtualNetworkManager();
    manager.store = virtualNetworkManagerStore;
    manager.intentService = intentService;
    NetTestTools.injectEventDispatcher(manager, new TestEventDispatcher());
    manager.activate();
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    virtualNetwork = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    topologyService = manager.get(virtualNetwork.id(), TopologyService.class);
    topologyProvider = new VirtualNetworkTopologyProvider();
    topologyProvider.topologyService = topologyService;
    topologyProvider.providerRegistry = virtualNetworkRegistry;
    topologyProvider.activate();
    setupVirtualNetworkTopology();
}
#method_after
@Before
public void setUp() throws Exception {
    virtualNetworkManagerStore = new DistributedVirtualNetworkStore();
    coreService = new VirtualNetworkTopologyProviderTest.TestCoreService();
    virtualNetworkManagerStore.setCoreService(coreService);
    TestUtils.setField(coreService, "coreService", new VirtualNetworkTopologyProviderTest.TestCoreService());
    TestUtils.setField(virtualNetworkManagerStore, "storageService", new TestStorageService());
    virtualNetworkManagerStore.activate();
    manager = new VirtualNetworkManager();
    manager.store = virtualNetworkManagerStore;
    manager.intentService = intentService;
    NetTestTools.injectEventDispatcher(manager, new TestEventDispatcher());
    manager.activate();
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    virtualNetwork = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    topologyService = manager.get(virtualNetwork.id(), TopologyService.class);
    topologyProvider = new VirtualNetworkTopologyProvider();
    topologyProvider.topologyService = topologyService;
    topologyProvider.providerRegistry = virtualNetworkRegistry;
    topologyProvider.activate();
    setupVirtualNetworkTopology();
    changed = new Semaphore(0, true);
}
#end_block

#method_before
private void setupVirtualNetworkTopology() {
    virtualDevice1 = manager.createVirtualDevice(virtualNetwork.id(), DID1);
    virtualDevice2 = manager.createVirtualDevice(virtualNetwork.id(), DID2);
    virtualDevice3 = manager.createVirtualDevice(virtualNetwork.id(), DID3);
    virtualDevice4 = manager.createVirtualDevice(virtualNetwork.id(), DID4);
    cp1 = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(1));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice1.id(), PortNumber.portNumber(1), new DefaultPort(virtualDevice1, PortNumber.portNumber(1), true));
    cp2 = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(2));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice1.id(), PortNumber.portNumber(2), new DefaultPort(virtualDevice1, PortNumber.portNumber(2), true));
    cp3 = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(3));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice2.id(), PortNumber.portNumber(3), new DefaultPort(virtualDevice2, PortNumber.portNumber(3), true));
    cp4 = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(4));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice2.id(), PortNumber.portNumber(4), new DefaultPort(virtualDevice2, PortNumber.portNumber(4), true));
    cp5 = new ConnectPoint(virtualDevice3.id(), PortNumber.portNumber(5));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice3.id(), PortNumber.portNumber(5), new DefaultPort(virtualDevice3, PortNumber.portNumber(5), true));
    cp6 = new ConnectPoint(virtualDevice3.id(), PortNumber.portNumber(6));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice3.id(), PortNumber.portNumber(6), new DefaultPort(virtualDevice3, PortNumber.portNumber(6), true));
    VirtualLink link1 = manager.createVirtualLink(virtualNetwork.id(), cp1, cp3);
    virtualNetworkManagerStore.updateLink(link1, link1.tunnelId(), Link.State.ACTIVE);
    VirtualLink link2 = manager.createVirtualLink(virtualNetwork.id(), cp3, cp1);
    virtualNetworkManagerStore.updateLink(link2, link2.tunnelId(), Link.State.ACTIVE);
    VirtualLink link3 = manager.createVirtualLink(virtualNetwork.id(), cp4, cp5);
    virtualNetworkManagerStore.updateLink(link3, link3.tunnelId(), Link.State.ACTIVE);
    VirtualLink link4 = manager.createVirtualLink(virtualNetwork.id(), cp5, cp4);
    virtualNetworkManagerStore.updateLink(link4, link4.tunnelId(), Link.State.ACTIVE);
}
#method_after
private void setupVirtualNetworkTopology() {
    virtualDevice1 = manager.createVirtualDevice(virtualNetwork.id(), DID1);
    virtualDevice2 = manager.createVirtualDevice(virtualNetwork.id(), DID2);
    virtualDevice3 = manager.createVirtualDevice(virtualNetwork.id(), DID3);
    virtualDevice4 = manager.createVirtualDevice(virtualNetwork.id(), DID4);
    virtualDevice5 = manager.createVirtualDevice(virtualNetwork.id(), DID5);
    cp1 = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(1));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice1.id(), PortNumber.portNumber(1), new DefaultPort(virtualDevice1, PortNumber.portNumber(1), true));
    cp2 = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(2));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice1.id(), PortNumber.portNumber(2), new DefaultPort(virtualDevice1, PortNumber.portNumber(2), true));
    cp3 = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(3));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice2.id(), PortNumber.portNumber(3), new DefaultPort(virtualDevice2, PortNumber.portNumber(3), true));
    cp4 = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(4));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice2.id(), PortNumber.portNumber(4), new DefaultPort(virtualDevice2, PortNumber.portNumber(4), true));
    cp5 = new ConnectPoint(virtualDevice3.id(), PortNumber.portNumber(5));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice3.id(), PortNumber.portNumber(5), new DefaultPort(virtualDevice3, PortNumber.portNumber(5), true));
    cp6 = new ConnectPoint(virtualDevice3.id(), PortNumber.portNumber(6));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice3.id(), PortNumber.portNumber(6), new DefaultPort(virtualDevice3, PortNumber.portNumber(6), true));
    cp7 = new ConnectPoint(virtualDevice4.id(), PortNumber.portNumber(7));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice4.id(), PortNumber.portNumber(7), new DefaultPort(virtualDevice4, PortNumber.portNumber(7), true));
    cp8 = new ConnectPoint(virtualDevice4.id(), PortNumber.portNumber(8));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice4.id(), PortNumber.portNumber(8), new DefaultPort(virtualDevice4, PortNumber.portNumber(8), true));
    cp9 = new ConnectPoint(virtualDevice5.id(), PortNumber.portNumber(9));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice5.id(), PortNumber.portNumber(9), new DefaultPort(virtualDevice5, PortNumber.portNumber(9), true));
    VirtualLink link1 = manager.createVirtualLink(virtualNetwork.id(), cp1, cp3);
    virtualNetworkManagerStore.updateLink(link1, link1.tunnelId(), Link.State.ACTIVE);
    VirtualLink link2 = manager.createVirtualLink(virtualNetwork.id(), cp3, cp1);
    virtualNetworkManagerStore.updateLink(link2, link2.tunnelId(), Link.State.ACTIVE);
    VirtualLink link3 = manager.createVirtualLink(virtualNetwork.id(), cp4, cp5);
    virtualNetworkManagerStore.updateLink(link3, link3.tunnelId(), Link.State.ACTIVE);
    VirtualLink link4 = manager.createVirtualLink(virtualNetwork.id(), cp5, cp4);
    virtualNetworkManagerStore.updateLink(link4, link4.tunnelId(), Link.State.ACTIVE);
    VirtualLink link5 = manager.createVirtualLink(virtualNetwork.id(), cp8, cp9);
    virtualNetworkManagerStore.updateLink(link5, link5.tunnelId(), Link.State.ACTIVE);
    VirtualLink link6 = manager.createVirtualLink(virtualNetwork.id(), cp9, cp8);
    virtualNetworkManagerStore.updateLink(link6, link6.tunnelId(), Link.State.ACTIVE);
    clusters = null;
}
#end_block

#method_before
@Override
public void topologyChanged(Set<Set<ConnectPoint>> clusters) {
}
#method_after
@Override
public void topologyChanged(Set<Set<ConnectPoint>> theClusters) {
    clusters = theClusters;
    changed.release();
}
#end_block

#method_before
@Override
public void tunnelUp(NetworkId networkId, ConnectPoint src, ConnectPoint dst, TunnelId tunnelId) {
// Release one permit on the created semaphore since the tunnelUp method was called.
// created.release();
}
#method_after
@Override
public void tunnelUp(NetworkId networkId, ConnectPoint src, ConnectPoint dst, TunnelId tunnelId) {
}
#end_block

#method_before
@Override
public void tunnelDown(NetworkId networkId, ConnectPoint src, ConnectPoint dst, TunnelId tunnelId) {
// Release one permit on the removed semaphore since the tunnelDown method was called.
// removed.release();
}
#method_after
@Override
public void tunnelDown(NetworkId networkId, ConnectPoint src, ConnectPoint dst, TunnelId tunnelId) {
}
#end_block

#method_before
@Override
public Integer size() {
    return complete(asyncMultimap.size());
}
#method_after
@Override
public int size() {
    return complete(asyncMultimap.size());
}
#end_block

#method_before
@Override
public Boolean isEmpty() {
    return complete(asyncMultimap.isEmpty());
}
#method_after
@Override
public boolean isEmpty() {
    return complete(asyncMultimap.isEmpty());
}
#end_block

#method_before
@Override
public Boolean containsKey(K key) {
    return complete(asyncMultimap.containsKey(key));
}
#method_after
@Override
public boolean containsKey(K key) {
    return complete(asyncMultimap.containsKey(key));
}
#end_block

#method_before
@Override
public Boolean containsValue(V value) {
    return complete(asyncMultimap.containsValue(value));
}
#method_after
@Override
public boolean containsValue(V value) {
    return complete(asyncMultimap.containsValue(value));
}
#end_block

#method_before
@Override
public Boolean containsEntry(K key, V value) {
    return complete(asyncMultimap.containsEntry(key, value));
}
#method_after
@Override
public boolean containsEntry(K key, V value) {
    return complete(asyncMultimap.containsEntry(key, value));
}
#end_block

#method_before
@Override
public Boolean put(K key, V value) {
    return complete(asyncMultimap.put(key, value));
}
#method_after
@Override
public boolean put(K key, V value) {
    return complete(asyncMultimap.put(key, value));
}
#end_block

#method_before
@Override
public Boolean remove(K key, V value) {
    return complete(asyncMultimap.remove(key, value));
}
#method_after
@Override
public boolean remove(K key, V value) {
    return complete(asyncMultimap.remove(key, value));
}
#end_block

#method_before
@Override
public Boolean removeAll(K key, Collection<? extends V> values) {
    return complete(asyncMultimap.removeAll(key, values));
}
#method_after
@Override
public boolean removeAll(K key, Collection<? extends V> values) {
    return complete(asyncMultimap.removeAll(key, values));
}
#end_block

#method_before
@Override
public Boolean putAll(K key, Collection<? extends V> values) {
    return complete(asyncMultimap.putAll(key, values));
}
#method_after
@Override
public boolean putAll(K key, Collection<? extends V> values) {
    return complete(asyncMultimap.putAll(key, values));
}
#end_block

#method_before
@Override
public Void clear() {
    return complete(asyncMultimap.clear());
}
#method_after
@Override
public void clear() {
    complete(asyncMultimap.clear());
}
#end_block

#method_before
private void wipeOutGroups() {
    print("Wiping groups");
    GroupService groupService = get(GroupService.class);
    DeviceAdminService deviceAdminService = get(DeviceAdminService.class);
    for (Device device : deviceAdminService.getDevices()) {
        groupService.purgeGroupEntry(device.id());
    }
}
#method_after
private void wipeOutGroups() {
    print("Wiping groups");
    GroupService groupService = get(GroupService.class);
    DeviceAdminService deviceAdminService = get(DeviceAdminService.class);
    for (Device device : deviceAdminService.getDevices()) {
        groupService.purgeGroupEntries(device.id());
    }
}
#end_block

#method_before
private void testPurgeGroupEntry(DeviceId deviceId) {
    assertEquals(1, Iterables.size(groupService.getGroups(deviceId, appId)));
    groupService.purgeGroupEntry(deviceId);
    assertEquals(0, Iterables.size(groupService.getGroups(deviceId, appId)));
}
#method_after
private void testPurgeGroupEntry(DeviceId deviceId) {
    assertEquals(1, Iterables.size(groupService.getGroups(deviceId, appId)));
    groupService.purgeGroupEntries(deviceId);
    assertEquals(0, Iterables.size(groupService.getGroups(deviceId, appId)));
}
#end_block

#method_before
@Override
public long life() {
    return life(TimeUnit.SECONDS);
}
#method_after
@Override
public long life() {
    return life(SECONDS);
}
#end_block

#method_before
@Override
public long life(TimeUnit timeUnit) {
    return TimeUnit.SECONDS.convert(baseValue + 11, timeUnit);
}
#method_after
@Override
public long life(TimeUnit timeUnit) {
    return SECONDS.convert(baseValue + 11, timeUnit);
}
#end_block

#method_before
public FlowEntry build(FlowEntryState... state) {
    FlowRule.Builder builder;
    try {
        switch(this.type) {
            case STAT:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).makeTemporary(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue());
                if (stat.getVersion() != OFVersion.OF_10) {
                    builder.forTable(stat.getTableId().getValue());
                }
                return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, TimeUnit.SECONDS.toNanos(stat.getDurationSec()) + stat.getDurationNsec(), TimeUnit.NANOSECONDS, stat.getPacketCount().getValue(), stat.getByteCount().getValue());
            case REMOVED:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(removed.getPriority()).makeTemporary(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue());
                if (removed.getVersion() != OFVersion.OF_10) {
                    builder.forTable(removed.getTableId().getValue());
                }
                return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, TimeUnit.SECONDS.toNanos(removed.getDurationSec()) + removed.getDurationNsec(), TimeUnit.NANOSECONDS, removed.getPacketCount().getValue(), removed.getByteCount().getValue());
            case MOD:
                FlowEntryState flowState = state.length > 0 ? state[0] : FlowEntryState.FAILED;
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(flowMod.getPriority()).makeTemporary(flowMod.getIdleTimeout()).withCookie(flowMod.getCookie().getValue());
                if (flowMod.getVersion() != OFVersion.OF_10) {
                    builder.forTable(flowMod.getTableId().getValue());
                }
                return new DefaultFlowEntry(builder.build(), flowState, 0, 0, 0);
            default:
                log.error("Unknown flow type : {}", this.type);
                return null;
        }
    } catch (UnsupportedOperationException e) {
        log.warn("Error building flow entry", e);
        return null;
    }
}
#method_after
public FlowEntry build(FlowEntryState... state) {
    FlowRule.Builder builder;
    try {
        switch(this.type) {
            case STAT:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).makeTemporary(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue());
                if (stat.getVersion() != OFVersion.OF_10) {
                    builder.forTable(stat.getTableId().getValue());
                }
                return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(stat.getDurationSec()) + stat.getDurationNsec(), NANOSECONDS, stat.getPacketCount().getValue(), stat.getByteCount().getValue());
            case REMOVED:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(removed.getPriority()).makeTemporary(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue());
                if (removed.getVersion() != OFVersion.OF_10) {
                    builder.forTable(removed.getTableId().getValue());
                }
                return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, SECONDS.toNanos(removed.getDurationSec()) + removed.getDurationNsec(), NANOSECONDS, removed.getPacketCount().getValue(), removed.getByteCount().getValue());
            case MOD:
                FlowEntryState flowState = state.length > 0 ? state[0] : FlowEntryState.FAILED;
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(flowMod.getPriority()).makeTemporary(flowMod.getIdleTimeout()).withCookie(flowMod.getCookie().getValue());
                if (flowMod.getVersion() != OFVersion.OF_10) {
                    builder.forTable(flowMod.getTableId().getValue());
                }
                return new DefaultFlowEntry(builder.build(), flowState, 0, 0, 0);
            default:
                log.error("Unknown flow type : {}", this.type);
                return null;
        }
    } catch (UnsupportedOperationException e) {
        log.warn("Error building flow entry", e);
        return null;
    }
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        backupEnabled = DEFAULT_BACKUP_ENABLED;
        logConfig("Default config");
        return;
    }
    Dictionary properties = context.getProperties();
    int newPoolSize;
    boolean newBackupEnabled;
    int newBackupPeriod;
    try {
        String s = get(properties, "msgHandlerPoolSize");
        newPoolSize = isNullOrEmpty(s) ? msgHandlerPoolSize : Integer.parseInt(s.trim());
        s = get(properties, "backupEnabled");
        newBackupEnabled = isNullOrEmpty(s) ? backupEnabled : Boolean.parseBoolean(s.trim());
        s = get(properties, "backupPeriod");
        newBackupPeriod = isNullOrEmpty(s) ? backupPeriod : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newPoolSize = MESSAGE_HANDLER_THREAD_POOL_SIZE;
        newBackupEnabled = DEFAULT_BACKUP_ENABLED;
        newBackupPeriod = DEFAULT_BACKUP_PERIOD_MILLIS;
    }
    boolean restartBackupTask = false;
    if (newBackupEnabled != backupEnabled) {
        backupEnabled = newBackupEnabled;
        if (!backupEnabled) {
            replicaInfoManager.removeListener(flowTable);
            if (backupTask != null) {
                backupTask.cancel(false);
                backupTask = null;
            }
        } else {
            replicaInfoManager.addListener(flowTable);
        }
        restartBackupTask = backupEnabled;
    }
    if (newBackupPeriod != backupPeriod) {
        backupPeriod = newBackupPeriod;
        restartBackupTask = backupEnabled;
    }
    if (restartBackupTask) {
        if (backupTask != null) {
            // cancel previously running task
            backupTask.cancel(false);
        }
        backupTask = backupSenderExecutor.scheduleWithFixedDelay(flowTable::backup, 0, backupPeriod, TimeUnit.MILLISECONDS);
    }
    if (newPoolSize != msgHandlerPoolSize) {
        msgHandlerPoolSize = newPoolSize;
        ExecutorService oldMsgHandler = messageHandlingExecutor;
        messageHandlingExecutor = Executors.newFixedThreadPool(msgHandlerPoolSize, groupedThreads("onos/store/flow", "message-handlers", log));
        // replace previously registered handlers.
        registerMessageHandlers(messageHandlingExecutor);
        oldMsgHandler.shutdown();
    }
    logConfig("Reconfigured");
}
#method_after
@SuppressWarnings("rawtypes")
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        backupEnabled = DEFAULT_BACKUP_ENABLED;
        logConfig("Default config");
        return;
    }
    Dictionary properties = context.getProperties();
    int newPoolSize;
    boolean newBackupEnabled;
    int newBackupPeriod;
    int newBackupCount;
    try {
        String s = get(properties, "msgHandlerPoolSize");
        newPoolSize = isNullOrEmpty(s) ? msgHandlerPoolSize : Integer.parseInt(s.trim());
        s = get(properties, "backupEnabled");
        newBackupEnabled = isNullOrEmpty(s) ? backupEnabled : Boolean.parseBoolean(s.trim());
        s = get(properties, "backupPeriod");
        newBackupPeriod = isNullOrEmpty(s) ? backupPeriod : Integer.parseInt(s.trim());
        s = get(properties, "backupCount");
        newBackupCount = isNullOrEmpty(s) ? backupCount : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newPoolSize = MESSAGE_HANDLER_THREAD_POOL_SIZE;
        newBackupEnabled = DEFAULT_BACKUP_ENABLED;
        newBackupPeriod = DEFAULT_BACKUP_PERIOD_MILLIS;
        newBackupCount = DEFAULT_MAX_BACKUP_COUNT;
    }
    boolean restartBackupTask = false;
    if (newBackupEnabled != backupEnabled) {
        backupEnabled = newBackupEnabled;
        if (!backupEnabled) {
            replicaInfoManager.removeListener(flowTable);
            if (backupTask != null) {
                backupTask.cancel(false);
                backupTask = null;
            }
        } else {
            replicaInfoManager.addListener(flowTable);
        }
        restartBackupTask = backupEnabled;
    }
    if (newBackupPeriod != backupPeriod) {
        backupPeriod = newBackupPeriod;
        restartBackupTask = backupEnabled;
    }
    if (restartBackupTask) {
        if (backupTask != null) {
            // cancel previously running task
            backupTask.cancel(false);
        }
        backupTask = backupSenderExecutor.scheduleWithFixedDelay(flowTable::backup, 0, backupPeriod, TimeUnit.MILLISECONDS);
    }
    if (newPoolSize != msgHandlerPoolSize) {
        msgHandlerPoolSize = newPoolSize;
        ExecutorService oldMsgHandler = messageHandlingExecutor;
        messageHandlingExecutor = Executors.newFixedThreadPool(msgHandlerPoolSize, groupedThreads("onos/store/flow", "message-handlers", log));
        // replace previously registered handlers.
        registerMessageHandlers(messageHandlingExecutor);
        oldMsgHandler.shutdown();
    }
    if (backupCount != newBackupCount) {
        backupCount = newBackupCount;
    }
    logConfig("Reconfigured");
}
#end_block

#method_before
private void logConfig(String prefix) {
    log.info("{} with msgHandlerPoolSize = {}; backupEnabled = {}, backupPeriod = {}", prefix, msgHandlerPoolSize, backupEnabled, backupPeriod);
}
#method_after
private void logConfig(String prefix) {
    log.info("{} with msgHandlerPoolSize = {}; backupEnabled = {}, backupPeriod = {}, backupCount = {}", prefix, msgHandlerPoolSize, backupEnabled, backupPeriod, backupCount);
}
#end_block

#method_before
private void handleEvent(ReplicaInfoEvent event) {
    if (!backupEnabled) {
        return;
    }
    if (event.type() == ReplicaInfoEvent.Type.BACKUPS_CHANGED) {
        DeviceId deviceId = event.subject();
        NodeId master = mastershipService.getMasterFor(deviceId);
        if (!Objects.equals(local, master)) {
            // ignore since this event is for a device this node does not manage.
            return;
        }
        NodeId newBackupNode = getBackupNode(deviceId);
        NodeId currentBackupNode = lastBackupNodes.get(deviceId);
        if (Objects.equals(newBackupNode, currentBackupNode)) {
            // ignore since backup location hasn't changed.
            return;
        }
        if (currentBackupNode != null && newBackupNode == null) {
            // Current backup node is most likely down and no alternate backup node
            // has been chosen. Clear current backup location so that we can resume
            // backups when either current backup comes online or a different backup node
            // is chosen.
            log.warn("Lost backup location {} for deviceId {} and no alternate backup node exists. " + "Flows can be lost if the master goes down", currentBackupNode, deviceId);
            lastBackupNodes.remove(deviceId);
            lastBackupTimes.remove(deviceId);
            return;
        // TODO: Pick any available node as backup and ensure hand-off occurs when
        // a new master is elected.
        }
        log.debug("Backup location for {} has changed from {} to {}.", deviceId, currentBackupNode, newBackupNode);
        backupSenderExecutor.schedule(() -> backupFlowEntries(newBackupNode, Sets.newHashSet(deviceId)), 0, TimeUnit.SECONDS);
    }
}
#method_after
private void handleEvent(ReplicaInfoEvent event) {
    DeviceId deviceId = event.subject();
    if (!backupEnabled || !mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    if (event.type() == MASTER_CHANGED) {
        lastUpdateTimes.put(deviceId, System.currentTimeMillis());
    }
    backupSenderExecutor.schedule(this::backup, 0, TimeUnit.SECONDS);
}
#end_block

#method_before
private void backupFlowEntries(NodeId nodeId, Set<DeviceId> deviceIds) {
    if (deviceIds.isEmpty()) {
        return;
    }
    log.debug("Sending flowEntries for devices {} to {} as backup.", deviceIds, nodeId);
    Map<DeviceId, Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>> deviceFlowEntries = Maps.newConcurrentMap();
    deviceIds.forEach(id -> deviceFlowEntries.put(id, ImmutableMap.copyOf(getFlowTable(id))));
    clusterCommunicator.<Map<DeviceId, Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>>, Set<DeviceId>>sendAndReceive(deviceFlowEntries, FLOW_TABLE_BACKUP, SERIALIZER::encode, SERIALIZER::decode, nodeId).whenComplete((backedupDevices, error) -> {
        Set<DeviceId> devicesNotBackedup = error != null ? deviceFlowEntries.keySet() : Sets.difference(deviceFlowEntries.keySet(), backedupDevices);
        if (devicesNotBackedup.size() > 0) {
            log.warn("Failed to backup devices: {}. Reason: {}", devicesNotBackedup, error.getMessage());
        }
        if (backedupDevices != null) {
            backedupDevices.forEach(id -> {
                lastBackupTimes.put(id, System.currentTimeMillis());
                lastBackupNodes.put(id, nodeId);
            });
        }
    });
}
#method_after
private void backupFlowEntries(NodeId nodeId, Set<DeviceId> deviceIds) {
    if (deviceIds.isEmpty()) {
        return;
    }
    log.debug("Sending flowEntries for devices {} to {} for backup.", deviceIds, nodeId);
    Map<DeviceId, Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>> deviceFlowEntries = Maps.newConcurrentMap();
    deviceIds.forEach(id -> deviceFlowEntries.put(id, ImmutableMap.copyOf(getFlowTable(id))));
    clusterCommunicator.<Map<DeviceId, Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>>, Set<DeviceId>>sendAndReceive(deviceFlowEntries, FLOW_TABLE_BACKUP, SERIALIZER::encode, SERIALIZER::decode, nodeId).whenComplete((backedupDevices, error) -> {
        Set<DeviceId> devicesNotBackedup = error != null ? deviceFlowEntries.keySet() : Sets.difference(deviceFlowEntries.keySet(), backedupDevices);
        if (devicesNotBackedup.size() > 0) {
            log.warn("Failed to backup devices: {}. Reason: {}", devicesNotBackedup, error.getMessage());
        }
        if (backedupDevices != null) {
            backedupDevices.forEach(id -> {
                lastBackupTimes.put(new BackupOperation(nodeId, id), System.currentTimeMillis());
            });
        }
    });
}
#end_block

#method_before
private void backup() {
    if (!backupEnabled) {
        return;
    }
    try {
        // determine the set of devices that we need to backup during this run.
        Set<DeviceId> devicesToBackup = flowEntries.keySet().stream().filter(mastershipService::isLocalMaster).filter(deviceId -> {
            Long lastBackupTime = lastBackupTimes.get(deviceId);
            Long lastUpdateTime = lastUpdateTimes.get(deviceId);
            NodeId lastBackupNode = lastBackupNodes.get(deviceId);
            NodeId newBackupNode = getBackupNode(deviceId);
            return lastBackupTime == null || !Objects.equals(lastBackupNode, newBackupNode) || (lastUpdateTime != null && lastUpdateTime > lastBackupTime);
        }).collect(Collectors.toSet());
        // compute a mapping from node to the set of devices whose flow entries it should backup
        Map<NodeId, Set<DeviceId>> devicesToBackupByNode = Maps.newHashMap();
        devicesToBackup.forEach(deviceId -> {
            NodeId backupLocation = getBackupNode(deviceId);
            if (backupLocation != null) {
                devicesToBackupByNode.computeIfAbsent(backupLocation, nodeId -> Sets.newHashSet()).add(deviceId);
            }
        });
        // send the device flow entries to their respective backup nodes
        devicesToBackupByNode.forEach(this::sendBackups);
    } catch (Exception e) {
        log.error("Backup failed.", e);
    }
}
#method_after
private void backup() {
    if (!backupEnabled) {
        return;
    }
    try {
        // compute a mapping from node to the set of devices whose flow entries it should backup
        Map<NodeId, Set<DeviceId>> devicesToBackupByNode = Maps.newHashMap();
        flowEntries.keySet().stream().forEach(deviceId -> {
            List<NodeId> backupNodes = getBackupNodes(deviceId);
            backupNodes.forEach(backupNode -> {
                if (lastBackupTimes.getOrDefault(new BackupOperation(backupNode, deviceId), 0L) < lastUpdateTimes.getOrDefault(deviceId, 0L)) {
                    devicesToBackupByNode.computeIfAbsent(backupNode, nodeId -> Sets.newHashSet()).add(deviceId);
                }
            });
        });
        // send the device flow entries to their respective backup nodes
        devicesToBackupByNode.forEach(this::sendBackups);
    } catch (Exception e) {
        log.error("Backup failed.", e);
    }
}
#end_block

#method_before
@Override
public long life() {
    return life(TimeUnit.SECONDS);
}
#method_after
@Override
public long life() {
    return life(SECONDS);
}
#end_block

#method_before
@Override
public long life(TimeUnit timeUnit) {
    return timeUnit.convert(life, TimeUnit.NANOSECONDS);
}
#method_after
@Override
public long life(TimeUnit timeUnit) {
    return timeUnit.convert(life, NANOSECONDS);
}
#end_block

#method_before
@Override
public void setLife(long life) {
    setLife(life, TimeUnit.SECONDS);
}
#method_after
@Override
public void setLife(long life) {
    setLife(life, SECONDS);
}
#end_block

#method_before
public void waitTimer(Channel ch) throws Exception {
    log.debug("OSPFInterfaceChannelHandler::waitTimer ");
    // section 9.4
    if (state() == OspfInterfaceState.WAITING) {
        electRouter(ch);
    }
}
#method_after
public void waitTimer(Channel ch) throws Exception {
    log.debug("OSPFInterfaceChannelHandler::waitTimer ");
    // According to RFC-2328 section 9.4
    if (state() == OspfInterfaceState.WAITING) {
        electRouter(ch);
    }
}
#end_block

