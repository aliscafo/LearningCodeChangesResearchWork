1367
#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setEdit(false);
            setMessageText(message);
            setDateText(FormatUtil.shortFormatDayTime(result.updated()));
            resizePaddingWidget();
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setEdit(false);
            setMessageText(message);
            setDate(result.updated());
            resizePaddingWidget();
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#end_block

#method_before
public static CommentInput create(CommentInfo original) {
    CommentInput input = createObject().cast();
    input.setId(original.id());
    input.setPath(original.path());
    input.setSide(original.side());
    input.setLine(original.line());
    input.setInReplyTo(original.in_reply_to());
    input.setMessage(original.message());
    return input;
}
#method_after
public static CommentInput create(CommentInfo original) {
    CommentInput input = createObject().cast();
    input.setId(original.id());
    input.setPath(original.path());
    input.setSide(original.side());
    if (original.has_line()) {
        input.setLine(original.line());
    }
    input.setInReplyTo(original.in_reply_to());
    input.setMessage(original.message());
    return input;
}
#end_block

#method_before
@Override
public void onUnload() {
    super.onUnload();
    if (messageClick != null) {
        messageClick.removeHandler();
        messageClick = null;
    }
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    if (messageClick != null) {
        messageClick.removeHandler();
        messageClick = null;
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    headerClick = header.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setOpen(!isOpen());
            if (clickCallback != null) {
                clickCallback.run();
            }
        }
    }, ClickEvent.getType());
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    headerClick = header.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setOpen(!isOpen());
            if (clickCallback != null) {
                clickCallback.run();
            }
        }
    }, ClickEvent.getType());
    res.style().ensureInjected();
}
#end_block

#method_before
private void setOpen(boolean open) {
    if (open) {
        removeStyleName(style.close());
        addStyleName(style.open());
    } else {
        removeStyleName(style.open());
        addStyleName(style.close());
    }
}
#method_after
private void setOpen(boolean open) {
    if (open) {
        removeStyleName(res.style().close());
        addStyleName(res.style().open());
    } else {
        removeStyleName(res.style().open());
        addStyleName(res.style().close());
    }
}
#end_block

#method_before
private boolean isOpen() {
    return getStyleName().contains(style.open());
}
#method_after
private boolean isOpen() {
    return getStyleName().contains(res.style().open());
}
#end_block

#method_before
public final AccountGroup.UUID getGroupUUID() {
    return new AccountGroup.UUID(URL.decodePathSegment(URL.decodeQueryString(id())));
}
#method_after
public final AccountGroup.UUID getGroupUUID() {
    return new AccountGroup.UUID(URL.decodeQueryString(id()));
}
#end_block

#method_before
public final AccountGroup.UUID getOwnerUUID() {
    String owner = owner_id();
    if (owner != null) {
        return new AccountGroup.UUID(URL.decodePathSegment(URL.decodeQueryString(owner)));
    }
    return null;
}
#method_after
public final AccountGroup.UUID getOwnerUUID() {
    String owner = owner_id();
    if (owner != null) {
        return new AccountGroup.UUID(URL.decodeQueryString(owner));
    }
    return null;
}
#end_block

#method_before
public final void setOwnerUUID(AccountGroup.UUID uuid) {
    owner_id(URL.encodePathSegment(URL.encodeQueryString(uuid.get())));
}
#method_after
public final void setOwnerUUID(AccountGroup.UUID uuid) {
    owner_id(URL.encodeQueryString(uuid.get()));
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void insert(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.getChange().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.getChange().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void deleteAll() throws IOException {
    try {
        openIndex.deleteByQuery("*:*");
        closedIndex.deleteByQuery("*:*");
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void deleteAll() throws IOException {
    try {
        openIndex.deleteByQuery("*:*");
        closedIndex.deleteByQuery("*:*");
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SolrServer> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, toQuery(p));
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SolrServer> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, QueryBuilder.toQuery(p));
}
#end_block

#method_before
private void commit(SolrServer server) throws IOException {
    try {
        server.commit();
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
private void commit(SolrServer server) throws IOException {
    try {
        server.commit();
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = null;
        SolrDocumentList docs = new SolrDocumentList();
        query.setParam("shards.tolerant", true);
        for (SolrServer index : indexes) {
            QueryResponse rsp = index.query(query);
            docs.addAll(rsp.getResults());
        }
        result = Lists.newArrayListWithCapacity(docs.size());
        for (SolrDocument doc : docs) {
            Integer v = (Integer) doc.getFieldValue(FIELD_CHANGE);
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = null;
        SolrDocumentList docs = new SolrDocumentList();
        query.setParam("shards.tolerant", true);
        for (SolrServer index : indexes) {
            QueryResponse rsp = index.query(query);
            docs.addAll(rsp.getResults());
        }
        result = Lists.newArrayListWithCapacity(docs.size());
        for (SolrDocument doc : docs) {
            Integer v = (Integer) doc.getFieldValue(FIELD_CHANGE);
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (SolrServerException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
public static IndexImplementation getChangeIndexImpl(Injector injector) {
    if (isEnabled(injector)) {
        Config config = injector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String implementation = config.getString("index", null, "implementation");
        if ("solr".equals(implementation)) {
            return IndexImplementation.SOLR;
        } else {
            return IndexImplementation.LUCENE;
        }
    }
    return IndexImplementation.NONE;
}
#method_after
public static IndexType getChangeIndexImpl(Injector injector) {
    if (isEnabled(injector)) {
        Config config = injector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        return config.getEnum("index", null, "type", IndexType.LUCENE);
    }
    return IndexType.NONE;
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(cfgInjector));
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = cfgInjector.getInstance(SolrIndexModule.class);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    install(new IndexModule(threads));
    bind(String.class).annotatedWith(Names.named("url")).toInstance(url);
    bind(ChangeIndex.class).to(SolrChangeIndex.class);
    listener().to(SolrChangeIndex.class);
    if (checkVersion) {
        listener().to(SolrIndexVersionCheck.class);
    }
}
#method_after
@Override
protected void configure() {
    install(new IndexModule(threads));
    bind(String.class).annotatedWith(SolrIndexUrl.class).toInstance(url);
    bind(ChangeIndex.class).to(SolrChangeIndex.class);
    listener().to(SolrChangeIndex.class);
    if (checkVersion) {
        listener().to(IndexVersionCheck.class);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any LuceneChangeIndex may be created.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    // Delete before any LuceneChangeIndex may be created.
    deleteAll();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(false, threads, dryRun);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(dbInjector), false, threads);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(false, threads, dryRun);
            break;
        case SOLR:
            Config config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
            changeIndexModule = new SolrIndexModule(config, false, threads);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private void writeVersion() throws IOException, ConfigInvalidException {
    if (dryRun) {
        return;
    }
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            LuceneIndexVersionCheck.writeVersion(sitePaths);
            break;
        case SOLR:
            SolrIndexVersionCheck.writeVersion(sitePaths);
            break;
        default:
            return;
    }
}
#method_after
private void writeVersion() throws IOException, ConfigInvalidException {
    if (dryRun) {
        return;
    }
    ChangeIndex index = sysInjector.getInstance(ChangeIndex.class);
    index.finishIndex();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(cfgInjector));
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = cfgInjector.getInstance(SolrIndexModule.class);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, toQuery(p));
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, QueryBuilder.toQuery(p));
}
#end_block

#method_before
private Term idTerm(ChangeData cd) {
    return intTerm(FIELD_CHANGE, cd.getId().get());
}
#method_after
private Term idTerm(ChangeData cd) {
    return QueryBuilder.intTerm(FIELD_CHANGE, cd.getId().get());
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw QueryBuilder.badFieldType(f.getType());
    }
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        return object.commitMessage(repoManager, db).contains(value);
    } catch (IOException e) {
        return false;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        for (ChangeData cData : index.getSource(Predicate.and(new LegacyChangeIdPredicate(db, object.getId()), this)).read()) {
            if (cData.getId().equals(object.getId())) {
                return true;
            }
        }
    } catch (QueryParseException e) {
        throw new OrmException(e);
    }
    return false;
}
#end_block

#method_before
@Override
public void start() {
// Do nothing.
}
#method_after
@Override
public void start() {
}
#end_block

#method_before
@Override
public void stop() {
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    List<Future<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    for (Future<?> future : closeFutures) {
        Futures.getUnchecked(future);
    }
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.insert(doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.insert(doc));
    }
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.replace(id, doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.replace(id, doc));
    }
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    return allOf(openIndex.delete(id), closedIndex.delete(id));
}
#end_block

#method_before
private Term idTerm(ChangeData cd) {
    return intTerm(FIELD_CHANGE, cd.getId().get());
}
#method_after
private Term idTerm(ChangeData cd) {
    return intTerm(ID_FIELD, cd.getId().get());
}
#end_block

#method_before
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#method_after
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        if (p.getChild(0) instanceof TimestampRangePredicate) {
            return notTimestampQuery((TimestampRangePredicate<ChangeData>) p.getChild(0));
        }
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#end_block

#method_before
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#method_after
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.TIMESTAMP) {
        return timestampQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.PREFIX) {
        return prefixQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else if (p instanceof SortKeyPredicate) {
        return sortKeyQuery((SortKeyPredicate) p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getOperator(), value));
}
#method_after
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getField().getName(), value));
}
#end_block

#method_before
private Query exactQuery(IndexPredicate<ChangeData> p) {
    return new TermQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query exactQuery(IndexPredicate<ChangeData> p) {
    if (p instanceof RegexPredicate<?>) {
        return regexQuery(p);
    } else {
        return new TermQuery(new Term(p.getField().getName(), p.getValue()));
    }
}
#end_block

#method_before
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getField().getName(), p.getValue()));
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    Sort sort = new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.INT, true));
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT, sort);
        }
        TopDocs docs = TopDocs.merge(sort, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc, FIELDS);
            Number v = doc.getField(ID_FIELD).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                Object val = f.get(cd, fillArgs);
                if (val != null) {
                    add(result, f, Collections.singleton(val));
                }
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    String name = f.getName();
    Store store = store(f);
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (f.getType() == FieldType.LONG) {
        for (Object value : values) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (f.getType() == FieldType.TIMESTAMP) {
        for (Object v : values) {
            doc.add(new IntField(name, toIndexTime((Timestamp) v), store));
        }
    } else if (f.getType() == FieldType.EXACT || f.getType() == FieldType.PREFIX) {
        for (Object value : values) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch) {
    if (!running) {
        log.warn("Replication plugin did not finish startup before event");
        return;
    }
    for (Destination cfg : configs) {
        for (URIish uri : cfg.getURIs(project, urlMatch)) {
            cfg.schedule(project, PushOne.ALL_REFS, uri);
        }
    }
}
#method_after
void scheduleFullSync(final Project.NameKey project, final String urlMatch) {
    if (!running) {
        log.warn("Replication plugin did not finish startup before event");
        return;
    }
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri);
            }
        }
    }
}
#end_block

#method_before
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, internalUserFactory, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    if (projectMatch != null) {
        if (projectMatch.endsWith("/*")) {
            // special case
            return project.get().startsWith(projectMatch.substring(0, projectMatch.length() - 1));
        } else {
            String projectPattern;
            if (isRE(projectMatch)) {
                projectPattern = projectMatch.substring(1);
            } else {
                projectPattern = projectMatch;
            }
            return (new RegExp(projectPattern)).toAutomaton().run(project.get());
        }
    }
    return true;
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    addPanel.setVisible(false);
    AccountApi.canCreateRefs("self", getProjectKey(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            addPanel.setVisible(true);
        }
    });
    refreshBranches();
    savedPanel = BRANCH;
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    addPanel.setVisible(false);
    AccessMap.get(getProjectKey(), new GerritCallback<ProjectAccessInfo>() {

        @Override
        public void onSuccess(ProjectAccessInfo result) {
            addPanel.setVisible(result.canAddRefs());
        }
    });
    refreshBranches();
    savedPanel = BRANCH;
}
#end_block

#method_before
private void refreshBranches() {
    ProjectApi.getBranches(getProjectKey(), new ScreenLoadCallback<JsArray<BranchInfo>>(this) {

        @Override
        public void preDisplay(final JsArray<BranchInfo> result) {
            display(Natives.asList(result));
            enableForm();
        }
    });
}
#method_after
private void refreshBranches() {
    ProjectApi.getBranches(getProjectKey(), new ScreenLoadCallback<JsArray<BranchInfo>>(this) {

        @Override
        public void preDisplay(final JsArray<BranchInfo> result) {
            display(Natives.asList(result));
            updateForm();
        }
    });
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return new RegexBranchPredicate(args.dbProvider, name);
    return new BranchPredicate(args.dbProvider, name);
}
#method_after
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return ref("^" + branchToRef(name.substring(1)));
    return ref(branchToRef(name));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (!allowsFile) {
        throw error("operator not permitted here: file:" + file);
    }
    if (file.startsWith("^")) {
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (allowFileRegex || args.index != ChangeIndex.DISABLED) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw error("secondary index must be enabled for file:" + file);
        }
    } else {
        if (args.index == ChangeIndex.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    String[] splitReviewer = name.split("~");
    name = splitReviewer[0];
    if (splitReviewer.length > 2) {
        throw new QueryParseException("more than one user specified");
    } else if (splitReviewer.length == 2) {
        accounts = parseAccount(splitReviewer[1]);
    }
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, name, accounts);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.dbProvider, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id)));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
public Builder copyFrom(GitilesView other) {
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
            path = other.path;
        // Fallthrough.
        case REVISION:
        case TAR:
        case ZIP:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    // Don't copy params.
    return this;
}
#method_after
public Builder copyFrom(GitilesView other) {
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
            path = other.path;
        // Fallthrough.
        case REVISION:
        case ARCHIVE:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    if (type == Type.ARCHIVE) {
        extension = other.extension;
    }
    // Don't copy params.
    return this;
}
#end_block

#method_before
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            this.oldRevision = checkNotNull(revision);
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set old revision on %s view", type));
    }
}
#method_after
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            this.oldRevision = revision;
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set old revision on %s view", type));
    }
}
#end_block

#method_before
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case TAR:
        case ZIP:
            checkArchive();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, params, anchor);
}
#method_after
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case ARCHIVE:
            checkArchive();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, extension, params, anchor);
}
#end_block

#method_before
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case TAR:
            url.append(repositoryName).append("/+tar/").append(revision.getName());
            break;
        case ZIP:
            url.append(repositoryName).append("/+zip/").append(revision.getName());
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url.toString();
}
#method_after
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case ARCHIVE:
            url.append(repositoryName).append("/+archive/").append(revision.getName()).append(Objects.firstNonNull(extension, DEFAULT_ARCHIVE_EXTENSION));
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url.toString();
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    Repository repo = ServletUtils.getRepository(req);
    // Check object type before starting the archive. If we just caught the
    // exception from cmd.call() below, we wouldn't know whether it was because
    // the input object is not a tree or something broke later.
    RevWalk walk = new RevWalk(repo);
    try {
        walk.parseTree(rev.getId());
    } catch (IncorrectObjectTypeException e) {
        res.sendError(SC_NOT_FOUND);
        return;
    } finally {
        walk.release();
    }
    String filename = getFilename(view, rev);
    setRawHeaders(req, res, filename, format.mimeType);
    res.setStatus(SC_OK);
    try {
        new ArchiveCommand(repo).setFormat(format.name).setTree(rev.getId()).setOutputStream(res.getOutputStream()).call();
    } catch (GitAPIException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    Repository repo = ServletUtils.getRepository(req);
    // Check object type before starting the archive. If we just caught the
    // exception from cmd.call() below, we wouldn't know whether it was because
    // the input object is not a tree or something broke later.
    RevWalk walk = new RevWalk(repo);
    try {
        walk.parseTree(rev.getId());
    } catch (IncorrectObjectTypeException e) {
        res.sendError(SC_NOT_FOUND);
        return;
    } finally {
        walk.release();
    }
    Format format = FORMATS_BY_EXTENSION.get(view.getExtension());
    String filename = getFilename(view, rev, view.getExtension());
    setDownloadHeaders(req, res, filename, format.mimeType);
    res.setStatus(SC_OK);
    try {
        new ArchiveCommand(repo).setFormat(format.name()).setTree(rev.getId()).setOutputStream(res.getOutputStream()).call();
    } catch (GitAPIException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private String getFilename(GitilesView view, Revision rev) {
    return new StringBuilder().append(view.getRepositoryName().replace('/', '-')).append('-').append(rev.getName()).append(format.format.suffixes().iterator().next()).toString();
}
#method_after
private String getFilename(GitilesView view, Revision rev, String ext) {
    return new StringBuilder().append(Paths.basename(view.getRepositoryName())).append('-').append(rev.getName()).append(ext).toString();
}
#end_block

#method_before
public void testPath() throws Exception {
    RevCommit master = repo.branch("refs/heads/master").commit().create();
    GitilesView view;
    view = getView("/repo/+show/master/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("", view.getPathPart());
    view = getView("/repo/+show/master/foo");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/bar");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo/bar", view.getPathPart());
}
#method_after
public void testPath() throws Exception {
    RevCommit master = repo.branch("refs/heads/master").commit().create();
    repo.branch("refs/heads/stable").commit().create();
    GitilesView view;
    view = getView("/repo/+show/master/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("", view.getPathPart());
    view = getView("/repo/+show/master/foo");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/bar");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo/bar", view.getPathPart());
    assertNull(getView("/repo/+show/stable..master/foo"));
}
#end_block

#method_before
static String trimLeadingSlash(String str) {
    checkArgument(str.startsWith("/"), "expected string starting with a slash: %s", str);
    return str.substring(1);
}
#method_after
static String trimLeadingSlash(String str) {
    return checkLeadingSlash(str).substring(1);
}
#end_block

#method_before
private GitilesView.Builder parse(HttpServletRequest req) throws IOException {
    String repoName = trimLeadingSlash(getRegexGroup(req, 1));
    String command = getRegexGroup(req, 2);
    String path = getRegexGroup(req, 3);
    boolean emptyPath = (path.isEmpty() || path.equals("/"));
    // Non-path cases.
    if (repoName.isEmpty()) {
        return GitilesView.hostIndex();
    } else if (command.equals(CMD_REFS)) {
        return GitilesView.refs().setRepositoryName(repoName).setPathPart(path);
    } else if (command.equals(CMD_LOG) && emptyPath) {
        return GitilesView.log().setRepositoryName(repoName);
    } else if (command.equals(CMD_DESCRIBE) && !emptyPath) {
        return GitilesView.describe().setRepositoryName(repoName).setPathPart(path);
    } else if (command.isEmpty()) {
        return GitilesView.repositoryIndex().setRepositoryName(repoName);
    } else if (path.isEmpty()) {
        // Command that requires a path, but no path.
        return null;
    }
    path = trimLeadingSlash(path);
    RevisionParser revParser = new RevisionParser(ServletUtils.getRepository(req), accessFactory.forRequest(req), visibilityCache);
    RevisionParser.Result result = revParser.parse(path);
    if (result == null) {
        return null;
    }
    path = path.substring(result.getPathStart());
    command = getCommand(command, result, path);
    GitilesView.Builder view;
    if (CMD_LOG.equals(command)) {
        view = GitilesView.log().setPathPart(path);
    } else if (CMD_SHOW.equals(command)) {
        if (path.isEmpty()) {
            view = GitilesView.revision();
        } else {
            view = GitilesView.path().setPathPart(path);
        }
    } else if (CMD_DIFF.equals(command)) {
        view = GitilesView.diff().setPathPart(path);
    } else if (CMD_REFS.equals(command)) {
        view = GitilesView.repositoryIndex();
    } else if (command.equals(CMD_TAR)) {
        view = GitilesView.tar();
    } else if (command.equals(CMD_ZIP)) {
        view = GitilesView.zip();
    } else {
        // Bad command.
        return null;
    }
    if (result.getOldRevision() != null) {
        // May be NULL.
        view.setOldRevision(result.getOldRevision());
    }
    view.setRepositoryName(repoName).setRevision(result.getRevision());
    return view;
}
#method_after
private GitilesView.Builder parse(HttpServletRequest req) throws IOException {
    String repoName = trimLeadingSlash(getRegexGroup(req, 1));
    if (repoName.isEmpty()) {
        return GitilesView.hostIndex();
    }
    String command = getRegexGroup(req, 2);
    String path = getRegexGroup(req, 3);
    if (command.isEmpty()) {
        return parseNoCommand(req, repoName, path);
    } else if (command.equals(CMD_ARCHIVE)) {
        return parseArchiveCommand(req, repoName, path);
    } else if (command.equals(CMD_AUTO)) {
        return parseAutoCommand(req, repoName, path);
    } else if (command.equals(CMD_DESCRIBE)) {
        return parseDescribeCommand(req, repoName, path);
    } else if (command.equals(CMD_DIFF)) {
        return parseDiffCommand(req, repoName, path);
    } else if (command.equals(CMD_LOG)) {
        return parseLogCommand(req, repoName, path);
    } else if (command.equals(CMD_REFS)) {
        return parseRefsCommand(req, repoName, path);
    } else if (command.equals(CMD_SHOW)) {
        return parseShowCommand(req, repoName, path);
    } else {
        return null;
    }
}
#end_block

#method_before
public synchronized BaseServlet getDefaultHandler(GitilesView.Type view) {
    checkNotInitialized();
    switch(view) {
        case HOST_INDEX:
            return new HostIndexServlet(renderer, urls, accessFactory);
        case REPOSITORY_INDEX:
            return new RepositoryIndexServlet(renderer, accessFactory, timeCache);
        case REFS:
            return new RefServlet(renderer, timeCache);
        case REVISION:
            return new RevisionServlet(renderer, linkifier());
        case PATH:
            return new PathServlet(renderer, urls);
        case DIFF:
            return new DiffServlet(renderer, linkifier());
        case LOG:
            return new LogServlet(renderer, linkifier());
        case DESCRIBE:
            return new DescribeServlet();
        case TAR:
            return new ArchiveServlet(ArchiveServlet.Format.TGZ);
        case ZIP:
            return new ArchiveServlet(ArchiveServlet.Format.ZIP);
        default:
            throw new IllegalArgumentException("Invalid view type: " + view);
    }
}
#method_after
public synchronized BaseServlet getDefaultHandler(GitilesView.Type view) {
    checkNotInitialized();
    switch(view) {
        case HOST_INDEX:
            return new HostIndexServlet(renderer, urls, accessFactory);
        case REPOSITORY_INDEX:
            return new RepositoryIndexServlet(renderer, accessFactory, timeCache);
        case REFS:
            return new RefServlet(renderer, timeCache);
        case REVISION:
            return new RevisionServlet(renderer, linkifier());
        case PATH:
            return new PathServlet(renderer, urls);
        case DIFF:
            return new DiffServlet(renderer, linkifier());
        case LOG:
            return new LogServlet(renderer, linkifier());
        case DESCRIBE:
            return new DescribeServlet();
        case ARCHIVE:
            return new ArchiveServlet();
        default:
            throw new IllegalArgumentException("Invalid view type: " + view);
    }
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try {
        final ReviewDb db = schemaFactory.open();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    return Providers.of(db);
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            index.replace(cd);
            return null;
        } finally {
            context.setContext(null);
            db.close();
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#method_after
@Override
public Void call() throws Exception {
    try {
        final ReviewDb db = schemaFactory.open();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    return Providers.of(db);
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            index.replace(cd);
            return null;
        } finally {
            context.setContext(null);
            db.close();
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any index may be created depending on this data.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any index may be created depending on this data.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private int indexAll() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    ListeningScheduledExecutorService executor = sysInjector.getInstance(Key.get(ListeningScheduledExecutorService.class, IndexExecutor.class));
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.start(1);
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    Set<Project.NameKey> projects;
    try {
        projects = Sets.newTreeSet();
        for (Change change : db.changes().all()) {
            int n = projects.size();
            projects.add(change.getProject());
            int d = projects.size() - n;
            if (d > 0) {
                pm.update(d);
            }
        }
    } finally {
        db.close();
    }
    pm.endTask();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(System.out, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", projects.size());
    final Task doneTask = mpm.beginSubTask(null, MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    Stopwatch sw = new Stopwatch().start();
    final CountDownLatch latch = new CountDownLatch(projects.size());
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(new ReindexProject(project, doneTask, failedTask));
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    // Logged by indexer.
                    ok.set(false);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                    latch.countDown();
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    mpm.waitFor(sysInjector.getInstance(WorkQueue.class).getDefaultQueue().submit(new Runnable() {

        @Override
        public void run() {
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            mpm.end();
        }
    }));
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    int n = doneTask.getCount() + failedTask.getCount();
    System.out.format("Reindexed %d changes in %.01fs (%.01f/s)\n", n, elapsed, n / elapsed);
    return ok.get() ? 0 : 1;
}
#method_after
private int indexAll() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    ListeningScheduledExecutorService executor = sysInjector.getInstance(Key.get(ListeningScheduledExecutorService.class, IndexExecutor.class));
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.start(1);
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    Set<Project.NameKey> projects = Sets.newTreeSet();
    try {
        for (Change change : db.changes().all()) {
            if (projects.add(change.getProject())) {
                pm.update(1);
            }
        }
    } finally {
        db.close();
    }
    pm.endTask();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(System.out, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", projects.size());
    final Task doneTask = mpm.beginSubTask(null, MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    Stopwatch sw = new Stopwatch().start();
    final List<ListenableFuture<?>> futures = Lists.newArrayListWithCapacity(projects.size());
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(new ReindexProject(project, doneTask, failedTask));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    // Logged by indexer.
                    ok.set(false);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

        @Override
        public ListenableFuture<Void> apply(List<?> input) throws Exception {
            mpm.end();
            return Futures.immediateFuture(null);
        }
    }));
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    int n = doneTask.getCount() + failedTask.getCount();
    System.out.format("Reindexed %d changes in %.01fs (%.01f/s)\n", n, elapsed, n / elapsed);
    return ok.get() ? 0 : 1;
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    GitRepositoryManager mgr = sysInjector.getInstance(GitRepositoryManager.class);
    repo = mgr.openRepository(project);
    try {
        Map<String, Ref> refs = repo.getAllRefs();
        for (Change c : db.changes().all()) {
            Ref r = refs.get(c.currentPatchSetId().toRefName());
            if (r != null) {
                byId.put(r.getObjectId(), new ChangeData(c));
            }
        }
        walk();
    } finally {
        repo.close();
        // Only used once per Reindex call.
        RepositoryCache.close(repo);
    }
    return null;
}
#method_after
@Override
public Void call() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    GitRepositoryManager mgr = sysInjector.getInstance(GitRepositoryManager.class);
    repo = mgr.openRepository(project);
    try {
        Map<String, Ref> refs = repo.getAllRefs();
        for (Change c : db.changes().byProject(project)) {
            Ref r = refs.get(c.currentPatchSetId().toRefName());
            if (r != null) {
                byId.put(r.getObjectId(), new ChangeData(c));
            }
        }
        walk();
    } finally {
        repo.close();
        // Only used once per Reindex call.
        RepositoryCache.close(repo);
    }
    return null;
}
#end_block

#method_before
private void walk() throws Exception {
    walk = new RevWalk(repo);
    try {
        // to mark every single change.
        for (Ref ref : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            RevObject o = walk.parseAny(ref.getObjectId());
            if (!(o instanceof RevCommit)) {
                continue;
            }
            walk.markStart((RevCommit) o);
        }
        RevCommit bCommit;
        while ((bCommit = walk.next()) != null) {
            if (!byId.containsKey(bCommit)) {
                // Not a change, skip diff.
                continue;
            }
            getPathsAndIndex(bCommit, true);
            if (byId.isEmpty()) {
                break;
            }
        }
        for (ObjectId id : byId.keySet()) {
            getPathsAndIndex(walk.parseCommit(id), false);
        }
    } finally {
        walk.release();
    }
}
#method_after
private void walk() throws Exception {
    walk = new RevWalk(repo);
    try {
        // to mark every single change.
        for (Ref ref : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            RevObject o = walk.parseAny(ref.getObjectId());
            if (o instanceof RevCommit) {
                walk.markStart((RevCommit) o);
            }
        }
        RevCommit bCommit;
        while ((bCommit = walk.next()) != null && !byId.isEmpty()) {
            if (byId.containsKey(bCommit)) {
                getPathsAndIndex(bCommit);
                byId.removeAll(bCommit);
            }
        }
        for (ObjectId id : byId.keySet()) {
            getPathsAndIndex(walk.parseCommit(id));
        }
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void getPathsAndIndex(RevCommit bCommit, boolean remove) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = remove ? byId.removeAll(bCommit) : byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    cd.setCurrentFilePaths(paths);
                    indexer.indexTask(cd).call();
                    done.update(1);
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        failed.update(1);
    }
}
#method_after
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    cd.setCurrentFilePaths(paths);
                    indexer.indexTask(cd).call();
                    done.update(1);
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        failed.update(1);
    }
}
#end_block

#method_before
public static Timestamp timeFromSortKey(String sortKey) {
    String ts = sortKey.substring(0, 8);
    int i = 0;
    while (i < 8 && ts.charAt(i) == '0') i++;
    long v = Long.parseLong(ts.substring(i), 16) * 60;
    return new Timestamp((v + SORT_KEY_EPOCH) * 1000);
}
#method_after
public static Timestamp timeFromSortKey(String sortKey) {
    if ("z".equals(sortKey)) {
        return new Timestamp(Long.MAX_VALUE);
    }
    String ts = sortKey.substring(0, 8);
    int i = 0;
    while (i < 8 && ts.charAt(i) == '0') i++;
    long v = Long.parseLong(ts.substring(i), 16) * 60;
    return new Timestamp((v + SORT_KEY_EPOCH) * 1000);
}
#end_block

#method_before
@Override
public void start() {
// Do nothing.
}
#method_after
@Override
public void start() {
    refreshThread.start();
}
#end_block

#method_before
@Override
public void stop() {
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    refreshThread.halt();
    List<Future<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    for (Future<?> future : closeFutures) {
        Futures.getUnchecked(future);
    }
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#method_after
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#end_block

#method_before
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#method_after
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        if (p.getChild(0) instanceof TimestampRangePredicate) {
            return notTimestampQuery((TimestampRangePredicate<ChangeData>) p.getChild(0));
        }
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#end_block

#method_before
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p instanceof AgePredicate) {
        int t = ChangeField.toIndexTime(((AgePredicate) p).getCutTimestamp());
        return NumericRangeQuery.newIntRange(p.getField().getName(), 0, t, true, true);
    } else if (p instanceof SortKeyPredicate) {
        int t = ChangeField.toIndexTime(((SortKeyPredicate) p).getCutTimestamp());
        if (p instanceof SortKeyPredicate.Before) {
            return NumericRangeQuery.newIntRange(p.getField().getName(), 0, t, true, true);
        } else {
            return NumericRangeQuery.newIntRange(p.getField().getName(), t, Integer.MAX_VALUE, true, true);
        }
    } else if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#method_after
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.TIMESTAMP) {
        return timestampQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT);
        }
        TopDocs docs = TopDocs.merge(null, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc);
            Number v = doc.getField(FIELD_CHANGE).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    String name = f.getName();
    Store store = store(f);
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (f.getType() == FieldType.TIMESTAMP) {
        for (Object v : values) {
            doc.add(new IntField(name, toIndexTime((Timestamp) v), store));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#end_block

#method_before
long getCut() {
    return cut;
}
#method_after
long getCut() {
    return cut + 1;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    Change change = object.change(dbProvider);
    return change != null && change.getLastUpdatedOn().getTime() < cut;
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    Change change = object.change(dbProvider);
    return change != null && change.getLastUpdatedOn().getTime() <= cut;
}
#end_block

#method_before
@Override
public void stop() {
    refreshThread.stop = true;
    try {
        refreshThread.join();
    } catch (InterruptedException e) {
        log.warn("error stopping refresh thread", e);
    }
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    refreshThread.halt();
    openIndex.close();
    closedIndex.close();
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT);
        }
        TopDocs docs = TopDocs.merge(null, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc);
            Number v = doc.getField(FIELD_CHANGE).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        if (stop) {
            break;
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            log.warn("error refreshing index searchers", e);
        }
        openIndex.maybeRefresh();
        closedIndex.maybeRefresh();
    }
}
#method_after
@Override
public void run() {
    while (!stop) {
        openIndex.maybeRefresh();
        closedIndex.maybeRefresh();
        synchronized (this) {
            try {
                wait(100);
            } catch (InterruptedException e) {
                log.warn("error refreshing index searchers", e);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    for (AccountGroup.Id groupId : groups) {
        GroupResource resource = toResource(groupId);
        if (!accountsToRemove.isEmpty()) {
            deleteMembers.apply(resource, fromMembers(accountsToRemove));
        }
        if (!groupsToRemove.isEmpty()) {
            deleteIncludedGroups.apply(resource, fromGroups(groupsToRemove));
        }
        if (!accountsToAdd.isEmpty()) {
            reportMembersAdded(resource.getName(), addMembers.apply(resource, fromMembers(accountsToAdd)));
        }
        if (!groupsToInclude.isEmpty()) {
            reportGroupsAdded(resource.getName(), addIncludedGroups.apply(resource, fromGroups(groupsToInclude)));
        }
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    for (AccountGroup.UUID groupUuid : groups) {
        GroupResource resource = groupsCollection.parse(TopLevelResource.INSTANCE, IdString.fromUrl(groupUuid.get()));
        if (!accountsToRemove.isEmpty()) {
            deleteMembers.get().apply(resource, fromMembers(accountsToRemove));
            reportMembersAction("removed from", resource, accountsToRemove);
        }
        if (!groupsToRemove.isEmpty()) {
            deleteIncludedGroups.get().apply(resource, fromGroups(groupsToRemove));
            reportGroupsAction("excluded from", resource, groupsToRemove);
        }
        if (!accountsToAdd.isEmpty()) {
            addMembers.get().apply(resource, fromMembers(accountsToAdd));
            reportMembersAction("added to", resource, accountsToAdd);
        }
        if (!groupsToInclude.isEmpty()) {
            addIncludedGroups.get().apply(resource, fromGroups(groupsToInclude));
            reportGroupsAction("included to", resource, groupsToInclude);
        }
    }
}
#end_block

#method_before
private AddIncludedGroups.Input fromGroups(List<AccountGroup.Id> accounts) {
    return AddIncludedGroups.Input.fromGroups(Lists.newArrayList(Iterables.transform(accounts, new Function<AccountGroup.Id, String>() {

        @Override
        public String apply(AccountGroup.Id id) {
            return id.toString();
        }
    })));
}
#method_after
private AddIncludedGroups.Input fromGroups(List<AccountGroup.UUID> accounts) {
    return AddIncludedGroups.Input.fromGroups(Lists.newArrayList(Iterables.transform(accounts, new Function<AccountGroup.UUID, String>() {

        @Override
        public String apply(AccountGroup.UUID uuid) {
            return uuid.toString();
        }
    })));
}
#end_block

#method_before
protected int getInsertRow(Comparator<RowItem> comparator, RowItem item) {
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        RowItem i = getRowItem(middle);
        int cmp = comparator.compare(i, item);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return -1;
        }
    }
    return left;
}
#method_after
protected int getInsertRow(Comparator<RowItem> comparator, RowItem item) {
    int row = lookupRowItem(comparator, item);
    if (row >= table.getRowCount() || comparator.compare(item, getRowItem(row)) != 0) {
        return row;
    }
    return -1;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new ServletModule() {

                @Override
                protected void configureServlets() {
                    serve("/become").with(BecomeAnyAccountLoginServlet.class);
                }
            });
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    factory(ClearPassword.Factory.class);
    install(new CmdLineParserModule());
    factory(GeneratePassword.Factory.class);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new BecomeAnyAccountModule());
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig, uiOptions));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    install(new AsyncReceiveCommits.Module());
    install(new CmdLineParserModule());
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#end_block

#method_before
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null, null);
    saveCookie();
}
#end_block

#method_before
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null);
    user = null;
}
#method_after
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null, null);
    user = null;
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    try {
        int status = SC_OK;
        checkUserSession(req);
        List<String> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            view = rc.list();
        } else {
            String id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                view = c.list();
                break;
            } else {
                rsrc = c.parse(rsrc, path.remove(0));
                view = view(c, req.getMethod(), path);
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        Multimap<String, String> params = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        Object result;
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            result = m.apply(rsrc, parseRequest(req, m.inputType()));
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, SC_CONFLICT, e.getMessage());
    } catch (ResourceNotFoundException e) {
        replyError(res, SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        handleException(e, req, res);
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            if ("GET".equals(req.getMethod())) {
                view = rc.list();
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                view = ac.post(rsrc);
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req, rsrc);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                if ("GET".equals(req.getMethod())) {
                    view = c.list();
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    view = ac.post(rsrc);
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req, rsrc);
                    view = null;
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        view = ac.create(rsrc, id);
                        status = SC_CREATED;
                    } else {
                        throw e;
                    }
                }
                if (view == null) {
                    view = view(c, req.getMethod(), path);
                }
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, r);
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (PreconditionFailedException e) {
        replyError(res, status = SC_PRECONDITION_FAILED, Objects.firstNonNull(e.getMessage(), "Precondition failed"));
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (UnprocessableEntityException e) {
        replyError(res, status = 422, Objects.firstNonNull(e.getMessage(), "Unprocessable Entity"));
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (MalformedJsonException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new HttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getRequestURI(), auditStartTs, params, req.getMethod(), inputRequestBody, status, result));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Class<Object> type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (type.getDeclaredFields().length == 0 && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            json.setLenient(true);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if (("PUT".equals(req.getMethod()) || "POST".equals(req.getMethod())) && acceptsRawInput(type)) {
        return parseRawInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
private Object parseString(String value, Class<Object> type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    Object obj = createInstance(type);
    Field[] fields = type.getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#method_after
private Object parseString(String value, Type type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    if (type == String.class) {
        return value;
    }
    Object obj = createInstance(type);
    Field[] fields = obj.getClass().getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#end_block

#method_before
private static Object createInstance(Class<Object> type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<Object> c = type.getDeclaredConstructor();
    c.setAccessible(true);
    return c.newInstance();
}
#method_after
private static Object createInstance(Type type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (type instanceof Class) {
        @SuppressWarnings("unchecked")
        Class<Object> clazz = (Class<Object>) type;
        Constructor<Object> c = clazz.getDeclaredConstructor();
        c.setAccessible(true);
        return c.newInstance();
    }
    throw new InstantiationException("Cannot make " + type);
}
#end_block

#method_before
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#method_after
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder();
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, Splitter.on(',').omitEmptyStrings().trimResults().split(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = NAMING.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#method_after
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, OptionUtil.splitOptionValue(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = // 
                        FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#end_block

#method_before
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                if (buf.length() < len) {
                    res.setContentLength((int) buf.length());
                    res.setHeader("Content-Encoding", "gzip");
                    buf.writeTo(dst, null);
                } else {
                    replyUncompressed(res, dst, bin, len);
                }
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                replyUncompressed(res, dst, bin, len);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#method_after
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.isBase64()) {
            bin = stackBase64(res, bin);
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        OutputStream dst = res.getOutputStream();
        try {
            bin.writeTo(dst);
        } finally {
            dst.close();
        }
    } finally {
        appResult.close();
    }
}
#end_block

#method_before
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<String> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final String projection = path.isEmpty() ? "/" : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private static List<String> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<String> out = Lists.newArrayList(Splitter.on('/').split(path));
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#method_after
private static List<IdString> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<IdString> out = Lists.newArrayList();
    for (String p : Splitter.on('/').split(path)) {
        out.add(IdString.fromUrl(p));
    }
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#end_block

#method_before
private static List<String> splitProjection(String projection) {
    return Lists.newArrayList(Splitter.on('~').limit(2).split(projection));
}
#method_after
private static List<String> splitProjection(IdString projection) {
    List<String> p = Lists.newArrayListWithCapacity(2);
    Iterables.addAll(p, Splitter.on('~').limit(2).split(projection.get()));
    return p;
}
#end_block

#method_before
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#method_after
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method. In order to authenticate, prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#end_block

#method_before
static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    replyText(null, res, msg);
}
#method_after
public static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    CacheHeaders.setNotCacheable(res);
    replyText(null, res, msg);
}
#end_block

#method_before
public static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#method_after
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#end_block

#method_before
private static TemporaryBuffer.Heap compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.finish();
    gz.flush();
    return buf;
}
#method_after
private static BinaryResult compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.close();
    return asBinaryResult(buf).setContentType(bin.getContentType());
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser user = session.get().getCurrentUser();
        if (!user.getCapabilities().canAdministrateServer()) {
            error(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            error(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            error(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            RestApiServlet.replyError((HttpServletResponse) res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#end_block

#method_before
public static RestApi capabilities() {
    return new RestApi("/config/server/capabilities/");
}
#method_after
public static void capabilities(AsyncCallback<NativeMap<CapabilityInfo>> cb) {
    new RestApi("/config/server/capabilities/").get(cb);
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        /*
      for (String varName : Util.C.capabilityNames().keySet()) {
        addPermission(varName, perms);
      }
      */
        for (String varName : projectAccess.getCapabilities().keySet()) {
            addPermission(varName, perms);
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (LabelType t : projectAccess.getLabelTypes().getLabelTypes()) {
            addPermission(Permission.LABEL + t.getName(), perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : projectAccess.getCapabilities().keySet()) {
            addPermission(varName, perms);
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (LabelType t : projectAccess.getLabelTypes().getLabelTypes()) {
            addPermission(Permission.LABEL + t.getName(), perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ConfigServerApi.capabilities().get(cbs.add(new AsyncCallback<CapabilityMap>() {

        @Override
        public void onSuccess(CapabilityMap result) {
            capabilityMap = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.PROJECT_SVC.projectAccess(getProjectKey(), cbs.addGwtjsonrpc(new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    }));
    savedPanel = ACCESS;
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ConfigServerApi.capabilities(cbs.add(new AsyncCallback<NativeMap<CapabilityInfo>>() {

        @Override
        public void onSuccess(NativeMap<CapabilityInfo> result) {
            capabilityMap = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.PROJECT_SVC.projectAccess(getProjectKey(), cbs.addGwtjsonrpc(new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    }));
    savedPanel = ACCESS;
}
#end_block

#method_before
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    Map<String, String> allCapabilities = new HashMap<String, String>();
    for (final CapabilityInfo c : Natives.asList(capabilityMap.values())) {
        allCapabilities.put(c.id(), c.name());
    }
    this.access.setCapabilities(allCapabilities);
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty() || access.canUpload());
    edit.setEnabled(!access.getOwnerOf().isEmpty() || access.canUpload());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#method_after
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    Map<String, String> allCapabilities = new HashMap<String, String>();
    for (CapabilityInfo c : Natives.asList(capabilityMap.values())) {
        allCapabilities.put(c.id(), c.name());
    }
    this.access.setCapabilities(allCapabilities);
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty() || access.canUpload());
    edit.setEnabled(!access.getOwnerOf().isEmpty() || access.canUpload());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#end_block

#method_before
@Override
public CapabilityResource parse(ConfigResource parent, IdString id) throws ResourceNotFoundException, Exception {
    return null;
}
#method_after
@Override
public CapabilityResource parse(ConfigResource parent, IdString id) throws ResourceNotFoundException {
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
public Object apply(ConfigResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final Map<String, CapabilityInfo> output = Maps.newTreeMap();
    Class<? extends CapabilityConstants> bundleClass = CapabilityConstants.get().getClass();
    CapabilityConstants c = CapabilityConstants.get();
    for (String s : Splitter.on(", ").split(CapabilityConstants.get().capabilityNames)) {
        String v = (String) bundleClass.getField(s).get(c);
        CapabilityInfo info = new CapabilityInfo(s, v);
        output.put(s, info);
    }
    return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
}
#method_after
@Override
public Map<String, CapabilityInfo> apply(ConfigResource resource) throws AuthException, BadRequestException, ResourceConflictException, IllegalArgumentException, SecurityException, IllegalAccessException, NoSuchFieldException {
    Map<String, CapabilityInfo> output = Maps.newTreeMap();
    Class<? extends CapabilityConstants> bundleClass = CapabilityConstants.get().getClass();
    CapabilityConstants c = CapabilityConstants.get();
    for (String id : GlobalCapability.getAllNames()) {
        String name = (String) bundleClass.getField(id).get(c);
        output.put(id, new CapabilityInfo(id, name));
    }
    return output;
}
#end_block

#method_before
@Override
public String render(String varName) {
    if (Permission.isLabel(varName)) {
        return Util.M.label(new Permission(varName).getLabel());
    }
    String desc = all.get(varName);
    if (desc == null) {
        desc = all.get(varName.toLowerCase());
    }
    return desc != null ? desc : varName;
}
#method_after
@Override
public String render(String varName) {
    if (Permission.isLabel(varName)) {
        return Util.M.label(new Permission(varName).getLabel());
    }
    String desc = permissions.get(varName);
    if (desc != null) {
        return desc;
    }
    desc = fromServer.get(varName);
    if (desc != null) {
        return desc;
    }
    desc = permissions.get(varName.toLowerCase());
    if (desc != null) {
        return desc;
    }
    desc = fromServer.get(varName.toLowerCase());
    if (desc != null) {
        return desc;
    }
    return varName;
}
#end_block

#method_before
@Override
public RestView<TopLevelResource> list() {
    return null;
}
#method_after
@Override
public RestView<TopLevelResource> list() throws ResourceNotFoundException {
    throw new ResourceNotFoundException();
}
#end_block

#method_before
@Override
public ConfigResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException {
    if (!"server".equals(id.get())) {
        throw new ResourceNotFoundException(id);
    }
    return new ConfigResource();
}
#method_after
@Override
public ConfigResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException {
    if (id.equals("server")) {
        return new ConfigResource();
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    final String ref = receiveEvent.command.getRefName();
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(ref).matches() || ReceiveCommits.NEW_PATCHSET.matcher(ref).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || ReceiveCommits.NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
public List<CommitValidationMessage> validateForGerritCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForGerritCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || ReceiveCommits.NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, labelTypes, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, labelTypes, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Map<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#end_block

#method_before
void addDiff(int endA, int endB, List<Edit> internalEdit) {
    int lenA = endA - nextA;
    int lenB = endB - nextB;
    checkState(lenA > 0 || lenB > 0);
    ContentEntry e = entry();
    if (lenA > 0) {
        e.a = Lists.newArrayListWithCapacity(lenA);
        for (; nextA < endA; nextA++) {
            e.a.add(fileA.get(nextA));
        }
    }
    if (lenB > 0) {
        e.b = Lists.newArrayListWithCapacity(lenB);
        for (; nextB < endB; nextB++) {
            e.b.add(fileB.get(nextB));
        }
    }
    if (internalEdit != null && !internalEdit.isEmpty()) {
        e.editA = Lists.newArrayListWithCapacity(internalEdit.size() * 2);
        e.editB = Lists.newArrayListWithCapacity(internalEdit.size() * 2);
        int lastA = 0;
        int lastB = 0;
        for (Edit edit : internalEdit) {
            if (edit.getBeginA() != edit.getEndA()) {
                e.editA.add(ImmutableList.of(edit.getBeginA() - lastA, edit.getEndA() - edit.getBeginA()));
                lastA = edit.getBeginA() + edit.getEndA();
            }
            if (edit.getBeginB() != edit.getEndB()) {
                e.editB.add(ImmutableList.of(edit.getBeginB() - lastB, edit.getEndB() - edit.getBeginB()));
                lastB = edit.getBeginB() + edit.getEndB();
            }
        }
    }
}
#method_after
void addDiff(int endA, int endB, List<Edit> internalEdit) {
    int lenA = endA - nextA;
    int lenB = endB - nextB;
    checkState(lenA > 0 || lenB > 0);
    ContentEntry e = entry();
    if (lenA > 0) {
        e.a = Lists.newArrayListWithCapacity(lenA);
        for (; nextA < endA; nextA++) {
            e.a.add(fileA.get(nextA));
        }
    }
    if (lenB > 0) {
        e.b = Lists.newArrayListWithCapacity(lenB);
        for (; nextB < endB; nextB++) {
            e.b.add(fileB.get(nextB));
        }
    }
    if (internalEdit != null && !internalEdit.isEmpty()) {
        e.editA = Lists.newArrayListWithCapacity(internalEdit.size() * 2);
        e.editB = Lists.newArrayListWithCapacity(internalEdit.size() * 2);
        int lastA = 0;
        int lastB = 0;
        for (Edit edit : internalEdit) {
            if (edit.getBeginA() != edit.getEndA()) {
                e.editA.add(ImmutableList.of(edit.getBeginA() - lastA, edit.getEndA() - edit.getBeginA()));
                lastA = edit.getEndA();
            }
            if (edit.getBeginB() != edit.getEndB()) {
                e.editB.add(ImmutableList.of(edit.getBeginB() - lastB, edit.getEndB() - edit.getBeginB()));
                lastB = edit.getEndB();
            }
        }
    }
}
#end_block

#method_before
public static void deleteSshKeys(String account, Set<Integer> sequenceNumbers, AsyncCallback<VoidResult> cb) {
    CountingCallback ccb = new CountingCallback(sequenceNumbers.size(), cb);
    for (int seq : sequenceNumbers) {
        new RestApi("/accounts/").id(account).view("sshkeys").id(seq).delete(ccb);
    }
}
#method_after
public static void deleteSshKeys(String account, Set<Integer> sequenceNumbers, AsyncCallback<VoidResult> cb) {
    CallbackGroup group = new CallbackGroup();
    for (int seq : sequenceNumbers) {
        new RestApi("/accounts/").id(account).view("sshkeys").id(seq).delete(group.add(cb));
        cb = CallbackGroup.emptyCallback();
    }
}
#end_block

#method_before
void deleteChecked() {
    final HashSet<Integer> sequenceNumbers = new HashSet<Integer>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final SshKeyInfo k = getRowItem(row);
        if (k != null && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            sequenceNumbers.add(k.seq());
        }
    }
    if (sequenceNumbers.isEmpty()) {
        updateDeleteButton();
    } else {
        AccountApi.deleteSshKeys("self", sequenceNumbers, new GerritCallback<VoidResult>() {

            public void onSuccess(VoidResult result) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final SshKeyInfo k = getRowItem(row);
                    if (k != null && sequenceNumbers.contains(k.seq())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
                if (table.getRowCount() == 1) {
                    display(Collections.<SshKeyInfo>emptyList());
                } else {
                    updateDeleteButton();
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                refreshSshKeys();
                super.onFailure(caught);
            }
        });
    }
}
#method_after
void deleteChecked() {
    final HashSet<Integer> sequenceNumbers = new HashSet<Integer>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final SshKeyInfo k = getRowItem(row);
        if (k != null && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            sequenceNumbers.add(k.seq());
        }
    }
    if (sequenceNumbers.isEmpty()) {
        updateDeleteButton();
    } else {
        AccountApi.deleteSshKeys("self", sequenceNumbers, new GerritCallback<VoidResult>() {

            public void onSuccess(VoidResult result) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final SshKeyInfo k = getRowItem(row);
                    if (k != null && sequenceNumbers.contains(k.seq())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
                if (table.getRowCount() == 1) {
                    display(Collections.<SshKeyInfo>emptyList());
                } else {
                    updateDeleteButton();
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                refreshSshKeys();
                updateDeleteButton();
                super.onFailure(caught);
            }
        });
    }
}
#end_block

#method_before
private void displayHeader(Collection<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    List<String> sorted_labels = new ArrayList<String>();
    sorted_labels.addAll(labels);
    Collections.sort(sorted_labels);
    for (String name : sorted_labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayHeader(Collection<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (String name : labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
void display(ChangeInfo change) {
    lastChange = change;
    reviewerSuggestOracle.setChange(change.legacy_id());
    Map<Integer, ApprovalDetail> byUser = new LinkedHashMap<Integer, ApprovalDetail>();
    Map<Integer, AccountInfo> accounts = new LinkedHashMap<Integer, AccountInfo>();
    List<String> missingLabels = initLabels(change, accounts, byUser);
    removeAllChildren(missing.getElement());
    for (String label : missingLabels) {
        addMissingLabel(Util.M.needApproval(label));
    }
    if (byUser.isEmpty()) {
        table.setVisible(false);
    } else {
        displayHeader(change.labels());
        table.resizeRows(1 + byUser.size());
        int i = 1;
        for (ApprovalDetail ad : ApprovalDetail.sort(byUser.values(), change.owner()._account_id())) {
            displayRow(i++, ad, change, accounts.get(ad.getAccount().get()));
        }
        table.setVisible(true);
    }
    if (Gerrit.getConfig().testChangeMerge() && change.status() != Change.Status.MERGED && !change.mergeable()) {
        addMissingLabel(Util.C.messageNeedsRebaseOrHasDependency());
    }
    missing.setVisible(DOM.getChildCount(missing.getElement()) > 0);
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#method_after
void display(ChangeInfo change) {
    lastChange = change;
    reviewerSuggestOracle.setChange(change.legacy_id());
    Map<Integer, ApprovalDetail> byUser = new LinkedHashMap<Integer, ApprovalDetail>();
    Map<Integer, AccountInfo> accounts = new LinkedHashMap<Integer, AccountInfo>();
    List<String> missingLabels = initLabels(change, accounts, byUser);
    removeAllChildren(missing.getElement());
    for (String label : missingLabels) {
        addMissingLabel(Util.M.needApproval(label));
    }
    if (byUser.isEmpty()) {
        table.setVisible(false);
    } else {
        List<String> labels = new ArrayList<String>(change.labels());
        Collections.sort(labels);
        displayHeader(labels);
        table.resizeRows(1 + byUser.size());
        int i = 1;
        for (ApprovalDetail ad : ApprovalDetail.sort(byUser.values(), change.owner()._account_id())) {
            displayRow(i++, ad, labels, accounts.get(ad.getAccount().get()));
        }
        table.setVisible(true);
    }
    if (Gerrit.getConfig().testChangeMerge() && change.status() != Change.Status.MERGED && !change.mergeable()) {
        addMissingLabel(Util.C.messageNeedsRebaseOrHasDependency());
    }
    missing.setVisible(DOM.getChildCount(missing.getElement()) > 0);
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
private void displayRow(int row, final ApprovalDetail ad, ChangeInfo change, AccountInfo account) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, new AccountLink(account));
    rows.put(account._account_id(), row);
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(Util.M.removeReviewer(account.name()));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addStyleName(Gerrit.RESOURCES.css().link());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : change.labels()) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        }
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            int v = ad.getValue(labelName);
            if (v == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ad.getValue(labelName));
            if (v > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayRow(int row, final ApprovalDetail ad, List<String> labels, AccountInfo account) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, new AccountLinkPanel(account));
    rows.put(account._account_id(), row);
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(Util.M.removeReviewer(account.name()));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addStyleName(Gerrit.RESOURCES.css().link());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : labels) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        }
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            int v = ad.getValue(labelName);
            if (v == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ad.getValue(labelName));
            if (v > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        // TODO: Handle empty contents
        return null;
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setWidth("100%");
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setWidth("100%");
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            padLines(cmA, delta, lineA - 1);
            lineB = colorLine(delta, lineA, lineB, true);
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            padLines(cmB, delta, lineB - 1);
            lineA = colorLine(delta, lineA, lineB, false);
        } else {
            lineA = colorLine(current.a().length(), lineA, lineB, false);
            lineB = colorLine(current.b().length(), lineA, lineB, true);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            insertEmptyLines(cmA, lineA, delta);
            lineB = colorLines(cmB, lineB, delta);
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            insertEmptyLines(cmB, lineB, delta);
            lineA = colorLines(cmA, lineA, delta);
        } else {
            // TODO: Implement intraline
            int aLength = current.a().length();
            int bLength = current.b().length();
            lineA = colorLines(cmA, lineA, aLength);
            lineB = colorLines(cmB, lineB, bLength);
            if (aLength < bLength) {
                insertEmptyLines(cmA, lineA, bLength - aLength);
            } else if (aLength > bLength) {
                insertEmptyLines(cmB, lineB, aLength - bLength);
            }
        }
    }
}
#end_block

#method_before
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in) {
    return super.rewrite(new IndexRewrite(index).rewrite(in));
}
#method_after
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in) {
    return super.rewrite(indexRewrite.rewrite(in));
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                addRepeatableField(result, f, cd);
            } else {
                addSingleField(result, f, cd);
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    index = new DummyIndex();
    rewrite = new IndexRewrite(index);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    index = new DummyIndex();
    queryBuilder = new ChangeQueryBuilder(new ChangeQueryBuilder.Arguments(null, null, null, null, null, null, null, null, null, null, null, null), null);
    rewrite = new IndexRewriteImpl(index);
}
#end_block

#method_before
public void testIndexPredicate() throws Exception {
    Predicate<ChangeData> in = new FieldPredicate("in");
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#method_after
public void testIndexPredicate() throws Exception {
    Predicate<ChangeData> in = parse("file:a");
    assertEquals(wrap(in), rewrite(in));
}
#end_block

#method_before
public void testIndexPredicates() throws Exception {
    Predicate<ChangeData> f1 = new FieldPredicate("f1");
    Predicate<ChangeData> f2 = new FieldPredicate("f2");
    Predicate<ChangeData> in = Predicate.and(f1, f2);
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#method_after
public void testIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("file:a file:b");
    assertEquals(wrap(in), rewrite(in));
}
#end_block

#method_before
public void testNonIndexPredicates() throws Exception {
    Predicate<ChangeData> o1 = new OpPredicate("o1", "o1");
    Predicate<ChangeData> o2 = new OpPredicate("o2", "o2");
    Predicate<ChangeData> in = Predicate.and(o1, o2);
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(o1, o2), out.getChildren());
}
#method_after
public void testNonIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("branch:a OR branch:b");
    assertSame(in, rewrite(in));
}
#end_block

#method_before
public void testOneIndexPredicate() throws Exception {
    Predicate<ChangeData> o1 = new OpPredicate("o1", "o1");
    Predicate<ChangeData> f2 = new FieldPredicate("f2");
    Predicate<ChangeData> in = Predicate.and(o1, f2);
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(o1, wrap(f2)), out.getChildren());
}
#method_after
public void testOneIndexPredicate() throws Exception {
    Predicate<ChangeData> in = parse("branch:a file:b");
    Predicate<ChangeData> out = rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(in.getChild(0), wrap(in.getChild(1))), out.getChildren());
}
#end_block

#method_before
public void testThreeLevelTreeWithAllIndexPredicates() throws Exception {
    Predicate<ChangeData> f1 = new FieldPredicate("f1");
    Predicate<ChangeData> f21 = new FieldPredicate("f21");
    Predicate<ChangeData> f22 = new FieldPredicate("f22");
    Predicate<ChangeData> n1 = Predicate.not(f1);
    Predicate<ChangeData> o2 = Predicate.or(f21, f22);
    Predicate<ChangeData> in = Predicate.and(n1, o2);
    assertEquals(2, in.getChildCount());
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#method_after
public void testThreeLevelTreeWithAllIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("-status:abandoned (status:open OR status:merged)");
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#end_block

#method_before
public void testThreeLevelTreeWithSomeIndexPredicates() throws Exception {
    Predicate<ChangeData> op1 = new OpPredicate("o1", "o1");
    Predicate<ChangeData> f21 = new FieldPredicate("f21");
    Predicate<ChangeData> f22 = new FieldPredicate("f22");
    Predicate<ChangeData> n1 = Predicate.not(op1);
    Predicate<ChangeData> o2 = Predicate.or(f21, f22);
    Predicate<ChangeData> in = Predicate.and(n1, o2);
    assertEquals(2, in.getChildCount());
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(n1, wrap(o2)), out.getChildren());
}
#method_after
public void testThreeLevelTreeWithSomeIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("-branch:a (file:b OR file:c)");
    Predicate<ChangeData> out = rewrite(in);
    assertEquals(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(in.getChild(0), wrap(in.getChild(1))), out.getChildren());
}
#end_block

#method_before
public void testMultipleIndexPredicates() throws Exception {
    Predicate<ChangeData> f1 = new FieldPredicate("f1");
    Predicate<ChangeData> o2 = new OpPredicate("o2", "o2");
    Predicate<ChangeData> f3 = new FieldPredicate("f3");
    Predicate<ChangeData> o4 = new OpPredicate("o4", "o4");
    Predicate<ChangeData> in = Predicate.and(f1, o2, f3, o4);
    assertEquals(4, in.getChildCount());
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(o2, o4, wrap(Predicate.and(f1, f3))), out.getChildren());
}
#method_after
public void testMultipleIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("file:a OR branch:b OR file:c OR branch:d");
    Predicate<ChangeData> out = rewrite(in);
    assertSame(OrPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(in.getChild(1), in.getChild(3), wrap(Predicate.or(in.getChild(0), in.getChild(2)))), out.getChildren());
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^")) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^") && args.index != ChangeIndex.DISABLED) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    Provider<ReviewDb> dbProvider = Providers.of(db);
    PatchListCache plc = sysInjector.getInstance(PatchListCache.class);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    index.getWriter().deleteAll();
    int i = 0;
    for (Change change : db.changes().all()) {
        ChangeData cd = new ChangeData(change);
        cd.fillIndexFields(dbProvider, plc);
        index.insert(cd);
        i++;
    }
    index.getWriter().commit();
    System.out.println("Reindexed " + i + " changes");
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!LuceneIndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    sitePaths = dbInjector.getInstance(SitePaths.class);
    deleteAll();
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    dbRef.set(db);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    Stopwatch sw = new Stopwatch().start();
    int i = 0;
    for (Change change : db.changes().all()) {
        index.insert(new ChangeData(change));
        i++;
    }
    index.getWriter().commit();
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Reindexed %d changes in %.02fms", i, elapsed);
    manager.stop();
    return 0;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new LifecycleModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(new LuceneIndexModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            bind(ReviewDb.class).toProvider(new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    return dbRef.get();
                }
            });
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    switch(p.getType()) {
        case INTEGER:
            return intQuery(p);
        case EXACT_REPEATABLE:
            return exactQuery(p);
        default:
            throw badFieldType(p.getType());
    }
}
#method_after
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    cd.checkIndexFields();
    org.apache.lucene.document.Document result = new Document();
    for (ChangeField f : ChangeField.values()) {
        switch(f.getType()) {
            case INTEGER:
                result.add(new IntField(f.getName(), (Integer) f.get(cd), store(f)));
                break;
            case EXACT_REPEATABLE:
                // Type checked in ChangeField.
                @SuppressWarnings("unchecked")
                Iterable<String> values = (Iterable<String>) f.get(cd);
                for (String value : values) {
                    result.add(new StringField(f.getName(), value, store(f)));
                }
                break;
        }
    }
    return result;
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private Field.Store store(ChangeField f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#method_after
private static Field.Store store(FieldDef<?, ?> f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#end_block

#method_before
private static IllegalArgumentException badFieldType(FieldType t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#method_after
private static IllegalArgumentException badFieldType(FieldType<?> t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
public FieldType getType() {
    return type;
}
#method_after
public FieldType<?> getType() {
    return def.getType();
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        workQueue.getDefaultQueue().submit(indexerFactory.create(change));
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        indexer.index(change);
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(changeIndexerFactory.create(change)));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ins.setReviewers(recipients.getReviewers()).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void addPadding(int line, CodeMirror cm) {
    Element div = DOM.createDiv();
    div.setAttribute("style", "background-color: #E6E6E6");
    div.appendChild(DOM.createElement("br"));
    cm.addLineWidget(line, div, null);
}
#method_after
private void addPadding(CodeMirror cm, int line) {
    Element div = DOM.createDiv();
    div.setClassName(diffTable.style.padding());
    cm.addLineWidget(line, div, null);
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    Configuration insertOpt = Configuration.create().set("className", "insert").set("readOnly", "true");
    Configuration deleteOpt = Configuration.create().set("className", "delete").set("readOnly", "true");
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            for (int j = 0; j < delta; j++) {
                addPadding(lineA - 1, cmA);
            }
            for (int j = 0; j < delta; j++) {
                cmB.addLineClass(lineB, "wrap", "insert");
                LineCharacter from = LineCharacter.create(lineB, 0).setLine(lineB).setCh(0);
                cmB.markText(from, from, insertOpt);
                lineB++;
            }
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            for (int j = 0; j < delta; j++) {
                addPadding(lineB - 1, cmB);
            }
            for (int j = 0; j < delta; j++) {
                cmA.addLineClass(lineA, "wrap", "delete");
                LineCharacter from = LineCharacter.create(lineA, 0).setLine(lineA).setCh(0);
                cmA.markText(from, from, deleteOpt);
                lineA++;
            }
        } else {
            // TODO: Handle intraline edit.
            lineA += current.a().length();
            lineB += current.a().length();
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    Configuration insertOpt = Configuration.create().set("className", diffTable.style.insert()).set("readOnly", true);
    Configuration deleteOpt = Configuration.create().set("className", diffTable.style.delete()).set("readOnly", true);
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            for (int j = 0; j < delta; j++) {
                addPadding(cmA, lineA - 1);
            }
            for (int j = 0; j < delta; j++) {
                cmB.addLineClass(lineB, LineClassWhere.WRAP, diffTable.style.insert());
                LineCharacter from = LineCharacter.create(lineB, 0);
                cmB.markText(from, from, insertOpt);
                lineB++;
            }
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            for (int j = 0; j < delta; j++) {
                addPadding(cmB, lineB - 1);
            }
            for (int j = 0; j < delta; j++) {
                cmA.addLineClass(lineA, LineClassWhere.WRAP, diffTable.style.delete());
                LineCharacter from = LineCharacter.create(lineA, 0);
                cmA.markText(from, from, deleteOpt);
                lineA++;
            }
        } else {
            // TODO: Handle intraline edit.
            lineA += current.a().length();
            lineB += current.a().length();
        }
    }
}
#end_block

#method_before
public void display(final ChangeDetail detail, final PatchSet.Id diffBaseId) {
    clear();
    final PatchSet currps = detail.getCurrentPatchSet();
    currentPatchSetId = currps.getId();
    patchSets = detail.getPatchSets();
    if (Gerrit.isSignedIn()) {
        final AccountGeneralPreferences p = Gerrit.getUserAccount().getGeneralPreferences();
        if (p.isReversePatchSetOrder()) {
            Collections.reverse(patchSets);
        }
    }
    patchSetPanelsList = new ArrayList<PatchSetComplexDisclosurePanel>();
    for (final PatchSet ps : patchSets) {
        final PatchSetComplexDisclosurePanel p = new PatchSetComplexDisclosurePanel(ps, ps == currps, detail.getPatchSetsWithDraftComments().contains(ps.getId()));
        if (diffBaseId != null) {
            p.setDiffBaseId(diffBaseId);
            if (ps == currps) {
                p.refresh();
            }
        }
        add(p);
        patchSetPanelsList.add(p);
    }
}
#method_after
public void display(final ChangeDetail detail, final PatchSet.Id diffBaseId) {
    clear();
    final PatchSet currps = detail.getCurrentPatchSet();
    currentPatchSetId = currps.getId();
    patchSets = detail.getPatchSets();
    if (Gerrit.isSignedIn()) {
        final AccountGeneralPreferences p = Gerrit.getUserAccount().getGeneralPreferences();
        if (p.isReversePatchSetOrder()) {
            Collections.reverse(patchSets);
        }
    }
    patchSetPanelsList = new ArrayList<PatchSetComplexDisclosurePanel>();
    for (final PatchSet ps : patchSets) {
        final PatchSetComplexDisclosurePanel p = new PatchSetComplexDisclosurePanel(ps, ps == currps, detail.hasDraftComments(ps.getId()));
        if (diffBaseId != null) {
            p.setDiffBaseId(diffBaseId);
            if (ps == currps) {
                p.refresh();
            }
        }
        add(p);
        patchSetPanelsList.add(p);
    }
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    Set<PatchSet.Id> patchesWithDraftComments = new HashSet<PatchSet.Id>();
    final CurrentUser user = control.getCurrentUser();
    final Account.Id me = user instanceof IdentifiedUser ? ((IdentifiedUser) user).getAccountId() : null;
    for (PatchSet ps : source) {
        final PatchSet.Id id = ps.getId();
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
            if (me != null && db.patchComments().draftByPatchSetAuthor(id, me).iterator().hasNext()) {
                patchesWithDraftComments.add(id);
            }
        }
        patchsetsById.put(id, ps);
    }
    detail.setPatchSets(patches);
    detail.setPatchSetsWithDraftComments(patchesWithDraftComments);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    Set<PatchSet.Id> patchesWithDraftComments = new HashSet<PatchSet.Id>();
    final CurrentUser user = control.getCurrentUser();
    final Account.Id me = user instanceof IdentifiedUser ? ((IdentifiedUser) user).getAccountId() : null;
    for (PatchSet ps : source) {
        final PatchSet.Id psId = ps.getId();
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
            if (me != null && db.patchComments().draftByPatchSetAuthor(psId, me).iterator().hasNext()) {
                patchesWithDraftComments.add(psId);
            }
        }
        patchsetsById.put(psId, ps);
    }
    detail.setPatchSets(patches);
    detail.setPatchSetsWithDraftComments(patchesWithDraftComments);
}
#end_block

#method_before
public void loadActionPanel(final PatchSetDetail detail) {
    if (!patchSet.getId().equals(diffBaseId)) {
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        actionsPanel.setVisible(true);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        body.add(actionsPanel);
    }
}
#method_after
public void loadActionPanel(final PatchSetDetail detail) {
    if (!patchSet.getId().equals(diffBaseId)) {
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        actionsPanel.setVisible(true);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
                populateCommands(detail);
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        body.add(actionsPanel);
    }
}
#end_block

#method_before
public void setPatchSetsWithDraftComments(Set<PatchSet.Id> patchSetsWithDraftComments) {
    this.patchSetsWithDraftComments = patchSetsWithDraftComments;
}
#method_after
public void setPatchSetsWithDraftComments(Set<PatchSet.Id> pwdc) {
    this.patchSetsWithDraftComments = pwdc;
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc, Input input) throws BadRequestException, ResourceConflictException, ResourceNotFoundException, AuthException, OrmException, EmailException {
    if (input == null) {
        input = new Input();
    }
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    if (input.noConfirmation && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to add email address without confirmation, " + "need to be Gerrit administrator");
    }
    if (input.noConfirmation || authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(rsrc.getUser().getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    EmailInfo e = new EmailInfo();
    e.email = email;
    if (input.preferred) {
        putPreferredProvider.get().apply(new AccountResource.Email(rsrc.getUser(), email), null);
        e.setPreferred(true);
    }
    return Response.created(e);
}
#method_after
@Override
public Object apply(AccountResource rsrc, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException {
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() != rsrc.getUser().getAccountId().get() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to add email address");
    }
    if (input == null) {
        input = new Input();
    }
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    if (input.noConfirmation && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to add email address without confirmation, " + "need to be Gerrit administrator");
    }
    if (input.noConfirmation || authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(rsrc.getUser().getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    EmailInfo e = new EmailInfo();
    e.email = email;
    if (input.preferred) {
        putPreferredProvider.get().apply(new AccountResource.Email(rsrc.getUser(), email), null);
        e.setPreferred(true);
    }
    return Response.created(e);
}
#end_block

#method_before
private static void asyncInjectCss(ExternalTextResource css) {
    try {
        css.getText(new ResourceCallback<TextResource>() {

            @Override
            public void onSuccess(TextResource resource) {
                StyleInjector.inject(resource.getText());
            }

            @Override
            public void onError(ResourceException e) {
            }
        });
    } catch (ResourceException e) {
    }
}
#method_after
private static void asyncInjectCss(ExternalTextResource css) {
    try {
        css.getText(new ResourceCallback<TextResource>() {

            @Override
            public void onSuccess(TextResource resource) {
                StyleInjector.inject(resource.getText());
            }

            @Override
            public void onError(ResourceException e) {
                error(e);
            }
        });
    } catch (ResourceException e) {
        error(e);
    }
}
#end_block

#method_before
@Override
public List<EmailInfo> apply(AccountResource rsrc) throws OrmException {
    List<EmailInfo> emails = Lists.newArrayList();
    ResultSet<AccountExternalId> ids = dbProvider.get().accountExternalIds().byAccount(rsrc.getUser().getAccountId());
    for (AccountExternalId extId : ids) {
        if (extId.isScheme(AccountExternalId.SCHEME_MAILTO)) {
            EmailInfo e = new EmailInfo();
            e.email = extId.getEmailAddress();
            e.setPreferred(extId.getEmailAddress().equals(rsrc.getUser().getAccount().getPreferredEmail()));
            emails.add(e);
        }
    }
    return emails;
}
#method_after
@Override
public List<EmailInfo> apply(AccountResource rsrc) throws AuthException, OrmException {
    if (!(self.get() instanceof IdentifiedUser)) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() != rsrc.getUser().getAccountId().get() && !s.getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to list email addresses");
    }
    List<EmailInfo> emails = Lists.newArrayList();
    ResultSet<AccountExternalId> ids = dbProvider.get().accountExternalIds().byAccount(rsrc.getUser().getAccountId());
    for (AccountExternalId extId : ids) {
        String email = extId.getEmailAddress();
        if (email != null) {
            EmailInfo e = new EmailInfo();
            e.email = email;
            e.setPreferred(email.equals(rsrc.getUser().getAccount().getPreferredEmail()));
            emails.add(e);
        }
    }
    return emails;
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc) {
    return Strings.nullToEmpty(rsrc.getUser().getAccount().getFullName());
}
#method_after
@Override
public String apply(AccountResource rsrc) {
    return Strings.nullToEmpty(rsrc.getUser().getAccount().getFullName());
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc, Input input) throws OrmException, MethodNotAllowedException {
    if (!realm.allowsEdit(FieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("The realm doesn't allow editing names");
    }
    if (input == null) {
        input = new Input();
    }
    Account a = rsrc.getUser().getAccount();
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.none() : a.getFullName();
}
#method_after
@Override
public Object apply(AccountResource rsrc, Input input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException {
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() != rsrc.getUser().getAccountId().get() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to change name");
    }
    if (!realm.allowsEdit(FieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("The realm doesn't allow editing names");
    }
    if (input == null) {
        input = new Input();
    }
    Account a = dbProvider.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("No such account: " + rsrc.getUser().getAccountId());
    }
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.none() : a.getFullName();
}
#end_block

#method_before
private void sendForm(HttpServletRequest req, HttpServletResponse res, @Nullable String errorMessage) throws IOException {
    String self = req.getRequestURI();
    String cancel = Objects.firstNonNull(urlProvider.get(), "/");
    String token = getToken(req);
    if (!token.equals("/")) {
        cancel += "#" + token;
    }
    Document doc = HtmlDomUtil.parseFile(LdapLoginServlet.class, "LoginForm.html");
    injectCssFile(doc, "gerrit_sitecss", sitePaths.site_css);
    injectXmlFile(doc, "gerrit_header", sitePaths.site_header);
    injectXmlFile(doc, "gerrit_footer", sitePaths.site_footer);
    HtmlDomUtil.find(doc, "hostName").setTextContent(req.getServerName());
    HtmlDomUtil.find(doc, "login_form").setAttribute("action", self);
    HtmlDomUtil.find(doc, "cancel_link").setAttribute("href", cancel);
    Element emsg = HtmlDomUtil.find(doc, "error_message");
    if (Strings.isNullOrEmpty(errorMessage)) {
        emsg.getParentNode().removeChild(emsg);
    } else {
        emsg.setTextContent(errorMessage);
    }
    byte[] bin = HtmlDomUtil.toUTF8(doc);
    res.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(bin.length);
    ServletOutputStream out = res.getOutputStream();
    try {
        out.write(bin);
    } finally {
        out.close();
    }
}
#method_after
private void sendForm(HttpServletRequest req, HttpServletResponse res, @Nullable String errorMessage) throws IOException {
    String self = req.getRequestURI();
    String cancel = Objects.firstNonNull(urlProvider.get(req), "/");
    String token = getToken(req);
    if (!token.equals("/")) {
        cancel += "#" + token;
    }
    Document doc = headers.parse(LdapLoginServlet.class, "LoginForm.html");
    HtmlDomUtil.find(doc, "hostName").setTextContent(req.getServerName());
    HtmlDomUtil.find(doc, "login_form").setAttribute("action", self);
    HtmlDomUtil.find(doc, "cancel_link").setAttribute("href", cancel);
    Element emsg = HtmlDomUtil.find(doc, "error_message");
    if (Strings.isNullOrEmpty(errorMessage)) {
        emsg.getParentNode().removeChild(emsg);
    } else {
        emsg.setTextContent(errorMessage);
    }
    byte[] bin = HtmlDomUtil.toUTF8(doc);
    res.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(bin.length);
    ServletOutputStream out = res.getOutputStream();
    try {
        out.write(bin);
    } finally {
        out.close();
    }
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String username = Strings.nullToEmpty(req.getParameter("username")).trim();
    String password = Strings.nullToEmpty(req.getParameter("password"));
    String remember = Strings.nullToEmpty(req.getParameter("rememberme"));
    if (username.isEmpty() || password.isEmpty()) {
        sendForm(req, res, "Invalid username or password.");
        return;
    }
    AuthRequest areq = AuthRequest.forUser(username);
    areq.setPassword(password);
    AuthResult ares;
    try {
        ares = accountManager.authenticate(areq);
    } catch (AccountUserNameException e) {
        sendForm(req, res, e.getMessage());
        return;
    } catch (AuthenticationUnavailableException e) {
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    } catch (AccountException e) {
        log.info(String.format("'%s' failed to sign in: %s", username, e.getMessage()));
        sendForm(req, res, "Invalid username or password.");
        return;
    } catch (RuntimeException e) {
        log.error("LDAP authentication failed", e);
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    }
    String token = getToken(req);
    StringBuilder dest = new StringBuilder();
    String url = urlProvider == null ? null : urlProvider.get();
    if (url == null) {
        url = guessCanonicalUrl(req);
    }
    dest.append(url);
    dest.append('#');
    dest.append(token);
    CacheHeaders.setNotCacheable(res);
    webSession.get().login(ares, "1".equals(remember));
    res.sendRedirect(dest.toString());
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String username = Strings.nullToEmpty(req.getParameter("username")).trim();
    String password = Strings.nullToEmpty(req.getParameter("password"));
    String remember = Strings.nullToEmpty(req.getParameter("rememberme"));
    if (username.isEmpty() || password.isEmpty()) {
        sendForm(req, res, "Invalid username or password.");
        return;
    }
    AuthRequest areq = AuthRequest.forUser(username);
    areq.setPassword(password);
    AuthResult ares;
    try {
        ares = accountManager.authenticate(areq);
    } catch (AccountUserNameException e) {
        sendForm(req, res, e.getMessage());
        return;
    } catch (AuthenticationUnavailableException e) {
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    } catch (AccountException e) {
        log.info(String.format("'%s' failed to sign in: %s", username, e.getMessage()));
        sendForm(req, res, "Invalid username or password.");
        return;
    } catch (RuntimeException e) {
        log.error("LDAP authentication failed", e);
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    }
    StringBuilder dest = new StringBuilder();
    dest.append(urlProvider.get(req));
    dest.append('#');
    dest.append(getToken(req));
    CacheHeaders.setNotCacheable(res);
    webSession.get().login(ares, "1".equals(remember));
    res.sendRedirect(dest.toString());
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = getToken(req);
    if ("/logout".equals(token) || "/signout".equals(token)) {
        req.getRequestDispatcher("/logout").forward(req, rsp);
        return;
    }
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    final StringBuilder rdr = new StringBuilder();
    String url = urlProvider == null ? null : urlProvider.get();
    if (url == null) {
        url = guessCanonicalUrl(req);
    }
    rdr.append(url);
    rdr.append('#');
    if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
        rdr.append(PageLinks.REGISTER);
    }
    rdr.append(token);
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = getToken(req);
    if ("/logout".equals(token) || "/signout".equals(token)) {
        req.getRequestDispatcher("/logout").forward(req, rsp);
        return;
    }
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    final StringBuilder rdr = new StringBuilder();
    rdr.append(urlProvider.get(req));
    rdr.append('#');
    if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
        rdr.append(PageLinks.REGISTER);
    }
    rdr.append(token);
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            Util.PROJECT_SVC.listBranches(getProjectKey(), new GerritCallback<ListBranchesResult>() {

                @Override
                public void onSuccess(ListBranchesResult result) {
                    display(result.getBranches());
                }
            });
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#method_after
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText().trim();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText().trim();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            Util.PROJECT_SVC.listBranches(getProjectKey(), new GerritCallback<ListBranchesResult>() {

                @Override
                public void onSuccess(ListBranchesResult result) {
                    display(result.getBranches());
                }
            });
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseStartingRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return trimTrailingSlashes(canonicalWebUrl);
    } else {
        return "http://" + getGerritHost(canonicalWebUrl);
    }
}
#method_after
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    } else {
        return "http://" + getGerritHost(canonicalWebUrl);
    }
}
#end_block

#method_before
private static String getGerritHost(String canonicalWebUrl) {
    String host = null;
    if (canonicalWebUrl != null) {
        try {
            host = new URL(canonicalWebUrl).getHost();
        } catch (MalformedURLException e) {
        // Ignore
        }
    }
    if (host == null) {
        host = SystemReader.getInstance().getHostname();
    }
    return trimTrailingSlashes(host);
}
#method_after
private static String getGerritHost(String canonicalWebUrl) {
    String host;
    if (canonicalWebUrl != null) {
        try {
            host = new URL(canonicalWebUrl).getHost();
        } catch (MalformedURLException e) {
            host = SystemReader.getInstance().getHostname();
        }
    } else {
        host = SystemReader.getInstance().getHostname();
    }
    return host;
}
#end_block

#method_before
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (!msg.toString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (msg != null && !msg.asString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListGroupMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#end_block

#method_before
@Override
protected void render(final PatchScript script, final PatchSetDetail detail) {
    final ArrayList<Object> lines = new ArrayList<Object>();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    allocateTableHeader(script, nc);
    lines.add(null);
    if (!isDisplayBinary) {
        if (script.getFileModeA() != FileMode.FILE || script.getFileModeB() != FileMode.FILE) {
            openLine(nc);
            appendModeLine(nc, script.getFileModeA());
            appendModeLine(nc, script.getFileModeB());
            closeLine(nc);
            lines.add(null);
        }
        if (hasDifferences(script)) {
            int lastA = 0;
            int lastB = 0;
            final boolean ignoreWS = script.isIgnoreWhitespace();
            a = getSparseHtmlFileA(script);
            b = getSparseHtmlFileB(script);
            final boolean intraline = script.getDiffPrefs().isIntralineDifference() && script.hasIntralineDifference();
            for (final EditList.Hunk hunk : script.getHunks()) {
                if (!hunk.isStartOfFile()) {
                    appendSkipLine(nc, hunk.getCurB() - lastB);
                    lines.add(new SkippedLine(lastA, lastB, hunk.getCurB() - lastB));
                }
                while (hunk.next()) {
                    if (hunk.isContextLine()) {
                        openLine(nc);
                        final SafeHtml ctx = a.getSafeHtmlLine(hunk.getCurA());
                        appendLineNumber(nc, hunk.getCurA(), false);
                        appendLineText(nc, CONTEXT, ctx, false, false);
                        if (ignoreWS && b.contains(hunk.getCurB())) {
                            appendLineText(nc, CONTEXT, b, hunk.getCurB(), false);
                        } else {
                            appendLineText(nc, CONTEXT, ctx, false, false);
                        }
                        appendLineNumber(nc, hunk.getCurB(), true);
                        closeLine(nc);
                        hunk.incBoth();
                        lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
                    } else if (hunk.isModifiedLine()) {
                        final boolean del = hunk.isDeletedA();
                        final boolean ins = hunk.isInsertedB();
                        final boolean full = intraline && hunk.getCurEdit().getType() != Edit.Type.REPLACE;
                        openLine(nc);
                        if (del) {
                            appendLineNumber(nc, hunk.getCurA(), false);
                            appendLineText(nc, DELETE, a, hunk.getCurA(), full);
                            hunk.incA();
                        } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                            appendLineNumber(nc, false);
                            appendLineNone(nc, DELETE);
                        } else {
                            appendLineNumber(nc, false);
                            appendLineNone(nc, CONTEXT);
                        }
                        if (ins) {
                            appendLineText(nc, INSERT, b, hunk.getCurB(), full);
                            appendLineNumber(nc, hunk.getCurB(), true);
                            hunk.incB();
                        } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                            appendLineNone(nc, INSERT);
                            appendLineNumber(nc, true);
                        } else {
                            appendLineNone(nc, CONTEXT);
                            appendLineNumber(nc, true);
                        }
                        closeLine(nc);
                        if (del && ins) {
                            lines.add(new PatchLine(REPLACE, hunk.getCurA(), hunk.getCurB()));
                        } else if (del) {
                            lines.add(new PatchLine(DELETE, hunk.getCurA(), -1));
                        } else if (ins) {
                            lines.add(new PatchLine(INSERT, -1, hunk.getCurB()));
                        }
                    }
                }
                lastA = hunk.getCurA();
                lastB = hunk.getCurB();
            }
            if (lastB != b.size()) {
                appendSkipLine(nc, b.size() - lastB);
                lines.add(new SkippedLine(lastA, lastB, b.size() - lastB));
            }
        }
    } else {
        // Display the patch header for binary
        for (final String line : script.getPatchHeader()) {
            appendFileHeader(nc, line);
        }
        // If there is a picture involved, we show it
        if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImageLine(script, nc);
        }
    }
    if (!hasDifferences(script)) {
        appendNoDifferences(nc);
    }
    resetHtml(nc);
    populateTableHeader(script, detail);
    if (hasDifferences(script)) {
        initScript(script);
        if (!isDisplayBinary) {
            for (int row = 0; row < lines.size(); row++) {
                setRowItem(row, lines.get(row));
                if (lines.get(row) instanceof SkippedLine) {
                    createSkipLine(row, (SkippedLine) lines.get(row));
                }
            }
        }
    }
}
#method_after
@Override
protected void render(final PatchScript script, final PatchSetDetail detail) {
    final ArrayList<Object> lines = new ArrayList<Object>();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    allocateTableHeader(script, nc);
    lines.add(null);
    if (!isDisplayBinary) {
        if (script.getFileModeA() != FileMode.FILE || script.getFileModeB() != FileMode.FILE) {
            openLine(nc);
            appendModeLine(nc, script.getFileModeA());
            appendModeLine(nc, script.getFileModeB());
            closeLine(nc);
            lines.add(null);
        }
        if (hasDifferences(script)) {
            int lastA = 0;
            int lastB = 0;
            final boolean ignoreWS = script.isIgnoreWhitespace();
            a = getSparseHtmlFileA(script);
            b = getSparseHtmlFileB(script);
            final boolean intraline = script.getDiffPrefs().isIntralineDifference() && script.hasIntralineDifference();
            for (final EditList.Hunk hunk : script.getHunks()) {
                if (!hunk.isStartOfFile()) {
                    appendSkipLine(nc, hunk.getCurB() - lastB);
                    lines.add(new SkippedLine(lastA, lastB, hunk.getCurB() - lastB));
                }
                while (hunk.next()) {
                    if (hunk.isContextLine()) {
                        openLine(nc);
                        final SafeHtml ctx = a.getSafeHtmlLine(hunk.getCurA());
                        appendLineNumber(nc, hunk.getCurA(), false);
                        appendLineText(nc, CONTEXT, ctx, false, false);
                        if (ignoreWS && b.contains(hunk.getCurB())) {
                            appendLineText(nc, CONTEXT, b, hunk.getCurB(), false);
                        } else {
                            appendLineText(nc, CONTEXT, ctx, false, false);
                        }
                        appendLineNumber(nc, hunk.getCurB(), true);
                        closeLine(nc);
                        hunk.incBoth();
                        lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
                    } else if (hunk.isModifiedLine()) {
                        final boolean del = hunk.isDeletedA();
                        final boolean ins = hunk.isInsertedB();
                        final boolean full = intraline && hunk.getCurEdit().getType() != Edit.Type.REPLACE;
                        openLine(nc);
                        if (del) {
                            appendLineNumber(nc, hunk.getCurA(), false);
                            appendLineText(nc, DELETE, a, hunk.getCurA(), full);
                            hunk.incA();
                        } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                            appendLineNumber(nc, false);
                            appendLineNone(nc, DELETE);
                        } else {
                            appendLineNumber(nc, false);
                            appendLineNone(nc, CONTEXT);
                        }
                        if (ins) {
                            appendLineText(nc, INSERT, b, hunk.getCurB(), full);
                            appendLineNumber(nc, hunk.getCurB(), true);
                            hunk.incB();
                        } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                            appendLineNone(nc, INSERT);
                            appendLineNumber(nc, true);
                        } else {
                            appendLineNone(nc, CONTEXT);
                            appendLineNumber(nc, true);
                        }
                        closeLine(nc);
                        if (del && ins) {
                            lines.add(new PatchLine(REPLACE, hunk.getCurA(), hunk.getCurB()));
                        } else if (del) {
                            lines.add(new PatchLine(DELETE, hunk.getCurA(), -1));
                        } else if (ins) {
                            lines.add(new PatchLine(INSERT, -1, hunk.getCurB()));
                        }
                    }
                }
                lastA = hunk.getCurA();
                lastB = hunk.getCurB();
            }
            if (lastB != b.size()) {
                appendSkipLine(nc, b.size() - lastB);
                lines.add(new SkippedLine(lastA, lastB, b.size() - lastB));
            }
        }
    } else {
        // Display the patch header for binary
        for (final String line : script.getPatchHeader()) {
            appendFileHeader(nc, line);
        }
        // If there is a safe picture involved, we show it
        if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImageLine(script, nc);
        }
    }
    if (!hasDifferences(script)) {
        appendNoDifferences(nc);
    }
    resetHtml(nc);
    populateTableHeader(script, detail);
    if (hasDifferences(script)) {
        initScript(script);
        if (!isDisplayBinary) {
            for (int row = 0; row < lines.size(); row++) {
                setRowItem(row, lines.get(row));
                if (lines.get(row) instanceof SkippedLine) {
                    createSkipLine(row, (SkippedLine) lines.get(row));
                }
            }
        }
    }
}
#end_block

#method_before
private void appendImageLine(final PatchScript script, final SafeHtmlBuilder m) {
    final String rawBase = GWT.getHostPageBaseURL() + "cat/";
    m.openTr();
    m.setAttribute("valign", "center");
    m.setAttribute("align", "center");
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().iconCell());
    m.closeTd();
    appendLineNumber(m, false);
    if (script.getDisplayMethodA() == DisplayMethod.IMG) {
        final String url;
        if (idSideA == null) {
            url = rawBase + KeyUtil.encode(patchKey.toString()) + "^1";
        } else {
            Patch.Key k = new Patch.Key(idSideA, patchKey.get());
            url = rawBase + KeyUtil.encode(k.toString()) + "^0";
        }
        appendLineText(m, DELETE, createImage(url), false, true);
    } else {
        appendLineNone(m, DELETE);
    }
    if (script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String url = rawBase + KeyUtil.encode(patchKey.toString()) + "^0";
        appendLineText(m, INSERT, createImage(url), false, true);
    } else {
        appendLineNone(m, INSERT);
    }
    appendLineNumber(m, true);
    m.closeTr();
}
#method_after
private void appendImageLine(final PatchScript script, final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "center");
    m.setAttribute("align", "center");
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().iconCell());
    m.closeTd();
    appendLineNumber(m, false);
    if (script.getDisplayMethodA() == DisplayMethod.IMG) {
        final String url = getUrlA();
        appendLineText(m, DELETE, createImage(url), false, true);
    } else {
        appendLineNone(m, DELETE);
    }
    if (script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String url = getUrlB();
        appendLineText(m, INSERT, createImage(url), false, true);
    } else {
        appendLineNone(m, INSERT);
    }
    appendLineNumber(m, true);
    m.closeTr();
}
#end_block

#method_before
/**
 * Get specificity of mime types with generic types forced to low values
 *
 * "application/octet-stream" is forced to -1.
 * "text/plain" is forced to 0.
 * All other mime types return the specificity reported by mimeType itself.
 *
 * @param mimeType The mimeType to get the corrected specificity for.
 * @return The corrected specificity.
 */
private int getCorrectedMimeSpecificity(MimeType mimeType) {
    final int ret;
    final String mimeTypeStr = mimeType.toString();
    if (mimeTypeStr.equals("application/octet-stream")) {
        ret = -1;
    } else if (mimeTypeStr.equals("text/plain")) {
        ret = 0;
    } else {
        ret = mimeType.getSpecificity();
    }
    return ret;
}
#method_after
private int getCorrectedMimeSpecificity(MimeType mimeType) {
    // Although the documentation of MimeType's getSpecificity claims that for
    // example "application/octet-stream" always has a specificity of 0, it
    // effectively returns 1 for us. This causes problems when trying to get
    // the correct mime type via sorting. For example in
    // [application/octet-stream, image/x-icon] both mime types come with
    // specificity 1 for us. Hence, getMimeType below may end up using
    // application/octet-stream instead of the more specific image/x-icon.
    // Therefore, we have to force the specificity of generic types below the
    // default of 1.
    // 
    final String mimeTypeStr = mimeType.toString();
    if (mimeTypeStr.equals("application/octet-stream")) {
        return -1;
    }
    if (mimeTypeStr.equals("text/plain")) {
        return 0;
    }
    return mimeType.getSpecificity();
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, footerLines, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(change, ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, footerLines, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void submit(Change change, PatchSet ps) throws OrmException {
    if (!projectControl.controlForRef(MagicBranch.NEW_CHANGE + change.getDest().get()).canSubmit()) {
        addError("Submitting of change " + change.getChangeId() + " not allowed.");
    } else {
        Change c = SubmitChange.submit(db, change, ps, currentUser);
        if (c == null) {
            addError("Submitting change " + change.getChangeId() + " failed.");
        } else {
            addMessage("");
            mergeQueue.merge(c.getDest());
            c = db.changes().get(c.getId());
            switch(c.getStatus()) {
                case SUBMITTED:
                    addMessage("Change " + c.getChangeId() + " submitted.");
                    break;
                case MERGED:
                    addMessage("Change " + c.getChangeId() + " merged.");
                    break;
                case NEW:
                    // If the merge was attempted and it failed the system usually
                    // writes a comment as a ChangeMessage and sets status to NEW.
                    // Find the relevant message and report that as the conflict.
                    final Timestamp before = change.getLastUpdatedOn();
                    ChangeMessage msg = Iterables.getFirst(Iterables.filter(Lists.reverse(db.changeMessages().byChange(c.getId()).toList()), new Predicate<ChangeMessage>() {

                        @Override
                        public boolean apply(ChangeMessage input) {
                            return input.getAuthor() == null && input.getWrittenOn().getTime() >= before.getTime();
                        }
                    }), null);
                    if (msg != null) {
                        addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                        break;
                    }
                default:
                    addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
            }
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(new ChangeResource(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final MailRecipients oldRecipients = getRecipientsFromApprovals(ApprovalsUtil.copyLabels(db, labelTypes, priorPatchSet, newPatchSet.getId()));
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(change, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final MailRecipients oldRecipients = getRecipientsFromApprovals(ApprovalsUtil.copyLabels(db, labelTypes, priorPatchSet, newPatchSet.getId()));
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(LabelTypes.class).toProvider(LabelTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeInserter.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeInserter.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final RefControl refControl, CommitValidators commitValidators, final IdentifiedUser user, final String message, final ReviewDb db, final CommitMessageEditedSender.Factory commitMessageEditedSenderFactory, final ChangeHooks hooks, Repository git, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated gitRefUpdated, PersonIdent myIdent, final ApprovalsUtil approvalsUtil, final TrackingFooters trackingFooters) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet originalPS = db.patchSets().get(patchSetId);
    if (originalPS == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(originalPS.getRevision().get()));
        if (commit.getFullMessage().equals(message)) {
            throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
        }
        Date now = myIdent.getWhen();
        Change change = db.changes().get(changeId);
        PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setParentIds(commit.getParents());
        commitBuilder.setAuthor(commit.getAuthorIdent());
        commitBuilder.setCommitter(authorIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
        final PatchSet newPatchSet = new PatchSet(id);
        newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
        newPatchSet.setUploader(user.getAccountId());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
        CommitReceivedEvent commitReceivedEvent = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), newCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), newCommit, user);
        try {
            commitValidators.validateForReceiveCommits(commitReceivedEvent);
        } catch (CommitValidationException e) {
            throw new InvalidChangeOperationException(e.getMessage());
        }
        final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        gitRefUpdated.fire(change.getProject(), ru);
        db.changes().beginTransaction(change.getId());
        try {
            Change updatedChange = db.changes().get(change.getId());
            if (updatedChange != null && updatedChange.getStatus().isOpen()) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
            }
            ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
            db.patchSets().insert(Collections.singleton(newPatchSet));
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(patchSetId)) {
                        return null;
                    }
                    if (change.getStatus() != Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
            }
            approvalsUtil.copyVetosToPatchSet(db, refControl.getProjectControl().getLabelTypes(), change.currentPatchSetId());
            final List<FooterLine> footerLines = newCommit.getFooterLines();
            updateTrackingIds(db, change, trackingFooters, footerLines);
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            cmsg.setMessage(msg);
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
            final CommitMessageEditedSender cm = commitMessageEditedSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(cmsg);
            cm.send();
        } finally {
            db.rollback();
        }
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
        return change.getId();
    } finally {
        revWalk.release();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final RefControl refControl, CommitValidators commitValidators, final IdentifiedUser user, final String message, final ReviewDb db, final CommitMessageEditedSender.Factory commitMessageEditedSenderFactory, final ChangeHooks hooks, Repository git, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated gitRefUpdated, PersonIdent myIdent, final TrackingFooters trackingFooters) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet originalPS = db.patchSets().get(patchSetId);
    if (originalPS == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(originalPS.getRevision().get()));
        if (commit.getFullMessage().equals(message)) {
            throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
        }
        Date now = myIdent.getWhen();
        Change change = db.changes().get(changeId);
        PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setParentIds(commit.getParents());
        commitBuilder.setAuthor(commit.getAuthorIdent());
        commitBuilder.setCommitter(authorIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
        final PatchSet newPatchSet = new PatchSet(id);
        newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
        newPatchSet.setUploader(user.getAccountId());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
        CommitReceivedEvent commitReceivedEvent = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), newCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), newCommit, user);
        try {
            commitValidators.validateForReceiveCommits(commitReceivedEvent);
        } catch (CommitValidationException e) {
            throw new InvalidChangeOperationException(e.getMessage());
        }
        final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        gitRefUpdated.fire(change.getProject(), ru);
        db.changes().beginTransaction(change.getId());
        try {
            Change updatedChange = db.changes().get(change.getId());
            if (updatedChange != null && updatedChange.getStatus().isOpen()) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
            }
            ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
            db.patchSets().insert(Collections.singleton(newPatchSet));
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(patchSetId)) {
                        return null;
                    }
                    if (change.getStatus() != Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
            }
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), originalPS.getId(), change.currentPatchSetId());
            final List<FooterLine> footerLines = newCommit.getFooterLines();
            updateTrackingIds(db, change, trackingFooters, footerLines);
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            cmsg.setMessage(msg);
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
            final CommitMessageEditedSender cm = commitMessageEditedSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(cmsg);
            cm.send();
        } finally {
            db.rollback();
        }
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
        return change.getId();
    } finally {
        revWalk.release();
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    showUsernameInReviewCategory = new CheckBox(Util.C.showUsernameInReviewCategory());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    defaultCommentVisibilityStrategy = new ListBox();
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    final Grid formGrid = new Grid(9, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, Util.C.defaultCommentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, defaultCommentVisibilityStrategy);
    row++;
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(showUsernameInReviewCategory);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(defaultCommentVisibilityStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    showUsernameInReviewCategory = new CheckBox(Util.C.showUsernameInReviewCategory());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    commentVisibilityStrategy = new ListBox();
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    final Grid formGrid = new Grid(9, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, Util.C.commentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, commentVisibilityStrategy);
    row++;
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(showUsernameInReviewCategory);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(commentVisibilityStrategy);
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    showUsernameInReviewCategory.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    defaultCommentVisibilityStrategy.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    showUsernameInReviewCategory.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    commentVisibilityStrategy.setEnabled(on);
}
#end_block

#method_before
private void display(final AccountGeneralPreferences p) {
    showSiteHeader.setValue(p.isShowSiteHeader());
    useFlashClipboard.setValue(p.isUseFlashClipboard());
    copySelfOnEmails.setValue(p.isCopySelfOnEmails());
    reversePatchSetOrder.setValue(p.isReversePatchSetOrder());
    showUsernameInReviewCategory.setValue(p.isShowUsernameInReviewCategory());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.getMaximumPageSize());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.getDateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.getTimeFormat());
    relativeDateInChangeTable.setValue(p.isRelativeDateInChangeTable());
    setListBox(defaultCommentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT, p.getDefaultCommentVisibilityStrategy());
}
#method_after
private void display(final AccountGeneralPreferences p) {
    showSiteHeader.setValue(p.isShowSiteHeader());
    useFlashClipboard.setValue(p.isUseFlashClipboard());
    copySelfOnEmails.setValue(p.isCopySelfOnEmails());
    reversePatchSetOrder.setValue(p.isReversePatchSetOrder());
    showUsernameInReviewCategory.setValue(p.isShowUsernameInReviewCategory());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.getMaximumPageSize());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.getDateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.getTimeFormat());
    relativeDateInChangeTable.setValue(p.isRelativeDateInChangeTable());
    setListBox(commentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT, p.getCommentVisibilityStrategy());
}
#end_block

#method_before
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setDefaultCommentVisibilityStrategy(getListBox(defaultCommentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_MOST_RECENT, CommentVisibilityStrategy.values()));
    enable(false);
    save.setEnabled(false);
    Util.ACCOUNT_SVC.changePreferences(p, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(final VoidResult result) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
        }

        @Override
        public void onFailure(final Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_MOST_RECENT, CommentVisibilityStrategy.values()));
    enable(false);
    save.setEnabled(false);
    Util.ACCOUNT_SVC.changePreferences(p, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(final VoidResult result) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
        }

        @Override
        public void onFailure(final Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void addComments(final ChangeDetail detail) {
    comments.clear();
    final AccountInfoCache accts = detail.getAccounts();
    final List<ChangeMessage> msgList = detail.getMessages();
    HorizontalPanel title = new HorizontalPanel();
    title.setWidth("100%");
    title.add(new Label(Util.C.changeScreenComments()));
    if (msgList.size() > 1) {
        title.add(messagesMenuBar());
    }
    title.setStyleName(Gerrit.RESOURCES.css().blockHeader());
    comments.add(title);
    final long AGE = 7 * 24 * 60 * 60 * 1000L;
    final Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    final CommentVisibilityStrategy commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getDefaultCommentVisibilityStrategy();
    for (int i = 0; i < msgList.size(); i++) {
        final ChangeMessage msg = msgList.get(i);
        AccountInfo author;
        if (msg.getAuthor() != null) {
            author = FormatUtil.asInfo(accts.get(msg.getAuthor()));
        } else {
            author = AccountInfo.create(0, Util.C.messageNoAuthor(), null);
        }
        boolean isRecent;
        if (i == msgList.size() - 1) {
            isRecent = true;
        } else {
            // TODO Instead of opening messages by strict age, do it by "unread"?
            isRecent = msg.getWrittenOn().after(aged);
        }
        final CommentPanel cp = new CommentPanel(author, msg.getWrittenOn(), msg.getMessage());
        cp.setRecent(isRecent);
        cp.addStyleName(Gerrit.RESOURCES.css().commentPanelBorder());
        if (i == msgList.size() - 1) {
            cp.addStyleName(Gerrit.RESOURCES.css().commentPanelLast());
        }
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_RECENT:
                isOpen = isRecent;
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
            default:
                isOpen = i == msgList.size() - 1;
                break;
        }
        cp.setOpen(isOpen);
        comments.add(cp);
    }
    final Button b = new Button(Util.C.changeScreenAddComment());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            PatchSet.Id currentPatchSetId = patchSetsBlock.getCurrentPatchSet().getId();
            Gerrit.display(Dispatcher.toPublish(currentPatchSetId));
        }
    });
    comments.add(b);
    comments.setVisible(msgList.size() > 0);
}
#method_after
private void addComments(final ChangeDetail detail) {
    comments.clear();
    final AccountInfoCache accts = detail.getAccounts();
    final List<ChangeMessage> msgList = detail.getMessages();
    HorizontalPanel title = new HorizontalPanel();
    title.setWidth("100%");
    title.add(new Label(Util.C.changeScreenComments()));
    if (msgList.size() > 1) {
        title.add(messagesMenuBar());
    }
    title.setStyleName(Gerrit.RESOURCES.css().blockHeader());
    comments.add(title);
    final long AGE = 7 * 24 * 60 * 60 * 1000L;
    final Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    CommentVisibilityStrategy commentVisibilityStrategy = CommentVisibilityStrategy.EXPAND_MOST_RECENT;
    if (Gerrit.isSignedIn()) {
        commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getCommentVisibilityStrategy();
    }
    for (int i = 0; i < msgList.size(); i++) {
        final ChangeMessage msg = msgList.get(i);
        AccountInfo author;
        if (msg.getAuthor() != null) {
            author = FormatUtil.asInfo(accts.get(msg.getAuthor()));
        } else {
            author = AccountInfo.create(0, Util.C.messageNoAuthor(), null);
        }
        boolean isRecent;
        if (i == msgList.size() - 1) {
            isRecent = true;
        } else {
            // TODO Instead of opening messages by strict age, do it by "unread"?
            isRecent = msg.getWrittenOn().after(aged);
        }
        final CommentPanel cp = new CommentPanel(author, msg.getWrittenOn(), msg.getMessage());
        cp.setRecent(isRecent);
        cp.addStyleName(Gerrit.RESOURCES.css().commentPanelBorder());
        if (i == msgList.size() - 1) {
            cp.addStyleName(Gerrit.RESOURCES.css().commentPanelLast());
        }
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_RECENT:
                isOpen = isRecent;
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
            default:
                isOpen = i == msgList.size() - 1;
                break;
        }
        cp.setOpen(isOpen);
        comments.add(cp);
    }
    final Button b = new Button(Util.C.changeScreenAddComment());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            PatchSet.Id currentPatchSetId = patchSetsBlock.getCurrentPatchSet().getId();
            Gerrit.display(Dispatcher.toPublish(currentPatchSetId));
        }
    });
    comments.add(b);
    comments.setVisible(msgList.size() > 0);
}
#end_block

#method_before
@Override
public Object apply(TopLevelResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    if (format == OutputFormat.TEXT) {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        display(buf);
        return BinaryResult.create(buf.toByteArray()).setContentType("text/plain").setCharacterEncoding("UTF-8");
    }
    format = OutputFormat.JSON;
    return display(null);
}
#method_after
@Override
public Object apply(TopLevelResource resource) {
    if (format == OutputFormat.TEXT) {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        display(buf);
        return BinaryResult.create(buf.toByteArray()).setContentType("text/plain").setCharacterEncoding("UTF-8");
    }
    return apply();
}
#end_block

#method_before
@Override
public Object apply(TopLevelResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    if (format == OutputFormat.TEXT) {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        display(buf);
        return BinaryResult.create(buf.toByteArray()).setContentType("text/plain").setCharacterEncoding("UTF-8");
    }
    format = OutputFormat.JSON;
    return display(null);
}
#method_after
public Map<String, ProjectInfo> apply() {
    format = OutputFormat.JSON;
    return display(null);
}
#end_block

#method_before
@Override
public Object apply(CommentResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#method_after
@Override
public Object apply(CommentResource rsrc) throws OrmException {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#end_block

#method_before
@Override
public Object apply(RevisionResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Map<String, List<CommentInfo>> out = Maps.newTreeMap();
    AccountInfo.Loader accountLoader = useAccountLoader() ? accountLoaderFactory.create(true) : null;
    for (PatchLineComment c : listComments(rsrc)) {
        CommentInfo o = new CommentInfo(c, accountLoader);
        List<CommentInfo> list = out.get(o.path);
        if (list == null) {
            list = Lists.newArrayList();
            out.put(o.path, list);
        }
        o.path = null;
        list.add(o);
    }
    for (List<CommentInfo> list : out.values()) {
        Collections.sort(list, new Comparator<CommentInfo>() {

            @Override
            public int compare(CommentInfo a, CommentInfo b) {
                int c = firstNonNull(a.side, Side.REVISION).ordinal() - firstNonNull(b.side, Side.REVISION).ordinal();
                if (c == 0) {
                    c = firstNonNull(a.line, 0) - firstNonNull(b.line, 0);
                }
                if (c == 0) {
                    c = a.id.compareTo(b.id);
                }
                return c;
            }
        });
    }
    if (accountLoader != null) {
        accountLoader.fill();
    }
    return out;
}
#method_after
@Override
public Object apply(RevisionResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Map<String, List<CommentInfo>> out = Maps.newTreeMap();
    AccountInfo.Loader accountLoader = includeAuthorInfo() ? accountLoaderFactory.create(true) : null;
    for (PatchLineComment c : listComments(rsrc)) {
        CommentInfo o = new CommentInfo(c, accountLoader);
        List<CommentInfo> list = out.get(o.path);
        if (list == null) {
            list = Lists.newArrayList();
            out.put(o.path, list);
        }
        o.path = null;
        list.add(o);
    }
    for (List<CommentInfo> list : out.values()) {
        Collections.sort(list, new Comparator<CommentInfo>() {

            @Override
            public int compare(CommentInfo a, CommentInfo b) {
                int c = firstNonNull(a.side, Side.REVISION).ordinal() - firstNonNull(b.side, Side.REVISION).ordinal();
                if (c == 0) {
                    c = firstNonNull(a.line, 0) - firstNonNull(b.line, 0);
                }
                if (c == 0) {
                    c = a.id.compareTo(b.id);
                }
                return c;
            }
        });
    }
    if (accountLoader != null) {
        accountLoader.fill();
    }
    return out;
}
#end_block

#method_before
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final GarbageCollectionProgressMonitor pm) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        pm.startGarbageCollection(projectName);
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(pm, (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            pm.endGarbageCollection();
        }
    }
    return result;
}
#method_after
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final PrintWriter writer) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        writer.print("collecting garbage for \"" + projectName + "\":\n");
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(new TextProgressMonitor(writer), (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            writer.print("done.\n\n");
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                collectGarbage();
            } finally {
                stdout.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                runGC();
            } finally {
                stdout.flush();
            }
        }
    });
}
#end_block

#method_before
@Override
public void run() throws UnloggedFailure, Failure, Exception {
    // Don't let people delete All-Projects, that's stupid
    final String projectName = project.getProject().getName();
    if (project.getProject().getName().endsWith(AllProjectsNameProvider.DEFAULT)) {
        throw new UnloggedFailure("Perhaps you meant to rm -fR " + site.site_path);
    }
    try {
        databaseDeleteHandler.assertCanDelete(project.getProject());
    } catch (Exception e) {
        throw new UnloggedFailure("Cannot delete project " + projectName + ": " + e.getMessage());
    }
    if (!yesReallyDelete) {
        stdout.print("Really delete " + project.getProject().getName() + "?\n");
        stdout.print("This is an operation which permanently deletes data. " + "This cannot be undone!\n");
        stdout.print("If you are sure you wish to delete this project, re-run\n" + "with the --yes-really-delete flag.\n");
        return;
    }
    if (!force) {
        Collection<String> warnings = databaseDeleteHandler.getWarnings(project.getProject());
        if (warnings != null && !warnings.isEmpty()) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("There are warnings against deleting ");
            msgBuilder.append(projectName);
            msgBuilder.append(":\n");
            for (String warning : warnings) {
                msgBuilder.append(" * ");
                msgBuilder.append(warning);
                msgBuilder.append("\n");
            }
            msgBuilder.append("To really delete ");
            msgBuilder.append(projectName);
            msgBuilder.append(" nonetheless, re-run with the --force flag.");
            throw new UnloggedFailure(msgBuilder.toString());
        }
    }
    databaseDeleteHandler.delete(project.getProject());
    deleteFromDisk(project.getProject());
    // Clean up the cache
    projectCache.remove(project.getProject());
}
#method_after
@Override
public void run() throws UnloggedFailure, Failure, Exception {
    // Don't let people delete All-Projects, that's stupid
    final String projectName = project.getProject().getName();
    if (project.getProject().getName().endsWith(AllProjectsNameProvider.DEFAULT)) {
        throw new UnloggedFailure("Perhaps you meant to rm -fR " + site.site_path);
    }
    try {
        databaseDeleteHandler.assertCanDelete(project.getProject());
    } catch (Exception e) {
        throw new UnloggedFailure("Cannot delete project " + projectName + ": " + e.getMessage());
    }
    if (!yesReallyDelete) {
        stdout.print("Really delete " + project.getProject().getName() + "?\n");
        stdout.print("This is an operation which permanently deletes data. " + "This cannot be undone!\n");
        stdout.print("If you are sure you wish to delete this project, re-run\n" + "with the --yes-really-delete flag.\n");
        return;
    }
    if (!force) {
        Collection<String> warnings = databaseDeleteHandler.getWarnings(project.getProject());
        if (warnings != null && !warnings.isEmpty()) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("There are warnings against deleting ");
            msgBuilder.append(projectName);
            msgBuilder.append(":\n");
            for (String warning : warnings) {
                msgBuilder.append(" * ");
                msgBuilder.append(warning);
                msgBuilder.append("\n");
            }
            msgBuilder.append("To really delete ");
            msgBuilder.append(projectName);
            msgBuilder.append(", re-run with the --force flag.");
            throw new UnloggedFailure(msgBuilder.toString());
        }
    }
    databaseDeleteHandler.delete(project.getProject());
    deleteFromDisk(project.getProject());
    // Clean up the cache
    projectCache.remove(project.getProject());
}
#end_block

#method_before
public Set<Account.Id> findAll(String nameOrEmail) throws OrmException {
    Matcher m = Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail);
    if (m.matches()) {
        return findById(m.group(1));
    }
    if (nameOrEmail.matches("^[1-9][0-9]*$")) {
        return findById(nameOrEmail);
    }
    if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) {
        AccountState who = byId.getByUsername(nameOrEmail);
        if (who != null) {
            return Collections.singleton(who.getAccount().getId());
        }
    }
    return findAllByNameOrEmail(nameOrEmail);
}
#method_after
public Set<Account.Id> findAll(String nameOrEmail) throws OrmException {
    Matcher m = Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail);
    if (m.matches()) {
        Account.Id id = Account.Id.parse(m.group(1));
        if (exists(id)) {
            return Collections.singleton(id);
        } else {
            return Collections.emptySet();
        }
    }
    if (nameOrEmail.matches("^[1-9][0-9]*$")) {
        Account.Id id = Account.Id.parse(nameOrEmail);
        if (exists(id)) {
            return Collections.singleton(id);
        } else {
            return Collections.emptySet();
        }
    }
    if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) {
        AccountState who = byId.getByUsername(nameOrEmail);
        if (who != null) {
            return Collections.singleton(who.getAccount().getId());
        }
    }
    return findAllByNameOrEmail(nameOrEmail);
}
#end_block

#method_before
@SuppressWarnings("serial")
private List<AccountInfo> GET(String endpoint) throws IOException {
    RestResponse r = session.get(endpoint);
    return (new Gson()).fromJson(r.getReader(), new TypeToken<List<AccountInfo>>() {
    }.getType());
}
#method_after
@SuppressWarnings("serial")
private List<AccountInfo> GET(String endpoint) throws IOException {
    RestResponse r = session.get(endpoint);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    return (new Gson()).fromJson(r.getReader(), new TypeToken<List<AccountInfo>>() {
    }.getType());
}
#end_block

#method_before
@SuppressWarnings("serial")
private AccountInfo GET_ONE(String endpoint) throws IOException {
    RestResponse r = session.get(endpoint);
    return (new Gson()).fromJson(r.getReader(), new TypeToken<AccountInfo>() {
    }.getType());
}
#method_after
@SuppressWarnings("serial")
private AccountInfo GET_ONE(String endpoint) throws IOException {
    RestResponse r = session.get(endpoint);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    return (new Gson()).fromJson(r.getReader(), new TypeToken<AccountInfo>() {
    }.getType());
}
#end_block

#method_before
@Override
public Object apply(AccountResource resource) throws BadRequestException, Exception {
    if (self.get() != resource.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    CapabilityControl cc = resource.getUser().getCapabilities();
    Map<String, Object> have = Maps.newLinkedHashMap();
    for (String name : GlobalCapability.getAllNames()) {
        if (!name.equals(PRIORITY) && want(name) && cc.canPerform(name)) {
            if (GlobalCapability.hasRange(name)) {
                have.put(name, new Range(cc.getRange(name)));
            } else {
                have.put(name, true);
            }
        }
    }
    have.put(CREATE_ACCOUNT, cc.canCreateAccount());
    have.put(CREATE_GROUP, cc.canCreateGroup());
    have.put(CREATE_PROJECT, cc.canCreateProject());
    have.put(KILL_TASK, cc.canKillTask());
    have.put(VIEW_CACHES, cc.canViewCaches());
    have.put(FLUSH_CACHES, cc.canFlushCaches());
    have.put(VIEW_CONNECTIONS, cc.canViewConnections());
    have.put(VIEW_QUEUE, cc.canViewQueue());
    have.put(START_REPLICATION, cc.canStartReplication());
    have.put(RAW_QUERY, cc.canPerformRawQuery());
    QueueProvider.QueueType queue = cc.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
    Iterator<Map.Entry<String, Object>> itr = have.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Object> e = itr.next();
        if (!want(e.getKey())) {
            itr.remove();
        } else if (e.getValue() instanceof Boolean && !((Boolean) e.getValue())) {
            itr.remove();
        }
    }
    if (format == OutputFormat.TEXT) {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, Object> e : have.entrySet()) {
            sb.append(e.getKey());
            if (!(e.getValue() instanceof Boolean)) {
                sb.append(": ");
                sb.append(e.getValue().toString());
            }
            sb.append('\n');
        }
        return BinaryResult.create(sb.toString());
    } else {
        return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
        }.getType());
    }
}
#method_after
@Override
public Object apply(AccountResource resource) throws BadRequestException, Exception {
    if (self.get() != resource.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    CapabilityControl cc = resource.getUser().getCapabilities();
    Map<String, Object> have = Maps.newLinkedHashMap();
    for (String name : GlobalCapability.getAllNames()) {
        if (!name.equals(PRIORITY) && want(name) && cc.canPerform(name)) {
            if (GlobalCapability.hasRange(name)) {
                have.put(name, new Range(cc.getRange(name)));
            } else {
                have.put(name, true);
            }
        }
    }
    have.put(CREATE_ACCOUNT, cc.canCreateAccount());
    have.put(CREATE_GROUP, cc.canCreateGroup());
    have.put(CREATE_PROJECT, cc.canCreateProject());
    have.put(EMAIL_REVIEWERS, cc.canEmailReviewers());
    have.put(KILL_TASK, cc.canKillTask());
    have.put(VIEW_CACHES, cc.canViewCaches());
    have.put(FLUSH_CACHES, cc.canFlushCaches());
    have.put(VIEW_CONNECTIONS, cc.canViewConnections());
    have.put(VIEW_QUEUE, cc.canViewQueue());
    have.put(START_REPLICATION, cc.canStartReplication());
    have.put(ACCESS_DATABASE, cc.canAccessDatabase());
    QueueProvider.QueueType queue = cc.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
    Iterator<Map.Entry<String, Object>> itr = have.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Object> e = itr.next();
        if (!want(e.getKey())) {
            itr.remove();
        } else if (e.getValue() instanceof Boolean && !((Boolean) e.getValue())) {
            itr.remove();
        }
    }
    if (format == OutputFormat.TEXT) {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, Object> e : have.entrySet()) {
            sb.append(e.getKey());
            if (!(e.getValue() instanceof Boolean)) {
                sb.append(": ");
                sb.append(e.getValue().toString());
            }
            sb.append('\n');
        }
        return BinaryResult.create(sb.toString());
    } else {
        return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
        }.getType());
    }
}
#end_block

#method_before
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getProject().getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
List<SectionMatcher> getAllSections() {
    if (isAllProjects) {
        return getLocalAccessSections();
    }
    List<SectionMatcher> all = new ArrayList<SectionMatcher>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    ProjectState allProjects = projectCache.getAllProjects();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        all.addAll(s.getLocalAccessSections());
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    if (seen.add(allProjects.getProject().getNameKey())) {
        all.addAll(allProjects.getLocalAccessSections());
    }
    return all;
}
#method_after
List<SectionMatcher> getAllSections() {
    if (isAllProjects) {
        return getLocalAccessSections();
    }
    List<SectionMatcher> all = Lists.newArrayList();
    for (ProjectState s : tree()) {
        all.addAll(s.getLocalAccessSections());
    }
    return all;
}
#end_block

#method_before
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isAllProjects) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#method_after
public Set<AccountGroup.UUID> getOwners() {
    for (ProjectState p : tree()) {
        if (!p.localOwners.isEmpty()) {
            return p.localOwners;
        }
    }
    return Collections.emptySet();
}
#end_block

#method_before
boolean isOwner(GroupMembership groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (groups.containsAnyOf(s.localOwners)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#method_after
boolean isOwner(final GroupMembership groups) {
    return Iterables.any(tree(), new Predicate<ProjectState>() {

        @Override
        public boolean apply(ProjectState in) {
            return groups.containsAnyOf(in.localOwners);
        }
    });
}
#end_block

#method_before
private boolean getInheritableBoolean(Function<Project, InheritableBoolean> func) {
    Set<Project.NameKey> seen = Sets.newHashSet();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        switch(func.apply(s.getProject())) {
            case TRUE:
                return true;
            case FALSE:
                return false;
            case INHERIT:
            default:
                Project.NameKey parent = s.getProject().getParent(allProjectsName);
                if (parent != null && seen.add(parent)) {
                    s = projectCache.get(parent);
                } else {
                    s = null;
                }
        }
    } while (s != null);
    return false;
}
#method_after
private boolean getInheritableBoolean(Function<Project, InheritableBoolean> func) {
    for (ProjectState s : tree()) {
        switch(func.apply(s.getProject())) {
            case TRUE:
                return true;
            case FALSE:
                return false;
            case INHERIT:
            default:
                continue;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, Input input) throws ResourceNotFoundException, AuthException, OrmException, EmailException {
    if (input.reviewer == null) {
        throw new ResourceNotFoundException();
    }
    Account.Id accountId = parser.parse(rsrc, input.reviewer);
    try {
        if (accountId != null) {
            return putAccount(reviewerFactory.create(rsrc, accountId));
        } else {
            return putGroup(rsrc, input);
        }
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, Input input) throws BadRequestException, ResourceNotFoundException, AuthException, OrmException, EmailException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Account.Id accountId = parser.parse(rsrc, input.reviewer);
    try {
        if (accountId != null) {
            return putAccount(reviewerFactory.create(rsrc, accountId));
        } else {
            return putGroup(rsrc, input);
        }
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    command(gerrit, TestSubmitRuleCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, Receive.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, ReviewCommand.class);
    // deprecated alias to review command
    alias(gerrit, "approve", ReviewCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, Receive.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, ReviewCommand.class);
    // deprecated alias to review command
    alias(gerrit, "approve", ReviewCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
}
#end_block

#method_before
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps == null) {
            throw new ResourceNotFoundException(id);
        }
        return new RevisionResource(change, ps);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, id.get())) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && change.getControl().isPatchVisible(ps, dbProvider.get())) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0));
}
#method_after
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps);
        }
        throw new ResourceNotFoundException(id);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, id.get())) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && visible(change, ps)) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0));
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (ReplaceRequest replace : replaceByChange.values()) {
        if (replace.inputCommand == newChange) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (newChange == null || newChange.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(newChange, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, OrmException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == newChange) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, OrmException> f : futures) {
            f.checkedGet();
        }
        newChange.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(newChange, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(newChange, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (ReplaceRequest replace : replaceByChange.values()) {
        if (replace.inputCommand == newChange) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (newChange == null || newChange.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(newChange, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, OrmException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == newChange) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, OrmException> f : futures) {
            f.checkedGet();
        }
        newChange.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(newChange, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(newChange, "internal server error");
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients(reviewerId, ccId);
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        insertAncestors(db, ps.getId(), commit);
        db.patchSets().insert(Collections.singleton(ps));
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(db, change, ps, info, recipients.getReviewers(), Collections.<Account.Id>emptySet());
        db.commit();
    } finally {
        db.rollback();
    }
    created = true;
    replication.fire(project.getNameKey(), ps.getRefName());
    hooks.doPatchsetCreatedHook(change, ps, db);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients(reviewerId, ccId);
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        insertAncestors(db, ps.getId(), commit);
        db.patchSets().insert(Collections.singleton(ps));
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(db, change, ps, info, recipients.getReviewers(), Collections.<Account.Id>emptySet());
        db.commit();
    } finally {
        db.rollback();
    }
    created = true;
    gitRefUpdated.fire(project.getNameKey(), ps.getRefName(), ObjectId.zeroId(), commit);
    hooks.doPatchsetCreatedHook(change, ps, db);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients(reviewerId, ccId);
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    final RefUpdate ru = repo.updateRef(newPatchSet.getRefName());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + newPatchSet.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.fire(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients(reviewerId, ccId);
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#end_block

#method_before
Map<String, Provider<Command>> getMap() {
    return commands;
}
#method_after
Map<String, CommandProvider> getMap() {
    return commands;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final Provider<Command> p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#end_block

#method_before
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!getName().isEmpty()) {
        usage.append(" of ");
        usage.append(getName());
    }
    usage.append(" are:\n");
    usage.append("\n");
    int maxLength = -1;
    for (String name : commands.keySet()) {
        maxLength = Math.max(maxLength, name.length());
    }
    String format = "%-" + maxLength + "s   %s";
    for (String name : Sets.newTreeSet(commands.keySet())) {
        final Command cmd = commands.get(name).get();
        usage.append("   ");
        if (cmd instanceof BaseCommand) {
            BaseCommand bc = (BaseCommand) cmd;
            String descr = bc.getDescription();
            if (name.equals("plugin")) {
                descr = "Install, reload, remove and list plugins";
            }
            usage.append(String.format(format, name, descr));
        } else {
            usage.append(name);
        }
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (getName().indexOf(' ') < 0) {
        usage.append(getName());
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#method_after
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!getName().isEmpty()) {
        usage.append(" of ");
        usage.append(getName());
    }
    usage.append(" are:\n");
    usage.append("\n");
    int maxLength = -1;
    for (String name : commands.keySet()) {
        maxLength = Math.max(maxLength, name.length());
    }
    String format = "%-" + maxLength + "s   %s";
    for (String name : Sets.newTreeSet(commands.keySet())) {
        final CommandProvider p = commands.get(name);
        usage.append("   ");
        usage.append(String.format(format, name, Strings.nullToEmpty(p.getDescription())));
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (getName().indexOf(' ') < 0) {
        usage.append(getName());
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#end_block

#method_before
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        final List<String> argv = new ArrayList<String>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        final Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.getAbsolutePath());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        InputStream is = ps.getInputStream();
        String output = null;
        try {
            output = readOutput(is);
        } finally {
            try {
                is.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    final int exitValue = result.getExitValue();
    if (exitValue != 0) {
        log.debug("hook[" + getName() + "] exitValue:" + exitValue);
    } else {
        log.info("hook[" + getName() + "] exitValue:" + exitValue);
    }
    BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
    try {
        String line;
        while ((line = br.readLine()) != null) {
            log.info("hook[" + getName() + "] output: " + line);
        }
    } catch (IOException iox) {
        log.error("Error writing hook output", iox);
    }
    return result;
}
#method_after
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        final List<String> argv = new ArrayList<String>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        final Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.getAbsolutePath());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        InputStream is = ps.getInputStream();
        String output = null;
        try {
            output = readOutput(is);
        } finally {
            try {
                is.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    final int exitValue = result.getExitValue();
    if (exitValue == 0) {
        log.debug("hook[" + getName() + "] exitValue:" + exitValue);
    } else {
        log.info("hook[" + getName() + "] exitValue:" + exitValue);
    }
    BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
    try {
        String line;
        while ((line = br.readLine()) != null) {
            log.info("hook[" + getName() + "] output: " + line);
        }
    } catch (IOException iox) {
        log.error("Error writing hook output", iox);
    }
    return result;
}
#end_block

#method_before
@Override
protected void display(final GroupDetail groupDetail) {
    switch(groupDetail.group.getType()) {
        case INTERNAL:
            accounts = groupDetail.accounts;
            MemberList.all(getGroupUUID(), new GerritCallback<MemberList>() {

                @Override
                public void onSuccess(MemberList result) {
                    members.display(result.asList());
                }
            });
            GroupList.included(getGroupUUID(), new GerritCallback<GroupList>() {

                @Override
                public void onSuccess(GroupList result) {
                    includes.display(result.asList());
                }
            });
            break;
        default:
            memberPanel.setVisible(false);
            includePanel.setVisible(false);
            noMembersInfo.setVisible(true);
            break;
    }
    enableForm(groupDetail.canModify);
    delMember.setVisible(groupDetail.canModify);
    delInclude.setVisible(groupDetail.canModify);
}
#method_after
@Override
protected void display(final GroupInfo group, final boolean canModify) {
    if (AccountGroup.isInternalGroup(group.getGroupUUID()) && !AccountGroup.isSystemGroup(group.getGroupUUID())) {
        MemberList.all(getGroupUUID(), new GerritCallback<MemberList>() {

            @Override
            public void onSuccess(MemberList result) {
                members.display(Natives.asList(result));
            }
        });
        GroupList.included(getGroupUUID(), new GerritCallback<GroupList>() {

            @Override
            public void onSuccess(GroupList result) {
                includes.display(Natives.asList(result));
            }
        });
    } else {
        memberPanel.setVisible(false);
        includePanel.setVisible(false);
        noMembersInfo.setVisible(true);
    }
    enableForm(canModify);
    delMember.setVisible(canModify);
    delInclude.setVisible(canModify);
}
#end_block

#method_before
void insert(MemberInfo info) {
    Comparator<MemberInfo> c = new Comparator<MemberInfo>() {

        @Override
        public int compare(MemberInfo a, MemberInfo b) {
            int cmp = nullToEmpty(a.fullName()).compareTo(nullToEmpty(b.fullName()));
            if (cmp != 0) {
                return cmp;
            }
            cmp = nullToEmpty(a.preferredEmail()).compareTo(nullToEmpty(b.preferredEmail()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getAccountId().get() - b.getAccountId().get();
        }

        public String nullToEmpty(String str) {
            return str == null ? "" : str;
        }
    };
    for (int row = 1; row < table.getRowCount(); row++) {
        final MemberInfo i = getRowItem(row);
        if (i != null) {
            if (c.compare(info, i) < 0) {
                table.insertRow(row);
                applyDataRowStyle(row);
                populate(row, info);
                return;
            }
        }
    }
    final int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    populate(row, info);
}
#method_after
void insert(MemberInfo info) {
    Comparator<MemberInfo> c = new Comparator<MemberInfo>() {

        @Override
        public int compare(MemberInfo a, MemberInfo b) {
            int cmp = nullToEmpty(a.fullName()).compareTo(nullToEmpty(b.fullName()));
            if (cmp != 0) {
                return cmp;
            }
            cmp = nullToEmpty(a.preferredEmail()).compareTo(nullToEmpty(b.preferredEmail()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getAccountId().get() - b.getAccountId().get();
        }

        public String nullToEmpty(String str) {
            return str == null ? "" : str;
        }
    };
    int insertPosition = table.getRowCount();
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        MemberInfo i = getRowItem(middle);
        int cmp = c.compare(i, info);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return;
        }
    }
    insertPosition = left;
    table.insertRow(insertPosition);
    applyDataRowStyle(insertPosition);
    populate(insertPosition, info);
}
#end_block

#method_before
void populate(final int row, final MemberInfo i) {
    final Account.Id accountId = i.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, i);
}
#method_after
void populate(final int row, final MemberInfo i) {
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, new AccountLink(i));
    table.setText(row, 3, i.preferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, i);
}
#end_block

#method_before
void insert(GroupInfo info) {
    Comparator<GroupInfo> c = new Comparator<GroupInfo>() {

        @Override
        public int compare(GroupInfo a, GroupInfo b) {
            int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getGroupUUID().compareTo(b.getGroupUUID());
        }

        public String nullToEmpty(String str) {
            return str == null ? "" : str;
        }
    };
    for (int row = 1; row < table.getRowCount(); row++) {
        final GroupInfo i = getRowItem(row);
        if (i != null) {
            if (c.compare(info, i) < 0) {
                table.insertRow(row);
                applyDataRowStyle(row);
                populate(row, info);
                return;
            }
        }
    }
    final int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    populate(row, info);
}
#method_after
void insert(GroupInfo info) {
    Comparator<GroupInfo> c = new Comparator<GroupInfo>() {

        @Override
        public int compare(GroupInfo a, GroupInfo b) {
            int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getGroupUUID().compareTo(b.getGroupUUID());
        }

        private String nullToEmpty(@Nullable String str) {
            return (str == null) ? "" : str;
        }
    };
    int insertPosition = table.getRowCount();
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        GroupInfo i = getRowItem(middle);
        int cmp = c.compare(i, info);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return;
        }
    }
    insertPosition = left;
    table.insertRow(insertPosition);
    applyDataRowStyle(insertPosition);
    populate(insertPosition, info);
}
#end_block

#method_before
public static void isGroupOwner(String groupName, final AsyncCallback<Boolean> cb) {
    GroupList.myOwned(groupName, new AsyncCallback<GroupList>() {

        @Override
        public void onSuccess(GroupList result) {
            cb.onSuccess(!result.asList().isEmpty());
        }

        @Override
        public void onFailure(Throwable caught) {
            cb.onFailure(caught);
        }
    });
}
#method_after
public static void isGroupOwner(String groupName, final AsyncCallback<Boolean> cb) {
    GroupMap.myOwned(groupName, new AsyncCallback<GroupMap>() {

        @Override
        public void onSuccess(GroupMap result) {
            cb.onSuccess(!result.isEmpty());
        }

        @Override
        public void onFailure(Throwable caught) {
            cb.onFailure(caught);
        }
    });
}
#end_block

#method_before
public static void setGroupOptions(AccountGroup.UUID group, boolean isVisibleToAll, AsyncCallback<VoidResult> cb) {
    GroupOptionsInput in = GroupOptionsInput.create();
    in.isVisibleToAll(isVisibleToAll);
    group(group).view("options").put(in, cb);
}
#method_after
public static void setGroupOptions(AccountGroup.UUID group, boolean isVisibleToAll, AsyncCallback<VoidResult> cb) {
    GroupOptionsInput in = GroupOptionsInput.create();
    in.visibleToAll(isVisibleToAll);
    group(group).view("options").put(in, cb);
}
#end_block

#method_before
public static void addMembers(AccountGroup.UUID group, Set<String> members, final AsyncCallback<NativeList<MemberInfo>> cb) {
    if (members.size() == 1) {
        addMember(group, members.iterator().next(), new AsyncCallback<MemberInfo>() {

            @Override
            public void onSuccess(MemberInfo result) {
                cb.onSuccess(NativeList.of(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        MemberInput input = MemberInput.create();
        for (String member : members) {
            input.add_member(member);
        }
        members(group).post(input, cb);
    }
}
#method_after
public static void addMembers(AccountGroup.UUID group, Set<String> members, final AsyncCallback<JsArray<MemberInfo>> cb) {
    if (members.size() == 1) {
        addMember(group, members.iterator().next(), new AsyncCallback<MemberInfo>() {

            @Override
            public void onSuccess(MemberInfo result) {
                cb.onSuccess(Natives.arrayOf(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        MemberInput input = MemberInput.create();
        for (String member : members) {
            input.add_member(member);
        }
        members(group).post(input, cb);
    }
}
#end_block

#method_before
public static void addIncludedGroups(AccountGroup.UUID group, Set<String> includedGroups, final AsyncCallback<NativeList<GroupInfo>> cb) {
    if (includedGroups.size() == 1) {
        addIncludedGroup(group, includedGroups.iterator().next(), new AsyncCallback<GroupInfo>() {

            @Override
            public void onSuccess(GroupInfo result) {
                cb.onSuccess(NativeList.of(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        IncludedGroupInput input = IncludedGroupInput.create();
        for (String includedGroup : includedGroups) {
            input.add_group(includedGroup);
        }
        groups(group).post(input, cb);
    }
}
#method_after
public static void addIncludedGroups(AccountGroup.UUID group, Set<String> includedGroups, final AsyncCallback<JsArray<GroupInfo>> cb) {
    if (includedGroups.size() == 1) {
        addIncludedGroup(group, includedGroups.iterator().next(), new AsyncCallback<GroupInfo>() {

            @Override
            public void onSuccess(GroupInfo result) {
                cb.onSuccess(Natives.arrayOf(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        IncludedGroupInput input = IncludedGroupInput.create();
        for (String includedGroup : includedGroups) {
            input.add_group(includedGroup);
        }
        groups(group).post(input, cb);
    }
}
#end_block

#method_before
public final Set<String> values() {
    return Natives.keys(values0());
}
#method_after
public final Set<String> values() {
    return Natives.keys(_values());
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    if (!accounts.isEmpty()) {
        for (Account account : db.get().accounts().get(accounts.keySet())) {
            AccountAttribute a = accounts.get(account.getId());
            a.name = Strings.emptyToNull(account.getFullName());
        }
    }
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    if (options.contains(LABELS) || options.contains(DETAILED_LABELS)) {
        out.labels = labelsFor(cd, options.contains(DETAILED_LABELS));
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                if (detailed) {
                    ApprovalType at = approvalTypes.byLabel(r.label);
                    if (at != null) {
                        PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
                        n.category = at.getCategory().getName();
                        n.id = at.getCategory().getId().get();
                        n.values = Maps.newLinkedHashMap();
                        for (ApprovalCategoryValue acv : at.getValues()) {
                            if (range.contains(acv.getValue())) {
                                n.values.put(acv.formatValue(), acv.getName());
                            }
                        }
                        if (n.values.size() == 1 && " 0".equals(Iterables.getOnlyElement(n.values.keySet()))) {
                            n.values = ImmutableMap.of();
                        }
                    }
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    initLabels(cd, labels, standard);
    Collection<PatchSetApproval> approvals = null;
    if (detailed) {
        approvals = cd.currentApprovals(db);
        setAllApprovals(labels, approvals);
    }
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null) {
            // TODO: Support arbitrary labels.
            continue;
        }
        if (standard) {
            approvals = setRecommendedAndDisliked(cd, approvals, type, e.getValue());
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountInfoCache = new AccountInfo.Cache(db, !options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountInfoCache.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountInfoCache.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountInfoCache.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountInfoCache.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountLoader.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountLoader.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.add").to(AddIncludedGroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
    put(INCLUDED_GROUP_KIND).to(UpdateIncludedGroup.class);
    install(new FactoryModuleBuilder().build(CreateGroup.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.add").to(AddIncludedGroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    get(GROUP_KIND, "owner").to(GetOwner.class);
    put(GROUP_KIND, "owner").to(PutOwner.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
    put(INCLUDED_GROUP_KIND).to(UpdateIncludedGroup.class);
    install(new FactoryModuleBuilder().build(CreateGroup.Factory.class));
}
#end_block

#method_before
@Override
public String apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceNotFoundException, ResourceConflictException, OrmException {
    if (resource.toAccountGroup() == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.emptyToNull(input.name) == null) {
        throw new BadRequestException("new name is missing");
    }
    try {
        return performRenameGroupFactory.create().renameGroup(resource.toAccountGroup().getId(), input.name).group.getName();
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException();
    } catch (InvalidNameException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public String apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceNotFoundException, ResourceConflictException, OrmException {
    if (resource.toAccountGroup() == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    } else if (input == null || Strings.isNullOrEmpty(input.name)) {
        throw new BadRequestException("name is required");
    }
    try {
        return performRenameGroupFactory.create().renameGroup(resource.toAccountGroup().getId(), input.name).group.getName();
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException();
    } catch (InvalidNameException e) {
        throw new BadRequestException(e.getMessage());
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public GroupInfo apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.emptyToNull(input.owner) == null) {
        throw new BadRequestException("new owner is missing");
    }
    GroupReference owner = GroupBackends.findExactSuggestion(groupBackend, input.owner);
    if (owner == null) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
    try {
        GroupControl c = controlFactory.validateFor(owner.getUUID());
        if (!internalGroup.getOwnerGroupUUID().equals(owner.getUUID())) {
            internalGroup.setOwnerGroupUUID(owner.getUUID());
            db.accountGroups().update(Collections.singleton(internalGroup));
            groupCache.evict(internalGroup);
        }
        return new GroupInfo(c.getGroup());
    } catch (NoSuchGroupException e) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
}
#method_after
@Override
public GroupInfo apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceNotFoundException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.owner)) {
        throw new BadRequestException("owner is required");
    }
    GroupReference owner = GroupBackends.findExactSuggestion(groupBackend, input.owner);
    if (owner == null) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
    try {
        GroupControl c = controlFactory.validateFor(owner.getUUID());
        group = db.accountGroups().get(group.getId());
        if (group == null) {
            throw new ResourceNotFoundException();
        }
        if (!group.getOwnerGroupUUID().equals(owner.getUUID())) {
            group.setOwnerGroupUUID(owner.getUUID());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
        }
        return new GroupInfo(c.getGroup());
    } catch (NoSuchGroupException e) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    com.google.gwtjsonrpc.common.AsyncCallback<PatchSetPublishDetail> load = new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    };
    CallbackGroup cbs = new CallbackGroup();
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.add(load));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.addGwtjsonrpc(new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    }));
}
#end_block

#method_before
private void onSuccess() {
    if (results.size() < callbacks.size()) {
        return;
    }
    Throwable caught = null;
    for (Object o : callbacks) {
        try {
            Object result = results.get(o);
            if (o instanceof AsyncCallback) {
                @SuppressWarnings("unchecked")
                AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
                cb.onSuccess(result);
            } else {
                @SuppressWarnings("unchecked")
                com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
                cb.onSuccess(result);
            }
        } catch (Throwable t) {
            if (caught != null) {
                caught = t;
            }
        }
    }
    if (caught != null) {
        if (caught instanceof RuntimeException) {
            throw (RuntimeException) caught;
        } else if (caught instanceof Error) {
            throw (Error) caught;
        } else {
            throw new RuntimeException(caught);
        }
    }
}
#method_after
private void onSuccess() {
    if (results.size() < callbacks.size()) {
        return;
    }
    for (Object o : callbacks) {
        Object result = results.get(o);
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onSuccess(result);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onSuccess(result);
        }
    }
}
#end_block

#method_before
private void onFailure(Throwable caught) {
    for (Object o : callbacks) {
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onFailure(caught);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onFailure(caught);
        }
    }
}
#method_after
private void onFailure(Throwable caught) {
    if (failed) {
        return;
    }
    failed = true;
    for (Object o : callbacks) {
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onFailure(caught);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onFailure(caught);
        }
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(uuid.toString());
    sb.append("|");
    sb.append(sessionId);
    sb.append('|');
    sb.append(who);
    sb.append('|');
    sb.append(when);
    sb.append('|');
    sb.append(what);
    sb.append('|');
    sb.append(elapsed);
    sb.append('|');
    if (params != null) {
        sb.append('[');
        for (int i = 0; i < params.size(); i++) {
            if (i > 0)
                sb.append(',');
            if (params != null) {
                Set<String> paramNames = params.keySet();
                for (String paramName : paramNames) {
                    sb.append("name=");
                    sb.append(paramName);
                    int numValues = 0;
                    Collection<?> paramValues = params.get(paramName);
                    for (Object paramValue : paramValues) {
                        sb.append(Objects.firstNonNull(paramValue, "null"));
                        if (numValues++ > 0) {
                            sb.append(",");
                        }
                    }
                }
            }
        }
        sb.append(']');
    }
    sb.append('|');
    if (result != null) {
        sb.append(result);
    }
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return String.format("AuditEvent UUID:%s, SID:%s, TS:%d, who:%s, what:%s", uuid.get(), sessionId, when, who, what);
}
#end_block

#method_before
private Multimap<String, ?> extractParameters(DispatchCommand dcmd) {
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    Multimap<String, String> parms = ArrayListMultimap.create();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
        } else {
            if (paramName == null) {
                parms.put("$" + argPos++, arg);
            } else {
                parms.put(paramName, arg);
                paramName = null;
            }
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#method_after
private Multimap<String, ?> extractParameters(DispatchCommand dcmd) {
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    Multimap<String, String> parms = ArrayListMultimap.create();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        // -- stop parameters parsing
        if (arg.equals("--")) {
            for (i++; i < cmdArgs.length; i++) {
                parms.put("$" + argPos++, cmdArgs[i]);
            }
            break;
        }
        // --param=value
        int eqPos = arg.indexOf('=');
        if (arg.startsWith("--") && eqPos > 0) {
            parms.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));
            continue;
        }
        // -p value or --param value
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
            continue;
        }
        // value
        if (paramName == null) {
            parms.put("$" + argPos++, arg);
        } else {
            parms.put(paramName, arg);
            paramName = null;
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#end_block

#method_before
void audit(Context ctx, Object result, String cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + cmd, created, null, result));
}
#method_after
void audit(Context ctx, Object result, String cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new SshAuditEvent(sid, extractCurrentUser(ctx), cmd, created, null, result));
}
#end_block

#method_before
void audit(Context ctx, Object result, DispatchCommand cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + extractWhat(cmd), created, extractParameters(cmd), result));
}
#method_after
void audit(Context ctx, Object result, DispatchCommand cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new SshAuditEvent(sid, extractCurrentUser(ctx), extractWhat(cmd), created, extractParameters(cmd), result));
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    int status = SC_OK;
    Object result = "";
    Multimap<String, String> params = LinkedHashMultimap.create();
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    try {
        checkUserSession(req);
        List<String> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            view = rc.list();
        } else {
            String id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                view = c.list();
                break;
            } else {
                rsrc = c.parse(rsrc, path.remove(0));
                view = view(c, req.getMethod(), path);
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            result = m.apply(rsrc, parseRequest(req, m.inputType()));
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        res.setStatus(status);
        if (result instanceof BinaryResult) {
            replyBinaryResult(req, res, (BinaryResult) result);
        } else {
            replyJson(req, res, config, result);
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (InvalidMethodException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new AuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getMethod() + " " + req.getRequestURI(), auditStartTs, params, status + " " + result));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    CacheHeaders.setNotCacheable(res);
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            if ("GET".equals(req.getMethod())) {
                view = rc.list();
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                view = ac.post(rsrc);
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                checkPreconditions(req, rsrc);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                if ("GET".equals(req.getMethod())) {
                    view = c.list();
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    view = ac.post(rsrc);
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req, rsrc);
                    view = null;
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        view = ac.create(rsrc, id);
                        status = SC_CREATED;
                    } else {
                        throw e;
                    }
                }
                if (view == null) {
                    view = view(c, req.getMethod(), path);
                }
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
        } else if (result instanceof Response.Redirect) {
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (PreconditionFailedException e) {
        replyError(res, status = SC_PRECONDITION_FAILED, Objects.firstNonNull(e.getMessage(), "Precondition failed"));
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new HttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getRequestURI(), auditStartTs, params, req.getMethod(), inputRequestBody, status, result));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Class<Object> type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, InvalidMethodException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (type.getDeclaredFields().length == 0 && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (isEmptyType(type) && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
private static boolean hasNoBody(HttpServletRequest req) {
    int len = req.getContentLength();
    String type = req.getContentType();
    return (len <= 0 && type == null) || (len == 0 && isType("application/x-www-form-urlencoded", type));
}
#method_after
private static boolean hasNoBody(HttpServletRequest req) {
    int len = req.getContentLength();
    String type = req.getContentType();
    return (len <= 0 && type == null) || (len == 0 && isType(FORM_TYPE, type));
}
#end_block

#method_before
private static boolean acceptsPutInput(Class<Object> type) {
    for (Field f : type.getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            return true;
        }
    }
    return false;
}
#method_after
@SuppressWarnings("rawtypes")
private static boolean acceptsPutInput(Type type) {
    if (type instanceof Class) {
        for (Field f : ((Class) type).getDeclaredFields()) {
            if (f.getType() == PutInput.class) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private Object parsePutInput(final HttpServletRequest req, Class<Object> type) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, InvalidMethodException {
    Object obj = createInstance(type);
    for (Field f : type.getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            f.setAccessible(true);
            f.set(obj, new PutInput() {

                @Override
                public String getContentType() {
                    return req.getContentType();
                }

                @Override
                public long getContentLength() {
                    return req.getContentLength();
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return req.getInputStream();
                }
            });
            return obj;
        }
    }
    throw new InvalidMethodException();
}
#method_after
private Object parsePutInput(final HttpServletRequest req, Type type) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, MethodNotAllowedException {
    Object obj = createInstance(type);
    for (Field f : obj.getClass().getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            f.setAccessible(true);
            f.set(obj, new PutInput() {

                @Override
                public String getContentType() {
                    return req.getContentType();
                }

                @Override
                public long getContentLength() {
                    return req.getContentLength();
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return req.getInputStream();
                }
            });
            return obj;
        }
    }
    throw new MethodNotAllowedException();
}
#end_block

#method_before
private Object parseString(String value, Class<Object> type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    Object obj = createInstance(type);
    Field[] fields = type.getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#method_after
private Object parseString(String value, Type type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    if (type == String.class) {
        return value;
    }
    Object obj = createInstance(type);
    Field[] fields = obj.getClass().getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#end_block

#method_before
private static Object createInstance(Class<Object> type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<Object> c = type.getDeclaredConstructor();
    c.setAccessible(true);
    return c.newInstance();
}
#method_after
private static Object createInstance(Type type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (type instanceof Class) {
        @SuppressWarnings("unchecked")
        Class<Object> clazz = (Class<Object>) type;
        Constructor<Object> c = clazz.getDeclaredConstructor();
        c.setAccessible(true);
        return c.newInstance();
    }
    throw new InstantiationException("Cannot make " + type);
}
#end_block

#method_before
private static void replyJson(HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8));
}
#method_after
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePrettyPrint(GsonBuilder gb, Multimap<String, String> config, HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#method_after
private static void enablePrettyPrint(GsonBuilder gb, Multimap<String, String> config, @Nullable HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null && req != null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#end_block

#method_before
private static void replyBinaryResult(HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                res.setContentLength((int) buf.length());
                res.setHeader("Content-Encoding", "gzip");
                buf.writeTo(dst, null);
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                if (0 <= len && len < Integer.MAX_VALUE) {
                    res.setContentLength((int) len);
                } else if (0 <= len) {
                    res.setHeader("Content-Length", Long.toString(len));
                }
                bin.writeTo(dst);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#method_after
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                if (buf.length() < len) {
                    res.setContentLength((int) buf.length());
                    res.setHeader("Content-Encoding", "gzip");
                    buf.writeTo(dst, null);
                } else {
                    replyUncompressed(res, dst, bin, len);
                }
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                replyUncompressed(res, dst, bin, len);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#end_block

#method_before
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<String> path) throws ResourceNotFoundException, InvalidMethodException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final String projection = path.isEmpty() ? "/" : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private static List<String> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<String> out = Lists.newArrayList(Splitter.on('/').split(path));
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#method_after
private static List<IdString> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<IdString> out = Lists.newArrayList();
    for (String p : Splitter.on('/').split(path)) {
        out.add(IdString.fromUrl(p));
    }
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#end_block

#method_before
private static List<String> splitProjection(String projection) {
    return Lists.newArrayList(Splitter.on('~').limit(2).split(projection));
}
#method_after
private static List<String> splitProjection(IdString projection) {
    List<String> p = Lists.newArrayListWithCapacity(2);
    Iterables.addAll(p, Splitter.on('~').limit(2).split(projection.get()));
    return p;
}
#end_block

#method_before
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if (!text.endsWith("\n")) {
        text += "\n";
    }
    replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
}
#method_after
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#end_block

#method_before
private static boolean acceptsJson(HttpServletRequest req) {
    return req != null && isType(JSON_TYPE, req.getHeader("Accept"));
}
#method_after
private static boolean acceptsJson(HttpServletRequest req) {
    return req != null && isType(JSON_TYPE, req.getHeader(HttpHeaders.ACCEPT));
}
#end_block

#method_before
private static boolean acceptsGzip(HttpServletRequest req) {
    return req != null && RPCServletUtils.acceptsGzipEncoding(req);
}
#method_after
private static boolean acceptsGzip(HttpServletRequest req) {
    if (req != null) {
        String accepts = req.getHeader(HttpHeaders.ACCEPT_ENCODING);
        return accepts != null && accepts.indexOf("gzip") != -1;
    }
    return false;
}
#end_block

#method_before
@Override
protected GerritCall createActiveCall(final HttpServletRequest req, final HttpServletResponse rsp) {
    final GerritCall call = new GerritCall(session.get(), req, rsp);
    currentCall.set(call);
    return call;
}
#method_after
@Override
protected GerritCall createActiveCall(final HttpServletRequest req, final HttpServletResponse rsp) {
    final GerritCall call = new GerritCall(session.get(), req, new AuditedHttpServletResponse(rsp));
    currentCall.set(call);
    return call;
}
#end_block

#method_before
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = (Audit) method.getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getSessionId();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final Multimap<String, ?> args = extractParams(note, call);
            final String what = extractWhat(note, method.getName());
            final Object result = call.getResult();
            audit.dispatch(new AuditEvent(sid, username, what, call.getWhen(), args, result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#method_after
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = (Audit) method.getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getSessionId();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final Multimap<String, ?> args = extractParams(note, call);
            final String what = extractWhat(note, call);
            final Object result = call.getResult();
            audit.dispatch(new RpcAuditEvent(sid, username, what, call.getWhen(), args, call.getHttpServletRequest().getMethod(), call.getHttpServletRequest().getMethod(), ((AuditedHttpServletResponse) (call.getHttpServletResponse())).getStatus(), result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#end_block

#method_before
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (ccase && !Character.isLowerCase(c)) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#method_after
private String extractWhat(final Audit note, final GerritCall call) {
    String methodClass = call.getMethodClass().getName();
    methodClass = methodClass.substring(methodClass.lastIndexOf(".") + 1);
    String what = note.action();
    if (what.length() == 0) {
        what = call.getMethod().getName();
    }
    return methodClass + "." + what;
}
#end_block

#method_before
@Override
public boolean xsrfValidate() {
    final String keyIn = getXsrfKeyIn();
    if (keyIn == null || "".equals(keyIn)) {
        // 
        return !session.isSignedIn();
    } else {
        // 
        return session.isSignedIn() && session.isValidAuthorization(keyIn);
    }
}
#method_after
@Override
public boolean xsrfValidate() {
    final String keyIn = getXsrfKeyIn();
    if (keyIn == null || "".equals(keyIn)) {
        // 
        return !session.isSignedIn();
    } else if (session.isSignedIn() && session.isValidAuthorization(keyIn)) {
        // The session must exist, and must be using this token.
        // 
        session.getCurrentUser().setAccessPath(AccessPath.JSON_RPC);
        return true;
    }
    return false;
}
#end_block

#method_before
public void setReviewedByCurrentUser(boolean reviewed) {
    if (fileList != null) {
        fileList.updateReviewedStatus(patchKey, reviewed);
    }
    MarkReviewedInput in = MarkReviewedInput.create();
    in.reviewed(reviewed);
    PatchSet.Id ps = patchKey.getParentKey();
    new RestApi("/changes/").id(ps.getParentKey().get()).view("revisions").id(ps.get()).view("files").id(patchKey.getFileName()).view("reviewed").post(in, new AsyncCallback<VoidResult>() {

        @Override
        public void onFailure(Throwable arg0) {
        // nop
        }

        @Override
        public void onSuccess(VoidResult result) {
        // nop
        }
    });
}
#method_after
public void setReviewedByCurrentUser(boolean reviewed) {
    if (fileList != null) {
        fileList.updateReviewedStatus(patchKey, reviewed);
    }
    PatchSet.Id ps = patchKey.getParentKey();
    RestApi api = new RestApi("/changes/").id(ps.getParentKey().get()).view("revisions").id(ps.get()).view("files").id(patchKey.getFileName()).view("reviewed");
    AsyncCallback<VoidResult> cb = new AsyncCallback<VoidResult>() {

        @Override
        public void onFailure(Throwable arg0) {
        // nop
        }

        @Override
        public void onSuccess(VoidResult result) {
        // nop
        }
    };
    if (reviewed) {
        api.put(cb);
    } else {
        api.delete(cb);
    }
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    post(PATCH_KIND, "reviewed").to(MarkReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Patches.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    put(PATCH_KIND, "reviewed").to(PutReviewed.class);
    delete(PATCH_KIND, "reviewed").to(DeleteReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#end_block

#method_before
public List<CommitValidationMessage> validCommit(ReceiveCommand cmd, RevCommit commit) throws CommitValidationException {
    HashMap<Pattern, ItsAssociationPolicy> regexes = getCommentRegexMap();
    if (regexes.size() == 0) {
        return Collections.emptyList();
    }
    String comment = commit.getFullMessage();
    log.debug("Searching comment " + comment.trim() + " for patterns " + regexes);
    String issueId = null;
    ItsAssociationPolicy associationPolicy = ItsAssociationPolicy.OPTIONAL;
    Pattern pattern = null;
    for (Entry<Pattern, ItsAssociationPolicy> entry : regexes.entrySet()) {
        pattern = entry.getKey();
        Matcher matcher = pattern.matcher(comment);
        associationPolicy = entry.getValue();
        if (matcher.find()) {
            issueId = extractMatchedWorkItems(matcher);
            log.debug("Pattern matched on comment '{}' with issue id '{}'", comment.trim(), issueId);
            break;
        }
    }
    String validationMessage = null;
    if (pattern != null && issueId == null) {
        validationMessage = "Missing issue-id in commit message\n" + "Commit " + commit.getId().getName() + " not associated to any issue\n" + "\n" + "Hint: insert one ore more issue-id anywhere in the commit message.\n" + "      Issue-ids are strings matching " + pattern.pattern() + "\n" + "      and are pointing to existing tickets on " + client.name() + " Issue-Tracker";
    } else if (pattern != null && !isWorkitemPresent(issueId, comment)) {
        validationMessage = "Issue " + issueId + " not found or visible in " + client.name() + " Issue-Tracker";
    } else {
        return Collections.emptyList();
    }
    switch(associationPolicy) {
        case MANDATORY:
            throw new CommitValidationException(validationMessage.split("\n")[0], Collections.singletonList(new CommitValidationMessage("\n" + validationMessage + "\n", false)));
        case SUGGESTED:
            return Collections.singletonList(new CommitValidationMessage("\n" + validationMessage + "\n", false));
        default:
            return Collections.emptyList();
    }
}
#method_after
public List<CommitValidationMessage> validCommit(ReceiveCommand cmd, RevCommit commit) throws CommitValidationException {
    HashMap<Pattern, ItsAssociationPolicy> regexes = getCommentRegexMap();
    if (regexes.size() == 0) {
        return Collections.emptyList();
    }
    String message = commit.getFullMessage();
    log.debug("Searching comment " + message.trim() + " for patterns " + regexes);
    String issueId = null;
    ItsAssociationPolicy associationPolicy = ItsAssociationPolicy.OPTIONAL;
    Pattern pattern = null;
    for (Entry<Pattern, ItsAssociationPolicy> entry : regexes.entrySet()) {
        pattern = entry.getKey();
        Matcher matcher = pattern.matcher(message);
        associationPolicy = entry.getValue();
        if (matcher.find()) {
            issueId = extractMatchedWorkItems(matcher);
            log.debug("Pattern matched on comment '{}' with issue id '{}'", message.trim(), issueId);
            break;
        }
    }
    String validationMessage = null;
    if (pattern != null && issueId == null) {
        validationMessage = "Missing issue-id in commit message\n" + "Commit " + commit.getId().getName() + " not associated to any issue\n" + "\n" + "Hint: insert one or more issue-id anywhere in the commit message.\n" + "      Issue-ids are strings matching " + pattern.pattern() + "\n" + "      and are pointing to existing tickets on " + client.name() + " Issue-Tracker";
    } else if (pattern != null && !isWorkitemPresent(issueId, message)) {
        validationMessage = "Issue " + issueId + " not found or visible in " + client.name() + " Issue-Tracker";
    } else {
        return Collections.emptyList();
    }
    switch(associationPolicy) {
        case MANDATORY:
            throw new CommitValidationException(validationMessage.split("\n")[0], Collections.singletonList(new CommitValidationMessage("\n" + validationMessage + "\n", false)));
        case SUGGESTED:
            return Collections.singletonList(new CommitValidationMessage("\n" + validationMessage + "\n", false));
        default:
            return Collections.emptyList();
    }
}
#end_block

#method_before
private boolean isWorkitemPresent(String issueId, String comment) {
    boolean exist = false;
    if (issueId != null) {
        try {
            ItsIssue issue = client.getIssue(issueId);
            if (issue == null) {
                log.warn("Workitem " + issueId + " declared in the comment " + comment + " but not found on ITS");
            } else {
                exist = true;
                log.warn("Workitem found: " + issue);
            }
        } catch (IOException ex) {
            log.warn("Unexpected error accessint ITS", ex);
        }
    } else {
        log.debug("Rejecting commit: no pattern matched on comment " + comment);
    }
    return exist;
}
#method_after
private boolean isWorkitemPresent(String issueId, String comment) {
    boolean exist = false;
    if (issueId != null) {
        try {
            if (!client.exists(issueId)) {
                log.warn("Workitem " + issueId + " declared in the comment " + comment + " but not found on ITS");
            } else {
                exist = true;
                log.warn("Workitem " + issueId + " found");
            }
        } catch (IOException ex) {
            log.warn("Unexpected error accessint ITS", ex);
        }
    } else {
        log.debug("Rejecting commit: no pattern matched on comment " + comment);
    }
    return exist;
}
#end_block

#method_before
@Override
public void addComment(String issueId, String comment) throws IOException {
    if (log.isDebugEnabled())
        log.debug("addComment({},{})", issueId, comment);
}
#method_after
@Override
public void addComment(String issueId, String comment) throws IOException {
    if (log.isDebugEnabled()) {
        log.debug("addComment({},{})", issueId, comment);
    }
}
#end_block

#method_before
@Override
public void addRelatedLink(String issueId, URL relatedUrl, String description) throws IOException {
    if (log.isDebugEnabled())
        log.debug("addRelatedLink({},{},{})", new Object[] { issueId, relatedUrl, description });
}
#method_after
@Override
public void addRelatedLink(String issueId, URL relatedUrl, String description) throws IOException {
    if (log.isDebugEnabled()) {
        log.debug("addRelatedLink({},{},{})", new Object[] { issueId, relatedUrl, description });
    }
}
#end_block

#method_before
@Override
public void performAction(String issueId, String actionName) throws IOException {
    if (log.isDebugEnabled())
        log.debug("performAction({},{})", issueId, actionName);
}
#method_after
@Override
public void performAction(String issueId, String actionName) throws IOException {
    if (log.isDebugEnabled()) {
        log.debug("performAction({},{})", issueId, actionName);
    }
}
#end_block

#method_before
@Override
public String healthCheck(Check check) throws IOException {
    if (log.isDebugEnabled())
        log.debug("healthCheck()");
    return "{\"status\"=\"ok\",\"system\"=\"not configured\",}";
}
#method_after
@Override
public String healthCheck(Check check) throws IOException {
    if (log.isDebugEnabled()) {
        log.debug("healthCheck()");
    }
    return "{\"status\"=\"ok\",\"system\"=\"not configured\",}";
}
#end_block

#method_before
@Override
public String createLinkForWebui(String url, String text) {
    if (log.isDebugEnabled())
        log.debug("createLinkForWebui({},{})", url, text);
    return "";
}
#method_after
@Override
public String createLinkForWebui(String url, String text) {
    if (log.isDebugEnabled()) {
        log.debug("createLinkForWebui({},{})", url, text);
    }
    return "";
}
#end_block

#method_before
private void add(Watchers matching, NotifyConfig nc, Project.NameKey project) throws OrmException, QueryParseException {
    for (GroupReference ref : nc.getGroups()) {
        CurrentUser user = new SingleGroupUser(args.capabilityControlFactory, ref.getUUID());
        if (filterMatch(user, nc.getFilter())) {
            deliverToMembers(matching.list(nc.getHeader()), ref.getUUID());
        }
    }
    if (!nc.getAddresses().isEmpty()) {
        if (filterMatch(args.anonymousUser, nc.getFilter())) {
            matching.list(nc.getHeader()).emails.addAll(nc.getAddresses());
        }
    }
}
#method_after
private void add(Watchers matching, NotifyConfig nc, Project.NameKey project) throws OrmException, QueryParseException {
    for (GroupReference ref : nc.getGroups()) {
        CurrentUser user = new SingleGroupUser(args.capabilityControlFactory, ref.getUUID());
        if (filterMatch(user, nc.getFilter())) {
            deliverToMembers(matching.list(nc.getHeader()), ref.getUUID());
        }
    }
    if (!nc.getAddresses().isEmpty()) {
        if (filterMatch(null, nc.getFilter())) {
            matching.list(nc.getHeader()).emails.addAll(nc.getAddresses());
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private boolean filterMatch(CurrentUser user, String filter) throws OrmException, QueryParseException {
    ChangeQueryBuilder qb = args.queryBuilder.create(user);
    Predicate<ChangeData> p = null;
    if (!(user instanceof AnonymousUser)) {
        p = qb.is_visible();
    }
    if (filter != null) {
        qb.setAllowFile(true);
        Predicate<ChangeData> filterPredicate = qb.parse(filter);
        if (p == null) {
            p = filterPredicate;
        } else {
            p = Predicate.and(filterPredicate, p);
        }
        p = args.queryRewriter.get().rewrite(p);
    }
    return p == null ? true : p.match(changeData);
}
#method_after
@SuppressWarnings("unchecked")
private boolean filterMatch(CurrentUser user, String filter) throws OrmException, QueryParseException {
    ChangeQueryBuilder qb;
    Predicate<ChangeData> p = null;
    if (user == null) {
        qb = args.queryBuilder.create(args.anonymousUser);
    } else {
        qb = args.queryBuilder.create(user);
        p = qb.is_visible();
    }
    if (filter != null) {
        qb.setAllowFile(true);
        Predicate<ChangeData> filterPredicate = qb.parse(filter);
        if (p == null) {
            p = filterPredicate;
        } else {
            p = Predicate.and(filterPredicate, p);
        }
        p = args.queryRewriter.get().rewrite(p);
    }
    return p == null ? true : p.match(changeData);
}
#end_block

#method_before
@Override
protected Watchers getWatchers(NotifyType type) throws OrmException {
    ProjectWatch watch = new ProjectWatch(args, project, projectState, changeData);
    return watch.getWatchers(type);
}
#method_after
@Override
protected final Watchers getWatchers(NotifyType type) throws OrmException {
    ProjectWatch watch = new ProjectWatch(args, project, projectState, changeData);
    return watch.getWatchers(type);
}
#end_block

#method_before
public static void removeMembers(AccountGroup.UUID groupUUID, Set<Account.Id> ids, AsyncCallback<VoidResult> cb) {
    RestApi call = new RestApi(membersBase(groupUUID));
    MemberInput input = MemberInput.create();
    for (Account.Id id : ids) {
        input.add_member(Integer.toString(id.get()));
    }
    call.data(input).delete(cb);
}
#method_after
public static void removeMembers(AccountGroup.UUID groupUUID, Set<Account.Id> ids, AsyncCallback<VoidResult> cb) {
    RestApi call = new RestApi(membersBase(groupUUID));
    MemberInput input = MemberInput.create();
    for (Account.Id id : ids) {
        input.add_member(id.toString());
    }
    call.data(input).delete(cb);
}
#end_block

#method_before
void doAddNewMember() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    GroupApi.addMembers(getGroupUUID(), Collections.singleton(nameEmail), new GerritCallback<NativeList<MemberInfo>>() {

        public void onSuccess(final NativeList<MemberInfo> memberInfo) {
            Gerrit.display(Dispatcher.toGroup(getGroupUUID(), AccountGroupScreen.MEMBERS));
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
void doAddNewMember() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    GroupApi.addMember(getGroupUUID(), nameEmail, new GerritCallback<MemberInfo>() {

        public void onSuccess(final MemberInfo memberInfo) {
            Gerrit.display(Dispatcher.toGroup(getGroupUUID(), AccountGroupScreen.MEMBERS));
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(GROUP_KIND, "members").to(PutMember.class);
    delete(GROUP_KIND, "members").to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(GROUP_KIND, "members").to(PutMembers.class);
    delete(GROUP_KIND, "members").to(DeleteMembers.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    Account account = getUserAccount();
    final CurrentUserPopupPanel userPopup = new CurrentUserPopupPanel(account, canLogOut);
    final String name = FormatUtil.name(account);
    String[] names = name.split("\\s+", 2);
    final InlineLabel l = new InlineLabel(names[0] + " ");
    l.setStyleName(RESOURCES.css().menuBarUserName());
    l.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (userPopup.isShowing()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(l);
            }
        }
    });
    userPopup.addAutoHidePartner(l.getElement());
    menuRight.add(l);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    Account account = getUserAccount();
    final CurrentUserPopupPanel userPopup = new CurrentUserPopupPanel(account, canLogOut);
    final InlineLabel l = new InlineLabel(FormatUtil.name(account) + " ");
    l.setStyleName(RESOURCES.css().menuBarUserName());
    l.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (userPopup.isShowing()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(l);
            }
        }
    });
    userPopup.addAutoHidePartner(l.getElement());
    FocusPanel fp = new FocusPanel(l);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                if (userPopup.isShowing()) {
                    userPopup.hide();
                } else {
                    userPopup.showRelativeTo(l);
                }
                event.preventDefault();
            }
        }
    });
    menuRight.add(fp);
}
#end_block

#method_before
public JsonElement display(OutputStream displayOutputStream) throws NoSuchGroupException {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    try {
        List<GroupInfo> groups;
        if (user != null) {
            groups = accountGetGroups.get().apply(new AccountResource(userFactory.create(user)));
        } else {
            VisibleGroups visibleGroups = visibleGroupsFactory.create();
            visibleGroups.setOnlyVisibleToAll(visibleToAll);
            visibleGroups.setGroupType(groupType);
            visibleGroups.setMatch(matchSubstring);
            List<AccountGroup> groupList;
            if (!projects.isEmpty()) {
                groupList = visibleGroups.get(projects);
            } else {
                groupList = visibleGroups.get();
            }
            groups = Lists.newArrayListWithCapacity(groupList.size());
            for (AccountGroup group : groupList) {
                groups.add(new GroupInfo(GroupDescriptions.forAccountGroup(group)));
            }
        }
        if (stdout == null) {
            final Map<String, GroupInfo> output = Maps.newTreeMap();
            for (GroupInfo info : groups) {
                output.put(Objects.firstNonNull(info.name, "Group " + info.id), info);
                info.name = null;
            }
            return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, GroupInfo>>() {
            }.getType());
        } else {
            final ColumnFormatter formatter = new ColumnFormatter(stdout, '\t');
            for (GroupInfo info : groups) {
                formatter.addColumn(info.name);
                if (verboseOutput) {
                    formatter.addColumn(info.id);
                    formatter.addColumn(Strings.nullToEmpty(info.description));
                    formatter.addColumn(Objects.firstNonNull(info.ownerId, "n/a"));
                    formatter.addColumn(Boolean.toString(Objects.firstNonNull(info.visibleToAll, Boolean.FALSE)));
                }
                formatter.nextLine();
            }
            formatter.finish();
            return null;
        }
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public JsonElement display(OutputStream displayOutputStream) throws NoSuchGroupException {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    try {
        List<GroupInfo> groups;
        if (user != null) {
            groups = accountGetGroups.get().apply(new AccountResource(userFactory.create(user)));
        } else {
            VisibleGroups visibleGroups = visibleGroupsFactory.create();
            visibleGroups.setOnlyVisibleToAll(visibleToAll);
            visibleGroups.setGroupType(groupType);
            visibleGroups.setMatch(matchSubstring);
            List<AccountGroup> groupList;
            if (!projects.isEmpty()) {
                groupList = visibleGroups.get(projects);
            } else {
                groupList = visibleGroups.get();
            }
            groups = Lists.newArrayListWithCapacity(groupList.size());
            for (AccountGroup group : groupList) {
                groups.add(new GroupInfo(GroupDescriptions.forAccountGroup(group)));
            }
        }
        if (stdout == null) {
            final Map<String, GroupInfo> output = Maps.newTreeMap();
            for (GroupInfo info : groups) {
                output.put(Objects.firstNonNull(info.name, "Group " + Url.decode(info.id)), info);
                info.name = null;
            }
            return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, GroupInfo>>() {
            }.getType());
        } else {
            final ColumnFormatter formatter = new ColumnFormatter(stdout, '\t');
            for (GroupInfo info : groups) {
                formatter.addColumn(info.name);
                if (verboseOutput) {
                    AccountGroup o = info.ownerId != null ? groupCache.get(new AccountGroup.UUID(Url.decode(info.ownerId))) : null;
                    formatter.addColumn(Url.decode(info.id));
                    formatter.addColumn(Strings.nullToEmpty(info.description));
                    formatter.addColumn(o != null ? o.getName() : "n/a");
                    formatter.addColumn(o != null ? o.getGroupUUID().get() : "");
                    formatter.addColumn(Boolean.toString(Objects.firstNonNull(info.visibleToAll, Boolean.FALSE)));
                }
                formatter.nextLine();
            }
            formatter.finish();
            return null;
        }
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    return Lists.newLinkedList(getMembers(resource.getGroupUUID(), recursive, new HashSet<AccountGroup.UUID>()).values());
}
#method_after
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final Map<Account.Id, MemberInfo> members = getMembers(resource.getGroupUUID(), new HashSet<AccountGroup.UUID>());
    return Lists.newArrayList(members.values());
}
#end_block

#method_before
private Map<Account.Id, MemberInfo> getMembers(final AccountGroup.UUID groupUUID, final boolean recursive, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException, NoSuchGroupException {
    seenGroups.add(groupUUID);
    final Map<Account.Id, MemberInfo> members = Maps.newHashMap();
    final AccountGroup group = groupCache.get(groupUUID);
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            final Account account = accountCache.get(member.getAccountId()).getAccount();
            members.put(account.getId(), MembersCollection.parse(account));
        }
    }
    if (recursive) {
        if (groupDetail.includes != null) {
            for (final AccountGroupIncludeByUuid includedGroup : groupDetail.includes) {
                if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                    members.putAll(getMembers(includedGroup.getIncludeUUID(), recursive, seenGroups));
                }
            }
        }
    }
    return members;
}
#method_after
private Map<Account.Id, MemberInfo> getMembers(final AccountGroup.UUID groupUUID, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException, NoSuchGroupException {
    seenGroups.add(groupUUID);
    final Map<Account.Id, MemberInfo> members = Maps.newHashMap();
    final AccountGroup group = groupCache.get(groupUUID);
    if (group == null) {
        // the included group is an external group and can't be resolved
        return Collections.emptyMap();
    }
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember m : groupDetail.members) {
            if (!members.containsKey(m.getAccountId())) {
                final Account account = accountCache.get(m.getAccountId()).getAccount();
                members.put(account.getId(), MembersCollection.parse(account));
            }
        }
    }
    if (recursive) {
        if (groupDetail.includes != null) {
            for (final AccountGroupIncludeByUuid includedGroup : groupDetail.includes) {
                if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                    members.putAll(getMembers(includedGroup.getIncludeUUID(), seenGroups));
                }
            }
        }
    }
    return members;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    AvatarProvider avatarProvider = avatarProviderItem.get();
    if (avatarProvider == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    String user = req.getPathInfo();
    if (user == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    // Hack off leading '/'
    user = user.substring(1);
    final Account account;
    try {
        account = accountResolver.find(user);
    } catch (OrmException e1) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    String size = req.getParameter("size");
    int imageSize = 0;
    if (size != null) {
        try {
            imageSize = Integer.parseInt(size);
        } catch (NumberFormatException e) {
        // Ignore, keep size at 0.
        }
    }
    final String url = avatarProvider.getUrl(account, imageSize);
    rsp.sendRedirect(rsp.encodeRedirectURL(url));
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    AvatarProvider avatarProvider = avatarProviderItem.get();
    if (avatarProvider == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    String user = req.getPathInfo();
    if (user == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    // Hack off leading '/'
    user = user.substring(1);
    final Account account;
    try {
        account = accountResolver.find(user);
    } catch (OrmException e1) {
        log.error("Exception while looking up avatar for user: " + user, e1);
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    if (account == null) {
        // Account was not found.
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    String size = req.getParameter("size");
    int imageSize = 0;
    if (size != null) {
        try {
            imageSize = Integer.parseInt(size);
        } catch (NumberFormatException e) {
        // Ignore, keep size at 0.
        }
    }
    final String url = avatarProvider.getUrl(account, imageSize);
    if (url == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else {
        rsp.sendRedirect(rsp.encodeRedirectURL(url));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(NotesBranchUtil.Factory.class);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/avatar/*").with(AvatarServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/avatar/*").with(AvatarServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#end_block

#method_before
private Key<HttpServlet> queryProjectNew() {
    return key(new HttpServlet() {

        private static final long serialVersionUID = 1L;

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            String name = req.getPathInfo();
            if (Strings.isNullOrEmpty(name)) {
                toGerrit(PageLinks.ADMIN_PROJECTS, req, rsp);
                return;
            }
            while (name.endsWith("/")) {
                name = name.substring(0, name.length() - 1);
            }
            if (name.endsWith(".git")) {
                name = name.substring(0, name.length() - 4);
            }
            while (name.endsWith("/")) {
                name = name.substring(0, name.length() - 1);
            }
            Project.NameKey project = new Project.NameKey(name);
            toGerrit(PageLinks.toChangeQuery(PageLinks.projectQuery(project, Change.Status.NEW)), req, rsp);
        }
    });
}
#method_after
private Key<HttpServlet> queryProjectNew() {
    return key(new HttpServlet() {

        private static final long serialVersionUID = 1L;

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            String name = req.getPathInfo();
            if (Strings.isNullOrEmpty(name)) {
                toGerrit(PageLinks.ADMIN_PROJECTS, req, rsp);
                return;
            }
            while (name.endsWith("/")) {
                name = name.substring(0, name.length() - 1);
            }
            if (name.endsWith(Constants.DOT_GIT_EXT)) {
                name = // 
                name.substring(// 
                0, name.length() - Constants.DOT_GIT_EXT.length());
            }
            while (name.endsWith("/")) {
                name = name.substring(0, name.length() - 1);
            }
            Project.NameKey project = new Project.NameKey(name);
            toGerrit(PageLinks.toChangeQuery(PageLinks.projectQuery(project, Change.Status.NEW)), req, rsp);
        }
    });
}
#end_block

#method_before
public DynamicItem<T> get() {
    return new DynamicItem<T>(find(injector, type));
}
#method_after
public DynamicItem<T> get() {
    return new DynamicItem<T>(key, find(injector, type), "gerrit");
}
#end_block

#method_before
private static <T> AtomicReference<Provider<T>> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null) {
        for (Binding<T> b : bindings) {
            if (b.getKey().getAnnotation() != null) {
                // TODO: throw exception if > 1 match?
                return new AtomicReference<Provider<T>>(b.getProvider());
            }
        }
    }
    return new AtomicReference<Provider<T>>();
}
#method_after
private static <T> Provider<T> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null && bindings.size() == 1) {
        return bindings.get(0).getProvider();
    } else if (bindings != null && bindings.size() > 1) {
        throw new ProvisionException(String.format("Multiple providers bound for DynamicItem<%s>\n" + "This is not allowed; check the server configuration.", type));
    } else {
        return null;
    }
}
#end_block

#method_before
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider()));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#method_after
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items, String pluginName) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider(), pluginName));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#end_block

#method_before
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member)).in(Scopes.SINGLETON);
}
#method_after
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member, key)).in(Scopes.SINGLETON);
}
#end_block

#method_before
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type).annotatedWith(UniqueAnnotations.create());
}
#method_after
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type);
}
#end_block

#method_before
public T get() {
    Provider<T> p = item.get();
    T t = null;
    if (p != null) {
        t = p.get();
    }
    return t;
}
#method_after
public T get() {
    NamedProvider<T> item = ref.get();
    return item != null ? item.impl.get() : null;
}
#end_block

#method_before
public ReloadableRegistrationHandle<T> set(Key<T> key, Provider<T> item) {
    if (!this.item.compareAndSet(null, item)) {
        // We already have an item bound.
        throw new RuntimeException("Type already provided by " + this.item.get());
    }
    return new ReloadableHandle(key, item);
}
#method_after
public RegistrationHandle set(T item, String pluginName) {
    return set(Providers.of(item), pluginName);
}
#end_block

#method_before
@Override
public void remove() {
    DynamicItem.this.item.compareAndSet(item, null);
}
#method_after
@Override
public void remove() {
    ref.compareAndSet(item, null);
}
#end_block

#method_before
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    if (DynamicItem.this.item.compareAndSet(item, newItem)) {
        return new ReloadableHandle(newKey, newItem);
    }
    return null;
}
#method_after
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    NamedProvider<T> n = new NamedProvider<T>(newItem, item.pluginName);
    if (ref.compareAndSet(item, n)) {
        return new ReloadableHandle(newKey, n);
    }
    return null;
}
#end_block

#method_before
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items)) {
        plugin.add(h);
    }
}
#method_after
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items, plugin.getName())) {
        plugin.add(h);
    }
}
#end_block

#method_before
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        // Index all old handles that match this DynamicItem<T> keyed by
        // annotations. Ignore the unique annotations, thereby favoring
        // the @Named annotations or some other non-unique naming.
        Map<Annotation, ReloadableRegistrationHandle<?>> am = Maps.newHashMap();
        List<ReloadableRegistrationHandle<?>> old = oldHandles.get(type);
        Iterator<ReloadableRegistrationHandle<?>> oi = old.iterator();
        while (oi.hasNext()) {
            ReloadableRegistrationHandle<?> h = oi.next();
            Annotation a = h.getKey().getAnnotation();
            if (a != null && !UNIQUE_ANNOTATION.isInstance(a)) {
                am.put(a, h);
                oi.remove();
            }
        }
        // Replace old handles with new bindings, favoring cases where there
        // is an exact match on an @Named annotation. If there is no match
        // pick any handle and replace it. We generally expect only one
        // handle of each DynamicItem type when using unique annotations, but
        // possibly multiple ones if @Named was used. Plugin authors that want
        // atomic replacement across reloads should use @Named annotations with
        // stable names that do not change across plugin versions to ensure the
        // handles are swapped correctly.
        oi = old.iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            Key<Object> key = b.getKey();
            if (key.getAnnotation() == null) {
                continue;
            }
            @SuppressWarnings("unchecked")
            ReloadableRegistrationHandle<Object> h1 = (ReloadableRegistrationHandle<Object>) am.remove(key.getAnnotation());
            if (h1 != null) {
                replace(newPlugin, h1, b);
            } else if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h2 = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h2, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider()));
            }
        }
    }
}
#method_after
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        Iterator<ReloadableRegistrationHandle<?>> oi = oldHandles.get(type).iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider(), newPlugin.getName()));
            }
        }
    }
}
#end_block

#method_before
@Override
public MemberResource parse(final GroupResource parent, final String id) throws ResourceNotFoundException, Exception {
    final String decodedId = Url.decode(id);
    if (decodedId.startsWith(GROUP_PREFIX)) {
        final String groupId = decodedId.substring(GROUP_PREFIX.length());
        final GroupControl ctl;
        try {
            if (groupId.startsWith(GroupsCollection.UUID_PREFIX)) {
                final String uuid = groupId.substring(GroupsCollection.UUID_PREFIX.length());
                ctl = groupControlFactory.controlFor(new AccountGroup.UUID(uuid));
            } else {
                try {
                    ctl = groupControlFactory.controlFor(new AccountGroup.Id(Integer.parseInt(groupId)));
                } catch (NumberFormatException e) {
                    throw new ResourceNotFoundException(id);
                }
            }
        } catch (NoSuchGroupException e) {
            throw new ResourceNotFoundException(id);
        }
        if (!ctl.isVisible() && !ctl.isOwner()) {
            throw new ResourceNotFoundException(id);
        }
        return new MemberResource(ctl);
    } else if (decodedId.startsWith(ACCOUNT_PREFIX)) {
        final String accountId = decodedId.substring(ACCOUNT_PREFIX.length());
        try {
            final IdentifiedUser u = userGenericFactory.create(new Account.Id(Integer.parseInt(accountId)));
            return new MemberResource(u);
        } catch (NumberFormatException e) {
            throw new ResourceNotFoundException(id);
        }
    } else {
        throw new ResourceNotFoundException(id);
    }
}
#method_after
@Override
public MemberResource parse(final GroupResource parent, final String id) throws ResourceNotFoundException, Exception {
    final Account.Id accountId;
    try {
        accountId = new Account.Id(Integer.parseInt(Url.decode(id)));
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
    final AccountGroup group = groupCache.get(parent.getControl().getGroup().getGroupUUID());
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            if (member.getAccountId().equals(accountId)) {
                return new MemberResource(userGenericFactory.create(accountId));
            }
        }
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
public MemberResource parse(final GroupResource parent, final String id) throws ResourceNotFoundException, Exception {
    final String decodedId = Url.decode(id);
    if (decodedId.startsWith(GROUP_PREFIX)) {
        final String groupId = decodedId.substring(GROUP_PREFIX.length());
        final GroupControl ctl;
        try {
            if (groupId.startsWith(GroupsCollection.UUID_PREFIX)) {
                final String uuid = groupId.substring(GroupsCollection.UUID_PREFIX.length());
                ctl = groupControlFactory.controlFor(new AccountGroup.UUID(uuid));
            } else {
                try {
                    ctl = groupControlFactory.controlFor(new AccountGroup.Id(Integer.parseInt(groupId)));
                } catch (NumberFormatException e) {
                    throw new ResourceNotFoundException(id);
                }
            }
        } catch (NoSuchGroupException e) {
            throw new ResourceNotFoundException(id);
        }
        if (!ctl.isVisible() && !ctl.isOwner()) {
            throw new ResourceNotFoundException(id);
        }
        return new MemberResource(ctl);
    } else if (decodedId.startsWith(ACCOUNT_PREFIX)) {
        final String accountId = decodedId.substring(ACCOUNT_PREFIX.length());
        try {
            final IdentifiedUser u = userGenericFactory.create(new Account.Id(Integer.parseInt(accountId)));
            return new MemberResource(u);
        } catch (NumberFormatException e) {
            throw new ResourceNotFoundException(id);
        }
    } else {
        throw new ResourceNotFoundException(id);
    }
}
#method_after
public static MemberInfo parse(final Account account) {
    final MemberInfo accountInfo = new MemberInfo();
    accountInfo.setId(account.getId());
    accountInfo.fullName = account.getFullName();
    accountInfo.preferredEmail = account.getPreferredEmail();
    accountInfo.userName = account.getUserName();
    return accountInfo;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
}
#end_block

#method_before
@Override
public Object apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final List<MemberInfo> members = Lists.newArrayList();
    final GroupControl groupControl = groupControlFactory.validateFor(resource.getGroupUUID());
    final AccountGroup group = groupCache.get(groupControl.getGroup().getGroupUUID());
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            final Account account = accountCache.get(member.getAccountId()).getAccount();
            final AccountInfo accountInfo = new AccountInfo();
            accountInfo.setId(account.getId());
            accountInfo.fullName = account.getFullName();
            accountInfo.email = account.getPreferredEmail();
            accountInfo.userName = account.getUserName();
            members.add(accountInfo);
        }
    }
    if (groupDetail.includes != null) {
        for (final AccountGroupInclude groupInclude : groupDetail.includes) {
            final AccountGroup includedGroup = groupCache.get(groupInclude.getIncludeId());
            final GroupInfo groupInfo = new GroupInfo();
            groupInfo.setUuid(includedGroup.getGroupUUID());
            groupInfo.groupId = includedGroup.getId().get();
            groupInfo.name = includedGroup.getName();
            groupInfo.description = includedGroup.getDescription();
            groupInfo.isVisibleToAll = includedGroup.isVisibleToAll();
            groupInfo.ownerUuid = includedGroup.getOwnerGroupUUID().get();
            members.add(groupInfo);
        }
    }
    return members;
}
#method_after
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final List<MemberInfo> members = Lists.newArrayList();
    final GroupControl groupControl = groupControlFactory.validateFor(resource.getGroupUUID());
    final AccountGroup group = groupCache.get(groupControl.getGroup().getGroupUUID());
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            final Account account = accountCache.get(member.getAccountId()).getAccount();
            members.add(MembersCollection.parse(account));
        }
    }
    return members;
}
#end_block

#method_before
public void addGroupInclude(final AccountGroup.Id groupId, final String groupName, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final AccountGroup a = findGroup(groupName);
            if (!control.canAddGroup(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupInclude.Key key = new AccountGroupInclude.Key(groupId, a.getGroupUUID());
            AccountGroupInclude m = db.accountGroupIncludes().get(key);
            if (m == null) {
                m = new AccountGroupInclude(key);
                db.accountGroupIncludesAudit().insert(Collections.singleton(new AccountGroupIncludeAudit(m, getAccountId())));
                db.accountGroupIncludes().insert(Collections.singleton(m));
                groupIncludeCache.evictInclude(a.getGroupUUID());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#method_after
public void addGroupInclude(final AccountGroup.Id groupId, final AccountGroup.UUID incGroupUUID, final String incGroupName, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            if (incGroupUUID == null) {
                throw new Failure(new NoSuchGroupException(incGroupName));
            }
            if (!control.canAddGroup(incGroupUUID)) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupIncludeByUuid.Key key = new AccountGroupIncludeByUuid.Key(groupId, incGroupUUID);
            AccountGroupIncludeByUuid m = db.accountGroupIncludesByUuid().get(key);
            if (m == null) {
                m = new AccountGroupIncludeByUuid(key);
                db.accountGroupIncludesByUuidAudit().insert(Collections.singleton(new AccountGroupIncludeByUuidAudit(m, getAccountId())));
                db.accountGroupIncludesByUuid().insert(Collections.singleton(m));
                groupIncludeCache.evictInclude(incGroupUUID);
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#end_block

#method_before
public void deleteGroupIncludes(final AccountGroup.Id groupId, final Set<AccountGroupInclude.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupInclude.Key k : keys) {
                if (!groupId.equals(k.getGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            final Set<AccountGroup.Id> groupsToEvict = new HashSet<AccountGroup.Id>();
            for (final AccountGroupInclude.Key k : keys) {
                final AccountGroupInclude m = db.accountGroupIncludes().get(k);
                if (m != null) {
                    if (!control.canRemoveGroup(m.getIncludeId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupIncludeAudit audit = null;
                    for (AccountGroupIncludeAudit a : db.accountGroupIncludesAudit().byGroupInclude(m.getGroupId(), m.getIncludeId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupIncludesAudit().update(Collections.singleton(audit));
                    }
                    db.accountGroupIncludes().delete(Collections.singleton(m));
                    groupsToEvict.add(k.getIncludeId());
                }
            }
            for (AccountGroup group : db.accountGroups().get(groupsToEvict)) {
                groupIncludeCache.evictInclude(group.getGroupUUID());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteGroupIncludes(final AccountGroup.Id groupId, final Set<AccountGroupIncludeByUuid.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupIncludeByUuid.Key k : keys) {
                if (!groupId.equals(k.getGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            final Set<AccountGroup.UUID> groupsToEvict = new HashSet<AccountGroup.UUID>();
            for (final AccountGroupIncludeByUuid.Key k : keys) {
                final AccountGroupIncludeByUuid m = db.accountGroupIncludesByUuid().get(k);
                if (m != null) {
                    if (!control.canRemoveGroup(m.getIncludeUUID())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupIncludeByUuidAudit audit = null;
                    for (AccountGroupIncludeByUuidAudit a : db.accountGroupIncludesByUuidAudit().byGroupInclude(m.getGroupId(), m.getIncludeUUID())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupIncludesByUuidAudit().update(Collections.singleton(audit));
                    }
                    db.accountGroupIncludesByUuid().delete(Collections.singleton(m));
                    groupsToEvict.add(k.getIncludeUUID());
                }
            }
            for (AccountGroup.UUID uuid : groupsToEvict) {
                groupIncludeCache.evictInclude(uuid);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Option(name = "--group", aliases = "-g", metaVar = "GROUP", usage = "initial set of groups to be included in the group")
void addGroup(final AccountGroup.UUID uuid) {
    initialGroups.add(uuid);
}
#method_after
@Option(name = "--group", aliases = "-g", metaVar = "GROUP", usage = "initial set of groups to be included in the group")
void addGroup(final AccountGroup.UUID id) {
    initialGroups.add(id);
}
#end_block

#method_before
private void addGroups(final AccountGroup.Id groupId, final Collection<? extends AccountGroup.UUID> groups) throws OrmException {
    final List<AccountGroupInclude> includeList = new ArrayList<AccountGroupInclude>();
    final List<AccountGroupIncludeAudit> includesAudit = new ArrayList<AccountGroupIncludeAudit>();
    for (AccountGroup.UUID includeUUID : groups) {
        final AccountGroupInclude groupInclude = new AccountGroupInclude(new AccountGroupInclude.Key(groupId, includeUUID));
        includeList.add(groupInclude);
        final AccountGroupIncludeAudit audit = new AccountGroupIncludeAudit(groupInclude, currentUser.getAccountId());
        includesAudit.add(audit);
    }
    db.accountGroupIncludes().insert(includeList);
    db.accountGroupIncludesAudit().insert(includesAudit);
    for (AccountGroup.UUID groupUUID : groups) {
        groupIncludeCache.evictInclude(groupUUID);
    }
}
#method_after
private void addGroups(final AccountGroup.Id groupId, final Collection<? extends AccountGroup.UUID> groups) throws OrmException {
    final List<AccountGroupIncludeByUuid> includeList = new ArrayList<AccountGroupIncludeByUuid>();
    final List<AccountGroupIncludeByUuidAudit> includesAudit = new ArrayList<AccountGroupIncludeByUuidAudit>();
    for (AccountGroup.UUID includeUUID : groups) {
        final AccountGroupIncludeByUuid groupInclude = new AccountGroupIncludeByUuid(new AccountGroupIncludeByUuid.Key(groupId, includeUUID));
        includeList.add(groupInclude);
        final AccountGroupIncludeByUuidAudit audit = new AccountGroupIncludeByUuidAudit(groupInclude, currentUser.getAccountId());
        includesAudit.add(audit);
    }
    db.accountGroupIncludesByUuid().insert(includeList);
    db.accountGroupIncludesByUuidAudit().insert(includesAudit);
    for (AccountGroup.UUID uuid : groups) {
        groupIncludeCache.evictInclude(uuid);
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
    factory(NotesBranchUtil.Factory.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
    factory(NotesBranchUtil.Factory.class);
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            boolean validCommit = CommitUtil.validateCommit(destBranchCtl, newChange, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    boolean validCommit = CommitUtil.validateCommit(changeCtl.getRefControl(), inputCommand, newCommit, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

        public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
            reject(newChange, rejectReason);
        }

        @Override
        public void onAccepted(List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
        }
    });
    if (!validCommit) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            boolean validCommit = CommitUtil.validateCommit(ctl, cmd, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@VisibleForTesting
Map<String, ?> buildData(HttpServletRequest req) throws IOException {
    RepositoryDescription desc = accessFactory.forRequest(req).getRepositoryDescription();
    return ImmutableMap.of("cloneUrl", desc.cloneUrl, "description", Strings.nullToEmpty(desc.description), "branches", getRefs(req, Constants.R_HEADS, Ordering.from(RefComparator.INSTANCE)), "tags", getRefs(req, Constants.R_TAGS, tagComparator(req)));
}
#method_after
@VisibleForTesting
Map<String, ?> buildData(HttpServletRequest req) throws IOException {
    RepositoryDescription desc = accessFactory.forRequest(req).getRepositoryDescription();
    RevWalk walk = new RevWalk(ServletUtils.getRepository(req));
    List<Map<String, String>> tags;
    try {
        tags = getRefs(req, Constants.R_TAGS, tagComparator(walk));
    } finally {
        walk.release();
    }
    return ImmutableMap.of("cloneUrl", desc.cloneUrl, "description", Strings.nullToEmpty(desc.description), "branches", getRefs(req, Constants.R_HEADS, Ordering.from(RefComparator.INSTANCE)), "tags", tags);
}
#end_block

#method_before
private List<Map<String, String>> getRefs(HttpServletRequest req, String prefix, Ordering<Ref> ordering) throws IOException {
    RefDatabase refdb = ServletUtils.getRepository(req).getRefDatabase();
    Collection<Ref> refs = ordering.sortedCopy(refdb.getRefs(prefix).values());
    List<Map<String, String>> result = Lists.newArrayListWithCapacity(refs.size());
    for (Ref ref : refs) {
        String name = ref.getName().substring(prefix.length());
        boolean needPrefix = !ref.getName().equals(refdb.getRef(name).getName());
        result.add(ImmutableMap.of("url", GitilesView.log().copyFrom(req).setRevision(Revision.unpeeled(needPrefix ? ref.getName() : name, ref.getObjectId())).toUrl(), "name", name));
    }
    return result;
}
#method_after
private List<Map<String, String>> getRefs(HttpServletRequest req, String prefix, Ordering<Ref> ordering) throws IOException {
    RefDatabase refdb = ServletUtils.getRepository(req).getRefDatabase();
    Collection<Ref> refs = ordering.sortedCopy(refdb.getRefs(prefix).values());
    List<Map<String, String>> result = Lists.newArrayListWithCapacity(refs.size());
    for (Ref ref : refs) {
        String name = ref.getName().substring(prefix.length());
        boolean needPrefix = !ref.getName().equals(refdb.getRef(name).getName());
        result.add(ImmutableMap.of("url", GitilesView.revision().copyFrom(req).setRevision(Revision.unpeeled(needPrefix ? ref.getName() : name, ref.getObjectId())).toUrl(), "name", name));
    }
    return result;
}
#end_block

#method_before
private Ordering<Ref> tagComparator(HttpServletRequest req) {
    final RevWalk walk = new RevWalk(ServletUtils.getRepository(req));
    return Ordering.natural().onResultOf(new Function<Ref, Long>() {

        @Override
        public Long apply(Ref ref) {
            try {
                return timeCache.getTime(walk, ref.getObjectId());
            } catch (IOException e) {
                throw new UncheckedExecutionException(e);
            }
        }
    }).reverse().compound(RefComparator.INSTANCE);
}
#method_after
private Ordering<Ref> tagComparator(final RevWalk walk) {
    return Ordering.natural().onResultOf(new Function<Ref, Long>() {

        @Override
        public Long apply(Ref ref) {
            try {
                return timeCache.getTime(walk, ref.getObjectId());
            } catch (IOException e) {
                throw new UncheckedExecutionException(e);
            }
        }
    }).reverse().compound(RefComparator.INSTANCE);
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing) {
    for (Ref ref : repo.getAllRefs().values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith("refs/changes/")) {
            if (existing != null)
                existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing) {
    for (Ref ref : repo.getAllRefs().values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith("refs/changes/")) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (destBranchCtl != null && ref.getName().equals(destBranchCtl.getRefName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !project.isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, null);
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !project.isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing);
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        return owner || canPerform(Permission.PUSH_TAG);
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
boolean validate(boolean ignoreNoChanges) throws IOException {
    if (inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !ignoreNoChanges) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    warnMalformedMessage(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (newProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    warnMalformedMessage(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                return change;
            }
        });
        if (change == null) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToLatestPatchSet(db, change);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : patchSetApprovals) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        approvalsUtil.addReviewers(db, change, newPatchSet, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    replication.fire(project.getNameKey(), newPatchSet.getRefName());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, newPatchSet.getId());
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : patchSetApprovals) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        approvalsUtil.addReviewers(db, change, newPatchSet, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    replication.fire(project.getNameKey(), newPatchSet.getRefName());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    // Execute commit validation plugins
    for (CommitValidationListener validator : commitValidators) {
        try {
            List<CommitValidationMessage> results = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
            messages.addAll(results);
        } catch (CommitValidationException error) {
            reject(cmd, error.getMessage());
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    // Execute commit validation plugins
    for (CommitValidationListener validator : commitValidators) {
        try {
            messages.addAll(validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser)));
        } catch (CommitValidationException error) {
            reject(cmd, error.getMessage());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
public static void all(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "ALL").addParameterTrue("all").addParameterTrue(// description
    "d").send(NativeMap.copyKeysIntoChildren(callback));
}
#method_after
public static void all(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "ALL").addParameterTrue("all").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(callback));
}
#end_block

#method_before
public static void permissions(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "PERMISSIONS").addParameterTrue("all").addParameterTrue(// description
    "d").send(NativeMap.copyKeysIntoChildren(callback));
}
#method_after
public static void permissions(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "PERMISSIONS").addParameterTrue("all").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(callback));
}
#end_block

#method_before
public static void parentCandidates(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "PARENT_CANDIDATES").addParameterTrue("all").addParameterTrue(// description
    "d").send(NativeMap.copyKeysIntoChildren(callback));
}
#method_after
public static void parentCandidates(AsyncCallback<ProjectMap> callback) {
    new RestApi("/projects/").addParameterRaw("type", "PARENT_CANDIDATES").addParameterTrue("all").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(callback));
}
#end_block

#method_before
public static void suggest(String prefix, int limit, AsyncCallback<ProjectMap> cb) {
    new RestApi("/projects/" + URL.encode(prefix).replaceAll("[?]", "%3F")).addParameterRaw("type", "ALL").addParameter("n", limit).addParameterTrue(// description
    "d").send(NativeMap.copyKeysIntoChildren(cb));
}
#method_after
public static void suggest(String prefix, int limit, AsyncCallback<ProjectMap> cb) {
    new RestApi("/projects/").addParameter("p", prefix).addParameter("n", limit).addParameterRaw("type", "ALL").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(cb));
}
#end_block

#method_before
public static void match(String match, AsyncCallback<ProjectMap> cb) {
    new RestApi("/projects/" + URL.encode(match).replaceAll("[?]", "%3F")).addParameterRaw("type", "ALL").addParameterTrue(// description
    "d").addParameterTrue("subname").send(NativeMap.copyKeysIntoChildren(cb));
}
#method_after
public static void match(String match, AsyncCallback<ProjectMap> cb) {
    new RestApi("/projects/").addParameter("m", match).addParameterRaw("type", "ALL").addParameterTrue(// description
    "d").get(NativeMap.copyKeysIntoChildren(cb));
}
#end_block

#method_before
protected void display(final ProjectMap result) {
    projects.display(result);
    projects.finishDisplay();
}
#method_after
private void display(final ProjectMap result) {
    projects.display(result);
    projects.finishDisplay();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, 3, Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, 3, Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProjectAdmin(item.name_key(), ProjectScreen.INFO);
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            if (Gerrit.getGitwebLink() != null) {
                table.getFlexCellFormatter().addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
            }
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            table.setWidget(row, 1, new Hyperlink(k.name(), link(k)));
            table.setText(row, 2, k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, 3, new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, 3, Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, 3, Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProjectAdmin(item.name_key(), ProjectScreen.INFO);
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            if (Gerrit.getGitwebLink() != null) {
                table.getFlexCellFormatter().addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
            }
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            FlowPanel fp = new FlowPanel();
            fp.add(new ProjectSearchLink(k.name_key()));
            fp.add(new InlineHyperlink(k.name(), link(k)));
            table.setWidget(row, 1, fp);
            table.setText(row, 2, k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, 3, new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#end_block

#method_before
protected void initPageHeader() {
}
#method_after
private void initPageHeader() {
    final HorizontalPanel hp = new HorizontalPanel();
    hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel());
    final Label filterLabel = new Label(Util.C.projectFilter());
    filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel());
    hp.add(filterLabel);
    filterTxt = new NpTextBox();
    filterTxt.setValue(subname);
    filterTxt.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            subname = filterTxt.getValue();
            refresh();
        }
    });
    hp.add(filterTxt);
    add(hp);
}
#end_block

#method_before
public ListProjects setFormat(OutputFormat fmt) {
    this.format = fmt;
    return this;
}
#method_after
public ListProjects setFormat(OutputFormat fmt) {
    format = fmt;
    return this;
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupCache.get(groupUuid)))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = e.getParentState();
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = parentState.getProject().getDescription();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = e.getParentState();
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription && !e.getProject().getDescription().isEmpty()) {
                    info.description = e.getProject().getDescription();
                }
                try {
                    if (showBranch != null) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#method_after
public JsonElement display(OutputStream displayOutputStream) {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupCache.get(groupUuid)))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = e.getParentState();
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.setName(parentState.getProject().getName());
                        info.description = Strings.emptyToNull(parentState.getProject().getDescription());
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.setName(projectName.get());
                if (showTree && format.isJson()) {
                    ProjectState parent = e.getParentState();
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription) {
                    info.description = Strings.emptyToNull(e.getProject().getDescription());
                }
                try {
                    if (showBranch != null) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        if (stdout == null) {
            return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, Object>>() {
            }.getType());
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
private Iterable<NameKey> scan() {
    if (recent) {
        return recentProjectsCache.getProjects(userProvider.get().getAccountId());
    } else if (match != null) {
        if (byPrefix) {
            return projectCache.byName(match);
        } else {
            return projectCache.bySubname(match);
        }
    } else {
        return projectCache.all();
    }
}
#method_after
private Iterable<Project.NameKey> scan() {
    if (matchPrefix != null) {
        return projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else {
        return projectCache.all();
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = new PatchSet.Id(change.getId(), Change.INITIAL_PATCH_SET_ID);
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = nextPatchSetId(git, changeToRevert.currentPatchSetId());
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = new PatchSet.Id(change.getId(), Change.INITIAL_PATCH_SET_ID);
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    bind(AnonymousUser.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapRealmModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    install(new LdapModule());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username;
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword());
            }
            return new AuthUser(new AuthUser.UUID(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username;
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        username = req.getUsername().toLowerCase(Locale.US);
    } else {
        username = req.getUsername();
    }
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword());
            }
            return new AuthUser(new AuthUser.UUID(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private void defaultStyle(final int row, final CellFormatter fmt) {
    fmt.addStyleName(row, A - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffText());
    if (isDisplayBinary) {
        fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffTextForBinaryInSidyBySide());
    }
    fmt.addStyleName(row, B, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void defaultStyle(final int row, final CellFormatter fmt) {
    fmt.addStyleName(row, A - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffText());
    if (isDisplayBinary) {
        fmt.addStyleName(row, A, Gerrit.RESOURCES.css().diffTextForBinaryInSideBySide());
    }
    fmt.addStyleName(row, B, Gerrit.RESOURCES.css().diffText());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, B + 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
public String getUnifiedDiff() {
    PatchList patchList;
    try {
        patchList = getPatchList();
        if (patchList.getOldId() == null) {
            // Currently these always have a null oldId in the PatchList.
            return "[There is no diff output.\n" + " Reason: This change has more than two parents.\n" + " Gerrit does not support for generating diff output\n" + " between this kind change and its parents by far.]\n";
        }
    } catch (PatchListNotAvailableException e) {
        log.error("Cannot format patch", e);
        return "";
    }
    TemporaryBuffer.Heap buf = new TemporaryBuffer.Heap(args.settings.maximumDiffSize);
    DiffFormatter fmt = new DiffFormatter(buf);
    Repository git;
    try {
        git = args.server.openRepository(change.getProject());
    } catch (IOException e) {
        log.error("Cannot open repository to format patch", e);
        return "";
    }
    try {
        fmt.setRepository(git);
        fmt.setDetectRenames(true);
        fmt.format(patchList.getOldId(), patchList.getNewId());
        return RawParseUtils.decode(buf.toByteArray());
    } catch (IOException e) {
        if (JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) {
            return "";
        }
        log.error("Cannot format patch", e);
        return "";
    } finally {
        fmt.release();
        git.close();
    }
}
#method_after
public String getUnifiedDiff() {
    PatchList patchList;
    try {
        patchList = getPatchList();
        if (patchList.getOldId() == null) {
            // Currently these always have a null oldId in the PatchList.
            return "[Octopus merge; cannot be formatted as a diff.]\n";
        }
    } catch (PatchListNotAvailableException e) {
        log.error("Cannot format patch", e);
        return "";
    }
    TemporaryBuffer.Heap buf = new TemporaryBuffer.Heap(args.settings.maximumDiffSize);
    DiffFormatter fmt = new DiffFormatter(buf);
    Repository git;
    try {
        git = args.server.openRepository(change.getProject());
    } catch (IOException e) {
        log.error("Cannot open repository to format patch", e);
        return "";
    }
    try {
        fmt.setRepository(git);
        fmt.setDetectRenames(true);
        fmt.format(patchList.getOldId(), patchList.getNewId());
        return RawParseUtils.decode(buf.toByteArray());
    } catch (IOException e) {
        if (JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) {
            return "";
        }
        log.error("Cannot format patch", e);
        return "";
    } finally {
        fmt.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final String newMessage = message + '\n';
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Date now = myIdent.getWhen();
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            if (commit.getFullMessage().equals(newMessage)) {
                throw new InvalidChangeOperationException("The commit message is unchanged");
            }
            PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(newMessage);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user.getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            if (commit.getFullMessage().equals(message)) {
                throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
            }
            Date now = myIdent.getWhen();
            Change change = db.changes().get(changeId);
            PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user.getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setHTML(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        ValueRadioButton b = new ValueRadioButton(ct.getCategory(), buttonValue);
        SafeHtml buf = new SafeHtmlBuilder().append(buttonValue.format());
        buf = CommentLinkProcessor.apply(buf);
        SafeHtml.set(b, buf);
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, false, r.getPatchSetInfo(), r.getAccounts(), r.getSubmitTypeRecord());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    revision = r.getPatchSetInfo().getRevId();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    ReviewInput data = ReviewInput.create();
    data.message(ChangeApi.emptyToNull(message.getText().trim()));
    data.init();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            data.label(b.category.getLabelName(), b.value.getValue());
        }
    }
    enableForm(false);
    new RestApi("/changes/" + patchSetId.getParentKey().get() + "/revisions/" + revision + "/review").data(data).post(new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#method_after
private void submit() {
    ChangeApi.submit(patchSetId.getParentKey().get(), revision, new GerritCallback<SubmitInfo>() {

        public void onSuccess(SubmitInfo result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
            } else {
                super.onFailure(err);
            }
            goChange();
        }
    });
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc) throws BadRequestException, OrmException {
    List<Object> reviewers = new ArrayList<Object>();
    ReviewDb db = dbProvider.get();
    Change.Id changeId = rsrc.getChange().getId();
    for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) {
        Account account = accountCache.get(patchSetApproval.getAccountId()).getAccount();
        reviewers.add(json.format(new ReviewerResource(rsrc, account)));
    }
    return reviewers;
}
#method_after
@Override
public Object apply(ChangeResource rsrc) throws BadRequestException, OrmException {
    Map<Account.Id, Object> reviewers = Maps.newLinkedHashMap();
    ReviewDb db = dbProvider.get();
    Change.Id changeId = rsrc.getChange().getId();
    for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) {
        Account.Id accountId = patchSetApproval.getAccountId();
        if (!reviewers.containsKey(accountId)) {
            Account account = accountCache.get(accountId).getAccount();
            reviewers.put(accountId, json.format(new ReviewerResource(rsrc, account)));
        }
    }
    return reviewers.values();
}
#end_block

#method_before
@Override
public ReviewerResource parse(ChangeResource changeResource, String id) throws OrmException, ResourceNotFoundException {
    // Get the account id
    if (!id.matches("^[0-9]+$")) {
        throw new ResourceNotFoundException(id);
    }
    Account.Id accountId = Account.Id.parse(id);
    // See if the id exists as a reviewer for this change
    if (fetchAccountIds(changeResource).contains(accountId)) {
        Account account = accountCache.get(accountId).getAccount();
        return new ReviewerResource(changeResource, account);
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public ReviewerResource parse(ChangeResource rsrc, String id) throws OrmException, ResourceNotFoundException, AuthException {
    Account.Id accountId;
    if (id.equals("self")) {
        CurrentUser user = rsrc.getControl().getCurrentUser();
        if (user instanceof IdentifiedUser) {
            accountId = ((IdentifiedUser) user).getAccountId();
        } else if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else {
            throw new ResourceNotFoundException(id);
        }
    } else if (id.matches("^[0-9]+$")) {
        accountId = Account.Id.parse(id);
    } else {
        throw new ResourceNotFoundException(id);
    }
    // See if the id exists as a reviewer for this change
    if (fetchAccountIds(rsrc).contains(accountId)) {
        Account account = accountCache.get(accountId).getAccount();
        return new ReviewerResource(rsrc, account);
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
private Set<Account.Id> fetchAccountIds(ChangeResource changeResource) throws OrmException {
    ReviewDb db = dbProvider.get();
    Change.Id changeId = changeResource.getChange().getId();
    Set<Account.Id> accountIds = new HashSet<Account.Id>();
    for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) {
        accountIds.add(patchSetApproval.getAccountId());
    }
    return accountIds;
}
#method_after
private Set<Account.Id> fetchAccountIds(ChangeResource rsrc) throws OrmException {
    Set<Account.Id> accountIds = Sets.newHashSet();
    for (PatchSetApproval a : dbProvider.get().patchSetApprovals().byChange(rsrc.getChange().getId())) {
        accountIds.add(a.getAccountId());
    }
    return accountIds;
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    if (!newChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : newChanges) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (ReplaceRequest replace : replaceByChange.values()) {
        if (replace.inputCommand == newChange) {
            replaceCount++;
            if (replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            }
        } else {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (newChange == null || newChange.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(newChange, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, newChanges.size(), project.getName()));
        return;
    }
    try {
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == newChange) {
                replace.insertPatchSet();
            }
        }
        for (CreateRequest create : newChanges) {
            create.insertChange();
        }
        newChange.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't inserting changes for " + project.getName(), err);
        reject(newChange, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(newChange, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (ReplaceRequest replace : replaceByChange.values()) {
        if (replace.inputCommand == newChange) {
            replaceCount++;
            if (replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            }
        } else {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (newChange == null || newChange.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(newChange, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, newChanges.size(), project.getName()));
        return;
    }
    try {
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == newChange) {
                replace.insertPatchSet();
            }
        }
        for (CreateRequest create : newChanges) {
            create.insertChange();
        }
        newChange.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(newChange, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(newChange, "internal server error");
    }
}
#end_block

#method_before
void insertChange() throws IOException, OrmException {
    rp.getRevWalk().parseBody(commit);
    warnMalformedMessage(commit);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = commit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    db.changes().beginTransaction(change.getId());
    try {
        insertAncestors(ps.getId(), commit);
        db.patchSets().insert(Collections.singleton(ps));
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(change, ps, info, reviewers);
        db.commit();
    } finally {
        db.rollback();
    }
    replication.fire(project.getNameKey(), ps.getRefName());
    hooks.doPatchsetCreatedHook(change, ps, db);
    newProgress.update(1);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
}
#method_after
void insertChange() throws IOException, OrmException {
    rp.getRevWalk().parseBody(commit);
    warnMalformedMessage(commit);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = commit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    db.changes().beginTransaction(change.getId());
    try {
        insertAncestors(ps.getId(), commit);
        db.patchSets().insert(Collections.singleton(ps));
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(change, ps, info, reviewers);
        db.commit();
    } finally {
        db.rollback();
    }
    created = true;
    replication.fire(project.getNameKey(), ps.getRefName());
    hooks.doPatchsetCreatedHook(change, ps, db);
    newProgress.update(1);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !project.isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (RepositoryNotFoundException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(openRepository(change), patchsetCreatedHook, args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(openRepository(change), commentAddedHook, args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(openRepository(change), changeMergedHook, args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(openRepository(change), changeAbandonedHook, args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(openRepository(refName.getParentKey()), refUpdatedHook, args);
}
#method_after
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-id", cla.getId().toString());
        runHook(claSignedHook, args);
    }
}
#method_after
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, File hook, List<String> args) {
    if (project != null && hook.exists()) {
        hookQueue.execute(new AsyncHookTask(project, hook, args));
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Repository repo, File hook, List<String> args) throws TimeoutException {
    if (hook.exists()) {
        SyncHookTask syncHook = new SyncHookTask(repo, hook, args);
        FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
        syncHookThreadPool.execute(task);
        try {
            return task.get(syncHookTimeout, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (ExecutionException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (TimeoutException e) {
            log.error("Synchronous hook timed out " + hook.getAbsolutePath());
            throw e;
        }
    }
    return null;
}
#method_after
private HookResult runSyncHook(Project.NameKey project, File hook, List<String> args) throws TimeoutException {
    if (!hook.exists()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.getAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.getAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
@Override
public HookResult call() throws Exception {
    HookResult result = null;
    StringBuilder output = new StringBuilder();
    try {
        final List<String> argv = new ArrayList<String>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (repo != null) {
            pb.directory(repo.getDirectory());
            final Map<String, String> env = pb.environment();
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        Process ps = pb.start();
        ps.getOutputStream().close();
        BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
        try {
            String line = br.readLine();
            while (line != null) {
                output.append(line);
                line = br.readLine();
                if (line != null) {
                    output.append(System.getProperty("line.separator"));
                }
            }
        } finally {
            try {
                br.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output.toString());
        }
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return result;
}
#method_after
@Override
public HookResult call() throws Exception {
    return super.runHook();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        // Run the update hook, if it returns output then reject the push
        // passing the output back to the user
        String output = hooks.doUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (output != null) {
            reject(cmd, output);
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        Map<String, Ref> refs = repo.getAllRefs();
        existingObjects = new ArrayList<ObjectId>(refs.size());
        for (Ref r : refs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#method_after
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        existingObjects = new ArrayList<ObjectId>(allRefs.size());
        for (Ref r : allRefs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        final String message = validationResult.getValidationReason();
        if (!validationResult.isValidated()) {
            reject(cmd, message);
            return false;
        } else if (!Strings.isNullOrEmpty(message)) {
            addMessage(String.format("(W) %s", message));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    addMessage(sb.toString());
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException {
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    db.changes().beginTransaction(revision.getChange().getId());
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        insertComments(revision, input.comments, input.drafts);
        if (change.getStatus().isOpen() && input.labels != null) {
            // TODO Allow updating some labels even when closed.
            updateLabels(revision, input.labels);
        }
        insertMessage(revision, input.message);
        db.changes().update(Collections.singleton(change));
        db.commit();
    } finally {
        db.rollback();
    }
    email.create(change, revision.getPatchSet(), revision.getAuthorId(), message, comments).sendAsync();
    fireCommentAddedHook(revision);
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#method_after
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException {
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    db.changes().beginTransaction(revision.getChange().getId());
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        insertComments(revision, input.comments, input.drafts);
        updateLabels(revision, input.labels);
        insertMessage(revision, input.message);
        db.changes().update(Collections.singleton(change));
        db.commit();
    } finally {
        db.rollback();
    }
    email.create(change, revision.getPatchSet(), revision.getAuthorId(), message, comments).sendAsync();
    fireCommentAddedHook(revision);
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
private void updateLabels(RevisionResource rsrc, Map<String, Short> labels) throws OrmException {
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ins = Lists.newArrayList();
    List<PatchSetApproval> upd = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(rsrc, del);
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        // TODO Support arbitrary label names.
        ApprovalType at = approvalTypes.byLabel(ent.getKey());
        String name = at.getCategory().getLabelName();
        PatchSetApproval c = current.get(name);
        if (ent.getValue() == null) {
            if (c != null) {
                // User requested delete of this label.
                del.add(c);
                labelDelta.add("-" + name);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(timestamp);
            c.cache(change);
            upd.add(c);
            labelDelta.add(format(name, c.getValue()));
            categories.put(at.getCategory().getId(), at.getValue(c.getValue()).getId());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), rsrc.getAuthorId(), at.getCategory().getId()), ent.getValue());
            c.setGranted(timestamp);
            c.cache(change);
            ins.add(c);
            labelDelta.add(format(name, c.getValue()));
            categories.put(at.getCategory().getId(), at.getValue(c.getValue()).getId());
        }
    }
    db.patchSetApprovals().delete(del);
    db.patchSetApprovals().insert(ins);
    db.patchSetApprovals().update(upd);
}
#method_after
private void updateLabels(RevisionResource rsrc, Map<String, Short> labels) throws OrmException {
    if (labels == null) {
        labels = Collections.emptyMap();
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ins = Lists.newArrayList();
    List<PatchSetApproval> upd = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(rsrc, del);
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        // TODO Support arbitrary label names.
        ApprovalType at = approvalTypes.byLabel(ent.getKey());
        String name = at.getCategory().getLabelName();
        if (change.getStatus().isClosed()) {
            // TODO Allow updating some labels even when closed.
            continue;
        }
        PatchSetApproval c = current.remove(name);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            if (c != null) {
                del.add(c);
                labelDelta.add("-" + name);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(timestamp);
            c.cache(change);
            upd.add(c);
            labelDelta.add(format(name, c.getValue()));
            categories.put(at.getCategory().getId(), at.getValue(c.getValue()).getId());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(name, c);
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), rsrc.getAuthorId(), at.getCategory().getId()), ent.getValue());
            c.setGranted(timestamp);
            c.cache(change);
            ins.add(c);
            labelDelta.add(format(name, c.getValue()));
            categories.put(at.getCategory().getId(), at.getValue(c.getValue()).getId());
        }
    }
    forceCallerAsReviewer(rsrc, current, ins, upd, del);
    db.patchSetApprovals().delete(del);
    db.patchSetApprovals().insert(ins);
    db.patchSetApprovals().update(upd);
}
#end_block

#method_before
public static void abandon(int changeId, String message, AsyncCallback<ChangeInfo> callback) {
    RestApi call = new RestApi(URI + changeId + "/abandon");
    Message msg = new Message();
    msg.setMessage(message);
    call.data(msg).post(callback);
}
#method_after
public static void abandon(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    Input input = Input.create();
    input.message(emptyToNull(msg));
    api(id, "abandon").data(input).post(cb);
}
#end_block

#method_before
public static void restore(int changeId, String message, AsyncCallback<ChangeInfo> callback) {
    RestApi call = new RestApi(URI + changeId + "/restore");
    Message msg = new Message();
    msg.setMessage(message);
    call.data(msg).post(callback);
}
#method_after
public static void restore(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    Input input = Input.create();
    input.message(emptyToNull(msg));
    api(id, "restore").data(input).post(cb);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AlterTopicHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EditCommitMessageHandler.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b) {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(patchSet.getId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b) {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final Abandon abandon = abandonProvider.get();
            final Abandon.Input input = new Abandon.Input();
            input.message = changeComment;
            ChangeControl ctl = changeControlFactory.controlFor(patchSetId.getParentKey());
            try {
                abandon.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            final Restore restore = restoreProvider.get();
            final Restore.Input input = new Restore.Input();
            input.message = changeComment;
            ChangeControl ctl = changeControlFactory.controlFor(patchSetId.getParentKey());
            try {
                restore.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    PostReview.Input review = new PostReview.Input();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = PostReview.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    try {
        ChangeControl ctl = changeControlFactory.controlFor(patchSetId.getParentKey());
        reviewProvider.get().apply(new RevisionResource(new ChangeResource(ctl), db.patchSets().get(patchSetId)), review);
        if (abandonChange) {
            final Abandon abandon = abandonProvider.get();
            final Abandon.Input input = new Abandon.Input();
            input.message = changeComment;
            try {
                abandon.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            final Restore restore = restoreProvider.get();
            final Restore.Input input = new Restore.Input();
            input.message = changeComment;
            try {
                restore.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(RequestScopedReviewDbProvider.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(ListProjects.class);
    bind(ApprovalsUtil.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    bind(AccountControl.Factory.class).in(SINGLETON);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    install(new AsyncReceiveCommits.Module());
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(RebaseChange.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(RequestScopedReviewDbProvider.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(ApprovalsUtil.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    bind(AccountControl.Factory.class).in(SINGLETON);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    install(new AsyncReceiveCommits.Module());
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(RebaseChange.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    factory(AbandonedSender.Factory.class);
    factory(RestoredSender.Factory.class);
}
#method_after
@Override
protected void configure() {
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(RestoredSender.Factory.class);
}
#end_block

#method_before
static DashboardInfo parse(Project project, String refName, String path, Config config) throws UnsupportedEncodingException {
    DashboardInfo info = new DashboardInfo(refName, path);
    info.title = config.getString("dashboard", null, "title");
    info.description = config.getString("dashboard", null, "description");
    info.allQueries = config.getString("dashboard", null, "allQueries");
    info.isDefault = info.id.equals(defaultOf(project)) ? true : null;
    UrlEncoded u = new UrlEncoded("/dashboard/");
    u.put("title", Objects.firstNonNull(info.title, info.path));
    if (info.allQueries != null) {
        u.put("allQueries", replace(project.getName(), info.allQueries));
    }
    for (String name : config.getSubsections("section")) {
        Section s = new Section();
        s.name = name;
        s.query = config.getString("section", name, "query");
        u.put(s.name, replace(project.getName(), s.query));
        info.sections.add(s);
    }
    info.url = u.toString().replace("%3A", ":");
    return info;
}
#method_after
static DashboardInfo parse(Project project, String refName, String path, Config config, boolean setDefault) throws UnsupportedEncodingException {
    DashboardInfo info = new DashboardInfo(refName, path);
    info.title = config.getString("dashboard", null, "title");
    info.description = config.getString("dashboard", null, "description");
    info.isDefault = setDefault ? (info.id.equals(defaultOf(project)) ? true : null) : null;
    info.foreach = config.getString("dashboard", null, "foreach");
    UrlEncoded u = new UrlEncoded("/dashboard/");
    u.put("title", Objects.firstNonNull(info.title, info.path));
    if (info.foreach != null) {
        u.put("foreach", replace(project.getName(), info.foreach));
    }
    for (String name : config.getSubsections("section")) {
        Section s = new Section();
        s.name = name;
        s.query = config.getString("section", name, "query");
        u.put(s.name, replace(project.getName(), s.query));
        info.sections.add(s);
    }
    info.url = u.toString().replace("%3A", ":");
    return info;
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.nextPatchSetId();
        change.setTopic(changeToRevert.getTopic());
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        Change change = db.changes().get(changeId);
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.addParentId(commit);
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setAuthor(authorIdent);
        commitBuilder.setCommitter(myIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        change.nextPatchSetId();
        final PatchSet originalPS = db.patchSets().get(patchSetId);
        final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
        newPatchSet.setCreatedOn(change.getCreatedOn());
        newPatchSet.setUploader(change.getOwner());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
        final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            Change updatedChange;
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
            }
            ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
            db.patchSets().insert(Collections.singleton(newPatchSet));
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(patchSetId)) {
                        return null;
                    }
                    if (change.getStatus() != Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            cmsg.setMessage(msg);
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.addParentId(commit);
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setAuthor(authorIdent);
            commitBuilder.setCommitter(myIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(change.getCreatedOn());
            newPatchSet.setUploader(change.getOwner());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus() == Change.Status.NEW && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus().isOpen() && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AbandonChangeHandler.Factory.class);
            factory(EditCommitMessageHandler.Factory.class);
            factory(AlterTopicHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EditCommitMessageHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#end_block

#method_before
public void display(final String commitMessage) {
    display(null, null, null, commitMessage);
}
#method_after
public void display(final String commitMessage) {
    display(null, null, false, commitMessage);
}
#end_block

#method_before
public void display(Change.Id changeId, final PatchSet.Id patchSetId, Boolean starred, final String commitMessage) {
    starPanel.clear();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null && patchSetId != null) {
        ChangeDetailCache detailCache = ChangeCache.get(patchSetId.getParentKey()).getChangeDetailCache();
        ChangeDetail changeDetail = detailCache.get();
        if (changeDetail.canEditCommitMessage()) {
            permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
            permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new EditCommitMessageActionDialog() {

                        {
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.editCommitMessage(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            edit.addStyleName(Gerrit.RESOURCES.css().changeInfoBlockEdit());
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(final PatchSet.Id patchSetId, Boolean starred, Boolean canEditCommitMessage, final String commitMessage) {
    starPanel.clear();
    Change.Id changeId = patchSetId.getParentKey();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null) {
        permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
        permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
        if (canEditCommitMessage) {
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new CommentedActionDialog<ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new ChangeDetailCache.IgnoreErrorCallback() {
                    }) {

                        {
                            message.setCharacterWidth(80);
                            message.setVisibleLines(20);
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.createNewPatchSet(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new InvalidChangeOperationException("Not allowed to add new Patch Sets to: " + changeId.toString());
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
public void display(Change chg, Boolean starred, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.getId(), chg.currentPatchSetId(), starred, info.getMessage());
}
#method_after
public void display(Change chg, Boolean starred, Boolean canEditCommitMessage, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.currentPatchSetId(), starred, canEditCommitMessage, info.getMessage());
}
#end_block

#method_before
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#method_after
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (column > C_ARROW && getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#method_after
@Override
protected void render(final PatchScript script, final PatchSetDetail detail) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    allocateTableHeader(nc);
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                padLineNumberForSideB(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), -1));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumberForSideA(nc);
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, -1, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    populateTableHeader(script, detail);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#end_block

#method_before
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == 0) {
            fora = cd.getForA(0);
            forb = cd.getForB(0);
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
        } else {
            row++;
            continue;
        }
        row++;
        if (!fora.isEmpty() && !forb.isEmpty()) {
            all.clear();
            all.addAll(fora);
            all.addAll(forb);
            Collections.sort(all, BY_DATE);
            row = insert(all, row, expandComments);
        } else if (!fora.isEmpty()) {
            row = insert(fora, row, expandComments);
        } else if (!forb.isEmpty()) {
            row = insert(forb, row, expandComments);
        }
    }
}
#method_after
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == R_HEAD) {
            fora = cd.getForA(R_HEAD);
            forb = cd.getForB(R_HEAD);
            row++;
            if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            }
            rowOfTableHeaderB = row;
            borderRowOfFileComment = row + 1;
            if (!forb.isEmpty()) {
                // Skip the Header of sideB.
                row++;
                row = insert(forb, row, expandComments);
                borderRowOfFileComment = row;
                createFileCommentBorderRow();
            }
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
            row++;
            if (!fora.isEmpty() && !forb.isEmpty()) {
                all.clear();
                all.addAll(fora);
                all.addAll(forb);
                Collections.sort(all, BY_DATE);
                row = insert(all, row, expandComments);
            } else if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            } else if (!forb.isEmpty()) {
                row = insert(forb, row, expandComments);
            }
        } else {
            row++;
            continue;
        }
    }
}
#end_block

#method_before
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, PC - 2, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC, Gerrit.RESOURCES.css().diffText());
}
#method_after
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    defaultStyle(row, fmt);
}
#end_block

#method_before
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        insertRow(row);
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#method_after
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        if (c.getLine() == R_HEAD) {
            insertFileCommentRow(row);
        } else {
            insertRow(row);
        }
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#end_block

#method_before
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#end_block

#method_before
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void destroyEditor(final int row, final int col) {
    table.clearCell(row, col);
    final int span = table.getFlexCellFormatter().getRowSpan(row, col);
    boolean removeRow = true;
    final int nCells = table.getCellCount(row);
    for (int cell = 0; cell < nCells; cell++) {
        if (table.getWidget(row, cell) != null) {
            removeRow = false;
            break;
        }
    }
    if (removeRow) {
        for (int r = row - 1; 0 <= r; r--) {
            boolean data = false;
            for (int c = 0; c < table.getCellCount(r); c++) {
                data |= table.getWidget(r, c) != null;
                final int s = table.getFlexCellFormatter().getRowSpan(r, c) - 1;
                if (r + s == row) {
                    table.getFlexCellFormatter().setRowSpan(r, c, s);
                }
            }
            if (!data) {
                break;
            }
        }
        table.removeRow(row);
        removeFileCommentBorderRow(row, col);
    } else {
        // 
        table.getFlexCellFormatter().setStyleName(row, col, Gerrit.RESOURCES.css().diffText());
        if (span != 1) {
            table.getFlexCellFormatter().setRowSpan(row, col, 1);
            for (int r = row + 1; r < row + span; r++) {
                table.insertCell(r, col);
                // 
                table.getFlexCellFormatter().setStyleName(r, col, Gerrit.RESOURCES.css().diffText());
            }
        }
    }
}
#method_after
private void destroyEditor(final int row, final int col) {
    table.clearCell(row, col);
    final int span = table.getFlexCellFormatter().getRowSpan(row, col);
    boolean removeRow = true;
    final int nCells = table.getCellCount(row);
    for (int cell = 0; cell < nCells; cell++) {
        if (table.getWidget(row, cell) != null) {
            removeRow = false;
            break;
        }
    }
    if (removeRow) {
        destroyCommentRow(row);
    } else {
        destroyComment(row, col, span);
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
    // Populate icons to lineNumber column header.
    if (psListOfHeaderA.isFile) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (psListOfHeaderB.isFile) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
    // Populate icons to lineNumber column header.
    if (headerSideA.isFile()) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (headerSideB.isFile()) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#end_block

#method_before
private void createFileCommentBorderRow(final int row) {
    if (row == 1 && !isFileCommentBorderRowExist) {
        isFileCommentBorderRowExist = true;
        table.insertRow(R_HEAD + 2);
        final CellFormatter fmt = table.getCellFormatter();
        // 
        fmt.addStyleName(// 
        R_HEAD + 2, // 
        C_ARROW, Gerrit.RESOURCES.css().iconCellOfFileCommentRow());
        defaultStyle(R_HEAD + 2, fmt);
        final Element iconCell = fmt.getElement(R_HEAD + 2, C_ARROW);
        UIObject.setStyleName(DOM.getParent(iconCell), Gerrit.RESOURCES.css().borderRowOfFileComment(), true);
    }
}
#method_after
private void createFileCommentBorderRow(final int row) {
    if (row == 1 && !isFileCommentBorderRowExist) {
        isFileCommentBorderRowExist = true;
        table.insertRow(R_HEAD + 2);
        final CellFormatter fmt = table.getCellFormatter();
        // 
        fmt.addStyleName(// 
        R_HEAD + 2, // 
        C_ARROW, Gerrit.RESOURCES.css().iconCellOfFileCommentRow());
        defaultStyle(R_HEAD + 2, fmt);
        final Element iconCell = fmt.getElement(R_HEAD + 2, C_ARROW);
        UIObject.setStyleName(DOM.getParent(iconCell), Gerrit.RESOURCES.css().fileCommentBorder(), true);
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, PC, psListOfHeaderA);
    table.setWidget(rowOfTableHeaderB, PC, psListOfHeaderB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, PC, headerSideA);
    table.setWidget(rowOfTableHeaderB, PC, headerSideB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#end_block

#method_before
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#method_after
@Override
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#end_block

#method_before
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            createCommentEditor(suggestRow, column, newComment).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#method_after
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            findOrCreateCommentEditor(suggestRow, column, newComment, true).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#end_block

#method_before
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    createEditor(newComment).setFocus(true);
}
#method_after
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    findOrCreateEditor(newComment, true).setFocus(true);
}
#end_block

#method_before
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = createEditor(newComment);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                createEditor(result).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#method_after
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = findOrCreateEditor(newComment, false);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            @Override
            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                findOrCreateEditor(result, true).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
    // Populate icons to lineNumber column header.
    if (psListOfHeaderA.isFile) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (psListOfHeaderB.isFile) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
    // Populate icons to lineNumber column header.
    if (headerSideA.isFile()) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (headerSideB.isFile()) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
}
#end_block

#method_before
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    isFile = isFile();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private Anchor createDownloadLink() {
    if (!isFile) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#method_after
private Anchor createDownloadLink() {
    if (!isFile()) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, PC, psListOfHeaderA);
    table.setWidget(rowOfTableHeaderB, PC, psListOfHeaderB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, PC, headerSideA);
    table.setWidget(rowOfTableHeaderB, PC, headerSideB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    final PatchSet.Id pId = patchSet.getId();
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            Account.Id authoId = psInfoFactory.get(db, pId).getAuthor().getAccount();
            if (authoId == null) {
                p.author = new AccountAttribute();
                p.author.email = "";
                p.author.name = "[Forge Author or non-gerrit User]";
                p.author.username = "";
            } else {
                p.author = asAccountAttribute(authoId);
            }
            Change change = db.changes().get(pId.getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    final PatchSet.Id pId = patchSet.getId();
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            UserIdentity author = psInfoFactory.get(db, pId).getAuthor();
            if (author.getAccount() == null) {
                p.author = new AccountAttribute();
                p.author.email = author.getEmail();
                p.author.name = author.getName();
                p.author.username = "";
            } else {
                p.author = asAccountAttribute(author.getAccount());
            }
            Change change = db.changes().get(pId.getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> dashboards;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    final Project.NameKey projectName = new Project.NameKey(entityName);
                    final ProjectState projectState = projectCache.get(projectName);
                    if (defaultDashboard) {
                        dashboards = Maps.newTreeMap();
                        DashboardInfo info = findProjectDefaultDashboard(projectState);
                        dashboards.put(info.id, info);
                    } else {
                        dashboards = allDashboardsFor(projectState);
                    }
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            dashboards = Maps.newTreeMap();
        }
        format.newGson().toJson(dashboards, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> dashboards;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    final Project.NameKey projectName = new Project.NameKey(entityName);
                    final ProjectState projectState = projectCache.get(projectName);
                    DashboardInfo defaultInfo = findProjectDefaultDashboard(projectState);
                    if (defaultDashboard) {
                        dashboards = Maps.newTreeMap();
                        if (defaultInfo != null) {
                            dashboards.put(defaultInfo.id, defaultInfo);
                        }
                    } else {
                        dashboards = allDashboardsFor(projectState, defaultInfo != null ? defaultInfo.id : null);
                    }
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            dashboards = Maps.newTreeMap();
        }
        format.newGson().toJson(dashboards, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private Map<String, DashboardInfo> allDashboardsFor(ProjectState projectState) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    do {
        dashboards = addProjectDashboards(projectState, dashboards);
        parent = projectState.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        projectState = projectCache.get(parent);
    } while (projectState != null);
    projectState = projectCache.getAllProjects();
    parent = projectState.getProject().getNameKey();
    if (seen.add(parent)) {
        dashboards = addProjectDashboards(projectState, dashboards);
    }
    for (String id : dashboards.keySet()) {
        DashboardInfo info = dashboards.get(id);
        info.parameters = info.parameters.replaceAll("[$][{]project[}]", projectName.get());
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> allDashboardsFor(ProjectState projectState, final String defaultId) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    do {
        dashboards = addProjectDashboards(projectState, dashboards, defaultId);
        parent = projectState.getProject().getParent(allProjects);
        projectState = projectCache.get(parent);
    } while (projectState != null && seen.add(parent));
    for (String id : dashboards.keySet()) {
        replaceTokens(dashboards.get(id), projectName.get());
    }
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> addProjectDashboards(final ProjectState projectState, Map<String, DashboardInfo> all) {
    final Map<String, DashboardInfo> dashboards = projectDashboards(projectState);
    dashboards.putAll(all);
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> addProjectDashboards(final ProjectState projectState, Map<String, DashboardInfo> all, final String defaultId) {
    final Map<String, DashboardInfo> dashboards = projectDashboards(projectState, defaultId);
    dashboards.putAll(all);
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> projectDashboards(final ProjectState projectState) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return dashboards;
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        revWalk = new RevWalk(repo);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                dashboards.putAll(loadDashboards(projectControl.getProject(), repo, revWalk, ref));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get(), e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> projectDashboards(final ProjectState projectState, final String defaultId) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return dashboards;
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        revWalk = new RevWalk(repo);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                dashboards.putAll(loadDashboards(projectControl.getProject(), repo, revWalk, ref, defaultId));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get(), e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> loadDashboards(final Project project, final Repository repo, final RevWalk revWalk, final Ref ref) throws IOException {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        final RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            final DashboardInfo info = loadDashboard(project, ref.getName(), treeWalk.getPathString(), loader);
            dashboards.put(info.id, info);
        }
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } finally {
        treeWalk.release();
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> loadDashboards(final Project project, final Repository repo, final RevWalk revWalk, final Ref ref, final String defaultId) throws IOException {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        final RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            final DashboardInfo info = loadDashboard(project, ref.getName(), treeWalk.getPathString(), defaultId, loader);
            dashboards.put(info.id, info);
        }
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } finally {
        treeWalk.release();
    }
    return dashboards;
}
#end_block

#method_before
private DashboardInfo findProjectDefaultDashboard(ProjectState projectState) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    DashboardInfo info;
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    boolean considerLocal = true;
    do {
        info = loadProjectDefaultDashboard(projectState, considerLocal);
        if (info != null) {
            return info;
        }
        parent = projectState.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        projectState = projectCache.get(parent);
        considerLocal = false;
    } while (projectState != null);
    projectState = projectCache.getAllProjects();
    parent = projectState.getProject().getNameKey();
    if (seen.add(parent)) {
        info = loadProjectDefaultDashboard(projectState, considerLocal);
    }
    return info;
}
#method_after
private DashboardInfo findProjectDefaultDashboard(ProjectState projectState) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    DashboardInfo info;
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    boolean considerLocal = true;
    do {
        info = loadProjectDefaultDashboard(projectState, considerLocal);
        if (info != null) {
            replaceTokens(info, projectName.get());
            return info;
        }
        considerLocal = false;
        parent = projectState.getProject().getParent(allProjects);
        projectState = projectCache.get(parent);
    } while (projectState != null && seen.add(parent));
    return null;
}
#end_block

#method_before
private DashboardInfo loadProjectDefaultDashboard(final ProjectState projectState, boolean considerLocal) {
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return null;
    }
    final Project project = projectControl.getProject();
    String defaultDashboardId = project.getDefaultDashboard();
    if (considerLocal && project.getLocalDefaultDashboard() != null) {
        defaultDashboardId = project.getLocalDefaultDashboard();
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    DashboardInfo info = loadDashboard(projectControl, defaultDashboardId);
    info.parameters = info.parameters.replaceAll("[$][{]project[}]", projectName.get());
    return info;
}
#method_after
private DashboardInfo loadProjectDefaultDashboard(final ProjectState projectState, boolean considerLocal) {
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return null;
    }
    final Project project = projectControl.getProject();
    String defaultDashboardId = project.getDefaultDashboard();
    if (considerLocal && project.getLocalDefaultDashboard() != null) {
        defaultDashboardId = project.getLocalDefaultDashboard();
    }
    if (defaultDashboardId == null) {
        return null;
    }
    return loadDashboard(projectControl, defaultDashboardId, defaultDashboardId);
}
#end_block

#method_before
private DashboardInfo loadDashboard(final Project project, final String refName, final String path, final ObjectLoader loader) throws IOException, ConfigInvalidException {
    DashboardInfo info = new DashboardInfo();
    info.dashboardName = path;
    info.refName = refName;
    info.projectName = project.getName();
    info.id = createId(info.refName, info.dashboardName);
    final String defaultDashboardId = project.getLocalDefaultDashboard() != null ? project.getLocalDefaultDashboard() : project.getDefaultDashboard();
    info.isDefault = info.id.equals(defaultDashboardId);
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    loader.copyTo(out);
    Config dashboardConfig = new Config();
    dashboardConfig.fromText(new String(out.toByteArray(), "UTF-8"));
    info.description = dashboardConfig.getString("main", null, "description");
    final StringBuilder query = new StringBuilder();
    query.append("title=");
    query.append(info.dashboardName.replaceAll(" ", "+"));
    final Set<String> sections = dashboardConfig.getSubsections("section");
    for (final String section : sections) {
        query.append("&");
        query.append(section.replaceAll(" ", "+"));
        query.append("=");
        query.append(dashboardConfig.getString("section", section, "query"));
    }
    info.parameters = query.toString();
    return info;
}
#method_after
private DashboardInfo loadDashboard(final ProjectControl projectControl, final String dashboardId, final String defaultId) {
    StringTokenizer t = new StringTokenizer(dashboardId, ":");
    if (t.countTokens() != 2) {
        throw new IllegalStateException("failed to load dashboard, invalid dashboard id: " + dashboardId);
    }
    final String refName = t.nextToken();
    final String path = t.nextToken();
    Repository repo = null;
    RevWalk revWalk = null;
    TreeWalk treeWalk = null;
    try {
        repo = repoManager.openRepository(projectControl.getProject().getNameKey());
        final Ref ref = repo.getRef(refName);
        if (ref == null) {
            return null;
        }
        if (!projectControl.controlForRef(ref.getName()).canRead()) {
            return null;
        }
        revWalk = new RevWalk(repo);
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        treeWalk = new TreeWalk(repo);
        treeWalk.addTree(commit.getTree());
        treeWalk.setRecursive(true);
        treeWalk.setFilter(PathFilter.create(path));
        if (!treeWalk.next()) {
            return null;
        }
        final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
        return loadDashboard(projectControl.getProject(), refName, path, defaultId, loader);
    } catch (IOException e) {
        log.warn("Failed to load default dashboard", e);
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + projectControl.getProject().getName() + " from ref " + refName, e);
    } finally {
        if (treeWalk != null) {
            treeWalk.release();
        }
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return null;
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            p.author = asAccountAttribute(psInfoFactory.get(db, patchSet.getId()).getAuthor().getAccount());
            Change change = db.changes().get(patchSet.getId().getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(patchSet.getId());
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s ", patchSet.getId()), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get deletions and insertions for %s ", patchSet.getId()), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    final PatchSet.Id pId = patchSet.getId();
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            p.author = asAccountAttribute(psInfoFactory.get(db, pId).getAuthor().getAccount());
            Change change = db.changes().get(pId.getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    bind(GitReferenceUpdated.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), CommitValidatorListener.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    newProgress.end();
    doReplaces();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
                commandProgress.update(1);
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                addMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                addMessage("  " + url + c.getChangeId());
            }
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        if (cmd.getResult().equals(ReceiveCommand.Result.NOT_ATTEMPTED)) {
            cmd.execute(rp);
        }
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidatorListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.validate(cmd, project, ctl.getRefName(), c, currentUser);
        if (!validationResult.validated) {
            reject(cmd, validationResult.why);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        String pluginName = pluginLoader.getPluginName(validator);
        if (!validationResult.validated) {
            reject(cmd, String.format("%s (rejected by plugin %s)", validationResult.message, pluginName));
            return false;
        } else if (!Strings.isNullOrEmpty(validationResult.message)) {
            addMessage(String.format("%s (from plugin %s)", pluginName));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
public static CommitValidationResult newFailure(String why) {
    return new CommitValidationResult(false, why);
}
#method_after
public static CommitValidationResult newFailure(String message) {
    return new CommitValidationResult(false, message);
}
#end_block

#method_before
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    String browserCssName;
    String prettifyCssName;
    String prettifyJsName;
    serveRegex(ROOT_REGEX).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#method_after
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    serveRegex(ROOT_REGEX).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#end_block

#method_before
private void setDefaultFields(FilterConfig config) throws ServletException {
    if (renderer != null && urls != null && accessFactory != null && resolver != null && visibilityCache != null) {
        return;
    }
    String configPath = config.getInitParameter(CONFIG_PATH_PARAM);
    if (configPath == null) {
        throw new ServletException("Missing required parameter " + configPath);
    }
    FileBasedConfig jgitConfig = new FileBasedConfig(new File(configPath), FS.DETECTED);
    try {
        jgitConfig.load();
    } catch (IOException e) {
        throw new ServletException(e);
    } catch (ConfigInvalidException e) {
        throw new ServletException(e);
    }
    if (renderer == null) {
        String staticPrefix = config.getServletContext().getContextPath() + STATIC_PREFIX;
        String customTemplates = jgitConfig.getString("gitiles", null, "customTemplates");
        String siteTitle = jgitConfig.getString("gitiles", null, "siteTitle");
        // TODO(dborowitz): Automatically set to true when run with mvn jetty:run.
        if (jgitConfig.getBoolean("gitiles", null, "reloadTemplates", false)) {
            renderer = new DebugRenderer(staticPrefix, customTemplates, Joiner.on(File.separatorChar).join(System.getProperty("user.dir"), "gitiles-servlet", "src", "main", "resources", "com", "google", "gitiles", "templates"), siteTitle);
        } else {
            renderer = new DefaultRenderer(staticPrefix, Renderer.toFileURL(customTemplates), siteTitle);
        }
    }
    if (urls == null) {
        try {
            urls = new DefaultUrls(jgitConfig.getString("gitiles", null, "canonicalHostName"), getBaseGitUrl(jgitConfig), getGerritUrl(jgitConfig));
        } catch (UnknownHostException e) {
            throw new ServletException(e);
        }
    }
    linkifier = new Linkifier(urls);
    if (accessFactory == null || resolver == null) {
        String basePath = jgitConfig.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = jgitConfig.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<HttpServletRequest>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(jgitConfig), fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
    if (visibilityCache == null) {
        if (jgitConfig.getSubsections("cache").contains("visibility")) {
            visibilityCache = new VisibilityCache(false, ConfigUtil.getCacheBuilder(jgitConfig, "visibility"));
        } else {
            visibilityCache = new VisibilityCache(false);
        }
    }
}
#method_after
private void setDefaultFields(FilterConfig config) throws ServletException {
    if (renderer != null && urls != null && accessFactory != null && resolver != null && visibilityCache != null) {
        return;
    }
    String configPath = config.getInitParameter(CONFIG_PATH_PARAM);
    if (configPath == null) {
        throw new ServletException("Missing required parameter " + configPath);
    }
    FileBasedConfig jgitConfig = new FileBasedConfig(new File(configPath), FS.DETECTED);
    try {
        jgitConfig.load();
    } catch (IOException e) {
        throw new ServletException(e);
    } catch (ConfigInvalidException e) {
        throw new ServletException(e);
    }
    if (renderer == null) {
        String staticPrefix = config.getServletContext().getContextPath() + STATIC_PREFIX;
        String customTemplates = jgitConfig.getString("gitiles", null, "customTemplates");
        String siteTitle = Objects.firstNonNull(jgitConfig.getString("gitiles", null, "siteTitle"), "Gitiles");
        // TODO(dborowitz): Automatically set to true when run with mvn jetty:run.
        if (jgitConfig.getBoolean("gitiles", null, "reloadTemplates", false)) {
            renderer = new DebugRenderer(staticPrefix, customTemplates, Joiner.on(File.separatorChar).join(System.getProperty("user.dir"), "gitiles-servlet", "src", "main", "resources", "com", "google", "gitiles", "templates"), siteTitle);
        } else {
            renderer = new DefaultRenderer(staticPrefix, Renderer.toFileURL(customTemplates), siteTitle);
        }
    }
    if (urls == null) {
        try {
            urls = new DefaultUrls(jgitConfig.getString("gitiles", null, "canonicalHostName"), getBaseGitUrl(jgitConfig), getGerritUrl(jgitConfig));
        } catch (UnknownHostException e) {
            throw new ServletException(e);
        }
    }
    linkifier = new Linkifier(urls);
    if (accessFactory == null || resolver == null) {
        String basePath = jgitConfig.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = jgitConfig.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<HttpServletRequest>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(jgitConfig), fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
    if (visibilityCache == null) {
        if (jgitConfig.getSubsections("cache").contains("visibility")) {
            visibilityCache = new VisibilityCache(false, ConfigUtil.getCacheBuilder(jgitConfig, "visibility"));
        } else {
            visibilityCache = new VisibilityCache(false);
        }
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && ChangeUtil.canDoRebase(db, change, repoManager));
    detail.setCanEdit(control.getRefControl().canWrite());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<PatchSet.Id> descendants = new HashSet<PatchSet.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                if (descendants.add(a.getPatchSet())) {
                    changesToGet.add(a.getPatchSet().getParentKey());
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null && ac.getProject().equals(detail.getChange().getProject())) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final PatchSet.Id a : descendants) {
        final Change ac = m.get(a.getParentKey());
        if (ac != null && ac.currentPatchSetId().equals(a)) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#method_after
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    currentDepPatchSets = new ArrayList<PatchSet>();
    currentDepChanges = new ArrayList<Change>();
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    currentPatchSetAncestors = db.patchSetAncestors().ancestorsOf(psId).toList();
    for (PatchSetAncestor a : currentPatchSetAncestors) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            currentDepPatchSets.add(p);
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<PatchSet.Id> descendants = new HashSet<PatchSet.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                if (descendants.add(a.getPatchSet())) {
                    changesToGet.add(a.getPatchSet().getParentKey());
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final CurrentUser currentUser = control.getCurrentUser();
    Account.Id currentUserId = null;
    if (currentUser instanceof IdentifiedUser) {
        currentUserId = ((IdentifiedUser) currentUser).getAccountId();
    }
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null && ac.getProject().equals(detail.getChange().getProject())) {
            currentDepChanges.add(ac);
            if (ac.getStatus().getCode() != Change.STATUS_DRAFT || ac.getOwner().equals(currentUserId) || isReviewer(ac)) {
                dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
            }
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final PatchSet.Id a : descendants) {
        final Change ac = m.get(a.getParentKey());
        if (ac != null && ac.currentPatchSetId().equals(a)) {
            if (ac.getStatus().getCode() != Change.STATUS_DRAFT || ac.getOwner().equals(currentUserId) || isReviewer(ac)) {
                neededBy.add(newChangeInfo(ac, null));
            }
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
protected void doLogout(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    webSession.get().logout();
    if (logoutUrl != null) {
        rsp.sendRedirect(logoutUrl);
    } else {
        String url = urlProvider.get();
        if (Strings.isNullOrEmpty(url)) {
            url = req.getContextPath();
        }
        if (Strings.isNullOrEmpty(url)) {
            url = "/";
        }
        if (!url.endsWith("/")) {
            url += "/";
        }
        rsp.sendRedirect(url);
    }
}
#method_after
private void doLogout(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    webSession.get().logout();
    if (logoutUrl != null) {
        rsp.sendRedirect(logoutUrl);
    } else {
        String url = urlProvider.get();
        if (Strings.isNullOrEmpty(url)) {
            url = req.getContextPath();
        }
        if (Strings.isNullOrEmpty(url)) {
            url = "/";
        }
        if (!url.endsWith("/")) {
            url += "/";
        }
        rsp.sendRedirect(url);
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final String sid = webSession.get().getToken();
    final String username = webSession.get().getCurrentUser().getUserName();
    final String what = "sign out";
    final AuditEvent record = new AuditEvent(sid, username, what, null);
    try {
        doLogout(req, rsp);
    } finally {
        record.setResult("{\"Success\":true}");
        audit.track(record);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final String sid = webSession.get().getToken();
    final CurrentUser currentUser = webSession.get().getCurrentUser();
    final String what = "sign out";
    final long when = System.currentTimeMillis();
    try {
        doLogout(req, rsp);
    } finally {
        audit.dispatch(new AuditEvent(sid, currentUser, what, when, null, null));
    }
}
#end_block

#method_before
public void setSession(final ServerSession session) {
    final SshSession s = session.getAttribute(SshSession.KEY);
    this.ctx = new Context(s, commandLine);
}
#method_after
public void setSession(final ServerSession session) {
    final SshSession s = session.getAttribute(SshSession.KEY);
    this.ctx = sshScope.newContext(s, commandLine);
}
#end_block

#method_before
private void onStart() throws IOException {
    synchronized (this) {
        final Context old = SshScope.set(ctx);
        try {
            cmd = dispatcher.get();
            cmd.setArguments(argv);
            cmd.setInputStream(in);
            cmd.setOutputStream(out);
            cmd.setErrorStream(err);
            cmd.setExitCallback(new ExitCallback() {

                @Override
                public void onExit(int rc, String exitMessage) {
                    exit.onExit(translateExit(rc), exitMessage);
                    log(rc);
                }

                @Override
                public void onExit(int rc) {
                    exit.onExit(translateExit(rc));
                    log(rc);
                }
            });
            cmd.start(env);
        } finally {
            SshScope.set(old);
        }
    }
}
#method_after
private void onStart() throws IOException {
    synchronized (this) {
        final Context old = sshScope.set(ctx);
        try {
            cmd = dispatcher.get();
            cmd.setArguments(argv);
            cmd.setInputStream(in);
            cmd.setOutputStream(out);
            cmd.setErrorStream(err);
            cmd.setExitCallback(new ExitCallback() {

                @Override
                public void onExit(int rc, String exitMessage) {
                    exit.onExit(translateExit(rc), exitMessage);
                    log(rc);
                }

                @Override
                public void onExit(int rc) {
                    exit.onExit(translateExit(rc));
                    log(rc);
                }
            });
            cmd.start(env);
        } finally {
            sshScope.set(old);
        }
    }
}
#end_block

#method_before
private void onDestroy() {
    synchronized (this) {
        if (cmd != null) {
            final Context old = SshScope.set(ctx);
            try {
                cmd.destroy();
                log(BaseCommand.STATUS_CANCEL);
            } finally {
                ctx = null;
                cmd = null;
                SshScope.set(old);
            }
        }
    }
}
#method_after
private void onDestroy() {
    synchronized (this) {
        if (cmd != null) {
            final Context old = sshScope.set(ctx);
            try {
                cmd.destroy();
                log(BaseCommand.STATUS_CANCEL);
            } finally {
                ctx = null;
                cmd = null;
                sshScope.set(old);
            }
        }
    }
}
#end_block

#method_before
static String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean inDblQuote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || inDblQuote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                else
                    inDblQuote = !inDblQuote;
                continue;
            case '\'':
                if (inDblQuote)
                    r.append(b);
                else
                    inquote = !inquote;
                continue;
            case '\\':
                if (inquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#method_after
static public String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean inDblQuote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || inDblQuote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                else
                    inDblQuote = !inDblQuote;
                continue;
            case '\'':
                if (inDblQuote)
                    r.append(b);
                else
                    inquote = !inquote;
                continue;
            case '\\':
                if (inquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
void onLogin() {
    async.append(log("LOGIN FROM " + session.get().getRemoteAddressAsString()));
    audit("0", "LOGIN", Collections.emptyList());
}
#method_after
void onLogin() {
    async.append(log("LOGIN FROM " + session.get().getRemoteAddressAsString()));
    audit("0", "LOGIN", new String[] {});
}
#end_block

#method_before
void onAuthFail(final SshSession sd) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger (optional)
    null, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    "AUTH FAILURE FROM " + sd.getRemoteAddressAsString(), // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    event.setProperty(P_USER_NAME, sd.getUsername());
    final String error = sd.getAuthenticationError();
    if (error != null) {
        event.setProperty(P_STATUS, error);
    }
    async.append(event);
    audit("FAIL", "AUTH", Arrays.asList(sd.getRemoteAddressAsString()));
}
#method_after
void onAuthFail(final SshSession sd) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    "AUTH FAILURE FROM " + sd.getRemoteAddressAsString(), // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    event.setProperty(P_USER_NAME, sd.getUsername());
    final String error = sd.getAuthenticationError();
    if (error != null) {
        event.setProperty(P_STATUS, error);
    }
    async.append(event);
    audit("FAIL", "AUTH", new String[] { sd.getRemoteAddressAsString() });
}
#end_block

#method_before
void onExecute(int exitValue) {
    final Context ctx = context.get();
    ctx.finished = System.currentTimeMillis();
    final String commandLine = ctx.getCommandLine();
    String cmd = QuotedString.BOURNE.quote(commandLine);
    if (cmd == commandLine) {
        cmd = "'" + commandLine + "'";
    }
    final LoggingEvent event = log(cmd);
    event.setProperty(P_WAIT, (ctx.started - ctx.created) + "ms");
    event.setProperty(P_EXEC, (ctx.finished - ctx.started) + "ms");
    final String status;
    switch(exitValue) {
        case BaseCommand.STATUS_CANCEL:
            status = "killed";
            break;
        case BaseCommand.STATUS_NOT_FOUND:
            status = "not-found";
            break;
        case BaseCommand.STATUS_NOT_ADMIN:
            status = "not-admin";
            break;
        default:
            status = String.valueOf(exitValue);
            break;
    }
    event.setProperty(P_STATUS, status);
    async.append(event);
    audit(status, getCommand(commandLine), getCommandArgs(commandLine));
}
#method_after
void onExecute(int exitValue) {
    final Context ctx = context.get();
    ctx.finished = System.currentTimeMillis();
    final String commandLine = ctx.getCommandLine();
    String cmd = QuotedString.BOURNE.quote(commandLine);
    if (cmd == commandLine) {
        cmd = "'" + commandLine + "'";
    }
    final LoggingEvent event = log(cmd);
    event.setProperty(P_WAIT, (ctx.started - ctx.created) + "ms");
    event.setProperty(P_EXEC, (ctx.finished - ctx.started) + "ms");
    final String status;
    switch(exitValue) {
        case BaseCommand.STATUS_CANCEL:
            status = "killed";
            break;
        case BaseCommand.STATUS_NOT_FOUND:
            status = "not-found";
            break;
        case BaseCommand.STATUS_NOT_ADMIN:
            status = "not-admin";
            break;
        default:
            status = String.valueOf(exitValue);
            break;
    }
    event.setProperty(P_STATUS, status);
    async.append(event);
    audit(status, getCommand(commandLine), CommandFactoryProvider.split(commandLine));
}
#end_block

#method_before
void onLogout() {
    async.append(log("LOGOUT"));
    audit("0", "LOGOUT", Collections.emptyList());
}
#method_after
void onLogout() {
    async.append(log("LOGOUT"));
    audit("0", "LOGOUT", new String[] {});
}
#end_block

#method_before
private LoggingEvent log(final String msg) {
    final SshSession sd = session.get();
    final CurrentUser user = sd.getCurrentUser();
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger (optional)
    null, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    msg, // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    String userName = "-", accountId = "-";
    if (user instanceof IdentifiedUser) {
        IdentifiedUser u = (IdentifiedUser) user;
        userName = u.getAccount().getUserName();
        accountId = "a/" + u.getAccountId().toString();
    } else if (user instanceof PeerDaemonUser) {
        userName = PeerDaemonUser.USER_NAME;
    }
    event.setProperty(P_USER_NAME, userName);
    event.setProperty(P_ACCOUNT_ID, accountId);
    return event;
}
#method_after
private LoggingEvent log(final String msg) {
    final SshSession sd = session.get();
    final CurrentUser user = sd.getCurrentUser();
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    msg, // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    String userName = "-", accountId = "-";
    if (user instanceof IdentifiedUser) {
        IdentifiedUser u = (IdentifiedUser) user;
        userName = u.getAccount().getUserName();
        accountId = "a/" + u.getAccountId().toString();
    } else if (user instanceof PeerDaemonUser) {
        userName = PeerDaemonUser.USER_NAME;
    }
    event.setProperty(P_USER_NAME, userName);
    event.setProperty(P_ACCOUNT_ID, accountId);
    return event;
}
#end_block

#method_before
void audit(Object result, String commandName, List<?> args) {
    final Context ctx = context.get();
    final String sid = extractSessionId(ctx);
    final String username = extractUsername(ctx);
    final long elapsed = extractElapsed(ctx);
    final long created = extractCreated(ctx);
    final String what = extractWhat(commandName, args);
    auditService.track(new AuditEvent(sid, username, "ssh:" + what, created, args, result, elapsed));
}
#method_after
void audit(Object result, String commandName, String[] args) {
    final Context ctx = context.get();
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    final String what = extractWhat(commandName, args);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + what, created, Arrays.asList(args), result));
}
#end_block

#method_before
private String extractWhat(String commandName, List<?> args) {
    String result = commandName;
    if ("gerrit".equals(commandName)) {
        if (args.size() > 1)
            result = "gerrit" + "." + args.get(1);
    }
    return result;
}
#method_after
private String extractWhat(String commandName, String[] args) {
    String result = commandName;
    if ("gerrit".equals(commandName)) {
        if (args.length > 1)
            result = "gerrit" + "." + args[1];
    }
    return result;
}
#end_block

#method_before
@Override
protected GsonBuilder createGsonBuilder() {
    final GsonBuilder g = super.createGsonBuilder();
    g.registerTypeAdapter(org.eclipse.jgit.diff.Edit.class, new org.eclipse.jgit.diff.EditDeserializer());
    return g;
}
#method_after
@Override
protected GsonBuilder createGsonBuilder() {
    return gerritDefaultGsonBuilder();
}
#end_block

#method_before
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws IOException {
    try {
        super.service(req, resp);
    } finally {
        try {
            audit();
        } catch (Throwable ignoreExceptionWhileLogging) {
        } finally {
            currentCall.set(null);
        }
    }
}
#method_after
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws IOException {
    try {
        super.service(req, resp);
    } finally {
        audit();
        currentCall.set(null);
    }
}
#end_block

#method_before
private void audit() {
    try {
        GerritCall call = currentCall.get();
        Audit note = (Audit) call.getMethod().getAnnotation(Audit.class);
        if (note != null) {
            final Gson gson = createGsonBuilder().setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).setVersion(1.0).create();
            final String sid = call.getWebSession().getToken();
            final String username = extractUsername(call);
            final List<Object> args = extractParams(note, call, gson);
            final String what = extractWhat(note, call.getMethod().getName());
            final Object result = call.getResult();
            audit.track(new AuditEvent(sid, username, what, call.getWhen(), args, result, call.getElapsed()));
        }
    } catch (Throwable all) {
        LOG.error("Unable to log the call", all);
    }
}
#method_after
private void audit() {
    try {
        GerritCall call = currentCall.get();
        Audit note = (Audit) call.getMethod().getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getToken();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final List<Object> args = extractParams(note, call);
            final String what = extractWhat(note, call.getMethod().getName());
            final Object result = call.getResult();
            audit.dispatch(new AuditEvent(sid, username, what, call.getWhen(), args, result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#end_block

#method_before
private List<Object> extractParams(final Audit note, final GerritCall call, Gson gson) {
    final List<Object> args = new ArrayList<Object>();
    final Object[] params = call.getParams();
    final int[] obfuscate = note.obfuscate();
    for (int i = 0; i < params.length; i++) {
        Object param = params[i];
        if (obfuscate.length > 0) {
            for (int id : obfuscate) {
                if (id == i) {
                    param = "*****";
                    break;
                }
            }
        }
        args.add(param);
    }
    return args;
}
#method_after
private List<Object> extractParams(final Audit note, final GerritCall call) {
    List<Object> args = Lists.newArrayList(Arrays.asList(call.getParams()));
    for (int idx : note.obfuscate()) {
        args.set(idx, "*****");
    }
    return args;
}
#end_block

#method_before
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (Character.isLowerCase(c) != ccase) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#method_after
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (ccase && !Character.isLowerCase(c)) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#end_block

#method_before
public Object getResult() {
    try {
        return resultField.get(this);
    } catch (IllegalArgumentException e) {
        LOG.error("Cannot access result field");
    } catch (IllegalAccessException e) {
        LOG.error("No permissions to access result field");
    }
    return null;
}
#method_after
public Object getResult() {
    if (resultField == null) {
        return null;
    }
    try {
        return resultField.get(this);
    } catch (IllegalArgumentException e) {
        log.error("Cannot access result field");
    } catch (IllegalAccessException e) {
        log.error("No permissions to access result field");
    }
    return null;
}
#end_block

#method_before
@Override
public MethodHandle getMethod() {
    if (currentMethod.get() == null)
        return super.getMethod();
    else
        return currentMethod.get();
}
#method_after
@Override
public MethodHandle getMethod() {
    if (currentMethod.get() == null) {
        return super.getMethod();
    } else {
        return currentMethod.get();
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return asString().hashCode();
}
#method_after
@Override
public int hashCode() {
    return uuid.hashCode();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AuditEvent other = (AuditEvent) obj;
    return this.asString().equals(other.asString());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AuditEvent other = (AuditEvent) obj;
    return this.uuid.equals(other.uuid);
}
#end_block

#method_before
@Override
public String toString() {
    return asString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(uuid.toString());
    sb.append("|");
    sb.append(sessionId);
    sb.append('|');
    sb.append(who);
    sb.append('|');
    sb.append(when);
    sb.append('|');
    sb.append(what);
    sb.append('|');
    sb.append(elapsed);
    sb.append('|');
    if (params != null) {
        sb.append('[');
        for (int i = 0; i < params.size(); i++) {
            if (i > 0)
                sb.append(',');
            Object param = params.get(i);
            if (param == null) {
                sb.append("null");
            } else {
                sb.append(param);
            }
        }
        sb.append(']');
    }
    sb.append('|');
    if (result != null) {
        sb.append(result);
    }
    return sb.toString();
}
#end_block

#method_before
private InitStep loadInitStep(File jar) {
    try {
        ClassLoader pluginLoader = new URLClassLoader(new URL[] { jar.toURI().toURL() }, InitPluginStepsLoader.class.getClassLoader());
        JarFile jarFile = new JarFile(jar);
        Attributes jarFileAttributes = jarFile.getManifest().getMainAttributes();
        String initClassName = jarFileAttributes.getValue("Gerrit-InitStep");
        if (initClassName == null) {
            return null;
        }
        @SuppressWarnings("unchecked")
        Class<? extends InitStep> initStepClass = (Class<? extends InitStep>) pluginLoader.loadClass(initClassName);
        return initInjector.getInstance(initStepClass);
    } catch (ClassCastException e) {
        log.warn("InitStep from plugin " + jar.getName() + " does not implement " + InitStep.class.getName(), e);
        return null;
    } catch (Exception e) {
        log.error("Cannot load and get plugin init step for " + jar, e);
        return null;
    }
}
#method_after
private InitStep loadInitStep(File jar) {
    try {
        ClassLoader pluginLoader = new URLClassLoader(new URL[] { jar.toURI().toURL() }, InitPluginStepsLoader.class.getClassLoader());
        JarFile jarFile = new JarFile(jar);
        Attributes jarFileAttributes = jarFile.getManifest().getMainAttributes();
        String initClassName = jarFileAttributes.getValue("Gerrit-InitStep");
        if (initClassName == null) {
            return null;
        }
        @SuppressWarnings("unchecked")
        Class<? extends InitStep> initStepClass = (Class<? extends InitStep>) pluginLoader.loadClass(initClassName);
        return getPluginInjector(jar).getInstance(initStepClass);
    } catch (ClassCastException e) {
        ui.message("WARN: InitStep from plugin %s does not implement %s (Exception: %s)", jar.getName(), InitStep.class.getName(), e.getMessage());
        return null;
    } catch (Exception e) {
        ui.message("WARN: Cannot load and get plugin init step for %s (Exception: %s)", jar, e.getMessage());
        return null;
    }
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") && pathname.isFile());
        }
    });
    if (matches == null) {
        ui.message("WARN: Cannot list %s", pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    Arrays.sort(matches, new Comparator<File>() {

        @Override
        public int compare(File o1, File o2) {
            return o1.getName().compareTo(o2.getName());
        }
    });
    return Arrays.asList(matches);
}
#end_block

#method_before
private void initPlugins() throws Exception {
    Collection<? extends InitStep> pluginsInitSteps = pluginLoader.getInitSteps();
    for (InitStep initStep : pluginsInitSteps) {
        initStep.run();
    }
}
#method_after
private void initPlugins() throws Exception {
    for (InitStep initStep : pluginLoader.getInitSteps()) {
        initStep.run();
    }
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
            loadPlugins(result.plugnis);
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    });
}
#end_block

#method_before
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    loadPlugins(hpd, token);
}
#end_block

#method_before
private void loadPlugins(String[] pluginsUrls) {
    for (final String url : pluginsUrls) {
        ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

            @Override
            public void onSuccess(Void result) {
            // does nothing
            }

            @Override
            public void onFailure(Exception reason) {
                Window.alert("Failed load pluing: " + url);
            }
        }).inject();
    }
}
#method_after
private void loadPlugins(HostPageData hpd, final String token) {
    if (hpd.plugins != null) {
        for (final String url : hpd.plugins) {
            ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

                @Override
                public void onSuccess(Void result) {
                }

                @Override
                public void onFailure(Exception reason) {
                    ErrorDialog d = new ErrorDialog(reason);
                    d.setTitle(M.pluginFailed(url));
                    d.center();
                }
            }).inject();
        }
    }
    CallbackHandle<Void> cb = new CallbackHandle<Void>(new ResultDeserializer<Void>() {

        @Override
        public Void fromResult(JavaScriptObject responseObject) {
            return null;
        }
    }, new AsyncCallback<Void>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(Void result) {
            display(token);
        }
    });
    cb.install();
    ScriptInjector.fromString(cb.getFunctionName() + "();").setWindow(ScriptInjector.TOP_WINDOW).inject();
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar menuBar = new LinkMenuBar();
        addLink(menuBar, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(menuBar, C.menuPlugins(), PageLinks.ADMIN_PLUGINS);
                }
            }
        }, ADMINISTRATE_SERVER);
        menuLeft.add(menuBar, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar groupsBar = new LinkMenuBar();
        addLink(groupsBar, C.menuGroupsList(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_GROUP)) {
                    addLink(groupsBar, C.menuGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP);
                }
            }
        }, CREATE_GROUP);
        menuLeft.add(groupsBar, C.menuGroups());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(groupsBar) + 1);
                }
            }
        }, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = get().get(select(req));
    final byte[] raw;
    final CurrentUser user = currentUser.get();
    if (user instanceof IdentifiedUser) {
        final StringWriter w = new StringWriter();
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xsrfToken=");
        json(session.get().getToken(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
        final byte[] userData = w.toString().getBytes("UTF-8");
        raw = concat(page.part1, userData, page.part2);
    } else {
        raw = page.full;
    }
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = raw == page.full ? page.full_gz : HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = get().get(select(req));
    final StringWriter w = new StringWriter();
    final CurrentUser user = currentUser.get();
    if (user instanceof IdentifiedUser) {
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xsrfToken=");
        json(session.get().getToken(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    final byte[] hpd = w.toString().getBytes("UTF-8");
    final byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#end_block

#method_before
private void asScript(final Element scriptNode) {
    scriptNode.removeAttribute("id");
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#method_after
private void asScript(final Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#end_block

#method_before
@Override
public String getUrl() {
    // not used
    return null;
}
#method_after
@Override
public String getUrl() {
    // not used
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public String getUrl() {
    String database = optional(cfg, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    File db = site.resolve(database);
    try {
        db = db.getCanonicalFile();
    } catch (IOException e) {
        db = db.getAbsoluteFile();
    }
    return "jdbc:h2:" + db.toURI().toString();
}
#method_after
@Override
public String getUrl() {
    String database = cfg.getString("database", null, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    File db = site.resolve(database);
    try {
        db = db.getCanonicalFile();
    } catch (IOException e) {
        db = db.getAbsoluteFile();
    }
    return "jdbc:h2:" + db.toURI().toString();
}
#end_block

#method_before
@Override
public String getUrl() {
    return required(cfg, "url");
}
#method_after
@Override
public String getUrl() {
    return ConfigUtil.getRequired(cfg, "database", "url");
}
#end_block

#method_before
private DataSource open(final SitePaths site, final Config cfg, final Context context, final DataSourceType dst) {
    String driver = optional(cfg, "driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = optional(cfg, "url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = optional(cfg, "username");
    String password = optional(cfg, "password");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", 8));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        return ds;
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return new SimpleDataSource(p);
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#method_after
private DataSource open(final SitePaths site, final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", 8));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        return ds;
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return new SimpleDataSource(p);
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#end_block

#method_before
@Override
public final NamedInputStream getIndexScript() {
    return getScriptAsStream(indexScript);
}
#method_after
@Override
public ScriptRunner getIndexScript() throws IOException {
    return getScriptRunner("index_generic.sql");
}
#end_block

#method_before
@Override
public final NamedInputStream getNextValScript() {
    return getScriptAsStream(nextValScript);
}
#method_after
@Override
public ScriptRunner getNextValScript() throws IOException {
    return ScriptRunner.NOOP;
}
#end_block

#method_before
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    final JdbcExecutor e = new JdbcExecutor(jdbc);
    try {
        jdbc.updateSchema(e);
    } finally {
        e.close();
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = versionNbr;
    db.schemaVersion().insert(Collections.singleton(sVer));
    final SystemConfig sConfig = initSystemConfig(db);
    initVerifiedCategory(db);
    initCodeReviewCategory(db, sConfig);
    if (mgr != null) {
        // TODO This should never be null when initializing a site.
        initWildCardProject();
    }
    runScript(dataSourceType.getIndexScript(), db);
    runScript(dataSourceType.getNextValScript(), db);
}
#method_after
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    final JdbcExecutor e = new JdbcExecutor(jdbc);
    try {
        jdbc.updateSchema(e);
    } finally {
        e.close();
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = versionNbr;
    db.schemaVersion().insert(Collections.singleton(sVer));
    final SystemConfig sConfig = initSystemConfig(db);
    initVerifiedCategory(db);
    initCodeReviewCategory(db, sConfig);
    if (mgr != null) {
        // TODO This should never be null when initializing a site.
        initWildCardProject();
    }
    dataSourceType.getIndexScript().run(db);
    dataSourceType.getNextValScript().run(db);
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    b.append("jdbc:postgresql://");
    b.append(hostname(optional(cfg, "hostname")));
    b.append(port(optional(cfg, "port")));
    b.append("/");
    b.append(required(cfg, "database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbc = new ConfigSection(cfg, "database");
    b.append("jdbc:postgresql://");
    b.append(hostname(dbc.optional("hostname")));
    b.append(port(dbc.optional("port")));
    b.append("/");
    b.append(dbc.required("database"));
    return b.toString();
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    b.append("jdbc:mysql://");
    b.append(hostname(optional(cfg, "hostname")));
    b.append(port(optional(cfg, "port")));
    b.append("/");
    b.append(required(cfg, "database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbs = new ConfigSection(cfg, "database");
    b.append("jdbc:mysql://");
    b.append(hostname(dbs.optional("hostname")));
    b.append(port(dbs.optional("port")));
    b.append("/");
    b.append(dbs.required("database"));
    return b.toString();
}
#end_block

#method_before
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(getProjectKey(), branchName, rev, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            display(result.getBranches());
        }

        @Override
        public void onFailure(final Throwable caught) {
            addBranch.setEnabled(true);
            if (caught instanceof RemoteJsonException) {
                final String msg = caught.getMessage();
                String userMsg = null;
                if (InvalidNameException.MESSAGE.equals(msg)) {
                    selectAllAndFocus(nameTxtBox);
                    userMsg = Gerrit.M.invalidBranchName(branchName);
                } else if (InvalidRevisionException.MESSAGE.equals(msg)) {
                    selectAllAndFocus(irevTxtBox);
                    userMsg = Gerrit.M.invalidRevision(rev);
                } else if (msg.startsWith(BranchCreationNotAllowedUnderRefnamePrefixException.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String refnamePrefix = caught.getMessage().substring(BranchCreationNotAllowedUnderRefnamePrefixException.MESSAGE.length());
                    userMsg = Gerrit.M.branchCreationNotAllowedUnderRefnamePrefix(refnamePrefix);
                } else if (msg.startsWith(BranchAlreadyExistsException.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String existingBranchName = caught.getMessage().substring(BranchAlreadyExistsException.MESSAGE.length());
                    userMsg = Gerrit.M.branchAlreadyExists(existingBranchName);
                } else if (msg.startsWith(BranchCreationNotAllowedUnderExistingBranch.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String existingBranchName = caught.getMessage().substring(BranchCreationNotAllowedUnderExistingBranch.MESSAGE.length());
                    userMsg = Gerrit.M.branchCreationNotAllowedUnderExistingBranch(branchName, existingBranchName);
                }
                if (userMsg != null) {
                    new ErrorDialog(userMsg).center();
                    return;
                }
            }
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(getProjectKey(), branchName, rev, new GerritCallback<AddBranchResult>() {

        public void onSuccess(final AddBranchResult result) {
            addBranch.setEnabled(true);
            if (!result.hasError()) {
                nameTxtBox.setText("");
                irevTxtBox.setText("");
                display(result.getListBranchesResult().getBranches());
            } else {
                final AddBranchResult.Error error = result.getError();
                final String msg;
                switch(error.getType()) {
                    case INVALID_NAME:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.invalidBranchName(branchName);
                        break;
                    case INVALID_REVISION:
                        selectAllAndFocus(irevTxtBox);
                        msg = Gerrit.M.invalidRevision(rev);
                        break;
                    case BRANCH_CREATION_NOT_ALLOWED_UNDER_REFNAME_PREFIX:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchCreationNotAllowedUnderRefnamePrefix(error.getRefname());
                        break;
                    case BRANCH_ALREADY_EXISTS:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchAlreadyExists(error.getRefname());
                        break;
                    case BRANCH_CREATION_CONFLICT:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchCreationConflict(branchName, error.getRefname());
                        break;
                    default:
                        msg = Gerrit.M.branchCreationFailed(branchName, error.toString());
                }
                new ErrorDialog(msg).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void deleteChecked() {
    final StringBuilder message = new StringBuilder();
    message.append("<b>").append(Gerrit.C.branchDeletionConfirmationMessage()).append("</b>");
    message.append("<p>");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                message.append(", <br>");
            }
            message.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    message.append("</p>");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

        @Override
        public void onOk() {
            Util.PROJECT_SVC.deleteBranch(getProjectKey(), ids, new GerritCallback<Set<Branch.NameKey>>() {

                public void onSuccess(final Set<Branch.NameKey> deleted) {
                    for (int row = 1; row < table.getRowCount(); ) {
                        final Branch k = getRowItem(row);
                        if (k != null && deleted.contains(k.getNameKey())) {
                            table.removeRow(row);
                        } else {
                            row++;
                        }
                    }
                }
            });
        }
    });
    confirmationDialog.center();
}
#method_after
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchDeletionConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids);
        }
    });
    confirmationDialog.center();
}
#end_block

#method_before
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor(c.getLinkName(), false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor(c.getLinkName(), false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException, InvalidNameException, InvalidRevisionException, IOException, BranchCreationNotAllowedUnderRefnamePrefixException, BranchAlreadyExistsException, BranchCreationNotAllowedUnderExistingBranch {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        throw new InvalidNameException();
    }
    if (MagicBranch.isMagicBranch(refname)) {
        throw new BranchCreationNotAllowedUnderRefnamePrefixException(MagicBranch.getMagicRefNamePrefix(refname));
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName);
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    replication.scheduleUpdate(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(refname) != null) {
                        throw new BranchAlreadyExistsException(refname);
                    }
                    String refPrefix = getRefPrefix(refname);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new BranchCreationNotAllowedUnderExistingBranch(refPrefix);
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } finally {
        repo.close();
    }
    return listBranchesFactory.create(projectName).call();
}
#method_after
@Override
public AddBranchResult call() throws NoSuchProjectException, IOException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.INVALID_NAME, refname));
    }
    if (MagicBranch.isMagicBranch(refname)) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_CREATION_NOT_ALLOWED_UNDER_REFNAME_PREFIX, MagicBranch.getMagicRefNamePrefix(refname)));
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName);
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(refname) != null) {
                        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_ALREADY_EXISTS, refname));
                    }
                    String refPrefix = getRefPrefix(refname);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_CREATION_CONFLICT, refPrefix));
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.INVALID_REVISION));
    } finally {
        repo.close();
    }
    return new AddBranchResult(listBranchesFactory.create(projectName).call());
}
#end_block

#method_before
private String getRefPrefix(final String refName) {
    int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#method_after
private static String getRefPrefix(final String refName) {
    final int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#end_block

#method_before
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#method_after
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#end_block

#method_before
private void updateSuperProjects(final Branch.NameKey updatedBranch, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            String msgbuf = msg;
            if (msgbuf == null) {
                // Initialize the message buffer
                msgbuf = "";
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.statusCode == CommitMergeStatus.CLEAN_MERGE || c.statusCode == CommitMergeStatus.CLEAN_PICK || c.statusCode == CommitMergeStatus.CLEAN_REBASE)) {
                        msgbuf += "\n";
                        msgbuf += c.getFullMessage();
                    }
                }
            }
            // update subscribers of this module
            for (final SubmoduleSubscription s : subscribers) {
                if (!updatedSubscribers.add(s.getSuperProject())) {
                    log.error("Possible circular subscription involving " + s.toString());
                } else {
                    Map<Branch.NameKey, ObjectId> modules = new HashMap<Branch.NameKey, ObjectId>(1);
                    modules.put(updatedBranch, mergedCommit);
                    Map<Branch.NameKey, String> paths = new HashMap<Branch.NameKey, String>(1);
                    paths.put(updatedBranch, s.getPath());
                    try {
                        updateGitlinks(s.getSuperProject(), modules, paths, msgbuf);
                    } catch (SubmoduleException e) {
                        throw e;
                    }
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            String msgbuf = msg;
            if (msgbuf == null) {
                // Initialize the message buffer
                msgbuf = "";
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.statusCode == CommitMergeStatus.CLEAN_MERGE || c.statusCode == CommitMergeStatus.CLEAN_PICK || c.statusCode == CommitMergeStatus.CLEAN_REBASE)) {
                        msgbuf += "\n";
                        msgbuf += c.getFullMessage();
                    }
                }
            }
            // update subscribers of this module
            for (final SubmoduleSubscription s : subscribers) {
                if (!updatedSubscribers.add(s.getSuperProject())) {
                    log.error("Possible circular subscription involving " + s.toString());
                } else {
                    Map<Branch.NameKey, ObjectId> modules = new HashMap<Branch.NameKey, ObjectId>(1);
                    modules.put(updatedBranch, mergedCommit);
                    Map<Branch.NameKey, String> paths = new HashMap<Branch.NameKey, String>(1);
                    paths.put(updatedBranch, s.getPath());
                    try {
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, msgbuf);
                    } catch (SubmoduleException e) {
                        throw e;
                    }
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = rw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.release();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#method_after
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    try {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    } finally {
        rw.release();
    }
}
#end_block

#method_before
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            final boolean isMergeable = !toMerge.isEmpty() ? createStrategy().dryRun(branchTip, toMerge.remove(0)) : false;
            // update sha1 tested merge.
            if (destBranchRef != null) {
                change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
            } else {
                change.setLastSha1MergeTested(new RevId(""));
            }
            change.setMergeable(isMergeable);
            db.changes().update(Collections.singleton(change));
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            if (!toMerge.isEmpty()) {
                final Entry<SubmitType, CodeReviewCommit> e = toMerge.entries().iterator().next();
                final boolean isMergeable = createStrategy(e.getKey()).dryRun(branchTip, e.getValue());
                // update sha1 tested merge.
                if (destBranchRef != null) {
                    change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
                } else {
                    change.setLastSha1MergeTested(new RevId(""));
                }
                change.setMergeable(isMergeable);
                db.changes().update(Collections.singleton(change));
            } else {
                log.error("Test merge attempt for change: " + change.getId() + " failed");
            }
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        final List<Change> submitted = db.changes().submitted(destBranch).toList();
        final RefUpdate branchUpdate = openBranch();
        validateChangeList(submitted);
        preMerge();
        updateBranch(branchUpdate);
        updateChangeStatus(submitted);
        updateSubscriptions(submitted);
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        openBranch();
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<Project.SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                final RefUpdate branchUpdate = openBranch();
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.change, message(commit.change, capable.getMessage()), false);
            }
        }
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void preMerge() throws MergeException {
    final SubmitStrategy strategy = createStrategy();
    mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    commits.putAll(strategy.getNewCommits());
}
#method_after
private void preMerge(final SubmitStrategy strategy, final List<CodeReviewCommit> toMerge) throws MergeException {
    mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    commits.putAll(strategy.getNewCommits());
}
#end_block

#method_before
private SubmitStrategy createStrategy() throws MergeException {
    return submitStrategyFactory.create(destProject.getSubmitType(), db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, destProject.isUseContentMerge());
}
#method_after
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, destProject.isUseContentMerge());
}
#end_block

#method_before
private void validateChangeList(final List<Change> submitted) throws MergeException {
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        commit.add(canMergeFlag);
        toMerge.add(commit);
    }
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void updateBranch(final RefUpdate branchUpdate) throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_REBASE:
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db, repo);
    try {
        codeReviewNotes.create(merged, computeMergeCommitAuthor(db, identifiedUserFactory, myIdent, rw, merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.fire(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_REBASE:
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    potentiallyStillSubmittable.add(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db, repo);
    try {
        codeReviewNotes.create(merged, computeMergeCommitAuthor(db, identifiedUserFactory, myIdent, rw, merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.fire(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        capable = new Capable(txt);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#method_after
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change;
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        capable = new Capable(txt);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            PatchSetApproval submitter;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                    submitter = getSubmitter(reviewDb, c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (submitter != null) {
                    cm.setFrom(submitter.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m = newThreeWayMerger(args.repo, args.inserter, args.useContentMerge);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(newMergeTip, n)) {
                    newMergeTip = writeCherryPickCommit(m, newMergeTip, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.useContentMerge, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m = newThreeWayMerger(args.repo, args.inserter, args.useContentMerge);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(newMergeTip, n)) {
                    newMergeTip = writeCherryPickCommit(m, newMergeTip, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#end_block

#method_before
private CodeReviewCommit writeCherryPickCommit(final Merger m, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = args.db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = args.identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(args.inserter, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.rw.parseCommit(id);
    n.change.nextPatchSetId();
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#method_after
private CodeReviewCommit writeCherryPickCommit(final Merger m, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = args.db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = args.identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(args.inserter, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.rw.parseCommit(id);
    n.change.nextPatchSetId();
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#end_block

#method_before
public static void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
public static void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
public static ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            return createRandomObjectId();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#method_after
public static ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        private final MutableObjectId buf = new MutableObjectId();

        private final static int LAST_BYTE = Constants.OBJECT_ID_LENGTH - 1;

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            // create non-existing dummy ID
            buf.setByte(LAST_BYTE, buf.getByte(LAST_BYTE) + 1);
            return buf.copy();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#end_block

#method_before
public static CodeReviewCommit mergeOneCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final boolean useContentMerge, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(reviewDb, identifiedUserFactory, myIdent, rw, inserter, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(rw, mergeTip, n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return mergeTip;
}
#method_after
public static CodeReviewCommit mergeOneCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final boolean useContentMerge, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(reviewDb, identifiedUserFactory, myIdent, rw, inserter, canMergeFlag, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return mergeTip;
}
#end_block

#method_before
private static CodeReviewCommit failed(final RevWalk rw, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.statusCode = failure;
    }
    return failed;
}
#method_after
private static CodeReviewCommit failed(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.statusCode = failure;
    }
    return failed;
}
#end_block

#method_before
public static CodeReviewCommit writeMergeCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(reviewDb, identifiedUserFactory, myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#method_after
public static CodeReviewCommit writeMergeCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(reviewDb, identifiedUserFactory, myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#end_block

#method_before
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            final SubmitType submitType = toMerge.keys().iterator().next();
            preMerge(createStrategy(submitType), toMerge.get(submitType));
            // update sha1 tested merge.
            if (destBranchRef != null) {
                change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
            } else {
                change.setLastSha1MergeTested(new RevId(""));
            }
            change.setMergeable(isMergeable(change));
            db.changes().update(Collections.singleton(change));
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            final SubmitType submitType = toMerge.keySet().iterator().next();
            preMerge(createStrategy(submitType), toMerge.get(submitType));
            // update sha1 tested merge.
            if (destBranchRef != null) {
                change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
            } else {
                change.setLastSha1MergeTested(new RevId(""));
            }
            change.setMergeable(isMergeable(change));
            db.changes().update(Collections.singleton(change));
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        openBranch();
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            for (final SubmitType submitType : toMerge.keys()) {
                final RefUpdate branchUpdate = openBranch();
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.change, message(commit.change, capable.getMessage()), false);
            }
        }
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        openBranch();
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<Project.SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                final RefUpdate branchUpdate = openBranch();
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.change, message(commit.change, capable.getMessage()), false);
            }
        }
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                    }
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            PatchSetApproval submitter;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                    submitter = getSubmitter(reviewDb, c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (submitter != null) {
                    cm.setFrom(submitter.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        final RevWalk recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.release();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    int h = 0;
    h = h * 31 + aId.hashCode();
    h = h * 31 + bId.hashCode();
    h = h * 31 + ignoreWhitespace.hashCode();
    return h;
}
#method_after
@Override
public int hashCode() {
    int h = 0;
    h = h * 31 + aId.hashCode();
    h = h * 31 + bId.hashCode();
    h = h * 31 + (ignoreWhitespace ? 1 : 0);
    return h;
}
#end_block

#method_before
@Override
public boolean equals(final Object o) {
    if (o instanceof IntraLineDiffKey) {
        final IntraLineDiffKey k = (IntraLineDiffKey) o;
        return // 
        aId.equals(k.aId) && // 
        bId.equals(k.bId) && ignoreWhitespace.equals(k.ignoreWhitespace);
    }
    return false;
}
#method_after
@Override
public boolean equals(final Object o) {
    if (o instanceof IntraLineDiffKey) {
        final IntraLineDiffKey k = (IntraLineDiffKey) o;
        return // 
        aId.equals(k.aId) && // 
        bId.equals(k.bId) && ignoreWhitespace == k.ignoreWhitespace;
    }
    return false;
}
#end_block

#method_before
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer();
}
#method_after
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon();
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#method_after
public boolean canRestore() {
    return // Anyone who can abandon the change can restore it back
    canAbandon() && // as long as you can upload too
    getRefControl().canUpload();
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    return evaluatePrologRules(db, patchSet, cd, fastEvalLabels, "submit_rule", "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, change, cd, fastEvalLabels, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#end_block

#method_before
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#method_after
public static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case FAST_FORWARD_ONLY:
                            break;
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                        default:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                        case FAST_FORWARD_ONLY:
                            // Not mergeable, no need to recheck.
                            break;
                        default:
                            log.warn("Lock failure in project with unknown merge type " + destProject.getSubmitType());
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeSubmitRecords) {
                    try {
                        PatchSet.Id psId = d.getChange().currentPatchSetId();
                        Change.Id changeId = psId.getParentKey();
                        ChangeControl control = changeControlFactory.validateFor(changeId);
                        List<SubmitRecord> submitResult = control.canSubmit(db.get(), psId);
                        eventFactory.addSubmitRecords(c, submitResult);
                    } catch (OrmException e) {
                    // Squash DB exceptions and leave submit records partially filled
                    } catch (NoSuchChangeException e) {
                    // Squash DB exceptions and leave submit records partially filled
                    }
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    Change.Id changeId = psId.getParentKey();
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
public void addSubmitRecords(ChangeAttribute ca, List<SubmitRecord> submitRecords) {
    ca.submitRecords = new ArrayList<SubmitRecordAttribute>();
    for (SubmitRecord submitRecord : submitRecords) {
        SubmitRecordAttribute sa = new SubmitRecordAttribute();
        switch(submitRecord.status) {
            case OK:
                sa.status = "OK";
                break;
            case NOT_READY:
                sa.status = "NOT_READY";
                if (!submitRecord.labels.isEmpty()) {
                    sa.labels = new ArrayList<SubmitLabelAttribute>();
                    for (SubmitRecord.Label lbl : submitRecord.labels) {
                        SubmitLabelAttribute la = new SubmitLabelAttribute();
                        la.label = lbl.label;
                        switch(lbl.status) {
                            case OK:
                                la.status = "OK";
                                break;
                            case REJECT:
                                la.status = "REJECT";
                                break;
                            case NEED:
                                la.status = "NEED";
                                break;
                            case IMPOSSIBLE:
                                la.status = "IMPOSSIBLE";
                                break;
                            default:
                                throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                        }
                        sa.labels.add(la);
                    }
                }
                break;
            case CLOSED:
                sa.status = "CLOSED";
                break;
            case RULE_ERROR:
                sa.status = "RULE_ERROR";
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
        ca.submitRecords.add(sa);
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.submitRecords.isEmpty()) {
        ca.submitRecords = null;
    }
}
#method_after
public void addSubmitRecords(ChangeAttribute ca, List<SubmitRecord> submitRecords) {
    ca.submitRecords = new ArrayList<SubmitRecordAttribute>();
    for (SubmitRecord submitRecord : submitRecords) {
        SubmitRecordAttribute sa = new SubmitRecordAttribute();
        sa.status = submitRecord.status.name();
        if (submitRecord.status != SubmitRecord.Status.RULE_ERROR) {
            addSubmitRecordLabels(submitRecord, sa);
        }
        ca.submitRecords.add(sa);
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.submitRecords.isEmpty()) {
        ca.submitRecords = null;
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd);
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd);
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            final Image readOnlyIcon = new Image(Gerrit.RESOURCES.readonly());
            readOnlyIcon.setTitle(Gerrit.C.userCannotVoteToolTip());
            table.setWidget(row, col, readOnlyIcon);
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String token = "token=" + verifier.encode(currentUser.get().getUserName(), getReqUrl(req));
    sendText(req, res, token);
}
#method_after
@Override
protected final void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    CurrentUser user = userProvider.get();
    if (!(user instanceof IdentifiedUser)) {
        sendError(res, SC_UNAUTHORIZED, "API requires authentication");
        return;
    }
    TokenInfo info = new TokenInfo();
    info._authkey = verifier.sign(((IdentifiedUser) user).getAccountId(), computeUrl(req));
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    String type;
    buf.write(JSON_MAGIC);
    if (acceptsJson(req)) {
        type = JSON_TYPE;
        buf.write(gson.toJson(info).getBytes(UTF_8));
    } else {
        type = FORM_ENCODED;
        buf.write(String.format("%s=%s", AUTHKEY_NAME, URLEncoder.encode(info._authkey, UTF_8)).getBytes(UTF_8));
    }
    res.setContentType(type);
    res.setCharacterEncoding(UTF_8);
    res.setHeader("Content-Disposition", "attachment");
    send(req, res, buf.toByteArray());
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    noCache(res);
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        res.setStatus(HttpServletResponse.SC_FORBIDDEN);
        noCache(res);
        sendText(req, res, err.getMessage());
    } catch (Error err) {
        handleError(err, req, res);
    } catch (RuntimeException err) {
        handleError(err, req, res);
    }
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        sendError(res, SC_FORBIDDEN, err.getMessage());
    } catch (Error err) {
        handleException(err, req, res);
    } catch (RuntimeException err) {
        handleException(err, req, res);
    }
}
#end_block

#method_before
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), ((IdentifiedUser) user).getNameEmail()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#method_after
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), user instanceof IdentifiedUser ? ((IdentifiedUser) user).getNameEmail() : user.toString()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#end_block

#method_before
protected static void sendText(HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#method_after
protected static void sendText(@Nullable HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#end_block

#method_before
protected static void send(HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#method_after
protected static void send(@Nullable HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && req != null && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(Request req, Response res) {
    String text = res.getText();
    if (text.startsWith("token=")) {
        RestApi.this.sendPost(cb, text);
        return;
    }
    RpcStatus.INSTANCE.onRpcComplete();
    int status = res.getStatusCode();
    if (status != 200) {
        if ((400 <= status && status < 500) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json.substring(JSON_MAGIC.length()));
    } catch (RuntimeException e) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
}
#method_after
@Override
public void onResponseReceived(Request req, Response res) {
    int status = res.getStatusCode();
    if (status != 200) {
        RpcStatus.INSTANCE.onRpcComplete();
        if ((400 <= status && status < 600) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    json = json.substring(JSON_MAGIC.length());
    if (wasGet && json.startsWith("{\"_authkey\":")) {
        RestApi.this.resendPost(cb, json);
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json);
    } catch (RuntimeException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
    RpcStatus.INSTANCE.onRpcComplete();
}
#end_block

#method_before
public RestApi addParameter(String name, int value) {
    return addParameterRaw(name, String.valueOf(value));
}
#method_after
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#end_block

#method_before
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#method_after
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(true, cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#end_block

#method_before
private void populateReviewedPanel() {
    reviewedPanel.clear();
    reviewedCheckBox = new CheckBox(PatchUtil.C.reviewedAnd() + " ");
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    reviewedPanel.add(reviewedCheckBox);
    reviewedAnchor = getReviewedAnchor();
    reviewedPanel.add(reviewedAnchor);
}
#method_after
private void populateReviewedPanel() {
    reviewedPanel.clear();
    reviewedCheckBox = new CheckBox(PatchUtil.C.reviewedAnd() + " ");
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(getReviewedAnchor());
}
#end_block

#method_before
private Anchor getReviewedAnchor() {
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(PatchUtil.C.next());
    text.append(SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    Anchor reviewedAnchor = new Anchor("");
    SafeHtml.set(reviewedAnchor, text);
    reviewedAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setReviewedByCurrentUser(true);
        }
    });
    final PatchValidator unreviewedValidator = new PatchValidator() {

        public boolean isValid(Patch patch) {
            return !patch.isReviewedByCurrentUser();
        }
    };
    int nextUnreviewedPatchIndex = fileList.getNextPatch(patchIndex, true, unreviewedValidator, fileList.PREFERENCE_VALIDATOR);
    if (nextUnreviewedPatchIndex > -1) {
        // Create invisible patch link to change page
        final PatchLink reviewedLink = fileList.createLink(nextUnreviewedPatchIndex, getPatchScreenType(), null, null);
        reviewedLink.setText("");
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                reviewedLink.go();
            }
        });
    } else {
        final ChangeLink upLink = new ChangeLink("", patchKey.getParentKey());
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                upLink.go();
            }
        });
    }
    return reviewedAnchor;
}
#method_after
private Anchor getReviewedAnchor() {
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(PatchUtil.C.next());
    text.append(SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    Anchor reviewedAnchor = new Anchor("");
    SafeHtml.set(reviewedAnchor, text);
    final PatchValidator unreviewedValidator = new PatchValidator() {

        public boolean isValid(Patch patch) {
            return !patch.isReviewedByCurrentUser();
        }
    };
    int nextUnreviewedPatchIndex = fileList.getNextPatch(patchIndex, true, unreviewedValidator, fileList.PREFERENCE_VALIDATOR);
    if (nextUnreviewedPatchIndex > -1) {
        // Create invisible patch link to change page
        reviewedLink = fileList.createLink(nextUnreviewedPatchIndex, getPatchScreenType(), null, null);
        reviewedLink.setText("");
    } else {
        reviewedLink = new ChangeLink("", patchKey.getParentKey());
    }
    reviewedAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setReviewedByCurrentUser(true);
            reviewedLink.go();
        }
    });
    return reviewedAnchor;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewedPanel);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    if (Gerrit.isSignedIn()) {
        keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
        keysAction.add(new MarkAsReviewedAndGoToNextCmd(0, 'v', PatchUtil.C.markAsReviewedAndGoToNext()));
    }
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader(getPatchScreenType());
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewedPanel);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    if (Gerrit.isSignedIn()) {
        keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
        keysAction.add(new ToggleReviewedCmd(0, 'm', PatchUtil.C.toggleReviewed()));
        keysAction.add(new MarkAsReviewedAndGoToNextCmd(0, 'M', PatchUtil.C.markAsReviewedAndGoToNext()));
    }
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader(getPatchScreenType());
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (reviewedAnchor != null) {
        DomEvent.fireNativeEvent(Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false), reviewedAnchor);
    }
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (reviewedLink != null) {
        setReviewedByCurrentUser(true);
        reviewedLink.go();
    }
}
#end_block

#method_before
@Deprecated
public Change.Id getId() {
    return changeId;
}
#method_after
public Change.Id getId() {
    return changeId;
}
#end_block

#method_before
@Deprecated
public int getChangeId() {
    return changeId.get();
}
#method_after
public int getChangeId() {
    return changeId.get();
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case ALREADY_MERGED:
                {
                    setMerged(c, null);
                    break;
                }
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    String str = dependencyError(commit);
                    if (submitStillPossible) {
                        if (str != null) {
                            sendMergeFail(c, message(c, str), false, false);
                        }
                    } else {
                        setNew(c, message(c, str));
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).runTestMerge(change);
}
#method_after
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).verifyMergeability(change);
}
#end_block

#method_before
public static void submit(MergeOp.Factory opFactory, PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db, MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (change.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, change.getDest());
    }
}
#method_after
public static void submit(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db, final MergeOp.Factory opFactory, final MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, updatedChange.getDest());
    }
}
#end_block

#method_before
public static PatchSetApproval createSubmitApproval(PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#method_after
public static PatchSetApproval createSubmitApproval(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canPushToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    return Capable.OK;
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
    ChangeUtil.testMerge(opFactory, change);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    ChangeUtil.testMerge(opFactory, change);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                change.setLastSha1MergeTested(null);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        ChangeUtil.mergeTestChangesByBranch(opFactory, destBranch);
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    if (!isMergeable) {
        final Label lbl = new Label();
        lbl.setText(Util.C.messageMergeFail());
        actionsPanel.add(lbl);
    }
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && allowedSchemes.contains(DownloadScheme.ANON_GIT)) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.setEnabled(isMergeable);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new RestoreChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display("change,publish," + patchSet.getId().toString(), new PublishCommentScreen(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display(Dispatcher.toPublish(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
    errorlabel.setText(Util.C.messageMergeFail());
    body.add(errorlabel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
}
#end_block

#method_before
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    for (final ApprovalType ct : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        if (r.isAllowed(ct.getCategory().getId())) {
            initApprovalType(r, body, ct);
        }
    }
}
#method_after
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    ApprovalTypes types = Gerrit.getConfig().getApprovalTypes();
    for (PermissionRange range : r.getLabels()) {
        ApprovalType type = types.byLabel(range.getLabel());
        if (type != null) {
            // Legacy type, use radio buttons.
            initApprovalType(r, body, type, range);
        } else {
        // TODO Newer style label.
        }
    }
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final Set<ApprovalCategoryValue.Id> allowed = r.getAllowed(catId);
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!allowed.contains(buttonValue.getId())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.isSubmitAllowed());
    submit.setEnabled(r.getChange().isMergeable());
    errorlabel.setVisible(!r.getChange().isMergeable());
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }
    });
}
#method_after
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private String toHTML(SparseFileContent src) {
    SafeHtml html;
    if (diffPrefs.isIntralineDifference()) {
        html = colorLineEdits(src);
    } else {
        SafeHtmlBuilder b = new SafeHtmlBuilder();
        for (int index = src.first(); index < src.size(); index = src.next(index)) {
            b.append(src.get(index));
            b.append('\n');
        }
        html = b;
        final String r = // 
        "<span class=\"wse\"" + " title=\"" + PrettifyConstants.C.wseBareCR() + // 
        "\"" + ">&nbsp;</span>$1";
        html = html.replaceAll("\r([^\n])", r);
    }
    if (diffPrefs.isShowWhitespaceErrors()) {
        // We need to do whitespace errors before showing tabs, because
        // these patterns rely on \t as a literal, before it expands.
        // 
        html = showTabAfterSpace(html);
        html = showTrailingWhitespace(html);
    }
    if (diffPrefs.isShowCrLf()) {
        html = showCrLf(html);
    }
    if (diffPrefs.isShowTabs()) {
        String t = 1 < diffPrefs.getTabSize() ? "\t" : "";
        html = html.replaceAll("\t", "<span class=\"vt\">\u00BB</span>" + t);
    }
    return html.asString();
}
#method_after
private String toHTML(SparseFileContent src) {
    SafeHtml html;
    if (diffPrefs.isIntralineDifference()) {
        html = colorLineEdits(src);
    } else {
        SafeHtmlBuilder b = new SafeHtmlBuilder();
        for (int index = src.first(); index < src.size(); index = src.next(index)) {
            b.append(src.get(index));
            b.append('\n');
        }
        html = b;
        final String r = // 
        "<span class=\"wse\"" + " title=\"" + PrettifyConstants.C.wseBareCR() + // 
        "\"" + ">&nbsp;</span>$1";
        html = html.replaceAll("\r([^\n])", r);
    }
    if (diffPrefs.isShowWhitespaceErrors()) {
        // We need to do whitespace errors before showing tabs, because
        // these patterns rely on \t as a literal, before it expands.
        // 
        html = showTabAfterSpace(html);
        html = showTrailingWhitespace(html);
    }
    if (diffPrefs.isShowLineEndings()) {
        html = showLineEndings(html);
    }
    if (diffPrefs.isShowTabs()) {
        String t = 1 < diffPrefs.getTabSize() ? "\t" : "";
        html = html.replaceAll("\t", "<span class=\"vt\">\u00BB</span>" + t);
    }
    return html.asString();
}
#end_block

#method_before
private void appendShowBareCR(SafeHtmlBuilder buf, String src, boolean end) {
    while (!src.isEmpty()) {
        int cr = src.indexOf('\r');
        if (cr < 0) {
            buf.append(src);
            return;
        } else if (end) {
            if (cr == src.length() - 1) {
                buf.append(src.substring(0, cr + 1));
                return;
            }
        } else if (cr == src.length() - 2 && src.charAt(cr + 1) == '\n') {
            buf.append(src.substring(0, cr + 1));
            buf.append('\n');
            return;
        }
        buf.append(src.substring(0, cr));
        buf.openSpan();
        buf.setStyleName("wse");
        buf.setAttribute("title", PrettifyConstants.C.wseBareCR());
        buf.nbsp();
        buf.closeSpan();
        src = src.substring(cr + 1);
    }
}
#method_after
private void appendShowBareCR(SafeHtmlBuilder buf, String src, boolean end) {
    while (!src.isEmpty()) {
        int cr = src.indexOf('\r');
        if (cr < 0) {
            buf.append(src);
            return;
        } else if (end) {
            if (cr == src.length() - 1) {
                buf.append(src.substring(0, cr + 1));
                return;
            }
        } else if (cr == src.length() - 2 && src.charAt(cr + 1) == '\n') {
            buf.append(src);
            return;
        }
        buf.append(src.substring(0, cr));
        buf.openSpan();
        buf.setStyleName("wse");
        buf.setAttribute("title", PrettifyConstants.C.wseBareCR());
        buf.nbsp();
        buf.closeSpan();
        src = src.substring(cr + 1);
    }
}
#end_block

#method_before
protected void display() {
    final AccountDiffPreference dp = getValue();
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    crlfErrors.setValue(dp.isShowCrLf());
    showTabs.setValue(dp.isShowTabs());
    skipDeleted.setValue(dp.isSkipDeleted());
    skipUncommented.setValue(dp.isSkipUncommented());
    expandAllComments.setValue(dp.isExpandAllComments());
    retainHeader.setValue(dp.isRetainHeader());
    manualReview.setValue(dp.isManualReview());
}
#method_after
protected void display() {
    final AccountDiffPreference dp = getValue();
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    showLineEndings.setValue(dp.isShowLineEndings());
    showTabs.setValue(dp.isShowTabs());
    skipDeleted.setValue(dp.isSkipDeleted());
    skipUncommented.setValue(dp.isSkipUncommented());
    expandAllComments.setValue(dp.isExpandAllComments());
    retainHeader.setValue(dp.isRetainHeader());
    manualReview.setValue(dp.isManualReview());
}
#end_block

#method_before
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowCrLf(crlfErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    dp.setExpandAllComments(expandAllComments.getValue());
    dp.setRetainHeader(retainHeader.getValue());
    dp.setManualReview(manualReview.getValue());
    listenablePrefs.set(dp);
}
#method_after
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowLineEndings(showLineEndings.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    dp.setExpandAllComments(expandAllComments.getValue());
    dp.setRetainHeader(retainHeader.getValue());
    dp.setManualReview(manualReview.getValue());
    listenablePrefs.set(dp);
}
#end_block

#method_before
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowCrLf(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    return p;
}
#method_after
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowLineEndings(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    return p;
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    if (query.length() == 0) {
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#method_after
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    // NOTE: this method is not called if the query is empty.
    if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions.tailSet(lastWord)) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            if (suggestion.contains("self") && !Gerrit.isSignedIn()) {
                continue;
            }
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (names != null && !names.isEmpty()) {
        try {
            loader.enablePlugins(Sets.newHashSet(names));
        } catch (PluginInstallException e) {
            e.printStackTrace(stderr);
            throw die("plugin failed to install");
        }
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (names != null && !names.isEmpty()) {
        try {
            loader.enablePlugins(Sets.newHashSet(names));
        } catch (PluginInstallException e) {
            e.printStackTrace(stderr);
            throw die("plugin failed to enable");
        }
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        String name = nameOf(jar);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        String name = nameOf(jar);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private void runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        unload.remove(nameOf(jar));
    }
    for (String name : unload) {
        log.info(String.format("Unloading plugin %s", name));
        running.remove(name).stop();
    }
}
#method_after
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        log.info(String.format("Unloading plugin %s", name));
        running.remove(name).stop();
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        unload.remove(nameOf(jar));
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    for (index--; index > -1; index--) {
        InlineHyperlink link = createLink(index, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    int previousPatchIndex = getPreviousPatch(index, PREFERENCE_VALIDATOR);
    if (previousPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(previousPatchIndex, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
    return link;
}
#end_block

#method_before
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    for (index++; index < patchList.size(); index++) {
        InlineHyperlink link = createLink(index, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    int nextPatchIndex = getNextPatch(index, false, PREFERENCE_VALIDATOR);
    if (nextPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(nextPatchIndex, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    return link;
}
#end_block

#method_before
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    if ((listenablePrefs.get().isSkipDeleted() && patch.getChangeType().equals(ChangeType.DELETED)) || (listenablePrefs.get().isSkipUncommented() && patch.getCommentCount() == 0)) {
        return null;
    }
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
public PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    loadedInfoTable(detail);
    loadedActionPanel(detail);
    loadedPatchTable(detail);
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    loadInfoTable(detail);
    loadActionPanel(detail);
    loadPatchTable(detail);
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(parent.shortMessage));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(Util.cropSubject(parent.shortMessage)));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
public void refresh() {
    if (patchSet.getId().equals(diffBaseId)) {
        if (patchTable != null) {
            patchTable.setVisible(false);
        }
        if (actionsPanel != null) {
            actionsPanel.setVisible(false);
        }
    } else {
        if (patchTable != null) {
            if (patchTable.getBase() == null && diffBaseId == null || patchTable.getBase() != null && patchTable.getBase().equals(diffBaseId)) {
                actionsPanel.setVisible(true);
                patchTable.setVisible(true);
                return;
            }
        }
        AccountDiffPreference diffPrefs;
        if (patchTable == null) {
            diffPrefs = new ListenableAccountDiffPreference().get();
        } else {
            diffPrefs = patchTable.getPreferences().get();
            patchTable.setVisible(false);
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                if (actionsPanel != null) {
                    actionsPanel.setVisible(true);
                } else {
                    loadedActionPanel(result);
                }
                loadedPatchTable(result);
            }
        });
    }
}
#method_after
public void refresh() {
    if (patchSet.getId().equals(diffBaseId)) {
        if (patchTable != null) {
            patchTable.setVisible(false);
        }
        if (actionsPanel != null) {
            actionsPanel.setVisible(false);
        }
    } else {
        if (patchTable != null) {
            if (patchTable.getBase() == null && diffBaseId == null || patchTable.getBase() != null && patchTable.getBase().equals(diffBaseId)) {
                actionsPanel.setVisible(true);
                patchTable.setVisible(true);
                return;
            }
        }
        AccountDiffPreference diffPrefs;
        if (patchTable == null) {
            diffPrefs = new ListenableAccountDiffPreference().get();
        } else {
            diffPrefs = patchTable.getPreferences().get();
            patchTable.setVisible(false);
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                if (actionsPanel != null) {
                    actionsPanel.setVisible(true);
                } else {
                    loadActionPanel(result);
                }
                loadPatchTable(result);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                loadedInfoTable(result);
                loadedActionPanel(result);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                loadInfoTable(result);
                loadActionPanel(result);
            }
        });
    }
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    Map<String, PluginInfo> output = Maps.newTreeMap();
    List<Plugin> plugins = Lists.newArrayList(pluginLoader.getPlugins(all));
    Collections.sort(plugins, new Comparator<Plugin>() {

        @Override
        public int compare(Plugin a, Plugin b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (!format.isJson()) {
        stdout.format("%-30s %-10s\n", "Name", "Version");
        stdout.print("----------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = new PluginInfo();
        info.version = p.getVersion();
        info.isDisabled = p.isDisabled();
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s\n", p.getName() + (info.isDisabled ? " (DISABLED)" : ""), Strings.nullToEmpty(info.version));
        }
    }
    if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    Map<String, PluginInfo> output = Maps.newTreeMap();
    List<Plugin> plugins = Lists.newArrayList(pluginLoader.getPlugins(all));
    Collections.sort(plugins, new Comparator<Plugin>() {

        @Override
        public int compare(Plugin a, Plugin b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (!format.isJson()) {
        stdout.format("%-30s %-10s %-8s\n", "Name", "Version", "Status");
        stdout.print("-------------------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = new PluginInfo();
        info.version = p.getVersion();
        info.disabled = p.isDisabled() ? true : null;
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s %-8s\n", p.getName(), Strings.nullToEmpty(info.version), p.isDisabled() ? "DISABLED" : "");
        }
    }
    if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
}
#end_block

#method_before
private void runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private void runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            return (pathname.getName().endsWith(".jar") || pathname.getName().endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#end_block

#method_before
public void add(RegistrationHandle handle) {
    if (handle instanceof ReloadableRegistrationHandle) {
        if (reloadableHandles == null) {
            reloadableHandles = Lists.newArrayList();
        }
        reloadableHandles.add((ReloadableRegistrationHandle<?>) handle);
    }
    manager.add(handle);
}
#method_after
public void add(RegistrationHandle handle) {
    if (manager != null) {
        if (handle instanceof ReloadableRegistrationHandle) {
            if (reloadableHandles == null) {
                reloadableHandles = Lists.newArrayList();
            }
            reloadableHandles.add((ReloadableRegistrationHandle<?>) handle);
        }
        manager.add(handle);
    }
}
#end_block

#method_before
private void createReviewedPanel() {
    reviewedPanel = new FlowPanel();
    reviewedCheckBox = new CheckBox();
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    Anchor reviewedAnchor = new Anchor(PatchUtil.C.reviewed());
    reviewedAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setReviewedByCurrentUser(true);
        }
    });
    final PatchValidator unreviewedValidator = new PatchValidator() {

        public boolean isValid(Patch patch) {
            return !patch.isReviewedByCurrentUser();
        }
    };
    int nextUnreviewedPatchIndex = patchSetDetail.getNextPatch(patchIndex, true, unreviewedValidator, fileList.PREFERENCE_VALIDATOR);
    if (nextUnreviewedPatchIndex > -1) {
        // Create invisible patch link to change page
        final PatchLink reviewedLink = fileList.createLink(nextUnreviewedPatchIndex, getPatchScreenType(), null, null);
        reviewedLink.setText("");
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                reviewedLink.go();
            }
        });
    } else {
        final ChangeLink upLink = new ChangeLink("", patchKey.getParentKey());
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                upLink.go();
            }
        });
    }
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(reviewedAnchor);
}
#method_after
private void createReviewedPanel() {
    reviewedPanel = new FlowPanel();
    reviewedCheckBox = new CheckBox(PatchUtil.C.reviewedAnd() + " ");
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(getReviewedAnchor());
}
#end_block

#method_before
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    int previousPatchIndex = detail.getPreviousPatch(index, PREFERENCE_VALIDATOR);
    if (previousPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(previousPatchIndex, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
    return link;
}
#method_after
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    int previousPatchIndex = getPreviousPatch(index, PREFERENCE_VALIDATOR);
    if (previousPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(previousPatchIndex, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
    return link;
}
#end_block

#method_before
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    int nextPatchIndex = detail.getNextPatch(index, false, PREFERENCE_VALIDATOR);
    if (nextPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(nextPatchIndex, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    return link;
}
#method_after
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    int nextPatchIndex = getNextPatch(index, false, PREFERENCE_VALIDATOR);
    if (nextPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(nextPatchIndex, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    return link;
}
#end_block

#method_before
public PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS, sugestParent);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectListPopup.setCoordinates(top, left);
            projectListPopup.display();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.suggestParentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.parentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                continue;
            }
            if (!isVisible && !(showTree && pctl.isOwner())) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && format.isJson() || (type == FilterType.SUGGEST_PARENT_CANDIDATES)) {
                ProjectState parent = e.getParentState();
                if (parent != null) {
                    ProjectControl parentCtrl = parent.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                            info.name = parent.getProject().getName();
                            info.description = parent.getProject().getDescription();
                            if (format.isJson()) {
                                output.put(info.name, info);
                            }
                            continue;
                        }
                        info.parent = parent.getProject().getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getProject().getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getProject().getName(), info.parent);
                        }
                    }
                } else {
                    if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                        continue;
                    }
                }
            }
            info.name = projectName.get();
            if (showDescription && !e.getProject().getDescription().isEmpty()) {
                info.description = e.getProject().getDescription();
            }
            try {
                if (showBranch != null) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = Maps.newLinkedHashMap();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    } finally {
                        git.close();
                    }
                } else if (!showTree && type != FilterType.ALL) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                    } finally {
                        git.close();
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + info.description.replace("\n", "\\n"));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = e.getParentState();
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = parentState.getProject().getDescription();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final ProjectControl pctl = e.controlFor(currentUser);
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = e.getParentState();
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription && !e.getProject().getDescription().isEmpty()) {
                    info.description = e.getProject().getDescription();
                }
                try {
                    if (showBranch != null) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
    resetHandlerRegistration();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    vp = new VerticalPanel();
    addCreateProjectPanel();
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
    projectListPopup.addProjectListPopupHandler(new ProjectListPopupHandler() {

        @Override
        public void onClose(ProjectListPopupOnCloseEvent projectListPopupEvent) {
            resetHandlerRegistration();
        }

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            sugestParent.setText(projectListPopupEvent.getProjectName());
        }

        @Override
        public void onMovePointer(ProjectListPopupOnMovePointerEvent projectListPopupEvent) {
            // prevent user input from being overwritten by simply poping up
            if (!projectListPopupEvent.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectListPopupEvent.getProjectName());
            }
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#end_block

#method_before
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    final HorizontalPanel bp = new HorizontalPanel();
    bp.add(create);
    fp.add(bp);
    vp.add(fp);
    initSuggestedParents();
    add(vp);
}
#method_after
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    fp.add(create);
    VerticalPanel vp = new VerticalPanel();
    vp.add(fp);
    initSuggestedParents();
    vp.add(suggestedParentsTab);
    add(vp);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    vp.add(suggestedParentsTab);
    Util.PROJECT_SVC.suggestParentCandidates(new AsyncCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.permissions(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS, nameTxt, this);
    projectListPopup.addProjectListPopupOnOpenRowHandler(new ProjectListPopup.ProjectListPopupOnOpenRowHandler() {

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            doAddNew();
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(nameBox.getText())) {
                nameBox.setText(projectName);
            }
        }

        @Override
        protected void openRow(String projectName) {
            nameBox.setText(projectName);
            doAddNew();
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS);
}
#end_block

#method_before
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            calculatePopupCoordinates();
            projectListPopup.display();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#method_after
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
protected void initPopup() {
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            if (top + offsetHeight > Window.getClientWidth()) {
                top = Window.getClientWidth() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#method_after
public void initPopup(final String popupText, final String currentPageLink) {
    createWidgets(popupText, currentPageLink);
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    sp.setSize("100%", "100%");
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popup.setHeight("100%");
    popupPosition = getPositionCallback();
}
#end_block

#method_before
protected void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            handlerManager.fireEvent(new ProjectListPopupOnMovePointerEvent(popingUp, getRowItem(row).getName()));
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            handlerManager.fireEvent(new ProjectListPopupOnOpenRowEvent(getRowItem(row).getName()));
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
            handlerManager.fireEvent(new ProjectListPopupOnCloseEvent());
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#method_after
private void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            onMovePointerTo(getRowItem(row).name());
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            openRow(getRowItem(row).name());
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#end_block

#method_before
public void closePopup() {
    popup.hide();
    resetHandlerRegistration();
}
#method_after
public void closePopup() {
    popup.hide();
}
#end_block

#method_before
protected void populateProjects() {
    Util.PROJECT_SVC.visibleProjects(new GerritCallback<ProjectList>() {

        @Override
        public void onSuccess(final ProjectList result) {
            projectsTab.display(result.getProjects());
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                display();
            }
        }
    });
}
#method_after
protected void populateProjects() {
    ProjectMap.all(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(final ProjectMap result) {
            projectsTab.display(result);
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                displayPopup();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader(getPatchScreenType());
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(script, patchKey, idSideA, idSideB, getPatchScreenType());
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(patchSetDetail, script, patchKey, idSideA, idSideB);
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
public void display(final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB, final PatchScreen.Type type) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.screenType = type;
    this.links = new LinkedList<Anchor>();
    linkPanel.add(new Label(PatchUtil.C.patchSet() + " "));
    if (side == Side.A) {
        addLink("Base", null);
    } else {
        links.add(null);
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    downloadLink();
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new LinkedList<Anchor>();
    if (screenType == PatchScreen.Type.UNIFIED) {
        sideMarker.setInnerText((side == Side.A) ? "(-)" : "(+)");
    }
    if (detail.getInfo().getParents().size() > 1) {
        addLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        addLink(PatchUtil.C.patchBase(), null);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = getDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(new Label(" - "));
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key k = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, k));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, k));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#method_after
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key keySideB = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, keySideB));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, keySideB));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#end_block

#method_before
public void display(PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB, PatchScreen.Type type) {
    listA.display(script, patchKey, idSideA, idSideB, type);
    listB.display(script, patchKey, idSideA, idSideB, type);
    if (type == PatchScreen.Type.UNIFIED) {
        aligner.getStyle().setDisplay(Display.NONE);
    }
}
#method_after
public void display(final PatchSetDetail detail, PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB) {
    listA.display(detail, script, patchKey, idSideA, idSideB);
    listB.display(detail, script, patchKey, idSideA, idSideB);
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        String parentMsg = parent.shortMessage;
        if (parentMsg.length() > 80) {
            parentMsg = parentMsg.substring(0, 80) + "...";
        }
        parentsTable.setWidget(row, 1, new InlineLabel(parentMsg));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(Util.cropSubject(parent.shortMessage)));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or change/patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSetIds.addAll(parsePatchSetId(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSetIds.addAll(parsePatchSetId(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#end_block

#method_before
public BanCommitResult ban(final ProjectControl projectControl, final List<ObjectId> commitsToBan, final String reason) throws PermissionDeniedException, IOException, IncompleteUserInfoException, InterruptedException, MergeException {
    if (!projectControl.isOwner()) {
        throw new PermissionDeniedException("No project owner: not permitted to ban commits");
    }
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // add a note for each banned commit to notes
    final Repository repo = repoManager.openRepository(projectControl.getProject().getNameKey());
    final RevWalk revWalk = new RevWalk(repo);
    final ObjectInserter inserter = repo.newObjectInserter();
    try {
        for (final ObjectId commitToBan : commitsToBan) {
            try {
                revWalk.parseCommit(commitToBan);
            } catch (MissingObjectException e) {
            // ignore exception, also not existing commits can be banned
            } catch (IncorrectObjectTypeException e) {
                result.notACommit(commitToBan, e.getMessage());
                continue;
            }
            banCommitNotes.set(commitToBan, createNoteContent(reason, inserter));
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(repo);
        NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REF_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
        for (Note n : banCommitNotes) {
            if (newlyCreated.contains(n)) {
                result.commitBanned(n);
            } else {
                result.commitAlreadyBanned(n);
            }
        }
        return result;
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#method_after
public BanCommitResult ban(final ProjectControl projectControl, final List<ObjectId> commitsToBan, final String reason) throws PermissionDeniedException, IOException, InterruptedException, MergeException, ConcurrentRefUpdateException {
    if (!projectControl.isOwner()) {
        throw new PermissionDeniedException("No project owner: not permitted to ban commits");
    }
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // add a note for each banned commit to notes
    final Repository repo = repoManager.openRepository(projectControl.getProject().getNameKey());
    try {
        final RevWalk revWalk = new RevWalk(repo);
        final ObjectInserter inserter = repo.newObjectInserter();
        try {
            for (final ObjectId commitToBan : commitsToBan) {
                try {
                    revWalk.parseCommit(commitToBan);
                } catch (MissingObjectException e) {
                // ignore exception, also not existing commits can be banned
                } catch (IncorrectObjectTypeException e) {
                    result.notACommit(commitToBan, e.getMessage());
                    continue;
                }
                banCommitNotes.set(commitToBan, createNoteContent(reason, inserter));
            }
            inserter.flush();
            NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(repo);
            NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REF_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
            for (Note n : banCommitNotes) {
                if (newlyCreated.contains(n)) {
                    result.commitBanned(n);
                } else {
                    result.commitAlreadyBanned(n);
                }
            }
            return result;
        } finally {
            revWalk.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private ObjectId createNoteContent(String reason, ObjectInserter inserter) throws UnsupportedEncodingException, IOException {
    String noteContent = reason != null ? reason : "";
    if (!noteContent.endsWith("\n")) {
        noteContent = noteContent + "\n";
    }
    return inserter.insert(Constants.OBJ_BLOB, noteContent.getBytes("UTF-8"));
}
#method_after
private ObjectId createNoteContent(String reason, ObjectInserter inserter) throws UnsupportedEncodingException, IOException {
    String noteContent = reason != null ? reason : "";
    if (noteContent.length() > 0 && !noteContent.endsWith("\n")) {
        noteContent = noteContent + "\n";
    }
    return inserter.insert(Constants.OBJ_BLOB, noteContent.getBytes("UTF-8"));
}
#end_block

#method_before
private PersonIdent createPersonIdent() throws IncompleteUserInfoException {
    final String userName = currentUser.get().getUserName();
    final Account account = accountCache.getByUsername(userName).getAccount();
    if (account.getFullName() == null) {
        throw new IncompleteUserInfoException(userName, "full name");
    }
    if (account.getPreferredEmail() == null) {
        throw new IncompleteUserInfoException(userName, "preferred email");
    }
    return new PersonIdent(account.getFullName(), account.getPreferredEmail());
}
#method_after
private PersonIdent createPersonIdent() {
    Date now = new Date();
    TimeZone tz = gerritIdent.getTimeZone();
    return currentUser.get().newCommitterIdent(now, tz);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ListProjects.class);
    bind(ApprovalsUtil.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    bind(AccountControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    install(new AsyncReceiveCommits.Module());
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ListProjects.class);
    bind(ApprovalsUtil.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    bind(AccountControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    install(new AsyncReceiveCommits.Module());
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new EhcachePoolImpl.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                    factory(NotesBranchUtil.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new DefaultCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                    factory(NotesBranchUtil.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#end_block

#method_before
public void create(List<CodeReviewCommit> commits, PersonIdent author) throws CodeReviewNoteCreationException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        if (author != null) {
            this.author = author;
        }
        NoteMap notes = NoteMap.newEmptyMap();
        StringBuilder message = new StringBuilder("Update notes for submitted changes\n\n");
        for (CodeReviewCommit c : commits) {
            notes.set(c, createNoteContent(c.change, c));
            message.append("* ").append(c.getShortMessage()).append("\n");
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(db);
        notesBranchUtil.commitAllNotes(notes, REFS_NOTES_REVIEW, author, message.toString());
    } catch (IOException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#method_after
public void create(List<CodeReviewCommit> commits, PersonIdent author) throws CodeReviewNoteCreationException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        if (author != null) {
            this.author = author;
        }
        NoteMap notes = NoteMap.newEmptyMap();
        StringBuilder message = new StringBuilder("Update notes for submitted changes\n\n");
        for (CodeReviewCommit c : commits) {
            notes.set(c, createNoteContent(c.change, c));
            message.append("* ").append(c.getShortMessage()).append("\n");
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(db);
        notesBranchUtil.commitAllNotes(notes, REFS_NOTES_REVIEW, author, message.toString());
    } catch (IOException e) {
        throw new CodeReviewNoteCreationException(e);
    } catch (ConcurrentRefUpdateException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#end_block

#method_before
public void create(List<Change> changes, PersonIdent author, String commitMessage, ProgressMonitor monitor) throws OrmException, IOException, CodeReviewNoteCreationException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        if (author != null) {
            this.author = author;
        }
        if (monitor == null) {
            monitor = NullProgressMonitor.INSTANCE;
        }
        NoteMap notes = NoteMap.newEmptyMap();
        for (Change c : changes) {
            monitor.update(1);
            PatchSet ps = schema.patchSets().get(c.currentPatchSetId());
            if (ps == null) {
                continue;
            }
            ObjectId commitId = ObjectId.fromString(ps.getRevision().get());
            notes.set(commitId, createNoteContent(c, commitId));
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(db);
        notesBranchUtil.commitAllNotes(notes, REFS_NOTES_REVIEW, author, commitMessage);
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#method_after
public void create(List<Change> changes, PersonIdent author, String commitMessage, ProgressMonitor monitor) throws OrmException, IOException, CodeReviewNoteCreationException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        if (author != null) {
            this.author = author;
        }
        if (monitor == null) {
            monitor = NullProgressMonitor.INSTANCE;
        }
        NoteMap notes = NoteMap.newEmptyMap();
        for (Change c : changes) {
            monitor.update(1);
            PatchSet ps = schema.patchSets().get(c.currentPatchSetId());
            ObjectId commitId = ObjectId.fromString(ps.getRevision().get());
            notes.set(commitId, createNoteContent(c, commitId));
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(db);
        notesBranchUtil.commitAllNotes(notes, REFS_NOTES_REVIEW, author, commitMessage);
    } catch (ConcurrentRefUpdateException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        revWalk.release();
        inserter.release();
    }
}
#end_block

#method_before
public final void commitAllNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException {
    this.overwrite = true;
    commitNotes(notes, notesBranch, commitAuthor, commitMessage);
}
#method_after
public final void commitAllNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException, ConcurrentRefUpdateException {
    this.overwrite = true;
    commitNotes(notes, notesBranch, commitAuthor, commitMessage);
}
#end_block

#method_before
public final NoteMap commitNewNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException {
    this.overwrite = false;
    commitNotes(notes, notesBranch, commitAuthor, commitMessage);
    NoteMap newlyCreated = NoteMap.newEmptyMap();
    for (Note n : notes) {
        if (!base.contains(n)) {
            newlyCreated.set(n, n.getData());
        }
    }
    return newlyCreated;
}
#method_after
public final NoteMap commitNewNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException, ConcurrentRefUpdateException {
    this.overwrite = false;
    commitNotes(notes, notesBranch, commitAuthor, commitMessage);
    NoteMap newlyCreated = NoteMap.newEmptyMap();
    for (Note n : notes) {
        if (base == null || !base.contains(n)) {
            newlyCreated.set(n, n.getData());
        }
    }
    return newlyCreated;
}
#end_block

#method_before
private void commitNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        reader = db.newObjectReader();
        loadBase(notesBranch);
        if (overwrite) {
            addAllNotes(notes);
        } else {
            addNewNotes(notes);
        }
        if (base != null) {
            oursCommit = createCommit(ours, commitAuthor, commitMessage, baseCommit);
        } else {
            oursCommit = createCommit(ours, commitAuthor, commitMessage);
        }
        updateRef(notesBranch);
    } catch (InterruptedException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (ConcurrentRefUpdateException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } finally {
        revWalk.release();
        inserter.release();
        reader.release();
    }
}
#method_after
private void commitNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException, ConcurrentRefUpdateException {
    try {
        revWalk = new RevWalk(db);
        inserter = db.newObjectInserter();
        reader = db.newObjectReader();
        loadBase(notesBranch);
        if (overwrite) {
            addAllNotes(notes);
        } else {
            addNewNotes(notes);
        }
        if (base != null) {
            oursCommit = createCommit(ours, commitAuthor, commitMessage, baseCommit);
        } else {
            oursCommit = createCommit(ours, commitAuthor, commitMessage);
        }
        updateRef(notesBranch);
    } finally {
        revWalk.release();
        inserter.release();
        reader.release();
    }
}
#end_block

#method_before
private void addAllNotes(NoteMap notes) throws IOException {
    for (Note n : notes) {
        if (ours.contains(n)) {
            // merge the existing and the new note as if they are both new
            // means: base == null
            // there is not really a common ancestry for these two note revisions
            // use the same NoteMerger that is used from the NoteMapMerger
            NoteMerger noteMerger = new ReviewNoteMerger();
            ObjectId noteContent = noteMerger.merge(null, n, ours.getNote(n), reader, inserter).getData();
            ours.set(n, noteContent);
        } else {
            ours.set(n, n.getData());
        }
    }
}
#method_after
private void addAllNotes(NoteMap notes) throws IOException {
    for (Note n : notes) {
        if (ours.contains(n)) {
            // Merge the existing and the new note as if they are both new,
            // means: base == null
            // There is no really a common ancestry for these two note revisions
            NoteMerger noteMerger = new ReviewNoteMerger();
            ObjectId noteContent = noteMerger.merge(null, n, ours.getNote(n), reader, inserter).getData();
            ours.set(n, noteContent);
        } else {
            ours.set(n, n.getData());
        }
    }
}
#end_block

#method_before
private void loadBase(String notesBranch) throws IOException {
    Ref branch = db.getRef(notesBranch);
    if (branch != null) {
        baseCommit = revWalk.parseCommit(branch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
}
#method_after
private void loadBase(String notesBranch) throws IOException {
    Ref branch = db.getRef(notesBranch);
    if (branch != null) {
        baseCommit = revWalk.parseCommit(branch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
    if (baseCommit != null) {
        ours = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
}
#end_block

#method_before
private void updateRef(String notesBranch) throws IOException, InterruptedException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, db.getRef(notesBranch), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            break;
        }
    }
}
#method_after
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, db.getRef(notesBranch), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            break;
        }
    }
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String[] auths = new String(decoded, encoding(req)).split(":");
    if (auths.length < 2) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = auths[0];
    String password = auths[1];
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = getAuthRequest(who, password);
    if (whoAuth == null) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        session.get().setUserAccountId(whoAuthResult.getAccountId(), AuthMethod.PASSWORD);
        return true;
    } catch (AccountException e) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null) {
        // 
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        session.get().setUserAccountId(whoAuthResult.getAccountId(), AuthMethod.PASSWORD);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private String encoding(HttpServletRequest req) {
    String encoding = req.getCharacterEncoding();
    if (encoding == null)
        encoding = "UTF-8";
    return encoding;
}
#method_after
private String encoding(HttpServletRequest req) {
    return Objects.firstNonNull(req.getCharacterEncoding(), "UTF-8");
}
#end_block

#method_before
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append("Basic");
        v.append(" realm=\"" + REALM_NAME + "\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#method_after
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append(LIT_BASIC);
        v.append("realm=\"" + REALM_NAME + "\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, RepositoryNotFoundException, IOException {
    final AbandonChange abandonChange = abandonChangeFactory.get();
    abandonChange.setChangeId(patchSetId.getParentKey());
    abandonChange.setMessage(message);
    final ReviewResult result = abandonChange.call();
    if (result.getErrors().size() > 0) {
        throw new NoSuchChangeException(result.getChangeId());
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, RepositoryNotFoundException, IOException {
    final AbandonChange abandonChange = abandonChangeProvider.get();
    abandonChange.setChangeId(patchSetId.getParentKey());
    abandonChange.setMessage(message);
    final ReviewResult result = abandonChange.call();
    if (result.getErrors().size() > 0) {
        throw new NoSuchChangeException(result.getChangeId());
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure, RepositoryNotFoundException, IOException {
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final AbandonChange abandonChange = abandonChangeFactory.get();
            abandonChange.setChangeId(patchSetId.getParentKey());
            abandonChange.setMessage(changeComment);
            final ReviewResult result = abandonChange.call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId.getParentKey(), changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure, RepositoryNotFoundException, IOException {
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final AbandonChange abandonChange = abandonChangeProvider.get();
            abandonChange.setChangeId(patchSetId.getParentKey());
            abandonChange.setMessage(changeComment);
            final ReviewResult result = abandonChange.call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId.getParentKey(), changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change/patch set";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case NOT_A_DRAFT:
                errMsg += "change is not a draft";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            case DEST_BRANCH_NOT_FOUND:
                errMsg += "destination branch not found";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case CHANGE_NOT_ABANDONED:
                errMsg += "change is not abandoned";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change/patch set";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case NOT_A_DRAFT:
                errMsg += "change is not a draft";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            case DEST_BRANCH_NOT_FOUND:
                errMsg += "destination branch not found";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final Change change = db.changes().get(changeId);
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canAbandon()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.ABANDON_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the abandoned change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
        if (message != null && message.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(message);
        }
        cmsg.setMessage(msgBuf.toString());
        // Abandon the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, abandonedSenderFactory, "Change is no longer open or patchset is not latest");
        hooks.doChangeAbandonedHook(updatedChange, currentUser.getAccount(), message, db);
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    if (changeId == null) {
        throw new InvalidChangeOperationException("changeId is required");
    }
    final ReviewResult result = new ReviewResult();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final Change change = db.changes().get(changeId);
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canAbandon()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.ABANDON_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the abandoned change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
        if (message != null && message.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(message);
        }
        cmsg.setMessage(msgBuf.toString());
        // Abandon the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (updatedChange == null) {
            result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
            return result;
        }
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, abandonedSenderFactory);
        hooks.doChangeAbandonedHook(updatedChange, currentUser.getAccount(), message, db);
    }
    return result;
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, repoManager, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase());
    detail.setCanEdit(control.getRefControl().canWrite());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final RevId cprev = loader.patchSet.getRevision();
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    if (cprev != null) {
        for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
            final Change.Id ck = a.getPatchSet().getParentKey();
            if (descendants.add(ck)) {
                changesToGet.add(a.getPatchSet().getParentKey());
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#method_after
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                final Change.Id ck = a.getPatchSet().getParentKey();
                if (descendants.add(ck)) {
                    changesToGet.add(ck);
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#end_block

#method_before
@Override
public ReviewResult call() throws IllegalStateException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, repoManager, patchSetId);
    if (submitResult.isEmpty()) {
        throw new IllegalStateException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
                break;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws IllegalStateException, InvalidChangeOperationException, NoSuchChangeException, OrmException, IOException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, patch);
    if (submitResult.isEmpty()) {
        throw new IllegalStateException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case MAY:
                            // The MAY label didn't cause the NOT_READY status
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
    }
    if (!ProjectUtil.branchExists(repoManager, control.getChange().getDest())) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.DEST_BRANCH_NOT_FOUND, "Destination branch \"" + control.getChange().getDest().get() + "\" not found."));
        return result;
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
                break;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent event) {
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent event) {
    resetEditors();
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final Set<String> diffs = new HashSet<String>();
            final Map<String, AccessSection> wantedSections = new HashMap<String, AccessSection>();
            for (final AccessSection section : wantedAccess.getLocal()) {
                wantedSections.put(section.getName(), section);
            }
            for (final AccessSection newSection : newAccess.getLocal()) {
                final AccessSection wantedSection = wantedSections.remove(newSection.getName());
                if (wantedSection == null) {
                    diffs.add(newSection.getName());
                    continue;
                }
                if (wantedSection.compareTo(newSection) != 0) {
                    diffs.add(wantedSection.getName());
                    continue;
                }
            }
            for (final AccessSection wantedSection : wantedSections.values()) {
                diffs.add(wantedSection.getName());
            }
            return diffs;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            super.onFailure(caught);
        }
    });
}
#method_after
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final HashSet<AccessSection> same = new HashSet<AccessSection>(wantedAccess.getLocal());
            final HashSet<AccessSection> different = new HashSet<AccessSection>(wantedAccess.getLocal().size() + newAccess.getLocal().size());
            different.addAll(wantedAccess.getLocal());
            different.addAll(newAccess.getLocal());
            same.retainAll(newAccess.getLocal());
            different.removeAll(same);
            final Set<String> differentNames = new HashSet<String>();
            for (final AccessSection s : different) {
                differentNames.add(s.getName());
            }
            return differentNames;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    table.setWidget(row, 1, new Anchor(plugin.name(), "/plugins/" + plugin.name() + "/"));
    table.setText(row, 2, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    table.setWidget(row, 1, new Anchor(plugin.name(), Gerrit.selfRedirect("/plugins/" + plugin.name() + "/")));
    table.setText(row, 2, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
public void display(Change.Id changeId, Boolean starred, String commitMessage) {
    if (changeId != null && starred != null && Gerrit.isSignedIn() && starPanel.getWidget() == null) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(Change.Id changeId, Boolean starred, String commitMessage) {
    starPanel.clear();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
private List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                for (final String permissionName : Permission.getPermissionNames()) {
                    if (!Permission.canBeOnWildProject(permissionName)) {
                        section.removePermission(permissionName);
                    }
                }
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
private List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
boolean isOwner(Set<AccountGroup.UUID> groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (CollectionsUtil.isAnyIncludedIn(s.localOwners, groups)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#method_after
boolean isOwner(GroupMembership groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (groups.containsAnyOf(s.localOwners)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#end_block

#method_before
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    Project.NameKey parentName = getProject().getParent();
    if (parentName == null) {
        parentName = allProjectsName;
    }
    return projectCache.get(parentName);
}
#method_after
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    return projectCache.get(getProject().getParent(allProjectsName));
}
#end_block

#method_before
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && AccessSection.isAccessSection(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#method_after
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && RefConfigSection.isValid(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (AccessSection.isAccessSection(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (RefConfigSection.isValid(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            addPermission(varName, perms);
        }
    } else if (AccessSection.isAccessSection(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            addPermission(varName, perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            addPermission(varName, perms);
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            addPermission(varName, perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
private void addPermission(final String permissionName, final List<String> permissionList) {
    if (value.getPermission(permissionName) != null) {
        return;
    }
    if (Gerrit.getConfig().getWildProject().equals(projectAccess.getProjectName()) && !Permission.canBeOnWildProject(permissionName)) {
        return;
    }
    permissionList.add(permissionName);
}
#method_after
private void addPermission(final String permissionName, final List<String> permissionList) {
    if (value.getPermission(permissionName) != null) {
        return;
    }
    if (Gerrit.getConfig().getWildProject().equals(projectAccess.getProjectName()) && !Permission.canBeOnAllProjects(value.getName(), permissionName)) {
        return;
    }
    permissionList.add(permissionName);
}
#end_block

#method_before
@Override
public PermissionEditor create(int index) {
    PermissionEditor subEditor = new PermissionEditor(readOnly, value);
    permissionContainer.insert(subEditor, index);
    return subEditor;
}
#method_after
@Override
public PermissionEditor create(int index) {
    PermissionEditor subEditor = new PermissionEditor(projectAccess.getProjectName(), readOnly, value);
    permissionContainer.insert(subEditor, index);
    return subEditor;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.initHighlightUnreviewed(true, ownerId);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.setHighlightUnreviewed(true);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#end_block

#method_before
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), compare());
    Collections.sort(in.asList(), compare());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#method_after
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), outComparator());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#end_block

#method_before
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#method_after
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else if (optional()) {
        return SubmitRecord.Label.Status.MAY;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed, Account.Id accountId) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    boolean reviewScored = false;
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
        reviewScored = true;
    }
    boolean needHighlight = false;
    // patch set, we also don't highlight it.
    if (highlightUnreviewed && !reviewScored && accountId != null) {
        needHighlight = true;
        for (int i = 0; i < c.messageAuthorIds().length(); i++) {
            if (accountId.get() == c.messageAuthorIds().get(i)) {
                needHighlight = false;
                break;
            }
        }
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed, ownerId);
    }
}
#method_after
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed);
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.labels = labelsFor(cd);
    out.messageauthors = recentMessageAuthorIds(cd);
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd);
    return out;
}
#end_block

#method_before
private AccountAttribute asAccountAttribute(Account.Id user) {
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#method_after
private AccountAttribute asAccountAttribute(Account.Id user) {
    if (user == null) {
        return null;
    }
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS, nameTxt, null);
    projectListPopup.addOpenRowHandler(new ProjectListPopup.ProjectListPopupOnOpenRowHandler() {

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            doAddNew();
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    sp.setSize("100%", "100%");
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popup.setHeight("100%");
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            if (top + offsetHeight > Window.getClientHeight()) {
                top = Window.getClientHeight() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#end_block

#method_before
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            calculatePopupCoordinates();
            projectListPopup.display();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#method_after
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    projectsTab = new ProjectsTable() {

        {
            keysNavigation.add(new OpenKeyCommand(0, 'o', Util.C.projectListOpen()));
            keysNavigation.add(new OpenKeyCommand(0, KeyCodes.KEY_ENTER, Util.C.projectListOpen()));
        }

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            // prevent user input from being overwritten by simply poping up
            if (!popingUp || "".equals(nameBox.getText())) {
                nameBox.setText(getRowItem(row).name());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            nameBox.setText(getRowItem(row).name());
            doAddNew();
        }
    };
    projectsTab.setSavePointerId(PageLinks.SETTINGS_PROJECTS);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(Util.C.projects());
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    closePopup();
}
#end_block

#method_before
public void display(final String commitMessage) {
    String commitSummary = "";
    String commitBody = "";
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    commitSummary = splitCommitMessage[0];
    commitBody = SafeHtmlUtils.htmlEscape(splitCommitMessage[1]);
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.setAttribute("style", "display: none;");
    }
    commitSummaryPre.setInnerText(commitSummary);
    // Linkify commit body for Change-Id etc.
    SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
    commitBodyLinkified = commitBodyLinkified.linkify();
    commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
    commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
}
#method_after
public void display(final String commitMessage) {
    String commitSummary = "";
    String commitBody = "";
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    commitSummary = splitCommitMessage[0];
    commitBody = splitCommitMessage[1];
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.setAttribute("style", "display: none;");
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    // Linkify commit body
    SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
    commitBodyLinkified = commitBodyLinkified.linkify();
    commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
}
#end_block

#method_before
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            for (int line = lineNbr - lines + 1; line <= lineNbr; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append(c.getMessage().trim());
            cmts.append("\n");
            for (int line = lineNbr + 1; line < lineNbr + lines; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#method_after
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            if (currentFileData != null) {
                int maxLines;
                try {
                    maxLines = currentFileData.getLineCount(side);
                } catch (Throwable e) {
                    maxLines = lineNbr;
                }
                final int startLine = Math.max(1, lineNbr - lines + 1);
                final int stopLine = Math.min(maxLines, lineNbr + lines);
                for (int line = startLine; line <= lineNbr; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
                cmts.append(c.getMessage().trim());
                cmts.append("\n");
                for (int line = lineNbr + 1; line < stopLine; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#end_block

#method_before
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    if (fileData != null) {
        try {
            final String lineStr = fileData.getLine(side, line);
            cmts.append(": ");
            cmts.append(lineStr);
        } catch (Throwable cce) {
        // Don't quote the line if we can't safely convert it.
        }
    }
    cmts.append("\n");
}
#method_after
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    try {
        final String lineStr = fileData.getLine(side, line);
        cmts.append(": ");
        cmts.append(lineStr);
    } catch (Throwable e) {
    // Don't quote the line if we can't safely convert it.
    }
    cmts.append("\n");
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, helper.queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, helper.queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
@Override
public void onCreateAccount(final AuthRequest who, final Account account) {
    usernameCache.put(who.getLocalUser(), account.getId());
}
#method_after
@Override
public void onCreateAccount(final AuthRequest who, final Account account) {
    usernameCache.put(who.getLocalUser(), Optional.of(account.getId()));
}
#end_block

#method_before
@Override
public GroupMembership groups(final AccountState who) {
    return groupMembershipFactory.create(Iterables.concat(membershipCache.get(findId(who.getExternalIds())), who.getInternalGroups()));
}
#method_after
@Override
public GroupMembership groups(final AccountState who) {
    String id = findId(who.getExternalIds());
    Set<AccountGroup.UUID> groups;
    if (id != null) {
        try {
            groups = membershipCache.get(id);
        } catch (ExecutionException e) {
            log.warn(String.format("Cannot lookup groups for %s in LDAP", id), e);
            groups = Collections.emptySet();
        }
    } else {
        groups = Collections.emptySet();
    }
    return groupMembershipFactory.create(Iterables.concat(groups, who.getInternalGroups()));
}
#end_block

#method_before
@Override
public Account.Id lookup(final String accountName) {
    return usernameCache.get(accountName);
}
#method_after
@Override
public Account.Id lookup(String accountName) {
    if (Strings.isNullOrEmpty(accountName)) {
        return null;
    }
    try {
        Optional<Account.Id> id = usernameCache.get(accountName);
        return id != null ? id.orNull() : null;
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup account %s in LDAP", accountName), e);
        return null;
    }
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final TypeLiteral<Cache<AccountGroup.Id, AccountGroup>> byId = new TypeLiteral<Cache<AccountGroup.Id, AccountGroup>>() {
            };
            core(byId, BYID_NAME).populateWith(ByIdLoader.class);
            final TypeLiteral<Cache<AccountGroup.NameKey, AccountGroup.Id>> byName = new TypeLiteral<Cache<AccountGroup.NameKey, AccountGroup.Id>>() {
            };
            core(byName, BYNAME_NAME).populateWith(ByNameLoader.class);
            final TypeLiteral<Cache<AccountGroup.UUID, AccountGroup.Id>> byUUID = new TypeLiteral<Cache<AccountGroup.UUID, AccountGroup.Id>>() {
            };
            core(byUUID, BYUUID_NAME).populateWith(ByUUIDLoader.class);
            final TypeLiteral<Cache<ListKey, SortedSet<AccountGroup.NameKey>>> listType = new TypeLiteral<Cache<ListKey, SortedSet<AccountGroup.NameKey>>>() {
            };
            core(listType, BYNAME_LIST).populateWith(Lister.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByUUIDLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public AccountGroup get(final AccountGroup.Id groupId) {
    return byId.get(groupId);
}
#method_after
@Override
public AccountGroup get(final AccountGroup.Id groupId) {
    try {
        Optional<AccountGroup> g = byId.get(groupId);
        return g.isPresent() ? g.get() : missing(groupId);
    } catch (ExecutionException e) {
        log.warn("Cannot load group " + groupId, e);
        return missing(groupId);
    }
}
#end_block

#method_before
@Override
public void evict(final AccountGroup group) {
    byId.remove(group.getId());
}
#method_after
@Override
public void evict(final AccountGroup group) {
    if (group.getId() != null) {
        byId.invalidate(group.getId());
    }
    if (group.getNameKey() != null) {
        byName.invalidate(group.getNameKey().get());
    }
    if (group.getGroupUUID() != null) {
        byUUID.invalidate(group.getGroupUUID().get());
    }
}
#end_block

#method_before
@Override
public void evictAfterRename(final AccountGroup.NameKey oldName, final AccountGroup.NameKey newName) {
    byName.remove(oldName);
    updateGroupList(oldName, newName);
}
#method_after
@Override
public void evictAfterRename(final AccountGroup.NameKey oldName, final AccountGroup.NameKey newName) {
    if (oldName != null) {
        byName.invalidate(oldName.get());
    }
    if (newName != null) {
        byName.invalidate(newName.get());
    }
}
#end_block

#method_before
@Override
public AccountGroup get(final AccountGroup.NameKey name) {
    AccountGroup.Id groupId = byName.get(name);
    if (groupId == null) {
        return null;
    }
    return get(groupId);
}
#method_after
@Override
public AccountGroup get(AccountGroup.NameKey name) {
    if (name == null) {
        return null;
    }
    try {
        return byName.get(name.get()).orNull();
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup group %s by name", name.get()), e);
        return null;
    }
}
#end_block

#method_before
@Override
public AccountGroup get(final AccountGroup.UUID uuid) {
    AccountGroup.Id groupId = byUUID.get(uuid);
    if (groupId == null) {
        return null;
    }
    return get(groupId);
}
#method_after
@Override
public AccountGroup get(AccountGroup.UUID uuid) {
    if (uuid == null) {
        return null;
    }
    try {
        return byUUID.get(uuid.get()).orNull();
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup group %s by name", uuid.get()), e);
        return null;
    }
}
#end_block

#method_before
@Override
public Iterable<AccountGroup> all() {
    SortedSet<NameKey> names = list.get(ListKey.ALL);
    List<AccountGroup> groups = Lists.newArrayListWithCapacity(names.size());
    for (AccountGroup.NameKey groupName : names) {
        AccountGroup group = get(groupName);
        if (group != null) {
            groups.add(group);
        }
    }
    return Collections.unmodifiableList(groups);
}
#method_after
@Override
public Iterable<AccountGroup> all() {
    try {
        ReviewDb db = schema.open();
        try {
            return Collections.unmodifiableList(db.accountGroups().all().toList());
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.warn("Cannot list internal groups", e);
        return Collections.emptyList();
    }
}
#end_block

#method_before
@Override
public void onCreateGroup(final AccountGroup.NameKey newGroupName) {
    updateGroupList(null, newGroupName);
}
#method_after
@Override
public void onCreateGroup(AccountGroup.NameKey newGroupName) {
    byName.invalidate(newGroupName.get());
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    // Find all groups that have an LDAP type.
    Map<AccountGroup.UUID, GroupReference> ldapUUIDMap = Maps.newHashMap();
    Set<AccountGroup.UUID> toResolve = Sets.newHashSet();
    List<AccountGroup.Id> toDelete = Lists.newArrayList();
    List<AccountGroup.NameKey> namesToDelete = Lists.newArrayList();
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet rs = stmt.executeQuery("SELECT group_id, group_uuid, external_name, name FROM account_groups" + " WHERE group_type ='LDAP'");
        try {
            Map<Integer, ContributorAgreement> agreements = Maps.newHashMap();
            while (rs.next()) {
                AccountGroup.Id groupId = new AccountGroup.Id(rs.getInt(1));
                AccountGroup.UUID groupUUID = new AccountGroup.UUID(rs.getString(2));
                AccountGroup.NameKey name = new AccountGroup.NameKey(rs.getString(4));
                String dn = rs.getString(3);
                if (isNullOrEmpty(dn)) {
                    // The LDAP group does not have a DN. Determine if the UUID is used.
                    toResolve.add(groupUUID);
                } else {
                    toDelete.add(groupId);
                    namesToDelete.add(name);
                    GroupReference ref = groupReference(dn);
                    ldapUUIDMap.put(groupUUID, ref);
                }
            }
        } catch (NamingException e) {
            throw new RuntimeException(e);
        } finally {
            rs.close();
        }
    } finally {
        stmt.close();
    }
    if (toDelete.isEmpty() && toResolve.isEmpty()) {
        // No ldap groups. Nothing to do.
        return;
    }
    ui.message("Update LDAP groups to be GroupReferences.");
    // Update the groupOwnerUUID for LDAP groups to point to the new UUID.
    List<AccountGroup> toUpdate = Lists.newArrayList();
    Set<AccountGroup.UUID> resolveToUpdate = Sets.newHashSet();
    Map<AccountGroup.UUID, AccountGroup> resolveGroups = Maps.newHashMap();
    com.google.gwtorm.server.ResultSet<AccountGroup> rs = db.accountGroups().all();
    try {
        for (AccountGroup g : rs) {
            if (ldapUUIDMap.containsKey(g.getGroupUUID())) {
                // Ignore the LDAP groups with a valid DN.
                continue;
            } else if (toResolve.contains(g.getGroupUUID())) {
                // Keep the ones to resolve.
                resolveGroups.put(g.getGroupUUID(), g);
                continue;
            }
            GroupReference ref = ldapUUIDMap.get(g.getOwnerGroupUUID());
            if (ref != null) {
                // Update the owner group UUID to the new ldap UUID scheme.
                g.setOwnerGroupUUID(ref.getUUID());
                toUpdate.add(g);
            } else if (toResolve.contains(g.getOwnerGroupUUID())) {
                // The unresolved group is used as an owner.
                // Add to the list of LDAP groups to be made INTERNAL.
                resolveToUpdate.add(g.getOwnerGroupUUID());
            }
        }
    } finally {
        rs.close();
    }
    toResolve.removeAll(resolveToUpdate);
    // Update project.config group references to use the new LDAP GroupReference
    for (Project.NameKey name : mgr.list()) {
        Repository git;
        try {
            git = mgr.openRepository(name);
        } catch (RepositoryNotFoundException e) {
            throw new OrmException(e);
        } catch (IOException e) {
            throw new OrmException(e);
        }
        try {
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, name, git);
            md.getCommitBuilder().setAuthor(serverUser);
            md.getCommitBuilder().setCommitter(serverUser);
            ProjectConfig config = ProjectConfig.read(md);
            // Update the existing refences to the new reference.
            boolean updated = false;
            for (Map.Entry<AccountGroup.UUID, GroupReference> entry : ldapUUIDMap.entrySet()) {
                GroupReference ref = config.getGroup(entry.getKey());
                if (ref != null) {
                    updated = true;
                    ref.setName(entry.getValue().getName());
                    ref.setUUID(entry.getValue().getUUID());
                    config.resolve(ref);
                }
            }
            // Determine if a toResolve group is used and should be made INTERNAL.
            Iterator<AccountGroup.UUID> iter = toResolve.iterator();
            while (iter.hasNext()) {
                AccountGroup.UUID uuid = iter.next();
                if (config.getGroup(uuid) != null) {
                    resolveToUpdate.add(uuid);
                    iter.remove();
                }
            }
            if (!updated) {
                continue;
            }
            md.setMessage("Upgrade to Gerrit Code Review schema 68\n");
            if (!config.commit(md)) {
                throw new OrmException("Cannot update " + name);
            }
        } catch (IOException e) {
            throw new OrmException(e);
        } catch (ConfigInvalidException e) {
            throw new OrmException(e);
        } finally {
            git.close();
        }
    }
    for (AccountGroup.UUID uuid : resolveToUpdate) {
        AccountGroup group = resolveGroups.get(uuid);
        group.setType(AccountGroup.Type.INTERNAL);
        toUpdate.add(group);
        ui.message(String.format("*** Group has no DN and is inuse. Updated to be INTERNAL: %s", group.getName()));
    }
    for (AccountGroup.UUID uuid : toResolve) {
        AccountGroup group = resolveGroups.get(uuid);
        toDelete.add(group.getId());
        namesToDelete.add(group.getNameKey());
    }
    // Update group owners
    db.accountGroups().update(toUpdate);
    // Delete existing LDAP groups
    db.accountGroupNames().deleteKeys(namesToDelete);
    db.accountGroups().deleteKeys(toDelete);
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    // Find all groups that have an LDAP type.
    Map<AccountGroup.UUID, GroupReference> ldapUUIDMap = Maps.newHashMap();
    Set<AccountGroup.UUID> toResolve = Sets.newHashSet();
    List<AccountGroup.Id> toDelete = Lists.newArrayList();
    List<AccountGroup.NameKey> namesToDelete = Lists.newArrayList();
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet rs = stmt.executeQuery("SELECT group_id, group_uuid, external_name, name FROM account_groups" + " WHERE group_type ='LDAP'");
        try {
            while (rs.next()) {
                AccountGroup.Id groupId = new AccountGroup.Id(rs.getInt(1));
                AccountGroup.UUID groupUUID = new AccountGroup.UUID(rs.getString(2));
                AccountGroup.NameKey name = new AccountGroup.NameKey(rs.getString(4));
                String dn = rs.getString(3);
                if (isNullOrEmpty(dn)) {
                    // The LDAP group does not have a DN. Determine if the UUID is used.
                    toResolve.add(groupUUID);
                } else {
                    toDelete.add(groupId);
                    namesToDelete.add(name);
                    GroupReference ref = groupReference(dn);
                    ldapUUIDMap.put(groupUUID, ref);
                }
            }
        } catch (NamingException e) {
            throw new RuntimeException(e);
        } finally {
            rs.close();
        }
    } finally {
        stmt.close();
    }
    if (toDelete.isEmpty() && toResolve.isEmpty()) {
        // No ldap groups. Nothing to do.
        return;
    }
    ui.message("Update LDAP groups to be GroupReferences.");
    // Update the groupOwnerUUID for LDAP groups to point to the new UUID.
    List<AccountGroup> toUpdate = Lists.newArrayList();
    Set<AccountGroup.UUID> resolveToUpdate = Sets.newHashSet();
    Map<AccountGroup.UUID, AccountGroup> resolveGroups = Maps.newHashMap();
    for (AccountGroup g : db.accountGroups().all()) {
        if (ldapUUIDMap.containsKey(g.getGroupUUID())) {
            // Ignore the LDAP groups with a valid DN.
            continue;
        } else if (toResolve.contains(g.getGroupUUID())) {
            // Keep the ones to resolve.
            resolveGroups.put(g.getGroupUUID(), g);
            continue;
        }
        GroupReference ref = ldapUUIDMap.get(g.getOwnerGroupUUID());
        if (ref != null) {
            // Update the owner group UUID to the new ldap UUID scheme.
            g.setOwnerGroupUUID(ref.getUUID());
            toUpdate.add(g);
        } else if (toResolve.contains(g.getOwnerGroupUUID())) {
            // The unresolved group is used as an owner.
            // Add to the list of LDAP groups to be made INTERNAL.
            resolveToUpdate.add(g.getOwnerGroupUUID());
        }
    }
    toResolve.removeAll(resolveToUpdate);
    // Update project.config group references to use the new LDAP GroupReference
    for (Project.NameKey name : mgr.list()) {
        Repository git;
        try {
            git = mgr.openRepository(name);
        } catch (RepositoryNotFoundException e) {
            throw new OrmException(e);
        } catch (IOException e) {
            throw new OrmException(e);
        }
        try {
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, name, git);
            md.getCommitBuilder().setAuthor(serverUser);
            md.getCommitBuilder().setCommitter(serverUser);
            ProjectConfig config = ProjectConfig.read(md);
            // Update the existing refences to the new reference.
            boolean updated = false;
            for (Map.Entry<AccountGroup.UUID, GroupReference> entry : ldapUUIDMap.entrySet()) {
                GroupReference ref = config.getGroup(entry.getKey());
                if (ref != null) {
                    updated = true;
                    ref.setName(entry.getValue().getName());
                    ref.setUUID(entry.getValue().getUUID());
                    config.resolve(ref);
                }
            }
            // Determine if a toResolve group is used and should be made INTERNAL.
            Iterator<AccountGroup.UUID> iter = toResolve.iterator();
            while (iter.hasNext()) {
                AccountGroup.UUID uuid = iter.next();
                if (config.getGroup(uuid) != null) {
                    resolveToUpdate.add(uuid);
                    iter.remove();
                }
            }
            if (!updated) {
                continue;
            }
            md.setMessage("Switch LDAP group UUIDs to DNs\n");
            if (!config.commit(md)) {
                throw new OrmException("Cannot update " + name);
            }
        } catch (IOException e) {
            throw new OrmException(e);
        } catch (ConfigInvalidException e) {
            throw new OrmException(e);
        } finally {
            git.close();
        }
    }
    for (AccountGroup.UUID uuid : resolveToUpdate) {
        AccountGroup group = resolveGroups.get(uuid);
        group.setType(AccountGroup.Type.INTERNAL);
        toUpdate.add(group);
        ui.message(String.format("*** Group has no DN and is inuse. Updated to be INTERNAL: %s", group.getName()));
    }
    for (AccountGroup.UUID uuid : toResolve) {
        AccountGroup group = resolveGroups.get(uuid);
        toDelete.add(group.getId());
        namesToDelete.add(group.getNameKey());
    }
    // Update group owners
    db.accountGroups().update(toUpdate);
    // Delete existing LDAP groups
    db.accountGroupNames().deleteKeys(namesToDelete);
    db.accountGroups().deleteKeys(toDelete);
}
#end_block

#method_before
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                final Change.Id ck = a.getPatchSet().getParentKey();
                if (descendants.add(ck)) {
                    changesToGet.add(a.getPatchSet().getParentKey());
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#method_after
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                final Change.Id ck = a.getPatchSet().getParentKey();
                if (descendants.add(ck)) {
                    changesToGet.add(ck);
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#end_block

#method_before
@Override
public void suggestChangeReviewer(final Change.Id change, final String query, final int limit, final AsyncCallback<List<ReviewerInfo>> callback) {
    run(callback, new Action<List<ReviewerInfo>>() {

        public List<ReviewerInfo> run(final ReviewDb db) throws OrmException {
            final ChangeControl changeControl;
            try {
                changeControl = changeControlFactory.controlFor(change);
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            }
            VisibilityControl visibilityControl = new VisibilityControl() {

                @Override
                public boolean isVisible(Account account) throws OrmException {
                    IdentifiedUser who = identifiedUserFactory.create(reviewDbProvider, account.getId());
                    return changeControl.getChange().getStatus() == Change.Status.DRAFT || changeControl.forUser(who).isVisible(reviewDbProvider.get());
                }
            };
            final List<AccountInfo> suggestedAccounts = suggestAccount(db, query, Boolean.TRUE, limit, visibilityControl);
            final List<ReviewerInfo> reviewer = new ArrayList<ReviewerInfo>(suggestedAccounts.size());
            for (final AccountInfo a : suggestedAccounts) {
                reviewer.add(new ReviewerInfo(a));
            }
            final List<GroupReference> suggestedAccountGroups = suggestAccountGroup(db, query, limit);
            for (final GroupReference g : suggestedAccountGroups) {
                if (suggestGroupAsReviewer(changeControl.getProject().getNameKey(), g)) {
                    reviewer.add(new ReviewerInfo(g));
                }
            }
            Collections.sort(reviewer);
            if (reviewer.size() <= limit) {
                return reviewer;
            } else {
                return reviewer.subList(0, limit);
            }
        }
    });
}
#method_after
@Override
public void suggestChangeReviewer(final Change.Id change, final String query, final int limit, final AsyncCallback<List<ReviewerInfo>> callback) {
    run(callback, new Action<List<ReviewerInfo>>() {

        public List<ReviewerInfo> run(final ReviewDb db) throws OrmException {
            final ChangeControl changeControl;
            try {
                changeControl = changeControlFactory.controlFor(change);
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            }
            VisibilityControl visibilityControl = new VisibilityControl() {

                @Override
                public boolean isVisible(Account account) throws OrmException {
                    IdentifiedUser who = identifiedUserFactory.create(reviewDbProvider, account.getId());
                    // to drafts
                    return changeControl.forUser(who).isRefVisible();
                }
            };
            final List<AccountInfo> suggestedAccounts = suggestAccount(db, query, Boolean.TRUE, limit, visibilityControl);
            final List<ReviewerInfo> reviewer = new ArrayList<ReviewerInfo>(suggestedAccounts.size());
            for (final AccountInfo a : suggestedAccounts) {
                reviewer.add(new ReviewerInfo(a));
            }
            final List<GroupReference> suggestedAccountGroups = suggestAccountGroup(db, query, limit);
            for (final GroupReference g : suggestedAccountGroups) {
                if (suggestGroupAsReviewer(changeControl.getProject().getNameKey(), g)) {
                    reviewer.add(new ReviewerInfo(g));
                }
            }
            Collections.sort(reviewer);
            if (reviewer.size() <= limit) {
                return reviewer;
            } else {
                return reviewer.subList(0, limit);
            }
        }
    });
}
#end_block

#method_before
public String getHtmlFromMarkdown(String markdownSource) {
    pegProcessor = new PegDownProcessor(ALL);
    String htmled;
    htmled = pegProcessor.markdownToHtml(markdownSource);
    return htmled;
}
#method_after
public byte[] getHtmlFromMarkdown(byte[] data, String charEnc) throws UnsupportedEncodingException {
    String decodedData = RawParseUtils.decode(Charset.forName(charEnc), data);
    String formatted = new PegDownProcessor(ALL).markdownToHtml(decodedData);
    data = formatted.getBytes(charEnc);
    return data;
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    String file = uri.substring(ctx.length() + 1);
    if (file.startsWith("Documentation/") || file.startsWith("static/")) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (file.startsWith("Documentation/") && !isValidEntry(entry)) {
            entry = getRealFileEntry(jar, file);
            if (isValidEntry(entry)) {
                sendResource(jar, entry, res, true);
                return;
            }
        }
        if (isValidEntry(entry)) {
            sendResource(jar, entry, res);
            return;
        }
    }
    noCache(res);
    res.sendError(HttpServletResponse.SC_NOT_FOUND);
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    String file = uri.substring(ctx.length() + 1);
    if (file.startsWith("Documentation/") || file.startsWith("static/")) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (file.startsWith("Documentation/") && !isValidEntry(entry)) {
            entry = getRealFileEntry(jar, file);
            if (isValidEntry(entry)) {
                sendResource(jar, entry, res, holder.plugin.getName(), true);
                return;
            }
        }
        if (isValidEntry(entry)) {
            sendResource(jar, entry, res, holder.plugin.getName());
            return;
        }
    }
    noCache(res);
    res.sendError(HttpServletResponse.SC_NOT_FOUND);
}
#end_block

#method_before
private JarEntry getRealFileEntry(JarFile jar, String file) {
    // TODO: Replace with a loop iterating over possible formatters
    String realFile = file.replaceAll("\\.html$", ".md");
    JarEntry entry = jar.getJarEntry(realFile);
    return entry;
}
#method_after
private JarEntry getRealFileEntry(JarFile jar, String file) {
    // TODO: Replace with a loop iterating over possible formatters
    return jar.getJarEntry(file.replaceAll("\\.html$", ".md"));
}
#end_block

#method_before
private Boolean isValidEntry(JarEntry entry) {
    if (entry != null && entry.getSize() > 0) {
        return true;
    }
    return false;
}
#method_after
private boolean isValidEntry(JarEntry entry) {
    return entry != null && entry.getSize() > 0;
}
#end_block

#method_before
private void sendResource(JarFile jar, JarEntry entry, HttpServletResponse res, Boolean format) throws IOException {
    String entryName = entry.getName();
    byte[] data = null;
    if (entry.getSize() <= 128 * 1024) {
        data = new byte[(int) entry.getSize()];
        InputStream in = jar.getInputStream(entry);
        try {
            IO.readFully(in, data, 0, data.length);
        } finally {
            in.close();
        }
    } else if (format == true) {
        log.warn(String.format("Plugin file %s to large to format", entryName));
    }
    String contentType = null;
    String characterEncoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        characterEncoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    MimeType type;
    if (contentType == null) {
        type = mimeUtil.getMimeType(entryName, data);
        contentType = type.toString();
    }
    if (characterEncoding == null) {
        characterEncoding = "UTF-8";
    }
    if (format == true && data != null) {
        MarkdownFormatter formatter = new MarkdownFormatter();
        String decodedData = RawParseUtils.decode(data);
        String formattedEntry = formatter.getHtmlFromMarkdown(decodedData);
        data = formattedEntry.getBytes(characterEncoding);
        res.setHeader("Content-Length", Long.toString(data.length));
        type = new MimeType("text/html");
        contentType = type.toString();
    } else {
        res.setHeader("Content-Length", Long.toString(entry.getSize()));
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setContentType(contentType);
    if (data != null) {
        res.getOutputStream().write(data);
    } else {
        InputStream in = jar.getInputStream(entry);
        try {
            OutputStream out = res.getOutputStream();
            try {
                byte[] tmp = new byte[1024];
                int n;
                while ((n = in.read(tmp)) > 0) {
                    out.write(tmp, 0, n);
                }
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }
}
#method_after
private void sendResource(JarFile jar, JarEntry entry, HttpServletResponse res, String pluginName) throws IOException {
    sendResource(jar, entry, res, pluginName, false);
}
#end_block

#method_before
public void start(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    manager = new LifecycleManager();
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(name, env, jarFile, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        manager.add(sysInjector);
    } else if (auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        manager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (sshModule != null && env.hasSshModule()) {
        sshInjector = sysInjector.createChildInjector(env.getSshModule(), sysInjector.getInstance(sshModule));
        manager.add(sshInjector);
    } else if (auto.sshModule != null && env.hasSshModule()) {
        sshInjector = sysInjector.createChildInjector(env.getSshModule(), auto.sshModule);
        manager.add(sshInjector);
    }
    if (httpModule != null && env.hasHttpModule()) {
        httpInjector = sysInjector.createChildInjector(env.getHttpModule(), sysInjector.getInstance(httpModule));
        manager.add(httpInjector);
    } else if (auto.httpModule != null && env.hasHttpModule()) {
        httpInjector = sysInjector.createChildInjector(env.getHttpModule(), auto.httpModule);
        manager.add(httpInjector);
    }
    manager.start();
}
#method_after
public void start(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    manager = new LifecycleManager();
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(name, env, jarFile, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        manager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        manager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        if (sshModule != null) {
            sshInjector = sysInjector.createChildInjector(env.getSshModule(), sysInjector.getInstance(sshModule));
            manager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            sshInjector = sysInjector.createChildInjector(env.getSshModule(), auto.sshModule);
            manager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        if (httpModule != null) {
            httpInjector = sysInjector.createChildInjector(env.getHttpModule(), sysInjector.getInstance(httpModule));
            manager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            httpInjector = sysInjector.createChildInjector(env.getHttpModule(), auto.httpModule);
            manager.add(httpInjector);
        }
    }
    manager.start();
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore(repoManager));
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, repoManager, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch);
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canRestore(repoManager)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the restored change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
        if (changeComment != null && changeComment.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(changeComment);
        }
        cmsg.setMessage(msgBuf.toString());
        // Restore the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
        hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException, RepositoryNotFoundException, IOException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canRestore()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
        return result;
    }
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Branch.NameKey destBranch = control.getChange().getDest();
    if (!ProjectUtil.branchExists(repoManager, destBranch)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.DEST_BRANCH_NOT_FOUND, destBranch.get()));
        return result;
    }
    // Create a message to accompany the restored change
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
    if (changeComment != null && changeComment.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(changeComment);
    }
    cmsg.setMessage(msgBuf.toString());
    // Restore the change
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.NEW);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
    hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canAdministrateServer()) {
                String msg = String.format("fatal: %s does not have \"Administrator\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(1, msg);
            }
            parseCommandLine();
            if (active && inactive) {
                throw new UnloggedFailure(1, "You can't use both --active and --inactive");
            }
            setAccount();
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canAdministrateServer()) {
                String msg = String.format("fatal: %s does not have \"Administrator\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(1, msg);
            }
            parseCommandLine();
            validate();
            setAccount();
        }
    });
}
#end_block

#method_before
private void setAccount() throws OrmException, IOException, InvalidSshKeyException, UnloggedFailure {
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw die("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    final Account account;
    AccountExternalId.Key key = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username);
    AccountExternalId accExtId = db.accountExternalIds().get(key);
    if (accExtId != null) {
        account = db.accounts().get(accExtId.getAccountId());
    } else {
        throw die("Could not find user : " + username);
    }
    Account.Id id = account.getId();
    if (newEmail != null) {
        link(id, newEmail);
    }
    if (oldEmail != null) {
        deleteMail(id, oldEmail);
    }
    if (fullName != null && realm.allowsEdit(FieldName.FULL_NAME)) {
        account.setFullName(fullName);
    }
    if (active) {
        account.setActive(true);
    } else if (inactive) {
        account.setActive(false);
    }
    final String readAddKey = readSshKey(addSshKey);
    if (readAddKey != null) {
        addSshKey(readAddKey, account);
    }
    final String readDeleteKey = readSshKey(deleteSshKey);
    if (readDeleteKey != null) {
        deleteSshKeys(readDeleteKey, account);
    }
    db.accounts().update(Collections.singleton(account));
    byIdCache.evict(id);
    db.close();
}
#method_after
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    final Account account = db.accounts().get(id);
    boolean accountUpdated = false;
    boolean sshKeysUpdated = false;
    for (String email : addEmails) {
        link(id, email);
    }
    for (String email : deleteEmails) {
        deleteMail(id, email);
    }
    if (fullName != null) {
        if (realm.allowsEdit(FieldName.FULL_NAME)) {
            account.setFullName(fullName);
        } else {
            throw new UnloggedFailure(1, "The realm doesn't allow editing names");
        }
    }
    if (active) {
        accountUpdated = true;
        account.setActive(true);
    } else if (inactive) {
        accountUpdated = true;
        account.setActive(false);
    }
    addSshKeys = readSshKey(addSshKeys);
    if (!addSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        addSshKeys(addSshKeys, account);
    }
    deleteSshKeys = readSshKey(deleteSshKeys);
    if (!deleteSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        deleteSshKeys(deleteSshKeys, account);
    }
    if (accountUpdated) {
        db.accounts().update(Collections.singleton(account));
        byIdCache.evict(id);
    }
    if (sshKeysUpdated) {
        sshKeyCache.evict(account.getUserName());
    }
    db.close();
}
#end_block

#method_before
private void deleteSshKeys(final String readDeleteKey, final Account account) throws OrmException {
    ResultSet<AccountSshKey> keys = db.accountSshKeys().byAccount(account.getId());
    if (readDeleteKey.equals("ALL")) {
        db.accountSshKeys().delete(keys);
    } else {
        for (AccountSshKey accountSshKey : keys) {
            if (accountSshKey.getSshPublicKey().equals(readDeleteKey)) {
                db.accountSshKeys().delete(Collections.singleton(accountSshKey));
            }
        }
    }
    sshKeyCache.evict(account.getUserName());
}
#method_after
private void deleteSshKeys(final List<String> keys, final Account account) throws OrmException {
    ResultSet<AccountSshKey> allKeys = db.accountSshKeys().byAccount(account.getId());
    if (keys.contains("ALL")) {
        db.accountSshKeys().delete(allKeys);
    } else {
        List<AccountSshKey> accountKeys = new ArrayList<AccountSshKey>();
        for (String key : keys) {
            for (AccountSshKey accountSshKey : allKeys) {
                if (key.trim().equals(accountSshKey.getSshPublicKey()) || accountSshKey.getComment().trim().equals(key)) {
                    accountKeys.add(accountSshKey);
                }
            }
        }
        db.accountSshKeys().delete(accountKeys);
    }
}
#end_block

#method_before
private void deleteMail(Account.Id id, final String mailAddress) throws UnloggedFailure {
    if (mailAddress.equals("ALL")) {
        ResultSet<AccountExternalId> ids;
        try {
            ids = db.accountExternalIds().byAccount(id);
        } catch (OrmException e) {
            throw die("Could not query database: " + e.getMessage());
        }
        for (AccountExternalId extId : ids) {
            unlink(id, extId.getEmailAddress());
        }
    } else {
        unlink(id, mailAddress);
    }
}
#method_after
private void deleteMail(Account.Id id, final String mailAddress) throws UnloggedFailure, OrmException {
    if (mailAddress.equals("ALL")) {
        ResultSet<AccountExternalId> ids = db.accountExternalIds().byAccount(id);
        for (AccountExternalId extId : ids) {
            if (extId.isScheme(AccountExternalId.SCHEME_MAILTO)) {
                unlink(id, extId.getEmailAddress());
            }
        }
    } else {
        AccountExternalId.Key key = new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, mailAddress);
        AccountExternalId extId = db.accountExternalIds().get(key);
        if (extId != null) {
            unlink(id, mailAddress);
        }
    }
}
#end_block

#method_before
private String readSshKey(String sshKey) throws UnsupportedEncodingException, IOException, InvalidSshKeyException {
    if (sshKey == null) {
        return null;
    }
    if ("-".equals(sshKey)) {
        sshKey = "";
        BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));
        String line;
        while ((line = br.readLine()) != null) {
            sshKey += line + "\n";
        }
    }
    return sshKey.trim();
}
#method_after
private List<String> readSshKey(final List<String> sshKeys) throws UnsupportedEncodingException, IOException {
    if (!sshKeys.isEmpty()) {
        String sshKey = "";
        int idx = sshKeys.indexOf("-");
        if (idx >= 0) {
            sshKey = "";
            BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));
            String line;
            while ((line = br.readLine()) != null) {
                sshKey += line + "\n";
            }
            sshKeys.set(idx, sshKey);
        }
    }
    return sshKeys;
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            rp.sendMessage("You are not allowed to perform this operation.\n" + "Configuration changes can only be pushed by project owners\n" + "who also have 'Push' rights");
        } else {
            rp.sendMessage("You are not allowed to perform this operation.\n" + "To push into this reference you need 'Push' rights." + MESSAGE_FOOTER);
        }
        reject(cmd, "Current user '" + ctl.getCurrentUser().getUserName() + "' can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "Deleting the project configuration is not allowed");
        } else {
            rp.sendMessage("You need 'Push' rights with the 'Force Push' flag set to delete references." + MESSAGE_FOOTER);
            reject(cmd, "Current user '" + ctl.getCurrentUser().getUserName() + "' can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        rp.sendMessage("You need 'Push' rights to upload code review requests.\n" + "Verify that you are pushing to the right branch." + MESSAGE_FOOTER);
        reject(cmd, "Current user '" + destBranchCtl.getCurrentUser().getUserName() + "' can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
        newProgress.update(1);
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(change, ps, info, reviewers);
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private void doReplaces() {
    for (final ReplaceRequest request : replaceByChange.values()) {
        try {
            doReplace(request);
        } catch (IOException err) {
            log.error("Error computing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "diff error");
        } catch (OrmException err) {
            log.error("Error storing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "database error");
        }
        if (request.cmd.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            log.error("Replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name() + " wasn't attempted." + "  This is a bug in the receive process implementation.");
            reject(request.cmd, "internal error");
        }
    }
}
#method_after
private void doReplaces() {
    for (final ReplaceRequest request : replaceByChange.values()) {
        try {
            doReplace(request, false);
            replaceProgress.update(1);
        } catch (IOException err) {
            log.error("Error computing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "diff error");
        } catch (OrmException err) {
            log.error("Error storing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "database error");
        }
        if (request.cmd.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            log.error("Replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name() + " wasn't attempted." + "  This is a bug in the receive process implementation.");
            reject(request.cmd, "internal error");
        }
    }
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request, boolean ignoreNoChanges) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq && !ignoreNoChanges) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet)) {
                    if (type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                        // If there was a negative vote on the prior patch set, carry it
                        // into this patch set.
                        // 
                        db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                    }
                }
            }
        }
        approvalsUtil.addReviewers(change, ps, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    addMessage(sb.toString());
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    ApprovalsUtil.syncChangeStatus(db, change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
@Override
public DeleteBranchesResult call() throws NoSuchProjectException, RepositoryNotFoundException, EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final DeleteBranchesResult result = new DeleteBranchesResult();
    final Iterator<Branch.NameKey> branchIt = toRemove.iterator();
    while (branchIt.hasNext()) {
        final Branch.NameKey k = branchIt.next();
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
        final List<Change> openChanges = db.changes().byBranchOpenAll(k).toList();
        if (!openChanges.isEmpty()) {
            if (!abandonOpenChanges) {
                result.addError(new DeleteBranchesResult.Error(DeleteBranchesResult.Error.Type.OPEN_CHANGES, k));
                branchIt.remove();
            } else {
                final boolean allAbandoned = abandon(openChanges, "Branch " + k.get() + " gets deleted.");
                if (!allAbandoned) {
                    result.addError(new DeleteBranchesResult.Error(DeleteBranchesResult.Error.Type.ABANDON_FAILED, k));
                    branchIt.remove();
                }
            }
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName);
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result refUpdateResult;
            final RefUpdate u;
            try {
                u = r.updateRef(refname);
                u.setForceUpdate(true);
                refUpdateResult = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(refUpdateResult) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefUpdatedHook(branchKey, u, identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + refUpdateResult.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + refUpdateResult.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    result.setDeletedBranches(deleted);
    return result;
}
#method_after
@Override
public Set<Branch.NameKey> call() throws NoSuchProjectException, RepositoryNotFoundException, OrmException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final Iterator<Branch.NameKey> branchIt = toRemove.iterator();
    while (branchIt.hasNext()) {
        final Branch.NameKey k = branchIt.next();
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
        if (db.changes().byBranchOpenAll(k).iterator().hasNext()) {
            branchIt.remove();
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName);
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result result;
            final RefUpdate u;
            try {
                u = r.updateRef(refname);
                u.setForceUpdate(true);
                result = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(result) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefUpdatedHook(branchKey, u, identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + result.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + result.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    return deleted;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.listBranches(getProjectKey(), new ScreenLoadCallback<ListBranchesResult>(this) {

        @Override
        public void preDisplay(final ListBranchesResult result) {
            if (result.getNoRepository()) {
                branches.setVisible(false);
                addPanel.setVisible(false);
                abandonOpenChanges.setVisible(false);
                delBranch.setVisible(false);
                Label no = new Label(Util.C.errorNoGitRepository());
                no.setStyleName(Gerrit.RESOURCES.css().smallHeading());
                add(no);
            } else {
                enableForm(true);
                display(result.getBranches());
                addPanel.setVisible(result.getCanAdd());
            }
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.listBranches(getProjectKey(), new ScreenLoadCallback<ListBranchesResult>(this) {

        @Override
        public void preDisplay(final ListBranchesResult result) {
            if (result.getNoRepository()) {
                branches.setVisible(false);
                addPanel.setVisible(false);
                delBranch.setVisible(false);
                Label no = new Label(Util.C.errorNoGitRepository());
                no.setStyleName(Gerrit.RESOURCES.css().smallHeading());
                add(no);
            } else {
                enableForm(true);
                display(result.getBranches());
                addPanel.setVisible(result.getCanAdd());
            }
        }
    });
}
#end_block

#method_before
private void display(final List<Branch> listBranches) {
    branches.display(listBranches);
    abandonOpenChanges.setVisible(branches.hasBranchCanDelete());
    delBranch.setVisible(branches.hasBranchCanDelete());
}
#method_after
private void display(final List<Branch> listBranches) {
    branches.display(listBranches);
    delBranch.setVisible(branches.hasBranchCanDelete());
}
#end_block

#method_before
private void enableForm(final boolean on) {
    abandonOpenChanges.setEnabled(on);
    delBranch.setEnabled(on);
    addBranch.setEnabled(on);
    nameTxtBox.setEnabled(on);
    irevTxtBox.setEnabled(on);
}
#method_after
private void enableForm(final boolean on) {
    delBranch.setEnabled(on);
    addBranch.setEnabled(on);
    nameTxtBox.setEnabled(on);
    irevTxtBox.setEnabled(on);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(2, 2);
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(50);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    abandonOpenChanges = new CheckBox(Util.C.checkboxAbandonOpenChanges());
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    final VerticalPanel v = new VerticalPanel();
    v.add(abandonOpenChanges);
    v.add(delBranch);
    add(v);
    add(addPanel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(2, 2);
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(50);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    add(delBranch);
    add(addPanel);
}
#end_block

#method_before
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    if (abandonOpenChanges.getValue()) {
        b.append(Gerrit.C.branchDeletionAndAbandonOpenChangesConfirmationMessage());
    } else {
        b.append(Gerrit.C.branchDeletionConfirmationMessage());
    }
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids, abandonOpenChanges.getValue());
        }
    });
    confirmationDialog.center();
}
#method_after
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchDeletionConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids);
        }
    });
    confirmationDialog.center();
}
#end_block

#method_before
private void deleteBranches(final Set<Branch.NameKey> branchIds, final boolean abandonOpenChanges) {
    Util.PROJECT_SVC.deleteBranch(getProjectKey(), branchIds, abandonOpenChanges, new GerritCallback<DeleteBranchesResult>() {

        public void onSuccess(final DeleteBranchesResult result) {
            final Set<NameKey> deletedBranches = result.getDeletedBranches();
            if (!deletedBranches.isEmpty()) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final Branch k = getRowItem(row);
                    if (k != null && deletedBranches.contains(k.getNameKey())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
            }
            if (result.hasErrors()) {
                final SafeHtmlBuilder b = new SafeHtmlBuilder();
                final Set<Branch.NameKey> branchesWithOpenChanges = new HashSet<Branch.NameKey>();
                final Set<Branch.NameKey> branchesWithOpenChangesThatCannotBeAbandoned = new HashSet<Branch.NameKey>();
                for (final DeleteBranchesResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case OPEN_CHANGES:
                            branchesWithOpenChanges.add(e.getBranchKey());
                            break;
                        case ABANDON_FAILED:
                            branchesWithOpenChangesThatCannotBeAbandoned.add(e.getBranchKey());
                            break;
                        default:
                            b.append(Gerrit.M.branchDeletionFailed(e.getBranchKey().get(), e.toString()));
                            b.br();
                    }
                }
                if (!branchesWithOpenChanges.isEmpty()) {
                    b.append(Util.C.branchDeletionOpenChanges());
                    b.br();
                    appendBranchOpenChangesLinks(b, branchesWithOpenChanges);
                }
                if (!branchesWithOpenChangesThatCannotBeAbandoned.isEmpty()) {
                    b.append(Util.C.branchDeletionAbandonFailed());
                    b.br();
                    appendBranchOpenChangesLinks(b, branchesWithOpenChangesThatCannotBeAbandoned);
                }
                new ErrorDialog(b.toSafeHtml()).center();
            }
        }

        private void appendBranchOpenChangesLinks(final SafeHtmlBuilder b, final Set<Branch.NameKey> branches) {
            b.openElement("p");
            for (final Branch.NameKey branch : branches) {
                b.openAnchor();
                final BranchLink link = new BranchLink(branch.getParentKey(), Change.Status.NEW, branch.get(), null);
                b.setAttribute("href", "/#" + link.getTargetHistoryToken());
                b.setAttribute("target", "_blank");
                b.append(branch.get());
                b.closeAnchor();
                b.br();
            }
            b.closeElement("p");
        }
    });
}
#method_after
private void deleteBranches(final Set<Branch.NameKey> branchIds) {
    Util.PROJECT_SVC.deleteBranch(getProjectKey(), branchIds, new GerritCallback<Set<Branch.NameKey>>() {

        public void onSuccess(final Set<Branch.NameKey> deleted) {
            if (!deleted.isEmpty()) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final Branch k = getRowItem(row);
                    if (k != null && deleted.contains(k.getNameKey())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
            }
            branchIds.removeAll(deleted);
            if (!branchIds.isEmpty()) {
                final VerticalPanel p = new VerticalPanel();
                final ErrorDialog errorDialog = new ErrorDialog(p);
                final Label l = new Label(Util.C.branchDeletionOpenChanges());
                l.setStyleName(Gerrit.RESOURCES.css().errorDialogText());
                p.add(l);
                for (final Branch.NameKey branch : branchIds) {
                    final BranchLink link = new BranchLink(branch.getParentKey(), Change.Status.NEW, branch.get(), null) {

                        @Override
                        public void go() {
                            errorDialog.hide();
                            super.go();
                        }
                    };
                    p.add(link);
                }
                errorDialog.center();
            }
        }
    });
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    try {
        final ReviewDb db = schema.open();
        try {
            p.parentsRevision = patchSetInfoFactory.get(db, patchSet.getId()).getParentRevisons();
        } finally {
            db.close();
        }
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(e);
        e.printStackTrace();
    } catch (OrmException e) {
        log.error(e);
        e.printStackTrace();
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    }
    return p;
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (ProjectConfigSection.isValidReferenceSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmConcurrencyException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!projectControl.isOwner()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValidReferenceSection(name)) {
                if (!projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefControl.validateRefPattern(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (projectControl.isOwner()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        if (config.commit(md)) {
            projectCache.evict(config.getProject());
            return projectAccessFactory.create(projectName).call();
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } finally {
        md.close();
    }
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmConcurrencyException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!projectControl.isOwner()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (!projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefControl.validateRefPattern(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (projectControl.isOwner()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        if (config.commit(md)) {
            projectCache.evict(config.getProject());
            return projectAccessFactory.create(projectName).call();
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } finally {
        md.close();
    }
}
#end_block

#method_before
public boolean isVisible() {
    return projectControl.visibleForReplication() || canPerform(Permission.READ);
}
#method_after
public boolean isVisible() {
    return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && canRead();
}
#end_block

#method_before
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH);
}
#method_after
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE);
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT);
}
#method_after
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && canWrite();
}
#end_block

#method_before
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH);
}
#method_after
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canForceUpdate() {
    return canPushWithForce() || canDelete();
}
#method_after
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && canWrite();
}
#end_block

#method_before
private boolean canPushWithForce() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#method_after
private boolean canPushWithForce() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
public static void validateRefPattern(String refPattern) throws InvalidNameException {
    if (refPattern.startsWith(ProjectConfigSection.REGEX_PREFIX)) {
        if (!Repository.isValidRefName(RefControl.shortestExample(refPattern))) {
            throw new InvalidNameException();
        }
    } else if (refPattern.equals(ProjectConfigSection.ALL)) {
    // This is a special case we have to allow, it fails below.
    } else if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!Repository.isValidRefName(prefix)) {
            throw new InvalidNameException(refPattern);
        }
    } else if (!Repository.isValidRefName(refPattern)) {
        throw new InvalidNameException(refPattern);
    }
}
#method_after
public static void validateRefPattern(String refPattern) throws InvalidNameException {
    if (refPattern.startsWith(RefConfigSection.REGEX_PREFIX)) {
        if (!Repository.isValidRefName(RefControl.shortestExample(refPattern))) {
            throw new InvalidNameException(refPattern);
        }
    } else if (refPattern.equals(RefConfigSection.ALL)) {
    // This is a special case we have to allow, it fails below.
    } else if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!Repository.isValidRefName(prefix)) {
            throw new InvalidNameException(refPattern);
        }
    } else if (!Repository.isValidRefName(refPattern)) {
        throw new InvalidNameException(refPattern);
    }
}
#end_block

#method_before
static SectionMatcher wrap(AccessSection section) {
    String ref = section.getName();
    if (AccessSection.isValidReferenceSection(ref)) {
        return wrap(ref, section);
    } else {
        return null;
    }
}
#method_after
static SectionMatcher wrap(AccessSection section) {
    String ref = section.getName();
    if (AccessSection.isValid(ref)) {
        return wrap(ref, section);
    } else {
        return null;
    }
}
#end_block

#method_before
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && ProjectConfigSection.isValidReferenceSection(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#method_after
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && RefConfigSection.isValid(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (ProjectConfigSection.isValidReferenceSection(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (RefConfigSection.isValid(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    } else if (ProjectConfigSection.isValidReferenceSection(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isValidReferenceSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isValidReferenceSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public int compare(final String pattern1, final String pattern2) {
    int cmp = distance(pattern1) - distance(pattern2);
    if (cmp == 0) {
        boolean p1_finite = finite(pattern1);
        boolean p2_finite = finite(pattern2);
        if (p1_finite && !p2_finite) {
            cmp = -1;
        } else if (!p1_finite && p2_finite) {
            cmp = 1;
        } else /* if (f1 == f2) */
        {
            cmp = 0;
        }
    }
    if (cmp == 0) {
        cmp = transitions(pattern1) - transitions(pattern2);
    }
    if (cmp == 0) {
        cmp = pattern2.length() - pattern1.length();
    }
    return cmp;
}
#method_after
@Override
public int compare(RefConfigSection a, RefConfigSection b) {
    return compare(a.getName(), b.getName());
}
#end_block

#method_before
@Rewrite("status:open P=(project:*) B=(branch:*) S=(sortkey_before:*) L=(limit:*)")
public Predicate<ChangeData> r05_byBranchOpenNext(@Named("P") final ProjectPredicate p, @Named("B") final BranchPredicate b, @Named("S") final SortKeyPredicate.Before s, @Named("L") final IntPredicate<ChangeData> l) {
    return new PaginatedSource(500, s.getValue(), l.intValue()) {

        @Override
        ResultSet<Change> scan(ChangeAccess a, String key, int limit) throws OrmException {
            return a.byBranchOpenNext(new Branch.NameKey(p.getValueKey(), b.getValue()), key, limit);
        }

        @Override
        public boolean match(ChangeData cd) throws OrmException {
            return // 
            cd.change(dbProvider).getStatus().isOpen() && // 
            p.match(cd) && // 
            b.match(cd) && s.match(cd);
        }
    };
}
#method_after
@Rewrite("status:open P=(project:*) B=(branch:*) S=(sortkey_before:*) L=(limit:*)")
public Predicate<ChangeData> r05_byBranchOpenNext(@Named("P") final ProjectPredicate p, @Named("B") final BranchPredicate b, @Named("S") final SortKeyPredicate.Before s, @Named("L") final IntPredicate<ChangeData> l) {
    return new PaginatedSource(500, s.getValue(), l.intValue()) {

        @Override
        ResultSet<Change> scan(ChangeAccess a, String key, int limit) throws OrmException {
            return a.byBranchOpenAll(new Branch.NameKey(p.getValueKey(), b.getValue()));
        }

        @Override
        public boolean match(ChangeData cd) throws OrmException {
            return // 
            cd.change(dbProvider).getStatus().isOpen() && // 
            p.match(cd) && // 
            b.match(cd) && s.match(cd);
        }
    };
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
private void publishApprovals(ChangeControl ctl) throws InvalidChangeOperationException, OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(ctl, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            functionState.normalize(types.byId(a.getCategoryId()), a);
        }
        if (o != a.getValue()) {
            throw new InvalidChangeOperationException(types.byId(a.getCategoryId()).getCategory().getLabelName() + "=" + o + " not permitted");
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#method_after
private void publishApprovals(ChangeControl ctl) throws InvalidChangeOperationException, OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(ctl, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            functionState.normalize(types.byId(a.getCategoryId()), a);
        }
        if (want.get() != a.getValue()) {
            throw new InvalidChangeOperationException(types.byId(a.getCategoryId()).getCategory().getLabelName() + "=" + want.get() + " not permitted");
        }
        if (o != a.getValue()) {
            // Value changed, ensure we update the database.
            // 
            a.setGranted();
            dirty.add(a.getCategoryId());
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#end_block

#method_before
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#method_after
private void email() {
    if (message == null) {
        return;
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSetInfo patchSetInfo;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSetInfo = patchSetInfoFactory.get(reviewDb, patchSetId);
                } finally {
                    reviewDb.close();
                }
            } catch (PatchSetInfoNotAvailableException e) {
                log.error("Cannot read PatchSetInfo of " + patchSetId, e);
                return;
            } catch (OrmException e) {
                log.error("Cannot email comments for " + patchSetId, e);
                return;
            }
            try {
                final CommentSender cm = commentSenderFactory.create(change);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, patchSetInfo);
                cm.setChangeMessage(message);
                cm.setPatchLineComments(drafts);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot email comments for " + patchSetId, e);
            }
        }

        @Override
        public String toString() {
            return "send-email comments";
        }
    }));
}
#end_block

#method_before
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    return projectCache.get(parentResolver.get(getProject()));
}
#method_after
public ProjectState getParentState() {
    if (isAllProjects) {
        return null;
    }
    return projectCache.get(getProject().getParent(allProjectsName));
}
#end_block

#method_before
public Project.NameKey getParentName() {
    return parentResolver.get(project);
}
#method_after
public Project.NameKey getParentName() {
    return project.getParent(allProjectsName);
}
#end_block

#method_before
private Set<Project.NameKey> getAllParents(final Project.NameKey projectName) {
    final Set<Project.NameKey> parents = new HashSet<Project.NameKey>();
    Project.NameKey p = projectName;
    while (p != null && parents.add(p)) {
        final ProjectState e = projectCache.get(p);
        if (e == null) {
            // If we can't get it from the cache, pretend it's not present.
            break;
        }
        p = parentResolver.get(e.getProject());
    }
    return parents;
}
#method_after
private Set<Project.NameKey> getAllParents(final Project.NameKey projectName) {
    final Set<Project.NameKey> parents = new HashSet<Project.NameKey>();
    Project.NameKey p = projectName;
    while (p != null && parents.add(p)) {
        final ProjectState e = projectCache.get(p);
        if (e == null) {
            // If we can't get it from the cache, pretend it's not present.
            break;
        }
        p = e.getProject().getParent(allProjectsName);
    }
    return parents;
}
#end_block

#method_before
private List<Project> getChildren(final Project.NameKey parentName) {
    final List<Project> childProjects = new ArrayList<Project>();
    for (final Project.NameKey projectName : projectCache.all()) {
        final ProjectState e = projectCache.get(projectName);
        if (e == null) {
            // If we can't get it from the cache, pretend it's not present.
            continue;
        }
        if (parentName.equals(parentResolver.get(e.getProject()))) {
            childProjects.add(e.getProject());
        }
    }
    return childProjects;
}
#method_after
private List<Project> getChildren(final Project.NameKey parentName) {
    final List<Project> childProjects = new ArrayList<Project>();
    for (final Project.NameKey projectName : projectCache.all()) {
        final ProjectState e = projectCache.get(projectName);
        if (e == null) {
            // If we can't get it from the cache, pretend it's not present.
            continue;
        }
        if (parentName.equals(e.getProject().getParent(projectName))) {
            childProjects.add(e.getProject());
        }
    }
    return childProjects;
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    detail.setInheritsFrom(parentResolver.get(config.getProject()));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.display(diffBaseId, detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchSideBySide(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchUnified(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchSideBySide(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchUnified(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.display(diffBaseId, result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    if (c.currPatchSetId().equals(ps.getId())) {
        d.isCurrentPatchSet = "true";
    } else {
        d.isCurrentPatchSet = "false";
    }
    return d;
}
#method_after
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    d.isCurrentPatchSet = c.currPatchSetId().equals(ps.getId());
    return d;
}
#end_block

#method_before
private void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        messageSender.sendMessage("");
        messageSender.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                messageSender.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                messageSender.sendMessage("  " + url + c.getChangeId());
            }
        }
        messageSender.sendMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        messageSender.sendMessage("");
        messageSender.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                messageSender.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                messageSender.sendMessage("  " + url + c.getChangeId());
            }
        }
        messageSender.sendMessage("");
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    messageSender.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    messageSender.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#end_block

#method_before
private void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                addMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                addMessage("  " + url + c.getChangeId());
            }
        }
        addMessage("");
    }
    sendMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands) {
    try {
        parseCommands(commands);
        if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            createNewChanges();
        }
        doReplaces();
        for (final ReceiveCommand c : commands) {
            if (c.getResult() == Result.OK) {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only schedule direct refs updates for replication.
                    // Change refs are scheduled when they are created.
                    // 
                    replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                    Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                    hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            }
        }
        if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
            final String url = canonicalWebUrl;
            addMessage("");
            addMessage("New Changes:");
            for (final Change c : allNewChanges) {
                if (c.getStatus() == Change.Status.DRAFT) {
                    addMessage("  " + url + c.getChangeId() + " [DRAFT]");
                } else {
                    addMessage("  " + url + c.getChangeId());
                }
            }
            addMessage("");
        }
    } finally {
        sendMessages();
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send email for new change";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send email for new patch set";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send email for submitted patch set";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private void email() {
    if (message == null) {
        return;
    }
    final PatchSetInfo patchSetInfo;
    try {
        patchSetInfo = patchSetInfoFactory.get(db, patchSetId);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
        return;
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CommentSender cm = commentSenderFactory.create(change);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, patchSetInfo);
                cm.setChangeMessage(message);
                cm.setPatchLineComments(drafts);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send comments by email for patch set " + patchSetId, e);
            }
        }

        @Override
        public String toString() {
            return "send email for patch set comments";
        }
    }));
}
#method_after
private void email() {
    if (message == null) {
        return;
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSetInfo patchSetInfo;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSetInfo = patchSetInfoFactory.get(reviewDb, patchSetId);
                } finally {
                    reviewDb.close();
                }
            } catch (PatchSetInfoNotAvailableException e) {
                log.error("Cannot read PatchSetInfo of " + patchSetId, e);
                return;
            } catch (OrmException e) {
                log.error("Cannot email comments for " + patchSetId, e);
                return;
            }
            try {
                final CommentSender cm = commentSenderFactory.create(change);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, patchSetInfo);
                cm.setChangeMessage(message);
                cm.setPatchLineComments(drafts);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot email comments for " + patchSetId, e);
            }
        }

        @Override
        public String toString() {
            return "send-email comments";
        }
    }));
}
#end_block

#method_before
private PersonIdent computeAuthor(final List<CodeReviewCommit> codeReviewCommits) {
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : codeReviewCommits) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : codeReviewCommits) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(codeReviewCommits.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    return authorIdent;
}
#method_after
private PersonIdent computeAuthor(final List<CodeReviewCommit> codeReviewCommits) {
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : codeReviewCommits) {
        PatchSetApproval s = getSubmitter(db, c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : codeReviewCommits) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(codeReviewCommits.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    return authorIdent;
}
#end_block

#method_before
private void markCleanMerges() throws MergeException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.reset();
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.patchsetId != null) {
                c.statusCode = CommitMergeStatus.CLEAN_MERGE;
                if (branchUpdate.getRefLogIdent() == null) {
                    setRefLogIdent(getSubmitter(c.patchsetId));
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot mark clean merges", e);
    }
}
#method_after
private void markCleanMerges() throws MergeException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.reset();
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.patchsetId != null) {
                c.statusCode = CommitMergeStatus.CLEAN_MERGE;
                if (branchUpdate.getRefLogIdent() == null) {
                    setRefLogIdent(getSubmitter(db, c.patchsetId));
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot mark clean merges", e);
    }
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private PatchSetApproval getSubmitter(PatchSet.Id c) {
    if (c == null) {
        return null;
    }
    PatchSetApproval submitter = null;
    try {
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byPatchSet(c).toList();
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
        }
    } catch (OrmException e) {
    }
    return submitter;
}
#method_after
private static PatchSetApproval getSubmitter(ReviewDb reviewDb, PatchSet.Id c) {
    if (c == null) {
        return null;
    }
    PatchSetApproval submitter = null;
    try {
        final List<PatchSetApproval> approvals = reviewDb.patchSetApprovals().byPatchSet(c).toList();
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
        }
    } catch (OrmException e) {
    }
    return submitter;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final PatchSet patchSet = db.patchSets().get(c.currentPatchSetId());
        final PatchSetApproval from = submitter;
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(c);
                    if (from != null) {
                        cm.setFrom(from.getAccountId());
                    }
                    cm.setPatchSet(patchSet);
                    cm.send();
                } catch (EmailException e) {
                    log.error("Cannot send email for submitted patch set " + c.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send email for submitted patch set";
            }
        }));
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (OrmException e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final PatchSet patchSet = db.patchSets().get(c.currentPatchSetId());
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergeFailSender cm = mergeFailSenderFactory.create(c);
                    final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
                    if (submitter != null) {
                        cm.setFrom(submitter.getAccountId());
                    }
                    cm.setPatchSet(patchSet);
                    cm.setChangeMessage(msg);
                    cm.send();
                } catch (EmailException e) {
                    log.error("Cannot send email notifications about merge failure", e);
                }
            }

            @Override
            public String toString() {
                return "send email for merge failure";
            }
        }));
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            PatchSetApproval submitter;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                    submitter = getSubmitter(reviewDb, c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (OrmException e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (submitter != null) {
                    cm.setFrom(submitter.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
}
#end_block

#method_before
@Override
public final com.google.gwtorm.client.ResultSet<T> get(final Iterable<K> keys) throws OrmException {
    final Collection<K> keySet;
    if (keys instanceof Collection) {
        keySet = (Collection<K>) keys;
    } else {
        keySet = new ArrayList<K>();
        for (final K k : keys) {
            keySet.add(k);
        }
    }
    switch(keySet.size()) {
        case 0:
            // 
            return new ListResultSet<T>(Collections.<T>emptyList());
        case 1:
            {
                // Only one key requested, use a faster equality lookup.
                // 
                final T entity = get(keySet.iterator().next());
                if (entity != null) {
                    return new ListResultSet<T>(Collections.singletonList(entity));
                }
                return new ListResultSet<T>(Collections.<T>emptyList());
            }
        default:
            return getBySqlIn(keySet);
    }
}
#method_after
@Override
public final com.google.gwtorm.server.ResultSet<T> get(final Iterable<K> keys) throws OrmException {
    final Collection<K> keySet;
    if (keys instanceof Collection) {
        keySet = (Collection<K>) keys;
    } else {
        keySet = new ArrayList<K>();
        for (final K k : keys) {
            keySet.add(k);
        }
    }
    switch(keySet.size()) {
        case 0:
            // 
            return new ListResultSet<T>(Collections.<T>emptyList());
        case 1:
            {
                // Only one key requested, use a faster equality lookup.
                // 
                final T entity = get(keySet.iterator().next());
                if (entity != null) {
                    return new ListResultSet<T>(Collections.singletonList(entity));
                }
                return new ListResultSet<T>(Collections.<T>emptyList());
            }
        default:
            return getBySqlIn(keySet);
    }
}
#end_block

#method_before
protected com.google.gwtorm.client.ResultSet<T> getBySqlIn(final Collection<K> keys) throws OrmException {
    return super.get(keys);
}
#method_after
protected com.google.gwtorm.server.ResultSet<T> getBySqlIn(final Collection<K> keys) throws OrmException {
    return super.get(keys);
}
#end_block

#method_before
protected ListResultSet<T> queryList(final PreparedStatement ps) throws OrmException {
    try {
        try {
            final ResultSet rs = ps.executeQuery();
            try {
                final ArrayList<T> r = new ArrayList<T>();
                while (rs.next()) {
                    final T o = newEntityInstance();
                    bindOneFetch(rs, o);
                    r.add(o);
                }
                return new ListResultSet<T>(r);
            } finally {
                rs.close();
            }
        } finally {
            ps.close();
        }
    } catch (SQLException e) {
        throw convertError("fetch", e);
    }
}
#method_after
protected com.google.gwtorm.server.ResultSet<T> queryList(final PreparedStatement ps) throws OrmException {
    final ResultSet rs;
    try {
        rs = ps.executeQuery();
        if (!rs.next()) {
            rs.close();
            ps.close();
            return new ListResultSet<T>(Collections.<T>emptyList());
        }
    } catch (SQLException err) {
        try {
            ps.close();
        } catch (SQLException e) {
        // Ignored.
        }
        throw convertError("fetch", err);
    }
    return new JdbcResultSet<T, K>(this, rs, ps);
}
#end_block

#method_before
private void insertIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getInsertOneSql());
            }
            bindOneInsert(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                throw new OrmConcurrencyException();
            }
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#method_after
private void insertIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        boolean concurrencyViolationDetected = false;
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getInsertOneSql());
            }
            bindOneInsert(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                concurrencyViolationDetected = true;
            }
        }
        if (concurrencyViolationDetected) {
            throw new OrmConcurrencyException();
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#end_block

#method_before
private void updateIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getUpdateOneSql());
            }
            bindOneUpdate(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                throw new OrmConcurrencyException();
            }
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#method_after
private void updateIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        boolean concurrencyViolationDetected = false;
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getUpdateOneSql());
            }
            bindOneUpdate(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                concurrencyViolationDetected = true;
            }
        }
        if (concurrencyViolationDetected) {
            throw new OrmConcurrencyException();
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#end_block

#method_before
private Collection<T> attemptUpdateAsBatch(final Iterable<T> instances) throws OrmException {
    Collection<T> inserts = null;
    try {
        PreparedStatement ps = null;
        try {
            int cnt = 0;
            List<T> allInstances = new ArrayList<T>();
            for (final T o : instances) {
                if (ps == null) {
                    ps = schema.getConnection().prepareStatement(getUpdateOneSql());
                }
                bindOneUpdate(ps, o);
                ps.addBatch();
                allInstances.add(o);
                cnt++;
            }
            if (0 < cnt) {
                final int[] states = ps.executeBatch();
                if (states == null) {
                    inserts = new ArrayList<T>(cnt);
                    for (T o : allInstances) {
                        inserts.add(o);
                    }
                } else {
                    int i = 0;
                    for (T o : allInstances) {
                        if (states.length <= i || states[i] != 1) {
                            if (inserts == null) {
                                inserts = new ArrayList<T>(cnt - i);
                            }
                            inserts.add(o);
                        }
                        i++;
                    }
                }
            }
        } finally {
            if (ps != null) {
                ps.close();
            }
        }
    } catch (SQLException e) {
        throw convertError("update", e);
    }
    return inserts;
}
#method_after
private Collection<T> attemptUpdateAsBatch(final Iterable<T> instances) throws OrmException {
    Collection<T> inserts = null;
    try {
        PreparedStatement ps = null;
        try {
            int cnt = 0;
            List<T> allInstances = new ArrayList<T>();
            for (final T o : instances) {
                if (ps == null) {
                    ps = schema.getConnection().prepareStatement(getUpdateOneSql());
                }
                bindOneUpdate(ps, o);
                ps.addBatch();
                allInstances.add(o);
                cnt++;
            }
            if (0 < cnt) {
                final int[] states = ps.executeBatch();
                if (states == null) {
                    inserts = allInstances;
                } else {
                    int i = 0;
                    for (T o : allInstances) {
                        if (states.length <= i || states[i] != 1) {
                            if (inserts == null) {
                                inserts = new ArrayList<T>(cnt - i);
                            }
                            inserts.add(o);
                        }
                        i++;
                    }
                }
            }
        } finally {
            if (ps != null) {
                ps.close();
            }
        }
    } catch (SQLException e) {
        throw convertError("update", e);
    }
    return inserts;
}
#end_block

#method_before
private void deleteIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getDeleteOneSql());
            }
            bindOneDelete(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                throw new OrmConcurrencyException();
            }
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#method_after
private void deleteIndividually(Iterable<T> instances) throws SQLException, OrmConcurrencyException {
    PreparedStatement ps = null;
    try {
        boolean concurrencyViolationDetected = false;
        for (final T o : instances) {
            if (ps == null) {
                ps = schema.getConnection().prepareStatement(getDeleteOneSql());
            }
            bindOneDelete(ps, o);
            int updateCount = ps.executeUpdate();
            if (updateCount != 1) {
                concurrencyViolationDetected = true;
            }
        }
        if (concurrencyViolationDetected) {
            throw new OrmConcurrencyException();
        }
    } finally {
        if (ps != null) {
            ps.close();
        }
    }
}
#end_block

#method_before
private OrmException convertError(final String op, final SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return schema.getDialect().convertError(op, getRelationName(), err);
}
#method_after
protected OrmException convertError(final String op, final SQLException err) {
    if (err.getCause() == null && err.getNextException() != null) {
        err.initCause(err.getNextException());
    }
    return schema.getDialect().convertError(op, getRelationName(), err);
}
#end_block

#method_before
public long nextLong(final Connection conn, final String query) throws OrmException {
    try {
        final Statement st = conn.createStatement();
        try {
            final ResultSet rs = st.executeQuery(query);
            try {
                if (!rs.next()) {
                    throw new SQLException("No result row for sequence query");
                }
                final long r = rs.getLong(1);
                if (rs.next()) {
                    throw new SQLException("Too many results from sequence query");
                }
                return r;
            } finally {
                rs.close();
            }
        } finally {
            st.close();
        }
    } catch (SQLException e) {
        throw convertError("sequence", query, e);
    }
}
#method_after
public long nextLong(final Connection conn, final String poolName) throws OrmException {
    final String query = getNextSequenceValueSql(poolName);
    try {
        final Statement st = conn.createStatement();
        try {
            final ResultSet rs = st.executeQuery(query);
            try {
                if (!rs.next()) {
                    throw new SQLException("No result row for sequence query");
                }
                final long r = rs.getLong(1);
                if (rs.next()) {
                    throw new SQLException("Too many results from sequence query");
                }
                return r;
            } finally {
                rs.close();
            }
        } finally {
            st.close();
        }
    } catch (SQLException e) {
        throw convertError("sequence", query, e);
    }
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", null, id);
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("", diffBase, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", null, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("unified", diffBase, id);
}
#end_block

#method_before
public static String toPatch(final PatchScreen.Type type, final Patch.Key id) {
    if (type == PatchScreen.Type.SIDE_BY_SIDE) {
        return toPatchSideBySide(id);
    } else {
        return toPatchUnified(id);
    }
}
#method_after
private static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    PatchSet.Id ps = id.getParentKey();
    Change.Id c = ps.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(ps.get()).append("/").append(KeyUtil.encode(id.get()));
    if (type != null && !type.isEmpty()) {
        p.append(",").append(type);
    }
    return p.toString();
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
public static void patch(String token, final Patch.Key id, final int patchIndex, final PatchSetDetail patchSetDetail, final PatchTable patchTable, final PatchScreen.TopView topView, final String panelType) {
    final String parametersUrl;
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        parametersUrl = token.substring(token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) + 1);
        token = token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START));
    } else {
        parametersUrl = null;
    }
    final PatchScreen.TopView top = topView == null ? Gerrit.getPatchScreenTopView() : topView;
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (id != null) {
                String panel = panelType;
                if (panel == null) {
                    int c = token.lastIndexOf(',');
                    panel = 0 <= c ? token.substring(c + 1) : "";
                }
                if ("".equals(panel)) {
                    return new // 
                    PatchScreen.SideBySide(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                } else if ("unified".equals(panel)) {
                    return new // 
                    PatchScreen.Unified(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
public static void patch(String token, PatchSet.Id base, Patch.Key id, int patchIndex, PatchSetDetail patchSetDetail, PatchTable patchTable, PatchScreen.TopView topView) {
    patch(token, base, id, patchIndex, patchSetDetail, patchTable, topView, null);
}
#end_block

#method_before
private static String skip(String token) {
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        return token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START)).substring(prefixlen);
    } else {
        return token.substring(prefixlen);
    }
}
#method_after
private static String skip(String token) {
    return token.substring(prefixlen);
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && prefs.getOld().isManualReview() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(idSideA, result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(idSideA, result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.display(diffBaseId, detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    addHandlerForDiffButton(detail);
    actionsPanel.add(diffAllSideBySide);
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchSideBySide(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchUnified(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    Gerrit.display(PageLinks.MINE);
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                public void onSuccess(final ChangeDetail result) {
                    if (result != null) {
                        changeScreen.update(result);
                    } else {
                        Gerrit.display(PageLinks.MINE);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
            hOfdiffAllSideBySide.removeHandler();
            hOfdiffAllUnified.removeHandler();
            addHandlerForDiffButton(result);
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.display(diffBaseId, result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#method_after
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    base, // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && prefs.getOld().isManualReview() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean revd = false;
        if (isFirst && !prefs.get().isManualReview()) {
            revd = true;
            setReviewedByCurrentUser(revd);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    revd = p.isReviewedByCurrentUser();
                }
            }
        }
        reviewed.setValue(revd);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(RetrieveParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(VisibleProjectDetails.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(SuggestParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    vp = new VerticalPanel();
    addCreateProjectPanel();
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects());
    projectListPopup.addProjectListPopupHandler(new ProjectListPopupHandler() {

        @Override
        public void onClose(ProjectListPopupOnCloseEvent projectListPopupEvent) {
            resetHandlerRegistration();
        }

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            sugestParent.setText(projectListPopupEvent.getProjectName());
        }

        @Override
        public void onMovePointer(ProjectListPopupOnMovePointerEvent projectListPopupEvent) {
            // prevent user input from being overwritten by simply poping up
            if (!projectListPopupEvent.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectListPopupEvent.getProjectName());
            }
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
}
#end_block

#method_before
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    final HorizontalPanel bp = new HorizontalPanel();
    bp.add(create);
    bp.add(browse);
    fp.add(bp);
    vp.add(fp);
    initSuggestedParents();
    add(vp);
}
#method_after
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    fp.add(create);
    VerticalPanel vp = new VerticalPanel();
    vp.add(fp);
    initSuggestedParents();
    vp.add(suggestedParentsTab);
    add(vp);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    vp.add(suggestedParentsTab);
    Util.PROJECT_SVC.suggestParentCandidates(new AsyncCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    Util.PROJECT_SVC.suggestParentCandidates(new GerritCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
private void addGrid(final VerticalPanel fp) {
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#method_after
private void addGrid(final VerticalPanel fp) {
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    RetrieveParentCandidatesHandlerFactory.create().to(callback);
}
#method_after
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    suggestParentCandidatesHandlerFactory.create().to(callback);
}
#end_block

#method_before
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base = ObjectId.fromString(baseRevision);
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#method_after
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base;
    if (baseRevision != null && !baseRevision.isEmpty()) {
        base = ObjectId.fromString(baseRevision);
    } else {
        base = null;
    }
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#end_block

#method_before
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            ReviewResult result = null;
            try {
                result = deleteDraftFactory.create(psid).call();
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(result.getChangeId()));
            }
            if (result.getErrors().size() > 0) {
                throw new Failure(new NoSuchEntityException());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            ReviewResult result = null;
            try {
                result = deleteDraftPatchSetFactory.create(psid).call();
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(result.getChangeId()));
            }
            if (result.getErrors().size() > 0) {
                throw new Failure(new NoSuchEntityException());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraft.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change/patch set";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case NOT_A_DRAFT:
                errMsg += "change is not a draft";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDelete()) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
public boolean canPublish(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canPublish(final ReviewDb db) throws OrmException {
    return change.getStatus() == Change.Status.DRAFT && isOwner() && isVisible(db);
}
#end_block

#method_before
public boolean canDelete(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canDelete(final ReviewDb db) throws OrmException {
    return change.getStatus() == Change.Status.DRAFT && isOwner() && isVisible(db);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanPublish(control.canDelete(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(control.canDelete(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case CHANGE_NOT_VISIBLE:
                errMsg += "not permitted to review change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.isVisible(db) && !control.isOwner()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_NOT_VISIBLE));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.canPublish(db)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.PUBLISH_NOT_PERMITTED));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canCreateProject()) {
                String msg = String.format("fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
            }
            parseCommandLine();
            if (!suggestParent) {
                // 
                if (projectName == null) {
                    throw new Failure(1, "fatal: Option \"--name (-n)\" is required");
                }
                try {
                    final CreateProjectArgs args = new CreateProjectArgs();
                    args.setProjectName(projectName);
                    args.setOwnerIds(ownerIds);
                    args.setNewParent(newParent);
                    args.setPermissionsOnly(permissionsOnly);
                    args.setProjectDescription(projectDescription);
                    args.setSubmitType(submitType);
                    args.setContributorAgreements(contributorAgreements);
                    args.setSignedOffBy(signedOffBy);
                    args.setContentMerge(contentMerge);
                    args.setChangeIdRequired(requireChangeID);
                    args.setBranch(branch);
                    args.setCreateEmptyCommit(createEmptyCommit);
                    final CreateProject createProject = CreateProjectFactory.create(args);
                    createProject.createProject();
                } catch (ProjectCreationFailedException err) {
                    throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
                }
            } else {
                List<Project> parentCandidates = retrieveParentCandidatesFactory.create().getParentCandidates();
                PrintWriter p = toPrintWriter(out);
                for (Project parent : parentCandidates) {
                    p.print(parent.getNameKey() + "\n");
                }
                p.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canCreateProject()) {
                String msg = String.format("fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
            }
            PrintWriter p = toPrintWriter(out);
            parseCommandLine();
            try {
                if (!suggestParent) {
                    if (projectName == null) {
                        throw new UnloggedFailure(1, "fatal: Project name is required.");
                    }
                    final CreateProjectArgs args = new CreateProjectArgs();
                    args.setProjectName(projectName);
                    args.ownerIds = ownerIds;
                    args.newParent = newParent;
                    args.permissionsOnly = permissionsOnly;
                    args.projectDescription = projectDescription;
                    args.submitType = submitType;
                    args.contributorAgreements = contributorAgreements;
                    args.signedOffBy = signedOffBy;
                    args.contentMerge = contentMerge;
                    args.changeIdRequired = requireChangeID;
                    args.branch = branch;
                    args.createEmptyCommit = createEmptyCommit;
                    final CreateProject createProject = CreateProjectFactory.create(args);
                    createProject.createProject();
                } else {
                    Set<Project.NameKey> parentCandidates = retrieveParentCandidatesFactory.create().get();
                    for (Project.NameKey parent : parentCandidates) {
                        p.print(parent + "\n");
                    }
                }
            } catch (ProjectCreationFailedException err) {
                throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
            } finally {
                p.flush();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, IllegalStateException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final ReviewResult result = submitFactory.create(patchSetId).call();
    if (result.getErrors().size() > 0) {
        throw new IllegalStateException("Cannot submit " + result.getErrors().get(0));
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, IllegalStateException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final ReviewResult result = submitFactory.create(patchSetId).call();
    if (result.getErrors().size() > 0) {
        throw new IllegalStateException("Cannot submit " + result.getErrors().get(0).getMessageOrType());
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
// public ReviewResult call() throws EmailException,
@Override
public ReviewResult call() throws InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, patchSetId);
    if (submitResult.isEmpty()) {
        throw new InvalidChangeOperationException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new InvalidChangeOperationException("Unsupported SubmitRecord.Label.status");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
            default:
                throw new InvalidChangeOperationException("Unsupported SubmitRecord.status");
        }
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws IllegalStateException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, patchSetId);
    if (submitResult.isEmpty()) {
        throw new IllegalStateException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
                break;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ReviewResult result = null;
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            result = abandonChangeFactory.create(patchSetId, changeComment).call();
        } else if (restoreChange) {
            result = restoreChangeFactory.create(patchSetId, changeComment).call();
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> submitResult = changeControl.canSubmit(db, patchSetId);
        if (submitResult.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(submitResult.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : submitResult.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (submitResult.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + submitResult.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + submitResult.get(0).status);
        }
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
    if (result != null) {
        for (ReviewResult.Error resultError : result.getErrors()) {
            switch(resultError.getType()) {
                case ABANDON_NOT_PERMITTED:
                    writeError("error: not permitted to abandon change");
                case RESTORE_NOT_PERMITTED:
                    writeError("error: not permitted to restore change");
                default:
                    writeError("error: failure in review");
            }
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ReviewResult result = null;
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            result = abandonChangeFactory.create(patchSetId, changeComment).call();
        } else if (restoreChange) {
            result = restoreChangeFactory.create(patchSetId, changeComment).call();
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> submitResult = changeControl.canSubmit(db, patchSetId);
        if (submitResult.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(submitResult.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : submitResult.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (submitResult.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + submitResult.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + submitResult.get(0).status);
        }
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
    if (result != null) {
        for (ReviewResult.Error resultError : result.getErrors()) {
            switch(resultError.getType()) {
                case ABANDON_NOT_PERMITTED:
                    writeError("error: not permitted to abandon change");
                    break;
                case RESTORE_NOT_PERMITTED:
                    writeError("error: not permitted to restore change");
                    break;
                default:
                    writeError("error: failure in review");
            }
        }
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canRestore()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a messaage to accompany the restored change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
        if (changeComment != null && changeComment.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(changeComment);
        }
        cmsg.setMessage(msgBuf.toString());
        // Restore the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
        hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canRestore()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the restored change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
        if (changeComment != null && changeComment.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(changeComment);
        }
        cmsg.setMessage(msgBuf.toString());
        // Restore the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
        hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    }
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
        updateSubscriptions();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : rw.getRepository().getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#method_after
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : db.getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#end_block

#method_before
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final Merger m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m;
    if (destProject.isUseContentMerge()) {
        // Settings for this project allow us to try and
        // automatically resolve conflicts within files if needed.
        // Use ResolveMerge and instruct to operate in core.
        m = MergeStrategy.RESOLVE.newMerger(db, true);
    } else {
        // No auto conflict resolving allowed. If any of the
        // affected files was modified, merge will fail.
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    }
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip, n });
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    mergeTip = (CodeReviewCommit) rw.parseCommit(id);
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void cherryPickChanges() throws MergeException, OrmException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip });
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (branchTip == null || branchTip != mergeTip) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void updateSubscriptions() {
    // Note: The merge is already performed so we shall not throw an exception
    // on failure.
    Transaction txn = null;
    final String gitmodulesFile = ".gitmodules";
    File tmpGitmodulesFile = null;
    try {
        final TreeWalk tw = TreeWalk.forPath(db, gitmodulesFile, mergeTip.getTree());
        if ((tw != null) && (tw.getFileMode(0).getObjectType() == Constants.OBJ_BLOB)) {
            tmpGitmodulesFile = File.createTempFile(gitmodulesFile, ".tmp");
            final byte[] blobData = db.openBlob(tw.getObjectId(0)).getCachedBytes();
            FileOutputStream fos = new FileOutputStream(tmpGitmodulesFile.getCanonicalPath());
            fos.write(blobData);
            fos.close();
            final FileBasedConfig cfg = new FileBasedConfig(tmpGitmodulesFile);
            final String thisServer = getSrvName(urlProvider.get());
            if (thisServer == null) {
                throw new DataFormatException("At parse of " + gitmodulesFile + ": problem retrieving name of this server.");
            }
            txn = schema.beginTransaction();
            schema.subscriptions().delete(schema.subscriptions().getSubscription(destBranch), txn);
            cfg.load();
            for (String id : cfg.getSubsections("submodule")) {
                final String url = cfg.getString("submodule", id, "url");
                final String path = cfg.getString("submodule", id, "path");
                String revision = cfg.getString("submodule", id, "revision");
                if (url != null && url.length() > 0 && path != null && path.length() > 0 && revision != null && revision.length() > 0) {
                    boolean pathIsRelative = url.startsWith("/");
                    String server = null;
                    if (!pathIsRelative)
                        server = getSrvName(url);
                    if ((pathIsRelative) || (server != null && server.equalsIgnoreCase(thisServer))) {
                        if (revision.equals(".")) {
                            revision = destBranch.get();
                        }
                        schema.subscriptions().insert(Collections.singleton(new Subscription(new Subscription.Id(schema.nextSubscriptionId()), new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get()), new Branch.NameKey(new Project.NameKey(path), revision))), txn);
                    }
                }
            }
            txn.commit();
        }
    } catch (OrmException e) {
        log.error("Database problem at update of subscriptions table from " + gitmodulesFile + " file.", e);
    } catch (ConfigInvalidException e) {
        log.error("Problem at update of subscriptions table: " + gitmodulesFile + " config file is invalid.", e);
    } catch (IOException e) {
        log.error("Problem at update of subscriptions table from " + gitmodulesFile + ".", e);
    } catch (DataFormatException e) {
        log.error(e.getMessage(), e);
    } finally {
        if (txn != null) {
            try {
                txn.rollback();
            } catch (OrmException e) {
            }
        }
        if (tmpGitmodulesFile != null) {
            tmpGitmodulesFile.delete();
        }
    }
}
#method_after
private void updateSubscriptions() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        SubmoduleOp subOp = subOpFactory.create(destBranch, mergeTip, rw, db, destProject, submitted, commits);
        try {
            subOp.update();
        } catch (SubmoduleException e) {
            log.error("The gitLinks were not updated according to the subscriptions " + e.getMessage());
        }
    }
}
#end_block

#method_before
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, c.currentPatchSetId());
    m.setMessage(body);
    return m;
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(schema, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()), schema);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canUploadToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#method_after
@Override
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#end_block

#method_before
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isHead(c) || isTag(c)) {
                // We only schedule heads and tags for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.find(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#method_after
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.findByNameOrEmail(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    final RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    final RevObject oldObject, newObject;
    try {
        oldObject = rp.getRevWalk().parseAny(cmd.getOldId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getOldId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    try {
        newObject = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (oldObject instanceof RevCommit && newObject instanceof RevCommit && ctl.canForceUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    if (rp.getAdvertisedRefs().containsKey(destBranchName)) {
        // We advertised the branch to the client so we know
        // the branch exists. Target this branch for the upload.
        // 
        destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
    } else {
        // We didn't advertise the branch, because it doesn't exist yet.
        // Allow it anyway if HEAD is a symbolic reference to the name.
        // 
        final String head;
        try {
            head = repo.getFullBranch();
        } catch (IOException e) {
            log.error("Cannot read HEAD symref", e);
            reject(cmd, "internal error");
            return;
        }
        if (head.equals(destBranchName)) {
            destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
        }
    }
    if (destBranch == null) {
        String n = destBranchName;
        if (n.startsWith(Constants.R_HEADS))
            n = n.substring(Constants.R_HEADS.length());
        reject(cmd, "branch " + n + " not found");
        return;
    }
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private void requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // Schedule as a replacement to this one matching change.
                    // 
                    requestReplace(newChange, changes.get(0), c);
                    continue;
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                if (messageEq && parentsEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    rp.sendMessage(// 
                    "(W) " + c.abbreviate(repo, 6).name() + ":" + // 
                    " no files changed, but" + // 
                    (!messageEq ? " message updated" : "") + // 
                    (!messageEq && !parentsEq ? " and" : "") + // 
                    (!parentsEq ? " was rebased" : ""));
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    if (65 < c.getShortMessage().length()) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            } else {
                log.warn("Replacement of Change-Id " + req.ontoChange + " with commit " + req.newCommit.name() + " did not import the new patch set.");
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private Map<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (final Ref r : repo.getAllRefs().values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private Map<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db);
    }
}
#method_after
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db, toTargetVersion);
    }
}
#end_block

#method_before
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        final List<String> pruneList = new ArrayList<String>();
        s.pruneSchema(new StatementExecutor() {

            public void execute(String sql) {
                pruneList.add(sql);
            }
        });
        if (!pruneList.isEmpty()) {
            ui.pruneSchema(e, pruneList);
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#method_after
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db, false);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        if (toTargetVersion) {
            final List<String> pruneList = new ArrayList<String>();
            s.pruneSchema(new StatementExecutor() {

                public void execute(String sql) {
                    pruneList.add(sql);
                }
            });
            if (!pruneList.isEmpty()) {
                ui.pruneSchema(e, pruneList);
            }
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateProjectImpl.Factory.class);
    bind(RetrieveParentCandidates.class).to(RetrieveParentCandidatesImpl.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(VisibleProjectDetails.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#end_block

#method_before
@Override
public ProjectList call() {
    final ProjectList result = new ProjectList();
    result.setProjects(getProjects());
    result.setCanCreateProject(user.getCapabilities().canCreateProject());
    return result;
}
#method_after
@Override
public ProjectList call() {
    ProjectList result = new ProjectList();
    result.setProjects(getProjects());
    result.setCanCreateProject(user.getCapabilities().canCreateProject());
    return result;
}
#end_block

#method_before
private List<Project> getProjects() {
    final List<Project> projects = new ArrayList<Project>();
    for (Project.NameKey p : projectCache.all()) {
        try {
            ProjectControl c = projectControlFactory.controlFor(p);
            if (c.isVisible() || c.isOwner()) {
                projects.add(c.getProject());
            }
        } catch (NoSuchProjectException e) {
            continue;
        }
    }
    Collections.sort(projects, new Comparator<Project>() {

        public int compare(final Project a, final Project b) {
            return a.getName().compareTo(b.getName());
        }
    });
    return projects;
}
#method_after
private List<Project> getProjects() {
    List<Project> result = new ArrayList<Project>();
    for (Project.NameKey p : projectCache.all()) {
        try {
            ProjectControl c = projectControlFactory.controlFor(p);
            if (c.isVisible() || c.isOwner()) {
                result.add(c.getProject());
            }
        } catch (NoSuchProjectException e) {
            continue;
        }
    }
    Collections.sort(result, new Comparator<Project>() {

        public int compare(final Project a, final Project b) {
            return a.getName().compareTo(b.getName());
        }
    });
    return result;
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchProjectException, ProjectCreationFailedException {
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(projectName);
    if (!parentName.equals("")) {
        final Project.NameKey nameKey = new Project.NameKey(parentName);
        args.setNewParent(projectControlFactory.validateFor(nameKey));
    }
    args.setProjectDescription("");
    args.setSubmitType(SubmitType.MERGE_IF_NECESSARY);
    args.setBranch(Constants.MASTER);
    args.setCreateEmptyCommit(emptyCommit);
    args.setPermissionsOnly(permissionsOnly);
    final CreateProject createProject = createProjectFactory.create(args);
    createProject.createProject();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws ProjectCreationFailedException {
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(projectName);
    if (!parentName.equals("")) {
        final Project.NameKey nameKey = new Project.NameKey(parentName);
        try {
            args.newParent = projectControlFactory.validateFor(nameKey);
        } catch (NoSuchProjectException e) {
            throw new ProjectCreationFailedException("Parent project \"" + parentName + "\" does not exist.", e);
        }
    }
    args.projectDescription = "";
    args.submitType = SubmitType.MERGE_IF_NECESSARY;
    args.branch = Constants.MASTER;
    args.createEmptyCommit = emptyCommit;
    args.permissionsOnly = permissionsOnly;
    final CreateProject createProject = createProjectFactory.create(args);
    createProject.createProject();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a (magic branch)/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    result = checkMagicBranchRef(NEW_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_DRAFT_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_PUBLISH_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!isMagicBranch(c)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (isMagicBranch(cmd)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = getDestBranchName(cmd);
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        change.setStatus(Change.Status.NEW);
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (isMagicBranch(cmd) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (!ps.isDraft() || control.isDraftVisible(db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
private void loadMessages() throws OrmException {
    ResultSet<ChangeMessage> source = db.changeMessages().byChange(changeId);
    List<ChangeMessage> msgList = new ArrayList<ChangeMessage>();
    for (ChangeMessage msg : source) {
        PatchSet.Id id = msg.getPatchSetId();
        if (id != null) {
            PatchSet ps = patchsetsById.get(msg.getPatchSetId());
            if (!ps.isDraft() || control.isDraftVisible(db)) {
                msgList.add(msg);
            }
        } else {
            // Not guaranteed to have a non-null patchset id, so just display it.
            msgList.add(msg);
        }
    }
    detail.setMessages(msgList);
    for (final ChangeMessage m : detail.getMessages()) {
        aic.want(m.getAuthor());
    }
}
#method_after
private void loadMessages() throws OrmException {
    ResultSet<ChangeMessage> source = db.changeMessages().byChange(changeId);
    List<ChangeMessage> msgList = new ArrayList<ChangeMessage>();
    for (ChangeMessage msg : source) {
        PatchSet.Id id = msg.getPatchSetId();
        if (id != null) {
            PatchSet ps = patchsetsById.get(msg.getPatchSetId());
            if (control.isPatchVisible(ps, db)) {
                msgList.add(msg);
            }
        } else {
            // Not guaranteed to have a non-null patchset id, so just display it.
            msgList.add(msg);
        }
    }
    detail.setMessages(msgList);
    for (final ChangeMessage m : detail.getMessages()) {
        aic.want(m.getAuthor());
    }
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException {
    return validate(controlFor(id));
}
#method_after
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException, OrmException {
    return validate(controlFor(id), db.get());
}
#end_block

#method_before
public ChangeControl validateFor(final Change change) throws NoSuchChangeException {
    return validate(controlFor(change));
}
#method_after
public ChangeControl validateFor(final Change change) throws NoSuchChangeException, OrmException {
    return validate(controlFor(change), db.get());
}
#end_block

#method_before
private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException {
    if (!c.isVisible()) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
private static ChangeControl validate(final ChangeControl c, final ReviewDb db) throws NoSuchChangeException, OrmException {
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isVisible();
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public boolean isDraftVisible(ReviewDb db) throws OrmException {
    return isOwner() || isReviewer(db);
}
#method_after
private boolean isDraftVisible(ReviewDb db) throws OrmException {
    return isOwner() || isReviewer(db);
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            r.append(GWT.getHostPageBaseURL());
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        final StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null && changeDetail.isAllowsAnonymous()) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            String base = GWT.getHostPageBaseURL();
            int p = base.indexOf("://");
            int s = base.indexOf('/', p + 3);
            if (s < 0) {
                s = base.length();
            }
            String host = base.substring(p + 3, s);
            if (host.contains("@")) {
                host = host.substring(host.indexOf('@') + 1);
            }
            r.append(base.substring(0, p + 3));
            r.append(Gerrit.getUserAccount().getUserName());
            r.append('@');
            r.append(host);
            r.append(base.substring(s));
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            changeScreen.update(result);
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#method_after
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b, final boolean redirect) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            if (redirect) {
                Gerrit.display(PageLinks.toChange(result.getChange().getId()));
            } else {
                changeScreen.update(result);
            }
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#end_block

#method_before
public static String toLongString(final Change.Status status) {
    if (status == null) {
        return "";
    }
    switch(status) {
        case NEW:
            return C.statusLongNew();
        case SUBMITTED:
            return C.statusLongSubmitted();
        case MERGED:
            return C.statusLongMerged();
        case ABANDONED:
            return C.statusLongAbandoned();
        case DRAFT:
            return C.statusLongDraft();
        default:
            return status.name();
    }
}
#method_after
public static String toLongString(final Change.Status status) {
    if (status == null) {
        return "";
    }
    switch(status) {
        case DRAFT:
            return C.statusLongDraft();
        case NEW:
            return C.statusLongNew();
        case SUBMITTED:
            return C.statusLongSubmitted();
        case MERGED:
            return C.statusLongMerged();
        case ABANDONED:
            return C.statusLongAbandoned();
        default:
            return status.name();
    }
}
#end_block

#method_before
public static void revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static void publishDraftPatchSet(final ReviewDb db, final PatchSet.Id patchSetId) throws OrmException, NoSuchChangeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    final PatchSet updatedPatchSet = db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

        @Override
        public PatchSet update(PatchSet patchset) {
            if (patchset.isDraft()) {
                patchset.setDraft(false);
            }
            return null;
        }
    });
    final Change change = db.changes().get(changeId);
    if (change.getStatus() == Change.Status.DRAFT) {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
    }
}
#method_after
public static void publishDraftPatchSet(final ReviewDb db, final PatchSet.Id patchSetId) throws OrmException, NoSuchChangeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

        @Override
        public PatchSet update(PatchSet patchset) {
            if (patchset.isDraft()) {
                patchset.setDraft(false);
            }
            return null;
        }
    });
    final Change change = db.changes().get(changeId);
    if (change.getStatus() == Change.Status.DRAFT) {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
    }
}
#end_block

#method_before
public static void deleteDraftChange(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final ReviewDb db) throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change change = db.changes().get(changeId);
    if (change == null || change.getStatus() != Change.Status.DRAFT) {
        throw new NoSuchChangeException(changeId);
    }
    for (PatchSet ps : db.patchSets().byChange(changeId)) {
        // These should all be draft patch sets.
        deleteOnlyDraftPatchSet(ps.getId(), gitManager, replication, db);
    }
    db.changeMessages().delete(db.changeMessages().byChange(changeId));
    db.starredChanges().delete(db.starredChanges().byChange(changeId));
    db.trackingIds().delete(db.trackingIds().byChange(changeId));
    db.changes().delete(Collections.singleton(change));
}
#method_after
public static void deleteDraftChange(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final ReviewDb db) throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final Change change = db.changes().get(changeId);
    if (change == null || change.getStatus() != Change.Status.DRAFT) {
        throw new NoSuchChangeException(changeId);
    }
    for (PatchSet ps : db.patchSets().byChange(changeId)) {
        // These should all be draft patch sets.
        deleteOnlyDraftPatchSet(ps, change, gitManager, replication, db);
    }
    db.changeMessages().delete(db.changeMessages().byChange(changeId));
    db.starredChanges().delete(db.starredChanges().byChange(changeId));
    db.trackingIds().delete(db.trackingIds().byChange(changeId));
    db.changes().delete(Collections.singleton(change));
}
#end_block

#method_before
public static void deleteDraftPatchSet(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final PatchSetInfoFactory patchSetInfoFactory, final ReviewDb db) throws NoSuchChangeException, OrmException, PatchSetInfoNotAvailableException, IOException {
    deleteOnlyDraftPatchSet(patchSetId, gitManager, replication, db);
    final Change.Id changeId = patchSetId.getParentKey();
    final Change change = db.changes().get(changeId);
    List<PatchSet> restOfPatches = db.patchSets().byChange(changeId).toList();
    if (restOfPatches.size() == 0) {
        deleteDraftChange(patchSetId, gitManager, replication, db);
    } else {
        PatchSet.Id highestId = null;
        for (PatchSet ps : restOfPatches) {
            if (highestId == null || ps.getPatchSetId() > highestId.get()) {
                highestId = ps.getId();
            }
        }
        if (change.currentPatchSetId().equals(patchSetId)) {
            change.lastPatchSetId();
            change.setCurrentPatchSet(patchSetInfoFactory.get(change.currPatchSetId()));
            db.changes().update(Collections.singleton(change));
        }
    }
}
#method_after
public static void deleteDraftPatchSet(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final PatchSetInfoFactory patchSetInfoFactory, final ReviewDb db) throws NoSuchChangeException, OrmException, PatchSetInfoNotAvailableException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final Change change = db.changes().get(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    deleteOnlyDraftPatchSet(patch, change, gitManager, replication, db);
    List<PatchSet> restOfPatches = db.patchSets().byChange(changeId).toList();
    if (restOfPatches.size() == 0) {
        deleteDraftChange(patchSetId, gitManager, replication, db);
    } else {
        PatchSet.Id highestId = null;
        for (PatchSet ps : restOfPatches) {
            if (highestId == null || ps.getPatchSetId() > highestId.get()) {
                highestId = ps.getId();
            }
        }
        if (change.currentPatchSetId().equals(patchSetId)) {
            change.removeLastPatchSetId();
            change.setCurrentPatchSet(patchSetInfoFactory.get(db, change.currPatchSetId()));
            db.changes().update(Collections.singleton(change));
        }
    }
}
#end_block

#method_before
private static void deleteOnlyDraftPatchSet(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final ReplicationQueue replication, final ReviewDb db) throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RefUpdate update = repo.updateRef(patch.getRefName());
        update.setForceUpdate(true);
        Result result = update.delete();
        if (result != Result.NEW && result != Result.FAST_FORWARD && result != Result.FORCED && result != Result.NO_CHANGE) {
            throw new IOException("Failed to delete ref " + patch.getRefName() + " in " + repo.getDirectory() + ": " + update.getResult());
        }
        replication.scheduleUpdate(change.getProject(), update.getName());
    } finally {
        repo.close();
    }
    db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(patchSetId));
    db.changeMessages().delete(db.changeMessages().byPatchSet(patchSetId));
    db.patchComments().delete(db.patchComments().byPatchSet(patchSetId));
    db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(patchSetId));
    db.patchSetAncestors().delete(db.patchSetAncestors().byPatchSet(patchSetId));
    db.patchSets().delete(Collections.singleton(patch));
}
#method_after
private static void deleteOnlyDraftPatchSet(final PatchSet patch, final Change change, GitRepositoryManager gitManager, final ReplicationQueue replication, final ReviewDb db) throws NoSuchChangeException, OrmException, IOException {
    final PatchSet.Id patchSetId = patch.getId();
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(patchSetId.getParentKey());
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RefUpdate update = repo.updateRef(patch.getRefName());
        update.setForceUpdate(true);
        update.disableRefLog();
        switch(update.delete()) {
            case NEW:
            case FAST_FORWARD:
            case FORCED:
            case NO_CHANGE:
                // Successful deletion.
                break;
            default:
                throw new IOException("Failed to delete ref " + patch.getRefName() + " in " + repo.getDirectory() + ": " + update.getResult());
        }
        replication.scheduleUpdate(change.getProject(), update.getName());
    } finally {
        repo.close();
    }
    db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(patchSetId));
    db.changeMessages().delete(db.changeMessages().byPatchSet(patchSetId));
    db.patchComments().delete(db.patchComments().byPatchSet(patchSetId));
    db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(patchSetId));
    db.patchSetAncestors().delete(db.patchSetAncestors().byPatchSet(patchSetId));
    db.patchSets().delete(Collections.singleton(patch));
}
#end_block

#method_before
private static void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#method_after
private static <T extends ReplyToChangeSender> void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory<T> senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.isOwner() || !control.isVisible(db)) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.deleteDraftChange(patchSetId, gitManager, replication, db);
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchChangeException, OrmException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.isOwner()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.deleteDraftChange(patchSetId, gitManager, replication, db);
    return VoidResult.INSTANCE;
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner() && control.isVisible(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
            if (detail.getPatchSet().isDraft()) {
                populatePublishAction();
            }
            if (canDeletePatchSet(detail)) {
                populateDeleteDraftPatchSetAction();
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                populatePublishAction();
            }
            if (canDeletePatchSet(detail)) {
                populateDeleteDraftPatchSetAction();
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            r.append(GWT.getHostPageBaseURL());
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        final StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null && changeDetail.isAllowsAnonymous()) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            String base = GWT.getHostPageBaseURL();
            int p = base.indexOf("://");
            int s = base.indexOf('/', p + 3);
            if (s < 0) {
                s = base.length();
            }
            String host = base.substring(p + 3, s);
            if (host.contains("@")) {
                host = host.substring(host.indexOf('@') + 1);
            }
            r.append(base.substring(0, p + 3));
            r.append(Gerrit.getUserAccount().getUserName());
            r.append('@');
            r.append(host);
            r.append(base.substring(s));
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            changeScreen.update(result);
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#method_after
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b, final boolean redirect) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            if (redirect) {
                Gerrit.display(PageLinks.toChange(result.getChange().getId()));
            } else {
                changeScreen.update(result);
            }
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#end_block

#method_before
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            try {
                final ChangeControl cc = changeControlFactory.validateFor(psid.getParentKey());
                if (!cc.isOwner() || !cc.isVisible(db)) {
                    throw new Failure(new NoSuchEntityException());
                }
                ChangeUtil.deleteDraftPatchSet(psid, gitManager, replication, patchSetInfoFactory, db);
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(psid.getParentKey()));
            } catch (PatchSetInfoNotAvailableException e) {
                throw new Failure(e);
            } catch (IOException e) {
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            try {
                final ChangeControl cc = changeControlFactory.validateFor(psid.getParentKey());
                if (!cc.isOwner()) {
                    throw new Failure(new NoSuchEntityException());
                }
                ChangeUtil.deleteDraftPatchSet(psid, gitManager, replication, patchSetInfoFactory, db);
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(psid.getParentKey()));
            } catch (PatchSetInfoNotAvailableException e) {
                throw new Failure(e);
            } catch (IOException e) {
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void publishComments(final PatchSet.Id psid, final String msg, final Set<ApprovalCategoryValue.Id> tags, final AsyncCallback<VoidResult> cb) {
    Handler.wrap(publishCommentsFactory.create(psid, msg, tags)).to(cb);
}
#method_after
public void publishComments(final PatchSet.Id psid, final String msg, final Set<ApprovalCategoryValue.Id> tags, final AsyncCallback<VoidResult> cb) {
    Handler.wrap(publishCommentsFactory.create(psid, msg, tags, false)).to(cb);
}
#end_block

#method_before
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            AccountPatchReview apr = db.accountPatchReviews().get(key);
            if (apr == null && reviewed) {
                db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
            } else if (apr != null && !reviewed) {
                db.accountPatchReviews().delete(Collections.singleton(apr));
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            db.accounts().beginTransaction(account);
            try {
                AccountPatchReview apr = db.accountPatchReviews().get(key);
                if (apr == null && reviewed) {
                    db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
                } else if (apr != null && !reviewed) {
                    db.accountPatchReviews().delete(Collections.singleton(apr));
                }
                db.commit();
                return VoidResult.INSTANCE;
            } finally {
                db.rollback();
            }
        }
    });
}
#end_block

#method_before
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a (magic branch)/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    result = checkMagicBranchRef(NEW_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_DRAFT_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_PUBLISH_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!isMagicBranch(c)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (isMagicBranch(cmd)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = getDestBranchName(cmd);
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    if (isDraft(newChange)) {
        change.setStatus(Change.Status.DRAFT);
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    if (isDraft(request.cmd)) {
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    msg.setPatchSetId(ps.getId());
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        change.setStatus(Change.Status.DRAFT);
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (isMagicBranch(cmd) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    msg.setPatchSetId(result.info.getKey());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException {
    return validate(controlFor(id));
}
#method_after
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException, OrmException {
    return validate(controlFor(id), db.get());
}
#end_block

#method_before
public ChangeControl validateFor(final Change change) throws NoSuchChangeException {
    return validate(controlFor(change));
}
#method_after
public ChangeControl validateFor(final Change change) throws NoSuchChangeException, OrmException {
    return validate(controlFor(change), db.get());
}
#end_block

#method_before
private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException {
    if (!c.isVisible()) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
private static ChangeControl validate(final ChangeControl c, final ReviewDb db) throws NoSuchChangeException, OrmException {
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isOwner() && !isReviewer(db)) {
        return false;
    }
    return isVisible();
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    if (change.getStatus() == Change.Status.DRAFT) {
        return ruleError("Cannot submit draft changes");
    }
    try {
        if (isDraftPatchSet(patchSetId, db)) {
            return ruleError("Cannot submit draft patch sets");
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (isDraftPatchSet(patchSetId, db)) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        return false;
    }
    return ps.isDraft();
}
#method_after
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        throw new OrmException("Patch set " + id + " not found");
    }
    return ps.isDraft();
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
        reject(cmd, "For non-fast forward updates, 'Force Push' privilege is needed");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            saveType.setVisible(result.canModify);
            delInclude.setVisible(result.canModify);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initIncludeList();
    initExternal();
}
#end_block

#method_before
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#method_after
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewMember();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#end_block

#method_before
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#method_after
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#end_block

#method_before
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#method_after
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includePanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includes.display(result.includes);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (value.isLabel()) {
                newRule.setRange(0, 1);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#method_after
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (rangeType != null) {
                int min = rangeType.getMin().getValue();
                int max = rangeType.getMax().getValue();
                newRule.setRange(min, max);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#end_block

#method_before
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value != null && Permission.OWNER.equals(value.getName())) {
        inherit.setEnabled(false);
    } else {
        inherit.setEnabled(!readOnly);
    }
}
#method_after
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value.isLabel()) {
        rangeType = Gerrit.getConfig().getApprovalTypes().byLabel(value.getLabel());
    } else {
        rangeType = null;
    }
    if (value != null && Permission.OWNER.equals(value.getName())) {
        exclusiveGroup.setEnabled(false);
    } else {
        exclusiveGroup.setEnabled(!readOnly);
    }
}
#end_block

#method_before
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#method_after
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value, rangeType);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#end_block

#method_before
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    local.getEditors().get(index).editRefPattern();
}
#method_after
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    AccessSectionEditor editor = local.getEditors().get(index);
    editor.enableEditing();
    editor.editRefPattern();
}
#end_block

#method_before
@Override
public void render(Action object, Appendable appendable) throws IOException {
    appendable.append(render(object));
}
#method_after
@Override
public String render(PermissionRule.Action object) {
    return object != null ? object.toString() : "";
}
#end_block

#method_before
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#method_after
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    if (suggestAccounts == SuggestAccountsEnum.OFF) {
        callback.onSuccess(Collections.<AccountInfo>emptyList());
        return;
    }
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#end_block

#method_before
private void addSuggestion(Map map, Account account, AccountInfo info, Boolean active) {
    if (active == null || active == account.isActive()) {
        map.put(account.getId(), info);
    }
}
#method_after
private void addSuggestion(Map<Account.Id, AccountInfo> map, Account account, AccountInfo info, Boolean active) {
    if (map.containsKey(account.getId())) {
        return;
    }
    if (active != null && active != account.isActive()) {
        return;
    }
    switch(suggestAccounts) {
        case ALL:
            map.put(account.getId(), info);
            break;
        case SAME_GROUP:
            {
                Set<AccountGroup.UUID> usersGroups = groupsOf(account);
                usersGroups.remove(AccountGroup.ANONYMOUS_USERS);
                usersGroups.remove(AccountGroup.REGISTERED_USERS);
                usersGroups.remove(authConfig.getBatchUsersGroup());
                for (AccountGroup.UUID myGroup : currentUser.get().getEffectiveGroups()) {
                    if (usersGroups.contains(myGroup)) {
                        map.put(account.getId(), info);
                        break;
                    }
                }
                break;
            }
        case OFF:
            break;
        default:
            throw new IllegalStateException("Bad SuggestAccounts " + suggestAccounts);
    }
}
#end_block

#method_before
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName c : db.accountGroupNames().suggestByName(a, b, n)) {
                AccountGroup g = groupCache.get(c.getId());
                if (g != null && g.getGroupUUID() != null) {
                    r.add(GroupReference.forGroup(g));
                }
            }
            return r;
        }
    });
}
#method_after
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            Set<AccountGroup.UUID> memberOf = currentUser.get().getEffectiveGroups();
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName group : db.accountGroupNames().suggestByName(a, b, n)) {
                try {
                    if (memberOf.contains(group.getId()) || groupControlFactory.controlFor(group.getId()).isVisible()) {
                        AccountGroup g = groupCache.get(group.getId());
                        if (g != null && g.getGroupUUID() != null) {
                            r.add(GroupReference.forGroup(g));
                        }
                    }
                } catch (NoSuchGroupException e) {
                    continue;
                }
            }
            return r;
        }
    });
}
#end_block

#method_before
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#method_after
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final String q = "patchset=";
        final String[] t = s.split(",", 2);
        if (t.length > 1 && t[1].startsWith(q)) {
            return new ChangeScreen(PatchSet.Id.parse(t[0] + "," + skip(q, t[1])));
        }
        return new ChangeScreen(Change.Id.parse(t[0]));
    }
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#end_block

#method_before
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAdd(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#method_after
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAddMember(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#end_block

#method_before
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemove(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemoveMember(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void setAction(Action action) {
    switch(action) {
        case ALLOW:
            setDeny(false);
            break;
        case DENY:
            setDeny(true);
            break;
        default:
            throw new IllegalArgumentException();
    }
}
#method_after
public void setAction(Action action) {
    if (action == null) {
        throw new NullPointerException("action");
    }
    setDeny(action == Action.DENY);
}
#end_block

#method_before
public int getMin() {
    return min;
}
#method_after
public Integer getMin() {
    return min;
}
#end_block

#method_before
public int getMax() {
    return max;
}
#method_after
public Integer getMax() {
    return max;
}
#end_block

#method_before
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#method_after
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = range(o) - range(this);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#end_block

#method_before
public String asString(boolean useRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (useRange) {
        if (getMin() == 0 && getMax() == 1) {
        } else if (getMin() == 1 && getMax() == 1) {
        } else if (getMin() < 0 && getMax() == 0) {
            r.append(getMin());
            r.append(' ');
        } else {
            if (getMin() != getMax()) {
                if (0 <= getMin())
                    r.append('+');
                r.append(getMin());
                r.append("..");
            }
            if (0 <= getMax())
                r.append('+');
            r.append(getMax());
            r.append(' ');
        }
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#method_after
public String asString(boolean canUseRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (canUseRange && (getMin() != 0 || getMax() != 0)) {
        if (0 <= getMin())
            r.append('+');
        r.append(getMin());
        r.append("..");
        if (0 <= getMax())
            r.append('+');
        r.append(getMax());
        r.append(' ');
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#end_block

#method_before
public static PermissionRule fromString(String src, boolean useRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (useRange) {
        if (src.startsWith("group ")) {
            rule.setRange(0, 1);
        } else {
            int sp = src.indexOf(' ');
            String range = src.substring(0, sp);
            if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
                int dotdot = range.indexOf("..");
                int min = parseInt(range.substring(0, dotdot));
                int max = parseInt(range.substring(dotdot + 2));
                rule.setRange(min, max);
            } else if (range.matches("^([+-]\\d)$")) {
                int v = parseInt(range);
                rule.setRange(v, v);
            } else {
                throw new IllegalArgumentException("Invalid range in rule: " + orig);
            }
            src = src.substring(sp + 1).trim();
        }
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#method_after
public static PermissionRule fromString(String src, boolean mightUseRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (mightUseRange && !src.startsWith("group ")) {
        int sp = src.indexOf(' ');
        String range = src.substring(0, sp);
        if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
            int dotdot = range.indexOf("..");
            int min = parseInt(range.substring(0, dotdot));
            int max = parseInt(range.substring(dotdot + 2));
            rule.setRange(min, max);
        } else {
            throw new IllegalArgumentException("Invalid range in rule: " + orig);
        }
        src = src.substring(sp + 1).trim();
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_DO_NOT_INHERIT)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setInherit(false);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (!perm.getInherit()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_DO_NOT_INHERIT, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_DO_NOT_INHERIT);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        rebuildPermissionSelector();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addDotDotDot());
        permissionSelector.setValue(Util.C.addDotDotDot());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
@Override
public void replicateNewProject(Project.NameKey projectName, String head) {
    if (!isEnabled()) {
        return;
    }
    for (ReplicationConfig config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            URIish adminURI = null;
            try {
                if (url != null && !url.isEmpty()) {
                    adminURI = new URIish(url);
                }
            } catch (URISyntaxException e) {
                log.error("The URL '" + url + "' is invalid");
            }
            if (adminURI != null) {
                final String replacedPath = replace(adminURI.getPath(), "name", projectName.get());
                if (replacedPath != null) {
                    adminURI = adminURI.setPath(replacedPath);
                    if (usingSSH(adminURI)) {
                        replicateProject(projectName, adminURI, head);
                        adminURLUsed = true;
                    } else {
                        log.error("The adminURL '" + url + "' is non-SSH which is not allowed");
                    }
                }
            }
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                replicateProject(projectName, uri, head);
            }
        }
    }
}
#method_after
@Override
public void replicateNewProject(Project.NameKey projectName, String head) {
    if (!isEnabled()) {
        return;
    }
    for (ReplicationConfig config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            URIish adminURI = null;
            try {
                if (url != null && !url.isEmpty()) {
                    adminURI = new URIish(url);
                }
            } catch (URISyntaxException e) {
                log.error("The URL '" + url + "' is invalid");
            }
            if (adminURI != null) {
                final String replacedPath = replace(adminURI.getPath(), "name", projectName.get());
                if (replacedPath != null) {
                    adminURI = adminURI.setPath(replacedPath);
                    if (usingSSH(adminURI)) {
                        replicateProject(adminURI, head);
                        adminURLUsed = true;
                    } else {
                        log.error("The adminURL '" + url + "' is non-SSH which is not allowed");
                    }
                }
            }
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                replicateProject(uri, head);
            }
        }
    }
}
#end_block

#method_before
private void replicateProject(final Project.NameKey projectName, final URIish replicateURI, final String head) {
    if (!replicateURI.isRemote()) {
        replicateProjectLocally(projectName, replicateURI, head);
    } else if (usingSSH(replicateURI)) {
        replicateProjectOverSsh(replicateURI, head);
    } else {
        log.warn("Cannot create new project on remote site since neither the " + "connection method is SSH nor the replication target is local: " + replicateURI.toString());
        return;
    }
}
#method_after
private void replicateProject(final URIish replicateURI, final String head) {
    if (!replicateURI.isRemote()) {
        replicateProjectLocally(replicateURI, head);
    } else if (usingSSH(replicateURI)) {
        replicateProjectOverSsh(replicateURI, head);
    } else {
        log.warn("Cannot create new project on remote site since neither the " + "connection method is SSH nor the replication target is local: " + replicateURI.toString());
        return;
    }
}
#end_block

#method_before
private void replicateProjectLocally(final Project.NameKey projectName, final URIish replicateURI, final String head) {
    Repository repo = null;
    try {
        repo = gitRepositoryManager.openRepository(projectName);
        FileUtils.copyDirectory(repo.getDirectory(), new File(replicateURI.getPath()));
    } catch (RepositoryNotFoundException e) {
        log.error("Failed to replicate project locally: " + replicateURI.toString());
    } catch (IOException e) {
        log.error("Failed to replicate project locally: " + replicateURI.toString());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
private void replicateProjectLocally(final URIish replicateURI, final String head) {
    try {
        final Repository repo = new FileRepository(replicateURI.getPath());
        try {
            repo.create(true);
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        log.error("Failed to replicate project locally: " + replicateURI.getPath());
    }
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    publishDrafts();
    final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
    if (isCurrent && change.getStatus().isOpen()) {
        publishApprovals(ctl);
    } else if (!approvals.isEmpty() && !alwaysPublishMessage) {
        throw new InvalidChangeOperationException("Change is closed");
    } else {
        publishMessageOnly();
    }
    touchChange();
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    db.changes().beginTransaction(changeId);
    try {
        publishDrafts();
        final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
        if (isCurrent && change.getStatus().isOpen()) {
            publishApprovals(ctl);
        } else if (approvals.isEmpty() || forceMessage) {
            publishMessageOnly();
        } else {
            throw new InvalidChangeOperationException("Change is closed");
        }
        touchChange();
        db.commit();
    } finally {
        db.rollback();
    }
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draft(patchSetId, user.getAccountId()).toList();
}
#method_after
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draftByPatchSetAuthor(patchSetId, user.getAccountId()).toList();
}
#end_block

#method_before
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#method_after
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, alwaysPublishMsg).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
}
#end_block

#method_before
public void deleteDraft(final PatchLineComment.Key commentKey, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final PatchLineComment comment = db.patchComments().get(commentKey);
            if (comment == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (!getAccountId().equals(comment.getAuthor())) {
                throw new Failure(new NoSuchEntityException());
            }
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            db.patchComments().delete(Collections.singleton(comment));
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteDraft(final PatchLineComment.Key commentKey, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            Change.Id id = commentKey.getParentKey().getParentKey().getParentKey();
            db.changes().beginTransaction(id);
            try {
                final PatchLineComment comment = db.patchComments().get(commentKey);
                if (comment == null) {
                    throw new Failure(new NoSuchEntityException());
                }
                if (!getAccountId().equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                    throw new Failure(new IllegalStateException("Comment published"));
                }
                db.patchComments().delete(Collections.singleton(comment));
                db.commit();
                return VoidResult.INSTANCE;
            } finally {
                db.rollback();
            }
        }
    });
}
#end_block

#method_before
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            AccountPatchReview apr = db.accountPatchReviews().get(key);
            if (apr == null && reviewed) {
                db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
            } else if (apr != null && !reviewed) {
                db.accountPatchReviews().delete(Collections.singleton(apr));
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            db.accounts().beginTransaction(account);
            try {
                AccountPatchReview apr = db.accountPatchReviews().get(key);
                if (apr == null && reviewed) {
                    db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
                } else if (apr != null && !reviewed) {
                    db.accountPatchReviews().delete(Collections.singleton(apr));
                }
                db.commit();
                return VoidResult.INSTANCE;
            } finally {
                db.rollback();
            }
        }
    });
}
#end_block

#method_before
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encode(project.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", encode(project.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParameterizedString pattern = new ParameterizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    p.put("file", URL.encodeQueryString(file));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParameterizedString pattern = new ParameterizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", encode(branch.getParentKey().get()));
    p.put("branch", encode(branch.get()));
    p.put("file", encode(file));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
String encode(String segment) {
    return URL.encodeQueryString(type.replacePathSeparator(segment));
}
#method_after
private String encode(String segment) {
    return URL.encodeQueryString(type.replacePathSeparator(segment));
}
#end_block

#method_before
public String replacePathSeparator(String newSeparator) {
    if ('/' != pathSeparator) {
        return newSeparator.replace('/', pathSeparator);
    }
    return newSeparator;
}
#method_after
public String replacePathSeparator(String urlSegment) {
    if ('/' != pathSeparator) {
        return urlSegment.replace('/', pathSeparator);
    }
    return urlSegment;
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
public String commitMessage(GitRepositoryManager repoManager, Provider<ReviewDb> db) {
    if (commitMessage == null) {
        try {
            PatchSet.Id psId = change.currentPatchSetId();
            String sha1 = db.get().patchSets().get(psId).getRevision().get();
            Project.NameKey name = change.getProject();
            Repository repo = repoManager.openRepository(name);
            RevWalk walk = new RevWalk(repo);
            RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
            commitMessage = c.getFullMessage();
            walk.release();
        } catch (RepositoryNotFoundException e) {
        } catch (IOException e) {
        } catch (OrmException e) {
        }
    }
    return commitMessage;
}
#method_after
public String commitMessage(GitRepositoryManager repoManager, Provider<ReviewDb> db) throws IOException, OrmException {
    if (commitMessage == null) {
        PatchSet.Id psId = change(db).currentPatchSetId();
        String sha1 = db.get().patchSets().get(psId).getRevision().get();
        Project.NameKey name = change.getProject();
        Repository repo = repoManager.openRepository(name);
        try {
            RevWalk walk = new RevWalk(repo);
            try {
                RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
                commitMessage = c.getFullMessage();
            } finally {
                walk.release();
            }
        } finally {
            repo.close();
        }
    }
    return commitMessage;
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute a, Collection<PatchSet> ps) {
    addPatchSets(a, ps, null);
}
#method_after
public void addPatchSets(ChangeAttribute a, Collection<PatchSet> ps) {
    addPatchSets(a, ps, null, false, null);
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
        }
    }
}
#method_after
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    addPatchSets(ca, ps, approvals, false, null);
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
        }
    }
}
#method_after
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals, boolean includeFiles, Change change) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
            if (includeFiles && change != null) {
                addPatchSetFileNames(psa, change, p);
            }
        }
    }
}
#end_block

#method_before
public boolean isVisible() {
    if (isOwner()) {
        return true;
    } else {
        return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && !isHidden();
    }
}
#method_after
public boolean isVisible() {
    return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && canRead();
}
#end_block

#method_before
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && isActive();
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && isActive();
}
#method_after
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && canWrite();
}
#end_block

#method_before
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && isActive();
}
#method_after
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && canWrite();
}
#end_block

#method_before
private boolean canPushWithForce() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#method_after
private boolean canPushWithForce() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!isActive()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().isOwner() || control.getRefControl().isActive());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public boolean isVisible() {
    return visibleForReplication() || canPerformOnAnyRef(Permission.READ) && !isHidden();
}
#method_after
public boolean isVisible() {
    return (visibleForReplication() || canPerformOnAnyRef(Permission.READ)) && !isHidden();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, STATE, null, KEY_VALUE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, STATE, null, KEY_VALUE, p.getState(), defaultStateValue);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (isEditable()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            r.append(GWT.getHostPageBaseURL());
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        final StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null && changeDetail.isAllowsAnonymous()) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            String base = GWT.getHostPageBaseURL();
            int p = base.indexOf("://");
            int s = base.indexOf('/', p + 3);
            if (s < 0) {
                s = base.length();
            }
            String host = base.substring(p + 3, s);
            if (host.contains("@")) {
                host = host.substring(host.indexOf('@') + 1);
            }
            r.append(base.substring(0, p + 3));
            r.append(Gerrit.getUserAccount().getUserName());
            r.append('@');
            r.append(host);
            r.append(base.substring(s));
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            changeScreen.update(result);
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#method_after
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b, final boolean redirect) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            if (redirect) {
                Gerrit.display(PageLinks.toChange(result.getChange().getId()));
            } else {
                changeScreen.update(result);
            }
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#end_block

#method_before
public void setParentName(String n) {
    parent = n != null ? new NameKey(n) : null;
}
#method_after
public void setParentName(NameKey n) {
    parent = n;
}
#end_block

#method_before
private void setState(final Project.State newState) {
    int index = -1;
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                index = i;
                break;
            }
        }
        state.setSelectedIndex(index);
    }
}
#method_after
private void setState(final Project.State newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#end_block

#method_before
public void setCanModifyState(final boolean cmmt) {
    canModifyState = cmmt;
}
#method_after
public void setCanModifyState(final boolean cms) {
    canModifyState = cms;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            parseCommandLine();
            updateParents();
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                updateParents();
            } finally {
                stdout.flush();
            }
        }
    });
}
#end_block

#method_before
private void updateParents() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: child projects have to be specified as arguments or the --old-parent option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --exclude can only be used together with --old-parent");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<Project.NameKey>();
    Project.NameKey newParentKey;
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    } else {
        // If no parent was selected, set to NULL to use the default.
        // 
        newParentKey = null;
    }
    final List<Project> childProjects = new ArrayList<Project>();
    for (final ProjectControl pc : children) {
        childProjects.add(pc.getProject());
    }
    if (oldParent != null) {
        final List<Project.NameKey> excluded = new ArrayList<Project.NameKey>(excludedChildren.size() + 1);
        if (newParentKey != null) {
            excluded.add(newParentKey);
        }
        for (final ProjectControl excludedChild : excludedChildren) {
            excluded.add(excludedChild.getProject().getNameKey());
        }
        final ProjectNode oldParentProject = createProjectHierarchyFactory.create().getProjectHierarchy(oldParent.getProject().getNameKey());
        for (final ProjectNode childProject : oldParentProject.getChildren()) {
            if (!excluded.contains(childProject.getProject().getNameKey())) {
                childProjects.add(childProject.getProject());
            }
        }
    }
    for (final Project project : childProjects) {
        final String name = project.getName();
        final Project.NameKey nameKey = project.getNameKey();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '" + name + "'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '" + name + "' and '" + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "'\n");
            continue;
        }
        try {
            MetaDataUpdate md = metaDataUpdateFactory.create(nameKey);
            try {
                ProjectConfig config = ProjectConfig.read(md);
                config.getProject().setParentName(newParentKey);
                md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
                if (!config.commit(md)) {
                    err.append("error: Could not update project " + name + "\n");
                }
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project " + name + " not found\n");
        } catch (IOException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        } catch (ConfigInvalidException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        }
        projectCache.evict(project);
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw new UnloggedFailure(1, err.toString());
    }
}
#method_after
private void updateParents() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: child projects have to be specified as " + "arguments or the --children-of option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --exclude can only be used together " + "with --children-of");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<Project.NameKey>();
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    }
    final List<Project> childProjects = new ArrayList<Project>();
    for (final ProjectControl pc : children) {
        childProjects.add(pc.getProject());
    }
    if (oldParent != null) {
        childProjects.addAll(getChildrenForReparenting(oldParent));
    }
    for (final Project project : childProjects) {
        final String name = project.getName();
        final Project.NameKey nameKey = project.getNameKey();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '" + name + "'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '" + name + "' and '" + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "'\n");
            continue;
        }
        try {
            MetaDataUpdate md = metaDataUpdateFactory.create(nameKey);
            try {
                ProjectConfig config = ProjectConfig.read(md);
                config.getProject().setParentName(newParentKey);
                md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
                if (!config.commit(md)) {
                    err.append("error: Could not update project " + name + "\n");
                }
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project " + name + " not found\n");
        } catch (IOException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        } catch (ConfigInvalidException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        }
        projectCache.evict(project);
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw new UnloggedFailure(1, err.toString());
    }
}
#end_block

#method_before
private boolean suggestGroupAsReviewer(final Project.NameKey project, final GroupReference group) throws OrmException {
    if (!AddReviewer.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        final PerformGroupMembers groupMembers = groupMembersFactory.create();
        groupMembers.setProject(project);
        final Set<Account> members = groupMembers.listAccounts(group.getUUID());
        if (members.isEmpty()) {
            return false;
        }
        final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", AddReviewer.DEFAULT_MAX_REVIEWERS);
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return true;
}
#method_after
private boolean suggestGroupAsReviewer(final Project.NameKey project, final GroupReference group) throws OrmException {
    if (!AddReviewer.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        final Set<Account> members = groupMembersFactory.create().listAccounts(group.getUUID(), project);
        if (members.isEmpty()) {
            return false;
        }
        final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", AddReviewer.DEFAULT_MAX_REVIEWERS);
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final PerformGroupMembers groupMembers = groupMembersFactory.create();
            groupMembers.setProject(control.getProject().getNameKey());
            final Set<Account> members = groupMembers.listAccounts(group.getGroupUUID());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    if (control.forUser(user).isVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        if (!control.forUser(user).isVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final PatchSet.Id psid = control.getChange().currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#method_after
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final Set<Account> members = groupMembersFactory.create().listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    if (control.forUser(user).isVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        if (!control.forUser(user).isVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final PatchSet.Id psid = control.getChange().currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(PerformGroupMembers.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformVisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembersFactory.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembersFactory.Factory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(FlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "ls-groups").to(ListGroups.class);
    command(gerrit, "query").to(Query.class);
    command(gerrit, "show-caches").to(ShowCaches.class);
    command(gerrit, "show-connections").to(ShowConnections.class);
    command(gerrit, "show-queue").to(ShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(gerrit, "version").to(VersionCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(FlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "ls-groups").to(ListGroupsCommand.class);
    command(gerrit, "query").to(Query.class);
    command(gerrit, "show-caches").to(ShowCaches.class);
    command(gerrit, "show-connections").to(ShowConnections.class);
    command(gerrit, "show-queue").to(ShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(gerrit, "version").to(VersionCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#end_block

#method_before
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getInheritsFrom(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#method_after
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#end_block

#method_before
public static GitWebType fromName(final String name) {
    final GitWebType type;
    if (name == null || name.isEmpty() || name.equalsIgnoreCase("gitweb")) {
        type = new GitWebType();
        type.setProject("?p=${project}.git;a=summary");
        type.setRevision("?p=${project}.git;a=commit;h=${commit}");
        type.setBranch("?p=${project}.git;a=shortlog;h=${branch}");
        type.setFileHistory("?p=${project}.git;a=history;hb=${branch};f=${file}");
    } else if (name.equalsIgnoreCase("cgit")) {
        type = new GitWebType();
        type.setProject("${project}/summary");
        type.setRevision("${project}/commit/?id=${commit}");
        type.setBranch("${project}/log/?h=${branch}");
        type.setFileHistory("${project}/history/?hb=${branch};f=${file}");
    } else if (name.equalsIgnoreCase("custom")) {
        type = new GitWebType();
    } else {
        type = null;
    }
    return type;
}
#method_after
public static GitWebType fromName(final String name) {
    final GitWebType type;
    if (name == null || name.isEmpty() || name.equalsIgnoreCase("gitweb")) {
        type = new GitWebType();
        type.setLinkName("gitweb");
        type.setProject("?p=${project}.git;a=summary");
        type.setRevision("?p=${project}.git;a=commit;h=${commit}");
        type.setBranch("?p=${project}.git;a=shortlog;h=${branch}");
        type.setFileHistory("?p=${project}.git;a=history;hb=${branch};f=${file}");
    } else if (name.equalsIgnoreCase("cgit")) {
        type = new GitWebType();
        type.setLinkName("cgit");
        type.setProject("${project}/summary");
        type.setRevision("${project}/commit/?id=${commit}");
        type.setBranch("${project}/log/?h=${branch}");
        type.setFileHistory("${project}/log/${file}?h=${branch}");
    } else if (name.equalsIgnoreCase("custom")) {
        type = new GitWebType();
        // The custom name is not defined, let's keep the old style of using GitWeb
        type.setLinkName("gitweb");
    } else if (name.equalsIgnoreCase("disabled")) {
        type = null;
    } else {
        type = null;
    }
    return type;
}
#end_block

#method_before
public String toRevision(final Project.NameKey project, final PatchSet ps) {
    ParamertizedString pattern = new ParamertizedString(type.getRevision());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    p.put("commit", URL.encodeQueryString(ps.getRevision().get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toRevision(final Project.NameKey project, final PatchSet ps) {
    ParameterizedString pattern = new ParameterizedString(type.getRevision());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    p.put("commit", URL.encodeQueryString(ps.getRevision().get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toProject(final Project.NameKey project) {
    ParamertizedString pattern = new ParamertizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toBranch(final Branch.NameKey branch) {
    ParamertizedString pattern = new ParamertizedString(type.getBranch());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toBranch(final Branch.NameKey branch) {
    ParameterizedString pattern = new ParameterizedString(type.getBranch());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParamertizedString pattern = new ParamertizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    p.put("file", URL.encodeQueryString(file));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParameterizedString pattern = new ParameterizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    p.put("file", URL.encodeQueryString(file));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#end_block

#method_before
private void expand(ClickEvent event, final int numRows) {
    Cell cell = table.getCellForEvent(event);
    int row = cell.getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        insertRow(row + i);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        setHtml(row + i, 1, "<a href=\"javascript:void(0)\">" + (lineA + 1) + "</a>");
        setHtml(row + i, 2, a.getSafeHtmlLine(lineA).asString());
        setHtml(row + i, 3, "<a href=\"javascript:void(0)\">" + (lineB + 1) + "</a>");
        setHtml(row + i, 4, b.getSafeHtmlLine(lineB).asString());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        removeRow(row + loopTo);
    }
}
#method_after
private void expand(ClickEvent event, final int numRows) {
    Cell cell = table.getCellForEvent(event);
    int row = cell.getRowIndex();
    if (!(getRowItem(row) instanceof SkippedLine)) {
        return;
    }
    SkippedLine line = (SkippedLine) getRowItem(row);
    int loopTo = numRows;
    if (numRows == 0) {
        loopTo = line.getSize();
    } else if (numRows < 0) {
        loopTo = -numRows;
    }
    int offset = 0;
    if (numRows < 0) {
        offset = 1;
    }
    for (int i = 0 + offset; i < loopTo + offset; i++) {
        insertRow(row + i);
        int lineA = line.getStartA() + i;
        int lineB = line.getStartB() + i;
        if (numRows < 0) {
            lineA = line.getStartA() + line.getSize() + numRows + i - offset;
            lineB = line.getStartB() + line.getSize() + numRows + i - offset;
        }
        setHtml(row + i, 1, "<a href=\"javascript:void(0)\">" + (lineA + 1) + "</a>");
        addStyle(row + i, 1, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 2, a.getSafeHtmlLine(lineA).asString());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 2, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setHtml(row + i, 3, "<a href=\"javascript:void(0)\">" + (lineB + 1) + "</a>");
        addStyle(row + i, 3, Gerrit.RESOURCES.css().lineNumber());
        setHtml(row + i, 4, b.getSafeHtmlLine(lineB).asString());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLine());
        addStyle(row + i, 4, Gerrit.RESOURCES.css().fileLineCONTEXT());
        setRowItem(row + i, new PatchLine(CONTEXT, lineA, lineB));
    }
    if (numRows > 0) {
        line.incrementStart(numRows);
        createSkipLine(row + loopTo, line);
    } else if (numRows < 0) {
        line.reduceSize(-numRows);
        createSkipLine(row, line);
    } else {
        removeRow(row + loopTo);
    }
}
#end_block

#method_before
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    final TreeMap<String, TreeNode> treeMap = new TreeMap<String, TreeNode>();
    try {
        for (final Project.NameKey projectName : projectCache.all()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            final boolean isVisible = pctl.isVisible() || pctl.isOwner();
            if (showTree) {
                treeMap.put(projectName.get(), new TreeNode(pctl.getProject(), isVisible));
                continue;
            }
            if (!isVisible) {
                // 
                continue;
            }
            try {
                if (showBranch != null) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (Ref ref : refs) {
                            if (ref == null) {
                                // Print stub (forty '-' symbols)
                                stdout.print("----------------------------------------");
                            } else {
                                stdout.print(ref.getObjectId().name());
                            }
                            stdout.print(' ');
                        }
                    } finally {
                        git.close();
                    }
                } else if (type != FilterType.ALL) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                    } finally {
                        git.close();
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            stdout.print(projectName.get() + "\n");
        }
        if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#method_after
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    if (showTree && showDescription) {
        throw new UnloggedFailure(1, "fatal: --tree and --description options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    final TreeMap<String, TreeNode> treeMap = new TreeMap<String, TreeNode>();
    try {
        for (final Project.NameKey projectName : projectCache.all()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
            if (showTree) {
                treeMap.put(projectName.get(), new TreeNode(pctl.getProject(), isVisible));
                continue;
            }
            if (!isVisible) {
                // 
                continue;
            }
            try {
                if (showBranch != null) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (Ref ref : refs) {
                            if (ref == null) {
                                // Print stub (forty '-' symbols)
                                stdout.print("----------------------------------------");
                            } else {
                                stdout.print(ref.getObjectId().name());
                            }
                            stdout.print(' ');
                        }
                    } finally {
                        git.close();
                    }
                } else if (type != FilterType.ALL) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                    } finally {
                        git.close();
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            stdout.print(projectName.get());
            String desc;
            if (showDescription && !(desc = e.getProject().getDescription()).isEmpty()) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + desc.replace("\n", "\\n"));
            }
            stdout.print("\n");
        }
        if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private List<Ref> getBranchRefs(Project.NameKey projectName, ProjectControl projectControl) {
    Ref[] result = new Ref[showBranch.size()];
    try {
        Repository git = repoManager.openRepository(projectName);
        try {
            for (int i = 0; i < showBranch.size(); i++) {
                Ref ref = git.getRef(showBranch.get(i));
                if (ref != null && ref.getObjectId() != null && projectControl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                    result[i] = ref;
                }
            }
        } finally {
            git.close();
        }
    } catch (IOException ioe) {
    // Fall through and return what is available.
    }
    return Arrays.asList(result);
}
#method_after
private List<Ref> getBranchRefs(Project.NameKey projectName, ProjectControl projectControl) {
    Ref[] result = new Ref[showBranch.size()];
    try {
        Repository git = repoManager.openRepository(projectName);
        try {
            for (int i = 0; i < showBranch.size(); i++) {
                Ref ref = git.getRef(showBranch.get(i));
                if (ref != null && ref.getObjectId() != null && (projectControl.controlForRef(ref.getLeaf().getName()).isVisible()) || (all && projectControl.isOwner())) {
                    result[i] = ref;
                }
            }
        } finally {
            git.close();
        }
    } catch (IOException ioe) {
    // Fall through and return what is available.
    }
    return Arrays.asList(result);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/query").with(ChangeQueryServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    filter("/p/*").through(ProjectAccessPathFilter.class);
    if (authConfig.isTrustContainerAuth())
        filter("/p/*").through(ContainerAuthFilter.class);
    else
        filter("/p/*").through(ProjectDigestFilter.class);
    serve("/p/*").with(ProjectServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/query").with(ChangeQueryServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    filter("/p/*").through(ProjectAccessPathFilter.class);
    if (authConfig.isTrustContainerAuth()) {
        filter("/p/*").through(ContainerAuthFilter.class);
    } else {
        filter("/p/*").through(ProjectDigestFilter.class);
    }
    serve("/p/*").with(ProjectServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, HttpServletResponseWrapper rsp) throws IOException {
    if (!authConfig.isTrustContainerAuth())
        return true;
    final String username = req.getRemoteUser();
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    session.get().setUserAccountId(who.getAccount().getId());
    return true;
}
#method_after
private boolean verify(HttpServletRequest req, HttpServletResponseWrapper rsp) throws IOException {
    final String username = req.getRemoteUser();
    final AccountState who = (username == null) ? null : accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    session.get().setUserAccountId(who.getAccount().getId());
    return true;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    Pattern regex = (Pattern) ((JavaObjectTerm) a1).object();
    Iterator<PatchListEntry> iter = (Iterator<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (iter.hasNext()) {
        PatchListEntry patch = iter.next();
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if (!newName.equals("/COMMIT_MSG") && regex.matcher(newName).matches() || (oldName != null && regex.matcher(oldName).matches())) {
            SymbolTerm changeSym = getTypeSymbol(changeType);
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    Pattern regex = (Pattern) ((JavaObjectTerm) a1).object();
    Iterator<PatchListEntry> iter = (Iterator<PatchListEntry>) ((JavaObjectTerm) a5).object();
    while (iter.hasNext()) {
        PatchListEntry patch = iter.next();
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if (newName.equals("/COMMIT_MSG")) {
            continue;
        }
        if (regex.matcher(newName).matches() || (oldName != null && regex.matcher(oldName).matches())) {
            SymbolTerm changeSym = getTypeSymbol(changeType);
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(changeSym, engine.trail)) {
                continue;
            }
            if (!a3.unify(newSym, engine.trail)) {
                continue;
            }
            if (!a4.unify(oldSym, engine.trail)) {
                continue;
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#end_block

#method_before
@Override
public void myGroups(final AsyncCallback<List<GroupDetail>> callback) {
    run(callback, new Action<List<GroupDetail>>() {

        public List<GroupDetail> run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            List<GroupDetail> groups = new ArrayList<GroupDetail>();
            try {
                for (AccountGroup group : myGroupsFactory.create().call()) {
                    groups.add(groupDetailFactory.create(group.getId()).call());
                }
            } catch (Exception e) {
                throw new Failure(e);
            }
            return groups;
        }
    });
}
#method_after
@Override
public void myGroups(final AsyncCallback<List<GroupDetail>> callback) {
    run(callback, new Action<List<GroupDetail>>() {

        public List<GroupDetail> run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            List<GroupDetail> groupDetails = new ArrayList<GroupDetail>();
            for (AccountGroup group : myGroupsFactory.create().call()) {
                groupDetails.add(groupDetailFactory.create(group.getId()).call());
            }
            return groupDetails;
        }
    });
}
#end_block

#method_before
private void postLoad() {
    if (haveAccount && haveEmails) {
        if (currentEmail != null) {
            boolean found = false;
            for (int i = 0; i < emailPick.getItemCount(); i++) {
                if (currentEmail.equals(emailPick.getValue(i))) {
                    emailPick.setSelectedIndex(i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                emailPick.addItem(currentEmail);
                emailPick.setSelectedIndex(emailPick.getItemCount() - 1);
            }
        }
        if (emailPick.getItemCount() > 0) {
            emailPick.setVisible(true);
            emailPick.setEnabled(true);
            if (canRegisterNewEmail()) {
                final String t = Util.C.buttonOpenRegisterNewEmail();
                emailPick.addItem("... " + t + "  ", t);
            }
        } else {
            emailPick.setVisible(false);
        }
        registerNewEmail.setEnabled(true);
    }
    display();
}
#method_after
private void postLoad() {
    if (haveAccount && haveEmails) {
        updateEmailList();
        registerNewEmail.setEnabled(true);
    }
    display();
}
#end_block

#method_before
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    box.hide();
                    switch(Gerrit.getConfig().getAuthType()) {
                        case HTTP:
                        case HTTP_LDAP:
                        case CLIENT_SSL_CERT_LDAP:
                        case OPENID:
                        case LDAP:
                        case LDAP_BIND:
                            break;
                        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                            Gerrit.upgradeUI(PageLinks.SETTINGS_CONTACT);
                            break;
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    body.add(new HTML(Util.C.descRegisterNewEmail()));
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#method_after
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                new ErrorDialog(Util.C.invalidUserEmail()).center();
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<Account>() {

                public void onSuccess(Account currentUser) {
                    box.hide();
                    if (Gerrit.getConfig().getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
                        currentEmail = addr;
                        if (emailPick.getItemCount() == 0) {
                            onSaveSuccess(currentUser);
                        } else {
                            save.setEnabled(true);
                        }
                        updateEmailList();
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    if (Gerrit.getConfig().getAuthType() != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        body.add(new HTML(Util.C.descRegisterNewEmail()));
    }
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#end_block

#method_before
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    try {
        switch(authConfig.getAuthType()) {
            case OPENID:
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
            case LDAP:
            case LDAP_BIND:
                final RegisterNewEmailSender sender;
                sender = registerNewEmailFactory.create(address);
                sender.send();
                cb.onSuccess(VoidResult.INSTANCE);
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                registerMail(address, cb);
                break;
            default:
                log.error("Unsupported loginType: " + authConfig.getAuthType(), new ProvisionException("Unsupported loginType: " + authConfig.getAuthType()));
                throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
        }
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#method_after
public void registerEmail(final String address, final AsyncCallback<Account> cb) {
    if (authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(address));
            cb.onSuccess(user.get().getAccount());
        } catch (AccountException e) {
            cb.onFailure(e);
        }
    } else {
        try {
            final RegisterNewEmailSender sender;
            sender = registerNewEmailFactory.create(address);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        }
    }
}
#end_block

#method_before
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        registerMail(newEmail, callback);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    }
}
#method_after
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        if (!newEmail.contains("@")) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(newEmail));
        callback.onSuccess(VoidResult.INSTANCE);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    } catch (AccountException e) {
        callback.onFailure(e);
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regex = Pattern.compile(a1.name());
    if (a2.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a2.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regexEdit = Pattern.compile(a2.name());
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    PatchList pl = getPatchList(env, psInfo);
    Repository repo;
    try {
        repo = getRepository(env);
    } catch (RepositoryNotFoundException err) {
        throw new JavaException(this, 1, err);
    }
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            final RevCommit p = bCommit.getParent(0);
            rw.parseHeaders(p);
            aTree = p.getTree();
        }
        bTree = bCommit.getTree();
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    for (PatchListEntry entry : pl.getPatches()) {
        String newName = entry.getNewName();
        String oldName = entry.getOldName();
        if (regex.matcher(newName).find() || (oldName != null && regex.matcher(oldName).find())) {
            List<Edit> edits = entry.getEdits();
            if (edits.isEmpty()) {
                continue;
            }
            try {
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, repo);
                } else {
                    tA = load(aTree, newName, repo);
                }
                Text tB = load(bTree, newName, repo);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (regexEdit.matcher(aDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (regexEdit.matcher(bDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                }
            } catch (IOException err) {
                throw new JavaException(this, 1, err);
            }
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Pattern fileRegex = getRegexParameter(a1);
    Pattern editRegex = getRegexParameter(a2);
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo = StoredValues.PATCH_SET_INFO.get(engine);
    PatchList pl = StoredValues.PATCH_LIST.get(engine);
    Repository repo = StoredValues.REPOSITORY.get(engine);
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            // web UI returns no files to match against, just fail.
            return engine.fail();
        }
        bTree = bCommit.getTree();
        for (PatchListEntry entry : pl.getPatches()) {
            String newName = entry.getNewName();
            String oldName = entry.getOldName();
            if (newName.equals("/COMMIT_MSG")) {
                continue;
            }
            if (fileRegex.matcher(newName).find() || (oldName != null && fileRegex.matcher(oldName).find())) {
                List<Edit> edits = entry.getEdits();
                if (edits.isEmpty()) {
                    continue;
                }
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, reader);
                } else {
                    tA = load(aTree, newName, reader);
                }
                Text tB = load(bTree, newName, reader);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (editRegex.matcher(aDiff).find()) {
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (editRegex.matcher(bDiff).find()) {
                            return cont;
                        }
                    }
                }
            }
        }
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    return engine.fail();
}
#end_block

#method_before
private Text load(final ObjectId tree, final String path, final Repository repo) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(repo, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(repo.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#method_after
private Text load(final ObjectId tree, final String path, final ObjectReader reader) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(reader, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(reader.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#end_block

#method_before
private void showText(Object data, int depth) {
    for (Field f : fieldsOf(data.getClass())) {
        Object val;
        try {
            val = f.get(data);
        } catch (IllegalArgumentException err) {
            continue;
        } catch (IllegalAccessException err) {
            continue;
        }
        if (val == null) {
            continue;
        }
        indent(depth);
        out.print(f.getName());
        out.print(":");
        if (val instanceof Long && isDateField(f.getName())) {
            out.print(' ');
            out.print(sdf.format(new Date(((Long) val) * 1000L)));
            out.print('\n');
        } else {
            showTextValue(val, depth);
        }
    }
}
#method_after
private void showText(Object data, int depth) {
    for (Field f : fieldsOf(data.getClass())) {
        Object val;
        try {
            val = f.get(data);
        } catch (IllegalArgumentException err) {
            continue;
        } catch (IllegalAccessException err) {
            continue;
        }
        if (val == null) {
            continue;
        }
        showField(f.getName(), val, depth);
    }
}
#end_block

#method_before
private void indent(int depth) {
    for (int i = 0; i < depth; i++) {
        out.print("  ");
    }
}
#method_after
private String indent(int spaces) {
    if (spaces == 0) {
        return "";
    } else {
        return String.format("%" + spaces + "s", " ");
    }
}
#end_block

#method_before
public MessageAttribute asMessageAttribute(ChangeMessage message) {
    MessageAttribute a = new MessageAttribute();
    a.timestamp = message.getWrittenOn().getTime();
    a.author = accountCache.get(message.getAuthor()).getAccount().getFullName();
    a.message = message.getMessage();
    return a;
}
#method_after
public MessageAttribute asMessageAttribute(ChangeMessage message) {
    MessageAttribute a = new MessageAttribute();
    a.timestamp = message.getWrittenOn().getTime() / 1000L;
    a.reviewer = asAccountAttribute(message.getAuthor());
    a.message = message.getMessage();
    return a;
}
#end_block

#method_before
public PatchSetCommentAttribute asPatchSetLineAttribute(PatchLineComment c) {
    PatchSetCommentAttribute a = new PatchSetCommentAttribute();
    a.author = accountCache.get(c.getAuthor()).getAccount().getFullName();
    a.file = c.getKey().getParentKey().get();
    a.line = c.getLine();
    a.message = c.getMessage();
    return a;
}
#method_after
public PatchSetCommentAttribute asPatchSetLineAttribute(PatchLineComment c) {
    PatchSetCommentAttribute a = new PatchSetCommentAttribute();
    a.reviewer = asAccountAttribute(c.getAuthor());
    a.file = c.getKey().getParentKey().get();
    a.line = c.getLine();
    a.message = c.getMessage();
    return a;
}
#end_block

#method_before
public Collection<ChangeMessage> messages(Provider<ReviewDb> db) throws OrmException {
    if (messages == null) {
        messages = db.get().changeMessages().byChange(legacyId).toList();
    }
    return messages;
}
#method_after
public List<ChangeMessage> messages(Provider<ReviewDb> db) throws OrmException {
    if (messages == null) {
        messages = db.get().changeMessages().byChange(legacyId).toList();
    }
    return messages;
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        try {
            while (parentState != null) {
                if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                    // parent has been seen before, stop walk up inheritance tree
                    break;
                }
                PrologEnvironment parentEnv;
                try {
                    parentEnv = parentState.newPrologEnvironment();
                } catch (CompileException err) {
                    return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
                }
                try {
                    parentEnv.copyStoredValues(childEnv);
                    Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
                    if (filterRule != null) {
                        try {
                            Term resultsTerm = toListTerm(results);
                            results.clear();
                            Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                            results.addAll(((ListTerm) template[2]).toJava());
                        } catch (PrologException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        } catch (RuntimeException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        }
                    }
                    parentState = parentState.getParentState();
                    childEnv = parentEnv;
                } finally {
                    // childEnv.close() below will handle it.
                    if (childEnv != parentEnv) {
                        parentEnv.close();
                    }
                }
            }
        } finally {
            childEnv.close();
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    child.delegateCleanup(cleanup);
}
#method_after
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    setCleanup(child.cleanup);
}
#end_block

#method_before
public void close() {
    for (Runnable task : cleanup) {
        task.run();
    }
    // ensure cleanup tasks run only once, even if close() is called again
    cleanup.clear();
}
#method_after
public void close() {
    for (final Iterator<Runnable> i = cleanup.iterator(); i.hasNext(); ) {
        try {
            i.next().run();
        } catch (Throwable err) {
            log.error("Failed to execute cleanup for PrologEnvironment", err);
        }
        i.remove();
    }
}
#end_block

#method_before
public T get(Prolog engine) {
    T obj = getOrNull(engine);
    if (obj == null) {
        // unless createValue() is overridden, will throw an exception
        obj = createValue(engine);
        set(engine, obj);
    }
    return obj;
}
#method_after
public T get(Prolog engine) {
    T obj = getOrNull(engine);
    if (obj == null) {
        // unless createValue() is overridden, will return null
        obj = createValue(engine);
        if (obj == null) {
            throw new SystemException("No " + key + " available");
        }
        set(engine, obj);
    }
    return obj;
}
#end_block

#method_before
protected T createValue(Prolog engine) {
    throw new SystemException("No " + key + " available");
}
#method_after
protected T createValue(Prolog engine) {
    return null;
}
#end_block

#method_before
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    if ("refs/meta/config".equals(k.getShortName()) || Constants.HEAD.equals(k.getShortName())) {
        fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().italic());
    }
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    if (c != null) {
        fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || Constants.HEAD.equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        return logRuleError("No user:submit_rule found for " + getProject().getName());
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    } catch (RuntimeException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    }
    ProjectState parentState = projectState.getParentState();
    PrologEnvironment parentEnv;
    PrologEnvironment childEnv = env;
    while (parentState != null) {
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", "locate_filter", new VariableTerm());
        if (filterRule != null) {
            try {
                Term resultsTerm = toListTerm(results);
                results.clear();
                List<Term> filtered = new ArrayList<Term>();
                for (Term[] template : parentEnv.all("gerrit", "filter_results", filterRule, resultsTerm, new VariableTerm())) {
                    results.add(template[2]);
                }
            } catch (PrologException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            } catch (RuntimeException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            }
        }
        parentState = parentState.getParentState();
        childEnv = parentEnv;
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        return logRuleError("No user:submit_rule found for " + getProject().getName());
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    } catch (RuntimeException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    }
    ProjectState parentState = projectState.getParentState();
    PrologEnvironment childEnv = env;
    Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
    projectsSeen.add(getProject().getNameKey());
    while (parentState != null) {
        if (!projectsSeen.add(parentState.getProject().getNameKey())) {
            // parent has been seen before, stop walk up inheritance tree
            break;
        }
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
        if (filterRule != null) {
            try {
                Term resultsTerm = toListTerm(results);
                results.clear();
                Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                results.addAll(((ListTerm) template[2]).toJava());
            } catch (PrologException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            } catch (RuntimeException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            }
        }
        parentState = parentState.getParentState();
        childEnv = parentEnv;
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (Term term : terms) {
        list = new ListTerm(term, list);
    }
    return list;
}
#method_after
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException {
    final ProjectControl pctl = // 
    projectControlFactory.validateFor(// 
    projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    final List<Branch> branches = new ArrayList<Branch>();
    Branch headBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException noGitRepository) {
        return new ListBranchesResult(branches, false, true);
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = pctl.controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                Branch b = createBranch(ref.getName());
                b.setRevision(new RevId(target));
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            RefControl refControl = pctl.controlForRef(ref.getName());
            if ((// 
            ref.getName().startsWith(Constants.R_HEADS) || GitRepositoryManager.REF_CONFIG.equals(ref.getName())) && refControl.isVisible()) {
                final Branch b = createBranch(ref.getName());
                if (ref.getObjectId() != null) {
                    b.setRevision(new RevId(ref.getObjectId().name()));
                }
                b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
                branches.add(b);
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<Branch>() {

        @Override
        public int compare(final Branch a, final Branch b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return new ListBranchesResult(branches, pctl.canAddRefs(), false);
}
#method_after
@Override
public ListBranchesResult call() throws NoSuchProjectException {
    final ProjectControl pctl = // 
    projectControlFactory.validateFor(// 
    projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    final List<Branch> branches = new ArrayList<Branch>();
    Branch headBranch = null;
    Branch configBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException noGitRepository) {
        return new ListBranchesResult(branches, false, true);
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = pctl.controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                Branch b = createBranch(ref.getName());
                b.setRevision(new RevId(target));
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            final RefControl refControl = pctl.controlForRef(ref.getName());
            if (refControl.isVisible()) {
                if (ref.getName().startsWith(Constants.R_HEADS)) {
                    branches.add(createBranch(ref, refControl, targets));
                } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) {
                    configBranch = createBranch(ref, refControl, targets);
                }
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<Branch>() {

        @Override
        public int compare(final Branch a, final Branch b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (configBranch != null) {
        branches.add(0, configBranch);
    }
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return new ListBranchesResult(branches, pctl.canAddRefs(), false);
}
#end_block

#method_before
private Branch createBranch(final String name) {
    return new Branch(new Branch.NameKey(projectName, name));
}
#method_after
private Branch createBranch(final Ref ref, final RefControl refControl, final Set<String> targets) {
    final Branch b = createBranch(ref.getName());
    if (ref.getObjectId() != null) {
        b.setRevision(new RevId(ref.getObjectId().name()));
    }
    b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
    return b;
}
#end_block

#method_before
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, "Base");
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, Util.M.patchSetHeader(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#method_after
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(0, 0, PatchUtil.C.patchHeaderPatchSet());
    fmt.setStyleName(0, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, PatchUtil.C.patchBase());
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, String.valueOf(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().patchHistoryTablePatchSetHeader());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    doPost(req, rsp);
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#end_block

#method_before
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(rsp, req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(rsp, req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(rsp, req.getParameter("account_id"));
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        rsp.setContentLength(raw.length);
        final OutputStream out = rsp.getOutputStream();
        try {
            out.write(raw);
        } finally {
            out.close();
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(urlProvider.get());
        if (IS_DEV && req.getParameter("gwt.codesvr") != null) {
            if (rdr.indexOf("?") < 0) {
                rdr.append("?");
            } else {
                rdr.append("&");
            }
            rdr.append("gwt.codesvr=").append(req.getParameter("gwt.codesvr"));
        }
        rdr.append('#');
        if (res.isNew()) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(PageLinks.MINE);
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        final Writer out = rsp.getWriter();
        out.write("<html>");
        out.write("<body>");
        out.write("<h1>Account Not Found</h1>");
        out.write("</body>");
        out.write("</html>");
        out.close();
    }
}
#method_after
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(rsp, req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(rsp, req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(rsp, req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        rsp.setContentLength(raw.length);
        final OutputStream out = rsp.getOutputStream();
        try {
            out.write(raw);
        } finally {
            out.close();
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(urlProvider.get());
        if (IS_DEV && req.getParameter("gwt.codesvr") != null) {
            if (rdr.indexOf("?") < 0) {
                rdr.append("?");
            } else {
                rdr.append("&");
            }
            rdr.append("gwt.codesvr=").append(req.getParameter("gwt.codesvr"));
        }
        rdr.append('#');
        if (res.isNew()) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(PageLinks.MINE);
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        final Writer out = rsp.getWriter();
        out.write("<html>");
        out.write("<body>");
        out.write("<h1>Account Not Found</h1>");
        out.write("</body>");
        out.write("</html>");
        out.close();
    }
}
#end_block

#method_before
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerFactory.create(id, reviewers, confirmed).to(callback);
}
#method_after
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerHandlerFactory.create(id, reviewers, confirmed).to(callback);
}
#end_block

#method_before
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerFactory.create(id, reviewerId).to(callback);
}
#method_after
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerHandlerFactory.create(id, reviewerId).to(callback);
}
#end_block

#method_before
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
private void displayHeader() {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (final ApprovalType t : types) {
        table.setText(0, col, t.getCategory().getName());
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(0, col, Gerrit.RESOURCES.css().rightmost());
    col++;
}
#method_after
private void displayHeader(List<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (String name : labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), change);
        }
        table.setVisible(true);
    }
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Element li = DOM.createElement("li");
                li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                DOM.setInnerText(li, Util.M.needApproval(at.getCategory().getName(), at.getMax().formatValue(), at.getMax().getName()));
                DOM.appendChild(missingList, li);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.setVisible(Gerrit.isSignedIn() && change.getStatus().isOpen());
}
#method_after
void display(ChangeDetail detail) {
    reviewerSuggestOracle.setProject(detail.getChange().getProject());
    List<String> columns = new ArrayList<String>();
    List<ApprovalDetail> rows = detail.getApprovals();
    changeId = detail.getChange().getId();
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (detail.getSubmitRecords() != null) {
        HashSet<String> reportedMissing = new HashSet<String>();
        HashMap<Account.Id, ApprovalDetail> byUser = new HashMap<Account.Id, ApprovalDetail>();
        for (ApprovalDetail ad : detail.getApprovals()) {
            byUser.put(ad.getAccount(), ad);
        }
        for (SubmitRecord rec : detail.getSubmitRecords()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label lbl : rec.labels) {
                if (!columns.contains(lbl.label)) {
                    columns.add(lbl.label);
                }
                switch(lbl.status) {
                    case OK:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.approved(lbl.label);
                            }
                            break;
                        }
                    case REJECT:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.rejected(lbl.label);
                            }
                            break;
                        }
                    case NEED:
                    case IMPOSSIBLE:
                        if (reportedMissing.add(lbl.label)) {
                            Element li = DOM.createElement("li");
                            li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                            DOM.setInnerText(li, Util.M.needApproval(lbl.label));
                            DOM.appendChild(missingList, li);
                        }
                        break;
                }
            }
        }
        missing.setVisible(!reportedMissing.isEmpty());
    } else {
        for (ApprovalDetail ad : rows) {
            for (PatchSetApproval psa : ad.getPatchSetApprovals()) {
                ApprovalType legacyType = types.byId(psa.getCategoryId());
                if (legacyType == null) {
                    continue;
                }
                String labelName = legacyType.getCategory().getLabelName();
                if (psa.getValue() == legacyType.getMax().getValue()) {
                    ad.approved(labelName);
                } else if (psa.getValue() == legacyType.getMin().getValue()) {
                    ad.rejected(labelName);
                }
                if (!columns.contains(labelName)) {
                    columns.add(labelName);
                }
            }
            Collections.sort(columns, new Comparator<String>() {

                @Override
                public int compare(String o1, String o2) {
                    ApprovalType a = types.byLabel(o1);
                    ApprovalType b = types.byLabel(o2);
                    int cmp = 0;
                    if (a != null && b != null) {
                        cmp = a.getCategory().getPosition() - b.getCategory().getPosition();
                    }
                    if (cmp == 0) {
                        cmp = o1.compareTo(o2);
                    }
                    return cmp;
                }
            });
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        displayHeader(columns);
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), detail.getChange(), columns);
        }
        table.setVisible(true);
    }
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
private void doAddReviewer() {
    final String userNameOrEmailOrGroupName = addMemberBox.getText();
    if (userNameOrEmailOrGroupName.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(userNameOrEmailOrGroupName);
    addReviewers(reviewers, false);
}
#method_after
private void doAddReviewer() {
    final String reviewer = addMemberBox.getText();
    if (reviewer.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(reviewer);
    addReviewers(reviewers, false);
}
#end_block

#method_before
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail.getChange(), changeDetail.getMissingApprovals(), changeDetail.getApprovals());
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case ACCOUNT_OR_GROUP_NOT_FOUND:
                            r.append(Util.M.accountOrGroupNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                StringBuilder message = new StringBuilder();
                                message.append("<b>");
                                message.append(Util.M.groupManyMembersConfirmation(e.getName(), result.getMemberCount()));
                                message.append("</b>");
                                ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                                    @Override
                                    public void onOk() {
                                        addReviewers(reviewers, true);
                                    }
                                });
                                confirmationDialog.center();
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail);
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case REVIEWER_NOT_FOUND:
                            r.append(Util.M.reviewerNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                askForConfirmation(e.getName(), result.getMemberCount());
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        private void askForConfirmation(final String groupName, final int memberCount) {
            final StringBuilder message = new StringBuilder();
            message.append("<b>");
            message.append(Util.M.groupManyMembersConfirmation(groupName, memberCount));
            message.append("</b>");
            final ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewers(reviewers, true);
                }
            });
            confirmationDialog.center();
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap();
    final StringBuilder hint = new StringBuilder();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (final ApprovalType type : types) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        final PatchSetApproval ca = am.get(type.getCategory().getId());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
            col++;
            continue;
        }
        final ApprovalCategoryValue acv = type.getValue(ca);
        if (acv != null) {
            if (hint.length() > 0) {
                hint.append("; ");
            }
            hint.append(acv.getName());
        }
        if (type.isMaxNegative(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (type.isMaxPositive(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    table.setText(row, col, hint.toString());
    fmt.setStyleName(row, col, Gerrit.RESOURCES.css().rightmost());
    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().approvalhint());
    col++;
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r.getChange(), r.getMissingApprovals(), r.getApprovals());
            } else {
                new ErrorDialog(result.getErrors().get(0).toString()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r);
            } else {
                final ReviewerResult.Error resultError = result.getErrors().get(0);
                String message;
                switch(resultError.getType()) {
                    case REMOVE_NOT_PERMITTED:
                        message = Util.C.approvalTableRemoveNotPermitted();
                        break;
                    case COULD_NOT_REMOVE:
                    default:
                        message = Util.C.approvalTableCouldNotRemove();
                }
                new ErrorDialog(message + " " + resultError.getName()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public PatchSet.Id getPatchSetId() {
    return psId;
}
#method_after
public PatchSet.Id getPatchSetId() {
    return patchSetId;
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(db, pc, meta, true, this.tagCache).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, db, pc, meta, true).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(GitTagCacheImpl.module());
    install(RegExpCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(TagCache.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            // 
            deferredTags.add(ref);
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        Map<Ref, List<Ref>> reachableTags = tagCache.get(db);
        for (Ref tag : reachableTags.keySet()) {
            for (Ref ref : reachableTags.get(tag)) {
                if (projectCtl.controlForRef(ref.getName()).isVisible()) {
                    result.put(tag.getName(), tag);
                    break;
                }
            }
        }
    }
    return result;
}
#method_after
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // 
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        TagMatcher tags = tagCache.get(projectName).matcher(db, result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get(), true, tagCache));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get(), true, tagCache));
    }
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, pc, db.get(), true));
    }
    return up;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey name = change.getProject();
    if (!a1.unify(SymbolTerm.intern(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey name = change.getProject();
    if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Term topicTerm = Prolog.Nil;
    Change change = StoredValues.CHANGE.get(engine);
    String topic = change.getTopic();
    if (topic != null) {
        topicTerm = SymbolTerm.intern(topic);
    }
    if (!a1.unify(topicTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Term topicTerm = Prolog.Nil;
    Change change = StoredValues.CHANGE.get(engine);
    String topic = change.getTopic();
    if (topic != null) {
        topicTerm = SymbolTerm.create(topic);
    }
    if (!a1.unify(topicTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Branch.NameKey name = change.getDest();
    if (!a1.unify(SymbolTerm.intern(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Branch.NameKey name = change.getDest();
    if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Term a3 = arg3.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    final PatchSet.Id id = StoredValues.PATCH_SET_ID.get(engine);
    PatchSetInfoFactory psiFactory = env.getInjector().getInstance(PatchSetInfoFactory.class);
    Term idTerm;
    Term nameTerm = Prolog.Nil;
    Term emailTerm = Prolog.Nil;
    try {
        UserIdentity author = psiFactory.get(id).getAuthor();
        Account.Id authorId = author.getAccount();
        if (authorId == null) {
            idTerm = SymbolTerm.intern("anonymous");
        } else {
            idTerm = new IntegerTerm(authorId.get());
        }
        String name = author.getName();
        if (name != null && !name.equals("")) {
            nameTerm = SymbolTerm.intern(name);
        }
        String email = author.getEmail();
        if (email != null && !email.equals("")) {
            emailTerm = SymbolTerm.intern(email);
        }
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    if (!a1.unify(new StructureTerm(user, idTerm), engine.trail)) {
        return engine.fail();
    }
    if (!a2.unify(nameTerm, engine.trail)) {
        return engine.fail();
    }
    if (!a3.unify(emailTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(engine);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity author = psInfo.getAuthor();
    return exec(engine, author);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Term a3 = arg3.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    final PatchSet.Id id = StoredValues.PATCH_SET_ID.get(engine);
    PatchSetInfoFactory psiFactory = env.getInjector().getInstance(PatchSetInfoFactory.class);
    Term idTerm;
    Term nameTerm = Prolog.Nil;
    Term emailTerm = Prolog.Nil;
    try {
        UserIdentity committer = psiFactory.get(id).getCommitter();
        Account.Id committerId = committer.getAccount();
        if (committerId == null) {
            idTerm = SymbolTerm.intern("anonymous");
        } else {
            idTerm = new IntegerTerm(committerId.get());
        }
        String name = committer.getName();
        if (name != null && !name.equals("")) {
            nameTerm = SymbolTerm.intern(name);
        }
        String email = committer.getEmail();
        if (email != null && !email.equals("")) {
            emailTerm = SymbolTerm.intern(email);
        }
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    if (!a1.unify(new StructureTerm(user, idTerm), engine.trail)) {
        return engine.fail();
    }
    if (!a2.unify(nameTerm, engine.trail)) {
        return engine.fail();
    }
    if (!a3.unify(emailTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(engine);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity committer = psInfo.getCommitter();
    return exec(engine, committer);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    dbInjector = createDbInjector(MULTI_USER);
    manager.add(dbInjector);
    manager.start();
    dbInjector.injectMembers(this);
    Project.NameKey project = getNameKey();
    Repository git = gitManager.openRepository(project);
    PrologJar jarMaker = new PrologJar(getSitePath(), git);
    boolean success = jarMaker.run();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    dbInjector = createDbInjector(SINGLE_USER);
    manager.add(dbInjector);
    manager.start();
    dbInjector.createChildInjector(new FactoryModule() {

        @Override
        protected void configure() {
            factory(PrologCompiler.Factory.class);
        }
    }).injectMembers(this);
    LinkedHashSet<Project.NameKey> names = new LinkedHashSet<Project.NameKey>();
    for (String name : projectNames) {
        names.add(new Project.NameKey(name));
    }
    if (all) {
        names.addAll(gitManager.list());
    }
    boolean error = false;
    for (Project.NameKey project : names) {
        Repository git = gitManager.openRepository(project);
        try {
            switch(jarFactory.create(git).call()) {
                case NO_RULES:
                    if (!all || projectNames.contains(project.get())) {
                        System.err.println("error: No rules.pl in " + project.get());
                        error = true;
                    }
                    break;
                case COMPILED:
                    if (!quiet) {
                        System.out.format("Compiled %-60s ... SUCCESS", project.get());
                        System.out.println();
                    }
                    break;
            }
        } catch (CompileException err) {
            if (showStackTrace) {
                err.printStackTrace();
            } else {
                System.err.println("fatal: " + err.getMessage());
            }
            error = true;
        } finally {
            git.close();
        }
    }
    return !error ? 0 : 1;
}
#end_block

#method_before
public URLClassLoader getClassLoader(ObjectId rulesId) {
    // get rules.pl's sha1, if it exists
    String filePath = "";
    File cacheFolder = site.resolve(config.getString("cache", null, "directory"));
    if (cacheFolder != null) {
        filePath = cacheFolder.getPath();
    }
    // read jar from (site)/cache/rules
    // the included jar file should be in format:
    // rules-(rules.pl's sha1).jar
    File jarFile = null;
    if (rulesId != null) {
        jarFile = new File(filePath + "/rules/rules-" + rulesId.getName() + ".jar");
    }
    ClassLoader defaultLoader = getClass().getClassLoader();
    if (cacheFolder != null && jarFile != null && jarFile.exists()) {
        URL url;
        try {
            url = jarFile.toURI().toURL();
        } catch (MalformedURLException e) {
            return null;
        }
        URL[] urls = new URL[] { url };
        return new URLClassLoader(urls, defaultLoader);
    } else {
        return null;
    }
}
#method_after
public synchronized ClassLoader getClassLoader(ObjectId rulesId) {
    if (rulesId == null || rulesDir == null) {
        return null;
    }
    Reference<? extends ClassLoader> ref = classLoaderCache.get(rulesId);
    if (ref != null) {
        ClassLoader cl = ref.get();
        if (cl != null) {
            return cl;
        }
        classLoaderCache.remove(rulesId);
        ref.enqueue();
    }
    cleanCache();
    // read jar from (site)/cache/rules
    // the included jar file should be in format:
    // rules-(rules.pl's sha1).jar
    File jarFile = new File(rulesDir, "rules-" + rulesId.getName() + ".jar");
    if (!jarFile.isFile()) {
        return null;
    }
    ClassLoader defaultLoader = getClass().getClassLoader();
    URL url;
    try {
        url = jarFile.toURI().toURL();
    } catch (MalformedURLException e) {
        log.error("Path to rules jar is broken", e);
        return null;
    }
    ClassLoader urlLoader = new URLClassLoader(new URL[] { url }, defaultLoader);
    LoaderRef lRef = new LoaderRef(rulesId, urlLoader);
    classLoaderCache.put(rulesId, lRef);
    return urlLoader;
}
#end_block

#method_before
private ProjectState newProjectState() {
    final Map<Project.NameKey, ProjectState> all = new HashMap<Project.NameKey, ProjectState>();
    final ProjectCache projectCache = new ProjectCache() {

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }
    };
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager mgr = null;
    Project.NameKey wildProject = new Project.NameKey("All-Projects");
    ProjectControl.AssistedFactory projectControlFactory = null;
    all.put(local.getProject().getNameKey(), new ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, envFactory, mgr, local, null));
    all.put(parent.getProject().getNameKey(), new ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, envFactory, mgr, parent, null));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState() {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager mgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    all.put(local.getProject().getNameKey(), new ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, local));
    all.put(parent.getProject().getNameKey(), new ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, parent));
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() throws CompileException {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    PrologEnvironment env;
    if (urlLoader != null) {
        env = envFactory.create(urlLoader);
        return env;
    } else {
        env = envFactory.create(getClass().getClassLoader());
    }
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    if (ruleLoader != null) {
        return envFactory.create(ruleLoader);
    }
    PrologEnvironment env = envFactory.create(getClass().getClassLoader());
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#end_block

#method_before
public Collection<AccessSection> getInheritedAccessSections() {
    if (isWildProject()) {
        return Collections.emptyList();
    }
    List<AccessSection> inherited = new ArrayList<AccessSection>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    Project.NameKey parent = getProject().getParent();
    while (parent != null && seen.add(parent)) {
        ProjectState s = projectCache.get(parent);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
            parent = s.getProject().getParent();
        } else {
            break;
        }
    }
    // Wild project is the parent, or the root of the tree
    if (parent == null) {
        ProjectState s = projectCache.get(wildProject);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
        }
    }
    return inherited;
}
#method_after
public Collection<AccessSection> getInheritedAccessSections() {
    if (isAllProjects) {
        return Collections.emptyList();
    }
    List<AccessSection> inherited = new ArrayList<AccessSection>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    Project.NameKey parent = getProject().getParent();
    while (parent != null && seen.add(parent)) {
        ProjectState s = projectCache.get(parent);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
            parent = s.getProject().getParent();
        } else {
            break;
        }
    }
    // The root of the tree is the special "All-Projects" case.
    if (parent == null) {
        inherited.addAll(projectCache.getAllProjects().getLocalAccessSections());
    }
    return inherited;
}
#end_block

#method_before
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isWildProject()) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#method_after
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isAllProjects) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            parseCommandLine();
            boolean ok = true;
            for (final Change.Id changeId : changeIds) {
                try {
                    ok = ok && modifyOne(changeId);
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while modifying reviewers in " + changeId + "\n");
                    log.error("internal error while modifying reviewers in " + changeId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more modifications of reviewers failed; review output above");
            }
        }
    });
}
#method_after
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            parseCommandLine();
            boolean ok = true;
            for (Change.Id changeId : changes) {
                try {
                    ok &= modifyOne(changeId);
                } catch (Exception err) {
                    ok = false;
                    log.error("Error updating reviewers on change " + changeId, err);
                    writeError("fatal", "internal error while updating " + changeId);
                }
            }
            if (!ok) {
                throw error("fatal: one or more updates failed; review output above");
            }
        }
    });
}
#end_block

#method_before
private boolean modifyOne(final Change.Id changeId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException, Exception {
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    boolean ok = true;
    for (final Account.Id accountId : reviewersToRemove) {
        final ReviewerResult result = removeReviewerFactory.create(changeId, accountId).call();
        for (ReviewerResult.Error resultError : result.getErrors()) {
            // sensitive information that we do not want to reveal to the user.
            if (resultError.getType() == ReviewerResult.Error.Type.COULD_NOT_REMOVE) {
                // For COULD_NOT_REMOVE, getName() contains the specific error
                // message with an id at the end
                final String message = resultError.getName();
                String regex = accountId + "$";
                if (message.matches("^.* " + regex)) {
                    writeError("error: " + message.replaceAll(regex, "\"" + allReviewers.get(accountId)) + "\"\n");
                } else {
                    writeError("error: " + "\"" + allReviewers.get(accountId) + "\" could not be removed\n");
                }
                ok = false;
            }
        }
    }
    final ReviewerResult result = addReviewerFactory.create(changeId, reviewersToAdd).call();
    // user and we have checked for this when we parsed the arguments.
    for (ReviewerResult.Error resultError : result.getErrors()) {
        ok = false;
        writeError("\"" + resultError.getName() + "\" could not be added\n");
    }
    return ok;
}
#method_after
private boolean modifyOne(Change.Id changeId) throws Exception {
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    ReviewerResult result;
    boolean ok = true;
    // Remove reviewers
    // 
    result = removeReviewerFactory.create(changeId, toRemove).call();
    ok &= result.getErrors().isEmpty();
    for (ReviewerResult.Error resultError : result.getErrors()) {
        String message;
        switch(resultError.getType()) {
            case REMOVE_NOT_PERMITTED:
                message = "not permitted to remove {0} from {1}";
                break;
            case COULD_NOT_REMOVE:
                message = "could not remove {0} from {1}";
                break;
            default:
                message = "could not remove {0}: {2}";
        }
        writeError("error", MessageFormat.format(message, resultError.getName(), changeId, resultError.getType()));
    }
    // Add reviewers
    // 
    result = addReviewerFactory.create(changeId, stringSet(toAdd)).call();
    ok &= result.getErrors().isEmpty();
    for (ReviewerResult.Error resultError : result.getErrors()) {
        String message;
        switch(resultError.getType()) {
            case ACCOUNT_NOT_FOUND:
                message = "account {0} not found";
                break;
            case ACCOUNT_INACTIVE:
                message = "account {0} inactive";
                break;
            case CHANGE_NOT_VISIBLE:
                message = "change {1} not visible to {0}";
                break;
            default:
                message = "could not add {0}: {2}";
        }
        writeError("error", MessageFormat.format(message, resultError.getName(), changeId, resultError.getType()));
    }
    return ok;
}
#end_block

#method_before
private Set<Change.Id> parseChangeId(final String changeIdentity) throws UnloggedFailure, OrmException {
    final Set<Change.Id> matches = new HashSet<Change.Id>();
    boolean foundInOtherProject = false;
    boolean matchesChangeKey = changeIdentity.matches("^I[0-9a-fA-F]*$");
    boolean matchesChangeId = changeIdentity.matches("^[1-9][0-9]*$");
    // By newer style changeKey?
    // 
    boolean changeKeyParses = matchesChangeKey;
    if (matchesChangeKey) {
        Change.Key changeKey = null;
        try {
            changeKey = Change.Key.parse(changeIdentity);
        } catch (IllegalArgumentException e) {
            changeKeyParses = false;
        }
        if (changeKeyParses) {
            final ResultSet<Change> changes = db.changes().byKeyRange(changeKey, changeKey.max());
            for (final Change change : changes) {
                if (inProject(change)) {
                    matches.add(change.getId());
                } else {
                    foundInOtherProject = true;
                }
            }
        }
    }
    // By older style changeId?
    // 
    boolean changeIdParses = matchesChangeId;
    if (matchesChangeId) {
        Change.Id changeId = null;
        try {
            changeId = Change.Id.parse(changeIdentity);
        } catch (IllegalArgumentException e) {
            changeIdParses = false;
        }
        if (changeIdParses) {
            final Change change = db.changes().get(changeId);
            if (change != null) {
                if (inProject(change)) {
                    matches.add(change.getId());
                } else {
                    foundInOtherProject = true;
                }
            }
        }
    }
    if (!changeKeyParses && !changeIdParses) {
        throw error("\"" + changeIdentity + "\" is not a valid change");
    }
    switch(matches.size()) {
        case 1:
            return matches;
        case 0:
            if (foundInOtherProject) {
                throw error("change " + changeIdentity + " not in project " + projectControl.getProject().getName());
            }
            throw error("\"" + changeIdentity + "\" no such change");
        default:
    }
    throw error("\"" + changeIdentity + "\" matches multiple changes");
}
#method_after
private Set<Change.Id> parseChangeId(String idstr) throws UnloggedFailure, OrmException {
    Set<Change.Id> matched = new HashSet<Change.Id>(4);
    boolean isCommit = idstr.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$");
    // By newer style changeKey?
    // 
    boolean changeKeyParses = false;
    if (idstr.matches("^I[0-9a-fA-F]*$")) {
        Change.Key key;
        try {
            key = Change.Key.parse(idstr);
            changeKeyParses = true;
        } catch (IllegalArgumentException e) {
            key = null;
            changeKeyParses = false;
        }
        if (changeKeyParses) {
            for (Change change : db.changes().byKeyRange(key, key.max())) {
                matchChange(matched, change);
            }
        }
    }
    // 
    if (isCommit) {
        RevId id = new RevId(idstr);
        ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet ps : patches) {
            matchChange(matched, ps.getId().getParentKey());
        }
    }
    // By older style changeId?
    // 
    boolean changeIdParses = false;
    if (idstr.matches("^[1-9][0-9]*$")) {
        Change.Id id;
        try {
            id = Change.Id.parse(idstr);
            changeIdParses = true;
        } catch (IllegalArgumentException e) {
            id = null;
            changeIdParses = false;
        }
        if (changeIdParses) {
            matchChange(matched, id);
        }
    }
    if (!changeKeyParses && !isCommit && !changeIdParses) {
        throw error("\"" + idstr + "\" is not a valid change");
    }
    switch(matched.size()) {
        case 0:
            throw error("\"" + idstr + "\" no such change");
        case 1:
            return matched;
        default:
            throw error("\"" + idstr + "\" matches multiple changes");
    }
}
#end_block

#method_before
private boolean inProject(final Change change) {
    if (projectControl == null) {
        // No --project option, so they want every project.
        return true;
    }
    return projectControl.getProject().getNameKey().equals(change.getProject());
}
#method_after
private boolean inProject(Change change) {
    if (projectControl != null) {
        return projectControl.getProject().getNameKey().equals(change.getProject());
    } else {
        // No --project option, so they want every project.
        return true;
    }
}
#end_block

#method_before
private void writeError(final String msg) {
    try {
        err.write(msg.getBytes(ENC));
    } catch (IOException e) {
    }
}
#method_after
private void writeError(String type, String msg) {
    try {
        err.write((type + ": " + msg + "\n").getBytes(ENC));
    } catch (IOException e) {
    }
}
#end_block

#method_before
private static UnloggedFailure error(final String msg) {
    return new UnloggedFailure(1, msg);
}
#method_after
private static UnloggedFailure error(String msg) {
    return new UnloggedFailure(1, msg);
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, final int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(idx + 1);
    m.closeAnchor();
    m.closeTd();
}
#method_after
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(idx + 1);
    m.closeTd();
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(lineNumberMinusOne + 1);
    m.closeAnchor();
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(lineNumberMinusOne + 1);
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    return envFactory.create(getClass().getClassLoader());
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    PrologEnvironment env = envFactory.create(getClass().getClassLoader());
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.makeSymbol("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it
    return canAbandon();
// back
}
#method_after
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#end_block

#method_before
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env = getProjectControl().getProjectState().newPrologEnvironment();
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    StructureTerm submitRule = SymbolTerm.makeSymbol("com.google.gerrit.rules.common", "default_submit", 1);
    ObjectStream ruleStream = getProjectControl().getProjectState().getPrologRules();
    if (ruleStream != null) {
        try {
            PushbackReader in = new PushbackReader(new InputStreamReader(ruleStream, Charset.forName("UTF-8")), Prolog.PUSHBACK_SIZE);
            JavaObjectTerm streamObject = new JavaObjectTerm(in);
            if (!env.execute(Prolog.BUILTIN, "consultStream", SymbolTerm.makeSymbol("submitrules"), streamObject)) {
                throw new CompileException("Cannot consult" + streamObject.toString());
            }
            // Replaces default_submit predicate with the submit_rule predicate in
            // the refs/meta/config:submit_rules.pl (if it exists)
            submitRule = SymbolTerm.makeSymbol("user", "submit_rule", 1);
        } catch (CompileException err) {
            log.error("Cannot consult provided submit_rules.pl", err);
        } finally {
            try {
                ruleStream.close();
            } catch (IOException err) {
                log.error("Close of ruleStream failed", err);
            }
        }
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#method_after
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env;
    try {
        env = getProjectControl().getProjectState().newPrologEnvironment();
    } catch (CompileException err) {
        log.error("cannot consult rules.pl", err);
        return new CanSubmitResult("Error reading submit rule");
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("com.google.gerrit.rules.common", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        log.error("Error in locate_submit_rule: no submit_rule found");
        return new CanSubmitResult("Error in finding submit rule");
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = (new ListenableAccountDiffPreference()).get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = (new ListenableAccountDiffPreference()).get();
        }
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    patchesList = new ListBox();
    patchesList.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            final int index = patchesList.getSelectedIndex();
            final String selectedPatchSet = patchesList.getValue(index);
            if (selectedPatchSet.equals("Base")) {
                diffBaseId = null;
            } else {
                diffBaseId = PatchSet.Id.parse(selectedPatchSet);
            }
            if (patchSetsBlock != null) {
                patchSetsBlock.refresh(diffBaseId);
            }
        }
    });
    patchesList.addItem("Base");
    patchesGrid = new Grid(1, 2);
    patchesGrid.setStyleName(Gerrit.RESOURCES.css().selectPatchSetOldVersion());
    patchesGrid.setText(0, 0, Util.C.oldVersionHistory());
    patchesGrid.setWidget(0, 1, patchesList);
    add(patchesGrid);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("auto");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    add(dependenciesPanel);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("auto");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    add(dependenciesPanel);
    patchesList = new ListBox();
    patchesList.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            final int index = patchesList.getSelectedIndex();
            final String selectedPatchSet = patchesList.getValue(index);
            if (index == 0) {
                diffBaseId = null;
            } else {
                diffBaseId = PatchSet.Id.parse(selectedPatchSet);
            }
            if (patchSetsBlock != null) {
                patchSetsBlock.refresh(diffBaseId);
            }
        }
    });
    patchesList.addItem(Util.C.baseDiffItem());
    patchesGrid = new Grid(1, 2);
    patchesGrid.setStyleName(Gerrit.RESOURCES.css().selectPatchSetOldVersion());
    patchesGrid.setText(0, 0, Util.C.oldVersionHistory());
    patchesGrid.setWidget(0, 1, patchesList);
    add(patchesGrid);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (starChange != null) {
        setStarred(detail.isStarred());
    }
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null) {
        if (patchesList != null) {
            int index = -1;
            for (int i = 0; i < patchesList.getItemCount(); i++) {
                if (!patchesList.getValue(i).equals("Base")) {
                    if (diffBaseId.equals(PatchSet.Id.parse(patchesList.getValue(i)))) {
                        index = i;
                        break;
                    }
                }
            }
            patchesList.setSelectedIndex(index);
        }
    }
    patchSetsBlock.display(detail, diffBaseId);
    if (openPatchSetId != null) {
        patchSetsBlock.activate(openPatchSetId);
    }
    addComments(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (starChange != null) {
        setStarred(detail.isStarred());
    }
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null && patchesList != null) {
        patchesList.setSelectedIndex(diffBaseId.get());
    }
    patchSetsBlock.display(detail, diffBaseId);
    if (openPatchSetId != null) {
        patchSetsBlock.activate(openPatchSetId);
    }
    addComments(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
}
#end_block

#method_before
public void display(PatchSetDetail detail) {
    this.detail = detail;
    this.patchList = detail.getPatches();
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(patchList, patchSetIdToCompareWith);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#method_after
public void display(PatchSetDetail detail) {
    this.detail = detail;
    this.patchList = detail.getPatches();
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(patchList, patchSetIdToCompareWith);
    if (cmd.execute()) {
        cmd.initMeter();
        Scheduler.get().scheduleIncremental(cmd);
    } else {
        cmd.showTable();
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    final PatchList list;
    if (psIdOld != null) {
        newId = toObjectId(psIdNew);
        oldId = psIdOld != null ? toObjectId(psIdOld) : null;
        projectKey = control.getProject().getNameKey();
        final Repository git;
        try {
            git = repoManager.openRepository(projectKey);
        } catch (RepositoryNotFoundException e) {
            log.error("Repository " + projectKey + " not found", e);
            throw new NoSuchChangeException(control.getChange().getId(), e);
        }
        git.close();
        list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
    } else {
        // OK, means use base to compare
        list = patchListCache.get(control.getChange(), patchSet);
        if (list == null) {
            throw new NoSuchEntityException();
        }
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<Patch.Key, Patch>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    for (final PatchLineComment c : db.patchComments().published(psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setInfo(infoFactory.get(psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user instanceof IdentifiedUser) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draft(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    return detail;
}
#method_after
@SuppressWarnings("deprecation")
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    final PatchList list;
    if (psIdOld != null) {
        newId = toObjectId(psIdNew);
        oldId = psIdOld != null ? toObjectId(psIdOld) : null;
        projectKey = control.getProject().getNameKey();
        list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
    } else {
        // OK, means use base to compare
        list = patchListCache.get(control.getChange(), patchSet);
        if (list == null) {
            throw new NoSuchEntityException();
        }
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<Patch.Key, Patch>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    for (final PatchLineComment c : db.patchComments().published(psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setInfo(infoFactory.get(psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user instanceof IdentifiedUser) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draft(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    return detail;
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    Grant grant = (Grant) o;
    return group.equals(grant.group) && pattern.equals(grant.pattern);
}
#method_after
@Override
public boolean equals(Object o) {
    if (o == null)
        return false;
    Grant grant = (Grant) o;
    return group.equals(grant.group) && pattern.equals(grant.pattern);
}
#end_block

#method_before
public Set<AccountGroup.Id> getOwners() {
    return owners;
}
#method_after
public Set<AccountGroup.Id> getOwners() {
    if (!localOwners.isEmpty() || isSpecialWildProject() || project.getParent() == null) {
        return localOwners;
    }
    final ProjectState parent = projectCache.get(project.getParent());
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#end_block

#method_before
void create(List<CodeReviewCommit> commits, PersonIdent author) throws MergeException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new MergeException("Couldn't create code review notes. Failed to lock the ref: " + REFS_NOTES_SUBMITTED);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                // TODO: NoteMapMerger.merge(base, ours,
                NoteMap merged = null;
                // theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new MergeException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new MergeException("Couldn't create code review notes", e);
    } catch (InterruptedException e) {
        throw new MergeException("Couldn't create code review notes", e);
    }
}
#method_after
public void create(List<CodeReviewCommit> commits, PersonIdent author) throws CodeReviewNoteCreationException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new CodeReviewNoteCreationException("Failed to lock the ref: " + REFS_NOTES_REVIEW);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                NoteMapMerger merger = new NoteMapMerger(db);
                NoteMap merged = merger.merge(base, ours, theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new CodeReviewNoteCreationException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new CodeReviewNoteCreationException(e);
    } catch (InterruptedException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        reader.release();
        inserter.release();
        revWalk.release();
    }
}
#end_block

#method_before
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_SUBMITTED);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#method_after
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_REVIEW);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#end_block

#method_before
private void setOurs() throws IOException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Submitted the following changes:");
    for (CodeReviewCommit c : commits) {
        if (ours.contains(c)) {
            throw new IllegalStateException("Review summary note already exists for commit: " + c + ". Merging of notes not yet supported");
        }
        ObjectId id = inserter.insert(Constants.OBJ_BLOB, createNoteContent(c));
        inserter.flush();
        RevBlob blob = revWalk.lookupBlob(id);
        ours.set(c, blob);
        message.append(" ");
        message.append(c.change.getId());
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#method_after
private void setOurs() throws IOException, CodeReviewNoteCreationException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Update notes for submitted changes\n\n");
    for (CodeReviewCommit c : commits) {
        ObjectId noteContent = createNoteContent(c);
        if (ours.contains(c)) {
            // merge the existing and the new note as if they are both new
            // means: base == null
            // there is not really a common ancestry for these two note revisions
            // use the same NoteMerger that is used from the NoteMapMerger
            DefaultNoteMerger noteMerger = new DefaultNoteMerger();
            Note newNote = new Note(c, noteContent);
            noteContent = noteMerger.merge(null, newNote, base.getNote(c), reader, inserter).getData();
        }
        ours.set(c, noteContent);
        message.append("* ").append(c.getShortMessage()).append("\n");
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#end_block

#method_before
private byte[] createNoteContent(CodeReviewCommit commit) throws UnsupportedEncodingException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter();
        formatter.appendChangeId(commit.change.getId());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(schema.approvalCategories().get(a.getCategoryId()), a.getValue(), schema.accounts().get(a.getAccountId()));
            }
        }
        formatter.appendBranch(schema.projects().get(commit.change.getProject()), commit.change.getDest());
        formatter.appendSubmittedBy(schema.accounts().get(submit.getAccountId()));
        formatter.appendSubmittedOn(submit.getGranted());
        return formatter.toString().getBytes("UTF-8");
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private ObjectId createNoteContent(CodeReviewCommit commit) throws CodeReviewNoteCreationException, IOException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter(author.getTimeZone());
        final List<String> idList = commit.getFooterLines(CHANGE_ID);
        if (idList.isEmpty())
            formatter.appendChangeId(commit.change.getKey());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(approvalTypes.getApprovalType(a.getCategoryId()).getCategory(), a.getValue(), accountCache.get(a.getAccountId()).getAccount());
            }
        }
        formatter.appendSubmittedBy(accountCache.get(submit.getAccountId()).getAccount());
        formatter.appendSubmittedAt(submit.getGranted());
        formatter.appendReviewedOn(canonicalWebUrl, commit.change.getId());
        formatter.appendProject(commit.change.getProject().get());
        formatter.appendBranch(commit.change.getDest());
        return inserter.insert(Constants.OBJ_BLOB, formatter.toString().getBytes("UTF-8"));
    } catch (OrmException e) {
        throw new CodeReviewNoteCreationException(commit, e);
    }
}
#end_block

#method_before
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    ObjectInserter inserter = db.newObjectInserter();
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    return revWalk.parseCommit(inserter.insert(b));
}
#method_after
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws IOException {
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    ObjectId commitId = inserter.insert(b);
    inserter.flush();
    return revWalk.parseCommit(commitId);
}
#end_block

#method_before
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_SUBMITTED);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#method_after
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_REVIEW);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = new CreateCodeReviewNotes(schema, db, myIdent);
    codeReviewNotes.create(merged, computeAuthor(merged));
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), CreateCodeReviewNotes.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false, false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#method_after
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public void appendChangeId(Change.Id changeId) {
    sb.append("Change-Id: ").append(changeId).append("\n");
}
#method_after
void appendChangeId(Change.Key changeKey) {
    sb.append("Change-Id: ").append(changeKey.get()).append("\n");
}
#end_block

#method_before
public void appendApproval(ApprovalCategory category, short value, Account user) {
    sb.append(category.getName());
    sb.append(value < 0 ? "-" : "+").append(value).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendApproval(ApprovalCategory category, short value, Account user) {
    // TODO: use category.getLabel() when available
    sb.append(category.getName().replace(' ', '-'));
    sb.append(value < 0 ? "-" : "+").append(Math.abs(value)).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
private void appendUserData(Account user) {
    sb.append(user.getFullName()).append(" <").append(user.getPreferredEmail()).append(">");
}
#method_after
private void appendUserData(Account user) {
    boolean needSpace = false;
    boolean wroteData = false;
    if (user.getFullName() != null && !user.getFullName().isEmpty()) {
        sb.append(user.getFullName());
        needSpace = true;
        wroteData = true;
    }
    if (user.getPreferredEmail() != null && !user.getPreferredEmail().isEmpty()) {
        if (needSpace) {
            sb.append(" ");
        }
        sb.append("<").append(user.getPreferredEmail()).append(">");
        wroteData = true;
    }
    if (!wroteData) {
        sb.append("Anonymous Coward #").append(user.getId());
    }
}
#end_block

#method_before
public void appendBranch(Project project, Branch.NameKey branch) {
    sb.append("Branch: ").append(project.getName()).append(" ").append(branch.get()).append("\n");
}
#method_after
void appendBranch(Branch.NameKey branch) {
    sb.append("Branch: ").append(branch.get()).append("\n");
}
#end_block

#method_before
public void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && cmd.getRefName().startsWith(NEW_CHANGE)) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            members.setEnabled(result.canModify);
            saveType.setVisible(result.canModify);
            display(result);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initGroupNotifications();
    Label spacer = new Label("");
    spacer.setHeight("15px");
    add(spacer);
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initExternal();
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    onlyAuthors.setValue(group.isEmailOnlyAuthors());
    onlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    visibleToAllCheckBox.setEnabled(true);
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    emailOnlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            members.setEnabled(result.canModify);
            saveType.setVisible(result.canModify);
            display(result);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initMemberList();
    initIncludedGroupList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initIncludeList();
    initExternal();
}
#end_block

#method_before
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includedGroupPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#method_after
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includePanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includedGroups.display(result.includedGroups);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includes.display(result.includes);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
public IdentifiedUser create(Provider<ReviewDb> db, Account.Id id) {
    return new IdentifiedUser(AccessPath.UNKNOWN, authConfig, canonicalUrl, realm, accountCache, null, db, id);
}
#method_after
public IdentifiedUser create(Provider<ReviewDb> db, Account.Id id) {
    return new IdentifiedUser(AccessPath.UNKNOWN, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, null, db, id);
}
#end_block

#method_before
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, null, id);
}
#method_after
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, remotePeerProvider, null, id);
}
#end_block

#method_before
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, dbProvider, id);
}
#method_after
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, remotePeerProvider, dbProvider, id);
}
#end_block

#method_before
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        Set<AccountGroup.Id> seedGroups = new HashSet<AccountGroup.Id>();
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            seedGroups = realm.groups(state());
        } else {
            seedGroups = authConfig.getRegisteredGroups();
        }
        effectiveGroups = getIncludedGroups(seedGroups);
    }
    return effectiveGroups;
}
#method_after
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        Set<AccountGroup.Id> seedGroups;
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            seedGroups = realm.groups(state());
        } else {
            seedGroups = authConfig.getRegisteredGroups();
        }
        effectiveGroups = getIncludedGroups(seedGroups);
    }
    return effectiveGroups;
}
#end_block

#method_before
private Set<AccountGroup.Id> getIncludedGroups(Set<AccountGroup.Id> seedGroups) {
    Set<AccountGroup.Id> includedGroups = new HashSet<AccountGroup.Id>(seedGroups);
    Queue<AccountGroup.Id> groupQueue = new LinkedList<AccountGroup.Id>(seedGroups);
    while (groupQueue.size() > 0) {
        AccountGroup.Id id = groupQueue.remove();
        try {
            for (final AccountGroupIncludedGroup i : dbProvider.get().accountGroupIncludedGroups().byIncludedGroup(id)) {
                AccountGroup.Id groupId = i.getGroupId();
                if (!includedGroups.contains(groupId)) {
                    includedGroups.add(groupId);
                    groupQueue.add(groupId);
                }
            }
        } catch (OrmException e) {
            log.warn("Cannot query included groups", e);
        }
    }
    return includedGroups;
}
#method_after
private Set<AccountGroup.Id> getIncludedGroups(Set<AccountGroup.Id> seedGroups) {
    Set<AccountGroup.Id> includes = new HashSet<AccountGroup.Id>(seedGroups);
    Queue<AccountGroup.Id> groupQueue = new LinkedList<AccountGroup.Id>(seedGroups);
    while (groupQueue.size() > 0) {
        AccountGroup.Id id = groupQueue.remove();
        for (final AccountGroup.Id groupId : groupIncludeCache.getByInclude(id)) {
            if (includes.add(groupId)) {
                groupQueue.add(groupId);
            }
        }
    }
    return Collections.unmodifiableSet(includes);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public boolean isVisible() {
    return isOwner();
}
#method_after
public boolean isVisible() {
    return group.isVisibleToAll() || isOwner();
}
#end_block

#method_before
public boolean canSeeMember(Account.Id id) {
    return isOwner();
}
#method_after
public boolean canSeeMember(Account.Id id) {
    return isVisible();
}
#end_block

#method_before
private void createGroup() throws OrmException, UnloggedFailure {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    try {
        performCreateGroup.createGroup(groupName, groupDescription, ownerGroupId, initialMembers.toArray(new Account.Id[initialMembers.size()]), initialIncludedGroups.toArray(new AccountGroup.Id[initialIncludedGroups.size()]));
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#method_after
private void createGroup() throws OrmException, UnloggedFailure {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    try {
        performCreateGroup.createGroup(groupName, groupDescription, visibleToAll, ownerGroupId, initialMembers, initialGroups);
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Override
public AccountGroup.Id call() throws OrmException, NameAlreadyUsedException {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    final Account.Id me = user.getAccountId();
    return performCreateGroup.createGroup(groupName, null, null, new Account.Id[] { me }, null);
}
#method_after
@Override
public AccountGroup.Id call() throws OrmException, NameAlreadyUsedException {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    final Account.Id me = user.getAccountId();
    return performCreateGroup.createGroup(groupName, null, false, null, Collections.singleton(me), null);
}
#end_block

#method_before
private AccountGroup findGroup(final String name) throws OrmException, Failure {
    final AccountGroup g = groupCache.get(new AccountGroup.NameKey(name));
    if (g == null) {
        throw new Failure(new NoSuchEntityException());
    }
    return g;
}
#method_after
private AccountGroup findGroup(final String name) throws OrmException, Failure {
    final AccountGroup g = groupCache.get(new AccountGroup.NameKey(name));
    if (g == null) {
        throw new Failure(new NoSuchGroupException(name));
    }
    return g;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = control.getAccountGroup();
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludedGroups(loadIncludedGroups());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setGroups(gic.create());
    return detail;
}
#method_after
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = control.getAccountGroup();
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#end_block

#method_before
public AccountGroup.Id createGroup(final String groupName, final String groupDescription, final AccountGroup.Id ownerGroupId, final Account.Id[] initialMembers, final AccountGroup.Id[] initialIncludedGroups) throws OrmException, NameAlreadyUsedException {
    final AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    final AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    final AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    final AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new NameAlreadyUsedException();
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers(groupId, initialMembers);
    if (initialIncludedGroups != null) {
        addIncludedGroups(groupId, initialIncludedGroups);
    }
    return groupId;
}
#method_after
public AccountGroup.Id createGroup(final String groupName, final String groupDescription, final boolean visibleToAll, final AccountGroup.Id ownerGroupId, final Collection<? extends Account.Id> initialMembers, final Collection<? extends AccountGroup.Id> initialGroups) throws OrmException, NameAlreadyUsedException {
    final AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    final AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    final AccountGroup group = new AccountGroup(nameKey, groupId);
    group.setVisibleToAll(visibleToAll);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    final AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new NameAlreadyUsedException();
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers(groupId, initialMembers);
    if (initialGroups != null) {
        addGroups(groupId, initialGroups);
    }
    return groupId;
}
#end_block

#method_before
private void addMembers(final AccountGroup.Id groupId, final Account.Id[] members) throws OrmException {
    final List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    final List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        final AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#method_after
private void addMembers(final AccountGroup.Id groupId, final Collection<? extends Account.Id> members) throws OrmException {
    final List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    final List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        final AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#end_block

#method_before
private void displayApprovals(final int row, final ApprovalSummary summary, final AccountInfoCache aic, final boolean highlightUnreviewed) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> approvals = summary.getApprovalMap();
    int col = BASE_COLUMNS;
    boolean haveReview = false;
    for (final ApprovalType type : approvalTypes) {
        final PatchSetApproval ca = approvals.get(type.getCategory().getId());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
        } else {
            haveReview = true;
            final ApprovalCategoryValue acv = type.getValue(ca);
            final AccountInfo ai = aic.get(ca.getAccountId());
            if (type.isMaxNegative(ca)) {
                table.setHTML(row, col, new Image(Gerrit.RESOURCES.redNot()).getElement().getString() + FormatUtil.name(ai));
            } else if (type.isMaxPositive(ca)) {
                table.setHTML(row, col, new Image(Gerrit.RESOURCES.greenCheck()).getElement().getString() + FormatUtil.name(ai));
            } else {
                String vstr = String.valueOf(ca.getValue()) + " " + FormatUtil.name(ai);
                if (ca.getValue() > 0) {
                    vstr = "+" + vstr;
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
                } else {
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                }
                table.setText(row, col, vstr);
            }
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            // 
            fmt.getElement(row, col).setTitle(acv.getName() + " \nby " + FormatUtil.nameEmail(ai));
        }
        col++;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), !haveReview && highlightUnreviewed);
}
#method_after
private void displayApprovals(final int row, final ApprovalSummary summary, final AccountInfoCache aic, final boolean highlightUnreviewed) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> approvals = summary.getApprovalMap();
    int col = BASE_COLUMNS;
    boolean haveReview = false;
    boolean displayPersonNameInReviewCategory = false;
    if (Gerrit.isSignedIn()) {
        AccountGeneralPreferences prefs = Gerrit.getUserAccount().getGeneralPreferences();
        if (prefs.isDisplayPersonNameInReviewCategory()) {
            displayPersonNameInReviewCategory = true;
        }
    }
    for (final ApprovalType type : approvalTypes) {
        final PatchSetApproval ca = approvals.get(type.getCategory().getId());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
        } else {
            haveReview = true;
            final ApprovalCategoryValue acv = type.getValue(ca);
            final AccountInfo ai = aic.get(ca.getAccountId());
            if (type.isMaxNegative(ca)) {
                if (displayPersonNameInReviewCategory) {
                    FlowPanel fp = new FlowPanel();
                    fp.add(new Image(Gerrit.RESOURCES.redNot()));
                    fp.add(new InlineLabel(FormatUtil.name(ai)));
                    table.setWidget(row, col, fp);
                } else {
                    table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
                }
            } else if (type.isMaxPositive(ca)) {
                if (displayPersonNameInReviewCategory) {
                    FlowPanel fp = new FlowPanel();
                    fp.add(new Image(Gerrit.RESOURCES.greenCheck()));
                    fp.add(new InlineLabel(FormatUtil.name(ai)));
                    table.setWidget(row, col, fp);
                } else {
                    table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
                }
            } else {
                String vstr = String.valueOf(ca.getValue());
                if (displayPersonNameInReviewCategory) {
                    vstr = vstr + " " + FormatUtil.name(ai);
                }
                if (ca.getValue() > 0) {
                    vstr = "+" + vstr;
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
                } else {
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                }
                table.setText(row, col, vstr);
            }
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            // 
            fmt.getElement(row, col).setTitle(acv.getName() + " \nby " + FormatUtil.nameEmail(ai));
        }
        col++;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), !haveReview && highlightUnreviewed);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> project(String name) throws OrmException {
    // "name" as substring.
    try {
        final ProjectControl projectControl = args.projectControlFactory.controlFor(new Project.NameKey(name));
    } catch (NoSuchProjectException e) {
        final List<ProjectPredicate> predicate = new ArrayList<ProjectPredicate>();
        for (final Project p : args.dbProvider.get().projects().all()) {
            if (p.getName().toLowerCase().contains(name.toLowerCase())) {
                predicate.add(new ProjectPredicate(args.dbProvider, p.getName()));
            }
        }
        // only one contains that, return only that one predicate by itself.
        if (predicate.size() == 1) {
            return predicate.get(0);
        } else if (predicate.size() > 1) {
            return Predicate.or(predicate);
        }
    }
    return new ProjectPredicate(args.dbProvider, name);
}
#method_after
@Operator
public Predicate<ChangeData> project(String name) {
    if (name.startsWith("^"))
        return new RegexProjectPredicate(args.dbProvider, name);
    return new ProjectPredicate(args.dbProvider, name);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    } else if (PAT_COMMIT.matcher(query).matches()) {
        return commit(query);
    } else if (PAT_EMAIL.matcher(query).find()) {
        try {
            return Predicate.or(owner(query), reviewer(query));
        } catch (OrmException err) {
            throw error("Cannot lookup user", err);
        }
    } else if (PAT_LABEL.matcher(query).find()) {
        return label(query);
    } else {
        throw error("Unsupported query:" + query);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    } else if (PAT_COMMIT.matcher(query).matches()) {
        return commit(query);
    } else if (PAT_EMAIL.matcher(query).find()) {
        try {
            return Predicate.or(owner(query), reviewer(query));
        } catch (OrmException err) {
            throw error("Cannot lookup user", err);
        }
    } else if (PAT_LABEL.matcher(query).find()) {
        return label(query);
    } else {
        // Try to match a project name by substring query.
        final List<ProjectPredicate> predicate = new ArrayList<ProjectPredicate>();
        try {
            for (final Project p : args.dbProvider.get().projects().all()) {
                if (p.getName().toLowerCase().contains(query.toLowerCase())) {
                    predicate.add(new ProjectPredicate(args.dbProvider, p.getName()));
                }
            }
            // only one contains that, return only that one predicate by itself.
            if (predicate.size() == 1) {
                return predicate.get(0);
            } else if (predicate.size() > 1) {
                return Predicate.or(predicate);
            }
        } catch (OrmException e) {
            throw error("Cannot lookup project.", e);
        }
        throw error("Unsupported query:" + query);
    }
}
#end_block

#method_before
Configuration toConfiguration() {
    configureDiskStore();
    configureDefaultCache();
    for (CacheProvider<?, ?> p : caches.values()) {
        final String name = p.getName();
        final CacheConfiguration c = newCache(name);
        c.setMemoryStoreEvictionPolicyFromObject(toPolicy(p.evictionPolicy()));
        c.setMaxElementsInMemory(getInt(name, "memorylimit", p.memoryLimit()));
        c.setTimeToIdleSeconds(0);
        c.setTimeToLiveSeconds(getSeconds(name, "maxage", p.maxAge()));
        c.setEternal(c.getTimeToLiveSeconds() == 0);
        if (p.disk() && mgr.getDiskStoreConfiguration() != null) {
            c.setMaxElementsOnDisk(getInt(name, "disklimit", p.diskLimit()));
            int v = c.getDiskSpoolBufferSizeMB() * MB;
            v = getInt(name, "diskbuffer", v) / MB;
            c.setDiskSpoolBufferSizeMB(Math.max(1, v));
            c.setOverflowToDisk(c.getMaxElementsOnDisk() > 0);
            c.setDiskPersistent(c.getMaxElementsOnDisk() > 0);
        }
        mgr.addCache(c);
    }
    return mgr;
}
#method_after
Configuration toConfiguration() {
    configureDiskStore();
    configureDefaultCache();
    for (CacheProvider<?, ?> p : caches.values()) {
        final String name = p.getName();
        final CacheConfiguration c = newCache(name);
        c.setMemoryStoreEvictionPolicyFromObject(toPolicy(p.evictionPolicy()));
        c.setMaxElementsInMemory(getInt(name, "memorylimit", p.memoryLimit()));
        long ttl = getSeconds(name, "maxage", p.maxAge());
        c.setEternal(ttl == 0);
        if (ttl != 0) {
            c.setTimeToIdleSeconds(0);
            c.setTimeToLiveSeconds(ttl);
        }
        if (p.disk() && mgr.getDiskStoreConfiguration() != null) {
            c.setMaxElementsOnDisk(getInt(name, "disklimit", p.diskLimit()));
            int v = c.getDiskSpoolBufferSizeMB() * MB;
            v = getInt(name, "diskbuffer", v) / MB;
            c.setDiskSpoolBufferSizeMB(Math.max(1, v));
            c.setOverflowToDisk(c.getMaxElementsOnDisk() > 0);
            c.setDiskPersistent(c.getMaxElementsOnDisk() > 0);
        }
        mgr.addCache(c);
    }
    return mgr;
}
#end_block

#method_before
private void configureDefaultCache() {
    final CacheConfiguration c = new CacheConfiguration();
    c.setMaxElementsInMemory(1024);
    c.setMemoryStoreEvictionPolicyFromObject(MemoryStoreEvictionPolicy.LFU);
    c.setTimeToIdleSeconds(0);
    c.setTimeToLiveSeconds(0);
    c.setEternal(true);
    if (mgr.getDiskStoreConfiguration() != null) {
        c.setMaxElementsOnDisk(16384);
        c.setOverflowToDisk(false);
        c.setDiskPersistent(false);
        c.setDiskSpoolBufferSizeMB(5);
        c.setDiskExpiryThreadIntervalSeconds(60 * 60);
    }
    mgr.setDefaultCacheConfiguration(c);
}
#method_after
private void configureDefaultCache() {
    final CacheConfiguration c = new CacheConfiguration();
    c.setMaxElementsInMemory(1024);
    c.setMemoryStoreEvictionPolicyFromObject(MemoryStoreEvictionPolicy.LFU);
    c.setEternal(true);
    if (mgr.getDiskStoreConfiguration() != null) {
        c.setMaxElementsOnDisk(16384);
        c.setOverflowToDisk(false);
        c.setDiskPersistent(false);
        c.setDiskSpoolBufferSizeMB(5);
        c.setDiskExpiryThreadIntervalSeconds(60 * 60);
    }
    mgr.setDefaultCacheConfiguration(c);
}
#end_block

#method_before
private List<ReplicationConfig> allConfigs(final SitePaths site) throws ConfigInvalidException, IOException {
    final FileBasedConfig cfg = new FileBasedConfig(site.replication_config, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfg.getFile() + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        // In case if refspec destination for push is not set then we assume it is equal to source
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg, database, replicationUserFactory));
    }
    return Collections.unmodifiableList(r);
}
#method_after
private List<ReplicationConfig> allConfigs(final SitePaths site) throws ConfigInvalidException, IOException {
    final FileBasedConfig cfg = new FileBasedConfig(site.replication_config, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfg.getFile() + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        // equal to source
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg, database, replicationUserFactory));
    }
    return Collections.unmodifiableList(r);
}
#end_block

#method_before
@Override
public void replicateNewProject(Project.NameKey projectName, String head) {
    if (!isEnabled()) {
        return;
    }
    for (ReplicationConfig config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String adminUrl = config.getAdminUrl();
        URIish adminURI = null;
        try {
            if (adminUrl != null && !adminUrl.isEmpty()) {
                adminURI = new URIish(adminUrl);
            }
        } catch (URISyntaxException e) {
        // syntax error
        // 
        }
        boolean adminURLUsed = false;
        if (adminURI != null) {
            final String replacedPath = replace(adminURI.getPath(), "name", projectName.get());
            if (replacedPath != null) {
                adminURI = adminURI.setPath(replacedPath);
                if (usingSSH(adminURI)) {
                    replicateProject(adminURI, head);
                    adminURLUsed = true;
                }
            }
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                replicateProject(uri, head);
            }
        }
    }
}
#method_after
@Override
public void replicateNewProject(Project.NameKey projectName, String head) {
    if (!isEnabled()) {
        return;
    }
    for (ReplicationConfig config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            URIish adminURI = null;
            try {
                if (url != null && !url.isEmpty()) {
                    adminURI = new URIish(url);
                }
            } catch (URISyntaxException e) {
                log.error("The URL '" + url + "' is invalid");
            }
            if (adminURI != null) {
                final String replacedPath = replace(adminURI.getPath(), "name", projectName.get());
                if (replacedPath != null) {
                    adminURI = adminURI.setPath(replacedPath);
                    if (usingSSH(adminURI)) {
                        replicateProject(adminURI, head);
                        adminURLUsed = true;
                    } else {
                        log.error("The adminURL '" + url + "' is non-SSH which is not allowed");
                    }
                }
            }
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                replicateProject(uri, head);
            }
        }
    }
}
#end_block

#method_before
void notifyStarting(final PushOp op) {
    synchronized (pending) {
        pending.remove(op.getURI());
    }
}
#method_after
void notifyStarting(final PushOp op) {
    synchronized (pending) {
        if (!op.wasCanceled()) {
            pending.remove(op.getURI());
        }
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    {
        nameBox = new NpTextBox();
        nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
        nameBox.setVisibleLength(50);
        nameBox.setText(Util.C.defaultProjectName());
        nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        nameBox.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultProjectName().equals(nameBox.getText())) {
                    nameBox.setText("");
                    nameBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(nameBox.getText())) {
                    nameBox.setText(Util.C.defaultProjectName());
                    nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                submitOnSelection = false;
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    if (nameTxt.isSuggestionListShowing()) {
                        submitOnSelection = true;
                    } else {
                        doAddNew();
                    }
                }
            }
        });
        nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

            @Override
            public void onSelection(SelectionEvent<Suggestion> event) {
                if (submitOnSelection) {
                    submitOnSelection = false;
                    doAddNew();
                }
            }
        });
        filterTxt = new NpTextBox();
        filterTxt.setVisibleLength(50);
        filterTxt.setText(Util.C.defaultFilter());
        filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        filterTxt.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultFilter().equals(filterTxt.getText())) {
                    filterTxt.setText("");
                    filterTxt.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(filterTxt.getText())) {
                    filterTxt.setText(Util.C.defaultFilter());
                    filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    doAddNew();
                }
            }
        });
        projects = new ProjectTable();
        addNew = new Button(Util.C.buttonWatchProject());
        addNew.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                doAddNew();
            }
        });
        final Grid grid = new Grid(2, 2);
        grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
        grid.setText(0, 0, Util.C.watchedProjectName());
        grid.setWidget(0, 1, nameTxt);
        grid.setText(1, 0, Util.C.watchedProjectFilter());
        grid.setWidget(1, 1, filterTxt);
        final CellFormatter fmt = grid.getCellFormatter();
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
        DisclosurePanel unwatched = new DisclosurePanel(Util.C.unwatchedProjects());
        unwatched.setContent(projects);
        final Grid grid2 = new Grid(1, 2);
        final FlowPanel fp2 = new FlowPanel();
        fp2.add(addNew);
        grid2.setWidget(0, 0, fp2);
        grid2.setWidget(0, 1, unwatched);
        final CellFormatter fmt2 = grid2.getCellFormatter();
        fmt2.setAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT, HasVerticalAlignment.ALIGN_TOP);
        final FlowPanel fp = new FlowPanel();
        fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
        fp.add(grid);
        fp.add(grid2);
        add(fp);
    }
    watches = new WatchTable();
    add(watches);
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watches.deleteChecked();
        }
    });
    add(delSel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            if (top + offsetHeight > Window.getClientHeight()) {
                top = Window.getClientHeight() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.ACCOUNT_SVC.myProjectWatch(new ScreenLoadCallback<List<AccountProjectWatchInfo>>(this) {

        public void preDisplay(final List<AccountProjectWatchInfo> result) {
            watchedProjects = result;
            watches.display(result);
            displayUnwatchedProjects();
        }
    });
    Util.PROJECT_SVC.visibleProjects(new ScreenLoadCallback<List<Project>>(this) {

        @Override
        protected void preDisplay(final List<Project> result) {
            allProjects = new ArrayList(result);
            // unneeded fake "--all projects--" entry
            allProjects.remove(0);
            displayUnwatchedProjects();
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    populateWatches();
}
#end_block

#method_before
void doAddNew() {
    final String projectName = nameTxt.getText();
    if (projectName == null || projectName.length() == 0 || Util.C.defaultProjectName().equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watches.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
protected void doAddNew() {
    final String projectName = nameTxt.getText();
    if ("".equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watchesTab.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    for (index--; index > -1; index--) {
        InlineHyperlink link = createLink(index, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    for (index--; index > -1; index--) {
        InlineHyperlink link = createLink(index, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
        if (link != null) {
            return link;
        }
    }
    return null;
}
#end_block

#method_before
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    if ((isSkipDeleted() && patch.getChangeType().equals(ChangeType.DELETED)) || (isSkipUncommented() && patch.getCommentCount() == 0)) {
        return null;
    }
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    if ((listenablePrefs.get().isSkipDeleted() && patch.getChangeType().equals(ChangeType.DELETED)) || (listenablePrefs.get().isSkipUncommented() && patch.getCommentCount() == 0)) {
        return null;
    }
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
private static String getFileNameOnly(Patch patch) {
    // Note: use '/' here and not File.pathSeparator since git paths
    // are always separated by /
    // 
    String fileName = patch.getFileName();
    int s = fileName.lastIndexOf('/');
    if (s >= 0) {
        fileName = fileName.substring(s + 1);
    }
    return fileName;
}
#method_after
private static String getFileNameOnly(Patch patch) {
    // Note: use '/' here and not File.pathSeparator since git paths
    // are always separated by /
    // 
    String fileName = getDisplayFileName(patch);
    int s = fileName.lastIndexOf('/');
    if (s >= 0) {
        fileName = fileName.substring(s + 1);
    }
    return fileName;
}
#end_block

#method_before
void initializeRow(int row) {
    Patch patch = PatchTable.this.patchList.get(row - 1);
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), patch.getKey(), row - 1, detail, PatchTable.this);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), patch.getKey(), row - 1, detail, PatchTable.this);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName(Gerrit.RESOURCES.css().sourceFilePath());
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), patch.getKey(), row - 1, detail, PatchTable.this));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), patch.getKey(), row - 1, detail, PatchTable.this));
}
#method_after
void initializeRow(int row) {
    Patch patch = PatchTable.this.patchList.get(row - 1);
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(getDisplayFileName(patch), patch.getKey(), row - 1, detail, PatchTable.this);
    } else {
        nameCol = new PatchLink.Unified(getDisplayFileName(patch), patch.getKey(), row - 1, detail, PatchTable.this);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName(Gerrit.RESOURCES.css().sourceFilePath());
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), patch.getKey(), row - 1, detail, PatchTable.this));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), patch.getKey(), row - 1, detail, PatchTable.this));
}
#end_block

#method_before
void appendHeader(final SafeHtmlBuilder m) {
    m.openTr();
    // Cursor
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconHeader());
    m.addStyleName(Gerrit.RESOURCES.css().leftMostCell());
    m.nbsp();
    m.closeTd();
    // Mode
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().iconHeader());
    m.nbsp();
    m.closeTd();
    // "File path"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnName());
    m.closeTd();
    // "Comments"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnComments());
    m.closeTd();
    // "Diff"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.setAttribute("colspan", 3);
    m.append(Util.C.patchTableColumnDiff());
    m.closeTd();
    // "Reviewed"
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(Gerrit.RESOURCES.css().iconHeader());
        m.addStyleName(Gerrit.RESOURCES.css().dataHeader());
        m.append(Util.C.reviewed());
        m.closeTd();
    }
    m.closeTr();
}
#method_after
void appendHeader(final SafeHtmlBuilder m) {
    m.openTr();
    // Cursor
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconHeader());
    m.addStyleName(Gerrit.RESOURCES.css().leftMostCell());
    m.nbsp();
    m.closeTd();
    // Mode
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().iconHeader());
    m.nbsp();
    m.closeTd();
    // "File path"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnName());
    m.closeTd();
    // "Comments"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnComments());
    m.closeTd();
    // "Size"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.append(Util.C.patchTableColumnSize());
    m.closeTd();
    // "Diff"
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().dataHeader());
    m.setAttribute("colspan", 3);
    m.append(Util.C.patchTableColumnDiff());
    m.closeTd();
    // "Reviewed"
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(Gerrit.RESOURCES.css().iconHeader());
        m.addStyleName(Gerrit.RESOURCES.css().dataHeader());
        m.append(Util.C.reviewed());
        m.closeTd();
    }
    m.closeTr();
}
#end_block

#method_before
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconCell());
    m.addStyleName(Gerrit.RESOURCES.css().leftMostCell());
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().changeTypeCell());
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().filePathCell());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().commentCell());
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    // Green check mark if the user is logged in and they reviewed that file
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(Gerrit.RESOURCES.css().dataCell());
        if (p.isReviewedByCurrentUser()) {
            m.openDiv();
            m.setStyleName(Gerrit.RESOURCES.css().greenCheckClass());
            m.closeSelf();
        }
        m.closeTd();
    }
    m.closeTr();
}
#method_after
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().iconCell());
    m.addStyleName(Gerrit.RESOURCES.css().leftMostCell());
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().changeTypeCell());
    if (Patch.COMMIT_MSG.equals(p.getFileName())) {
        m.nbsp();
    } else {
        m.append(p.getChangeType().getCode());
    }
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().filePathCell());
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().commentCell());
    appendCommentCount(m, p);
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().dataCell());
    m.addStyleName(Gerrit.RESOURCES.css().patchSizeCell());
    appendSize(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    // Green check mark if the user is logged in and they reviewed that file
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(Gerrit.RESOURCES.css().dataCell());
        if (p.isReviewedByCurrentUser()) {
            m.openDiv();
            m.setStyleName(Gerrit.RESOURCES.css().greenCheckClass());
            m.closeSelf();
        }
        m.closeTd();
    }
    m.closeTr();
}
#end_block

#method_before
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#method_after
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
                table.appendRow(nc, list.get(row++));
            }
            while (row < list.size()) {
                Patch p = list.get(row);
                insertions += p.getInsertions();
                deletions += p.getDeletions();
                table.appendRow(nc, p);
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.appendTotals(nc, insertions, deletions);
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    VerticalPanel vp = new VerticalPanel();
    vp.add(historyPanel);
    vp.add(settingsPanel);
    commitMessageBlock = new CommitMessageBlock("6em");
    HorizontalPanel hp = new HorizontalPanel();
    hp.setWidth("100%");
    hp.add(vp);
    hp.add(commitMessageBlock);
    add(hp);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey().getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey().getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        fileList.setSkipDeleted(settingsPanel.skipDeleted.getValue());
        fileList.setSkipUncommented(settingsPanel.skipUncommented.getValue());
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id ck = patchKey.getParentKey().getParentKey();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(ck, 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    VerticalPanel vp = new VerticalPanel();
    vp.add(historyPanel);
    vp.add(settingsPanel);
    commitMessageBlock = new CommitMessageBlock("6em");
    HorizontalPanel hp = new HorizontalPanel();
    hp.setWidth("100%");
    hp.add(vp);
    hp.add(commitMessageBlock);
    add(hp);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey().getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey().getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable();
                    fileList.setSkipDeleted(settingsPanel.skipDeleted.getValue());
                    fileList.setSkipUncommented(settingsPanel.skipUncommented.getValue());
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    contentTable.setRegisterKeys(contentTable.isVisible());
    regNavigation = GlobalKey.add(this, keysNavigation);
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    contentTable.setRegisterKeys(contentTable.isVisible());
    if (regNavigation != null) {
        regNavigation.removeHandler();
        regNavigation = null;
    }
    regNavigation = GlobalKey.add(this, keysNavigation);
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path + "(" + ++mtn + ")"));
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    fileList.setSkipDeleted(settingsPanel.skipDeleted.getValue());
    fileList.setSkipUncommented(settingsPanel.skipUncommented.getValue());
    topNav.display(patchIndex, getPatchScreenType(), fileList);
    bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path));
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    registerKeys();
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable();
        fileList.setSkipDeleted(settingsPanel.skipDeleted.getValue());
        fileList.setSkipUncommented(settingsPanel.skipUncommented.getValue());
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(value.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#end_block

#method_before
public void setEnableIntralineDifference(final boolean on) {
    enableIntralineDifference = on;
    if (enableIntralineDifference) {
        intralineDifference.setValue(value.isIntralineDifference());
    } else {
        intralineDifference.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#method_after
public void setEnableIntralineDifference(final boolean on) {
    enableIntralineDifference = on;
    if (enableIntralineDifference) {
        intralineDifference.setValue(getValue().isIntralineDifference());
    } else {
        intralineDifference.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#end_block

#method_before
public AccountDiffPreference getValue() {
    return value;
}
#method_after
public AccountDiffPreference getValue() {
    return listenablePrefs.get();
}
#end_block

#method_before
public void setValue(final AccountDiffPreference dp) {
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    showTabs.setValue(dp.isShowTabs());
    value = dp;
}
#method_after
public void setValue(final AccountDiffPreference dp) {
    listenablePrefs.set(dp);
    display();
}
#end_block

#method_before
private void update() {
    AccountDiffPreference dp = new AccountDiffPreference(value);
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    value = dp;
    fireEvent(new ValueChangeEvent<AccountDiffPreference>(dp) {
    });
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#method_after
private void update() {
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    listenablePrefs.set(dp);
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#end_block

#method_before
private void persistDiffPreferences() {
    setEnabled(false);
    Util.ACCOUNT_SVC.changeDiffPreferences(value, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            Gerrit.setAccountDiffPreference(value);
            setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            setEnabled(true);
        }
    });
}
#method_after
private void persistDiffPreferences() {
    setEnabled(false);
    Util.ACCOUNT_SVC.changeDiffPreferences(getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            Gerrit.setAccountDiffPreference(getValue());
            setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            setEnabled(true);
        }
    });
}
#end_block

#method_before
private Whitespace getIgnoreWhitespace() {
    final int sel = ignoreWhitespace.getSelectedIndex();
    if (0 <= sel) {
        return Whitespace.valueOf(ignoreWhitespace.getValue(sel));
    }
    return value.getIgnoreWhitespace();
}
#method_after
private Whitespace getIgnoreWhitespace() {
    final int sel = ignoreWhitespace.getSelectedIndex();
    if (0 <= sel) {
        return Whitespace.valueOf(ignoreWhitespace.getValue(sel));
    }
    return getValue().getIgnoreWhitespace();
}
#end_block

#method_before
private short getContext() {
    final int sel = context.getSelectedIndex();
    if (0 <= sel) {
        return Short.parseShort(context.getValue(sel));
    }
    return (short) value.getContext();
}
#method_after
private short getContext() {
    final int sel = context.getSelectedIndex();
    if (0 <= sel) {
        return Short.parseShort(context.getValue(sel));
    }
    return (short) getValue().getContext();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initSubmitType();
    initAgreements();
    add(saveProject);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initProjectOptions();
    initAgreements();
    add(saveProject);
}
#end_block

#method_before
private void enableForm(final boolean canModifyAgreements, final boolean canModifyDescription, final boolean canModifyMergeType) {
    submitType.setEnabled(canModifyMergeType);
    descTxt.setEnabled(canModifyDescription);
    useContributorAgreements.setEnabled(canModifyAgreements);
    useSignedOffBy.setEnabled(canModifyAgreements);
    saveProject.setEnabled(canModifyAgreements || canModifyDescription || canModifyMergeType);
}
#method_after
private void enableForm(final boolean canModifyAgreements, final boolean canModifyDescription, final boolean canModifyMergeType) {
    submitType.setEnabled(canModifyMergeType);
    descTxt.setEnabled(canModifyDescription);
    useContributorAgreements.setEnabled(canModifyAgreements);
    useSignedOffBy.setEnabled(canModifyAgreements);
    requireChangeID.setEnabled(canModifyMergeType);
    saveProject.setEnabled(canModifyAgreements || canModifyDescription || canModifyMergeType);
}
#end_block

#method_before
private void initDescription() {
    final VerticalPanel vp = new VerticalPanel();
    vp.add(new SmallHeading(Util.C.headingDescription()));
    descTxt = new NpTextArea();
    descTxt.setVisibleLines(6);
    descTxt.setCharacterWidth(60);
    vp.add(descTxt);
    add(vp);
    saveEnabler = new OnEditEnabler(saveProject, descTxt);
}
#method_after
private void initDescription() {
    final VerticalPanel vp = new VerticalPanel();
    vp.add(new SmallHeading(Util.C.headingDescription()));
    descTxt = new NpTextArea();
    descTxt.setVisibleLines(6);
    descTxt.setCharacterWidth(60);
    vp.add(descTxt);
    add(vp);
    saveEnabler = new OnEditEnabler(saveProject);
    saveEnabler.listenTo(descTxt);
}
#end_block

#method_before
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    submitTypePanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    setSubmitType(project.getSubmitType());
    saveProject.setEnabled(false);
}
#method_after
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    projectOptionsPanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    requireChangeID.setValue(project.isRequireChangeID());
    setSubmitType(project.getSubmitType());
    saveProject.setEnabled(false);
}
#end_block

#method_before
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false, false, false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            display(result);
        }
    });
}
#method_after
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    project.setRequireChangeID(requireChangeID.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false, false, false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            display(result);
        }
    });
}
#end_block

#method_before
// Register input widgets to be listened to
public void listenTo(final TextBoxBase tb) {
    strings.put(tb, tb.getText());
    tb.addKeyPressHandler(this);
    // Is there another way to capture middle button X11 pastes in browsers
    // which do not yet support ONPASTE events (Firefox)?
    tb.addMouseUpHandler(this);
    // Resetting the "original text" on focus ensures that we are
    // up to date with non-user updates of the text (calls to
    // setText()...) and also up to date with user changes which
    // occured after enabling "widget".
    tb.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            strings.put(tb, tb.getText());
        }
    });
    // CTRL-V Pastes in Chrome seem only detectable via BrowserEvents.
    // Since passed in widgets cannot be extended, go straight to the
    // Element itself and intercept all its events!
    tb.sinkEvents(Event.ONPASTE);
    Element el = tb.getElement();
    tbis.put(el, new TBBInfo(tb, Event.getEventListener(el)));
    Event.setEventListener(el, this);
}
#method_after
// Register input widgets to be listened to
public void listenTo(final TextBoxBase tb) {
    strings.put(tb, tb.getText());
    tb.addKeyPressHandler(this);
    // Is there another way to capture middle button X11 pastes in browsers
    // which do not yet support ONPASTE events (Firefox)?
    tb.addMouseUpHandler(this);
    // Resetting the "original text" on focus ensures that we are
    // up to date with non-user updates of the text (calls to
    // setText()...) and also up to date with user changes which
    // occured after enabling "widget".
    tb.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            strings.put(tb, tb.getText());
        }
    });
    // CTRL-V Pastes in Chrome seem only detectable via BrowserEvents or
    // KeyDownEvents, the latter is better.
    tb.addKeyDownHandler(this);
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent e) {
    on(e);
}
#method_after
// Handlers
@Override
public void onKeyPress(final KeyPressEvent e) {
    on(e);
}
#end_block

#method_before
// Handlers
@Override
public void onMouseUp(final MouseUpEvent e) {
    on(e);
}
#method_after
@Override
public void onMouseUp(final MouseUpEvent e) {
    on(e);
}
#end_block

#method_before
private void onTextBoxBase(final TextBoxBase tb) {
    // The text appears to not get updated until the handlers complete.
    DeferredCommand.add(new Command() {

        public void execute() {
            String orig = strings.get(tb);
            orig = orig == null ? "" : orig;
            if (!orig.equals(tb.getText())) {
                widget.setEnabled(true);
            }
        }
    });
}
#method_after
private void onTextBoxBase(final TextBoxBase tb) {
    // The text appears to not get updated until the handlers complete.
    DeferredCommand.add(new Command() {

        @Override
        public void execute() {
            String orig = strings.get(tb);
            if (orig == null) {
                orig = "";
            }
            if (!orig.equals(tb.getText())) {
                widget.setEnabled(true);
            }
        }
    });
}
#end_block

#method_before
private void initGroupType() {
    typeSystem = new Label(Util.C.groupType_SYSTEM());
    typeSelect = new ListBox();
    typeSelect.addItem(Util.C.groupType_INTERNAL(), AccountGroup.Type.INTERNAL.name());
    typeSelect.addItem(Util.C.groupType_LDAP(), AccountGroup.Type.LDAP.name());
    typeSelect.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            saveType.setEnabled(true);
        }
    });
    saveType = new Button(Util.C.buttonChangeGroupType());
    saveType.setEnabled(false);
    saveType.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            onSaveType();
        }
    });
    switch(Gerrit.getConfig().getAuthType()) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
            break;
        default:
            return;
    }
    final VerticalPanel fp = new VerticalPanel();
    fp.add(new SmallHeading(Util.C.headingGroupType()));
    fp.add(typeSystem);
    fp.add(typeSelect);
    fp.add(saveType);
    add(fp);
}
#method_after
private void initGroupType() {
    typeSystem = new Label(Util.C.groupType_SYSTEM());
    typeSelect = new ListBox();
    typeSelect.addItem(Util.C.groupType_INTERNAL(), AccountGroup.Type.INTERNAL.name());
    typeSelect.addItem(Util.C.groupType_LDAP(), AccountGroup.Type.LDAP.name());
    typeSelect.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            saveType.setEnabled(true);
        }
    });
    saveType = new Button(Util.C.buttonChangeGroupType());
    saveType.setEnabled(false);
    saveType.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            onSaveType();
        }
    });
    switch(Gerrit.getConfig().getAuthType()) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            break;
        default:
            return;
    }
    final VerticalPanel fp = new VerticalPanel();
    fp.add(new SmallHeading(Util.C.headingGroupType()));
    fp.add(typeSystem);
    fp.add(typeSelect);
    fp.add(saveType);
    add(fp);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addressTxt = new NpTextArea();
    addressTxt.setVisibleLines(4);
    addressTxt.setCharacterWidth(60);
    countryTxt = new NpTextBox();
    countryTxt.setVisibleLength(40);
    countryTxt.setMaxLength(40);
    phoneTxt = new NpTextBox();
    phoneTxt.setVisibleLength(30);
    phoneTxt.setMaxLength(30);
    faxTxt = new NpTextBox();
    faxTxt.setVisibleLength(30);
    faxTxt.setMaxLength(30);
    final Grid infoSecure = new Grid(4, 2);
    infoSecure.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoSecure.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    final HTML privhtml = new HTML(Util.C.contactPrivacyDetailsHtml());
    privhtml.setStyleName(Gerrit.RESOURCES.css().accountContactPrivacyDetails());
    hasContact = new Label();
    hasContact.setStyleName(Gerrit.RESOURCES.css().accountContactOnFile());
    hasContact.setVisible(false);
    if (Gerrit.getConfig().isUseContactInfo()) {
        body.add(privhtml);
        body.add(hasContact);
        body.add(infoSecure);
    }
    row(infoSecure, 0, Util.C.contactFieldAddress(), addressTxt);
    row(infoSecure, 1, Util.C.contactFieldCountry(), countryTxt);
    row(infoSecure, 2, Util.C.contactFieldPhone(), phoneTxt);
    row(infoSecure, 3, Util.C.contactFieldFax(), faxTxt);
    infoSecure.getCellFormatter().addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    infoSecure.getCellFormatter().addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    infoSecure.getCellFormatter().addStyleName(3, 0, Gerrit.RESOURCES.css().bottomheader());
    final OnEditEnabler sbl = new OnEditEnabler(save, addressTxt);
    sbl.listenTo(countryTxt);
    sbl.listenTo(phoneTxt);
    sbl.listenTo(faxTxt);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addressTxt = new NpTextArea();
    addressTxt.setVisibleLines(4);
    addressTxt.setCharacterWidth(60);
    countryTxt = new NpTextBox();
    countryTxt.setVisibleLength(40);
    countryTxt.setMaxLength(40);
    phoneTxt = new NpTextBox();
    phoneTxt.setVisibleLength(30);
    phoneTxt.setMaxLength(30);
    faxTxt = new NpTextBox();
    faxTxt.setVisibleLength(30);
    faxTxt.setMaxLength(30);
    final Grid infoSecure = new Grid(4, 2);
    infoSecure.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoSecure.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    final HTML privhtml = new HTML(Util.C.contactPrivacyDetailsHtml());
    privhtml.setStyleName(Gerrit.RESOURCES.css().accountContactPrivacyDetails());
    hasContact = new Label();
    hasContact.setStyleName(Gerrit.RESOURCES.css().accountContactOnFile());
    hasContact.setVisible(false);
    if (Gerrit.getConfig().isUseContactInfo()) {
        body.add(privhtml);
        body.add(hasContact);
        body.add(infoSecure);
    }
    row(infoSecure, 0, Util.C.contactFieldAddress(), addressTxt);
    row(infoSecure, 1, Util.C.contactFieldCountry(), countryTxt);
    row(infoSecure, 2, Util.C.contactFieldPhone(), phoneTxt);
    row(infoSecure, 3, Util.C.contactFieldFax(), faxTxt);
    infoSecure.getCellFormatter().addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    infoSecure.getCellFormatter().addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    infoSecure.getCellFormatter().addStyleName(3, 0, Gerrit.RESOURCES.css().bottomheader());
    final OnEditEnabler sbl = new OnEditEnabler(save);
    sbl.listenTo(addressTxt);
    sbl.listenTo(countryTxt);
    sbl.listenTo(phoneTxt);
    sbl.listenTo(faxTxt);
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(info.getKey(), detail.getPatches());
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#end_block

#method_before
private void displayDownload() {
    final Branch.NameKey branchKey = changeDetail.getChange().getDest();
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous()) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadUrl.HTTP, "HTTP", r.toString()));
    }
    if (Gerrit.getConfig().isUseRepoDownload()) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Branch.NameKey branchKey = changeDetail.getChange().getDest();
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && allowedSchemes.contains(DownloadScheme.ANON_GIT)) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new RestoreChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                SideBySide link = new PatchLink.SideBySide(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Unified link = new PatchLink.Unified(p.getFileName(), p.getKey(), 0, null);
                Window.open(link.getElement().toString(), p.getFileName(), null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchSideBySide(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchUnified(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new DashboardKeyCommand(0, 'u', Util.C.upToDashboard()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("98%");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("98%");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#end_block

#method_before
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    serveRegex("^/(.*?)/?$").with(new HttpServlet() {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            ProjectControl pc;
            try {
                pc = getProjectControl(req);
            } catch (ServiceNotEnabledException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            Project.NameKey dst = pc.getProject().getNameKey();
            StringBuilder r = new StringBuilder();
            r.append(urlProvider.get());
            r.append('#');
            r.append(PageLinks.toProject(dst, Change.Status.NEW));
            rsp.sendRedirect(r.toString());
        }
    });
}
#method_after
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    serveRegex("^/(.*?)/?$").with(new HttpServlet() {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            ProjectControl pc;
            try {
                pc = getProjectControl(req);
            } catch (ServiceNotEnabledException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            Project.NameKey dst = pc.getProject().getNameKey();
            StringBuilder r = new StringBuilder();
            r.append(urlProvider.get());
            r.append('#');
            r.append(PageLinks.toChangeQuery(PageLinks.projectQuery(dst, Change.Status.NEW)));
            rsp.sendRedirect(r.toString());
        }
    });
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    final ProjectControl pc = getProjectControl(req);
    final CurrentUser user = pc.getCurrentUser();
    final Set<AccountGroup.Id> uploadGroup = serverCommandConfig.getUploadGroup();
    if (uploadGroup != null && !uploadGroup.isEmpty()) {
        if (!CollectionsUtil.isAnyIncludedIn(user.getEffectiveGroups(), uploadGroup)) {
            throw new ServiceNotAuthorizedException();
        }
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get()));
    }
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get()));
    }
    return up;
}
#end_block

#method_before
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    final ProjectControl pc = getProjectControl(req);
    if (pc.getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
        final Set<AccountGroup.Id> receiveGroup = serverCommandConfig.getReceiveGroup();
        if (receiveGroup != null && !receiveGroup.isEmpty()) {
            if (!CollectionsUtil.isAnyIncludedIn(user.getEffectiveGroups(), receiveGroup)) {
                throw new ServiceNotAuthorizedException();
            }
        }
        final ReceiveCommits rc = factory.create(pc, db);
        final ReceiveCommits.Capable s = rc.canUpload();
        if (s != ReceiveCommits.Capable.OK) {
            // TODO We should alert the user to this message on the HTTP
            // response channel, assuming Git will even report it to them.
            // 
            final String who = user.getUserName();
            final String why = s.getMessage();
            log.warn("Rejected push from " + who + ": " + why);
            throw new ServiceNotEnabledException();
        }
        rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
        return rc.getReceivePack();
    } else {
        throw new ServiceNotAuthorizedException();
    }
}
#method_after
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    final ProjectControl pc = getProjectControl(req);
    if (!pc.canRunReceivePack()) {
        throw new ServiceNotAuthorizedException();
    }
    if (pc.getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
        final ReceiveCommits rc = factory.create(pc, db);
        final ReceiveCommits.Capable s = rc.canUpload();
        if (s != ReceiveCommits.Capable.OK) {
            // TODO We should alert the user to this message on the HTTP
            // response channel, assuming Git will even report it to them.
            // 
            final String who = user.getUserName();
            final String why = s.getMessage();
            log.warn("Rejected push from " + who + ": " + why);
            throw new ServiceNotEnabledException();
        }
        rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
        return rc.getReceivePack();
    } else {
        throw new ServiceNotAuthorizedException();
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    final Set<AccountGroup.Id> receiveGroup = getServerCommandConfig().getReceiveGroup();
    if (receiveGroup != null && !receiveGroup.isEmpty()) {
        if (!CollectionsUtil.isAnyIncludedIn(currentUser.getEffectiveGroups(), receiveGroup)) {
            throw new Failure(1, "User: " + currentUser.getUserName() + " not allowed to execute this command on this server");
        }
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    ReceiveCommits.Capable r = receive.canUpload();
    if (r != ReceiveCommits.Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    try {
        rp.receive(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    ReceiveCommits.Capable r = receive.canUpload();
    if (r != ReceiveCommits.Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    try {
        rp.receive(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    final Set<AccountGroup.Id> uploadGroup = getServerCommandConfig().getUploadGroup();
    if (uploadGroup != null && !uploadGroup.isEmpty()) {
        if (!CollectionsUtil.isAnyIncludedIn(currentUser.getEffectiveGroups(), uploadGroup)) {
            throw new Failure(1, "User: " + currentUser.getUserName() + " not allowed to execute this command on this server");
        }
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get()));
    }
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get()));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.Id>>() {
    }).annotatedWith(ProjectCreatorGroups.class).toProvider(ProjectCreatorGroupsProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.Id>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(new TypeLiteral<ServerCommand>() {
    }).annotatedWith(ServerCommandConfig.class).toProvider(ServerCommandConfigProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(MergeOp.Factory.class);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    factory(FunctionState.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    setHeader("Subject", "[Gerrit Code Review] Email Verification");
    add(RecipientType.TO, new Address(addr));
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    setHeader("Subject", "[Gerrit Code Review] Email Verification");
    add(RecipientType.TO, new Address(addr));
}
#end_block

#method_before
@Override
protected void format() {
    appendText(velocifyFile("RegisterNewEmail.vm"));
}
#method_after
@Override
protected void format() throws EmailException {
    appendText(velocifyFile("RegisterNewEmail.vm"));
}
#end_block

#method_before
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("NewChange.vm");
    extractMailExample("RegisterNewEmail.vm");
    extractMailExample("ReplacePatchSet.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#method_after
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("ChangeFooter.vm");
    extractMailExample("ChangeSubject.vm");
    extractMailExample("Comment.vm");
    extractMailExample("Merged.vm");
    extractMailExample("MergeFail.vm");
    extractMailExample("NewChange.vm");
    extractMailExample("RegisterNewEmail.vm");
    extractMailExample("ReplacePatchSet.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#end_block

#method_before
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, "/" + orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#method_after
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    setHeader("Message-ID", getChangeMessageThreadId());
    add(RecipientType.TO, reviewers);
    add(RecipientType.CC, extraCC);
    rcptToAuthors(RecipientType.CC);
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    setHeader("Message-ID", getChangeMessageThreadId());
    add(RecipientType.TO, reviewers);
    add(RecipientType.CC, extraCC);
    rcptToAuthors(RecipientType.CC);
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("NewChange.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("NewChange.vm"));
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    add(RecipientType.TO, reviewers);
    add(RecipientType.CC, extraCC);
    rcptToAuthors(RecipientType.CC);
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    add(RecipientType.TO, reviewers);
    add(RecipientType.CC, extraCC);
    rcptToAuthors(RecipientType.CC);
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("ReplacePatchSet.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("ReplacePatchSet.vm"));
}
#end_block

#method_before
protected void format() {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#method_after
protected void format() throws EmailException {
    formatChange();
    appendText(velocifyFile("ChangeFooter.vm"));
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#end_block

#method_before
protected void init() {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    super.init();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#method_after
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    super.init();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
}
#end_block

#method_before
private void setChangeSubjectHeader() {
    final StringBuilder subj = new StringBuilder();
    subj.append("[");
    subj.append(change.getDest().getShortName());
    subj.append("] ");
    subj.append("Change ");
    subj.append(change.getKey().abbreviate());
    subj.append(": (");
    subj.append(projectName);
    subj.append(") ");
    if (change.getSubject().length() > 60) {
        subj.append(change.getSubject().substring(0, 60));
        subj.append("...");
    } else {
        subj.append(change.getSubject());
    }
    setHeader("Subject", subj.toString());
}
#method_after
private void setChangeSubjectHeader() throws EmailException {
    setHeader("Subject", velocifyFile("ChangeSubject.vm"));
}
#end_block

#method_before
@Override
protected void setupVelocityContext() {
    super.setupVelocityContext();
    velocityContext.put("change", change);
    velocityContext.put("branch", change.getDest());
    velocityContext.put("projectName", projectName);
    velocityContext.put("patchSet", patchSet);
    velocityContext.put("patchSetInfo", patchSetInfo);
}
#method_after
@Override
protected void setupVelocityContext() {
    super.setupVelocityContext();
    velocityContext.put("change", change);
    velocityContext.put("changeId", change.getKey());
    velocityContext.put("coverLetter", getCoverLetter());
    velocityContext.put("branch", change.getDest());
    velocityContext.put("fromName", getNameFor(fromId));
    velocityContext.put("projectName", projectName);
    velocityContext.put("patchSet", patchSet);
    velocityContext.put("patchSetInfo", patchSetInfo);
}
#end_block

#method_before
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("MergeFail.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#method_after
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("ChangeFooter.vm");
    extractMailExample("ChangeSubject.vm");
    extractMailExample("Comment.vm");
    extractMailExample("Merged.vm");
    extractMailExample("MergeFail.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#end_block

#method_before
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, "/" + orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#method_after
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccExistingReviewers();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccExistingReviewers();
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("MergeFail.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("MergeFail.vm"));
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("Abandoned.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("Abandoned.vm"));
}
#end_block

#method_before
protected void format() {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#method_after
protected void format() throws EmailException {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#end_block

#method_before
protected void init() {
    super.init();
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#method_after
protected void init() {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    super.init();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#end_block

#method_before
private String getSettingsUrl() {
    if (getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append("settings");
        return r.toString();
    }
    return null;
}
#method_after
public String getSettingsUrl() {
    if (getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append("settings");
        return r.toString();
    }
    return null;
}
#end_block

#method_before
protected void setVHeader(final String name, final String value) {
    setHeader(name, velocify(value));
}
#method_after
protected void setVHeader(final String name, final String value) throws EmailException {
    setHeader(name, velocify(value));
}
#end_block

#method_before
private void add(final RecipientType rt, final UserIdentity who) {
    if (who != null && who.getAccount() != null) {
        add(rt, who.getAccount());
    }
}
#method_after
protected void add(final RecipientType rt, final UserIdentity who) {
    if (who != null && who.getAccount() != null) {
        add(rt, who.getAccount());
    }
}
#end_block

#method_before
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#method_after
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (!a.isActive() || e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#end_block

#method_before
protected void setupVelocityContext() {
    String rl = "resource.loader";
    String pkg = "org.apache.velocity.runtime.resource.loader";
    Properties p = new Properties();
    p.setProperty(rl, "file, class");
    p.setProperty("file." + rl + ".class", pkg + ".FileResourceLoader");
    p.setProperty("file." + rl + ".path", args.site.mail_dir.getAbsolutePath());
    p.setProperty("class." + rl + ".class", pkg + ".ClasspathResourceLoader");
    p.setProperty(org.apache.velocity.runtime.RuntimeConstants.RUNTIME_LOG, args.site.logs_dir.getAbsolutePath() + java.io.File.separator + "velocity_log");
    try {
        Velocity.init(p);
    } catch (Exception e) {
    }
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#method_after
protected void setupVelocityContext() {
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#end_block

#method_before
protected String velocify(String tpl) {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        return tpl.toString();
    }
}
#method_after
protected String velocify(String tpl) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        throw new EmailException("Velocity template " + tpl.toString(), e);
    }
}
#end_block

#method_before
protected String velocifyFile(String name) {
    Exception eo;
    StringWriter w = new StringWriter();
    try {
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            eo = e;
        }
    } catch (Exception e) {
        eo = e;
    }
    return "Velocity exception in template " + name + ".\n" + eo.toString();
}
#method_after
protected String velocifyFile(String name) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            StringWriter w = new StringWriter();
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            throw new EmailException("Velocity WAR template" + name + ".\n", e2);
        }
    } catch (Exception e) {
        throw new EmailException("Velocity template " + name + ".\n", e);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) {
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, name);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) {
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, args.projectCache, name);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    install(new PredicateModule());
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    install(new ChangeQueryModule());
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    // TODO(spearce) This probably should be more lazy.
    // 
    ArrayList<ChangeData> r = new ArrayList<ChangeData>();
    ChangeData last = null;
    boolean skipped = false;
    for (ChangeData cd : prefetchData(source)) {
        if (match(cd)) {
            r.add(cd);
        } else {
            skipped = true;
        }
        last = cd;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        Paginated p = (Paginated) source;
        while (skipped && r.size() < p.limit()) {
            ChangeData lastBeforeRestart = last;
            skipped = false;
            last = null;
            for (ChangeData cd : p.restart(lastBeforeRestart)) {
                if (match(cd)) {
                    r.add(cd);
                } else {
                    skipped = true;
                }
                last = cd;
            }
        }
    }
    return new ListResultSet<ChangeData>(r);
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    // TODO(spearce) This probably should be more lazy.
    // 
    ArrayList<ChangeData> r = new ArrayList<ChangeData>();
    ChangeData last = null;
    boolean skipped = false;
    for (ChangeData cd : prefetchData(source.read())) {
        if (match(cd)) {
            r.add(cd);
        } else {
            skipped = true;
        }
        last = cd;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        Paginated p = (Paginated) source;
        while (skipped && r.size() < p.limit()) {
            ChangeData lastBeforeRestart = last;
            skipped = false;
            last = null;
            for (ChangeData cd : prefetchData(p.restart(lastBeforeRestart))) {
                if (match(cd)) {
                    r.add(cd);
                } else {
                    skipped = true;
                }
                last = cd;
            }
        }
    }
    return new ListResultSet<ChangeData>(r);
}
#end_block

#method_before
private Collection<ChangeData> prefetchData(ChangeDataSource source) throws OrmException {
    final ReviewDb db = dbProvider.get();
    final ArrayList<ChangeData> data = new ArrayList<ChangeData>();
    final EnumSet<NeededData> needed = getNeededData();
    for (ChangeData cd : source.read()) {
        data.add(cd);
    }
    for (ChangeData cd : data) {
        if (needed.contains(NeededData.APPROVALS)) {
            cd.setApprovals(db.patchSetApprovals().byChange(cd.getId()).toList());
        }
        if (needed.contains(NeededData.CHANGE)) {
            cd.setChange(db.changes().get(cd.getId()));
        }
        if (needed.contains(NeededData.PATCHES)) {
            cd.setPatches(db.patchSets().byChange(cd.getId()).toList());
        }
        if (needed.contains(NeededData.COMMENTS)) {
            cd.setComments(db.patchComments().byChange(cd.getId()).toList());
        }
        if (needed.contains(NeededData.TRACKING_IDS)) {
            cd.setTrackingIds(db.trackingIds().byChange(cd.getId()).toList());
        }
    }
    if (needed.contains(NeededData.PROJECT_STATE)) {
        ArrayList<Project.NameKey> projectNames = new ArrayList<Project.NameKey>();
        for (ChangeData cd : data) {
            projectNames.add(cd.getChange().getProject());
        }
        Map<Project.NameKey, ProjectState> projectMap = projectCache.getAll(projectNames);
        for (ChangeData cd : data) {
            cd.setProjectState(projectMap.get(cd.getChange().getProject()));
        }
    }
    db.close();
    return data;
}
#method_after
private Collection<ChangeData> prefetchData(ResultSet<ChangeData> resultSet) throws OrmException {
    final List<ChangeData> data = resultSet.toList();
    final EnumSet<NeededData> needed = getNeededData();
    if (needed.contains(NeededData.PROJECT_STATE)) {
        needed.add(NeededData.CHANGE);
    }
    if (needed.contains(NeededData.CHANGE)) {
        HashMap<Change.Id, ChangeData> need = new HashMap<Change.Id, ChangeData>();
        for (ChangeData cd : data) {
            if (!cd.hasChange()) {
                need.put(cd.getId(), cd);
            }
        }
        if (!need.isEmpty()) {
            for (Change c : dbProvider.get().changes().get(need.keySet())) {
                need.get(c.getId()).setChange(c);
            }
        }
    }
    if (needed.contains(NeededData.PROJECT_STATE)) {
        HashSet<Project.NameKey> projectNames = new HashSet<Project.NameKey>();
        for (ChangeData cd : data) {
            projectNames.add(cd.getChange().getProject());
        }
        Map<Project.NameKey, ProjectState> projectMap = projectCache.getAll(projectNames);
        for (ChangeData cd : data) {
            cd.setProjectState(projectMap.get(cd.getChange().getProject()));
        }
    }
    return data;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData cd) throws OrmException {
    if (rules == null) {
        ChangeQueryBuilder builder = new ChangeQueryBuilder(args, user);
        rules = new HashMap<Project.NameKey, List<Predicate<ChangeData>>>();
        for (AccountProjectWatch w : user.getNotificationFilters()) {
            List<Predicate<ChangeData>> list = rules.get(w.getProjectNameKey());
            if (list == null) {
                list = new ArrayList<Predicate<ChangeData>>(4);
                rules.put(w.getProjectNameKey(), list);
            }
            Predicate<ChangeData> p = compile(builder, w);
            if (p != null) {
                list.add(p);
            }
        }
    }
    if (rules.isEmpty()) {
        return false;
    }
    Change change = cd.change(args.dbProvider);
    if (change == null) {
        return false;
    }
    Project.NameKey project = change.getDest().getParentKey();
    List<Predicate<ChangeData>> list = rules.get(project);
    if (list == null) {
        list = rules.get(args.wildProjectName);
    }
    if (list != null) {
        for (Predicate<ChangeData> p : list) {
            if (p.match(cd)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
@Override
public boolean match(final ChangeData cd) throws OrmException {
    Map<Project.NameKey, List<Predicate<ChangeData>>> rules = getRules();
    if (rules.isEmpty()) {
        return false;
    }
    Change change = cd.change(args.dbProvider);
    if (change == null) {
        return false;
    }
    Project.NameKey project = change.getDest().getParentKey();
    List<Predicate<ChangeData>> list = rules.get(project);
    if (list == null) {
        list = rules.get(args.wildProjectName);
    }
    if (list != null) {
        for (Predicate<ChangeData> p : list) {
            if (p.match(cd)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public EnumSet<NeededData> getNeededData() {
    return EnumSet.of(NeededData.CHANGE);
}
#method_after
@Override
public EnumSet<NeededData> getNeededData() {
    Map<NameKey, List<Predicate<ChangeData>>> rules = getRules();
    if (rules.isEmpty()) {
        return EnumSet.noneOf(NeededData.class);
    }
    EnumSet<NeededData> needed = EnumSet.of(NeededData.CHANGE);
    for (List<Predicate<ChangeData>> list : rules.values()) {
        for (Predicate<ChangeData> p : list) {
            if (p instanceof Prefetchable) {
                needed.addAll(((Prefetchable) p).getNeededData());
            }
        }
    }
    return needed;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    for (PatchSetApproval p : object.currentApprovals(dbProvider)) {
        if (p.getCategoryId().equals(category)) {
            short psVal = p.getValue();
            if (test.match(psVal, expVal)) {
                // 
                try {
                    ChangeControl cc = // 
                    ccFactory.controlFor(// 
                    object.change(dbProvider), userFactory.create(dbProvider, p.getAccountId()));
                    if (!cc.isVisible()) {
                        // 
                        continue;
                    }
                    psVal = cc.normalize(category, psVal);
                } catch (NoSuchChangeException e) {
                    // 
                    continue;
                }
                if (test.match(psVal, expVal)) {
                    return true;
                }
            }
        }
    }
    return false;
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    for (PatchSetApproval p : object.currentApprovals(dbProvider)) {
        if (p.getCategoryId().equals(category)) {
            short psVal = p.getValue();
            if (test.match(psVal, expVal)) {
                // Double check the value is still permitted for the user.
                // 
                Change c = object.change(dbProvider);
                IdentifiedUser user = userFactory.create(dbProvider, p.getAccountId());
                ChangeControl cc = object.projectState(dbProvider, projectCache).controlFor(user).controlFor(c);
                if (!cc.isVisible()) {
                    // 
                    continue;
                }
                psVal = cc.normalize(category, psVal);
                if (test.match(psVal, expVal)) {
                    return true;
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public EnumSet<NeededData> getNeededData() {
    return EnumSet.of(NeededData.APPROVALS, NeededData.CHANGE);
}
#method_after
@Override
public EnumSet<NeededData> getNeededData() {
    return EnumSet.of(NeededData.APPROVALS, NeededData.CHANGE, NeededData.PROJECT_STATE);
}
#end_block

#method_before
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, null, id, starredChangesCache);
}
#method_after
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, starredChangesCache, remotePeerProvider, null, id);
}
#end_block

#method_before
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, dbProvider, id, starredChangesCache);
}
#method_after
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, starredChangesCache, remotePeerProvider, dbProvider, id);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final TypeLiteral<Cache<StarredChange.Key, StarredChange>> byKeyType = new TypeLiteral<Cache<StarredChange.Key, StarredChange>>() {
            };
            core(byKeyType, BY_KEY).populateWith(ByKeyLoader.class);
            final TypeLiteral<Cache<Account.Id, StarredChangeList>> byAccountIdType = new TypeLiteral<Cache<Account.Id, StarredChangeList>>() {
            };
            core(byAccountIdType, BY_ACCOUNT_ID).populateWith(ByAccountIdLoader.class);
            final TypeLiteral<Cache<Change.Id, StarredChangeList>> byChangeIdType = new TypeLiteral<Cache<Change.Id, StarredChangeList>>() {
            };
            core(byChangeIdType, BY_CHANGE_ID).populateWith(ByChangeIdLoader.class);
            bind(StarredChangesCacheImpl.class);
            bind(StarredChangesCache.class).to(StarredChangesCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final TypeLiteral<Cache<Account.Id, StarredChangeList>> byAccountIdType = new TypeLiteral<Cache<Account.Id, StarredChangeList>>() {
            };
            core(byAccountIdType, BY_ACCOUNT_ID).populateWith(ByAccountIdLoader.class);
            final TypeLiteral<Cache<Change.Id, StarredChangeList>> byChangeIdType = new TypeLiteral<Cache<Change.Id, StarredChangeList>>() {
            };
            core(byChangeIdType, BY_CHANGE_ID).populateWith(ByChangeIdLoader.class);
            bind(StarredChangesCacheImpl.class);
            bind(StarredChangesCache.class).to(StarredChangesCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public void evict(StarredChange.Key key) {
    byKey.remove(key);
    byAccountId.remove(key.getParentKey());
    byChangeId.remove(key.getChangeId());
}
#method_after
@Override
public void evict(StarredChange.Key key) {
    byAccountId.remove(key.getParentKey());
    byChangeId.remove(key.getChangeId());
}
#end_block

#method_before
public void toggleStars(final ToggleStarRequest req, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException {
            final Account.Id me = getAccountId();
            final Set<Change.Id> existing = currentUser.get().getStarredChanges();
            List<StarredChange> add = new ArrayList<StarredChange>();
            List<StarredChange.Key> remove = new ArrayList<StarredChange.Key>();
            if (req.getAddSet() != null) {
                for (final Change.Id id : req.getAddSet()) {
                    if (!existing.contains(id)) {
                        StarredChange.Key key = new StarredChange.Key(me, id);
                        add.add(new StarredChange(key));
                        starredChangesCache.evict(key);
                    }
                }
            }
            if (req.getRemoveSet() != null) {
                for (final Change.Id id : req.getRemoveSet()) {
                    StarredChange.Key key = new StarredChange.Key(me, id);
                    remove.add(key);
                    starredChangesCache.evict(key);
                }
            }
            db.starredChanges().insert(add);
            db.starredChanges().deleteKeys(remove);
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void toggleStars(final ToggleStarRequest req, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException {
            final Account.Id me = getAccountId();
            final Set<Change.Id> existing = currentUser.get().getStarredChanges();
            List<StarredChange> add = new ArrayList<StarredChange>();
            List<StarredChange.Key> remove = new ArrayList<StarredChange.Key>();
            if (req.getAddSet() != null) {
                for (final Change.Id id : req.getAddSet()) {
                    if (!existing.contains(id)) {
                        add.add(new StarredChange(new StarredChange.Key(me, id)));
                    }
                }
            }
            if (req.getRemoveSet() != null) {
                for (final Change.Id id : req.getRemoveSet()) {
                    remove.add(new StarredChange.Key(me, id));
                }
            }
            db.starredChanges().insert(add);
            db.starredChanges().deleteKeys(remove);
            for (StarredChange sc : add) {
                starredChangesCache.evict(sc.getKey());
            }
            for (StarredChange.Key key : remove) {
                starredChangesCache.evict(key);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
private void start() {
    synchronized (lock) {
        if (manager != null) {
            throw new IllegalStateException("Cache pool has already been started");
        }
        try {
            System.setProperty("net.sf.ehcache.skipUpdateCheck", "" + true);
        } catch (SecurityException e) {
        // Ignore it, the system is just going to ping some external page
        // using a background thread and there's not much we can do about
        // it now.
        }
        manager = new CacheManager(new Factory().toConfiguration());
        for (CacheProvider<?, ?> p : caches.values()) {
            Ehcache eh = manager.getEhcache(p.getName());
            EntryCreator<?, ?> c = p.getEntryCreator();
            if (c != null) {
                if (p.disk()) {
                    p.bind(new PopulatingProtobufCache(eh, c, p.getKeyClass(), p.getValueClass(), p.getValueProvider()));
                } else {
                    p.bind(new PopulatingCache(eh, c));
                }
            } else {
                if (p.disk()) {
                    p.bind(new SimpleProtobufCache(eh, p.getKeyClass(), p.getValueClass(), p.getValueProvider()));
                } else {
                    p.bind(new SimpleCache(eh));
                }
            }
        }
    }
}
#method_after
private void start() {
    synchronized (lock) {
        if (manager != null) {
            throw new IllegalStateException("Cache pool has already been started");
        }
        try {
            System.setProperty("net.sf.ehcache.skipUpdateCheck", "" + true);
        } catch (SecurityException e) {
        // Ignore it, the system is just going to ping some external page
        // using a background thread and there's not much we can do about
        // it now.
        }
        manager = new CacheManager(new Factory().toConfiguration());
        for (CacheProvider<?, ?> p : caches.values()) {
            Ehcache eh = manager.getEhcache(p.getName());
            EntryCreator<?, ?> c = p.getEntryCreator();
            if (c != null && p.disk()) {
                c = new ProtobufEntryCreator(c, p.getKeyClass(), p.getValueClass());
            }
            Cache m;
            if (c != null) {
                m = new PopulatingCache(eh, c);
            } else {
                m = new SimpleCache(eh);
            }
            if (p.disk()) {
                m = new ProtobufCache(m, p.getKeyClass(), p.getValueClass(), p.getValueProvider());
            }
            p.bind(m);
        }
    }
}
#end_block

#method_before
public T toObject(ProtobufCodec<T> codec, Provider<T> provider) {
    if (object == null) {
        this.codec = codec;
        if (provider == null) {
            object = codec.decode(buf);
        } else {
            object = provider.get();
            try {
                codec.mergeFrom(CodedInputStream.newInstance(buf), object);
            } catch (IOException e) {
                throw new RuntimeException("Cannot decode message", e);
            }
        }
        // Free the memory being taken up by the buffer.
        buf = null;
    }
    return object;
}
#method_after
T toObject(ProtobufCodec<T> codec, Provider<T> provider) {
    if (codec == null) {
        return null;
    }
    Object d = data;
    if (d instanceof byte[]) {
        this.codec = codec;
        if (provider == null) {
            d = codec.decode((byte[]) d);
        } else {
            T tmp = provider.get();
            codec.mergeFrom((byte[]) d, tmp);
            d = tmp;
        }
        data = d;
    }
    return (T) d;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SerializableProtobuf<?>)) {
        return false;
    }
    SerializableProtobuf<?> other = ((SerializableProtobuf<?>) obj);
    if (hash != other.hash) {
        return false;
    }
    if (object != null && other.object != null) {
        return object.equals(other.object);
    }
    return Arrays.equals(buf, other.buf);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SerializableProtobuf<?>)) {
        return false;
    }
    SerializableProtobuf<T> other = ((SerializableProtobuf<T>) obj);
    if (hash != other.hash) {
        return false;
    }
    // Make sure we either both have codecs, or we both do not
    if (this.codec == null && other.codec != null) {
        this.codec = other.codec;
    } else if (this.codec != null && other.codec == null) {
        other.codec = this.codec;
    }
    // Equals is only ever called on keys, which cannot have providers
    T thisObject = this.toObject(codec, null);
    T otherObject = other.toObject(other.codec, null);
    if (thisObject == null && otherObject == null) {
        // Neither of us had codecs, so we must compare byte arrays
        return Arrays.equals((byte[]) this.data, (byte[]) other.data);
    } else if (thisObject != null && otherObject != null) {
        return thisObject.equals(otherObject);
    } else {
        return false;
    }
}
#end_block

#method_before
private void writeObject(ObjectOutputStream oos) throws IOException {
    if (buf == null) {
        // If buffer is null, toObject must have been called, which means that we
        // have the object and the codec.
        buf = new byte[codec.sizeof(object)];
        codec.encode(object, buf);
    }
    oos.defaultWriteObject();
}
#method_after
private void writeObject(ObjectOutputStream oos) throws IOException {
    oos.writeInt(hash);
    Object d = data;
    if (d instanceof byte[]) {
        byte[] buf = (byte[]) d;
        oos.writeInt(buf.length);
        oos.write(buf);
    } else {
        // We assume that if we have an object, we must have a codec
        T obj = (T) d;
        oos.writeInt(codec.sizeof(obj));
        CodedOutputStream cos = CodedOutputStream.newInstance(oos);
        codec.encode(obj, cos);
        cos.flush();
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else if (!Pattern.compile("refs/.*").matcher(refPattern.replace("*", ".*")).matches()) {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    boolean exclusive = refPattern.startsWith("-");
    if (exclusive) {
        refPattern = refPattern.substring(1);
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        String example = RefControl.shortestExample(refPattern);
        if (!example.startsWith(Constants.R_REFS)) {
            refPattern = RefRight.REGEX_PREFIX + Constants.R_HEADS + refPattern.substring(RefRight.REGEX_PREFIX.length());
            example = RefControl.shortestExample(refPattern);
        }
        if (!Repository.isValidRefName(example)) {
            throw new InvalidNameException();
        }
    } else {
        if (!refPattern.startsWith(Constants.R_REFS)) {
            refPattern = Constants.R_HEADS + refPattern;
        }
        if (refPattern.endsWith("/*")) {
            final String prefix = refPattern.substring(0, refPattern.length() - 2);
            if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
                throw new InvalidNameException();
            }
        } else {
            if (!Repository.isValidRefName(refPattern)) {
                throw new InvalidNameException();
            }
        }
    }
    if (exclusive) {
        refPattern = "-" + refPattern;
    }
    if (!projectControl.controlForRef(refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (!RefRight.ALL.equals(getRefName()) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (getRefName().equals(RefRight.ALL.substring(0, RefRight.ALL.length() - 1)) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#end_block

#method_before
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    for (RefRight right : filterMostSpecific(allRights)) {
        if (groups.contains(right.getAccountGroupId())) {
            val = Math.max(right.getMaxValue(), val);
        }
    }
    return val >= level;
}
#method_after
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (RefRightsForPattern right : perPatternRights.values()) {
        val = Math.max(val, right.allowedValueForRef(groups));
        if (val >= level || right.containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#end_block

#method_before
public static boolean matches(String refName, String refPattern) {
    return Pattern.matches(refPattern.replace("*", "(.*)"), refName);
}
#method_after
public static boolean matches(String refName, String refPattern) {
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        return Pattern.matches(refPattern, refName);
    }
    if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 1);
        return refName.startsWith(prefix);
    } else {
        return refName.equals(refPattern);
    }
}
#end_block

#method_before
private void createGroup() throws OrmException {
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    db.accountGroups().insert(Collections.singleton(group));
    AccountGroupName groupName = new AccountGroupName(group);
    db.accountGroupNames().insert(Collections.singleton(groupName));
    List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (String userName : initialMembers) {
        AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, userName);
        Account.Id accountId = db.accountExternalIds().get(key).getAccountId();
        AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
}
#method_after
private void createGroup() throws OrmException, UnloggedFailure {
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw die("group '" + groupName + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : initialMembers) {
        AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
}
#end_block

#method_before
public Iterable<SshKeyCacheEntry> get(String username) {
    return cache.get(username).sshKeyIter;
}
#method_after
public Iterable<SshKeyCacheEntry> get(String username) {
    return cache.get(username).getSshKeyCacheEntries();
}
#end_block

#method_before
public void addProjectWatch(final String projectName, final String fileMatch, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            final AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, fileMatch));
            db.accountProjectWatches().insert(Collections.singleton(watch));
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#method_after
public void addProjectWatch(final String projectName, final String filter, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException, InvalidQueryException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            if (filter != null) {
                try {
                    ChangeQueryBuilder builder = queryBuilder.create(currentUser.get());
                    builder.setAllowFile(true);
                    builder.parse(filter);
                } catch (QueryParseException badFilter) {
                    throw new InvalidQueryException(badFilter.getMessage(), filter);
                }
            }
            AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, filter));
            try {
                db.accountProjectWatches().insert(Collections.singleton(watch));
            } catch (OrmDuplicateKeyException alreadyHave) {
                watch = db.accountProjectWatches().get(watch.getKey());
            }
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#end_block

#method_before
public void send() throws EmailException {
    if (!emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            // If we are impersonating a user, make sure they receive a CC of
            // this message so they can always review and audit what we sent
            // on their behalf to others.
            // 
            add(RecipientType.CC, fromId);
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#method_after
public void send() throws EmailException {
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            if (fromUser.getGeneralPreferences().isCopySelfOnEmails()) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                final String fromEmail = fromUser.getPreferredEmail();
                for (Iterator<Address> i = smtpRcptTo.iterator(); i.hasNext(); ) {
                    if (i.next().email.equals(fromEmail)) {
                        i.remove();
                    }
                }
                for (EmailHeader hdr : headers.values()) {
                    if (hdr instanceof AddressList) {
                        ((AddressList) hdr).remove(fromEmail);
                    }
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
            appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
            try {
                HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
                for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
                    reviewers.add(p.getAccountId());
                }
                TreeSet<String> names = new TreeSet<String>();
                for (Account.Id who : reviewers) {
                    names.add(getNameEmailFor(who));
                }
                for (String name : names) {
                    appendText("Gerrit-Reviewer: " + name + "\n");
                }
            } catch (OrmException e) {
            }
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        args.emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#end_block

#method_before
protected void init() {
    if (change != null && projectCache != null) {
        projectState = projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    smtpFromAddress = fromAddressGenerator.from(fromId);
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (fromId != null && fromAddressGenerator.isGenericAddress(fromId)) {
        final Account account = accountCache.get(fromId).getAccount();
        final String name = account.getFullName();
        final String email = account.getPreferredEmail();
        if ((name != null && !name.isEmpty()) || (email != null && !email.isEmpty())) {
            body.append("From");
            if (name != null && !name.isEmpty()) {
                body.append(" ").append(name);
            }
            if (email != null && !email.isEmpty()) {
                body.append(" <").append(email).append(">");
            }
            body.append(":\n\n");
        }
    }
    if (change != null && db != null) {
        if (patchSet == null) {
            try {
                patchSet = db.patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#method_after
protected void init() {
    if (change != null && args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        final Account account = args.accountCache.get(fromId).getAccount();
        final String name = account.getFullName();
        final String email = account.getPreferredEmail();
        if ((name != null && !name.isEmpty()) || (email != null && !email.isEmpty())) {
            body.append("From");
            if (name != null && !name.isEmpty()) {
                body.append(" ").append(name);
            }
            if (email != null && !email.isEmpty()) {
                body.append(" <").append(email).append(">");
            }
            body.append(":\n\n");
        }
    }
    if (change != null) {
        if (patchSet == null) {
            try {
                patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#end_block

#method_before
protected String getGerritUrl() {
    return urlProvider.get();
}
#method_after
protected String getGerritUrl() {
    return args.urlProvider.get();
}
#end_block

#method_before
protected PatchList getPatchList() {
    if (patchSet != null) {
        return patchListCache.get(change, patchSet);
    }
    return null;
}
#method_after
protected PatchList getPatchList() {
    if (patchSet != null) {
        return args.patchListCache.get(change, patchSet);
    }
    return null;
}
#end_block

#method_before
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return "Anonymous Coward";
    }
    final Account userAccount = accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = "Anonymous Coward #" + accountId;
    }
    return name;
}
#method_after
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return "Anonymous Coward";
    }
    final Account userAccount = args.accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = "Anonymous Coward #" + accountId;
    }
    return name;
}
#end_block

#method_before
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (rcptTo.isEmpty()) {
        // 
        return false;
    }
    if (rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#method_after
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // 
        return false;
    }
    if (rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#end_block

#method_before
protected Set<AccountGroup.Id> getProjectOwners() {
    final ProjectState r;
    r = projectCache.get(change.getProject());
    return r != null ? r.getOwners() : Collections.<AccountGroup.Id>emptySet();
}
#method_after
protected Set<AccountGroup.Id> getProjectOwners() {
    final ProjectState r;
    r = args.projectCache.get(change.getProject());
    return r != null ? r.getOwners() : Collections.<AccountGroup.Id>emptySet();
}
#end_block

#method_before
protected void bccStarredBy() {
    if (db != null) {
        try {
            // 
            for (StarredChange w : db.starredChanges().byChange(change.getId())) {
                add(RecipientType.BCC, w.getAccountId());
            }
        } catch (OrmException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        }
    }
}
#method_after
protected void bccStarredBy() {
    try {
        // 
        for (StarredChange w : args.db.get().starredChanges().byChange(change.getId())) {
            add(RecipientType.BCC, w.getAccountId());
        }
    } catch (OrmException err) {
    // Just don't BCC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#end_block

#method_before
protected void bccWatchesNotifyAllComments(List<String> specificFileName) {
    if (db != null) {
        if (specificFileName == null) {
            final List<Patch> patches = getPatches(patchSet.getId());
            specificFileName = getPatchesFileNames(patches);
        }
        try {
            // BCC anyone else who has interest in this project's changes
            // 
            final ProjectState ps = getProjectState();
            if (ps != null) {
                for (final AccountProjectWatch w : db.accountProjectWatches().notifyAllComments(ps.getProject().getNameKey())) {
                    if (canAddRecipient(w, specificFileName)) {
                        add(RecipientType.BCC, w.getAccountId());
                    }
                }
            }
        } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        }
    }
}
#method_after
protected void bccWatchesNotifyAllComments() {
    try {
        // 
        for (final AccountProjectWatch w : getWatches()) {
            if (w.isNotifyAllComments()) {
                add(RecipientType.BCC, w.getAccountId());
            }
        }
    } catch (OrmException err) {
    // Just don't CC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void add(List<AccountProjectWatch> matching, AccountProjectWatch w) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(args.db, w.getAccountId());
    ChangeQueryBuilder qb = args.queryBuilder.create(user);
    Predicate<ChangeData> p = qb.is_visible();
    if (w.getFilter() != null) {
        try {
            qb.setAllowFile(true);
            p = Predicate.and(qb.parse(w.getFilter()), p);
            p = args.queryRewriter.get().rewrite(p);
            if (p.match(changeData)) {
                matching.add(w);
            }
        } catch (QueryParseException e) {
        // Ignore broken filter expressions.
        }
    } else if (p.match(changeData)) {
        matching.add(w);
    }
}
#end_block

#method_before
private void ccApprovals(final boolean includeZero) {
    if (db != null) {
        try {
            // 
            for (PatchSetApproval ap : db.patchSetApprovals().byChange(change.getId())) {
                if (!includeZero && ap.getValue() == 0) {
                    continue;
                }
                add(RecipientType.CC, ap.getAccountId());
            }
        } catch (OrmException err) {
        }
    }
}
#method_after
private void ccApprovals(final boolean includeZero) {
    try {
        // 
        for (PatchSetApproval ap : args.db.get().patchSetApprovals().byChange(change.getId())) {
            if (!includeZero && ap.getValue() == 0) {
                continue;
            }
            add(RecipientType.CC, ap.getAccountId());
        }
    } catch (OrmException err) {
    }
}
#end_block

#method_before
private boolean isVisibleTo(final Account.Id to) {
    return projectState == null || change == null || projectState.controlFor(identifiedUserFactory.create(to)).controlFor(change).isVisible();
}
#method_after
private boolean isVisibleTo(final Account.Id to) {
    return projectState == null || change == null || projectState.controlFor(args.identifiedUserFactory.create(to)).controlFor(change).isVisible();
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        if (args.emailSender.canEmail(addr.email)) {
            smtpRcptTo.add(addr);
            switch(rt) {
                case TO:
                    ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                    break;
                case CC:
                    ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                    break;
            }
        } else {
            log.warn("Not emailing " + addr.email + " (prohibited by allowrcpt)");
        }
    }
}
#end_block

#method_before
private Address toAddress(final Account.Id id) {
    final Account a = accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#method_after
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#end_block

#method_before
public void setPatchLineComments(final List<PatchLineComment> plc) {
    inlineComments = plc;
}
#method_after
public void setPatchLineComments(final List<PatchLineComment> plc) {
    inlineComments = plc;
    Set<String> paths = new HashSet<String>();
    for (PatchLineComment c : plc) {
        Patch.Key p = c.getKey().getParentKey();
        paths.add(p.getFileName());
    }
    changeData.setCurrentFilePaths(paths);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    final List<String> inlineCommentsFiles = new ArrayList<String>();
    for (final PatchLineComment c : inlineComments) {
        final String fileName = c.getKey().getParentKey().getFileName();
        inlineCommentsFiles.add(fileName);
    }
    bccWatchesNotifyAllComments(inlineCommentsFiles);
}
#method_after
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#end_block

#method_before
private Repository getRepository() {
    try {
        return server.openRepository(projectName);
    } catch (RepositoryNotFoundException e) {
        return null;
    }
}
#method_after
private Repository getRepository() {
    try {
        return args.server.openRepository(projectName);
    } catch (RepositoryNotFoundException e) {
        return null;
    }
}
#end_block

#method_before
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    messageBlock.display(info);
}
#method_after
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    messageBlock.display(info.getMessage());
}
#end_block

#method_before
public void display(final PatchSetInfo info) {
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg = CommentLinkProcessor.apply(msg);
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#method_after
public void display(final String commitMessage) {
    SafeHtml msg = new SafeHtmlBuilder().append(commitMessage);
    msg = msg.linkify();
    msg = CommentLinkProcessor.apply(msg);
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#end_block

#method_before
private boolean canReuse(PatchScriptSettings s, PatchScript last) {
    if (last.getSettings().getWhitespace() != s.getWhitespace()) {
        // Whitespace ignore setting requires server computation.
        return false;
    }
    final int ctx = s.getContext();
    if (ctx == WHOLE_FILE_CONTEXT && !last.getA().isWholeFile()) {
        // We don't have the entire file here, so we can't render it.
        return false;
    }
    if (last.getSettings().getContext() < ctx && !last.getA().isWholeFile()) {
        // We don't have sufficient context.
        return false;
    }
    if (s.getPrettySettings().isSyntaxHighlighting() && !last.getA().isWholeFile()) {
        // We need the whole file to syntax highlight accurately.
        return false;
    }
    return true;
}
#method_after
private boolean canReuse(PatchScriptSettings s, PatchScript last) {
    if (last.getSettings().getWhitespace() != s.getWhitespace()) {
        // Whitespace ignore setting requires server computation.
        return false;
    }
    final int ctx = s.getContext();
    if (ctx == AccountDiffPreference.WHOLE_FILE_CONTEXT && !last.getA().isWholeFile()) {
        // We don't have the entire file here, so we can't render it.
        return false;
    }
    if (last.getSettings().getContext() < ctx && !last.getA().isWholeFile()) {
        // We don't have sufficient context.
        return false;
    }
    if (s.getPrettySettings().isSyntaxHighlighting() && !last.getA().isWholeFile()) {
        // We need the whole file to syntax highlight accurately.
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    VerticalPanel vp = new VerticalPanel();
    vp.add(historyPanel);
    vp.add(settingsPanel);
    commitMessageBlock = new CommitMessageBlock("6em");
    HorizontalPanel hp = new HorizontalPanel();
    hp.setWidth("100%");
    hp.add(vp);
    hp.add(commitMessageBlock);
    add(hp);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either
    // side, expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null || (historyOpen != null && historyOpen));
    historyPanel.addOpenHandler(cacheOpenState);
    historyPanel.addCloseHandler(cacheCloseState);
    VerticalPanel vp = new VerticalPanel();
    vp.add(historyPanel);
    vp.add(settingsPanel);
    commitMessageBlock = new CommitMessageBlock("6em");
    HorizontalPanel hp = new HorizontalPanel();
    hp.setWidth("100%");
    hp.add(vp);
    hp.add(commitMessageBlock);
    add(hp);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey().getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey().getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    refresh(true);
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable();
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                    topNav.display(patchIndex, getPatchScreenType(), fileList);
                    bottomNav.display(patchIndex, getPatchScreenType(), fileList);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path));
    Util.DETAIL_SVC.changeDetail(currentChangeId, new GerritCallback<ChangeDetail>() {

        @Override
        public void onSuccess(ChangeDetail detail) {
            commitMessageBlock.display(detail.getCurrentPatchSetDetail().getInfo());
        }
    });
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final Change.Key cid = script.getChangeId();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(cid.abbreviate(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(cid.abbreviate(), path));
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    historyPanel.setVisible(true);
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        settingsPanel.getReviewedCheckBox().setValue(true);
        setReviewedByCurrentUser(true);
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable();
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(psid, result.getPatches());
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable();
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
public void setContext(final int ctx) {
    assert 0 <= ctx || ctx == AccountGeneralPreferences.WHOLE_FILE_CONTEXT;
    context = ctx;
}
#method_after
public void setContext(final int ctx) {
    assert 0 <= ctx || ctx == AccountDiffPreference.WHOLE_FILE_CONTEXT;
    context = ctx;
}
#end_block

#method_before
@Override
public void myDiffPreferences(AsyncCallback<AccountDiffPreference> callback) {
    run(callback, new Action<AccountDiffPreference>() {

        @Override
        public AccountDiffPreference run(ReviewDb db) throws OrmException, Failure, NoSuchProjectException, NoSuchGroupException {
            return db.accountDiffPreferences().get(currentUser.get().getAccountId());
        }
    });
}
#method_after
@Override
public void myDiffPreferences(AsyncCallback<AccountDiffPreference> callback) {
    run(callback, new Action<AccountDiffPreference>() {

        @Override
        public AccountDiffPreference run(ReviewDb db) throws OrmException {
            return currentUser.get().getAccountDiffPreference();
        }
    });
}
#end_block

#method_before
@Override
public void changeDiffPreferences(final AccountDiffPreference diffPref, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure, NoSuchProjectException, NoSuchGroupException {
            Id accountId = getAccountId();
            diffPref.setAccountId(accountId);
            final AccountDiffPreference p = db.accountDiffPreferences().get(accountId);
            if (p == null) {
                db.accountDiffPreferences().insert(Collections.singleton(diffPref));
            } else {
                db.accountDiffPreferences().update(Collections.singleton(diffPref));
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void changeDiffPreferences(final AccountDiffPreference diffPref, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id accountId = getAccountId();
            if (!diffPref.getAccountId().equals(getAccountId())) {
                throw new IllegalArgumentException("diffPref.getAccountId() " + diffPref.getAccountId() + " doesn't match" + " the accountId of the signed in user " + getAccountId());
            }
            db.accountDiffPreferences().upsert(Collections.singleton(diffPref));
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public char getIgnoreWhitespace() {
    return ignoreWhitespace;
}
#method_after
public Whitespace getIgnoreWhitespace() {
    return Whitespace.forCode(ignoreWhitespace);
}
#end_block

#method_before
public void setIgnoreWhitespace(char ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace;
}
#method_after
public void setIgnoreWhitespace(Whitespace ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace.getCode();
}
#end_block

#method_before
public void setEnabled(final boolean on) {
    for (Widget w : (HasWidgets) getWidget()) {
        if (w instanceof FocusWidget) {
            ((FocusWidget) w).setEnabled(on);
        }
    }
    toggleEnabledStatus(on);
}
#method_after
public void setEnabled(final boolean on) {
    if (on) {
        setEnabledCounter++;
    } else {
        setEnabledCounter--;
    }
    if (on && setEnabledCounter == 0 || !on) {
        for (Widget w : (HasWidgets) getWidget()) {
            if (w instanceof FocusWidget) {
                ((FocusWidget) w).setEnabled(on);
            }
        }
        toggleEnabledStatus(on);
    }
    ;
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        final PrettySettings p = getValue().getPrettySettings();
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
        showFullFile.setValue(getValue().getContext() == WHOLE_FILE_CONTEXT);
    } else {
        syntaxHighlighting.setValue(false);
        showFullFile.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        final PrettySettings p = getValue().getPrettySettings();
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#end_block

#method_before
private void toggleEnabledStatus(final boolean on) {
    intralineDifference.setEnabled(on & enableIntralineDifference);
    syntaxHighlighting.setEnabled(on & enableSmallFileFeatures);
    showFullFile.setEnabled(on & enableSmallFileFeatures);
    final String title = enableSmallFileFeatures ? null : PatchUtil.C.disabledOnLargeFiles();
    syntaxHighlighting.setTitle(title);
    showFullFile.setTitle(title);
}
#method_after
private void toggleEnabledStatus(final boolean on) {
    intralineDifference.setEnabled(on & enableIntralineDifference);
    syntaxHighlighting.setEnabled(on & enableSmallFileFeatures);
    final String title = enableSmallFileFeatures ? null : PatchUtil.C.disabledOnLargeFiles();
    syntaxHighlighting.setTitle(title);
}
#end_block

#method_before
public void setValue(final PatchScriptSettings s) {
    final PrettySettings p = s.getPrettySettings();
    setIgnoreWhitespace(s.getWhitespace());
    if (enableSmallFileFeatures) {
        showFullFile.setValue(s.getContext() == WHOLE_FILE_CONTEXT);
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        showFullFile.setValue(false);
        syntaxHighlighting.setValue(false);
    }
    tabWidth.setIntValue(p.getTabSize());
    colWidth.setIntValue(p.getLineLength());
    intralineDifference.setValue(p.isIntralineDifference());
    whitespaceErrors.setValue(p.isShowWhiteSpaceErrors());
    showTabs.setValue(p.isShowTabs());
    value = s;
}
#method_after
public void setValue(final PatchScriptSettings s) {
    final PrettySettings p = s.getPrettySettings();
    setIgnoreWhitespace(s.getWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(s.getContext());
    tabWidth.setIntValue(p.getTabSize());
    colWidth.setIntValue(p.getLineLength());
    intralineDifference.setValue(p.isIntralineDifference());
    whitespaceErrors.setValue(p.isShowWhiteSpaceErrors());
    showTabs.setValue(p.isShowTabs());
    value = s;
}
#end_block

#method_before
@UiHandler("update")
void onUpdate(ClickEvent event) {
    update();
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#method_after
@UiHandler("update")
void onUpdate(ClickEvent event) {
    update();
}
#end_block

#method_before
private void update() {
    PatchScriptSettings s = new PatchScriptSettings(getValue());
    PrettySettings p = s.getPrettySettings();
    s.setWhitespace(getIgnoreWhitespace());
    if (showFullFile.getValue()) {
        s.setContext(WHOLE_FILE_CONTEXT);
    } else if (Gerrit.isSignedIn()) {
        final Account u = Gerrit.getUserAccount();
        final AccountGeneralPreferences pref = u.getGeneralPreferences();
        if (pref.getDefaultContext() == WHOLE_FILE_CONTEXT) {
            s.setContext(DEFAULT_CONTEXT);
        } else {
            s.setContext(pref.getDefaultContext());
        }
    } else {
        s.setContext(DEFAULT_CONTEXT);
    }
    p.setTabSize(tabWidth.getIntValue());
    p.setLineLength(colWidth.getIntValue());
    p.setSyntaxHighlighting(syntaxHighlighting.getValue());
    p.setIntralineDifference(intralineDifference.getValue());
    p.setShowWhiteSpaceErrors(whitespaceErrors.getValue());
    p.setShowTabs(showTabs.getValue());
    value = s;
    fireEvent(new ValueChangeEvent<PatchScriptSettings>(s) {
    });
}
#method_after
private void update() {
    PatchScriptSettings s = new PatchScriptSettings(getValue());
    PrettySettings p = s.getPrettySettings();
    s.setWhitespace(getIgnoreWhitespace());
    s.setContext(getContext());
    p.setTabSize(tabWidth.getIntValue());
    p.setLineLength(colWidth.getIntValue());
    p.setSyntaxHighlighting(syntaxHighlighting.getValue());
    p.setIntralineDifference(intralineDifference.getValue());
    p.setShowWhiteSpaceErrors(whitespaceErrors.getValue());
    p.setShowTabs(showTabs.getValue());
    value = s;
    fireEvent(new ValueChangeEvent<PatchScriptSettings>(s) {
    });
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#end_block

#method_before
private void persistDiffPreferences() {
    AccountDiffPreference diffPref = new AccountDiffPreference();
    diffPref.setIgnoreWhitespace(getIgnoreWhitespace().getCode());
    diffPref.setTabSize(tabWidth.getIntValue());
    diffPref.setLineLength(colWidth.getIntValue());
    diffPref.setSyntaxHighlighting(syntaxHighlighting.getValue());
    diffPref.setShowWhitespaceErrors(whitespaceErrors.getValue());
    diffPref.setIntralineDifference(intralineDifference.getValue());
    diffPref.setShowTabs(showTabs.getValue());
    Util.ACCOUNT_SVC.changeDiffPreferences(diffPref, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
        }
    });
}
#method_after
private void persistDiffPreferences() {
    setEnabled(false);
    final AccountDiffPreference diffPref = new AccountDiffPreference(Gerrit.getUserAccount().getId());
    diffPref.setIgnoreWhitespace(getIgnoreWhitespace());
    diffPref.setTabSize(tabWidth.getIntValue());
    diffPref.setLineLength(colWidth.getIntValue());
    diffPref.setSyntaxHighlighting(syntaxHighlighting.getValue());
    diffPref.setShowWhitespaceErrors(whitespaceErrors.getValue());
    diffPref.setIntralineDifference(intralineDifference.getValue());
    diffPref.setShowTabs(showTabs.getValue());
    diffPref.setContext(getContext());
    Util.ACCOUNT_SVC.changeDiffPreferences(diffPref, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            Gerrit.setAccountDiffPreference(diffPref);
            setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            setEnabled(true);
        }
    });
}
#end_block

#method_before
final protected List<AccountProjectWatch> getProjectWatches() throws OrmException {
    final List<AccountProjectWatch> projectWatches = new LinkedList<AccountProjectWatch>();
    final List<Account.Id> projectWatchers = new LinkedList<Account.Id>();
    final ProjectState ps = getProjectState();
    if (ps != null) {
        for (final AccountProjectWatch w : db.accountProjectWatches().byProject(ps.getProject().getNameKey())) {
            projectWatches.add(w);
            projectWatchers.add(w.getAccountId());
        }
    }
    for (final AccountProjectWatch w : db.accountProjectWatches().byProject(wildProject)) {
        if (!projectWatchers.contains(w.getAccountId())) {
            // the all projects watch settings are only relevant if the user did not configure
            // any specific rules for the concrete project
            projectWatches.add(w);
        }
    }
    return Collections.unmodifiableList(projectWatches);
}
#method_after
final protected Set<AccountProjectWatch> getProjectWatches() throws OrmException {
    final Set<AccountProjectWatch> projectWatches = new HashSet<AccountProjectWatch>();
    final Set<Account.Id> projectWatchers = new HashSet<Account.Id>();
    final ProjectState ps = getProjectState();
    if (ps != null) {
        for (final AccountProjectWatch w : db.accountProjectWatches().byProject(ps.getProject().getNameKey())) {
            projectWatches.add(w);
            projectWatchers.add(w.getAccountId());
        }
    }
    for (final AccountProjectWatch w : db.accountProjectWatches().byProject(wildProject)) {
        if (!projectWatchers.contains(w.getAccountId())) {
            // the all projects watch settings are only relevant if the user did not configure
            // any specific rules for the concrete project
            projectWatches.add(w);
        }
    }
    return Collections.unmodifiableSet(projectWatches);
}
#end_block

#method_before
private boolean isWatched(Change c) {
    Set<Project.NameKey> watchedProjects = currentUser.get().getWatchedProjects();
    return watchedProjects.contains(c.getProject()) || watchedProjects.contains(systemConfigProvider.get().wildProjectName);
}
#method_after
private boolean isWatched(Change c) {
    Set<Project.NameKey> watchedProjects = currentUser.get().getWatchedProjects();
    return watchedProjects.contains(c.getProject()) || watchedProjects.contains(wildProject);
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.ALL_OPEN);
    addLink(m, C.menuAllMerged(), PageLinks.ALL_MERGED);
    addLink(m, C.menuAllAbandoned(), PageLinks.ALL_ABANDONED);
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menyMyDrafts(), PageLinks.MINE_DRAFTS);
        addLink(m, C.menuMyWatchedChanges(), PageLinks.MINE_WATCHED);
        addLink(m, C.menuMyStarredChanges(), PageLinks.MINE_STARRED);
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        addLink(m, C.menuProjects(), PageLinks.ADMIN_PROJECTS);
        menuLeft.add(m, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        menuRight.add(anchor(C.menuSignOut(), "logout"));
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", "become"));
                break;
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.ALL_OPEN);
    addLink(m, C.menuAllMerged(), PageLinks.ALL_MERGED);
    addLink(m, C.menuAllAbandoned(), PageLinks.ALL_ABANDONED);
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.MINE_DRAFTS);
        addLink(m, C.menuMyWatchedChanges(), PageLinks.MINE_WATCHED);
        addLink(m, C.menuMyStarredChanges(), PageLinks.MINE_STARRED);
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        addLink(m, C.menuProjects(), PageLinks.ADMIN_PROJECTS);
        menuLeft.add(m, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        menuRight.add(anchor(C.menuSignOut(), "logout"));
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", "become"));
                break;
        }
    }
}
#end_block

#method_before
@Override
public Set<NameKey> getWatchedProjects() {
    if (watchedProjects == null) {
        if (dbProvider == null) {
            throw new OutOfScopeException("Not in request scoped user");
        }
        final Set<Project.NameKey> h = new HashSet<Project.NameKey>();
        try {
            for (AccountProjectWatch projectWatch : dbProvider.get().accountProjectWatches().byAccount(getAccountId()).toList()) {
                h.add(projectWatch.getProjectNameKey());
            }
        } catch (ProvisionException e) {
            log.warn("Cannot query project watches of a user", e);
        } catch (OrmException e) {
            log.warn("Cannot query project watches of a user", e);
        }
        watchedProjects = Collections.unmodifiableSet(h);
    }
    return watchedProjects;
}
#method_after
@Override
public Set<Project.NameKey> getWatchedProjects() {
    if (watchedProjects == null) {
        if (dbProvider == null) {
            throw new OutOfScopeException("Not in request scoped user");
        }
        final Set<Project.NameKey> h = new HashSet<Project.NameKey>();
        try {
            for (AccountProjectWatch projectWatch : dbProvider.get().accountProjectWatches().byAccount(getAccountId())) {
                h.add(projectWatch.getProjectNameKey());
            }
        } catch (OrmException e) {
            log.warn("Cannot query project watches of a user", e);
        }
        watchedProjects = Collections.unmodifiableSet(h);
    }
    return watchedProjects;
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException {
    // TODO(jeffschu) correctly handle file renames
    // TODO(jeffschu) correctly handle merge commits
    // TODO(jeffschu) implement whitespace ignore
    final RevWalk rw = new RevWalk(repo);
    final RevCommit b = rw.parseCommit(key.getNewId());
    final AnyObjectId a = aFor(key, repo, b);
    if (a == null) {
        return new PatchList(a, b, computeIntraline, new PatchListEntry[0]);
    }
    RevTree aTree = rw.parseTree(a);
    RevTree bTree = b.getTree();
    final TreeWalk walk = new TreeWalk(repo);
    walk.reset();
    walk.setRecursive(true);
    walk.addTree(aTree);
    walk.addTree(bTree);
    walk.setFilter(TreeFilter.ANY_DIFF);
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    PrintStream ps = new PrintStream(buf);
    while (walk.next()) {
        outputDiff(ps, walk.getPathString(), walk.getObjectId(0), walk.getFileMode(0), walk.getObjectId(1), walk.getFileMode(1), repo);
    }
    org.eclipse.jgit.patch.Patch p = new org.eclipse.jgit.patch.Patch();
    p.parse(new ByteArrayInputStream(buf.toByteArray()));
    final int cnt = p.getFiles().size();
    final PatchListEntry[] entries = new PatchListEntry[cnt];
    for (int i = 0; i < cnt; i++) {
        entries[i] = newEntry(repo, aTree, bTree, p.getFiles().get(i));
    }
    return new PatchList(a, b, computeIntraline, entries);
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException {
    // TODO(jeffschu) correctly handle file renames
    // TODO(jeffschu) correctly handle merge commits
    // TODO(jeffschu) implement whitespace ignore
    final RevWalk rw = new RevWalk(repo);
    final RevCommit b = rw.parseCommit(key.getNewId());
    final AnyObjectId a = aFor(key, repo, b);
    if (a == null) {
        return new PatchList(a, b, computeIntraline, new PatchListEntry[0]);
    }
    RevTree aTree = rw.parseTree(a);
    RevTree bTree = b.getTree();
    final TreeWalk walk = new TreeWalk(repo);
    walk.reset();
    walk.setRecursive(true);
    walk.addTree(aTree);
    walk.addTree(bTree);
    walk.setFilter(TreeFilter.ANY_DIFF);
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    PrintStream ps = new PrintStream(buf, true, "UTF-8");
    while (walk.next()) {
        outputDiff(ps, walk.getPathString(), walk.getObjectId(0), walk.getFileMode(0), walk.getObjectId(1), walk.getFileMode(1), repo);
    }
    org.eclipse.jgit.patch.Patch p = new org.eclipse.jgit.patch.Patch();
    ps.flush();
    p.parse(new ByteArrayInputStream(buf.toByteArray()));
    final int cnt = p.getFiles().size();
    final PatchListEntry[] entries = new PatchListEntry[cnt];
    for (int i = 0; i < cnt; i++) {
        entries[i] = newEntry(repo, aTree, bTree, p.getFiles().get(i));
    }
    return new PatchList(a, b, computeIntraline, entries);
}
#end_block

#method_before
private void outputDiff(PrintStream out, String path, ObjectId id1, FileMode mode1, ObjectId id2, FileMode mode2, Repository repo) throws IOException {
    DiffFormatter fmt = new DiffFormatter();
    String name1 = "a/" + path;
    String name2 = "b/" + path;
    out.println("diff --git " + name1 + " " + name2);
    boolean isNew = false;
    boolean isDelete = false;
    if (id1.equals(ObjectId.zeroId())) {
        out.println("new file mode " + mode2);
        isNew = true;
    } else if (id2.equals(ObjectId.zeroId())) {
        out.println("deleted file mode " + mode1);
        isDelete = true;
    } else if (!mode1.equals(mode2)) {
        out.println("old mode " + mode1);
        out.println("new mode " + mode2);
    }
    out.println("index " + id1.abbreviate(repo, 7).name() + ".." + id2.abbreviate(repo, 7).name() + (mode1.equals(mode2) ? " " + mode1 : ""));
    out.println("--- " + (isNew ? "/dev/null" : name1));
    out.println("+++ " + (isDelete ? "/dev/null" : name2));
    RawText a = getRawText(id1, repo);
    RawText b = getRawText(id2, repo);
    MyersDiff diff = new MyersDiff(a, b);
    fmt.formatEdits(out, a, b, diff.getEdits());
}
#method_after
private void outputDiff(PrintStream out, String path, ObjectId id1, FileMode mode1, ObjectId id2, FileMode mode2, Repository repo) throws IOException {
    DiffFormatter fmt = new DiffFormatter();
    String name1 = "a/" + path;
    if (needsQuoting(name1)) {
        name1 = QuotedString.GIT_PATH.quote(name1);
    }
    String name2 = "b/" + path;
    if (needsQuoting(name2)) {
        name2 = QuotedString.GIT_PATH.quote(name2);
    }
    out.print("diff --git " + name1 + " " + name2 + "\n");
    boolean isNew = FileMode.MISSING.equals(mode1);
    boolean isDelete = FileMode.MISSING.equals(mode2);
    if (isNew) {
        out.print("new file mode " + mode2 + "\n");
    } else if (isDelete) {
        out.print("deleted file mode " + mode1 + "\n");
    } else if (!mode1.equals(mode2)) {
        out.print("old mode " + mode1 + "\n");
        out.print("new mode " + mode2 + "\n");
    }
    out.print("index " + id1.abbreviate(repo, 7).name() + ".." + id2.abbreviate(repo, 7).name() + (mode1.equals(mode2) ? " " + mode1 : "") + "\n");
    out.print("--- " + (isNew ? "/dev/null" : name1) + "\n");
    out.print("+++ " + (isDelete ? "/dev/null" : name2) + "\n");
    RawText a = getRawText(id1, repo);
    RawText b = getRawText(id2, repo);
    MyersDiff diff = new MyersDiff(a, b);
    fmt.formatEdits(out, a, b, diff.getEdits());
}
#end_block

#method_before
private RawText getRawText(ObjectId id, Repository repo) throws IOException {
    if (id.equals(ObjectId.zeroId()))
        return new RawText(new byte[] {});
    return new RawText(repo.openBlob(id).getCachedBytes());
}
#method_after
private RawText getRawText(ObjectId id, Repository repo) throws IOException {
    if (id.equals(ObjectId.zeroId())) {
        return new RawText(new byte[] {});
    }
    return new RawText(repo.openBlob(id).getCachedBytes());
}
#end_block

#method_before
static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final String cacheName = CACHE_NAME;
            final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type = new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {
            };
            // 
            core(type, cacheName).memoryLimit(// reasonable default for many sites
            1024).maxAge(12, // expire sessions if they are inactive
            HOURS).evictionPolicy(// keep most recently used
            EvictionPolicy.LRU);
            bind(WebSession.class).in(RequestScoped.class);
        }
    };
}
#method_after
static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type = new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {
            };
            // 
            core(type, CACHE_NAME).memoryLimit(// reasonable default for many sites
            1024).maxAge(12, // expire sessions if they are inactive
            HOURS).evictionPolicy(// keep most recently used
            EvictionPolicy.LRU);
            bind(WebSession.class).in(RequestScoped.class);
            bind(WebSession.KeyGenerator.class).in(SINGLETON);
        }
    };
}
#end_block

#method_before
static long now() {
    return System.currentTimeMillis();
}
#method_after
private static long now() {
    return System.currentTimeMillis();
}
#end_block

#method_before
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
    }
    key = createKey(id);
    session = createSession(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
public void login(final AuthResult res, final boolean rememberMe) throws OrmException {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
    }
    key = createKey(id);
    session = createSession(key, id, rememberMe, identity, null);
    saveCookie();
}
#end_block

#method_before
void setUserAccountId(Account.Id id) {
    key = new ActiveSession.Key("id:" + id);
    session = new ActiveSession(key, id, 0, false, null, "");
}
#method_after
void setUserAccountId(Account.Id id) {
    key = new ActiveSession.Key("id:" + id);
    session = new ActiveSession(key, id, new Timestamp(0), false, null, "");
}
#end_block

#method_before
public void logout() {
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
        saveCookie();
    }
}
#method_after
public void logout() {
    if (session != null) {
        try {
            destroy(key);
        } catch (OrmException e) {
            log.error("Could not remove session key from cache", e);
        }
        key = null;
        session = null;
        saveCookie();
    }
}
#end_block

#method_before
ActiveSession.Key createKey(final Account.Id who) {
    try {
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        buf = new ByteArrayOutputStream(3 + nonceLen);
        writeVarInt32(buf, who.get());
        writeBytes(buf, rnd);
        return new ActiveSession.Key(CookieBase64.encode(buf.toByteArray()));
    } catch (IOException e) {
        throw new RuntimeException("Cannot produce new account cookie", e);
    }
}
#method_after
private ActiveSession.Key createKey(final Account.Id who) {
    try {
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        buf = new ByteArrayOutputStream(3 + nonceLen);
        writeVarInt32(buf, who.get());
        writeBytes(buf, rnd);
        return new ActiveSession.Key(CookieBase64.encode(buf.toByteArray()));
    } catch (IOException e) {
        throw new RuntimeException("Cannot produce new account cookie", e);
    }
}
#end_block

#method_before
ActiveSession createSession(final ActiveSession.Key key, final ActiveSession session) {
    final Account.Id who = session.getAccountId();
    final boolean remember = session.isPersistentCookie();
    final AccountExternalId.Key lastLogin = session.getExternalId();
    final String xsrfToken = session.getXsrfToken();
    return createSession(key, who, remember, lastLogin, xsrfToken);
}
#method_after
private ActiveSession createSession(final ActiveSession.Key key, final ActiveSession session) throws OrmException {
    final Account.Id who = session.getAccountId();
    final boolean remember = session.isPersistentCookie();
    final AccountExternalId.Key lastLogin = session.getExternalId();
    final String xsrfToken = session.getXsrfToken();
    return createSession(key, who, remember, lastLogin, xsrfToken);
}
#end_block

#method_before
ActiveSession createSession(final ActiveSession.Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = cache.getTimeToLive(MILLISECONDS) >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    ActiveSession session = new ActiveSession(key, who, refreshCookieAt, remember, lastLogin, xsrfToken);
    cache.put(key, session);
    return session;
}
#method_after
private ActiveSession createSession(final ActiveSession.Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) throws OrmException {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = cache.getTimeToLive(MILLISECONDS) >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    ActiveSession session = new ActiveSession(key, who, new Timestamp(refreshCookieAt), remember, lastLogin, xsrfToken);
    put(session);
    return session;
}
#end_block

#method_before
int getCookieAge(final ActiveSession session) {
    if (session.isPersistentCookie()) {
        // 
        return (int) cache.getTimeToLive(SECONDS);
    } else {
        // 
        return -1;
    }
}
#method_after
private int getCookieAge(final ActiveSession session) {
    if (session.isPersistentCookie()) {
        // 
        return (int) cache.getTimeToLive(SECONDS);
    } else {
        // 
        return -1;
    }
}
#end_block

#method_before
ActiveSession get(final ActiveSession.Key key) {
    return cache.get(key);
}
#method_after
private ActiveSession get(final ActiveSession.Key key) throws OrmException {
    ActiveSession as = cache.get(key);
    final ActiveSessionAccess activeSessions = schema.activeSessions();
    if (as == null) {
        as = activeSessions.get(key);
        if (as == null) {
            return null;
        } else {
            if (expiredFromCache(as)) {
                destroy(key);
                return null;
            } else if (needsCacheRefresh(as)) {
                as.updateLastSeen();
                put(as);
            }
            return as;
        }
    } else {
        if (needsCacheRefresh(as)) {
            as.updateLastSeen();
            put(as);
        }
        return as;
    }
}
#end_block

#method_before
void destroy(final ActiveSession.Key key) {
    cache.remove(key);
}
#method_after
private void destroy(final ActiveSession.Key key) throws OrmException {
    schema.activeSessions().deleteKeys(Arrays.asList(key));
    cache.remove(key);
}
#end_block

#method_before
public long getRefreshCookieAt() {
    return refreshCookieAt;
}
#method_after
public Timestamp getRefreshCookieAt() {
    return refreshCookieAt;
}
#end_block

#method_before
public void setRefreshCookieAt(long refreshCookieAt) {
    this.refreshCookieAt = refreshCookieAt;
}
#method_after
public void setRefreshCookieAt(Timestamp refreshCookieAt) {
    this.refreshCookieAt = refreshCookieAt;
}
#end_block

#method_before
public boolean needsCookieRefresh() {
    return refreshCookieAt <= System.currentTimeMillis();
}
#method_after
public boolean needsCookieRefresh() {
    return refreshCookieAt.before(now());
}
#end_block

#method_before
private void publishApprovals() throws OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final List<ApprovalCategoryValue.Id> ignore = new ArrayList<ApprovalCategoryValue.Id>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            if (want.get() != 0) {
                a = new PatchSetApproval(new PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
                a.cache(change);
                ins.add(a);
                all.add(a);
                mine.put(a.getCategoryId(), a);
                dirty.add(a.getCategoryId());
            } else {
                ignore.add(want);
            }
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(change, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        if (ignore.indexOf(want) == -1) {
            final PatchSetApproval a = mine.get(want.getParentKey());
            final short o = a.getValue();
            a.setValue(want.get());
            a.cache(change);
            functionState.normalize(types.getApprovalType(a.getCategoryId()), a);
            if (o != a.getValue()) {
                // Value changed, ensure we update the database.
                // 
                a.setGranted();
                dirty.add(a.getCategoryId());
            }
            if (!ins.contains(a)) {
                upd.add(a);
            }
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#method_after
private void publishApprovals() throws OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(change, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        functionState.normalize(types.getApprovalType(a.getCategoryId()), a);
        if (o != a.getValue()) {
            // Value changed, ensure we update the database.
            // 
            a.setGranted();
            dirty.add(a.getCategoryId());
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    message(msgbuf.toString());
}
#end_block

