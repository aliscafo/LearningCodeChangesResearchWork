285
#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    post(PROJECT_KIND, "check.access").to(CheckAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    put(PROJECT_KIND, "access:review").to(CreateAccessChange.class);
    post(PROJECT_KIND, "check.access").to(CheckAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
@Override
public AccessCheckInfo checkAccess(AccessCheckInput in) throws RestApiException {
    try {
        ProjectResource r = checkExists();
        return checkAccess.apply(r, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot post check access", e);
    }
}
#method_after
@Override
public AccessCheckInfo checkAccess(AccessCheckInput in) throws RestApiException {
    try {
        return checkAccess.apply(checkExists(), in);
    } catch (Exception e) {
        throw asRestApiException("Cannot check access rights", e);
    }
}
#end_block

#method_before
@Override
public ListRefsRequest<BranchInfo> branches() {
    return new ListRefsRequest<BranchInfo>() {

        @Override
        public List<BranchInfo> get() throws RestApiException {
            return listBranches(this);
        }
    };
}
#method_after
@Override
public ListRefsRequest<BranchInfo> branches() {
    return new ListRefsRequest<BranchInfo>() {

        @Override
        public List<BranchInfo> get() throws RestApiException {
            try {
                return listBranches.get().request(this).apply(checkExists());
            } catch (Exception e) {
                throw asRestApiException("Cannot list branches", e);
            }
        }
    };
}
#end_block

#method_before
@Override
public ListRefsRequest<TagInfo> tags() {
    return new ListRefsRequest<TagInfo>() {

        @Override
        public List<TagInfo> get() throws RestApiException {
            return listTags(this);
        }
    };
}
#method_after
@Override
public ListRefsRequest<TagInfo> tags() {
    return new ListRefsRequest<TagInfo>() {

        @Override
        public List<TagInfo> get() throws RestApiException {
            try {
                return listTags.get().request(this).apply(checkExists());
            } catch (Exception e) {
                throw asRestApiException("Cannot list tags", e);
            }
        }
    };
}
#end_block

#method_before
@Override
public AccessCheckInfo apply(ProjectResource rsrc, AccessCheckInput input) throws OrmException, PermissionBackendException, RestApiException, IOException, ConfigInvalidException {
    permissionBackend.user(currentUser.get()).check(GlobalPermission.ADMINISTRATE_SERVER);
    if (input == null) {
        throw new BadRequestException("input is required");
    }
    if (Strings.isNullOrEmpty(input.account)) {
        throw new BadRequestException("input requires 'account'");
    }
    Account match = accountResolver.find(db.get(), input.account);
    if (match == null) {
        throw new BadRequestException(String.format("cannot find account %s", input.account));
    }
    AccessCheckInfo info = new AccessCheckInfo();
    IdentifiedUser user = userFactory.create(match.getId());
    try {
        permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.ACCESS);
    } catch (AuthException | PermissionBackendException e) {
        info.message = String.format("user %s (%s) cannot see project %s", user.getNameEmail(), user.getAccount().getId(), rsrc.getName());
        info.status = HttpServletResponse.SC_FORBIDDEN;
        return info;
    }
    if (!Strings.isNullOrEmpty(input.ref)) {
        try {
            permissionBackend.user(user).ref(new Branch.NameKey(rsrc.getNameKey(), input.ref)).check(RefPermission.READ);
        } catch (AuthException | PermissionBackendException e) {
            info.status = HttpServletResponse.SC_FORBIDDEN;
            info.message = String.format("user %s (%s) cannot see ref %s in project %s", user.getNameEmail(), user.getAccount().getId(), input.ref, rsrc.getName());
            return info;
        }
    }
    info.status = HttpServletResponse.SC_OK;
    return info;
}
#method_after
@Override
public AccessCheckInfo apply(ProjectResource rsrc, AccessCheckInput input) throws OrmException, PermissionBackendException, RestApiException, IOException, ConfigInvalidException {
    permissionBackend.user(rsrc.getUser()).check(GlobalPermission.ADMINISTRATE_SERVER);
    if (input == null) {
        throw new BadRequestException("input is required");
    }
    if (Strings.isNullOrEmpty(input.account)) {
        throw new BadRequestException("input requires 'account'");
    }
    Account match = accountResolver.find(db.get(), input.account);
    if (match == null) {
        throw new UnprocessableEntityException(String.format("cannot find account %s", input.account));
    }
    AccessCheckInfo info = new AccessCheckInfo();
    IdentifiedUser user = userFactory.create(match.getId());
    try {
        permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.ACCESS);
    } catch (AuthException | PermissionBackendException e) {
        info.message = String.format("user %s (%s) cannot see project %s", user.getNameEmail(), user.getAccount().getId(), rsrc.getName());
        info.status = HttpServletResponse.SC_FORBIDDEN;
        return info;
    }
    if (!Strings.isNullOrEmpty(input.ref)) {
        try {
            permissionBackend.user(user).ref(new Branch.NameKey(rsrc.getNameKey(), input.ref)).check(RefPermission.READ);
        } catch (AuthException | PermissionBackendException e) {
            info.status = HttpServletResponse.SC_FORBIDDEN;
            info.message = String.format("user %s (%s) cannot see ref %s in project %s", user.getNameEmail(), user.getAccount().getId(), input.ref, rsrc.getName());
            return info;
        }
    }
    info.status = HttpServletResponse.SC_OK;
    return info;
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, DeleteEdit.Input input) throws AuthException, ResourceConflictException, BadRequestException, IOException, OrmException, InvalidChangeOperationException {
    return deleteEditFactory.create(rsrc.getChange(), null).apply(rsrc, input);
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws AuthException, BadRequestException, IOException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        editUtil.delete(edit.get());
    } else {
        throw new BadRequestException("change edit doesn't exist");
    }
    return Response.none();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteEdit.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteEdit.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
public PatchScript call() throws OrmException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    PatchSet psEntityA = psa != null ? psUtil.get(db, notes, psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, notes, psb);
    ChangeControl ctl = changeControlFactory.controlFor(notes, userProvider.get());
    if ((psEntityA != null && !ctl.isPatchVisible(psEntityA, db)) || (psEntityB != null && !ctl.isPatchVisible(psEntityB, db))) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = repoManager.openRepository(project)) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(ctl, content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + project + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + project, e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#method_after
@Override
public PatchScript call() throws OrmException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    PatchSet psEntityA = psa != null ? psUtil.get(db, notes, psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, notes, psb);
    ChangeControl ctl = changeControlFactory.controlFor(notes, userProvider.get());
    if ((psEntityA != null && !ctl.isPatchVisible(psEntityA, db)) || (psEntityB != null && !ctl.isPatchVisible(psEntityB, db))) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = repoManager.openRepository(notes.getProjectName())) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(ctl, content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + notes.getProjectName() + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + notes.getProjectName(), e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#end_block

#method_before
private PatchList listFor(PatchListKey key) throws PatchListNotAvailableException {
    return patchListCache.get(key, project);
}
#method_after
private PatchList listFor(PatchListKey key) throws PatchListNotAvailableException {
    return patchListCache.get(key, notes.getProjectName());
}
#end_block

#method_before
private PatchScriptBuilder newBuilder(PatchList list, Repository git) {
    final PatchScriptBuilder b = builderFactory.get();
    b.setRepository(git, project);
    b.setChange(change);
    b.setDiffPrefs(diffPrefs);
    b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId());
    return b;
}
#method_after
private PatchScriptBuilder newBuilder(PatchList list, Repository git) {
    final PatchScriptBuilder b = builderFactory.get();
    b.setRepository(git, notes.getProjectName());
    b.setChange(notes.getChange());
    b.setDiffPrefs(diffPrefs);
    b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId());
    return b;
}
#end_block

#method_before
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(notes);
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(change.getId());
}
#method_after
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(notes);
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(notes.getChangeId());
}
#end_block

#method_before
private void loadPublished(Map<Patch.Key, Patch> byKey, String file) throws OrmException {
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#method_after
private void loadPublished(Map<Patch.Key, Patch> byKey, String file) throws OrmException {
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        comments.include(notes.getChangeId(), c);
        PatchSet.Id psId = new PatchSet.Id(notes.getChangeId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#end_block

#method_before
private void loadDrafts(Map<Patch.Key, Patch> byKey, Account.Id me, String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, notes, file, me)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#method_after
private void loadDrafts(Map<Patch.Key, Patch> byKey, Account.Id me, String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, notes, file, me)) {
        comments.include(notes.getChangeId(), c);
        PatchSet.Id psId = new PatchSet.Id(notes.getChangeId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#end_block

#method_before
@Override
public OAuthService createService(OAuthConfig config) {
    // return new OAuth20ServiceImpl(this,config); // TODO can't use this until updating to newer scribe lib
    return new DexOAuthService(this, config);
}
#method_after
@Override
public OAuthService createService(OAuthConfig config) {
    // return new OAuth20ServiceImpl(this,config);
    return new DexOAuthService(this, config);
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().change(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().change(u.notes.getChange()).subject(subject).draft(u.replaceOp != null && u.replaceOp.getPatchSet().isDraft()).edit(edit)._private(isPrivate).wip(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsDraft(u.replaceOp != null && u.replaceOp.getPatchSet().isDraft()).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
}
#end_block

#method_before
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, changeFormatter.changeClosed(ChangeReportFormatter.Input.builder().change(change).build()));
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, changeFormatter.changeClosed(ChangeReportFormatter.Input.builder().setChange(change).build()));
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private MergeableFileBasedConfig newConfig() {
    return new MergeableFileBasedConfig(new File(tempDir, counter.incrementAndGet() + ".config"), FS.detect());
}
#method_after
private MergeableFileBasedConfig newConfig() throws Exception {
    File f = File.createTempFile(getClass().getSimpleName(), ".config");
    f.deleteOnExit();
    return new MergeableFileBasedConfig(f, FS.detect());
}
#end_block

#method_before
private String formatChangeUrl(String url, Input input) {
    Change change = input.getChange();
    StringBuilder m = new StringBuilder().append("  ").append(ChangeUtil.formatChangeUrl(url, change)).append(" ").append(ChangeUtil.cropSubject(input.getSubject()));
    if (input.isDraft()) {
        m.append(" [DRAFT]");
    }
    if (input.isEdit()) {
        m.append(" [EDIT]");
    }
    if (input.isPrivate()) {
        m.append(" [PRIVATE]");
    }
    if (input.isWorkInProgress()) {
        m.append(" [WIP]");
    }
    return m.toString();
}
#method_after
private String formatChangeUrl(String url, Input input) {
    StringBuilder m = new StringBuilder().append("  ").append(ChangeUtil.formatChangeUrl(url, input.getChange())).append(" ").append(ChangeUtil.cropSubject(input.getSubject()));
    if (input.isDraft()) {
        m.append(" [DRAFT]");
    }
    if (input.isEdit()) {
        m.append(" [EDIT]");
    }
    if (input.isPrivate()) {
        m.append(" [PRIVATE]");
    }
    if (input.isWorkInProgress()) {
        m.append(" [WIP]");
    }
    return m.toString();
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws RestApiException, OrmException, IOException {
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = rsrc.getProject();
    return includedIn.apply(project, ps.getRevision().get());
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws RestApiException, OrmException, IOException {
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    return includedIn.apply(rsrc.getProject(), ps.getRevision().get());
}
#end_block

#method_before
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(control.getNotes(), control.getUser());
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(change.getId());
}
#method_after
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(control.getNotes());
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(change.getId());
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String keyStr = req.getPathInfo();
    // We shouldn't have to do this extra decode pass, but somehow we
    // are now receiving our "^1" suffix as "%5E1", which confuses us
    // downstream. Other times we get our embedded "," as "%2C", which
    // is equally bad. And yet when these happen a "%2F" is left as-is,
    // rather than escaped as "%252F", which makes me feel really really
    // uncomfortable with a blind decode right here.
    // 
    keyStr = Url.decode(keyStr);
    if (!keyStr.startsWith("/")) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    keyStr = keyStr.substring(1);
    final Patch.Key patchKey;
    final int side;
    {
        final int c = keyStr.lastIndexOf('^');
        if (c == 0) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        if (c < 0) {
            side = 0;
        } else {
            try {
                side = Integer.parseInt(keyStr.substring(c + 1));
                keyStr = keyStr.substring(0, c);
            } catch (NumberFormatException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
        }
        try {
            patchKey = Patch.Key.parse(keyStr);
        } catch (NumberFormatException e) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
    }
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    String revision;
    try {
        ChangeNotes notes = changeNotesFactory.createChecked(changeId);
        permissionBackend.user(userProvider).change(notes).database(requestDb).check(ChangePermission.READ);
        if (patchKey.getParentKey().get() == 0) {
            // change edit
            Optional<ChangeEdit> edit = changeEditUtil.byChange(notes, userProvider.get());
            if (edit.isPresent()) {
                revision = ObjectId.toString(edit.get().getEditCommit());
            } else {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
        } else {
            PatchSet patchSet = psUtil.get(requestDb.get(), notes, patchKey.getParentKey());
            if (patchSet == null) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            revision = patchSet.getRevision().get();
        }
    } catch (NoSuchChangeException | AuthException e) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    } catch (OrmException | PermissionBackendException e) {
        getServletContext().log("Cannot query database", e);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        return;
    }
    String path = patchKey.getFileName();
    String restUrl = String.format("%s/changes/%d/revisions/%s/files/%s/download?parent=%d", req.getContextPath(), changeId.get(), revision, Url.encode(path), side);
    rsp.sendRedirect(restUrl);
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String keyStr = req.getPathInfo();
    // We shouldn't have to do this extra decode pass, but somehow we
    // are now receiving our "^1" suffix as "%5E1", which confuses us
    // downstream. Other times we get our embedded "," as "%2C", which
    // is equally bad. And yet when these happen a "%2F" is left as-is,
    // rather than escaped as "%252F", which makes me feel really really
    // uncomfortable with a blind decode right here.
    // 
    keyStr = Url.decode(keyStr);
    if (!keyStr.startsWith("/")) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    keyStr = keyStr.substring(1);
    final Patch.Key patchKey;
    final int side;
    {
        final int c = keyStr.lastIndexOf('^');
        if (c == 0) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        if (c < 0) {
            side = 0;
        } else {
            try {
                side = Integer.parseInt(keyStr.substring(c + 1));
                keyStr = keyStr.substring(0, c);
            } catch (NumberFormatException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
        }
        try {
            patchKey = Patch.Key.parse(keyStr);
        } catch (NumberFormatException e) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
    }
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    String revision;
    try {
        ChangeNotes notes = changeNotesFactory.createChecked(changeId);
        permissionBackend.user(userProvider).change(notes).database(requestDb).check(ChangePermission.READ);
        if (patchKey.getParentKey().get() == 0) {
            // change edit
            Optional<ChangeEdit> edit = changeEditUtil.byChange(notes);
            if (edit.isPresent()) {
                revision = ObjectId.toString(edit.get().getEditCommit());
            } else {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
        } else {
            PatchSet patchSet = psUtil.get(requestDb.get(), notes, patchKey.getParentKey());
            if (patchSet == null) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            revision = patchSet.getRevision().get();
        }
    } catch (NoSuchChangeException | AuthException e) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    } catch (OrmException | PermissionBackendException e) {
        getServletContext().log("Cannot query database", e);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        return;
    }
    String path = patchKey.getFileName();
    String restUrl = String.format("%s/changes/%d/revisions/%s/files/%s/download?parent=%d", req.getContextPath(), changeId.get(), revision, Url.encode(path), side);
    rsp.sendRedirect(restUrl);
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(ChangeNotes notes, CurrentUser user) throws AuthException, IOException {
    if (!user.isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser u = user.asIdentifiedUser();
    Change change = notes.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(u.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.empty();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(notes, ref);
            return Optional.of(new ChangeEdit(change, ref.getName(), commit, basePs));
        }
    }
}
#method_after
public Optional<ChangeEdit> byChange(ChangeNotes notes) throws AuthException, IOException {
    return byChange(notes, userProvider.get());
}
#end_block

#method_before
private List<RevisionResource> loadEdit(ChangeResource change, RevId revid) throws AuthException, IOException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(change.getNotes(), change.getUser());
    if (edit.isPresent()) {
        PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), 0));
        RevId editRevId = new RevId(ObjectId.toString(edit.get().getEditCommit()));
        ps.setRevision(editRevId);
        if (revid == null || editRevId.equals(revid)) {
            return Collections.singletonList(new RevisionResource(change, ps, edit));
        }
    }
    return Collections.emptyList();
}
#method_after
private List<RevisionResource> loadEdit(ChangeResource change, RevId revid) throws AuthException, IOException {
    Optional<ChangeEdit> edit = editUtil.byChange(change.getNotes(), change.getUser());
    if (edit.isPresent()) {
        PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), 0));
        RevId editRevId = new RevId(ObjectId.toString(edit.get().getEditCommit()));
        ps.setRevision(editRevId);
        if (revid == null || editRevId.equals(revid)) {
            return Collections.singletonList(new RevisionResource(change, ps, edit));
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private Optional<ChangeEdit> lookupChangeEdit(ChangeNotes notes) throws AuthException, IOException {
    return changeEditUtil.byChange(notes, currentUser.get());
}
#method_after
private Optional<ChangeEdit> lookupChangeEdit(ChangeNotes notes) throws AuthException, IOException {
    return changeEditUtil.byChange(notes);
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeMessage(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            addMessage(formatChangeMessage(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeMessage(canonicalWebUrl, c.change, c.change.getSubject(), c.change.getStatus() == Change.Status.DRAFT, // edit
            false, c.change.isPrivate(), c.change.isWorkInProgress()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            addMessage(formatChangeMessage(canonicalWebUrl, u.notes.getChange(), subject, u.replaceOp != null && u.replaceOp.getPatchSet().isDraft(), edit, isPrivate, wip));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeMessage(String url, Change change, String subject, boolean draft, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(ChangeUtil.formatChangeUrl(url, change)).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    if (change.isPrivate()) {
        m.append(" [PRIVATE]");
    }
    if (change.isWorkInProgress()) {
        m.append(" [WIP]");
    }
    return m.toString();
}
#method_after
private static String formatChangeMessage(String url, Change change, String subject, boolean draft, boolean edit, boolean isPrivate, boolean wip) {
    StringBuilder m = new StringBuilder().append("  ").append(ChangeUtil.formatChangeUrl(url, change)).append(" ").append(ChangeUtil.cropSubject(subject));
    if (draft) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    if (isPrivate) {
        m.append(" [PRIVATE]");
    }
    if (wip) {
        m.append(" [WIP]");
    }
    return m.toString();
}
#end_block

#method_before
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + ChangeUtil.formatChangeUrl(canonicalWebUrl, change) + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
@Test
public void output() throws Exception {
    String url = canonicalWebUrl.get() + "#/c/" + project.get() + "/+/";
    ObjectId initialHead = testRepo.getRepository().resolve("HEAD");
    PushOneCommit.Result r1 = pushTo("refs/for/master");
    Change.Id id1 = r1.getChange().getId();
    r1.assertOkStatus();
    r1.assertChange(Change.Status.NEW, null);
    r1.assertMessage("New changes:\n  " + url + id1 + " " + r1.getCommit().getShortMessage() + "\n");
    testRepo.reset(initialHead);
    String newMsg = r1.getCommit().getShortMessage() + " v2";
    testRepo.branch("HEAD").commit().message(newMsg).insertChangeId(r1.getChangeId().substring(1)).create();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, "another commit", "b.txt", "bbb").to("refs/for/master");
    Change.Id id2 = r2.getChange().getId();
    r2.assertOkStatus();
    r2.assertChange(Change.Status.NEW, null);
    r2.assertMessage("New changes:\n" + "  " + url + id2 + " another commit\n" + "\n" + "\n" + "Updated changes:\n" + "  " + url + id1 + " " + newMsg + "\n");
    testRepo.reset(initialHead);
    newMsg = r2.getCommit().getShortMessage() + " v3";
    testRepo.branch("HEAD").commit().message(newMsg).insertChangeId(r2.getChangeId().substring(1)).create();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "another commit", "b.txt", "bbb");
    push.setPushOptions(ImmutableList.of("private", "wip"));
    PushOneCommit.Result r3 = push.to("refs/for/master");
    r3.assertOkStatus();
    r3.assertChange(Change.Status.NEW, null);
    r3.assertMessage(" [PRIVATE]");
    r3.assertMessage(" [WIP]");
}
#method_after
@Test
public void output() throws Exception {
    String url = canonicalWebUrl.get() + "#/c/" + project.get() + "/+/";
    ObjectId initialHead = testRepo.getRepository().resolve("HEAD");
    PushOneCommit.Result r1 = pushTo("refs/for/master");
    Change.Id id1 = r1.getChange().getId();
    r1.assertOkStatus();
    r1.assertChange(Change.Status.NEW, null);
    r1.assertMessage("New changes:\n  " + url + id1 + " " + r1.getCommit().getShortMessage() + "\n");
    testRepo.reset(initialHead);
    String newMsg = r1.getCommit().getShortMessage() + " v2";
    testRepo.branch("HEAD").commit().message(newMsg).insertChangeId(r1.getChangeId().substring(1)).create();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, "another commit", "b.txt", "bbb").to("refs/for/master");
    Change.Id id2 = r2.getChange().getId();
    r2.assertOkStatus();
    r2.assertChange(Change.Status.NEW, null);
    r2.assertMessage("New changes:\n" + "  " + url + id2 + " another commit\n" + "\n" + "\n" + "Updated changes:\n" + "  " + url + id1 + " " + newMsg + "\n");
}
#end_block

#method_before
@Test
public void pushPrivateChange() throws Exception {
    // Push a private change.
    PushOneCommit.Result r = pushTo("refs/for/master%private");
    r.assertOkStatus();
    assertThat(r.getChange().change().isPrivate()).isTrue();
    // Pushing a new patch set without --private doesn't remove the privacy flag from the change.
    r = amendChange(r.getChangeId(), "refs/for/master");
    r.assertOkStatus();
    assertThat(r.getChange().change().isPrivate()).isTrue();
    // Remove the privacy flag from the change.
    r = amendChange(r.getChangeId(), "refs/for/master%remove-private");
    r.assertOkStatus();
    assertThat(r.getChange().change().isPrivate()).isFalse();
    // Normal push: privacy flag is not added back.
    r = amendChange(r.getChangeId(), "refs/for/master");
    r.assertOkStatus();
    assertThat(r.getChange().change().isPrivate()).isFalse();
    // Make the change private again.
    r = pushTo("refs/for/master%private");
    r.assertOkStatus();
    assertThat(r.getChange().change().isPrivate()).isTrue();
    // Can't use --private and --remove-private together.
    r = pushTo("refs/for/master%private,remove-private");
    r.assertErrorStatus();
}
#method_after
@Test
public void pushPrivateChange() throws Exception {
    // Push a private change.
    PushOneCommit.Result r = pushTo("refs/for/master%private");
    r.assertOkStatus();
    r.assertMessage(" [PRIVATE]");
    assertThat(r.getChange().change().isPrivate()).isTrue();
    // Pushing a new patch set without --private doesn't remove the privacy flag from the change.
    r = amendChange(r.getChangeId(), "refs/for/master");
    r.assertOkStatus();
    r.assertMessage(" [PRIVATE]");
    assertThat(r.getChange().change().isPrivate()).isTrue();
    // Remove the privacy flag from the change.
    r = amendChange(r.getChangeId(), "refs/for/master%remove-private");
    r.assertOkStatus();
    r.assertNotMessage(" [PRIVATE]");
    assertThat(r.getChange().change().isPrivate()).isFalse();
    // Normal push: privacy flag is not added back.
    r = amendChange(r.getChangeId(), "refs/for/master");
    r.assertOkStatus();
    r.assertNotMessage(" [PRIVATE]");
    assertThat(r.getChange().change().isPrivate()).isFalse();
    // Make the change private again.
    r = pushTo("refs/for/master%private");
    r.assertOkStatus();
    r.assertMessage(" [PRIVATE]");
    assertThat(r.getChange().change().isPrivate()).isTrue();
    // Can't use --private and --remove-private together.
    r = pushTo("refs/for/master%private,remove-private");
    r.assertErrorStatus();
}
#end_block

#method_before
@Test
public void pushWorkInProgressChange() throws Exception {
    // Push a work-in-progress change.
    PushOneCommit.Result r = pushTo("refs/for/master%wip");
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
    // Pushing a new patch set without --wip doesn't remove the wip flag from the change.
    r = amendChange(r.getChangeId(), "refs/for/master");
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
    // Remove the wip flag from the change.
    r = amendChange(r.getChangeId(), "refs/for/master%ready");
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Normal push: wip flag is not added back.
    r = amendChange(r.getChangeId(), "refs/for/master");
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Make the change work-in-progress again.
    r = amendChange(r.getChangeId(), "refs/for/master%wip");
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
    // Can't use --wip and --ready together.
    r = amendChange(r.getChangeId(), "refs/for/master%wip,ready");
    r.assertErrorStatus();
}
#method_after
@Test
public void pushWorkInProgressChange() throws Exception {
    // Push a work-in-progress change.
    PushOneCommit.Result r = pushTo("refs/for/master%wip");
    r.assertOkStatus();
    r.assertMessage(" [WIP]");
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
    // Pushing a new patch set without --wip doesn't remove the wip flag from the change.
    r = amendChange(r.getChangeId(), "refs/for/master");
    r.assertOkStatus();
    r.assertMessage(" [WIP]");
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
    // Remove the wip flag from the change.
    r = amendChange(r.getChangeId(), "refs/for/master%ready");
    r.assertOkStatus();
    r.assertNotMessage(" [WIP]");
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Normal push: wip flag is not added back.
    r = amendChange(r.getChangeId(), "refs/for/master");
    r.assertOkStatus();
    r.assertNotMessage(" [WIP]");
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Make the change work-in-progress again.
    r = amendChange(r.getChangeId(), "refs/for/master%wip");
    r.assertOkStatus();
    r.assertMessage(" [WIP]");
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
    // Can't use --wip and --ready together.
    r = amendChange(r.getChangeId(), "refs/for/master%wip,ready");
    r.assertErrorStatus();
}
#end_block

#method_before
@Override
public ChangeInfo apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, UnprocessableEntityException, BadRequestException, InvalidNameException, ResourceConflictException {
    ProjectControl projectControl = rsrc.getControl();
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    PermissionBackend.ForRef metaRef = permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).ref(RefNames.REFS_CONFIG);
    try {
        metaRef.check(RefPermission.READ);
    } catch (AuthException denied) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!projectControl.isOwner()) {
        try {
            metaRef.check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validityChecks(projectControl, config, newParentProjectName, additions, removals);
        setAccess.cleanupPermissions(config, removals, additions);
        try {
            setAccess.updateParent(projectControl, config, newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), config.getProject().getNameKey(), projectControl.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidate(false).setUpdateRef(// Created by commitToNewRef.
            false));
            bu.execute();
        } catch (UpdateException | RestApiException e) {
            throw new IOException(e);
        }
        // TODO: add reviewers
        ChangeInfo result = new ChangeInfo();
        result._number = changeId.get();
        result.project = projectControl.getProject().getName();
        return result;
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, InvalidNameException, UpdateException, RestApiException {
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    PermissionBackend.ForRef metaRef = permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(RefNames.REFS_CONFIG);
    try {
        metaRef.check(RefPermission.READ);
    } catch (AuthException denied) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!rsrc.getControl().isOwner()) {
        try {
            metaRef.check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validateChanges(config, removals, additions);
        setAccess.applyChanges(config, removals, additions);
        try {
            setAccess.setParentName(rsrc.getUser().asIdentifiedUser(), config, rsrc.getNameKey(), newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setMessage("Review access change");
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), rsrc.getNameKey(), rsrc.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            ChangeInserter ins = changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG);
            ins.setMessage("First patchset").setValidate(false).setUpdateRef(false);
            bu.insertChange(ins);
            bu.execute();
            return Response.created(jsonFactory.noOptions().format(ins.getChange()));
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    put(PROJECT_KIND, "config:review").to(CreateAccessChange.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    put(PROJECT_KIND, "access:review").to(CreateAccessChange.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
@Test
public void missingRepo() throws Exception {
    // NoteDb can't have a change without a repo.
    assumeNoteDbDisabled();
    ChangeNotes notes = insertChange();
    Project.NameKey name = notes.getProjectName();
    // Create control before deleting repo to avoid NoSuchProjectException
    ChangeControl ctl = controlForNotes(notes);
    ((InMemoryRepositoryManager) repoManager).deleteRepository(name);
    assertThat(checker.check(ctl, null).problems()).containsExactlyElementsIn(ImmutableList.of(problem("Destination repository not found: " + name))).inOrder();
}
#method_after
@Test
public void missingRepo() throws Exception {
    // NoteDb can't have a change without a repo.
    assumeNoteDbDisabled();
    ChangeNotes notes = insertChange();
    Project.NameKey name = notes.getProjectName();
    // Create control before deleting repo to avoid NoSuchProjectException
    ChangeControl ctl = controlForNotes(notes);
    ((InMemoryRepositoryManager) repoManager).deleteRepository(name);
    assertThat(checker.check(ctl, null).problems()).containsExactly(problem("Destination repository not found: " + name));
}
#end_block

#method_before
@Test
public void onlyPatchSetObjectMissingWithFix() throws Exception {
    Change c = TestChanges.newChange(project, admin.getId(), sequences.nextChangeId());
    // Set review started, mimicking Schema_153, so tests pass with NoteDbMode.CHECK.
    c.setReviewStarted(true);
    PatchSet.Id psId = c.currentPatchSetId();
    String rev = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    PatchSet ps = newPatchSet(psId, rev, adminId);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        db.changes().insert(singleton(c));
        db.patchSets().insert(singleton(ps));
    }
    addNoteDbCommit(c.getId(), "Create change\n" + "\n" + "Patch-set: 1\n" + "Branch: " + c.getDest().get() + "\n" + "Change-id: " + c.getKey().get() + "\n" + "Subject: Bogus subject\n" + "Commit: " + rev + "\n" + "Groups: " + rev + "\n");
    indexer.index(db, c.getProject(), c.getId());
    IdentifiedUser user = userFactory.create(admin.getId());
    ChangeNotes notes = changeNotesFactory.create(db, c.getProject(), c.getId());
    FixInput fix = new FixInput();
    fix.deletePatchSetIfCommitMissing = true;
    assertProblems(notes, fix, problem("Ref missing: " + ps.getId().toRefName()), problem("Object missing: patch set 1: " + rev, FIX_FAILED, "Cannot delete patch set; no patch sets would remain"));
    notes = reload(notes);
    assertThat(notes.getChange().currentPatchSetId().get()).isEqualTo(1);
    assertThat(psUtil.current(db, notes)).isNotNull();
}
#method_after
@Test
public void onlyPatchSetObjectMissingWithFix() throws Exception {
    Change c = TestChanges.newChange(project, admin.getId(), sequences.nextChangeId());
    // Set review started, mimicking Schema_153, so tests pass with NoteDbMode.CHECK.
    c.setReviewStarted(true);
    PatchSet.Id psId = c.currentPatchSetId();
    String rev = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    PatchSet ps = newPatchSet(psId, rev, adminId);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        db.changes().insert(singleton(c));
        db.patchSets().insert(singleton(ps));
    }
    addNoteDbCommit(c.getId(), "Create change\n" + "\n" + "Patch-set: 1\n" + "Branch: " + c.getDest().get() + "\n" + "Change-id: " + c.getKey().get() + "\n" + "Subject: Bogus subject\n" + "Commit: " + rev + "\n" + "Groups: " + rev + "\n");
    indexer.index(db, c.getProject(), c.getId());
    ChangeNotes notes = changeNotesFactory.create(db, c.getProject(), c.getId());
    FixInput fix = new FixInput();
    fix.deletePatchSetIfCommitMissing = true;
    assertProblems(notes, fix, problem("Ref missing: " + ps.getId().toRefName()), problem("Object missing: patch set 1: " + rev, FIX_FAILED, "Cannot delete patch set; no patch sets would remain"));
    notes = reload(notes);
    assertThat(notes.getChange().currentPatchSetId().get()).isEqualTo(1);
    assertThat(psUtil.current(db, notes)).isNotNull();
}
#end_block

#method_before
private ChangeNotes insertChange(TestAccount owner, String dest) throws Exception {
    Change.Id id = new Change.Id(sequences.nextChangeId());
    ChangeInserter ins;
    try (BatchUpdate bu = newUpdate(owner.getId())) {
        RevCommit commit = patchSetCommit(new PatchSet.Id(id, 1));
        ins = changeInserterFactory.create(id, commit, dest).setValidate(false).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setSendMail(false);
        bu.insertChange(ins).execute();
    }
    // Return control for admin regardless of owner.
    return changeNotesFactory.create(db, project, ins.getChange().getId());
}
#method_after
private ChangeNotes insertChange(TestAccount owner, String dest) throws Exception {
    Change.Id id = new Change.Id(sequences.nextChangeId());
    ChangeInserter ins;
    try (BatchUpdate bu = newUpdate(owner.getId())) {
        RevCommit commit = patchSetCommit(new PatchSet.Id(id, 1));
        ins = changeInserterFactory.create(id, commit, dest).setValidate(false).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setSendMail(false);
        bu.insertChange(ins).execute();
    }
    return changeNotesFactory.create(db, project, ins.getChange().getId());
}
#end_block

#method_before
private void assertProblems(ChangeNotes notes, @Nullable FixInput fix, ProblemInfo first, ProblemInfo... rest) throws NoSuchChangeException {
    List<ProblemInfo> expected = new ArrayList<>(1 + rest.length);
    expected.add(first);
    expected.addAll(Arrays.asList(rest));
    assertThat(checker.check(controlForNotes(notes), fix).problems()).containsExactlyElementsIn(expected).inOrder();
}
#method_after
private void assertProblems(ChangeNotes notes, @Nullable FixInput fix, ProblemInfo first, ProblemInfo... rest) throws Exception {
    List<ProblemInfo> expected = new ArrayList<>(1 + rest.length);
    expected.add(first);
    expected.addAll(Arrays.asList(rest));
    assertThat(checker.check(controlForNotes(notes), fix).problems()).containsExactlyElementsIn(expected).inOrder();
}
#end_block

#method_before
private void assertNoProblems(ChangeNotes notes, @Nullable FixInput fix) throws NoSuchChangeException {
    assertThat(checker.check(controlForNotes(notes), fix).problems()).isEmpty();
}
#method_after
private void assertNoProblems(ChangeNotes notes, @Nullable FixInput fix) throws Exception {
    assertThat(checker.check(controlForNotes(notes), fix).problems()).isEmpty();
}
#end_block

#method_before
private ChangeControl controlForNotes(ChangeNotes notes) throws NoSuchChangeException {
    return changeControlFactory.controlFor(notes, userFactory.create(admin.id));
}
#method_after
private ChangeControl controlForNotes(ChangeNotes notes) throws Exception {
    return changeControlFactory.controlFor(notes, userFactory.create(admin.id));
}
#end_block

#method_before
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MoveInput input) throws RestApiException, OrmException, UpdateException, PermissionBackendException {
    Change change = rsrc.getChange();
    Project.NameKey project = rsrc.getProject();
    IdentifiedUser caller = rsrc.getUser();
    input.destinationBranch = RefNames.fullName(input.destinationBranch);
    if (change.getStatus().isClosed()) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Branch.NameKey newDest = new Branch.NameKey(project, input.destinationBranch);
    if (change.getDest().equals(newDest)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    // Move requires abandoning this change, and creating a new change.
    try {
        rsrc.permissions().database(dbProvider).check(ChangePermission.ABANDON);
        permissionBackend.user(caller).database(dbProvider).ref(newDest).check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        throw new AuthException("move not permitted", denied);
    }
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, caller, TimeUtil.nowTs())) {
        u.addOp(change.getId(), new Op(input));
        u.execute();
    }
    return json.noOptions().format(project, rsrc.getId());
}
#method_after
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MoveInput input) throws RestApiException, OrmException, UpdateException, PermissionBackendException {
    Change change = rsrc.getChange();
    Project.NameKey project = rsrc.getProject();
    IdentifiedUser caller = rsrc.getUser();
    input.destinationBranch = RefNames.fullName(input.destinationBranch);
    if (change.getStatus().isClosed()) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Branch.NameKey newDest = new Branch.NameKey(project, input.destinationBranch);
    if (change.getDest().equals(newDest)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    // Move requires abandoning this change, and creating a new change.
    try {
        rsrc.permissions().database(dbProvider).check(ABANDON);
        permissionBackend.user(caller).database(dbProvider).ref(newDest).check(CREATE_CHANGE);
    } catch (AuthException denied) {
        throw new AuthException("move not permitted", denied);
    }
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, caller, TimeUtil.nowTs())) {
        u.addOp(change.getId(), new Op(input));
        u.execute();
    }
    return json.noOptions().format(project, rsrc.getId());
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Move Change").setTitle("Move change to a different branch").setVisible(!(change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) && permissionBackend.user(rsrc.getUser()).ref(change.getDest()).testOrFalse(CREATE_CHANGE) && rsrc.permissions().database(dbProvider).testOrFalse(ChangePermission.ABANDON));
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Move Change").setTitle("Move change to a different branch").setVisible(change.getStatus().isOpen() && permissionBackend.user(rsrc.getUser()).ref(change.getDest()).testOrFalse(CREATE_CHANGE) && rsrc.permissions().database(dbProvider).testOrFalse(ABANDON));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(new TypeLiteral<Optional<PeerInfo>>() {
    }).toProvider(JGroupsPeerInfoProvider.class);
    listener().to(JGroupsPeerInfoProvider.class);
}
#method_after
@Override
protected void configure() {
    bind(new TypeLiteral<Optional<PeerInfo>>() {
    }).toProvider(PeerInfoProvider.class);
    if (strategy == Configuration.PeerInfoStrategy.JGROUPS) {
        listener().to(JGroupsPeerInfoProvider.class);
    }
}
#end_block

#method_before
private int getInt(PluginConfig cfg, String name, int defaultValue) {
    try {
        return cfg.getInt(name, defaultValue);
    } catch (IllegalArgumentException e) {
        log.error(String.format("invalid value for %s; using default value %d", name, defaultValue));
        log.debug("Failed retrieve integer value: " + e.getMessage(), e);
        return defaultValue;
    }
}
#method_after
private static int getInt(Config cfg, String section, String name, int defaultValue) {
    try {
        return cfg.getInt(section, name, defaultValue);
    } catch (IllegalArgumentException e) {
        log.error(String.format("invalid value for %s; using default value %d", name, defaultValue));
        log.debug("Failed to retrieve integer value: " + e.getMessage(), e);
        return defaultValue;
    }
}
#end_block

#method_before
List<AccessSection> getAccessSections(Map<String, AccessSectionInfo> sectionInfos) throws UnprocessableEntityException {
    if (sectionInfos == null) {
        return Collections.emptyList();
    }
    List<AccessSection> sections = new ArrayList<>(sectionInfos.size());
    for (Map.Entry<String, AccessSectionInfo> entry : sectionInfos.entrySet()) {
        AccessSection accessSection = new AccessSection(entry.getKey());
        if (entry.getValue().permissions == null) {
            continue;
        }
        for (Map.Entry<String, PermissionInfo> permissionEntry : entry.getValue().permissions.entrySet()) {
            Permission p = new Permission(permissionEntry.getKey());
            if (permissionEntry.getValue().exclusive != null) {
                p.setExclusiveGroup(permissionEntry.getValue().exclusive);
            }
            if (permissionEntry.getValue().rules == null) {
                continue;
            }
            for (Map.Entry<String, PermissionRuleInfo> permissionRuleInfoEntry : permissionEntry.getValue().rules.entrySet()) {
                PermissionRuleInfo pri = permissionRuleInfoEntry.getValue();
                GroupDescription.Basic group = groupsCollection.parseId(permissionRuleInfoEntry.getKey());
                if (group == null) {
                    throw new UnprocessableEntityException(permissionRuleInfoEntry.getKey() + " is not a valid group ID");
                }
                PermissionRule r = new PermissionRule(GroupReference.forGroup(group));
                if (pri != null) {
                    if (pri.max != null) {
                        r.setMax(pri.max);
                    }
                    if (pri.min != null) {
                        r.setMin(pri.min);
                    }
                    r.setAction(GetAccess.ACTION_TYPE.inverse().get(pri.action));
                    if (pri.force != null) {
                        r.setForce(pri.force);
                    }
                }
                p.add(r);
            }
            accessSection.getPermissions().add(p);
        }
        sections.add(accessSection);
    }
    return sections;
}
#method_after
List<AccessSection> getAccessSections(Map<String, AccessSectionInfo> sectionInfos) throws UnprocessableEntityException {
    if (sectionInfos == null) {
        return Collections.emptyList();
    }
    List<AccessSection> sections = new ArrayList<>(sectionInfos.size());
    for (Map.Entry<String, AccessSectionInfo> entry : sectionInfos.entrySet()) {
        if (entry.getValue().permissions == null) {
            continue;
        }
        AccessSection accessSection = new AccessSection(entry.getKey());
        for (Map.Entry<String, PermissionInfo> permissionEntry : entry.getValue().permissions.entrySet()) {
            if (permissionEntry.getValue().rules == null) {
                continue;
            }
            Permission p = new Permission(permissionEntry.getKey());
            if (permissionEntry.getValue().exclusive != null) {
                p.setExclusiveGroup(permissionEntry.getValue().exclusive);
            }
            for (Map.Entry<String, PermissionRuleInfo> permissionRuleInfoEntry : permissionEntry.getValue().rules.entrySet()) {
                GroupDescription.Basic group = groupsCollection.parseId(permissionRuleInfoEntry.getKey());
                if (group == null) {
                    throw new UnprocessableEntityException(permissionRuleInfoEntry.getKey() + " is not a valid group ID");
                }
                PermissionRuleInfo pri = permissionRuleInfoEntry.getValue();
                PermissionRule r = new PermissionRule(GroupReference.forGroup(group));
                if (pri != null) {
                    if (pri.max != null) {
                        r.setMax(pri.max);
                    }
                    if (pri.min != null) {
                        r.setMin(pri.min);
                    }
                    r.setAction(GetAccess.ACTION_TYPE.inverse().get(pri.action));
                    if (pri.force != null) {
                        r.setForce(pri.force);
                    }
                }
                p.add(r);
            }
            accessSection.getPermissions().add(p);
        }
        sections.add(accessSection);
    }
    return sections;
}
#end_block

#method_before
void validateChanges(ProjectControl projectControl, ProjectConfig config, List<AccessSection> removals, List<AccessSection> additions) throws BadRequestException, AuthException, InvalidNameException, PermissionBackendException {
    // Perform permission checks.
    for (AccessSection section : Iterables.concat(additions, removals)) {
        boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
        if (isGlobalCapabilities) {
            if (!allProjects.equals(config.getName())) {
                throw new BadRequestException("Cannot edit global capabilities for projects other than " + allProjects.get());
            }
        }
    }
    // Perform addition checks
    for (AccessSection section : additions) {
        String name = section.getName();
        boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name);
        if (!isGlobalCapabilities) {
            if (!AccessSection.isValid(name)) {
                throw new BadRequestException("invalid section name");
            }
            RefPattern.validate(name);
        }
        // Check all permissions for soundness
        for (Permission p : section.getPermissions()) {
            if (isGlobalCapabilities && !GlobalCapability.isCapability(p.getName())) {
                throw new BadRequestException("Cannot add non-global capability " + p.getName() + " to global capabilities");
            }
        }
    }
}
#method_after
void validateChanges(ProjectConfig config, List<AccessSection> removals, List<AccessSection> additions) throws BadRequestException, AuthException, InvalidNameException, PermissionBackendException {
    // Perform permission checks
    for (AccessSection section : Iterables.concat(additions, removals)) {
        boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
        if (isGlobalCapabilities) {
            if (!allProjects.equals(config.getName())) {
                throw new BadRequestException("Cannot edit global capabilities for projects other than " + allProjects.get());
            }
        }
    }
    // Perform addition checks
    for (AccessSection section : additions) {
        String name = section.getName();
        boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name);
        if (!isGlobalCapabilities) {
            if (!AccessSection.isValid(name)) {
                throw new BadRequestException("invalid section name");
            }
            RefPattern.validate(name);
        } else {
            // Check all permissions for soundness
            for (Permission p : section.getPermissions()) {
                if (!GlobalCapability.isCapability(p.getName())) {
                    throw new BadRequestException("Cannot add non-global capability " + p.getName() + " to global capabilities");
                }
            }
        }
    }
}
#end_block

#method_before
void setParentName(ProjectControl projectControl, ProjectConfig config, Project.NameKey newParentProjectName, boolean checkPermissions) throws ResourceConflictException, AuthException, PermissionBackendException {
    if (newParentProjectName != null && !config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(newParentProjectName)) {
        try {
            setParent.get().validateParentUpdate(projectControl.getProject().getNameKey(), projectControl.getUser().asIdentifiedUser(), MoreObjects.firstNonNull(newParentProjectName, allProjects).get(), checkPermissions);
        } catch (UnprocessableEntityException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
        config.getProject().setParentName(newParentProjectName);
    }
}
#method_after
void setParentName(IdentifiedUser identifiedUser, ProjectConfig config, Project.NameKey projectName, Project.NameKey newParentProjectName, boolean checkAdmin) throws ResourceConflictException, AuthException, PermissionBackendException {
    if (newParentProjectName != null && !config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(newParentProjectName)) {
        try {
            setParent.get().validateParentUpdate(projectName, identifiedUser, newParentProjectName.get(), checkAdmin);
        } catch (UnprocessableEntityException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
        config.getProject().setParentName(newParentProjectName);
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource rsrc, ProjectAccessInput input) throws ResourceNotFoundException, ResourceConflictException, IOException, AuthException, BadRequestException, UnprocessableEntityException, OrmException, PermissionBackendException {
    List<AccessSection> removals = accessUtil.getAccessSections(input.remove);
    List<AccessSection> additions = accessUtil.getAccessSections(input.add);
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    ProjectControl projectControl = rsrc.getControl();
    ProjectConfig config;
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        config = ProjectConfig.read(md);
        accessUtil.validateChanges(projectControl, config, removals, additions);
        // Check that the user has the right permissions.
        for (AccessSection section : Iterables.concat(additions, removals)) {
            boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
            if (isGlobalCapabilities) {
                permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER);
            } else if (!projectControl.controlForRef(section.getName()).isOwner()) {
                throw new AuthException("You are not allowed to edit permissions for ref: " + section.getName());
            }
        }
        accessUtil.cleanupPermissions(config, removals, additions);
        accessUtil.setParentName(projectControl, config, newParentProjectName, true);
        if (!Strings.isNullOrEmpty(input.message)) {
            if (!input.message.endsWith("\n")) {
                input.message += "\n";
            }
            md.setMessage(input.message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        config.commit(md);
        projectCache.evict(config.getProject());
    } catch (InvalidNameException e) {
        throw new BadRequestException(e.toString());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(rsrc.getName());
    }
    return getAccess.apply(rsrc.getNameKey());
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc, ProjectAccessInput input) throws ResourceNotFoundException, ResourceConflictException, IOException, AuthException, BadRequestException, UnprocessableEntityException, OrmException, PermissionBackendException {
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    ProjectConfig config;
    List<AccessSection> removals = accessUtil.getAccessSections(input.remove);
    List<AccessSection> additions = accessUtil.getAccessSections(input.add);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        config = ProjectConfig.read(md);
        // Check that the user has the right permissions.
        boolean checkedAdmin = false;
        for (AccessSection section : Iterables.concat(additions, removals)) {
            boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
            if (isGlobalCapabilities) {
                if (!checkedAdmin) {
                    permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER);
                    checkedAdmin = true;
                }
            } else if (!rsrc.getControl().controlForRef(section.getName()).isOwner()) {
                throw new AuthException("You are not allowed to edit permissions for ref: " + section.getName());
            }
        }
        accessUtil.validateChanges(config, removals, additions);
        accessUtil.applyChanges(config, removals, additions);
        accessUtil.setParentName(identifiedUser.get(), config, rsrc.getNameKey(), input.parent == null ? null : new Project.NameKey(input.parent), !checkedAdmin);
        if (!Strings.isNullOrEmpty(input.message)) {
            if (!input.message.endsWith("\n")) {
                input.message += "\n";
            }
            md.setMessage(input.message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        config.commit(md);
        projectCache.evict(config.getProject());
    } catch (InvalidNameException e) {
        throw new BadRequestException(e.toString());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(rsrc.getName());
    }
    return getAccess.apply(rsrc.getNameKey());
}
#end_block

#method_before
@Override
synchronized public void onEvent(final Event event) {
    if (event instanceof TopicChangedEvent) {
        onTopicChanged((TopicChangedEvent) event);
    } else if (event instanceof PatchSetCreatedEvent) {
        onPatchSetCreated((PatchSetCreatedEvent) event);
    } else if (event instanceof CommentAddedEvent) {
        onCommentAdded((CommentAddedEvent) event);
    }
    // trigger others on the whole project/branch
    if (event instanceof RefEvent) {
        onRefEvent((RefEvent) event);
    }
}
#method_after
@Override
synchronized public void onEvent(final Event event) {
    if (event instanceof TopicChangedEvent) {
        onTopicChanged((TopicChangedEvent) event);
    } else if (event instanceof PatchSetCreatedEvent) {
        onPatchSetCreated((PatchSetCreatedEvent) event);
    } else if (event instanceof CommentAddedEvent) {
        onCommentAdded((CommentAddedEvent) event);
    }
    // trigger others on the whole project/branch
    if (event instanceof RefUpdatedEvent) {
        onRefUpdatedEvent((RefUpdatedEvent) event);
    }
}
#end_block

#method_before
@Override
public OAuthUserInfo getUserInfo(OAuthToken token) throws IOException {
    final String protectedResourceUrl = String.format(PROTECTED_RESOURCE_URL, rootUrl);
    OAuthRequest request = new OAuthRequest(Verb.GET, protectedResourceUrl);
    Token t = new Token(token.getToken(), token.getSecret(), token.getRaw());
    service.signRequest(t, request);
    Response response = request.send();
    if (response.getCode() != HttpServletResponse.SC_OK) {
        throw new IOException(String.format("Status %s (%s) for request %s", response.getCode(), response.getBody(), request.getUrl()));
    }
    if (log.isDebugEnabled()) {
        log.debug("User info response: {}", response.getBody());
    }
    JsonElement userJson = OutputFormat.JSON.newGson().fromJson(response.getBody(), JsonElement.class);
    if (!userJson.isJsonObject()) {
        throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson));
    }
    JsonObject jsonObject = userJson.getAsJsonObject();
    JsonElement id = jsonObject.get("id");
    if (id == null || id.isJsonNull()) {
        throw new IOException(String.format("Response doesn't contain %s field", "id"));
    }
    JsonElement attrListJson = jsonObject.get("attributes");
    String email = null, name = null, login = null;
    if (attrListJson != null && attrListJson.isJsonArray()) {
        JsonArray attrJson = attrListJson.getAsJsonArray();
        for (JsonElement elem : attrJson) {
            if (elem == null || !elem.isJsonObject()) {
                throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", elem));
            }
            JsonObject obj = elem.getAsJsonObject();
            String property = getStringElement(obj, "email");
            if (property != null)
                email = property;
            property = getStringElement(obj, "name");
            if (property != null)
                name = property;
            property = getStringElement(obj, "login");
            if (property != null)
                login = property;
        }
    }
    return new OAuthUserInfo(CAS_PROVIDER_PREFIX + id.getAsString(), login, email, name, fixLegacyUserId ? id.getAsString() : null);
}
#method_after
@Override
public OAuthUserInfo getUserInfo(OAuthToken token) throws IOException {
    final String protectedResourceUrl = String.format(PROTECTED_RESOURCE_URL, rootUrl);
    OAuthRequest request = new OAuthRequest(Verb.GET, protectedResourceUrl);
    Token t = new Token(token.getToken(), token.getSecret(), token.getRaw());
    service.signRequest(t, request);
    Response response = request.send();
    if (response.getCode() != HttpServletResponse.SC_OK) {
        throw new IOException(String.format("Status %s (%s) for request %s", response.getCode(), response.getBody(), request.getUrl()));
    }
    if (log.isDebugEnabled()) {
        log.debug("User info response: {}", response.getBody());
    }
    JsonElement userJson = OutputFormat.JSON.newGson().fromJson(response.getBody(), JsonElement.class);
    if (!userJson.isJsonObject()) {
        throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson));
    }
    JsonObject jsonObject = userJson.getAsJsonObject();
    JsonElement id = jsonObject.get("id");
    if (id == null || id.isJsonNull()) {
        throw new IOException(String.format("CAS response missing id: %s", response.getBody()));
    }
    JsonElement attrListJson = jsonObject.get("attributes");
    if (attrListJson == null) {
        throw new IOException(String.format("CAS response missing attributes: %s", response.getBody()));
    }
    String email = null, name = null, login = null;
    if (attrListJson != null && attrListJson.isJsonArray()) {
        // It is possible for CAS to be configured to not return any attributes (email, name, login), in which case,
        // CAS returns an empty JSON object "attributes":{}, rather than "null" or an empty JSON array "attributes": []
        JsonArray attrJson = attrListJson.getAsJsonArray();
        for (JsonElement elem : attrJson) {
            if (elem == null || !elem.isJsonObject()) {
                throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", elem));
            }
            JsonObject obj = elem.getAsJsonObject();
            String property = getStringElement(obj, "email");
            if (property != null)
                email = property;
            property = getStringElement(obj, "name");
            if (property != null)
                name = property;
            property = getStringElement(obj, "login");
            if (property != null)
                login = property;
        }
    }
    return new OAuthUserInfo(CAS_PROVIDER_PREFIX + id.getAsString(), login, email, name, fixLegacyUserId ? id.getAsString() : null);
}
#end_block

#method_before
public IdentifiedUser getUser() {
    return getControl().getUser().asIdentifiedUser();
}
#method_after
public CurrentUser getUser() {
    return getControl().getUser();
}
#end_block

#method_before
// This includes all information relevant for ETag computation
public void prepareETag(Hasher h, CurrentUser user) {
    h.putInt(JSON_FORMAT_VERSION).putLong(getChange().getLastUpdatedOn().getTime()).putInt(getChange().getRowVersion()).putInt(user.isIdentifiedUser() ? user.getAccountId().get() : 0);
    if (user.isIdentifiedUser()) {
        for (AccountGroup.UUID uuid : user.getEffectiveGroups().getKnownGroups()) {
            h.putBytes(uuid.get().getBytes(UTF_8));
        }
    }
    byte[] buf = new byte[20];
    Set<Account.Id> accounts = new HashSet<>();
    accounts.add(getChange().getOwner());
    try {
        ListMultimap<PatchSet.Id, PatchSetApproval> approvals = approvalUtil.byChange(db.get(), getNotes());
        ReviewerSet reviewers = approvalUtil.getReviewers(getNotes(), approvals.values());
        accounts.addAll(approvals.values().stream().map(a -> a.getAccountId()).collect(toSet()));
        accounts.addAll(reviewers.byState(ReviewerStateInternal.REVIEWER));
        accounts.addAll(reviewers.byState(ReviewerStateInternal.CC));
    } catch (OrmException e) {
    // This ETag will be invalidated if it loads next time.
    }
    accounts.stream().forEach(a -> hashObjectId(h, ObjectId.fromString(accountCache.get(a).getAccount().getMetaId()), buf));
    ObjectId noteId;
    try {
        noteId = getNotes().loadRevision();
    } catch (OrmException e) {
        // This ETag will be invalidated if it loads next time.
        noteId = null;
    }
    hashObjectId(h, noteId, buf);
    for (ProjectState p : control.getProjectControl().getProjectState().tree()) {
        hashObjectId(h, p.getConfig().getRevision(), buf);
    }
}
#method_after
// This includes all information relevant for ETag computation
public void prepareETag(Hasher h, CurrentUser user) {
    h.putInt(JSON_FORMAT_VERSION).putLong(getChange().getLastUpdatedOn().getTime()).putInt(getChange().getRowVersion()).putInt(user.isIdentifiedUser() ? user.getAccountId().get() : 0);
    if (user.isIdentifiedUser()) {
        for (AccountGroup.UUID uuid : user.getEffectiveGroups().getKnownGroups()) {
            h.putBytes(uuid.get().getBytes(UTF_8));
        }
    }
    byte[] buf = new byte[20];
    Set<Account.Id> accounts = new HashSet<>();
    accounts.add(getChange().getOwner());
    if (getChange().getAssignee() != null) {
        accounts.add(getChange().getAssignee());
    }
    try {
        patchSetUtil.byChange(db.get(), getNotes()).stream().map(ps -> ps.getUploader()).forEach(accounts::add);
        // It's intentional to include the states for *all* reviewers into the ETag computation.
        // We need the states of all current reviewers and CCs because they are part of ChangeInfo.
        // Including removed reviewers is a cheap way of making sure that the states of accounts that
        // posted a message on the change are included. Loading all change messages to find the exact
        // set of accounts that posted a message is too expensive. However everyone who posts a
        // message is automatically added as reviewer. Hence if we include removed reviewers we can
        // be sure that we have all accounts that posted messages on the change.
        accounts.addAll(approvalUtil.getReviewers(db.get(), getNotes()).all());
    } catch (OrmException e) {
    // This ETag will be invalidated if it loads next time.
    }
    accounts.stream().forEach(a -> hashAccount(h, accountCache.get(a), buf));
    ObjectId noteId;
    try {
        noteId = getNotes().loadRevision();
    } catch (OrmException e) {
        // This ETag will be invalidated if it loads next time.
        noteId = null;
    }
    hashObjectId(h, noteId, buf);
    for (ProjectState p : control.getProjectControl().getProjectState().tree()) {
        hashObjectId(h, p.getConfig().getRevision(), buf);
    }
}
#end_block

#method_before
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#method_after
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("remove reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#end_block

#method_before
private Map<Change.Id, Branch.NameKey> visibleChangesByScan() {
    Project.NameKey p = projectCtl.getProject().getNameKey();
    Stream<ChangeNotesResult> s;
    try {
        s = changeNotesFactory.scan(git, db.get(), p);
    } catch (IOException e) {
        log.error("Cannot load changes for project " + p + ", assuming no changes are visible", e);
        return Collections.emptyMap();
    }
    return s.map(r -> {
        if (r.error().isPresent()) {
            log.warn("Failed to load change " + r.id() + " in " + p, r.error().get());
            return null;
        }
        try {
            if (permissionBackend.user(user).change(r.notes()).database(db).test(ChangePermission.READ)) {
                return r.notes();
            }
        } catch (PermissionBackendException e) {
            log.warn("Failed to check permission for " + r.id() + " in " + p, e);
        }
        return null;
    }).filter(Objects::nonNull).collect(toMap(n -> n.getChangeId(), n -> n.getChange().getDest()));
}
#method_after
private Map<Change.Id, Branch.NameKey> visibleChangesByScan() {
    Project.NameKey p = projectCtl.getProject().getNameKey();
    Stream<ChangeNotesResult> s;
    try {
        s = changeNotesFactory.scan(git, db.get(), p);
    } catch (IOException e) {
        log.error("Cannot load changes for project " + p + ", assuming no changes are visible", e);
        return Collections.emptyMap();
    }
    return s.map(r -> toNotes(p, r)).filter(Objects::nonNull).collect(toMap(n -> n.getChangeId(), n -> n.getChange().getDest()));
}
#end_block

#method_before
private Map<Change.Id, Branch.NameKey> visibleChangesByScan() {
    Project.NameKey project = projectCtl.getProject().getNameKey();
    try {
        Map<Change.Id, Branch.NameKey> visibleChanges = new HashMap<>();
        ChangeNotesIterator it = changeNotesFactory.scan(git, db.get(), project);
        while (it.hasNext()) {
            ChangeNotes cn = it.next();
            if (permissionBackend.user(user).change(cn).database(db).test(ChangePermission.READ)) {
                visibleChanges.put(cn.getChangeId(), cn.getChange().getDest());
            }
        }
        return visibleChanges;
    } catch (IOException | OrmException | PermissionBackendException e) {
        log.error("Cannot load changes for project " + project + ", assuming no changes are visible", e);
        return Collections.emptyMap();
    }
}
#method_after
private Map<Change.Id, Branch.NameKey> visibleChangesByScan() {
    Project.NameKey project = projectCtl.getProject().getNameKey();
    try {
        Map<Change.Id, Branch.NameKey> visibleChanges = new HashMap<>();
        // avoid this ugly foreach loop.
        for (ChangeNotesResult r : (Iterable<ChangeNotesResult>) changeNotesFactory.scan(git, db.get(), project)::iterator) {
            if (r.error().isPresent()) {
                throw new OrmException(r.error().get());
            }
            ChangeNotes cn = r.notes();
            if (permissionBackend.user(user).change(cn).database(db).test(ChangePermission.READ)) {
                visibleChanges.put(cn.getChangeId(), cn.getChange().getDest());
            }
        }
        return visibleChanges;
    } catch (IOException | OrmException | PermissionBackendException e) {
        log.error("Cannot load changes for project " + project + ", assuming no changes are visible", e);
        return Collections.emptyMap();
    }
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // Order of scanning changes is undefined. This is ok if we assume that packfile locality is
        // not important for indexing, since sites should have a fully populated DiffSummary cache.
        // It does mean that reindexing after invalidating the DiffSummary cache will be expensive,
        // but the goal is to invalidate that cache as infrequently as we possibly can.
        ChangeNotesIterator it = notesFactory.scan(repo, db, project);
        while (true) {
            ChangeNotes notes = null;
            try {
                notes = it.next();
                indexer.index(changeDataFactory.create(db, notes));
                done.update(1);
                verboseWriter.println("Reindexed change " + notes.getChangeId());
            } catch (NoSuchElementException e) {
                break;
            } catch (RejectedExecutionException e) {
                // Server shutdown, don't spam the logs.
                failSilently();
            } catch (NextChangeNotesException e) {
                fail("Failed to index change " + e.getId(), true, e);
            } catch (Exception e) {
                String msg = notes != null ? "Failed to index change " + notes.getChangeId() : "Failed to index unknown change";
                fail(msg, true, e);
            }
        }
    }
    return null;
}
#method_after
@Override
public Void call() throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // Order of scanning changes is undefined. This is ok if we assume that packfile locality is
        // not important for indexing, since sites should have a fully populated DiffSummary cache.
        // It does mean that reindexing after invalidating the DiffSummary cache will be expensive,
        // but the goal is to invalidate that cache as infrequently as we possibly can. And besides,
        // we don't have concrete proof that improving packfile locality would help.
        notesFactory.scan(repo, db, project).forEach(r -> index(db, r));
    } catch (RepositoryNotFoundException rnfe) {
        log.error(rnfe.getMessage());
    }
    return null;
}
#end_block

#method_before
// TODO(ekempin): Remove when database backend is deleted
ChangeNotes createFromChangeOnlyWhenNoteDbDisabled(Change change) throws OrmException {
    checkState(!args.migration.readChanges(), "do not call createFromChangeWhenNoteDbDisabled when NoteDb is enabled");
    return new ChangeNotes(args, change).load();
}
#method_after
// TODO(ekempin): Remove when database backend is deleted
private ChangeNotes createFromChangeOnlyWhenNoteDbDisabled(Change change) throws OrmException {
    checkState(!args.migration.readChanges(), "do not call createFromChangeWhenNoteDbDisabled when NoteDb is enabled");
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = MultimapBuilder.hashKeys().arrayListValues().build();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                ChangeNotesIterator it = scanNoteDb(repo, db, project);
                while (it.hasNext()) {
                    ChangeNotes cn = it.next();
                    if (predicate.test(cn)) {
                        m.put(project, cn);
                    }
                }
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.test(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#method_after
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = MultimapBuilder.hashKeys().arrayListValues().build();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                scanNoteDb(repo, db, project).filter(r -> !r.error().isPresent()).map(ChangeNotesResult::notes).filter(predicate).forEach(n -> m.put(n.getProjectName(), n));
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.test(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#end_block

#method_before
public ChangeNotesIterator scan(Repository repo, ReviewDb db, Project.NameKey project) {
    return args.migration.readChanges() ? scanNoteDb(repo, db, project) : new ReviewDbChangeNotesIterator(this, repo, db);
}
#method_after
public Stream<ChangeNotesResult> scan(Repository repo, ReviewDb db, Project.NameKey project) throws IOException {
    return args.migration.readChanges() ? scanNoteDb(repo, db, project) : scanReviewDb(repo, db);
}
#end_block

#method_before
private NoteDbChangeNotesIterator scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) {
    return new NoteDbChangeNotesIterator(this, repo, db, project, args.migration.changePrimaryStorage());
}
#method_after
private Stream<ChangeNotesResult> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws IOException {
    ScanResult sr = scanChangeIds(repo);
    PrimaryStorage defaultStorage = args.migration.changePrimaryStorage();
    return sr.all().stream().map(id -> scanOneNoteDbChange(db, project, sr, defaultStorage, id)).filter(Objects::nonNull);
}
#end_block

#method_before
static ScanResult scanChangeIds(Repository repo) throws IOException {
    ImmutableSet.Builder<Change.Id> fromPs = ImmutableSet.builder();
    ImmutableSet.Builder<Change.Id> fromMeta = ImmutableSet.builder();
    for (Ref r : repo.getRefDatabase().getRefs(RefNames.REFS_CHANGES).values()) {
        Change.Id id = Change.Id.fromRef(r.getName());
        if (id != null) {
            (r.getName().endsWith(RefNames.META_SUFFIX) ? fromMeta : fromPs).add(id);
        }
    }
    return new AutoValue_ChangeNotes_Factory_ScanResult(fromPs.build(), fromMeta.build());
}
#method_after
private static ScanResult scanChangeIds(Repository repo) throws IOException {
    ImmutableSet.Builder<Change.Id> fromPs = ImmutableSet.builder();
    ImmutableSet.Builder<Change.Id> fromMeta = ImmutableSet.builder();
    for (Ref r : repo.getRefDatabase().getRefs(RefNames.REFS_CHANGES).values()) {
        Change.Id id = Change.Id.fromRef(r.getName());
        if (id != null) {
            (r.getName().endsWith(RefNames.META_SUFFIX) ? fromMeta : fromPs).add(id);
        }
    }
    return new AutoValue_ChangeNotes_Factory_ScanResult(fromPs.build(), fromMeta.build());
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // all ChangeNotes into memory.
        for (ChangeNotes notes : notesFactory.scan(repo, db, project)) {
            try {
                indexer.index(changeDataFactory.create(db, notes));
                done.update(1);
                verboseWriter.println("Reindexed change " + notes.getChangeId());
            } catch (RejectedExecutionException e) {
                // Server shutdown, don't spam the logs.
                failSilently();
            } catch (Exception e) {
                fail("Failed to index change " + notes.getChangeId(), true, e);
            }
        }
    }
    return null;
}
#method_after
@Override
public Void call() throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // all ChangeNotes into memory.
        for (ChangeNotes notes : notesFactory.scan(repo, db, project)) {
            try {
                indexer.index(changeDataFactory.create(db, notes));
                done.update(1);
                verboseWriter.println("Reindexed change " + notes.getChangeId());
            } catch (RejectedExecutionException e) {
                // Server shutdown, don't spam the logs.
                failSilently();
            } catch (Exception e) {
                fail("Failed to index change " + notes.getChangeId(), true, e);
            }
        }
    } catch (RepositoryNotFoundException rnfe) {
        log.error(rnfe.getMessage());
    }
    return null;
}
#end_block

#method_before
@Test
public void revisionActionsTwoChangesInTopic_conflicting() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    // create another change with the same topic
    String changeId2 = createChangeWithTopic(testRepo, "foo2", "touching b", "b.txt", "real content").getChangeId();
    approve(changeId2);
    // collide with the other change in the same topic
    testRepo.reset("HEAD~2");
    String collidingChange = createChangeWithTopic(testRepo, "off_topic", "rewriting file b", "b.txt", "garbage\ngarbage\ngarbage").getChangeId();
    gApi.changes().id(collidingChange).current().review(ReviewInput.approve());
    gApi.changes().id(collidingChange).current().submit();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("Problems with change(s): 2");
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
    }
}
#method_after
@Test
public void revisionActionsTwoChangesInTopic_conflicting() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    // create another change with the same topic
    String changeId2 = createChangeWithTopic(testRepo, "foo2", "touching b", "b.txt", "real content").getChangeId();
    int changeNum2 = gApi.changes().id(changeId2).info()._number;
    approve(changeId2);
    // collide with the other change in the same topic
    testRepo.reset("HEAD~2");
    String collidingChange = createChangeWithTopic(testRepo, "off_topic", "rewriting file b", "b.txt", "garbage\ngarbage\ngarbage").getChangeId();
    gApi.changes().id(collidingChange).current().review(ReviewInput.approve());
    gApi.changes().id(collidingChange).current().submit();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("Problems with change(s): " + changeNum2);
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
    }
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    // As a workaround, we simply reindex all available groups here.
    for (AccountGroup group : groupCache.all()) {
        groupCache.evict(group);
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
@Test
public void lookUpByPreferredEmail() throws Exception {
    // create an inconsistent account that has a preferred email without external ID
    String prefEmail = "foo.preferred@example.com";
    TestAccount foo = accountCreator.create(name("foo"));
    accountsUpdate.create().update(db, foo.id, a -> a.setPreferredEmail(prefEmail));
    // verify that the account is still found when using the preferred email to lookup the account
    ImmutableSet<Account.Id> accountsByPrefEmail = emails.getAccountFor(prefEmail);
    assertThat(accountsByPrefEmail).hasSize(1);
    assertThat(Iterables.getOnlyElement(accountsByPrefEmail)).isEqualTo(foo.id);
}
#method_after
@Test
public void lookUpByPreferredEmail() throws Exception {
    // create an inconsistent account that has a preferred email without external ID
    String prefix = "foo.preferred";
    String prefEmail = prefix + "@example.com";
    TestAccount foo = accountCreator.create(name("foo"));
    accountsUpdate.create().update(db, foo.id, a -> a.setPreferredEmail(prefEmail));
    // verify that the account is still found when using the preferred email to lookup the account
    ImmutableSet<Account.Id> accountsByPrefEmail = emails.getAccountFor(prefEmail);
    assertThat(accountsByPrefEmail).hasSize(1);
    assertThat(Iterables.getOnlyElement(accountsByPrefEmail)).isEqualTo(foo.id);
    // look up by email prefix doesn't find the account
    accountsByPrefEmail = emails.getAccountFor(prefix);
    assertThat(accountsByPrefEmail).isEmpty();
    // look up by other case doesn't find the account
    accountsByPrefEmail = emails.getAccountFor(prefEmail.toUpperCase(Locale.US));
    assertThat(accountsByPrefEmail).isEmpty();
}
#end_block

#method_before
@Test
public void groups() throws Exception {
    assertGroups(admin.username, ImmutableList.of("Registered Users", "Administrators", "Anonymous Users"));
    // TODO: is the user expected to be in these groups?
    // assertGroups(user.username, ImmutableList.of("Registered Users", "Anonymous Users"));
    String group = createGroup("group");
    String user = createAccount("user1", group);
    assertGroups(user, ImmutableList.of(group));
}
#method_after
@Test
public void groups() throws Exception {
    assertGroups(admin.username, ImmutableList.of("Anonymous Users", "Registered Users", "Administrators"));
    // TODO: update when test user is fixed to be included in "Anonymous Users" and
    // "Registered Users" groups
    assertGroups(user.username, ImmutableList.of());
    String group = createGroup("group");
    String newUser = createAccount("user1", group);
    assertGroups(newUser, ImmutableList.of(group));
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException, PermissionBackendException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    List<PatchSetApproval> del = new ArrayList<>();
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (!ctx.getControl().canRemoveReviewer(a)) {
            ctx.permissions().check(ChangePermission.REMOVE_REVIEWER);
        }
        del.add(a);
        if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
            oldApprovals.put(a.getLabel(), a.getValue());
            removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            votesRemoved = true;
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException, PermissionBackendException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    List<PatchSetApproval> del = new ArrayList<>();
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        removeReviewerControl.checkRemoveReviewer(ctx.getNotes(), ctx.getUser(), a);
        del.add(a);
        if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
            oldApprovals.put(a.getLabel(), a.getValue());
            removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            votesRemoved = true;
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, account.getId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else if (!ctl.canRemoveReviewer(a)) {
            try {
                ctx.permissions().check(ChangePermission.REMOVE_REVIEWER);
            } catch (AuthException e) {
                throw new AuthException("delete vote not permitted", e);
            }
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(account.getId(), label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(account.getId()).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, account.getId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else {
            try {
                removeReviewerControl.checkRemoveReviewer(ctx.getNotes(), ctx.getUser(), a);
            } catch (AuthException e) {
                throw new AuthException("delete vote not permitted", e);
            }
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(account.getId(), label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(account.getId()).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) throws PermissionBackendException {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (canRemoveReviewer(ctl, id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (canRemoveReviewer(ctl, id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) throws PermissionBackendException, NoSuchChangeException {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (removeReviewerControl.testRemoveReviewer(ctl.getNotes(), ctl.getUser(), id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (removeReviewerControl.testRemoveReviewer(ctl.getNotes(), ctl.getUser(), id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    return isVisible(db, null);
}
#method_after
boolean isVisible(ReviewDb db) throws OrmException {
    return isVisible(db, null);
}
#end_block

#method_before
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return getRefControl().isVisible();
}
#method_after
private boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return getRefControl().isVisible();
}
#end_block

#method_before
public boolean isPatchVisible(PatchSet ps, ReviewDb db) throws OrmException {
    if (ps != null && ps.isDraft() && !isDraftVisible(db, null)) {
        return false;
    }
    return isVisible(db);
}
#method_after
public boolean isPatchVisible(PatchSet ps, ReviewDb db) throws OrmException {
    // TODO(hiesel) These don't need to be migrated, just remove after support for drafts is removed
    if (ps != null && ps.isDraft() && !isDraftVisible(db, null)) {
        return false;
    }
    return isVisible(db);
}
#end_block

#method_before
public boolean isPatchVisible(PatchSet ps, ChangeData cd) throws OrmException {
    checkArgument(cd.getId().equals(ps.getId().getParentKey()), "%s not for change %s", ps, cd.getId());
    if (ps.isDraft() && !isDraftVisible(cd.db(), cd)) {
        return false;
    }
    return isVisible(cd.db());
}
#method_after
public boolean isPatchVisible(PatchSet ps, ChangeData cd) throws OrmException {
    // TODO(hiesel) These don't need to be migrated, just remove after support for drafts is removed
    checkArgument(cd.getId().equals(ps.getId().getParentKey()), "%s not for change %s", ps, cd.getId());
    if (ps.isDraft() && !isDraftVisible(cd.db(), cd)) {
        return false;
    }
    return isVisible(cd.db());
}
#end_block

#method_before
private boolean isOwner() {
    if (getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(getChange().getOwner());
    }
    return false;
}
#method_after
boolean isOwner() {
    if (getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(getChange().getOwner());
    }
    return false;
}
#end_block

#method_before
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), changeData());
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REMOVE_REVIEWER:
                return canRemoveReviewer();
            case REBASE:
                return canRebase(db());
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return getRefControl().canSubmit(isOwner());
            case SUBMIT_AS:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), changeData());
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return getRefControl().canSubmit(isOwner());
            case REMOVE_REVIEWER:
            case SUBMIT_AS:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
public Multimap<String, AccountState> byPreferredEmail(String... emails) throws OrmException {
    List<String> emailList = Arrays.asList(emails);
    List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmail(e)).collect(toList()));
    Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
    for (int i = 0; i < emailList.size(); i++) {
        String email = emailList.get(i);
        Set<AccountState> matchingAccounts = r.get(i).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toSet());
        accountsByEmail.putAll(email, matchingAccounts);
    }
    return accountsByEmail;
}
#method_after
public List<AccountState> byPreferredEmail(String email) throws OrmException {
    return query(AccountPredicates.preferredEmail(email)).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toList());
}
#end_block

#method_before
@Test
public void largeObjectTombstoneCanBeSerializedAndDeserialized() throws Exception {
    // Serialize
    byte[] serializedObject;
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream objectStream = new ObjectOutputStream(baos)) {
        objectStream.writeObject(new PatchListCacheImpl.LargeObjectTombstone());
        serializedObject = baos.toByteArray();
    }
    assertThat(serializedObject).isNotNull();
    // Deserialize
    PatchList recoveredTombstone;
    try (InputStream is = new ByteArrayInputStream(serializedObject);
        ObjectInputStream ois = new ObjectInputStream(is)) {
        recoveredTombstone = (PatchList) ois.readObject();
    }
    assertThat(recoveredTombstone).isInstanceOf(PatchListCacheImpl.LargeObjectTombstone.class);
}
#method_after
@Test
public void largeObjectTombstoneCanBeSerializedAndDeserialized() throws Exception {
    // Serialize
    byte[] serializedObject;
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream objectStream = new ObjectOutputStream(baos)) {
        objectStream.writeObject(new PatchListCacheImpl.LargeObjectTombstone());
        serializedObject = baos.toByteArray();
        assertThat(serializedObject).isNotNull();
    }
    // Deserialize
    try (InputStream is = new ByteArrayInputStream(serializedObject);
        ObjectInputStream ois = new ObjectInputStream(is)) {
        assertThat(ois.readObject()).isInstanceOf(PatchListCacheImpl.LargeObjectTombstone.class);
    }
}
#end_block

#method_before
@Test
public void byName() throws Exception {
    assertQuery("name:non-existing");
    GroupInfo group = createGroup(name("Group"));
    assertQuery("name:" + group.name, group);
    // only exact match
    GroupInfo groupWithHyphen = createGroup(name("group-with-hyphen"));
    createGroup(name("group-no-match-with-hyphen"));
    assertQuery("name:" + groupWithHyphen.name, groupWithHyphen);
}
#method_after
@Test
public void byName() throws Exception {
    assertQuery("name:non-existing");
    GroupInfo group = createGroup(name("Group"));
    assertQuery("name:" + group.name, group);
    assertQuery("name:" + group.name.toLowerCase(Locale.US));
    // only exact match
    GroupInfo groupWithHyphen = createGroup(name("group-with-hyphen"));
    createGroup(name("group-no-match-with-hyphen"));
    assertQuery("name:" + groupWithHyphen.name, groupWithHyphen);
}
#end_block

#method_before
public static Predicate<InternalGroup> uuid(AccountGroup.UUID uuid) {
    return new GroupPredicate(GroupField.UUID, GroupQueryBuilder.FIELD_UUID, uuid.get());
}
#method_after
public static Predicate<AccountGroup> uuid(AccountGroup.UUID uuid) {
    return new GroupPredicate(GroupField.UUID, GroupQueryBuilder.FIELD_UUID, uuid.get());
}
#end_block

#method_before
public static Predicate<InternalGroup> description(String description) {
    return new GroupPredicate(GroupField.DESCRIPTION, GroupQueryBuilder.FIELD_DESCRIPTION, description);
}
#method_after
public static Predicate<AccountGroup> description(String description) {
    return new GroupPredicate(GroupField.DESCRIPTION, GroupQueryBuilder.FIELD_DESCRIPTION, description);
}
#end_block

#method_before
public static Predicate<InternalGroup> inname(String name) {
    return new GroupPredicate(GroupField.NAME_PART, GroupQueryBuilder.FIELD_INNAME, name.toLowerCase(Locale.US));
}
#method_after
public static Predicate<AccountGroup> inname(String name) {
    return new GroupPredicate(GroupField.NAME_PART, GroupQueryBuilder.FIELD_INNAME, name.toLowerCase(Locale.US));
}
#end_block

#method_before
public static Predicate<InternalGroup> name(String name) {
    return new GroupPredicate(GroupField.NAME, GroupQueryBuilder.FIELD_NAME, name);
}
#method_after
public static Predicate<AccountGroup> name(String name) {
    return new GroupPredicate(GroupField.NAME, GroupQueryBuilder.FIELD_NAME, name);
}
#end_block

#method_before
public static Predicate<InternalGroup> owner(AccountGroup.UUID ownerUuid) {
    return new GroupPredicate(GroupField.OWNER_UUID, GroupQueryBuilder.FIELD_OWNER, ownerUuid.get());
}
#method_after
public static Predicate<AccountGroup> owner(AccountGroup.UUID ownerUuid) {
    return new GroupPredicate(GroupField.OWNER_UUID, GroupQueryBuilder.FIELD_OWNER, ownerUuid.get());
}
#end_block

#method_before
public static Predicate<InternalGroup> isVisibleToAll() {
    return new GroupPredicate(GroupField.IS_VISIBLE_TO_ALL, "1");
}
#method_after
public static Predicate<AccountGroup> isVisibleToAll() {
    return new GroupPredicate(GroupField.IS_VISIBLE_TO_ALL, "1");
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setPrivateByDefault(getEnum(rc, RECEIVE, null, KEY_PRIVATE_BY_DEFAULT, InheritableBoolean.INHERIT));
    p.setEnableReviewerByEmail(getEnum(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setMatchAuthorToCommitterDate(getEnum(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc);
    loadContributorAgreements(rc);
    loadAccessSections(rc);
    loadBranchOrderSection(rc);
    loadNotifySections(rc);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
    loadExtensionPanelSections(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setPrivateByDefault(getEnum(rc, CHANGE, null, KEY_PRIVATE_BY_DEFAULT, InheritableBoolean.INHERIT));
    p.setEnableReviewerByEmail(getEnum(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setMatchAuthorToCommitterDate(getEnum(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc);
    loadContributorAgreements(rc);
    loadAccessSections(rc);
    loadBranchOrderSection(rc);
    loadNotifySections(rc);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
    loadExtensionPanelSections(rc);
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, p.getRejectImplicitMerges(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_PRIVATE_BY_DEFAULT, p.getPrivateByDefault(), InheritableBoolean.INHERIT);
    set(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, p.getEnableReviewerByEmail(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), DEFAULT_SUBMIT_ACTION);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, p.getMatchAuthorToCommitterDate(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), DEFAULT_STATE_VALUE);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, p.getRejectImplicitMerges(), InheritableBoolean.INHERIT);
    set(rc, CHANGE, null, KEY_PRIVATE_BY_DEFAULT, p.getPrivateByDefault(), InheritableBoolean.INHERIT);
    set(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, p.getEnableReviewerByEmail(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), DEFAULT_SUBMIT_ACTION);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, p.getMatchAuthorToCommitterDate(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), DEFAULT_STATE_VALUE);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    Project p = (Project) obj;
    if (!name.equals(p.name)) {
        return false;
    }
    if (!path.equals(p.path)) {
        return false;
    }
    if (!remote.equals(p.remote)) {
        return false;
    }
    if (!remotebranch.equals(p.remotebranch)) {
        // check for master, empty means master
        if (!((remotebranch.equals("master") && p.remotebranch.equals("")) || (p.remotebranch.equals("master") && remotebranch.equals("")))) {
            return false;
        }
    }
    if (!revision.equals(p.revision)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    Project p = (Project) obj;
    if (!name.equals(p.name)) {
        return false;
    }
    if (!path.equals(p.path)) {
        return false;
    }
    if (!remote.equals(p.remote)) {
        return false;
    }
    if (!remotebranch.equals(p.remotebranch)) {
        return false;
    }
    if (!revision.equals(p.revision)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void updateSubmodules(Repository repo, String targetRef, JiriProjects projects, GerritRemoteReader reader) throws Exception {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndaddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndaddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                if (ref.isEmpty()) {
                    ref = "master";
                }
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    // Run ls-remote
                    LsRemoteCommand ls = new LsRemoteCommand(repo);
                    ls.setRemote(nameUri);
                    Map<String, Ref> refs = ls.callAsMap();
                    if (refs.containsKey(REFS_HEADS + ref)) {
                        objectId = refs.get(REFS_HEADS + ref).getObjectId();
                    } else if (refs.containsKey(REFS_TAGS + ref)) {
                        objectId = refs.get(REFS_TAGS + ref).getObjectId();
                    } else {
                        warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                        continue;
                    }
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                // $NON-NLS-1$ //$NON-NLS-2$
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // $NON-NLS-1$ //$NON-NLS-2$
            cfg.setString("submodule", path, "path", path);
            // $NON-NLS-1$ //$NON-NLS-2$
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        // $NON-NLS-1$
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
        rw.parseCommit(commitId);
    }
}
#method_after
private void updateSubmodules(Repository repo, String targetRef, JiriProjects projects, GerritRemoteReader reader) throws Exception {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndaddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndaddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            nameUri = URI.create(nameUri).toString();
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", nameUri);
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#end_block

#method_before
public static JiriProjects GetProjects(Repository repo, String ref, String manifest) throws Exception {
    Queue<String> q = new LinkedList<>();
    q.add(manifest);
    HashSet<String> processedFiles = new HashSet<>();
    HashMap<String, Project> projectMap = new HashMap<>();
    while (q.size() != 0) {
        String file = q.remove();
        if (processedFiles.contains(file)) {
            continue;
        }
        processedFiles.add(file);
        JiriManifest m = parseManifest(repo, ref, file);
        if (m.imports.getImports().length != 0) {
            throw new Exception(String.format("Manifest %s contains remote imports which are not supported", file));
        }
        for (Project project : m.projects.getProjects()) {
            if (projectMap.containsKey(project.Key())) {
                if (!projectMap.get(project.Key()).equals(project))
                    throw new Exception(String.format("Duplicate conflicting project %s in manifest %s\n%s\n%s", project.Key(), file, project.toString(), projectMap.get(project.Key()).toString()));
            } else {
                projectMap.put(project.Key(), project);
            }
        }
        URI parentURI = new URI(file);
        for (LocalImport l : m.imports.getLocalImports()) {
            q.add(parentURI.resolve(l.getFile()).getPath());
        }
    }
    return new JiriProjects(projectMap.values().toArray(new Project[0]));
}
#method_after
public static JiriProjects GetProjects(Repository repo, String ref, String manifest) throws Exception {
    Queue<String> q = new LinkedList<>();
    q.add(manifest);
    HashSet<String> processedFiles = new HashSet<>();
    HashMap<String, JiriProjects.Project> projectMap = new HashMap<>();
    while (q.size() != 0) {
        String file = q.remove();
        if (processedFiles.contains(file)) {
            continue;
        }
        processedFiles.add(file);
        JiriManifest m = parseManifest(repo, ref, file);
        if (m.imports.getImports().length != 0) {
            throw new Exception(String.format("Manifest %s contains remote imports which are not supported", file));
        }
        for (JiriProjects.Project project : m.projects.getProjects()) {
            project.fillDefault();
            if (projectMap.containsKey(project.Key())) {
                if (!projectMap.get(project.Key()).equals(project))
                    throw new Exception(String.format("Duplicate conflicting project %s in manifest %s\n%s\n%s", project.Key(), file, project.toString(), projectMap.get(project.Key()).toString()));
            } else {
                projectMap.put(project.Key(), project);
            }
        }
        URI parentURI = new URI(file);
        for (JiriManifest.LocalImport l : m.imports.getLocalImports()) {
            q.add(parentURI.resolve(l.getFile()).getPath());
        }
    }
    return new JiriProjects(projectMap.values().toArray(new JiriProjects.Project[0]));
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("%s -> %s => %s", toolType, src(), dest());
}
#method_after
@Override
public String toString() {
    return String.format("%s (%s) => %s", src(), toolType, dest());
}
#end_block

#method_before
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownConfig cfg, MarkdownToHtml.Builder fmt, MarkdownFile navFile, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(buildNavbar(cfg, fmt, navFile));
    Node doc = GitilesMarkdown.parse(cfg, srcFile.consumeContent());
    data.put("breadcrumbs", null);
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#method_after
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownConfig cfg, MarkdownToHtml.Builder fmt, MarkdownFile navFile, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(buildNavbar(cfg, fmt, navFile));
    Node doc = GitilesMarkdown.parse(cfg, srcFile.consumeContent());
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#end_block

#method_before
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownConfig cfg, MarkdownToHtml.Builder fmt, MarkdownFile navFile, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(buildNavbar(fmt, navFile));
    Node doc = GitilesMarkdown.parse(srcFile.consumeContent());
    data.put("breadcrumbs", null);
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#method_after
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownConfig cfg, MarkdownToHtml.Builder fmt, MarkdownFile navFile, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(buildNavbar(fmt, navFile));
    Node doc = GitilesMarkdown.parse(srcFile.consumeContent());
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#end_block

#method_before
@Override
public /**
 * Return an empty list so that {@link PatchListWeigher} rely on {@code patches} being set in
 * {@link PatchList}
 */
List<PatchListEntry> getPatches() {
    return ImmutableList.of();
}
#method_after
@Override
public List<PatchListEntry> getPatches() {
    return ImmutableList.of();
}
#end_block

#method_before
private PatchList readPatchList(Repository repo, RevWalk rw, ObjectInserter ins) throws IOException, PatchListNotAvailableException {
    ObjectReader reader = rw.getObjectReader();
    checkArgument(reader.getCreatedFromInserter() == ins);
    RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        RevCommit b = rw.parseCommit(key.getNewId());
        RevObject a = aFor(key, repo, rw, ins, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is an octopus merge commit which should be compared against the
            // auto-merge. However since we don't support computing the auto-merge
            // for octopus merge commits, we fall back to diffing against the first
            // parent, even though this wasn't what was requested.
            // 
            ComparisonType comparisonType = ComparisonType.againstParent(1);
            PatchListEntry[] entries = new PatchListEntry[2];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            entries[1] = newMergeList(cmp, reader, null, b, comparisonType);
            return new PatchList(a, b, true, comparisonType, entries);
        }
        ComparisonType comparisonType = getComparisonType(a, b);
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setReader(reader, repo.getConfig());
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = new ArrayList<>(df.scan(aTree, bTree));
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, comparisonType.isAgainstParentOrAutoMerge() ? null : aCommit, b));
        boolean isMerge = b.getParentCount() > 1;
        if (isMerge) {
            entries.add(newMergeList(cmp, reader, comparisonType.isAgainstParentOrAutoMerge() ? null : aCommit, b, comparisonType));
        }
        Multimap<String, ContextAwareEdit> editsDueToRebasePerFilePath = key.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF ? getEditsDueToRebasePerFilePath(aCommit, b, diffEntries, df) : ImmutableMultimap.of();
        for (DiffEntry diffEntry : diffEntries) {
            Set<ContextAwareEdit> editsDueToRebase = getEditsDueToRebase(editsDueToRebasePerFilePath, diffEntry);
            Optional<PatchListEntry> patchListEntry = getPatchListEntry(reader, df, diffEntry, aTree, bTree, editsDueToRebase);
            patchListEntry.ifPresent(entries::add);
        }
        return new PatchList(a, b, isMerge, comparisonType, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#method_after
private PatchList readPatchList(Repository repo, RevWalk rw, ObjectInserter ins) throws IOException, PatchListNotAvailableException {
    ObjectReader reader = rw.getObjectReader();
    checkArgument(reader.getCreatedFromInserter() == ins);
    RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        RevCommit b = rw.parseCommit(key.getNewId());
        RevObject a = aFor(key, repo, rw, ins, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is an octopus merge commit which should be compared against the
            // auto-merge. However since we don't support computing the auto-merge
            // for octopus merge commits, we fall back to diffing against the first
            // parent, even though this wasn't what was requested.
            // 
            ComparisonType comparisonType = ComparisonType.againstParent(1);
            PatchListEntry[] entries = new PatchListEntry[2];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            entries[1] = newMergeList(cmp, reader, null, b, comparisonType);
            return new PatchList(a, b, true, comparisonType, entries);
        }
        ComparisonType comparisonType = getComparisonType(a, b);
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setReader(reader, repo.getConfig());
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Multimap<String, ContextAwareEdit> editsDueToRebasePerFilePath = ImmutableMultimap.of();
        if (key.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF) {
            EditsDueToRebaseResult editsDueToRebaseResult = determineEditsDueToRebase(aCommit, b, diffEntries, df, rw);
            diffEntries = editsDueToRebaseResult.getRelevantOriginalDiffEntries();
            editsDueToRebasePerFilePath = editsDueToRebaseResult.getEditsDueToRebasePerFilePath();
        }
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, comparisonType.isAgainstParentOrAutoMerge() ? null : aCommit, b));
        boolean isMerge = b.getParentCount() > 1;
        if (isMerge) {
            entries.add(newMergeList(cmp, reader, comparisonType.isAgainstParentOrAutoMerge() ? null : aCommit, b, comparisonType));
        }
        for (DiffEntry diffEntry : diffEntries) {
            Set<ContextAwareEdit> editsDueToRebase = getEditsDueToRebase(editsDueToRebasePerFilePath, diffEntry);
            Optional<PatchListEntry> patchListEntry = getPatchListEntry(reader, df, diffEntry, aTree, bTree, editsDueToRebase);
            patchListEntry.ifPresent(entries::add);
        }
        return new PatchList(a, b, isMerge, comparisonType, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#end_block

#method_before
private static Stream<String> getTouchedFilePaths(PatchListEntry patchListEntry) {
    String oldFilePath = patchListEntry.getOldName();
    String newFilePath = patchListEntry.getNewName();
    return oldFilePath == null ? Stream.of(newFilePath) : Stream.of(oldFilePath, newFilePath);
}
#method_after
private static Set<String> getTouchedFilePaths(PatchListEntry patchListEntry) {
    String oldFilePath = patchListEntry.getOldName();
    String newFilePath = patchListEntry.getNewName();
    return oldFilePath == null ? ImmutableSet.of(newFilePath) : ImmutableSet.of(oldFilePath, newFilePath);
}
#end_block

#method_before
private List<PatchListEntry> getRelevantPatchListEntries(List<DiffEntry> parentDiffEntries, RevCommit parentCommitA, RevCommit parentCommitB, ImmutableSet<String> touchedFilePaths, DiffFormatter diffFormatter) throws IOException {
    List<PatchListEntry> parentPatchListEntries = new ArrayList<>(parentDiffEntries.size());
    for (DiffEntry parentDiffEntry : parentDiffEntries) {
        if (!isTouched(touchedFilePaths, parentDiffEntry)) {
            continue;
        }
        FileHeader fileHeader = toFileHeader(parentCommitB, diffFormatter, parentDiffEntry);
        PatchListEntry patchListEntry = newEntry(parentCommitA.getTree(), fileHeader, ImmutableSet.of(), 0, 0);
        parentPatchListEntries.add(patchListEntry);
    }
    return parentPatchListEntries;
}
#method_after
private List<PatchListEntry> getRelevantPatchListEntries(List<DiffEntry> parentDiffEntries, RevCommit parentCommitA, RevCommit parentCommitB, Set<String> touchedFilePaths, DiffFormatter diffFormatter) throws IOException {
    List<PatchListEntry> parentPatchListEntries = new ArrayList<>(parentDiffEntries.size());
    for (DiffEntry parentDiffEntry : parentDiffEntries) {
        if (!isTouched(touchedFilePaths, parentDiffEntry)) {
            continue;
        }
        FileHeader fileHeader = toFileHeader(parentCommitB, diffFormatter, parentDiffEntry);
        // The code which uses this PatchListEntry doesn't care about the last three parameters. As
        // they are expensive to compute, we use arbitrary values for them.
        PatchListEntry patchListEntry = newEntry(parentCommitA.getTree(), fileHeader, ImmutableSet.of(), 0, 0);
        parentPatchListEntries.add(patchListEntry);
    }
    return parentPatchListEntries;
}
#end_block

#method_before
private List<QueryResult<T>> query(List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    checkState(!isDisabled(), "%s is disabled", getClass().getSimpleName());
    long startNanos = System.nanoTime();
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + " of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<T> pred = rewriter.rewrite(q, opts);
        if (enforceVisibility) {
            pred = enforceVisibility(pred);
        }
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // only measure successful queries
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#method_after
private List<QueryResult<T>> query(@Nullable List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    long startNanos = System.nanoTime();
    checkState(!used.getAndSet(true), "%s has already been used", getClass().getSimpleName());
    int cnt = queries.size();
    if (queryStrings != null) {
        int qs = queryStrings.size();
        checkArgument(qs == cnt, "got %s query strings but %s predicates", qs, cnt);
    }
    if (cnt == 0) {
        return ImmutableList.of();
    }
    if (isDisabled()) {
        return disabledResults(queryStrings, queries);
    }
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + " of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<T> pred = rewriter.rewrite(q, opts);
        if (enforceVisibility) {
            pred = enforceVisibility(pred);
        }
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // Only measure successful queries that actually touched the index.
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#end_block

#method_before
public boolean isDisabled() {
    return enforceVisibility && permittedLimit <= 0;
}
#method_after
public boolean isDisabled() {
    return enforceVisibility && getPermittedLimit() <= 0;
}
#end_block

#method_before
private int getEffectiveLimit(Predicate<T> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    checkState(permittedLimit > 0, "user limit should have been positive");
    possibleLimits.add(permittedLimit);
    if (userProvidedLimit > 0) {
        possibleLimits.add(userProvidedLimit);
    }
    if (limitField != null) {
        Integer limitFromPredicate = LimitPredicate.getLimit(limitField, p);
        if (limitFromPredicate != null) {
            possibleLimits.add(limitFromPredicate);
        }
    }
    return Ordering.natural().min(possibleLimits);
}
#method_after
private int getEffectiveLimit(Predicate<T> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    possibleLimits.add(getPermittedLimit());
    if (userProvidedLimit > 0) {
        possibleLimits.add(userProvidedLimit);
    }
    if (limitField != null) {
        Integer limitFromPredicate = LimitPredicate.getLimit(limitField, p);
        if (limitFromPredicate != null) {
            possibleLimits.add(limitFromPredicate);
        }
    }
    int result = Ordering.natural().min(possibleLimits);
    // Should have short-circuited from #query or thrown some other exception before getting here.
    checkState(result > 0, "effective limit should be positive");
    return result;
}
#end_block

#method_before
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            QueryResult<AccountState> result = accountQueryProcessor.setUserProvidedLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(AccountPredicates.andActive(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery())));
            return result.entities().stream().map(a -> a.getAccount().getId()).collect(toList());
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#method_after
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            QueryResult<AccountState> result = queryProvider.get().setUserProvidedLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(AccountPredicates.andActive(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery())));
            return result.entities().stream().map(a -> a.getAccount().getId()).collect(toList());
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#end_block

#method_before
private List<QueryResult<T>> query(List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    checkState(!isDisabled(), "%s is disabled", getClass().getSimpleName());
    checkState(!used.getAndSet(true), "%s has already been used", getClass().getSimpleName());
    long startNanos = System.nanoTime();
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + " of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<T> pred = rewriter.rewrite(q, opts);
        if (enforceVisibility) {
            pred = enforceVisibility(pred);
        }
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // only measure successful queries
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#method_after
private List<QueryResult<T>> query(@Nullable List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    long startNanos = System.nanoTime();
    checkState(!used.getAndSet(true), "%s has already been used", getClass().getSimpleName());
    int cnt = queries.size();
    if (queryStrings != null) {
        int qs = queryStrings.size();
        checkArgument(qs == cnt, "got %s query strings but %s predicates", qs, cnt);
    }
    if (cnt == 0) {
        return ImmutableList.of();
    }
    if (isDisabled()) {
        return disabledResults(queryStrings, queries);
    }
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + " of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<T> pred = rewriter.rewrite(q, opts);
        if (enforceVisibility) {
            pred = enforceVisibility(pred);
        }
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // Only measure successful queries that actually touched the index.
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#end_block

#method_before
public boolean isDisabled() {
    return enforceVisibility && permittedLimit <= 0;
}
#method_after
public boolean isDisabled() {
    return enforceVisibility && getPermittedLimit() <= 0;
}
#end_block

#method_before
private int getEffectiveLimit(Predicate<T> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    checkState(permittedLimit > 0, "user limit should have been positive");
    possibleLimits.add(permittedLimit);
    if (userProvidedLimit > 0) {
        possibleLimits.add(userProvidedLimit);
    }
    if (limitField != null) {
        Integer limitFromPredicate = LimitPredicate.getLimit(limitField, p);
        if (limitFromPredicate != null) {
            possibleLimits.add(limitFromPredicate);
        }
    }
    return Ordering.natural().min(possibleLimits);
}
#method_after
private int getEffectiveLimit(Predicate<T> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    possibleLimits.add(getPermittedLimit());
    if (userProvidedLimit > 0) {
        possibleLimits.add(userProvidedLimit);
    }
    if (limitField != null) {
        Integer limitFromPredicate = LimitPredicate.getLimit(limitField, p);
        if (limitFromPredicate != null) {
            possibleLimits.add(limitFromPredicate);
        }
    }
    int result = Ordering.natural().min(possibleLimits);
    // Should have short-circuited from #query or thrown some other exception before getting here.
    checkState(result > 0, "effective limit should be positive");
    return result;
}
#end_block

#method_before
public Multimap<String, AccountState> byPreferredEmail(String... emails) throws OrmException {
    List<String> emailList = Arrays.asList(emails);
    List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmail(e)).collect(toList()));
    Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
    for (int i = 0; i < emailList.size(); i++) {
        accountsByEmail.putAll(emailList.get(i), r.get(i));
    }
    return accountsByEmail;
}
#method_after
public List<AccountState> byPreferredEmail(String email) throws OrmException {
    return query(AccountPredicates.preferredEmail(email));
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    MarkdownConfig cfg = MarkdownConfig.get(getAccess(req).getConfig());
    if (!cfg.render) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo)) {
        ObjectReader reader = rw.getObjectReader();
        String path = view.getPathPart();
        RevTree root;
        try {
            root = rw.parseTree(view.getRevision().getId());
        } catch (IncorrectObjectTypeException e) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        MarkdownFile srcmd = findFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        MarkdownFile navmd = findFile(rw, root, NAVBAR_MD);
        String curEtag = etag(srcmd, navmd);
        if (etagMatch(req, curEtag)) {
            res.setStatus(SC_NOT_MODIFIED);
            return;
        }
        view = view.toBuilder().setPathPart(srcmd.path).build();
        try {
            srcmd.read(reader, cfg);
            if (navmd != null) {
                navmd.read(reader, cfg);
            }
        } catch (LargeObjectException.ExceedsLimit errBig) {
            fileTooBig(res, view, errBig);
            return;
        } catch (IOException err) {
            readError(res, view, err);
            return;
        }
        MarkdownToHtml.Builder fmt = MarkdownToHtml.builder().setConfig(cfg).setGitilesView(view).setRequestUri(req.getRequestURI()).setReader(reader).setRootTree(root).setHtmlSanitizer(htmlSanitizer.create(req));
        res.setHeader(HttpHeaders.ETAG, curEtag);
        showDoc(req, res, view, cfg, fmt, navmd, srcmd);
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    MarkdownConfig cfg = MarkdownConfig.get(getAccess(req).getConfig());
    if (!cfg.render) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo)) {
        ObjectReader reader = rw.getObjectReader();
        String path = view.getPathPart();
        RevTree root;
        try {
            root = rw.parseTree(view.getRevision().getId());
        } catch (IncorrectObjectTypeException e) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        MarkdownFile srcmd = findFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        MarkdownFile navmd = findFile(rw, root, NAVBAR_MD);
        String curEtag = etag(srcmd, navmd);
        if (etagMatch(req, curEtag)) {
            res.setStatus(SC_NOT_MODIFIED);
            return;
        }
        view = view.toBuilder().setPathPart(srcmd.path).build();
        try {
            srcmd.read(reader, cfg);
            if (navmd != null) {
                navmd.read(reader, cfg);
            }
        } catch (LargeObjectException.ExceedsLimit errBig) {
            fileTooBig(res, view, errBig);
            return;
        } catch (IOException err) {
            readError(res, view, err);
            return;
        }
        MarkdownToHtml.Builder fmt = MarkdownToHtml.builder().setConfig(cfg).setGitilesView(view).setRequestUri(req.getRequestURI()).setReader(reader).setRootTree(root).setHtmlSanitizer(htmlSanitizer.create(req));
        Navbar navbar = createNavbar(cfg, fmt, navmd);
        res.setHeader(HttpHeaders.ETAG, curEtag);
        showDoc(req, res, view, fmt, navbar, srcmd);
    }
}
#end_block

#method_before
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownConfig cfg, MarkdownToHtml.Builder fmt, MarkdownFile navFile, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(buildNavbar(cfg, fmt, navFile));
    Node doc = GitilesMarkdown.parse(cfg, srcFile.consumeContent());
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#method_after
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownToHtml.Builder fmt, Navbar navbar, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(navbar.toSoyData());
    MarkdownConfig cfg = navbar.getConfig();
    Node doc = GitilesMarkdown.parse(cfg, srcFile.consumeContent());
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setConfig(cfg).setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#end_block

#method_before
@Override
public void visit(Heading node) {
    outputNamedAnchor = false;
    String tag = "h" + node.getLevel();
    html.open(tag);
    String id = toc.idFromHeader(node);
    if (id != null) {
        html.open("a").attribute("class", "h").attribute("name", id).attribute("href", "#" + id).open("span").close("span").close("a");
    }
    visitChildren(node);
    html.close(tag);
    outputNamedAnchor = true;
}
#method_after
@Override
public void visit(Heading node) {
    outputNamedAnchor = false;
    String tag = "h" + node.getLevel();
    html.open(tag);
    String id = toc.idFromHeader(node);
    if (id != null) {
        html.open("a").attribute("class", "h").attribute("name", id).attribute("href", "#" + id).open("span").close("span").close("a");
        // github markdown compatibility
        if (id != id.toLowerCase()) {
            html.open("a").attribute("class", "h").attribute("name", id.toLowerCase()).attribute("href", "#" + id.toLowerCase()).open("span").close("span").close("a");
        }
    }
    visitChildren(node);
    html.close(tag);
    outputNamedAnchor = true;
}
#end_block

#method_before
@Override
public void visit(HtmlInline node) {
// Discard inline HTML, as its always partial tags.
}
#method_after
@Override
public void visit(HtmlInline node) {
// Discard inline HTML, as it's always partial tags.
}
#end_block

#method_before
@Test
public void includesNavbar() throws Exception {
    String navbar = "# Site Title\n" + "\n" + "* [Home](index.md)\n" + "* [README](README.md)\n";
    repo.branch("master").commit().add("README.md", "# page\n\nof information.").add("navbar.md", navbar).create();
    String html = buildHtml("/repo/+doc/master/README.md");
    assertThat(html).contains("<title>Site Title - page</title>");
    assertThat(html).contains("<span class=\"Header-anchorTitle\">Site Title</span>");
    assertThat(html).contains("<li><a href=\"/b/repo/+/master/index.md\">Home</a></li>");
    assertThat(html).contains("<li><a href=\"/b/repo/+/master/README.md\">README</a></li>");
    assertThat(html).contains("<h1>" + "<a class=\"h\" name=\"page\" href=\"#page\"><span></span></a>" + "page</h1>");
}
#method_after
@Test
public void includesNavbar() throws Exception {
    String navbar = "# Site Title\n" + "\n" + "* [Home](index.md)\n" + "* [README](README.md)\n";
    repo.branch("master").commit().add("README.md", "# page\n\nof information.").add("navbar.md", navbar).create();
    String html = buildHtml("/repo/+doc/master/README.md");
    assertThat(html).contains("<title>Site Title - page</title>");
    assertThat(html).contains("<span class=\"Header-anchorTitle\">Site Title</span>");
    assertThat(html).contains("<li><a href=\"/b/repo/+/master/index.md\">Home</a></li>");
    assertThat(html).contains("<li><a href=\"/b/repo/+/master/README.md\">README</a></li>");
    assertThat(html).contains("<h1><a class=\"h\" name=\"page\" href=\"#page\"><span></span></a>page</h1>");
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (receiveEvent.commit.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress())) {
        try {
            perm.check(RefPermission.FORGE_SERVER);
        } catch (AuthException denied) {
            throw new CommitValidationException(String.format("amending merges from others requires '%s' permission", RefPermission.FORGE_SERVER.name()));
        } catch (PermissionBackendException e) {
            log.error("cannot check FORGE_SERVER", e);
            throw new CommitValidationException("internal auth error");
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (receiveEvent.commit.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress())) {
        try {
            // Stop authors from amending the merge commits that Gerrit itself creates.
            perm.check(RefPermission.FORGE_SERVER);
        } catch (AuthException denied) {
            throw new CommitValidationException(String.format("pushing merge commit %s by %s requires '%s' permission", receiveEvent.commit.getId(), gerritIdent.getEmailAddress(), RefPermission.FORGE_SERVER.name()));
        } catch (PermissionBackendException e) {
            log.error("cannot check FORGE_SERVER", e);
            throw new CommitValidationException("internal auth error");
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public SortedMap<String, PluginInfo> apply(TopLevelResource resource) throws BadRequestException {
    return apply();
}
#method_after
@Override
public SortedMap<String, PluginInfo> apply(TopLevelResource resource) throws BadRequestException {
    Stream<Plugin> s = Streams.stream(pluginLoader.getPlugins(all));
    if (matchPrefix != null) {
        checkMatchOptions(matchSubstring == null && matchRegex == null);
        s = s.filter(p -> p.getName().startsWith(matchPrefix));
    } else if (matchSubstring != null) {
        checkMatchOptions(matchPrefix == null && matchRegex == null);
        String substring = matchSubstring.toLowerCase(Locale.US);
        s = s.filter(p -> p.getName().toLowerCase(Locale.US).contains(substring));
    } else if (matchRegex != null) {
        checkMatchOptions(matchPrefix == null && matchSubstring == null);
        Pattern pattern = Pattern.compile(matchRegex);
        s = s.filter(p -> pattern.matcher(p.getName()).matches());
    }
    s = s.sorted(comparing(Plugin::getName));
    if (start > 0) {
        s = s.skip(start);
    }
    if (limit > 0) {
        s = s.limit(limit);
    }
    return new TreeMap<>(s.collect(Collectors.toMap(p -> p.getName(), p -> toPluginInfo(p))));
}
#end_block

#method_before
@Override
public void run() throws Exception {
    list.setAll(all);
    Map<String, PluginInfo> output = list.apply();
    if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } else {
        stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File");
        stdout.print("-------------------------------------------------------------------------------\n");
        for (Map.Entry<String, PluginInfo> p : output.entrySet()) {
            PluginInfo info = p.getValue();
            stdout.format("%-30s %-10s %-8s %s\n", p.getKey(), Strings.nullToEmpty(info.version), status(info.disabled), Strings.nullToEmpty(info.filename));
        }
    }
    stdout.flush();
}
#method_after
@Override
public void run() throws Exception {
    list.setAll(all);
    Map<String, PluginInfo> output = list.apply(TopLevelResource.INSTANCE);
    if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } else {
        stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File");
        stdout.print("-------------------------------------------------------------------------------\n");
        for (Map.Entry<String, PluginInfo> p : output.entrySet()) {
            PluginInfo info = p.getValue();
            stdout.format("%-30s %-10s %-8s %s\n", p.getKey(), Strings.nullToEmpty(info.version), status(info.disabled), Strings.nullToEmpty(info.filename));
        }
    }
    stdout.flush();
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    checkValidCLA(rsrc.getControl());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(privateByDefault || (input.isPrivate != null && input.isPrivate));
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    checkValidCLA(rsrc.getControl());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(input.isPrivate == null ? privateByDefault : input.isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(receiveConfig.privateByDefault || magicBranch.isPrivate).setWorkInProgress(magicBranch.workInProgress).setValidate(false);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#method_after
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(magicBranch.isPrivate || (receiveConfig.privateByDefault && !magicBranch.removePrivate)).setWorkInProgress(magicBranch.workInProgress).setValidate(false);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#end_block

#method_before
@Test
public void createChangeWithPrivateByDefaultEnabled() throws Exception {
    assume().that(isPrivateByDefault()).isTrue();
    ChangeInfo info = gApi.changes().create(new ChangeInput(project.get(), "master", "empty change")).get();
    assertThat(info.isPrivate).isEqualTo(true);
}
#method_after
@Test
@GerritConfig(name = "change.privateByDefault", value = "true")
public void createChangeWithPrivateByDefaultEnabled() throws Exception {
    ChangeInput input = new ChangeInput(project.get(), "master", "empty change");
    assertThat(gApi.changes().create(input).get().isPrivate).isEqualTo(true);
}
#end_block

#method_before
@Test
public void createChangeWithPrivateByDefaultDisabled() throws Exception {
    assume().that(isPrivateByDefault()).isFalse();
    ChangeInfo info = gApi.changes().create(new ChangeInput(project.get(), "master", "empty change")).get();
    assertThat(info.isPrivate).isNull();
}
#method_after
@Test
public void createChangeWithPrivateByDefaultDisabled() throws Exception {
    ChangeInfo info = gApi.changes().create(new ChangeInput(project.get(), "master", "empty change")).get();
    assertThat(info.isPrivate).isNull();
}
#end_block

#method_before
@Test
public void pushWithPrivateByDefaultEnabled() throws Exception {
    assume().that(isPrivateByDefault()).isTrue();
    assertThat(createChange().getChange().change().isPrivate()).isEqualTo(true);
}
#method_after
@Test
@GerritConfig(name = "change.privateByDefault", value = "true")
public void pushWithPrivateByDefaultEnabled() throws Exception {
    assertThat(createChange().getChange().change().isPrivate()).isEqualTo(true);
}
#end_block

#method_before
@Test
public void pushWithPrivateByDefaultDisabled() throws Exception {
    assume().that(isPrivateByDefault()).isFalse();
    assertThat(createChange().getChange().change().isPrivate()).isEqualTo(false);
}
#method_after
@Test
public void pushWithPrivateByDefaultDisabled() throws Exception {
    assertThat(createChange().getChange().change().isPrivate()).isEqualTo(false);
}
#end_block

#method_before
@Override
public void message(String msg) {
}
#method_after
@Override
public void message(String message) {
}
#end_block

#method_before
@Override
public boolean yesno(boolean def, String msg) {
    return def;
}
#method_after
@Override
public boolean yesno(boolean defaultValue, String message) {
    return defaultValue;
}
#end_block

#method_before
@Override
public String readString(String def, Set<String> allowedValues, String fmt) {
    return "";
}
#method_after
@Override
public String readString(String defaultValue, Set<String> allowedValues, String message) {
    return defaultValue;
}
#end_block

#method_before
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public void waitForUser() {
            ui.waitForUser();
        }

        @Override
        public String readString(String def, Set<String> allowedValues, String fmt) {
            return ui.readString(def, allowedValues, fmt);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#method_after
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String message) {
            System.err.println(message);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean defaultValue, String message) {
            return ui.yesno(defaultValue, message);
        }

        @Override
        public void waitForUser() {
            ui.waitForUser();
        }

        @Override
        public String readString(String defaultValue, Set<String> allowedValues, String message) {
            return ui.readString(defaultValue, allowedValues, message);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (cd.fastIsVisibleTo(user)) {
        return true;
    }
    Change change;
    try {
        change = cd.change();
        if (change == null) {
            return false;
        }
        ChangeNotes notes = notesFactory.createFromIndexedChange(change);
        ChangeControl cc = changeControl.controlFor(notes, user);
        boolean visible;
        try {
            visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ);
        } catch (PermissionBackendException e) {
            throw new OrmException("unable to check permissions", e);
        }
        if (visible) {
            cd.cacheVisibleTo(cc);
            return true;
        }
    } catch (NoSuchChangeException e) {
        // Ignored
        return false;
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (cd.fastIsVisibleTo(user)) {
        return true;
    }
    Change change = cd.change();
    if (change == null) {
        return false;
    }
    ChangeControl changeControl;
    ChangeNotes notes = notesFactory.createFromIndexedChange(change);
    try {
        changeControl = changeControlFactory.controlFor(notes, user);
    } catch (NoSuchChangeException e) {
        // Ignored
        return false;
    }
    boolean visible;
    try {
        visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ);
    } catch (PermissionBackendException e) {
        throw new OrmException("unable to check permissions", e);
    }
    if (visible) {
        cd.cacheVisibleTo(changeControl);
        return true;
    }
    return false;
}
#end_block

#method_before
private static String startTime(final Date when) {
    return format(when, TimeUtil.nowMs() - when.getTime());
}
#method_after
private static String startTime(Date when) {
    return format(when, TimeUtil.nowMs() - when.getTime());
}
#end_block

#method_before
// See GuiceRequestScopePropagator#wrapImpl
@SuppressWarnings("javadoc")
public final <T> Callable<T> wrap(final Callable<T> callable) {
    final RequestContext callerContext = checkNotNull(local.getContext());
    final Callable<T> wrapped = wrapImpl(context(callerContext, cleanup(callable)));
    return new Callable<T>() {

        @Override
        public T call() throws Exception {
            if (callerContext == local.getContext()) {
                return callable.call();
            }
            return wrapped.call();
        }

        @Override
        public String toString() {
            return callable.toString();
        }
    };
}
#method_after
// See GuiceRequestScopePropagator#wrapImpl
@SuppressWarnings("javadoc")
public final <T> Callable<T> wrap(Callable<T> callable) {
    final RequestContext callerContext = checkNotNull(local.getContext());
    final Callable<T> wrapped = wrapImpl(context(callerContext, cleanup(callable)));
    return new Callable<T>() {

        @Override
        public T call() throws Exception {
            if (callerContext == local.getContext()) {
                return callable.call();
            }
            return wrapped.call();
        }

        @Override
        public String toString() {
            return callable.toString();
        }
    };
}
#end_block

#method_before
public final Runnable wrap(final Runnable runnable) {
    final Callable<Object> wrapped = wrap(Executors.callable(runnable));
    if (runnable instanceof ProjectRunnable) {
        return new ProjectRunnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (Exception e) {
                    Throwables.throwIfUnchecked(e);
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public Project.NameKey getProjectNameKey() {
                return ((ProjectRunnable) runnable).getProjectNameKey();
            }

            @Override
            public String getRemoteName() {
                return ((ProjectRunnable) runnable).getRemoteName();
            }

            @Override
            public boolean hasCustomizedPrint() {
                return ((ProjectRunnable) runnable).hasCustomizedPrint();
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    }
    return new Runnable() {

        @Override
        public void run() {
            try {
                wrapped.call();
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                // Not possible.
                throw new RuntimeException(e);
            }
        }

        @Override
        public String toString() {
            return runnable.toString();
        }
    };
}
#method_after
public final Runnable wrap(Runnable runnable) {
    final Callable<Object> wrapped = wrap(Executors.callable(runnable));
    if (runnable instanceof ProjectRunnable) {
        return new ProjectRunnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (Exception e) {
                    Throwables.throwIfUnchecked(e);
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public Project.NameKey getProjectNameKey() {
                return ((ProjectRunnable) runnable).getProjectNameKey();
            }

            @Override
            public String getRemoteName() {
                return ((ProjectRunnable) runnable).getRemoteName();
            }

            @Override
            public boolean hasCustomizedPrint() {
                return ((ProjectRunnable) runnable).hasCustomizedPrint();
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    }
    return new Runnable() {

        @Override
        public void run() {
            try {
                wrapped.call();
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                // Not possible.
                throw new RuntimeException(e);
            }
        }

        @Override
        public String toString() {
            return runnable.toString();
        }
    };
}
#end_block

#method_before
@Override
public void setInputStream(final InputStream in) {
    this.in = in;
}
#method_after
@Override
public void setInputStream(InputStream in) {
    this.in = in;
}
#end_block

#method_before
@Override
public void setOutputStream(final OutputStream out) {
    this.out = out;
}
#method_after
@Override
public void setOutputStream(OutputStream out) {
    this.out = out;
}
#end_block

#method_before
@Override
public void setErrorStream(final OutputStream err) {
    this.err = err;
}
#method_after
@Override
public void setErrorStream(OutputStream err) {
    this.err = err;
}
#end_block

#method_before
@Override
public void setExitCallback(final ExitCallback callback) {
    this.exit = callback;
}
#method_after
@Override
public void setExitCallback(ExitCallback callback) {
    this.exit = callback;
}
#end_block

#method_before
void setName(final String prefix) {
    this.commandName = prefix;
}
#method_after
void setName(String prefix) {
    this.commandName = prefix;
}
#end_block

#method_before
public void setArguments(final String[] argv) {
    this.argv = argv;
}
#method_after
public void setArguments(String[] argv) {
    this.argv = argv;
}
#end_block

#method_before
protected void provideStateTo(final Command cmd) {
    cmd.setInputStream(in);
    cmd.setOutputStream(out);
    cmd.setErrorStream(err);
    cmd.setExitCallback(exit);
}
#method_after
protected void provideStateTo(Command cmd) {
    cmd.setInputStream(in);
    cmd.setOutputStream(out);
    cmd.setErrorStream(err);
    cmd.setExitCallback(exit);
}
#end_block

#method_before
protected void startThread(final CommandRunnable thunk) {
    final TaskThunk tt = new TaskThunk(thunk);
    if (isAdminHighPriorityCommand()) {
        // Admin commands should not block the main work threads (there
        // might be an interactive shell there), nor should they wait
        // for the main work threads.
        // 
        new Thread(tt, tt.toString()).start();
    } else {
        task.set(executor.submit(tt));
    }
}
#method_after
protected void startThread(CommandRunnable thunk) {
    final TaskThunk tt = new TaskThunk(thunk);
    if (isAdminHighPriorityCommand()) {
        // Admin commands should not block the main work threads (there
        // might be an interactive shell there), nor should they wait
        // for the main work threads.
        // 
        new Thread(tt, tt.toString()).start();
    } else {
        task.set(executor.submit(tt));
    }
}
#end_block

#method_before
protected void onExit(final int rc) {
    exit.onExit(rc);
    if (cleanup != null) {
        cleanup.run();
    }
}
#method_after
protected void onExit(int rc) {
    exit.onExit(rc);
    if (cleanup != null) {
        cleanup.run();
    }
}
#end_block

#method_before
protected static PrintWriter toPrintWriter(final OutputStream o) {
    return new PrintWriter(new BufferedWriter(new OutputStreamWriter(o, ENC)));
}
#method_after
protected static PrintWriter toPrintWriter(OutputStream o) {
    return new PrintWriter(new BufferedWriter(new OutputStreamWriter(o, ENC)));
}
#end_block

#method_before
private int handleError(final Throwable e) {
    if ((e.getClass() == IOException.class && "Pipe closed".equals(e.getMessage())) || // 
    (e.getClass() == SshException.class && "Already closed".equals(e.getMessage())) || // 
    e.getClass() == InterruptedIOException.class) {
        // 
        return 127;
    }
    if (!(e instanceof UnloggedFailure)) {
        final StringBuilder m = new StringBuilder();
        m.append("Internal server error");
        if (user.isIdentifiedUser()) {
            final IdentifiedUser u = user.asIdentifiedUser();
            m.append(" (user ");
            m.append(u.getAccount().getUserName());
            m.append(" account ");
            m.append(u.getAccountId());
            m.append(")");
        }
        m.append(" during ");
        m.append(context.getCommandLine());
        log.error(m.toString(), e);
    }
    if (e instanceof Failure) {
        final Failure f = (Failure) e;
        try {
            err.write((f.getMessage() + "\n").getBytes(ENC));
            err.flush();
        } catch (IOException e2) {
        // Ignored
        } catch (Throwable e2) {
            log.warn("Cannot send failure message to client", e2);
        }
        return f.exitCode;
    }
    try {
        err.write("fatal: internal server error\n".getBytes(ENC));
        err.flush();
    } catch (IOException e2) {
    // Ignored
    } catch (Throwable e2) {
        log.warn("Cannot send internal server error message to client", e2);
    }
    return 128;
}
#method_after
private int handleError(Throwable e) {
    if ((e.getClass() == IOException.class && "Pipe closed".equals(e.getMessage())) || // 
    (e.getClass() == SshException.class && "Already closed".equals(e.getMessage())) || // 
    e.getClass() == InterruptedIOException.class) {
        // 
        return 127;
    }
    if (!(e instanceof UnloggedFailure)) {
        final StringBuilder m = new StringBuilder();
        m.append("Internal server error");
        if (user.isIdentifiedUser()) {
            final IdentifiedUser u = user.asIdentifiedUser();
            m.append(" (user ");
            m.append(u.getAccount().getUserName());
            m.append(" account ");
            m.append(u.getAccountId());
            m.append(")");
        }
        m.append(" during ");
        m.append(context.getCommandLine());
        log.error(m.toString(), e);
    }
    if (e instanceof Failure) {
        final Failure f = (Failure) e;
        try {
            err.write((f.getMessage() + "\n").getBytes(ENC));
            err.flush();
        } catch (IOException e2) {
        // Ignored
        } catch (Throwable e2) {
            log.warn("Cannot send failure message to client", e2);
        }
        return f.exitCode;
    }
    try {
        err.write("fatal: internal server error\n".getBytes(ENC));
        err.flush();
    } catch (IOException e2) {
    // Ignored
    } catch (Throwable e2) {
        log.warn("Cannot send internal server error message to client", e2);
    }
    return 128;
}
#end_block

#method_before
public List<Task<?>> getTasks() {
    final List<Task<?>> r = new ArrayList<>();
    for (final Executor e : queues) {
        e.addAllTo(r);
    }
    return r;
}
#method_after
public List<Task<?>> getTasks() {
    final List<Task<?>> r = new ArrayList<>();
    for (Executor e : queues) {
        e.addAllTo(r);
    }
    return r;
}
#end_block

#method_before
public Task<?> getTask(final int id) {
    Task<?> result = null;
    for (final Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#method_after
public Task<?> getTask(int id) {
    Task<?> result = null;
    for (Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#end_block

#method_before
private void stop() {
    for (final Executor p : queues) {
        p.shutdown();
        boolean isTerminated;
        do {
            try {
                isTerminated = p.awaitTermination(10, TimeUnit.SECONDS);
            } catch (InterruptedException ie) {
                isTerminated = false;
            }
        } while (!isTerminated);
    }
    queues.clear();
}
#method_after
private void stop() {
    for (Executor p : queues) {
        p.shutdown();
        boolean isTerminated;
        do {
            try {
                isTerminated = p.awaitTermination(10, TimeUnit.SECONDS);
            } catch (InterruptedException ie) {
                isTerminated = false;
            }
        } while (!isTerminated);
    }
    queues.clear();
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Callable<V> callable, final RunnableScheduledFuture<V> task) {
    throw new UnsupportedOperationException("Callable not implemented");
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {
    throw new UnsupportedOperationException("Callable not implemented");
}
#end_block

#method_before
void remove(final Task<?> task) {
    all.remove(task.getTaskId(), task);
}
#method_after
void remove(Task<?> task) {
    all.remove(task.getTaskId(), task);
}
#end_block

#method_before
Task<?> getTask(final int id) {
    return all.get(id);
}
#method_after
Task<?> getTask(int id) {
    return all.get(id);
}
#end_block

#method_before
void addAllTo(final List<Task<?>> list) {
    // iterator is thread safe
    list.addAll(all.values());
}
#method_after
void addAllTo(List<Task<?>> list) {
    // iterator is thread safe
    list.addAll(all.values());
}
#end_block

#method_before
@Override
public ScheduledThreadPoolExecutor get() {
    final ScheduledThreadPoolExecutor executor;
    executor = queues.createQueue(poolSize, "SSH-Stream-Worker");
    final ThreadFactory parent = executor.getThreadFactory();
    executor.setThreadFactory(new ThreadFactory() {

        @Override
        public Thread newThread(final Runnable task) {
            final Thread t = parent.newThread(task);
            t.setPriority(Thread.MIN_PRIORITY);
            return t;
        }
    });
    return executor;
}
#method_after
@Override
public ScheduledThreadPoolExecutor get() {
    final ScheduledThreadPoolExecutor executor;
    executor = queues.createQueue(poolSize, "SSH-Stream-Worker");
    final ThreadFactory parent = executor.getThreadFactory();
    executor.setThreadFactory(new ThreadFactory() {

        @Override
        public Thread newThread(Runnable task) {
            final Thread t = parent.newThread(task);
            t.setPriority(Thread.MIN_PRIORITY);
            return t;
        }
    });
    return executor;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(UTF_8));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    eventListenerRegistration = eventListeners.add(new UserScopedEventListener() {

        @Override
        public void onEvent(final Event event) {
            if (subscribedToEvents.isEmpty() || subscribedToEvents.contains(event.getType())) {
                offer(event);
            }
        }

        @Override
        public CurrentUser getUser() {
            return currentUser;
        }
    });
    gson = new GsonBuilder().registerTypeAdapter(Supplier.class, new SupplierSerializer()).registerTypeAdapter(Project.NameKey.class, new ProjectNameKeySerializer()).create();
}
#method_after
@Override
public void start(Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(UTF_8));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    eventListenerRegistration = eventListeners.add(new UserScopedEventListener() {

        @Override
        public void onEvent(Event event) {
            if (subscribedToEvents.isEmpty() || subscribedToEvents.contains(event.getType())) {
                offer(event);
            }
        }

        @Override
        public CurrentUser getUser() {
            return currentUser;
        }
    });
    gson = new GsonBuilder().registerTypeAdapter(Supplier.class, new SupplierSerializer()).registerTypeAdapter(Project.NameKey.class, new ProjectNameKeySerializer()).create();
}
#end_block

#method_before
@Override
protected void onExit(final int rc) {
    eventListenerRegistration.remove();
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#method_after
@Override
protected void onExit(int rc) {
    eventListenerRegistration.remove();
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#end_block

#method_before
private void offer(final Event event) {
    synchronized (taskLock) {
        if (!queue.offer(event)) {
            dropped = true;
        }
        if (task == null && !done) {
            task = pool.submit(writer);
        }
    }
}
#method_after
private void offer(Event event) {
    synchronized (taskLock) {
        if (!queue.offer(event)) {
            dropped = true;
        }
        if (task == null && !done) {
            task = pool.submit(writer);
        }
    }
}
#end_block

#method_before
private void write(final Object message) {
    String msg = null;
    try {
        msg = gson.toJson(message) + "\n";
    } catch (Exception e) {
        log.warn("Could not deserialize the msg: ", e);
    }
    if (msg != null) {
        synchronized (stdout) {
            stdout.print(msg);
        }
    }
}
#method_after
private void write(Object message) {
    String msg = null;
    try {
        msg = gson.toJson(message) + "\n";
    } catch (Exception e) {
        log.warn("Could not deserialize the msg: ", e);
    }
    if (msg != null) {
        synchronized (stdout) {
            stdout.print(msg);
        }
    }
}
#end_block

#method_before
@Provides
@Singleton
@Named(TIMEOUT_NAME)
long getTimeoutMillis(@GerritServerConfig final Config cfg) {
    return ConfigUtil.getTimeUnit(cfg, "receive", null, "timeout", TimeUnit.MINUTES.toMillis(4), TimeUnit.MILLISECONDS);
}
#method_after
@Provides
@Singleton
@Named(TIMEOUT_NAME)
long getTimeoutMillis(@GerritServerConfig Config cfg) {
    return ConfigUtil.getTimeUnit(cfg, "receive", null, "timeout", TimeUnit.MINUTES.toMillis(4), TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public void onPreReceive(final ReceivePack rp, final Collection<ReceiveCommand> commands) {
    try {
        progress.waitFor(executor.submit(scopePropagator.wrap(new Worker(commands))), timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (ExecutionException e) {
        log.warn(String.format("Error in ReceiveCommits while processing changes for project %s", rc.getProject().getName()), e);
        rc.addError("internal error while processing changes");
        // point is very bad.
        for (final ReceiveCommand c : commands) {
            if (c.getResult() == Result.NOT_ATTEMPTED) {
                c.setResult(Result.REJECTED_OTHER_REASON, "internal error");
            }
        }
    } finally {
        rc.sendMessages();
    }
}
#method_after
@Override
public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) {
    try {
        progress.waitFor(executor.submit(scopePropagator.wrap(new Worker(commands))), timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (ExecutionException e) {
        log.warn(String.format("Error in ReceiveCommits while processing changes for project %s", rc.getProject().getName()), e);
        rc.addError("internal error while processing changes");
        // point is very bad.
        for (ReceiveCommand c : commands) {
            if (c.getResult() == Result.NOT_ATTEMPTED) {
                c.setResult(Result.REJECTED_OTHER_REASON, "internal error");
            }
        }
    } finally {
        rc.sendMessages();
    }
}
#end_block

#method_before
private void setThreadFactory(ScheduledThreadPoolExecutor executor) {
    final ThreadFactory parent = executor.getThreadFactory();
    executor.setThreadFactory(new ThreadFactory() {

        @Override
        public Thread newThread(final Runnable task) {
            final Thread t = parent.newThread(task);
            t.setPriority(Thread.MIN_PRIORITY);
            return t;
        }
    });
}
#method_after
private void setThreadFactory(ScheduledThreadPoolExecutor executor) {
    final ThreadFactory parent = executor.getThreadFactory();
    executor.setThreadFactory(new ThreadFactory() {

        @Override
        public Thread newThread(Runnable task) {
            final Thread t = parent.newThread(task);
            t.setPriority(Thread.MIN_PRIORITY);
            return t;
        }
    });
}
#end_block

#method_before
static String computeCanonicalPath(String canonicalURL) throws URISyntaxException {
    if (canonicalURL == null) {
        return "";
    }
    // If we serving from a sub-directory rather than root, determine the path
    // from the cannonical web URL.
    URI uri = new URI(canonicalURL);
    return uri.getPath().replaceAll("/$", "");
}
#method_after
static String computeCanonicalPath(String canonicalURL) throws URISyntaxException {
    if (Strings.isNullOrEmpty(canonicalURL)) {
        return "";
    }
    // If we serving from a sub-directory rather than root, determine the path
    // from the cannonical web URL.
    URI uri = new URI(canonicalURL);
    return uri.getPath().replaceAll("/$", "");
}
#end_block

#method_before
public String getPluginName(Path srcPath) {
    return MoreObjects.firstNonNull(getGerritPluginName(srcPath), nameOf(srcPath));
}
#method_after
public String getPluginName(Path srcPath) {
    return MoreObjects.firstNonNull(getGerritPluginName(srcPath), PluginUtil.nameOf(srcPath));
}
#end_block

#method_before
public String installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    checkRemoteInstall();
    String fileName = originalName;
    Path tmp = asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = MoreObjects.firstNonNull(getGerritPluginName(tmp), nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>, use it instead of the input name: <%s>", name, originalName));
    }
    String fileExtension = getExtension(fileName);
    Path dst = pluginsDir.resolve(name + fileExtension);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getFileName().toString();
            log.info(String.format("Replacing plugin %s", active.getName()));
            Path old = pluginsDir.resolve(".last_" + fileName);
            Files.deleteIfExists(old);
            Files.move(active.getSrcFile(), old);
        }
        Files.deleteIfExists(pluginsDir.resolve(fileName + ".disabled"));
        Files.move(tmp, dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            Files.deleteIfExists(dst);
            throw e;
        }
        cleanInBackground();
    }
    return name;
}
#method_after
public String installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    checkRemoteInstall();
    String fileName = originalName;
    Path tmp = PluginUtil.asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = MoreObjects.firstNonNull(getGerritPluginName(tmp), PluginUtil.nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>, use it instead of the input name: <%s>", name, originalName));
    }
    String fileExtension = getExtension(fileName);
    Path dst = pluginsDir.resolve(name + fileExtension);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getFileName().toString();
            log.info(String.format("Replacing plugin %s", active.getName()));
            Path old = pluginsDir.resolve(".last_" + fileName);
            Files.deleteIfExists(old);
            Files.move(active.getSrcFile(), old);
        }
        Files.deleteIfExists(pluginsDir.resolve(fileName + ".disabled"));
        Files.move(tmp, dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            Files.deleteIfExists(dst);
            throw e;
        }
        cleanInBackground();
    }
    return name;
}
#end_block

#method_before
@Override
public synchronized void start() {
    removeStalePluginFiles();
    log.info("Loading plugins from " + pluginsDir.toAbsolutePath());
    srvInfoImpl.state = ServerInformation.State.STARTUP;
    rescan();
    srvInfoImpl.state = ServerInformation.State.RUNNING;
    if (scanner != null) {
        scanner.start();
    }
}
#method_after
@Override
public synchronized void start() {
    removeStalePluginFiles();
    Path absolutePath = pluginsDir.toAbsolutePath();
    if (!Files.exists(absolutePath)) {
        log.info(absolutePath + " does not exist; creating");
        try {
            Files.createDirectories(absolutePath);
        } catch (IOException e) {
            log.error(String.format("Failed to create %s: %s", absolutePath, e.getMessage()));
        }
    }
    log.info("Loading plugins from " + absolutePath);
    srvInfoImpl.state = ServerInformation.State.STARTUP;
    rescan();
    srvInfoImpl.state = ServerInformation.State.RUNNING;
    if (scanner != null) {
        scanner.start();
    }
}
#end_block

#method_before
private static String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext) : "";
}
#method_after
private String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext) : "";
}
#end_block

#method_before
private String getPluginCanonicalWebUrl(String name) {
    String canonicalWebUrl = urlProvider.get();
    if (canonicalWebUrl == null) {
        canonicalWebUrl = "";
    }
    String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl), name);
    return url;
}
#method_after
private String getPluginCanonicalWebUrl(String name) {
    String canonicalWebUrl = urlProvider.get();
    if (Strings.isNullOrEmpty(canonicalWebUrl)) {
        return "/plugins/" + name;
    }
    String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl), name);
    return url;
}
#end_block

#method_before
// Only one active plugin per plugin name can exist for each plugin name.
private static Map<String, Path> filterDisabled(SetMultimap<String, Path> pluginPaths) {
    Map<String, Path> activePlugins = Maps.newHashMapWithExpectedSize(pluginPaths.keys().size());
    for (String name : pluginPaths.keys()) {
        for (Path pluginPath : pluginPaths.asMap().get(name)) {
            if (!pluginPath.getFileName().toString().endsWith(".disabled")) {
                assert !activePlugins.containsKey(name);
                activePlugins.put(name, pluginPath);
            }
        }
    }
    return activePlugins;
}
#method_after
// Only one active plugin per plugin name can exist for each plugin name.
private Map<String, Path> filterDisabled(SetMultimap<String, Path> pluginPaths) {
    Map<String, Path> activePlugins = Maps.newHashMapWithExpectedSize(pluginPaths.keys().size());
    for (String name : pluginPaths.keys()) {
        for (Path pluginPath : pluginPaths.asMap().get(name)) {
            if (!pluginPath.getFileName().toString().endsWith(".disabled")) {
                assert !activePlugins.containsKey(name);
                activePlugins.put(name, pluginPath);
            }
        }
    }
    return activePlugins;
}
#end_block

#method_before
private List<Path> scanPathsInPluginsDirectory(Path pluginsDir) {
    try {
        return listPlugins(pluginsDir);
    } catch (IOException e) {
        log.error("Cannot list " + pluginsDir.toAbsolutePath(), e);
        return ImmutableList.of();
    }
}
#method_after
private List<Path> scanPathsInPluginsDirectory(Path pluginsDir) {
    try {
        return PluginUtil.listPlugins(pluginsDir);
    } catch (IOException e) {
        log.error("Cannot list " + pluginsDir.toAbsolutePath(), e);
        return ImmutableList.of();
    }
}
#end_block

#method_before
private static Iterable<Path> filterDisabledPlugins(Collection<Path> paths) {
    return Iterables.filter(paths, p -> !p.getFileName().toString().endsWith(".disabled"));
}
#method_after
private Iterable<Path> filterDisabledPlugins(Collection<Path> paths) {
    return Iterables.filter(paths, p -> !p.getFileName().toString().endsWith(".disabled"));
}
#end_block

#method_before
private static boolean isUiPlugin(String name) {
    return isPlugin(name, "js") || isPlugin(name, "html");
}
#method_after
private boolean isUiPlugin(String name) {
    return isPlugin(name, "js") || isPlugin(name, "html");
}
#end_block

#method_before
private static boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#method_after
private boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#end_block

#method_before
private static String getHostName(String canonicalWebUrl) {
    try {
        return new URI(canonicalWebUrl).getHost();
    } catch (URISyntaxException e) {
        return null;
    }
}
#method_after
private static String getHostName(String canonicalWebUrl) {
    if (canonicalWebUrl == null) {
        log.error("No canonicalWebUrl defined in gerrit.config, OAuth may not work properly");
        return null;
    }
    try {
        return new URI(canonicalWebUrl).getHost();
    } catch (URISyntaxException e) {
        log.error("Invalid canonicalWebUrl '" + canonicalWebUrl + "'", e);
        return null;
    }
}
#end_block

#method_before
private String getShortenedCommentMessage(Comment comment) {
    final int THRESHOLD = 100;
    final String fullMessage = comment.message.trim();
    String msg = fullMessage;
    if (msg.length() > THRESHOLD) {
        msg = msg.substring(0, THRESHOLD);
    }
    int lf = msg.indexOf('\n');
    int period = msg.lastIndexOf('.');
    if (lf > 0) {
        // Truncate if a line feed appears within the threshold.
        msg = msg.substring(0, lf);
    } else if (period > 0) {
        // Otherwise truncate if there is a period within the threshold.
        msg = msg.substring(0, period + 1);
    }
    // Append an ellipsis if the message has been truncated.
    if (!msg.equals(fullMessage)) {
        msg += " […]";
    }
    return msg;
}
#method_after
protected static String getShortenedCommentMessage(String message) {
    int threshold = 100;
    String fullMessage = message.trim();
    String msg = fullMessage;
    if (msg.length() > threshold) {
        msg = msg.substring(0, threshold);
    }
    int lf = msg.indexOf('\n');
    int period = msg.lastIndexOf('.');
    if (lf > 0) {
        // Truncate if a line feed appears within the threshold.
        msg = msg.substring(0, lf);
    } else if (period > 0) {
        // Otherwise truncate if there is a period within the threshold.
        msg = msg.substring(0, period + 1);
    }
    // Append an ellipsis if the message has been truncated.
    if (!msg.equals(fullMessage)) {
        msg += " […]";
    }
    return msg;
}
#end_block

#method_before
private String getShortenedCommentMessage(Comment comment) {
    final int THRESHOLD = 100;
    final String fullMessage = comment.message.trim();
    String msg = fullMessage;
    if (msg.length() > THRESHOLD) {
        msg = msg.substring(0, THRESHOLD);
    }
    int lf = msg.indexOf('\n');
    int period = msg.lastIndexOf('.');
    if (lf > 0) {
        // Truncate if a line feed appears within the threshold.
        msg = msg.substring(0, lf);
    } else if (period > 0) {
        // Otherwise truncate if there is a period within the threshold.
        msg = msg.substring(0, period + 1);
    }
    // Append an ellipsis if the message has been truncated.
    if (!msg.equals(fullMessage)) {
        msg += " […]";
    }
    return msg;
}
#method_after
protected static String getShortenedCommentMessage(Comment comment) {
    return getShortenedCommentMessage(comment.message);
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    testRule.schema151.migrateData(testRule.db, new TestUpdateUI());
    AccountGroup group = testRule.db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isAtLeast(testStartTime);
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isAtLeast(testStartTime);
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    testRule.schema151.migrateData(testRule.db, new TestUpdateUI());
    AccountGroup group = testRule.db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#end_block

#method_before
private AccountGroup.Id createGroup(String name) throws Exception {
    GroupInput groupInput = new GroupInput();
    groupInput.name = name;
    GroupInfo groupInfo = testRule.createGroupFactory.create(name).apply(TopLevelResource.INSTANCE, groupInput);
    return new Id(groupInfo.groupId);
}
#method_after
private AccountGroup.Id createGroup(String name) throws Exception {
    GroupInput groupInput = new GroupInput();
    groupInput.name = name;
    GroupInfo groupInfo = createGroupFactory.create(name).apply(TopLevelResource.INSTANCE, groupInput);
    return new Id(groupInfo.groupId);
}
#end_block

#method_before
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws OrmException {
    AccountGroup group = testRule.db.accountGroups().get(groupId);
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    group.setCreatedOn(Timestamp.from(instant));
    testRule.db.accountGroups().update(ImmutableList.of(group));
}
#method_after
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws OrmException {
    AccountGroup group = db.accountGroups().get(groupId);
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    group.setCreatedOn(Timestamp.from(instant));
    db.accountGroups().update(ImmutableList.of(group));
}
#end_block

#method_before
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    ResultSet<AccountGroupMemberAudit> groupMemberAudits = testRule.db.accountGroupMembersAudit().byGroup(groupId);
    testRule.db.accountGroupMembersAudit().delete(groupMemberAudits);
}
#method_after
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(groupId);
    db.accountGroupMembersAudit().delete(groupMemberAudits);
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding("UTF-8");
    try {
        Context.setForwardedEvent(true);
        if (!MediaType.parse(req.getContentType()).is(JSON_UTF_8)) {
            sendError(rsp, SC_UNSUPPORTED_MEDIA_TYPE, "Expecting " + JSON_UTF_8.toString() + " content type");
            return;
        }
        Event event = getEventFromRequest(req);
        dispatcher.postEvent(event);
        rsp.setStatus(SC_NO_CONTENT);
    } catch (OrmException e) {
        logger.debug("Error trying to find a change ", e);
        sendError(rsp, SC_NOT_FOUND, "Change not found\n");
    } catch (IOException e) {
        logger.error("Unable to re-trigger event", e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    } catch (PermissionBackendException e) {
        logger.error("Unable to re-trigger event", e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    } finally {
        Context.unsetForwardedEvent();
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding("UTF-8");
    try {
        Context.setForwardedEvent(true);
        if (!MediaType.parse(req.getContentType()).is(JSON_UTF_8)) {
            sendError(rsp, SC_UNSUPPORTED_MEDIA_TYPE, "Expecting " + JSON_UTF_8.toString() + " content type");
            return;
        }
        Event event = getEventFromRequest(req);
        dispatcher.postEvent(event);
        rsp.setStatus(SC_NO_CONTENT);
    } catch (OrmException e) {
        logger.debug("Error trying to find a change ", e);
        sendError(rsp, SC_NOT_FOUND, "Change not found\n");
    } catch (IOException | PermissionBackendException e) {
        logger.error("Unable to re-trigger event", e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    } finally {
        Context.unsetForwardedEvent();
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage())));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        bu.setRefLogMessage("push");
        logDebug("Adding {} replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logDebug("Adding {} create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logDebug("Adding {} group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logDebug("Adding {} additional ref updates", actualCommands.size());
        actualCommands.forEach(c -> bu.addRepoOnlyOp(new UpdateOneRefOp(c)));
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranchCmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException | UpdateException | IOException | ConfigInvalidException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage())));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        bu.setRefLogMessage("push");
        logDebug("Adding {} replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logDebug("Adding {} create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logDebug("Adding {} group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logDebug("Adding {} additional ref updates", actualCommands.size());
        actualCommands.forEach(c -> bu.addRepoOnlyOp(new UpdateOneRefOp(c)));
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranchCmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException | UpdateException | IOException | ConfigInvalidException | PermissionBackendException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException, PermissionBackendException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetIdFromAllRefsMap(allRefs(), notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#method_after
private void newPatchSet() throws IOException, OrmException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetIdFromAllRefsMap(allRefs(), notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage())));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        bu.setRefLogMessage("push");
        logDebug("Adding {} replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logDebug("Adding {} create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logDebug("Adding {} group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logDebug("Adding {} additional ref updates", actualCommands.size());
        actualCommands.forEach(c -> bu.addRepoOnlyOp(new UpdateOneRefOp(c)));
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranchCmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException | UpdateException | IOException | ConfigInvalidException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage())));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        bu.setRefLogMessage("push");
        logDebug("Adding {} replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logDebug("Adding {} create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logDebug("Adding {} group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logDebug("Adding {} additional ref updates", actualCommands.size());
        actualCommands.forEach(c -> bu.addRepoOnlyOp(new UpdateOneRefOp(c)));
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranchCmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException | UpdateException | IOException | ConfigInvalidException | PermissionBackendException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException, PermissionBackendException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetIdFromAllRefsMap(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#method_after
private void newPatchSet() throws IOException, OrmException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetIdFromAllRefsMap(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Map<String, Ref> oldRefs = rp.getAdvertisedRefs();
    checkState(oldRefs != null, "expected refs to previously be advertised; %s assumes it is not the first %s in the chain", getClass().getSimpleName(), AdvertiseRefsHook.class.getSimpleName());
    Result r = advertiseRefs(oldRefs);
    rp.setAdvertisedRefs(r.allRefs(), r.additionalHaves());
}
#method_after
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Result r = advertiseRefs(HookUtil.ensureAllRefsAdvertised(rp));
    rp.setAdvertisedRefs(r.allRefs(), r.additionalHaves());
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#end_block

#method_before
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    CacheHeaders.setNotCacheable(rsp);
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        rsp.setContentLength(raw.length);
        try (OutputStream out = rsp.getOutputStream()) {
            out.write(raw);
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(req.getContextPath());
        rdr.append("/");
        if (res.isNew()) {
            rdr.append('#' + PageLinks.REGISTER);
        } else {
            rdr.append(LoginUrlToken.getToken(req));
        }
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        try (Writer out = rsp.getWriter()) {
            out.write("<html>");
            out.write("<body>");
            out.write("<h1>Account Not Found</h1>");
            out.write("</body>");
            out.write("</html>");
        }
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    CacheHeaders.setNotCacheable(rsp);
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        rsp.setContentLength(raw.length);
        try (OutputStream out = rsp.getOutputStream()) {
            out.write(raw);
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(req.getContextPath());
        rdr.append("/");
        if (res.isNew()) {
            rdr.append('#' + PageLinks.REGISTER);
        } else {
            rdr.append(LoginUrlToken.getToken(req));
        }
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        try (Writer out = rsp.getWriter()) {
            out.write("<html>");
            out.write("<body>");
            out.write("<h1>Account Not Found</h1>");
            out.write("</body>");
            out.write("</html>");
        }
    }
}
#end_block

#method_before
private byte[] prepareHtmlOutput() throws IOException, OrmException {
    final String pageName = "BecomeAnyAccount.html";
    Document doc = headers.parse(getClass(), pageName);
    if (doc == null) {
        throw new FileNotFoundException("No " + pageName + " in webapp");
    }
    Element userlistElement = HtmlDomUtil.find(doc, "userlist");
    try (ReviewDb db = schema.open()) {
        ResultSet<Account> accounts = db.accounts().firstNById(100);
        for (Account a : accounts) {
            String displayName;
            if (a.getUserName() != null) {
                displayName = a.getUserName();
            } else if (a.getFullName() != null && !a.getFullName().isEmpty()) {
                displayName = a.getFullName();
            } else if (a.getPreferredEmail() != null) {
                displayName = a.getPreferredEmail();
            } else {
                displayName = a.getId().toString();
            }
            Element linkElement = doc.createElement("a");
            linkElement.setAttribute("href", "?account_id=" + a.getId().toString());
            linkElement.setTextContent(displayName);
            userlistElement.appendChild(linkElement);
            userlistElement.appendChild(doc.createElement("br"));
        }
    }
    return HtmlDomUtil.toUTF8(doc);
}
#method_after
private byte[] prepareHtmlOutput() throws IOException, OrmException {
    final String pageName = "BecomeAnyAccount.html";
    Document doc = headers.parse(getClass(), pageName);
    if (doc == null) {
        throw new FileNotFoundException("No " + pageName + " in webapp");
    }
    Element userlistElement = HtmlDomUtil.find(doc, "userlist");
    try (ReviewDb db = schema.open()) {
        for (Account.Id accountId : accounts.firstNIds(100)) {
            Account a = accountCache.get(accountId).getAccount();
            String displayName;
            if (a.getUserName() != null) {
                displayName = a.getUserName();
            } else if (a.getFullName() != null && !a.getFullName().isEmpty()) {
                displayName = a.getFullName();
            } else if (a.getPreferredEmail() != null) {
                displayName = a.getPreferredEmail();
            } else {
                displayName = accountId.toString();
            }
            Element linkElement = doc.createElement("a");
            linkElement.setAttribute("href", "?account_id=" + a.getId().toString());
            linkElement.setTextContent(displayName);
            userlistElement.appendChild(linkElement);
            userlistElement.appendChild(doc.createElement("br"));
        }
    }
    return HtmlDomUtil.toUTF8(doc);
}
#end_block

#method_before
private AuthResult auth(final Account account) {
    if (account != null) {
        return new AuthResult(account.getId(), null, false);
    }
    return null;
}
#method_after
private AuthResult auth(Account account) {
    if (account != null) {
        return new AuthResult(account.getId(), null, false);
    }
    return null;
}
#end_block

#method_before
private AuthResult byUserName(final String userName) {
    try {
        List<AccountState> accountStates = accountQuery.byExternalId(SCHEME_USERNAME, userName);
        if (accountStates.isEmpty()) {
            getServletContext().log("No accounts with username " + userName + " found");
            return null;
        }
        if (accountStates.size() > 1) {
            getServletContext().log("Multiple accounts with username " + userName + " found");
            return null;
        }
        return auth(accountStates.get(0).getAccount().getId());
    } catch (OrmException e) {
        getServletContext().log("cannot query account index", e);
        return null;
    }
}
#method_after
private AuthResult byUserName(String userName) {
    try {
        List<AccountState> accountStates = accountQuery.byExternalId(SCHEME_USERNAME, userName);
        if (accountStates.isEmpty()) {
            getServletContext().log("No accounts with username " + userName + " found");
            return null;
        }
        if (accountStates.size() > 1) {
            getServletContext().log("Multiple accounts with username " + userName + " found");
            return null;
        }
        return auth(accountStates.get(0).getAccount().getId());
    } catch (OrmException e) {
        getServletContext().log("cannot query account index", e);
        return null;
    }
}
#end_block

#method_before
private AuthResult byPreferredEmail(final String email) {
    Set<Account> matches = accountCache.getByPreferredEmail(email).stream().map(a -> a.getAccount()).collect(toSet());
    return matches.size() == 1 ? auth(Iterables.getOnlyElement(matches)) : null;
}
#method_after
private AuthResult byPreferredEmail(String email) {
    try (ReviewDb db = schema.open()) {
        Optional<Account> match = accountQuery.byPreferredEmail(email).stream().filter(a -> email.equalsIgnoreCase(a.getAccount().getPreferredEmail())).map(AccountState::getAccount).findFirst();
        return match.isPresent() ? auth(match.get()) : null;
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#end_block

#method_before
private AuthResult byAccountId(final String idStr) {
    final Account.Id id;
    try {
        id = Account.Id.parse(idStr);
    } catch (NumberFormatException nfe) {
        return null;
    }
    try (ReviewDb db = schema.open()) {
        return auth(db.accounts().get(id));
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#method_after
private AuthResult byAccountId(String idStr) {
    final Account.Id id;
    try {
        id = Account.Id.parse(idStr);
    } catch (NumberFormatException nfe) {
        return null;
    }
    try (ReviewDb db = schema.open()) {
        return auth(accounts.get(db, id));
    } catch (OrmException | IOException | ConfigInvalidException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#end_block

#method_before
public boolean canRead(ProjectState state, Repository repo, RevCommit commit) {
    Project.NameKey project = state.getProject().getNameKey();
    // Look for changes associated with the commit.
    try {
        PermissionBackend.WithUser perm = permissionBackend.user(user).database(db);
        List<ChangeData> changes = queryProvider.get().byProjectCommit(project, commit);
        if (!perm.filterChangeData(ChangePermission.READ, changes).isEmpty()) {
            return true;
        }
    } catch (OrmException | PermissionBackendException e) {
        log.error("Cannot look up change for commit " + commit.name() + " in " + project, e);
    }
    return isReachableFrom(state, repo, commit, repo.getAllRefs());
}
#method_after
public boolean canRead(ProjectState state, Repository repo, RevCommit commit) {
    Project.NameKey project = state.getProject().getNameKey();
    // Look for changes associated with the commit.
    try {
        List<ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit);
        if (!changes.isEmpty()) {
            return true;
        }
    } catch (OrmException e) {
        log.error("Cannot look up change for commit " + commit.name() + " in " + project, e);
    }
    return isReachableFrom(state, repo, commit, repo.getAllRefs());
}
#end_block

#method_before
public boolean isReachableFrom(ProjectState state, Repository repo, RevCommit commit, Map<String, Ref> refs) {
    try (RevWalk rw = new RevWalk(repo)) {
        refs = refFilter.create(state, repo).filter(refs, true);
        return !refs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, refs.values());
    } catch (IOException e) {
        log.error(String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), state.getProject().getNameKey()), e);
        return false;
    }
}
#method_after
public boolean isReachableFrom(ProjectState state, Repository repo, RevCommit commit, Map<String, Ref> refs) {
    try (RevWalk rw = new RevWalk(repo)) {
        refs = refFilter.create(state, repo).filter(refs, true);
        return IncludedInResolver.includedInAny(repo, rw, commit, refs.values());
    } catch (IOException e) {
        log.error(String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), state.getProject().getNameKey()), e);
        return false;
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    repoManager = new InMemoryRepositoryManager();
    projectCache = new ProjectCache() {

        @Override
        public ProjectState getAllProjects() {
            return get(allProjectsName);
        }

        @Override
        public ProjectState getAllUsers() {
            return null;
        }

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }

        @Override
        public Set<AccountGroup.UUID> guessRelevantGroupUUIDs() {
            return Collections.emptySet();
        }

        @Override
        public ProjectState checkedGet(Project.NameKey projectName) throws IOException {
            return all.get(projectName);
        }

        @Override
        public void evict(Project.NameKey p) {
        }
    };
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    try {
        Repository repo = repoManager.createRepository(allProjectsName);
        ProjectConfig allProjects = new ProjectConfig(new Project.NameKey(allProjectsName.get()));
        allProjects.load(repo);
        LabelType cr = Util.codeReview();
        allProjects.getLabelSections().put(cr.getName(), cr);
        add(allProjects);
    } catch (IOException | ConfigInvalidException e) {
        throw new RuntimeException(e);
    }
    db = schemaFactory.open();
    singleVersionListener.start();
    try {
        schemaCreator.create(db);
    } finally {
        singleVersionListener.stop();
    }
    Cache<SectionSortCache.EntryKey, SectionSortCache.EntryVal> c = CacheBuilder.newBuilder().build();
    sectionSorter = new PermissionCollection.Factory(new SectionSortCache(c));
    parent = new ProjectConfig(parentKey);
    parent.load(newRepository(parentKey));
    add(parent);
    local = new ProjectConfig(localKey);
    local.load(newRepository(localKey));
    add(local);
    local.getProject().setParentName(parentKey);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return null;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
    changeControlFactory = injector.getInstance(ChangeControl.Factory.class);
}
#method_after
@Before
public void setUp() throws Exception {
    repoManager = new InMemoryRepositoryManager();
    projectCache = new ProjectCache() {

        @Override
        public ProjectState getAllProjects() {
            return get(allProjectsName);
        }

        @Override
        public ProjectState getAllUsers() {
            return null;
        }

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public void remove(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }

        @Override
        public Set<AccountGroup.UUID> guessRelevantGroupUUIDs() {
            return Collections.emptySet();
        }

        @Override
        public ProjectState checkedGet(Project.NameKey projectName) throws IOException {
            return all.get(projectName);
        }

        @Override
        public void evict(Project.NameKey p) {
        }
    };
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    try {
        Repository repo = repoManager.createRepository(allProjectsName);
        ProjectConfig allProjects = new ProjectConfig(new Project.NameKey(allProjectsName.get()));
        allProjects.load(repo);
        LabelType cr = Util.codeReview();
        allProjects.getLabelSections().put(cr.getName(), cr);
        add(allProjects);
    } catch (IOException | ConfigInvalidException e) {
        throw new RuntimeException(e);
    }
    db = schemaFactory.open();
    singleVersionListener.start();
    try {
        schemaCreator.create(db);
    } finally {
        singleVersionListener.stop();
    }
    Cache<SectionSortCache.EntryKey, SectionSortCache.EntryVal> c = CacheBuilder.newBuilder().build();
    sectionSorter = new PermissionCollection.Factory(new SectionSortCache(c));
    parent = new ProjectConfig(parentKey);
    parent.load(newRepository(parentKey));
    add(parent);
    local = new ProjectConfig(localKey);
    local.load(newRepository(localKey));
    add(local);
    local.getProject().setParentName(parentKey);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return null;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
    changeControlFactory = injector.getInstance(ChangeControl.Factory.class);
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    checkValidCLA(rsrc.getControl());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(input.isPrivate != null && input.isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    checkValidCLA(rsrc.getControl());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(input.isPrivate == null ? privateByDefault : input.isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Test
@Sandboxed
@GerritConfig(name = "user.readAccountsFromGit", value = "true")
public void deleteUserBranchWithAccessDatabaseCapability() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.DELETE, true, REGISTERED_USERS);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    String userRef = RefNames.refsUsers(admin.id);
    PushResult r = deleteRef(allUsersRepo, userRef);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(userRef);
    assertThat(refUpdate.getStatus()).isEqualTo(RemoteRefUpdate.Status.OK);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(userRef)).isNull();
    }
    assertThat(accountCache.getOrNull(admin.id)).isNull();
    accountQuery.byDefault(admin.id.toString()).isEmpty();
}
#method_after
@Test
@Sandboxed
@GerritConfig(name = "user.readAccountsFromGit", value = "true")
public void deleteUserBranchWithAccessDatabaseCapability() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.DELETE, true, REGISTERED_USERS);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    String userRef = RefNames.refsUsers(admin.id);
    PushResult r = deleteRef(allUsersRepo, userRef);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(userRef);
    assertThat(refUpdate.getStatus()).isEqualTo(RemoteRefUpdate.Status.OK);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(userRef)).isNull();
    }
    assertThat(accountCache.getOrNull(admin.id)).isNull();
    assertThat(accountQuery.byDefault(admin.id.toString())).isEmpty();
}
#end_block

#method_before
@Override
public Set<ExternalId> byAccount(Account.Id accountId) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).byAccount().get(accountId);
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by account", e);
    }
}
#method_after
@Override
public Set<ExternalId> byAccount(Account.Id accountId) throws IOException {
    return get().byAccount().get(accountId);
}
#end_block

#method_before
@Override
public ImmutableSetMultimap<Account.Id, ExternalId> allByAccount() throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).byAccount();
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by account", e);
    }
}
#method_after
@Override
public ImmutableSetMultimap<Account.Id, ExternalId> allByAccount() throws IOException {
    return get().byAccount();
}
#end_block

#method_before
@Override
public ImmutableSetMultimap<String, ExternalId> byEmails(String... emails) throws IOException {
    try {
        AllExternalIds allExternalIds = extIdsByAccount.get(externalIdReader.readRevision());
        ImmutableSetMultimap.Builder<String, ExternalId> byEmails = ImmutableSetMultimap.builder();
        for (String email : emails) {
            byEmails.putAll(email, allExternalIds.byEmail().get(email));
        }
        return byEmails.build();
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by email", e);
    }
}
#method_after
@Override
public ImmutableSetMultimap<String, ExternalId> byEmails(String... emails) throws IOException {
    AllExternalIds allExternalIds = get();
    ImmutableSetMultimap.Builder<String, ExternalId> byEmails = ImmutableSetMultimap.builder();
    for (String email : emails) {
        byEmails.putAll(email, allExternalIds.byEmail().get(email));
    }
    return byEmails.build();
}
#end_block

#method_before
@Override
public ImmutableSetMultimap<String, ExternalId> allByEmail() throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).byEmail();
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by account", e);
    }
}
#method_after
@Override
public ImmutableSetMultimap<String, ExternalId> allByEmail() throws IOException {
    return get().byEmail();
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (LabelVote d : labelDelta) {
        buf.append(" ").append(d.format());
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (in.ready) {
        buf.append("\n\nThis change is ready for review.");
    }
    if (buf.length() == 0) {
        return false;
    }
    message = ChangeMessagesUtil.newMessage(psId, user, ctx.getWhen(), "Patch Set " + psId.get() + ":" + buf, in.tag);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (LabelVote d : labelDelta) {
        buf.append(" ").append(d.format());
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    } else if (in.ready) {
        buf.append("\n\n" + START_REVIEW_MESSAGE);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = ChangeMessagesUtil.newMessage(psId, user, ctx.getWhen(), "Patch Set " + psId.get() + ":" + buf, in.tag);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
public List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) throws NoSuchProjectException, IOException {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(getRepo(project).getUpdate().setRefLogMessage("push"));
    }
    return updates;
}
#method_after
public List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) throws NoSuchProjectException, IOException {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(getRepo(project).getUpdate().setRefLogMessage("merged"));
    }
    return updates;
}
#end_block

#method_before
public List<ChangeControl> find(String id, CurrentUser user) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    int z = id.lastIndexOf('~');
    int y = id.lastIndexOf('~', z - 1);
    if (y < 0 && z > 0) {
        // Try project~numericChangeId
        Integer n = Ints.tryParse(id.substring(z + 1));
        if (n != null) {
            return fromProjectNumber(user, id.substring(0, z), n.intValue());
        }
    }
    if (y < 0 && z < 0) {
        // Try numeric changeId
        Integer n = Ints.tryParse(id, 10);
        if (n != null) {
            return find(new Change.Id(n), user);
        }
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    if (y > 0 && z > 0) {
        // Try change triplet (project~branch~Ihash...)
        Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id, y, z);
        if (triplet.isPresent()) {
            ChangeTriplet t = triplet.get();
            return asChangeControls(query.byBranchKey(t.branch(), t.id()), user);
        }
    }
    // Try isolated Ihash... format ("Change-Id: Ihash").
    return asChangeControls(query.byKeyPrefix(id), user);
}
#method_after
public List<ChangeControl> find(String id, CurrentUser user) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    int z = id.lastIndexOf('~');
    int y = id.lastIndexOf('~', z - 1);
    if (y < 0 && z > 0) {
        // Try project~numericChangeId
        Integer n = Ints.tryParse(id.substring(z + 1));
        if (n != null) {
            return fromProjectNumber(user, id.substring(0, z), n.intValue());
        }
    }
    if (y < 0 && z < 0) {
        // Try numeric changeId
        Integer n = Ints.tryParse(id);
        if (n != null) {
            return find(new Change.Id(n), user);
        }
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    if (y > 0 && z > 0) {
        // Try change triplet (project~branch~Ihash...)
        Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id, y, z);
        if (triplet.isPresent()) {
            ChangeTriplet t = triplet.get();
            return asChangeControls(query.byBranchKey(t.branch(), t.id()), user);
        }
    }
    // Try isolated Ihash... format ("Change-Id: Ihash").
    return asChangeControls(query.byKeyPrefix(id), user);
}
#end_block

#method_before
@Test
@GerritConfig(name = "plugins.allowRemoteAdmin", value = "true")
public void pluginManagement() throws Exception {
    // No plugins are loaded
    assertThat(list().get()).isEmpty();
    assertThat(list().all().get()).isEmpty();
    PluginApi api;
    // Install all the plugins
    InstallPluginInput input = new InstallPluginInput();
    input.raw = RawInputUtil.create(JS_PLUGIN_CONTENT);
    for (String plugin : PLUGINS) {
        api = gApi.plugins().install(plugin + ".js", input);
        assertThat(api).isNotNull();
        PluginInfo info = api.get();
        assertThat(info.id).isEqualTo(plugin);
        assertThat(info.disabled).isNull();
    }
    assertPlugins(list().get(), PLUGINS);
    // With pagination
    assertPlugins(list().start(1).limit(2).get(), PLUGINS.subList(1, 3));
    // With prefix
    assertPlugins(list().prefix("plugin-b").get(), ImmutableList.of("plugin-b"));
    // With substring
    assertPlugins(list().substring("lugin-").get(), PLUGINS);
    // With regex
    assertPlugins(list().regex(".*in-b").get(), ImmutableList.of("plugin-b"));
    assertPlugins(list().regex("plugin-.*").get(), PLUGINS);
    // Invalid match combinations
    assertBadRequest(list().regex(".*in-b").substring("a"));
    assertBadRequest(list().regex(".*in-b").prefix("a"));
    assertBadRequest(list().substring(".*in-b").prefix("a"));
    // Disable
    api = gApi.plugins().name("plugin-a");
    api.disable();
    api = gApi.plugins().name("plugin-a");
    assertThat(api.get().disabled).isTrue();
    assertPlugins(list().get(), PLUGINS.subList(1, PLUGINS.size()));
    assertPlugins(list().all().get(), PLUGINS);
    // Enable
    api.enable();
    api = gApi.plugins().name("plugin-a");
    assertThat(api.get().disabled).isNull();
    assertPlugins(list().get(), PLUGINS);
}
#method_after
@Test
@GerritConfig(name = "plugins.allowRemoteAdmin", value = "true")
public void pluginManagement() throws Exception {
    // No plugins are loaded
    assertThat(list().get()).isEmpty();
    assertThat(list().all().get()).isEmpty();
    PluginApi api;
    // Install all the plugins
    InstallPluginInput input = new InstallPluginInput();
    input.raw = RawInputUtil.create(JS_PLUGIN_CONTENT);
    for (String plugin : PLUGINS) {
        api = gApi.plugins().install(plugin + ".js", input);
        assertThat(api).isNotNull();
        PluginInfo info = api.get();
        assertThat(info.id).isEqualTo(plugin);
        assertThat(info.disabled).isNull();
    }
    assertPlugins(list().get(), PLUGINS);
    // With pagination
    assertPlugins(list().start(1).limit(2).get(), PLUGINS.subList(1, 3));
    // With prefix
    assertPlugins(list().prefix("plugin-b").get(), ImmutableList.of("plugin-b"));
    assertPlugins(list().prefix("PLUGIN-").get(), ImmutableList.of());
    // With substring
    assertPlugins(list().substring("lugin-").get(), PLUGINS);
    assertPlugins(list().substring("lugin-").start(1).limit(2).get(), PLUGINS.subList(1, 3));
    // With regex
    assertPlugins(list().regex(".*in-b").get(), ImmutableList.of("plugin-b"));
    assertPlugins(list().regex("plugin-.*").get(), PLUGINS);
    assertPlugins(list().regex("plugin-.*").start(1).limit(2).get(), PLUGINS.subList(1, 3));
    // Invalid match combinations
    assertBadRequest(list().regex(".*in-b").substring("a"));
    assertBadRequest(list().regex(".*in-b").prefix("a"));
    assertBadRequest(list().substring(".*in-b").prefix("a"));
    // Disable
    api = gApi.plugins().name("plugin-a");
    api.disable();
    api = gApi.plugins().name("plugin-a");
    assertThat(api.get().disabled).isTrue();
    assertPlugins(list().get(), PLUGINS.subList(1, PLUGINS.size()));
    assertPlugins(list().all().get(), PLUGINS);
    // Enable
    api.enable();
    api = gApi.plugins().name("plugin-a");
    assertThat(api.get().disabled).isNull();
    assertPlugins(list().get(), PLUGINS);
}
#end_block

#method_before
public SortedMap<String, PluginInfo> display(@Nullable PrintWriter stdout) throws BadRequestException {
    SortedMap<String, PluginInfo> output = new TreeMap<>();
    Stream<Plugin> s = Streams.stream(pluginLoader.getPlugins(all)).sorted(comparing(Plugin::getName));
    if (start > 0) {
        s = s.skip(start);
    }
    if (limit > 0) {
        s = s.limit(limit);
    }
    if (matchPrefix != null) {
        checkMatchOptions(matchSubstring == null && matchRegex == null);
        String prefix = matchPrefix.toLowerCase(Locale.US);
        s = s.filter(p -> p.getName().toLowerCase(Locale.US).startsWith(prefix));
    } else if (matchSubstring != null) {
        checkMatchOptions(matchPrefix == null && matchRegex == null);
        String substring = matchSubstring.toLowerCase(Locale.US);
        s = s.filter(p -> p.getName().toLowerCase(Locale.US).contains(substring));
    } else if (matchRegex != null) {
        checkMatchOptions(matchPrefix == null && matchSubstring == null);
        Pattern pattern = Pattern.compile(matchRegex);
        s = s.filter(p -> pattern.matcher(p.getName()).matches());
    }
    List<Plugin> plugins = s.collect(toList());
    if (!format.isJson()) {
        stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File");
        stdout.print("-------------------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = toPluginInfo(p);
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s %-8s %s\n", p.getName(), Strings.nullToEmpty(info.version), p.isDisabled() ? "DISABLED" : "ENABLED", p.getSrcFile().getFileName());
        }
    }
    if (stdout == null) {
        return output;
    } else if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
    return null;
}
#method_after
public SortedMap<String, PluginInfo> display(@Nullable PrintWriter stdout) throws BadRequestException {
    SortedMap<String, PluginInfo> output = new TreeMap<>();
    Stream<Plugin> s = Streams.stream(pluginLoader.getPlugins(all));
    if (matchPrefix != null) {
        checkMatchOptions(matchSubstring == null && matchRegex == null);
        s = s.filter(p -> p.getName().startsWith(matchPrefix));
    } else if (matchSubstring != null) {
        checkMatchOptions(matchPrefix == null && matchRegex == null);
        String substring = matchSubstring.toLowerCase(Locale.US);
        s = s.filter(p -> p.getName().toLowerCase(Locale.US).contains(substring));
    } else if (matchRegex != null) {
        checkMatchOptions(matchPrefix == null && matchSubstring == null);
        Pattern pattern = Pattern.compile(matchRegex);
        s = s.filter(p -> pattern.matcher(p.getName()).matches());
    }
    s = s.sorted(comparing(Plugin::getName));
    if (start > 0) {
        s = s.skip(start);
    }
    if (limit > 0) {
        s = s.limit(limit);
    }
    List<Plugin> plugins = s.collect(toList());
    if (!format.isJson()) {
        stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File");
        stdout.print("-------------------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = toPluginInfo(p);
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s %-8s %s\n", p.getName(), Strings.nullToEmpty(info.version), p.isDisabled() ? "DISABLED" : "ENABLED", p.getSrcFile().getFileName());
        }
    }
    if (stdout == null) {
        return output;
    } else if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
    return null;
}
#end_block

#method_before
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate() ? true : null;
        info.workInProgress = c.isWorkInProgress() ? true : null;
        info.hasReviewStarted = c.hasReviewStarted();
        info.revertOf = c.getRevertOf() != null ? c.getRevertOf().get() : null;
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#method_after
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate() ? true : null;
        info.workInProgress = c.isWorkInProgress() ? true : null;
        info.hasReviewStarted = c.hasReviewStarted();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(ctl, out);
        // TODO(hiesel) Replace with a call to ChangeData where the value was reconstructed from the
        // index.
        out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
@Test
public void reviewAndStartReview() throws Exception {
    PushOneCommit.Result r = createWorkInProgressChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(false);
    gApi.changes().id(r.getChangeId()).revision("current").review(in);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isNull();
}
#method_after
@Test
public void reviewAndStartReview() throws Exception {
    PushOneCommit.Result r = createWorkInProgressChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(false);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.ready).isTrue();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isNull();
}
#end_block

#method_before
@Test
public void reviewAndMoveToWorkInProgress() throws Exception {
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    gApi.changes().id(r.getChangeId()).revision("current").review(in);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isTrue();
}
#method_after
@Test
public void reviewAndMoveToWorkInProgress() throws Exception {
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.ready).isNull();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isTrue();
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(revertChange.revertOf).isEqualTo(r.getChange().getId().get());
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(revertChange.revertOf).isEqualTo(gApi.changes().id(r.getChangeId()).get()._number);
}
#end_block

#method_before
private void testRebase(Rebase rebase) throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Add an approval whose score should be copied on trivial rebase
    gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend());
    String changeId = r2.getChangeId();
    // Rebase the second change
    rebase.call(changeId);
    // Second change should have 2 patch sets and an approval
    ChangeInfo c2 = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.DETAILED_LABELS));
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer and description should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    String description = info.revisions.get(info.currentRevision).description;
    assertThat(description).isEqualTo("Rebase");
    // ...and the approval was copied
    LabelInfo cr = c2.labels.get("Code-Review");
    assertThat(cr).isNotNull();
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(1);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        // Ensure record was actually copied under ReviewDb
        List<PatchSetApproval> psas = db.patchSetApprovals().byPatchSet(new PatchSet.Id(new Change.Id(c2._number), 2)).toList();
        assertThat(psas).hasSize(1);
        assertThat(psas.get(0).getValue()).isEqualTo((short) 1);
    }
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#method_after
private void testRebase(Rebase rebase) throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Add an approval whose score should be copied on trivial rebase
    gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend());
    String changeId = r2.getChangeId();
    // Rebase the second change
    rebase.call(changeId);
    // Second change should have 2 patch sets and an approval
    ChangeInfo c2 = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.DETAILED_LABELS));
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer and description should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    String description = info.revisions.get(info.currentRevision).description;
    assertThat(description).isEqualTo("Rebase");
    // ...and the approval was copied
    LabelInfo cr = c2.labels.get("Code-Review");
    assertThat(cr).isNotNull();
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(1);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        // Ensure record was actually copied under ReviewDb
        List<PatchSetApproval> psas = unwrapDb(db).patchSetApprovals().byPatchSet(new PatchSet.Id(new Change.Id(c2._number), 2)).toList();
        assertThat(psas).hasSize(1);
        assertThat(psas.get(0).getValue()).isEqualTo((short) 1);
    }
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#end_block

#method_before
@Test
public void addReviewerThatIsInactiveEmailFallback() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    PushOneCommit.Result result = createChange();
    String username = "user@domain.com";
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    in.state = ReviewerState.CC;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(username);
    assertThat(r.error).isNull();
    // When adding by email, the reviewers field is also empty because we can't
    // render a ReviewerInfo object for a non-account.
    assertThat(r.reviewers).isNull();
}
#method_after
@Test
public void addReviewerThatIsInactiveEmailFallback() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    PushOneCommit.Result result = createChange();
    String username = "user@domain.com";
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    in.state = ReviewerState.CC;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(username);
    assertThat(r.error).isNull();
    // When adding by email, the reviewers field is also empty because we can't
    // render a ReviewerInfo object for a non-account.
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    assume().that(notesMigration.changePrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    assume().that(notesMigration.changePrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#end_block

#method_before
@Test
public void check() throws Exception {
    // TODO(dborowitz): Re-enable when ConsistencyChecker supports NoteDb.
    assume().that(notesMigration.enabled()).isFalse();
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.CHECK)).problems).isEmpty();
}
#method_after
@Test
public void check() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.CHECK)).problems).isEmpty();
}
#end_block

#method_before
public List<ChangeNotes> create(ReviewDb db, Collection<Change.Id> changeIds) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id changeId : changeIds) {
            try {
                notes.add(createChecked(changeId));
            } catch (NoSuchChangeException e) {
            // Ignore missing changes to match Access#get(Iterable) behavior.
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        notes.add(createFromChangeOnlyWhenNoteDbDisabled(c));
    }
    return notes;
}
#method_after
public List<ChangeNotes> create(ReviewDb db, Collection<Change.Id> changeIds) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.readChanges()) {
        for (Change.Id changeId : changeIds) {
            try {
                notes.add(createChecked(changeId));
            } catch (NoSuchChangeException e) {
            // Ignore missing changes to match Access#get(Iterable) behavior.
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        notes.add(createFromChangeOnlyWhenNoteDbDisabled(c));
    }
    return notes;
}
#end_block

#method_before
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            try {
                ChangeNotes cn = create(db, project, cid);
                if (cn.getChange() != null && predicate.test(cn)) {
                    notes.add(cn);
                }
            } catch (NoSuchChangeException e) {
                // a dangling patch set ref or something.
                continue;
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#method_after
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.readChanges()) {
        for (Change.Id cid : changeIds) {
            try {
                ChangeNotes cn = create(db, project, cid);
                if (cn.getChange() != null && predicate.test(cn)) {
                    notes.add(cn);
                }
            } catch (NoSuchChangeException e) {
                // a dangling patch set ref or something.
                continue;
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#end_block

#method_before
public void setRevertOf(int revertOf) {
    int ownId = getChange().getId().get();
    checkArgument(ownId != revertOf, "A change cannot revert itself.");
    this.revertOf = revertOf;
}
#method_after
public void setRevertOf(int revertOf) {
    int ownId = getChange().getId().get();
    checkArgument(ownId != revertOf, "A change cannot revert itself");
    this.revertOf = revertOf;
    rootOnly = true;
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), ReviewerByEmailSet.fromTable(Tables.transpose(reviewersByEmail)), pendingReviewers, pendingReviewersByEmail, allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress, hasReviewStarted, revertOf != null ? new Change.Id(revertOf) : null);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), ReviewerByEmailSet.fromTable(Tables.transpose(reviewersByEmail)), pendingReviewers, pendingReviewersByEmail, allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress, hasReviewStarted, revertOf);
}
#end_block

#method_before
private Integer parseRevertOf(ChangeNotesCommit commit) throws ConfigInvalidException {
    String footer = parseOneFooter(commit, FOOTER_REVERT_OF);
    if (footer == null) {
        return null;
    }
    return Ints.tryParse(footer);
}
#method_after
private Change.Id parseRevertOf(ChangeNotesCommit commit) throws ConfigInvalidException {
    String footer = parseOneFooter(commit, FOOTER_REVERT_OF);
    if (footer == null) {
        return null;
    }
    Integer revertOf = Ints.tryParse(footer);
    if (revertOf == null) {
        throw invalidFooter(FOOTER_REVERT_OF, footer);
    }
    return new Change.Id(revertOf);
}
#end_block

#method_before
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    change.setWorkInProgress(c.isWorkInProgress() == null ? false : c.isWorkInProgress());
    change.setReviewStarted(c.hasReviewStarted() == null ? false : c.hasReviewStarted());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#method_after
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    change.setWorkInProgress(c.isWorkInProgress() == null ? false : c.isWorkInProgress());
    change.setReviewStarted(c.hasReviewStarted() == null ? false : c.hasReviewStarted());
    change.setRevertOf(c.revertOf());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#end_block

#method_before
public void setRevertOf(Change.Id revertOf) {
    this.revertOf = revertOf;
}
#method_after
public void setRevertOf(Id revertOf) {
    this.revertOf = revertOf;
}
#end_block

#method_before
@Test
public void setRevertOfPersistsValue() throws Exception {
    Change c = newChange();
    Change changeToRevert = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setRevertOf(changeToRevert.getChangeId());
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getRevertOf()).isEqualTo(changeToRevert.getId());
}
#method_after
@Test
public void setRevertOfPersistsValue() throws Exception {
    Change changeToRevert = newChange();
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeId(c.getKey().get());
    update.setRevertOf(changeToRevert.getId().get());
    update.commit();
    assertThat(newNotes(c).getRevertOf()).isEqualTo(changeToRevert.getId());
}
#end_block

#method_before
@Test
public void setRevertOfToCurrentChangeFails() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    exception.expect(IllegalArgumentException.class);
    exception.expectMessage("A change cannot revert itself.");
    update.setRevertOf(c.getId().get());
}
#method_after
@Test
public void setRevertOfToCurrentChangeFails() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    exception.expect(IllegalArgumentException.class);
    exception.expectMessage("A change cannot revert itself");
    update.setRevertOf(c.getId().get());
}
#end_block

#method_before
protected PushOneCommit.Result forceDraftChange() throws Exception {
    Result pushTo = pushTo("refs/for/master");
    markChangeAsDraft(pushTo.getChange().change().getId());
    setDraftStatusOfPatchSetsOfChange(pushTo.getChange().change().getId(), true);
    return pushTo;
}
#method_after
protected PushOneCommit.Result forceDraftChange() throws Exception {
    PushOneCommit.Result pushTo = pushTo("refs/for/master");
    markChangeAsDraft(pushTo.getChange().change().getId());
    setDraftStatusOfPatchSetsOfChange(pushTo.getChange().change().getId(), true);
    return pushTo;
}
#end_block

#method_before
@Test
public void reviewAndStartReview() throws Exception {
    PushOneCommit.Result r = createWorkInProgressChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(false);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.reviewStarted).isTrue();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isNull();
}
#method_after
@Test
public void reviewAndStartReview() throws Exception {
    PushOneCommit.Result r = createWorkInProgressChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(false);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.ready).isTrue();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isNull();
}
#end_block

#method_before
@Test
public void reviewAndMoveToWorkInProgress() throws Exception {
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.reviewStarted).isNull();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isTrue();
}
#method_after
@Test
public void reviewAndMoveToWorkInProgress() throws Exception {
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.ready).isNull();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isTrue();
}
#end_block

#method_before
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    NotifyHandling reviewerNotify = input.notify;
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (!revision.getChange().getOwner().equals(revision.getUser().getAccountId())) {
                output.error = ERROR_ONLY_OWNER_CAN_MODIFY_WORK_IN_PROGRESS;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (input.ready) {
                output.reviewStarted = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, reviewerNotify, accountsToNotify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    NotifyHandling reviewerNotify = input.notify;
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (!revision.getChange().getOwner().equals(revision.getUser().getAccountId())) {
                output.error = ERROR_ONLY_OWNER_CAN_MODIFY_WORK_IN_PROGRESS;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (input.ready) {
                output.ready = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, reviewerNotify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
public ReviewerInfo format(ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd, Iterable<PatchSetApproval> approvals) throws OrmException, PermissionBackendException {
    LabelTypes labelTypes = cd.getLabelTypes();
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    out.approvals = new TreeMap<>(labelTypes.nameComparator());
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : cd.changeControl().getLabelRanges()) {
            if (!pr.isEmpty()) {
                LabelType at = labelTypes.byLabel(ca.getLabelId());
                if (at != null) {
                    out.approvals.put(at.getName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    PatchSet ps = cd.currentPatchSet();
    if (ps != null) {
        for (SubmitRecord rec : new SubmitRuleEvaluator(accountByEmailCache, accountCache, cd).setFastEvalLabels(true).setAllowDraft(true).evaluate()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                LabelType type = labelTypes.byLabel(name);
                if (!out.approvals.containsKey(name) && type != null && perm.test(new LabelPermission(type))) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#method_after
public ReviewerInfo format(ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd, Iterable<PatchSetApproval> approvals) throws OrmException, PermissionBackendException {
    LabelTypes labelTypes = cd.getLabelTypes();
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    out.approvals = new TreeMap<>(labelTypes.nameComparator());
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : cd.changeControl().getLabelRanges()) {
            if (!pr.isEmpty()) {
                LabelType at = labelTypes.byLabel(ca.getLabelId());
                if (at != null) {
                    out.approvals.put(at.getName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    PatchSet ps = cd.currentPatchSet();
    if (ps != null) {
        for (SubmitRecord rec : new SubmitRuleEvaluator(accountCache, accounts, cd).setFastEvalLabels(true).setAllowDraft(true).evaluate()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                LabelType type = labelTypes.byLabel(name);
                if (!out.approvals.containsKey(name) && type != null && perm.test(new LabelPermission(type))) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (opts.rule() != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNT_BY_EMAIL_CACHE, accountByEmailCache);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (opts.rule() != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#end_block

#method_before
public List<SubmitRecord> submitRecords(SubmitRuleOptions options) throws OrmException {
    List<SubmitRecord> records = submitRecords.get(options);
    if (records == null) {
        if (!lazyLoad) {
            return Collections.emptyList();
        }
        records = new SubmitRuleEvaluator(accountByEmailCache, accountCache, this).setOptions(options).evaluate();
        submitRecords.put(options, records);
    }
    return records;
}
#method_after
public List<SubmitRecord> submitRecords(SubmitRuleOptions options) throws OrmException {
    List<SubmitRecord> records = submitRecords.get(options);
    if (records == null) {
        if (!lazyLoad) {
            return Collections.emptyList();
        }
        records = new SubmitRuleEvaluator(accountCache, accounts, this).setOptions(options).evaluate();
        submitRecords.put(options, records);
    }
    return records;
}
#end_block

#method_before
public SubmitTypeRecord submitTypeRecord() throws OrmException {
    if (submitTypeRecord == null) {
        submitTypeRecord = new SubmitRuleEvaluator(accountByEmailCache, accountCache, this).getSubmitType();
    }
    return submitTypeRecord;
}
#method_after
public SubmitTypeRecord submitTypeRecord() throws OrmException {
    if (submitTypeRecord == null) {
        submitTypeRecord = new SubmitRuleEvaluator(accountCache, accounts, this).getSubmitType();
    }
    return submitTypeRecord;
}
#end_block

#method_before
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    ChangeControl cc = d.changeControl().forUser(user);
    LabelTypes labelTypes = cc.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, trackingFooters.extract(d.commitFooters()));
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, new SubmitRuleEvaluator(accountByEmailCache, accountCache, d).setAllowClosed(true).setAllowDraft(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        if (current != null && cc.isPatchVisible(current, d.db())) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    c.plugins = queryProcessor.create(d);
    return c;
}
#method_after
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    ChangeControl cc = d.changeControl().forUser(user);
    LabelTypes labelTypes = cc.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, trackingFooters.extract(d.commitFooters()));
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, new SubmitRuleEvaluator(accountCache, accounts, d).setAllowClosed(true).setAllowDraft(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        if (current != null && cc.isPatchVisible(current, d.db())) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    c.plugins = queryProcessor.create(d);
    return c;
}
#end_block

#method_before
private SubmitType getSubmitType(ChangeData cd, PatchSet patchSet) throws OrmException {
    SubmitTypeRecord rec = new SubmitRuleEvaluator(accountByEmailCache, accountCache, cd).setPatchSet(patchSet).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    return rec.type;
}
#method_after
private SubmitType getSubmitType(ChangeData cd, PatchSet patchSet) throws OrmException {
    SubmitTypeRecord rec = new SubmitRuleEvaluator(accountCache, accounts, cd).setPatchSet(patchSet).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    return rec.type;
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountByEmailCache, accountCache, changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
private SubmitType submitType(ChangeData cd, PatchSet ps, boolean visible) throws OrmException {
    // would be submitted together with the visible ones.
    if (!visible) {
        return cd.changeControl().getProject().getSubmitType();
    }
    SubmitTypeRecord str = ps == cd.currentPatchSet() ? cd.submitTypeRecord() : new SubmitRuleEvaluator(accountByEmailCache, accountCache, cd).setPatchSet(ps).getSubmitType();
    if (!str.isOk()) {
        logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
    }
    return str.type;
}
#method_after
private SubmitType submitType(ChangeData cd, PatchSet ps, boolean visible) throws OrmException {
    // would be submitted together with the visible ones.
    if (!visible) {
        return cd.changeControl().getProject().getSubmitType();
    }
    SubmitTypeRecord str = ps == cd.currentPatchSet() ? cd.submitTypeRecord() : new SubmitRuleEvaluator(accountCache, accounts, cd).setPatchSet(ps).getSubmitType();
    if (!str.isOk()) {
        logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
    }
    return str.type;
}
#end_block

#method_before
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountByEmailCache, accountCache, changeDataFactory.create(db.get(), rsrc.getControl()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, changeDataFactory.create(db.get(), rsrc.getControl()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#end_block

#method_before
private static void handleMimePart(Entity part, StringBuilder textBuilder, StringBuilder htmlBuilder) throws IOException {
    if (isPlainOrHtml(part.getMimeType()) && !isAttachment(part.getDispositionType())) {
        TextBody tb = (TextBody) part.getBody();
        String result = CharStreams.toString(new InputStreamReader(tb.getInputStream(), tb.getMimeCharset()));
        if (part.getMimeType().equals("text/plain")) {
            textBuilder.append(result);
        } else if (part.getMimeType().equals("text/html")) {
            htmlBuilder.append(result);
        }
    } else if (isMixedOrAlternative(part.getMimeType())) {
        Multipart multipart = (Multipart) part.getBody();
        for (Entity e : multipart.getBodyParts()) {
            handleMimePart(e, textBuilder, htmlBuilder);
        }
    }
}
#method_after
private static void handleMimePart(Entity part, StringBuilder textBuilder, StringBuilder htmlBuilder) throws IOException {
    if (isPlainOrHtml(part.getMimeType()) && !isAttachment(part.getDispositionType())) {
        TextBody tb = (TextBody) part.getBody();
        String result = CharStreams.toString(new InputStreamReader(tb.getInputStream(), tb.getMimeCharset()));
        if (part.getMimeType().equals("text/plain")) {
            textBuilder.append(result);
        } else if (part.getMimeType().equals("text/html")) {
            htmlBuilder.append(result);
        }
    } else if (isMultipart(part.getMimeType())) {
        Multipart multipart = (Multipart) part.getBody();
        for (Entity e : multipart.getBodyParts()) {
            handleMimePart(e, textBuilder, htmlBuilder);
        }
    }
}
#end_block

#method_before
private Supplier<AccountAttribute> accountAttributeSupplier(final AccountInfo account) {
    return Suppliers.memoize(new Supplier<AccountAttribute>() {

        @Override
        public AccountAttribute get() {
            return eventFactory.asAccountAttribute(new Account.Id(account._accountId));
        }
    });
}
#method_after
private Supplier<AccountAttribute> accountAttributeSupplier(final AccountInfo account) {
    return Suppliers.memoize(new Supplier<AccountAttribute>() {

        @Override
        public AccountAttribute get() {
            return account != null ? eventFactory.asAccountAttribute(new Account.Id(account._accountId)) : null;
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    change = ctx.getChange();
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add Assignee; NoteDb is disabled");
    }
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    ChangeUpdate update = ctx.getUpdate(ctx.getChange().currentPatchSetId());
    ChangeNotes notes = update.getNotes();
    Account.Id oldAssigneeId = notes.getAssignee();
    if (input.assignee == null) {
        if (oldAssigneeId != null) {
            throw new AuthException("Cannot remove Assignee");
        }
        return false;
    }
    oldAssignee = null;
    if (oldAssigneeId != null) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId);
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId != null && oldAssigneeId.equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", change.getChangeId(), newAssigneeUser.getUserName()));
    }
    update.setAssignee(newAssigneeUser.getAccountId());
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    Optional<Account.Id> oldAssigneeId = Optional.fromNullable(change.getAssignee());
    if (input.assignee == null) {
        if (oldAssigneeId.isPresent()) {
            throw new BadRequestException("Cannot set Assignee to empty");
        }
        return false;
    }
    oldAssignee = null;
    if (oldAssigneeId.isPresent()) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId.get());
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId.isPresent() && oldAssigneeId.get().equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", change.getChangeId(), newAssigneeUser.getUserName()));
    }
    try {
        for (AssigneeValidationListener validator : validationListeners) {
            validator.validateAssignee(change, newAssigneeUser.getAccount());
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    // notedb
    update.setAssignee(newAssigneeUser.getAccountId());
    // reviewdb
    change.setAssignee(newAssigneeUser.getAccountId());
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getName(anonymousCowardName));
        msg.append(" to:");
        msg.append(newAssignee.getName(anonymousCowardName));
    }
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(msg.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getName(anonymousCowardName));
        msg.append(" to: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    }
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(msg.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (change != null) {
        assigneeChanged.fire(change, ctx.getAccount(), oldAssignee, ctx.getWhen());
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    assigneeChanged.fire(change, ctx.getAccount(), oldAssignee, ctx.getWhen());
}
#end_block

#method_before
public static GerritServer initAndStart(Description desc, Config baseConfig) throws Exception {
    if (!desc.memory()) {
        assume().withMessage("FUSED mode not yet supported for on-disk sites").that(NoteDbMode.get()).isNotEqualTo(NoteDbMode.FUSED);
    }
    Path site = TempFileUtil.createTempDirectory().toPath();
    baseConfig = new Config(baseConfig);
    baseConfig.setString("gerrit", null, "tempSiteDir", site.toString());
    try {
        if (!desc.memory()) {
            init(desc, baseConfig, site);
        }
        return start(desc, baseConfig, site, null);
    } catch (Exception e) {
        TempFileUtil.recursivelyDelete(site.toFile());
        throw e;
    }
}
#method_after
public static GerritServer initAndStart(Description desc, Config baseConfig) throws Exception {
    Path site = TempFileUtil.createTempDirectory().toPath();
    baseConfig = new Config(baseConfig);
    baseConfig.setString("gerrit", null, "tempSiteDir", site.toString());
    try {
        if (!desc.memory()) {
            init(desc, baseConfig, site);
        }
        return start(desc, baseConfig, site, null);
    } catch (Exception e) {
        TempFileUtil.recursivelyDelete(site.toFile());
        throw e;
    }
}
#end_block

#method_before
public static GerritServer initAndStart(Description desc, Config baseConfig) throws Exception {
    if (!desc.memory()) {
        assume().withMessage("FUSED mode not yet supported for on-disk sites").that(NoteDbMode.get()).isNotEqualTo(NoteDbMode.FUSED);
    }
    Path site = TempFileUtil.createTempDirectory().toPath();
    baseConfig = new Config(baseConfig);
    baseConfig.setString("gerrit", null, "tempSiteDir", site.toString());
    try {
        if (!desc.memory()) {
            init(desc, baseConfig, site);
        }
        return start(desc, baseConfig, site, null);
    } catch (Exception e) {
        TempFileUtil.recursivelyDelete(site.toFile());
        throw e;
    }
}
#method_after
public static GerritServer initAndStart(Description desc, Config baseConfig) throws Exception {
    Path site = TempFileUtil.createTempDirectory().toPath();
    baseConfig = new Config(baseConfig);
    baseConfig.setString("gerrit", null, "tempSiteDir", site.toString());
    try {
        if (!desc.memory()) {
            init(desc, baseConfig, site);
        }
        return start(desc, baseConfig, site, null);
    } catch (Exception e) {
        TempFileUtil.recursivelyDelete(site.toFile());
        throw e;
    }
}
#end_block

#method_before
public MutableNotesMigration setFrom(NotesMigrationState state) {
    snapshot.set(state.snapshot());
    return this;
}
#method_after
public MutableNotesMigration setFrom(NotesMigration other) {
    snapshot.set(other.snapshot.get());
    return this;
}
#end_block

#method_before
public static GerritServer initAndStart(Description desc, Config baseConfig) throws Exception {
    if (!desc.memory()) {
        assume().withMessage("FUSED mode not yet supported for on-disk sites").that(NoteDbMode.get()).isNotEqualTo(NoteDbMode.FUSED);
    }
    Path site = Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir"));
    if (!desc.memory()) {
        init(desc, baseConfig, site);
    }
    return start(desc, baseConfig, site, null);
}
#method_after
public static GerritServer initAndStart(Description desc, Config baseConfig) throws Exception {
    Path site = Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir"));
    if (!desc.memory()) {
        init(desc, baseConfig, site);
    }
    return start(desc, baseConfig, site, null);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    TestAccount user = accounts.create("user", "user@example.com", "User");
    userSession = new RestSession(server, user);
}
#method_after
@Before
public void setUp() throws Exception {
    TestAccount user = accounts.create("user", "user@example.com", "User");
    TestAccount admin = accounts.admin();
    userSession = new RestSession(server, user);
    adminSession = new RestSession(server, admin);
}
#end_block

#method_before
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException {
    ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get());
    if (ctl.getProject().getState().equals(ProjectState.HIDDEN)) {
        throw new NoSuchProjectException(name);
    }
    Repository repo = repoManager.openRepository(name);
    return new FilteredRepository(ctl, repo, visibleRefFilterFactory.create(ctl.getProjectState(), repo));
}
#method_after
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException {
    ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get());
    if (ctl.getProject().getState().equals(ProjectState.HIDDEN)) {
        throw new NoSuchProjectException(name);
    }
    return new FilteredRepository(ctl, repoManager.openRepository(name), visibleRefFilterFactory);
}
#end_block

#method_before
public ProjectInfo format(Project p) {
    ProjectInfo info = new ProjectInfo();
    info.name = p.getName();
    Project.NameKey parentName = p.getParent(allProjects);
    info.parent = parentName != null ? parentName.get() : null;
    info.description = Strings.emptyToNull(p.getDescription());
    info.state = p.getState();
    info.id = Url.encode(info.name);
    List<WebLinkInfo> links = webLinks.getProjectLinks(p.getName());
    info.webLinks = links.isEmpty() ? null : links;
    return info;
}
#method_after
public ProjectInfo format(ProjectControl ctl) {
    ProjectInfo info = format(ctl.getProject());
    info.labels = new HashMap<>();
    for (LabelType t : ctl.getLabelTypes().getLabelTypes()) {
        LabelTypeInfo labelInfo = new LabelTypeInfo();
        labelInfo.values = t.getValues().stream().collect(Collectors.toMap(LabelValue::formatValue, LabelValue::getText));
        labelInfo.defaultValue = t.getDefaultValue();
        info.labels.put(t.getName(), labelInfo);
    }
    return info;
}
#end_block

#method_before
@Test
public void getProject() throws Exception {
    String name = project.get();
    ProjectInfo p = gApi.projects().name(name).get();
    assertThat(p.name).isEqualTo(name);
    assertThat(p.labels.get("Code-Review").values.get("0")).isEqualTo("No score");
}
#method_after
@Test
public void getProject() throws Exception {
    String name = project.get();
    ProjectInfo p = gApi.projects().name(name).get();
    assertThat(p.name).isEqualTo(name);
    assertThat(p.labels).hasSize(1);
    LabelTypeInfo l = p.labels.get("Code-Review");
    ImmutableMap<String, String> want = ImmutableMap.of(" 0", "No score", "-1", "I would prefer this is not merged as is", "-2", "This shall not be merged", "+1", "Looks good to me, but someone else must approve", "+2", "Looks good to me, approved");
    assertThat(l.values).isEqualTo(want);
    assertThat(l.defaultValue).isEqualTo(0);
}
#end_block

#method_before
private Path resolvePath(HttpServletRequest req) {
    return sitePaths.resolve(req.getServletPath() + req.getPathInfo());
}
#method_after
private Path resolvePath(HttpServletRequest req) {
    return sitePaths.resolve(CharMatcher.is('/').trimLeadingFrom(req.getServletPath() + req.getPathInfo()));
}
#end_block

#method_before
private void render(Writer out, final Map<String, EmailHeader> callerHeaders, String textBody, @Nullable String htmlBody) throws IOException, EmailException {
    final Map<String, EmailHeader> hdrs = new LinkedHashMap<>(callerHeaders);
    setMissingHeader(hdrs, "MIME-Version", "1.0");
    setMissingHeader(hdrs, "Content-Transfer-Encoding", "8bit");
    setMissingHeader(hdrs, "Content-Disposition", "inline");
    setMissingHeader(hdrs, "User-Agent", "Gerrit/" + Version.getVersion());
    if (importance != null) {
        setMissingHeader(hdrs, "Importance", importance);
    }
    if (expiryDays > 0) {
        Date expiry = new Date(TimeUtil.nowMs() + expiryDays * 24 * 60 * 60 * 1000L);
        setMissingHeader(hdrs, "Expiry-Date", new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z").format(expiry));
    }
    String encodedBody;
    if (htmlBody == null) {
        setMissingHeader(hdrs, "Content-Type", "text/plain; charset=UTF-8");
        encodedBody = textBody;
    } else {
        String boundary = generateMultipartBoundary(textBody, htmlBody);
        setMissingHeader(hdrs, "Content-Type", "multipart/alternative; boundary=\"" + boundary + "\"; charset=UTF-8");
        encodedBody = buildMultipartBody(boundary, textBody, htmlBody);
    }
    try (Writer w = new BufferedWriter(out)) {
        for (Map.Entry<String, EmailHeader> h : hdrs.entrySet()) {
            if (!h.getValue().isEmpty()) {
                w.write(h.getKey());
                w.write(": ");
                h.getValue().write(w);
                w.write("\r\n");
            }
        }
        w.write("\r\n");
        w.write(encodedBody);
        w.flush();
    }
}
#method_after
private void render(Writer out, Map<String, EmailHeader> callerHeaders, String textBody, @Nullable String htmlBody) throws IOException, EmailException {
    final Map<String, EmailHeader> hdrs = new LinkedHashMap<>(callerHeaders);
    setMissingHeader(hdrs, "MIME-Version", "1.0");
    setMissingHeader(hdrs, "Content-Transfer-Encoding", "8bit");
    setMissingHeader(hdrs, "Content-Disposition", "inline");
    setMissingHeader(hdrs, "User-Agent", "Gerrit/" + Version.getVersion());
    if (importance != null) {
        setMissingHeader(hdrs, "Importance", importance);
    }
    if (expiryDays > 0) {
        Date expiry = new Date(TimeUtil.nowMs() + expiryDays * 24 * 60 * 60 * 1000L);
        setMissingHeader(hdrs, "Expiry-Date", new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z").format(expiry));
    }
    String encodedBody;
    if (htmlBody == null) {
        setMissingHeader(hdrs, "Content-Type", "text/plain; charset=UTF-8");
        encodedBody = textBody;
    } else {
        String boundary = generateMultipartBoundary(textBody, htmlBody);
        setMissingHeader(hdrs, "Content-Type", "multipart/alternative; boundary=\"" + boundary + "\"; charset=UTF-8");
        encodedBody = buildMultipartBody(boundary, textBody, htmlBody);
    }
    try (Writer w = new BufferedWriter(out)) {
        for (Map.Entry<String, EmailHeader> h : hdrs.entrySet()) {
            if (!h.getValue().isEmpty()) {
                w.write(h.getKey());
                w.write(": ");
                h.getValue().write(w);
                w.write("\r\n");
            }
        }
        w.write("\r\n");
        w.write(encodedBody);
        w.flush();
    }
}
#end_block

#method_before
private static void setMissingHeader(final Map<String, EmailHeader> hdrs, String name, String value) {
    if (!hdrs.containsKey(name) || hdrs.get(name).isEmpty()) {
        hdrs.put(name, new EmailHeader.String(value));
    }
}
#method_after
private static void setMissingHeader(Map<String, EmailHeader> hdrs, String name, String value) {
    if (!hdrs.containsKey(name) || hdrs.get(name).isEmpty()) {
        hdrs.put(name, new EmailHeader.String(value));
    }
}
#end_block

#method_before
private void render(Writer out, final Map<String, EmailHeader> callerHeaders, String textBody, @Nullable String htmlBody) throws IOException, EmailException {
    final Map<String, EmailHeader> hdrs = new LinkedHashMap<>(callerHeaders);
    setMissingHeader(hdrs, "MIME-Version", "1.0");
    setMissingHeader(hdrs, "Content-Transfer-Encoding", "8bit");
    setMissingHeader(hdrs, "Content-Disposition", "inline");
    setMissingHeader(hdrs, "User-Agent", "Gerrit/" + Version.getVersion());
    if (importance != null) {
        setMissingHeader(hdrs, "Importance", importance);
    }
    if (expiryDays > 0) {
        Date expiry = new Date(TimeUtil.nowMs() + expiryDays * 24 * 60 * 60 * 1000L);
        setMissingHeader(hdrs, "Expiry-Date", new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z").format(expiry));
    }
    String encodedBody;
    if (htmlBody == null) {
        setMissingHeader(hdrs, "Content-Type", "text/plain; charset=UTF-8");
        encodedBody = textBody;
    } else {
        String boundary = generateMultipartBoundary(textBody, htmlBody);
        setMissingHeader(hdrs, "Content-Type", "multipart/alternative; boundary=\"" + boundary + "\"; charset=UTF-8");
        encodedBody = buildMultipartBody(boundary, textBody, htmlBody);
    }
    try (Writer w = new BufferedWriter(out)) {
        for (Map.Entry<String, EmailHeader> h : hdrs.entrySet()) {
            if (!h.getValue().isEmpty()) {
                w.write(h.getKey());
                w.write(": ");
                h.getValue().write(w);
                w.write("\r\n");
            }
        }
        w.write("\r\n");
        w.write(encodedBody);
        w.flush();
    }
}
#method_after
private void render(Writer out, Map<String, EmailHeader> callerHeaders, String textBody, @Nullable String htmlBody) throws IOException, EmailException {
    final Map<String, EmailHeader> hdrs = new LinkedHashMap<>(callerHeaders);
    setMissingHeader(hdrs, "MIME-Version", "1.0");
    setMissingHeader(hdrs, "Content-Transfer-Encoding", "8bit");
    setMissingHeader(hdrs, "Content-Disposition", "inline");
    setMissingHeader(hdrs, "User-Agent", "Gerrit/" + Version.getVersion());
    if (importance != null) {
        setMissingHeader(hdrs, "Importance", importance);
    }
    if (expiryDays > 0) {
        Date expiry = new Date(TimeUtil.nowMs() + expiryDays * 24 * 60 * 60 * 1000L);
        setMissingHeader(hdrs, "Expiry-Date", new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z").format(expiry));
    }
    String encodedBody;
    if (htmlBody == null) {
        setMissingHeader(hdrs, "Content-Type", "text/plain; charset=UTF-8");
        encodedBody = textBody;
    } else {
        String boundary = generateMultipartBoundary(textBody, htmlBody);
        setMissingHeader(hdrs, "Content-Type", "multipart/alternative; boundary=\"" + boundary + "\"; charset=UTF-8");
        encodedBody = buildMultipartBody(boundary, textBody, htmlBody);
    }
    try (Writer w = new BufferedWriter(out)) {
        for (Map.Entry<String, EmailHeader> h : hdrs.entrySet()) {
            if (!h.getValue().isEmpty()) {
                w.write(h.getKey());
                w.write(": ");
                h.getValue().write(w);
                w.write("\r\n");
            }
        }
        w.write("\r\n");
        w.write(encodedBody);
        w.flush();
    }
}
#end_block

#method_before
protected String buildMultipartBody(String boundary, String textPart, String htmlPart) throws IOException {
    return // Output the text part:
    "--" + boundary + "\r\n" + "Content-Type: text/plain; charset=UTF-8\r\n" + "Content-Transfer-Encoding: quoted-printable\r\n" + "\r\n" + quotedPrintableEncode(textPart) + "\r\n" + // Output the HTML part:
    "--" + boundary + "\r\n" + "Content-Type: text/html; charset=UTF-8\r\n" + "Content-Transfer-Encoding: quoted-printable\r\n" + "\r\n" + quotedPrintableEncode(htmlPart) + "\r\n" + // Output the closing boundary.
    "--" + boundary + "--\r\n";
}
#method_after
protected String buildMultipartBody(String boundary, String textPart, String htmlPart) throws IOException {
    String encodedTextPart = quotedPrintableEncode(textPart);
    String encodedHtmlPart = quotedPrintableEncode(htmlPart);
    // Only declare quoted-printable encoding if there are characters that need to be encoded.
    String textTransferEncoding = textPart.equals(encodedTextPart) ? "7bit" : "quoted-printable";
    String htmlTransferEncoding = htmlPart.equals(encodedHtmlPart) ? "7bit" : "quoted-printable";
    return // Output the text part:
    "--" + boundary + "\r\n" + "Content-Type: text/plain; charset=UTF-8\r\n" + "Content-Transfer-Encoding: " + textTransferEncoding + "\r\n" + "\r\n" + encodedTextPart + "\r\n" + // Output the HTML part:
    "--" + boundary + "\r\n" + "Content-Type: text/html; charset=UTF-8\r\n" + "Content-Transfer-Encoding: " + htmlTransferEncoding + "\r\n" + "\r\n" + encodedHtmlPart + "\r\n" + // Output the closing boundary.
    "--" + boundary + "--\r\n";
}
#end_block

#method_before
protected String quotedPrintableEncode(String input) throws IOException {
    ByteArrayOutputStream s = new ByteArrayOutputStream();
    QuotedPrintableOutputStream qp = new QuotedPrintableOutputStream(s, false);
    qp.write(input.getBytes(UTF_8));
    qp.close();
    return s.toString();
}
#method_after
protected String quotedPrintableEncode(String input) throws IOException {
    ByteArrayOutputStream s = new ByteArrayOutputStream();
    try (QuotedPrintableOutputStream qp = new QuotedPrintableOutputStream(s, false)) {
        qp.write(input.getBytes(UTF_8));
    }
    return s.toString();
}
#end_block

#method_before
private static void setMissingHeader(final Map<String, EmailHeader> hdrs, String name, String value) {
    if (!hdrs.containsKey(name) || hdrs.get(name).isEmpty()) {
        hdrs.put(name, new EmailHeader.String(value));
    }
}
#method_after
private static void setMissingHeader(Map<String, EmailHeader> hdrs, String name, String value) {
    if (!hdrs.containsKey(name) || hdrs.get(name).isEmpty()) {
        hdrs.put(name, new EmailHeader.String(value));
    }
}
#end_block

#method_before
@Override
public OAuthUserInfo getUserInfo(OAuthToken token) throws IOException {
    OAuthRequest request = new OAuthRequest(Verb.GET, PROTECTED_RESOURCE_URL);
    Token t = new Token(token.getToken(), token.getSecret(), token.getRaw());
    service.signRequest(t, request);
    Response response = request.send();
    if (response.getCode() != HttpServletResponse.SC_OK) {
        throw new IOException(String.format("Status %s (%s) for request %s", response.getCode(), response.getBody(), request.getUrl()));
    }
    JsonElement userJson = OutputFormat.JSON.newGson().fromJson(response.getBody(), JsonElement.class);
    if (log.isDebugEnabled()) {
        log.debug("User info response: {}", response.getBody());
    }
    if (userJson.isJsonObject()) {
        JsonObject jsonObject = userJson.getAsJsonObject();
        JsonElement id = jsonObject.get("id");
        if (id == null || id.isJsonNull()) {
            throw new IOException(String.format("Response doesn't contain id field"));
        }
        JsonElement email = jsonObject.get("email");
        JsonElement name = jsonObject.get("name");
        String login = null;
        if (domains.length > 0) {
            boolean domainMatched = false;
            JsonObject jwtToken = retrieveJWTToken(token);
            String hdClaim = retrieveHostedDomain(jwtToken);
            for (String domain : domains) {
                if (domain.equalsIgnoreCase(hdClaim)) {
                    domainMatched = true;
                    break;
                }
            }
            if (!domainMatched) {
                // TODO(davido): improve error reporting in OAuth extension point
                log.error("Error: hosted domain validation failed: {}", Strings.nullToEmpty(hdClaim));
                return null;
            }
        }
        if (useEmailAsUsername && !email.isJsonNull()) {
            login = email.getAsString().split("@")[0];
        }
        return new OAuthUserInfo(GOOGLE_PROVIDER_PREFIX + id.getAsString(), /*externalId*/
        login, /*username*/
        email == null || email.isJsonNull() ? null : email.getAsString(), /*email*/
        name == null || name.isJsonNull() ? null : name.getAsString(), /*displayName*/
        fixLegacyUserId ? id.getAsString() : null);
    }
    throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson));
}
#method_after
@Override
public OAuthUserInfo getUserInfo(OAuthToken token) throws IOException {
    OAuthRequest request = new OAuthRequest(Verb.GET, PROTECTED_RESOURCE_URL);
    Token t = new Token(token.getToken(), token.getSecret(), token.getRaw());
    service.signRequest(t, request);
    Response response = request.send();
    if (response.getCode() != HttpServletResponse.SC_OK) {
        throw new IOException(String.format("Status %s (%s) for request %s", response.getCode(), response.getBody(), request.getUrl()));
    }
    JsonElement userJson = OutputFormat.JSON.newGson().fromJson(response.getBody(), JsonElement.class);
    if (log.isDebugEnabled()) {
        log.debug("User info response: {}", response.getBody());
    }
    if (userJson.isJsonObject()) {
        JsonObject jsonObject = userJson.getAsJsonObject();
        JsonElement id = jsonObject.get("id");
        if (id == null || id.isJsonNull()) {
            throw new IOException(String.format("Response doesn't contain id field"));
        }
        JsonElement email = jsonObject.get("email");
        JsonElement name = jsonObject.get("name");
        String login = null;
        if (domains.size() > 0) {
            boolean domainMatched = false;
            JsonObject jwtToken = retrieveJWTToken(token);
            String hdClaim = retrieveHostedDomain(jwtToken);
            for (String domain : domains) {
                if (domain.equalsIgnoreCase(hdClaim)) {
                    domainMatched = true;
                    break;
                }
            }
            if (!domainMatched) {
                // TODO(davido): improve error reporting in OAuth extension point
                log.error("Error: hosted domain validation failed: {}", Strings.nullToEmpty(hdClaim));
                return null;
            }
        }
        if (useEmailAsUsername && !email.isJsonNull()) {
            login = email.getAsString().split("@")[0];
        }
        return new OAuthUserInfo(GOOGLE_PROVIDER_PREFIX + id.getAsString(), /*externalId*/
        login, /*username*/
        email == null || email.isJsonNull() ? null : email.getAsString(), /*email*/
        name == null || name.isJsonNull() ? null : name.getAsString(), /*displayName*/
        fixLegacyUserId ? id.getAsString() : null);
    }
    throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson));
}
#end_block

#method_before
@Override
public String getAuthorizationUrl() {
    String url = service.getAuthorizationUrl(null);
    try {
        if (domains.length == 1) {
            url += "&hd=" + URLEncoder.encode(domains[0], StandardCharsets.UTF_8.name());
        } else if (domains.length > 1) {
            url += "&hd=*";
        }
    } catch (UnsupportedEncodingException e) {
        throw new IllegalArgumentException(e);
    }
    if (log.isDebugEnabled()) {
        log.debug("OAuth2: authorization URL={}", url);
    }
    return url;
}
#method_after
@Override
public String getAuthorizationUrl() {
    String url = service.getAuthorizationUrl(null);
    try {
        if (domains.size() == 1) {
            url += "&hd=" + URLEncoder.encode(domains.get(0), StandardCharsets.UTF_8.name());
        } else if (domains.size() > 1) {
            url += "&hd=*";
        }
    } catch (UnsupportedEncodingException e) {
        throw new IllegalArgumentException(e);
    }
    if (log.isDebugEnabled()) {
        log.debug("OAuth2: authorization URL={}", url);
    }
    return url;
}
#end_block

#method_before
public Optional<Comment> getPublished(ReviewDb db, ChangeNotes notes, Comment.Key key) throws OrmException {
    if (!migration.readChanges()) {
        return Optional.ofNullable(db.patchComments().get(PatchLineComment.Key.from(notes.getChangeId(), key))).map(plc -> plc.asComment(serverId));
    }
    return publishedByChange(db, notes).stream().filter(c -> key.equals(c.key)).findFirst();
}
#method_after
public Optional<Comment> getPublished(ReviewDb db, ChangeNotes notes, Comment.Key key) throws OrmException {
    if (!migration.readChanges()) {
        return getReviewDb(db, notes, key);
    }
    return publishedByChange(db, notes).stream().filter(c -> key.equals(c.key)).findFirst();
}
#end_block

#method_before
public Optional<Comment> getDraft(ReviewDb db, ChangeNotes notes, IdentifiedUser user, Comment.Key key) throws OrmException {
    if (!migration.readChanges()) {
        return Optional.ofNullable(db.patchComments().get(PatchLineComment.Key.from(notes.getChangeId(), key))).map(plc -> plc.asComment(serverId));
    }
    return draftByChangeAuthor(db, notes, user.getAccountId()).stream().filter(c -> key.equals(c.key)).findFirst();
}
#method_after
public Optional<Comment> getDraft(ReviewDb db, ChangeNotes notes, IdentifiedUser user, Comment.Key key) throws OrmException {
    if (!migration.readChanges()) {
        Optional<Comment> c = getReviewDb(db, notes, key);
        if (c.isPresent() && !c.get().author.getId().equals(user.getAccountId())) {
            throw new OrmException(String.format("Expected draft %s to belong to account %s, but it belongs to %s", key, user.getAccountId(), c.get().author.getId()));
        }
        return c;
    }
    return draftByChangeAuthor(db, notes, user.getAccountId()).stream().filter(c -> key.equals(c.key)).findFirst();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    Optional<Comment> maybeComment = commentsUtil.getDraft(ctx.getDb(), ctx.getNotes(), ctx.getIdentifiedUser(), key);
    if (!maybeComment.isPresent()) {
        // because the input might be missing required fields. Just give up.
        throw new ResourceNotFoundException("comment not found: " + key);
    }
    Comment origComment = maybeComment.get();
    comment = new Comment(origComment);
    PatchSet.Id psId = new PatchSet.Id(ctx.getChange().getId(), origComment.key.patchSetId);
    ChangeUpdate update = ctx.getUpdate(psId);
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    if (in.path != null && !in.path.equals(origComment.key.filename)) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        commentsUtil.deleteComments(ctx.getDb(), update, Collections.singleton(origComment));
        comment.key.filename = in.path;
    }
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    commentsUtil.putComments(ctx.getDb(), update, Status.DRAFT, Collections.singleton(update(comment, in, ctx.getWhen())));
    ctx.dontBumpLastUpdatedOn();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    Optional<Comment> maybeComment = commentsUtil.getDraft(ctx.getDb(), ctx.getNotes(), ctx.getIdentifiedUser(), key);
    if (!maybeComment.isPresent()) {
        // because the input might be missing required fields. Just give up.
        throw new ResourceNotFoundException("comment not found: " + key);
    }
    Comment origComment = maybeComment.get();
    comment = new Comment(origComment);
    // Copy constructor preserved old real author; replace with current real
    // user.
    ctx.getUser().updateRealAccountId(comment::setRealAuthor);
    PatchSet.Id psId = new PatchSet.Id(ctx.getChange().getId(), origComment.key.patchSetId);
    ChangeUpdate update = ctx.getUpdate(psId);
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    if (in.path != null && !in.path.equals(origComment.key.filename)) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        commentsUtil.deleteComments(ctx.getDb(), update, Collections.singleton(origComment));
        comment.key.filename = in.path;
    }
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    commentsUtil.putComments(ctx.getDb(), update, Status.DRAFT, Collections.singleton(update(comment, in, ctx.getWhen())));
    ctx.dontBumpLastUpdatedOn();
    return true;
}
#end_block

#method_before
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change change, PatchSet patch, CherryPickInput input, RefControl refControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    return cherryPick(batchUpdateFactory, change, patch.getId(), change.getDest(), change.getTopic(), change.getProject(), ObjectId.fromString(patch.getRevision().get()), input, refControl);
}
#method_after
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change change, PatchSet patch, CherryPickInput input, RefControl refControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException, ConfigInvalidException {
    return cherryPick(batchUpdateFactory, change, patch.getId(), change.getProject(), ObjectId.fromString(patch.getRevision().get()), input, refControl);
}
#end_block

#method_before
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change sourceChange, @Nullable PatchSet.Id sourcePatchId, @Nullable Branch.NameKey sourceBranch, @Nullable String sourceChangeTopic, Project.NameKey project, ObjectId sourceCommit, CherryPickInput input, RefControl destRefControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(reader)) {
        String destRefName = destRefControl.getRefName();
        Ref destRef = git.getRefDatabase().exactRef(destRefName);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destRefName));
        }
        RevCommit baseCommit = getBaseCommit(destRef, project.get(), revWalk, input.base);
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (input.parent <= 0 || input.parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", input.parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), baseCommit, commitToCherryPick.getAuthorIdent(), committerIdent, input.message);
        String commitMessage = ChangeIdUtil.insertId(input.message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = destRefControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(oi, git.getConfig(), baseCommit, commitToCherryPick, committerIdent, commitMessage, revWalk, input.parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = destRefControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit, input);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(sourceChangeTopic)) {
                        newTopic = sourceChangeTopic + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, destRefControl, newTopic, sourceChange, sourceCommit, input);
                    if (sourceChange != null && sourcePatchId != null) {
                        bu.addOp(sourceChange.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, RefNames.shortName(destRefName), cherryPickCommit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#method_after
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, @Nullable Change sourceChange, @Nullable PatchSet.Id sourcePatchId, Project.NameKey project, ObjectId sourceCommit, CherryPickInput input, RefControl destRefControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException, ConfigInvalidException {
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(reader)) {
        String destRefName = destRefControl.getRefName();
        Ref destRef = git.getRefDatabase().exactRef(destRefName);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destRefName));
        }
        RevCommit baseCommit = getBaseCommit(destRef, project.get(), revWalk, input.base);
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (input.parent <= 0 || input.parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", input.parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), baseCommit, commitToCherryPick.getAuthorIdent(), committerIdent, input.message);
        String commitMessage = ChangeIdUtil.insertId(input.message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = destRefControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(oi, git.getConfig(), baseCommit, commitToCherryPick, committerIdent, commitMessage, revWalk, input.parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = destRefControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit, input);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (sourceChange != null && !Strings.isNullOrEmpty(sourceChange.getTopic())) {
                        newTopic = sourceChange.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, destRefName, newTopic, sourceChange, sourceCommit, input);
                    if (sourceChange != null && sourcePatchId != null) {
                        bu.addOp(sourceChange.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, RefNames.shortName(destRefName), cherryPickCommit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#end_block

#method_before
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSet current = psUtil.current(dbProvider.get(), destCtl.getNotes());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setDraft(current.isDraft()).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#method_after
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException, ConfigInvalidException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSet current = psUtil.current(dbProvider.get(), destCtl.getNotes());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setDraft(current.isDraft()).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#end_block

#method_before
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, RefControl destRefControl, String topic, Change sourceChange, ObjectId sourceCommit, CherryPickInput input) throws OrmException, IOException, BadRequestException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, destRefControl.getRefName());
    Branch.NameKey sourceBranch = null;
    if (sourceChange != null) {
        sourceBranch = sourceChange.getDest();
    }
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit)).setTopic(topic).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    if (input.keepReviewers && sourceChange != null) {
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(dbProvider.get(), destRefControl.getProjectControl().controlFor(dbProvider.get(), sourceChange).getNotes());
        Set<Account.Id> reviewers = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.add(sourceChange.getOwner());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ins.setReviewers(reviewers).setExtraCC(ccs);
    }
    bu.insertChange(ins);
    return changeId;
}
#method_after
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, @Nullable Change sourceChange, ObjectId sourceCommit, CherryPickInput input) throws OrmException, IOException, BadRequestException, ConfigInvalidException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName);
    Branch.NameKey sourceBranch = sourceChange == null ? null : sourceChange.getDest();
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit)).setTopic(topic).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    if (input.keepReviewers && sourceChange != null) {
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(dbProvider.get(), changeNotesFactory.createChecked(dbProvider.get(), sourceChange));
        Set<Account.Id> reviewers = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.add(sourceChange.getOwner());
        reviewers.remove(user.get().getAccountId());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.get().getAccountId());
        ins.setReviewers(reviewers).setExtraCC(ccs);
    }
    bu.insertChange(ins);
    return changeId;
}
#end_block

#method_before
@Test
public void cherryPickNotify() throws Exception {
    createBranch(new NameKey(project, "branch-1"));
    createBranch(new NameKey(project, "branch-2"));
    createBranch(new NameKey(project, "branch-3"));
    // Creates a change for 'admin'.
    PushOneCommit.Result result = createChange();
    String changeId = project.get() + "~master~" + result.getChangeId();
    // 'user' cherry-picks the change to a new branch, the source change's author/committer('admin')
    // will be added as a reviewer of the newly created change.
    setApiUser(user);
    CherryPickInput input = new CherryPickInput();
    input.message = "it goes to a new branch";
    // Enable the notification. 'admin' as a reviewer should be notified.
    input.destination = "branch-1";
    input.notify = NotifyHandling.ALL;
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertNotifyCc(admin);
    // Disable the notification. 'admin' as a reviewer should not be notified any more.
    input.destination = "branch-2";
    input.notify = NotifyHandling.NONE;
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertThat(sender.getMessages()).hasSize(0);
    // Disable the notification. The user provided in the 'notifyDetails' should still be notified.
    TestAccount userToNotify = accountCreator.user2();
    input.destination = "branch-3";
    input.notify = NotifyHandling.NONE;
    input.notifyDetails = ImmutableMap.of(RecipientType.TO, new NotifyInfo(ImmutableList.of(userToNotify.email)));
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertNotifyTo(userToNotify);
}
#method_after
@Test
public void cherryPickNotify() throws Exception {
    createBranch(new Branch.NameKey(project, "branch-1"));
    createBranch(new Branch.NameKey(project, "branch-2"));
    createBranch(new Branch.NameKey(project, "branch-3"));
    // Creates a change for 'admin'.
    PushOneCommit.Result result = createChange();
    String changeId = project.get() + "~master~" + result.getChangeId();
    // 'user' cherry-picks the change to a new branch, the source change's author/committer('admin')
    // will be added as a reviewer of the newly created change.
    setApiUser(user);
    CherryPickInput input = new CherryPickInput();
    input.message = "it goes to a new branch";
    // Enable the notification. 'admin' as a reviewer should be notified.
    input.destination = "branch-1";
    input.notify = NotifyHandling.ALL;
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertNotifyCc(admin);
    // Disable the notification. 'admin' as a reviewer should not be notified any more.
    input.destination = "branch-2";
    input.notify = NotifyHandling.NONE;
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertThat(sender.getMessages()).hasSize(0);
    // Disable the notification. The user provided in the 'notifyDetails' should still be notified.
    TestAccount userToNotify = accountCreator.user2();
    input.destination = "branch-3";
    input.notify = NotifyHandling.NONE;
    input.notifyDetails = ImmutableMap.of(RecipientType.TO, new NotifyInfo(ImmutableList.of(userToNotify.email)));
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertNotifyTo(userToNotify);
}
#end_block

#method_before
@Test
public void cherryPickKeepReviewers() throws Exception {
    createBranch(new NameKey(project, "stable"));
    // admin creates the change.
    PushOneCommit.Result r = createChange();
    // Which is approved by admin2, who also adds user as a CC.
    setApiUser(accountCreator.admin2());
    ReviewInput in = ReviewInput.approve();
    in.reviewer(accountCreator.admin2().email);
    in.reviewer(user.email, ReviewerState.CC, true);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // Finally, cherrypicked by user2.
    setApiUser(accountCreator.user2());
    CherryPickInput cin = new CherryPickInput();
    cin.message = "this need to go to stable";
    cin.destination = "stable";
    cin.keepReviewers = true;
    Map<ReviewerState, Collection<AccountInfo>> result = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(cin).get().reviewers;
    // Therefore, admin and admin2 should both be reviewers (as the old
    // owner and old reviewer), and user should still be on CC.
    assertThat(result).containsKey(ReviewerState.REVIEWER);
    List<Integer> reviewers = result.get(ReviewerState.REVIEWER).stream().map(a -> a._accountId).collect(toList());
    if (notesMigration.readChanges()) {
        assertThat(result).containsKey(ReviewerState.CC);
        List<Integer> ccs = result.get(ReviewerState.CC).stream().map(a -> a._accountId).collect(toList());
        assertThat(ccs).containsExactly(user.id.get());
        assertThat(reviewers).containsExactly(admin.id.get(), accountCreator.admin2().id.get());
    } else {
        assertThat(reviewers).containsExactly(user.id.get(), admin.id.get(), accountCreator.admin2().id.get());
    }
}
#method_after
@Test
public void cherryPickKeepReviewers() throws Exception {
    createBranch(new Branch.NameKey(project, "stable"));
    // Change is created by 'admin'.
    PushOneCommit.Result r = createChange();
    // Change is approved by 'admin2'. Change is CC'd to 'user'.
    setApiUser(accountCreator.admin2());
    ReviewInput in = ReviewInput.approve();
    in.reviewer(user.email, ReviewerState.CC, true);
    gApi.changes().id(r.getChangeId()).current().review(in);
    // Change is cherrypicked by 'user2'.
    setApiUser(accountCreator.user2());
    CherryPickInput cin = new CherryPickInput();
    cin.message = "this need to go to stable";
    cin.destination = "stable";
    cin.keepReviewers = true;
    Map<ReviewerState, Collection<AccountInfo>> result = gApi.changes().id(r.getChangeId()).current().cherryPick(cin).get().reviewers;
    // 'admin' should be a reviewer as the old owner.
    // 'admin2' should be a reviewer as the old reviewer.
    // 'user' should be on CC.
    assertThat(result).containsKey(ReviewerState.REVIEWER);
    List<Integer> reviewers = result.get(ReviewerState.REVIEWER).stream().map(a -> a._accountId).collect(toList());
    if (notesMigration.readChanges()) {
        assertThat(result).containsKey(ReviewerState.CC);
        List<Integer> ccs = result.get(ReviewerState.CC).stream().map(a -> a._accountId).collect(toList());
        assertThat(ccs).containsExactly(user.id.get());
        assertThat(reviewers).containsExactly(admin.id.get(), accountCreator.admin2().id.get());
    } else {
        assertThat(reviewers).containsExactly(user.id.get(), admin.id.get(), accountCreator.admin2().id.get());
    }
}
#end_block

#method_before
@Test
public void cherryPickToMergedChangeRevision() throws Exception {
    createBranch(new NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    merge(dstChange);
    PushOneCommit.Result result = createChange(testRepo, "foo", SUBJECT, "b.txt", "c", "t");
    result.assertOkStatus();
    merge(result);
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    ChangeInfo changeInfo = gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
    assertCherryPickResult(changeInfo, input, srcChange.getChangeId());
}
#method_after
@Test
public void cherryPickToMergedChangeRevision() throws Exception {
    createBranch(new Branch.NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    merge(dstChange);
    PushOneCommit.Result result = createChange(testRepo, "foo", SUBJECT, "b.txt", "c", "t");
    result.assertOkStatus();
    merge(result);
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    ChangeInfo changeInfo = gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
    assertCherryPickResult(changeInfo, input, srcChange.getChangeId());
}
#end_block

#method_before
@Test
public void cherryPickToOpenChangeRevision() throws Exception {
    createBranch(new NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    ChangeInfo changeInfo = gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
    assertCherryPickResult(changeInfo, input, srcChange.getChangeId());
}
#method_after
@Test
public void cherryPickToOpenChangeRevision() throws Exception {
    createBranch(new Branch.NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    ChangeInfo changeInfo = gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
    assertCherryPickResult(changeInfo, input, srcChange.getChangeId());
}
#end_block

#method_before
@Test
public void cherryPickToNonVisibleChangeFails() throws Exception {
    createBranch(new NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    gApi.changes().id(dstChange.getChangeId()).setPrivate(true, null);
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    setApiUser(user);
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage(String.format("Commit %s does not exist on branch refs/heads/foo", input.base));
    gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
}
#method_after
@Test
public void cherryPickToNonVisibleChangeFails() throws Exception {
    createBranch(new Branch.NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    gApi.changes().id(dstChange.getChangeId()).setPrivate(true, null);
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    setApiUser(user);
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage(String.format("Commit %s does not exist on branch refs/heads/foo", input.base));
    gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
}
#end_block

#method_before
@Test
public void pushWorkInProgressChangeWhenNotOwner() throws Exception {
    TestRepository<?> userRepo = cloneProject(project, user);
    PushOneCommit.Result r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%wip");
    r.assertOkStatus();
    assertThat(r.getChange().change().getOwner()).isEqualTo(user.id);
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    GitUtil.fetch(testRepo, r.getPatchSet().getRefName() + ":ps");
    testRepo.reset("ps");
    r = amendChange(r.getChangeId(), "refs/for/master%wip", admin, testRepo);
    r.assertErrorStatus(ReplaceOp.ONLY_OWNER_CAN_MODIFY_WIP);
    r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%ready");
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    GitUtil.fetch(testRepo, r.getPatchSet().getRefName() + ":ps");
    testRepo.reset("ps");
    r = amendChange(r.getChangeId(), "refs/for/master%ready", admin, testRepo);
    r.assertErrorStatus(ReplaceOp.ONLY_OWNER_CAN_MODIFY_WIP);
}
#method_after
@Test
public void pushWorkInProgressChangeWhenNotOwner() throws Exception {
    TestRepository<?> userRepo = cloneProject(project, user);
    PushOneCommit.Result r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%wip");
    r.assertOkStatus();
    assertThat(r.getChange().change().getOwner()).isEqualTo(user.id);
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    // Other user trying to move from WIP to ready should fail.
    GitUtil.fetch(testRepo, r.getPatchSet().getRefName() + ":ps");
    testRepo.reset("ps");
    r = amendChange(r.getChangeId(), "refs/for/master%ready", admin, testRepo);
    r.assertErrorStatus(ReceiveCommits.ONLY_OWNER_CAN_MODIFY_WIP);
    // Other user trying to move from WIP to WIP should succeed.
    r = amendChange(r.getChangeId(), "refs/for/master%wip", admin, testRepo);
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    // Push as change owner to move change from WIP to ready.
    r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%ready");
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    // Other user trying to move from ready to WIP should fail.
    GitUtil.fetch(testRepo, r.getPatchSet().getRefName() + ":ps");
    testRepo.reset("ps");
    r = amendChange(r.getChangeId(), "refs/for/master%wip", admin, testRepo);
    r.assertErrorStatus(ReceiveCommits.ONLY_OWNER_CAN_MODIFY_WIP);
    // Other user trying to move from ready to ready should succeed.
    r = amendChange(r.getChangeId(), "refs/for/master%ready", admin, testRepo);
    r.assertOkStatus();
}
#end_block

#method_before
@Override
public synchronized void handleEmails(boolean async) throws MailTransferException, IOException {
    IMAPClient imap;
    if (mailSettings.encryption != Encryption.NONE) {
        imap = new IMAPSClient(mailSettings.encryption.name(), true);
    } else {
        imap = new IMAPClient();
    }
    if (mailSettings.port > 0) {
        imap.setDefaultPort(mailSettings.port);
    }
    // Set a 30s timeout for each operation
    imap.setDefaultTimeout(30 * 1000);
    imap.connect(mailSettings.host);
    try {
        if (!imap.login(mailSettings.username, mailSettings.password)) {
            throw new MailTransferException("Could not login to IMAP server");
        }
        try {
            if (!imap.select(INBOX_FOLDER)) {
                throw new MailTransferException(("Could not select IMAP folder " + INBOX_FOLDER));
            }
            // should fetch.
            if (!imap.fetch("1:*", "(INTERNALDATE)")) {
                // false indicates that there are no messages to fetch
                log.info("Fetched 0 messages via IMAP");
                return;
            }
            // Format of reply is one line per email and one line to indicate
            // that the fetch was successful.
            // Example:
            // * 1 FETCH (INTERNALDATE "Mon, 24 Oct 2016 16:53:22 +0200 (CEST)")
            // * 2 FETCH (INTERNALDATE "Mon, 24 Oct 2016 16:53:22 +0200 (CEST)")
            // AAAC OK FETCH completed.
            int numMessages = imap.getReplyStrings().length - 1;
            log.info("Fetched " + numMessages + " messages via IMAP");
            // Fetch the full version of all emails
            List<MailMessage> mailMessages = new ArrayList<>(numMessages);
            for (int i = 1; i <= numMessages; i++) {
                if (imap.fetch(i + ":" + i, "(BODY.PEEK[])")) {
                    // Obtain full reply
                    String[] rawMessage = imap.getReplyStrings();
                    if (rawMessage.length < 2) {
                        continue;
                    }
                    // First and last line are IMAP status codes. We have already
                    // checked, that the fetch returned true (OK), so we safely ignore
                    // those two lines.
                    StringBuilder b = new StringBuilder(2 * (rawMessage.length - 2));
                    for (int j = 1; j < rawMessage.length - 1; j++) {
                        if (j > 1) {
                            b.append("\n");
                        }
                        b.append(rawMessage[j]);
                    }
                    try {
                        MailMessage mailMessage = RawMailParser.parse(b.toString());
                        if (pendingDeletion.contains(mailMessage.id())) {
                            // Mark message as deleted
                            if (imap.store(i + ":" + i, "+FLAGS", "(\\Deleted)")) {
                                pendingDeletion.remove(mailMessage.id());
                            } else {
                                log.error("Could not mark mail message as deleted: " + mailMessage.id());
                            }
                        } else {
                            mailMessages.add(mailMessage);
                        }
                    } catch (MailParsingException e) {
                        log.error("Exception while parsing email after IMAP fetch", e);
                    }
                } else {
                    log.error("IMAP fetch failed. Will retry in next fetch cycle.");
                }
            }
            // Permanently delete emails marked for deletion
            if (!imap.expunge()) {
                log.error("Could not expunge IMAP emails");
            }
            dispatchMailProcessor(mailMessages, async);
        } finally {
            imap.logout();
        }
    } finally {
        imap.disconnect();
    }
}
#method_after
@Override
public synchronized void handleEmails(boolean async) throws MailTransferException, IOException {
    IMAPClient imap;
    if (mailSettings.encryption != Encryption.NONE) {
        imap = new IMAPSClient(mailSettings.encryption.name(), true);
    } else {
        imap = new IMAPClient();
    }
    if (mailSettings.port > 0) {
        imap.setDefaultPort(mailSettings.port);
    }
    // Set a 30s timeout for each operation
    imap.setDefaultTimeout(30 * 1000);
    imap.connect(mailSettings.host);
    try {
        if (!imap.login(mailSettings.username, mailSettings.password)) {
            throw new MailTransferException("Could not login to IMAP server");
        }
        try {
            if (!imap.select(INBOX_FOLDER)) {
                throw new MailTransferException("Could not select IMAP folder " + INBOX_FOLDER);
            }
            // should fetch.
            if (!imap.fetch("1:*", "(INTERNALDATE)")) {
                // false indicates that there are no messages to fetch
                log.info("Fetched 0 messages via IMAP");
                return;
            }
            // Format of reply is one line per email and one line to indicate
            // that the fetch was successful.
            // Example:
            // * 1 FETCH (INTERNALDATE "Mon, 24 Oct 2016 16:53:22 +0200 (CEST)")
            // * 2 FETCH (INTERNALDATE "Mon, 24 Oct 2016 16:53:22 +0200 (CEST)")
            // AAAC OK FETCH completed.
            int numMessages = imap.getReplyStrings().length - 1;
            log.info("Fetched " + numMessages + " messages via IMAP");
            // Fetch the full version of all emails
            List<MailMessage> mailMessages = new ArrayList<>(numMessages);
            for (int i = 1; i <= numMessages; i++) {
                if (imap.fetch(i + ":" + i, "(BODY.PEEK[])")) {
                    // Obtain full reply
                    String[] rawMessage = imap.getReplyStrings();
                    if (rawMessage.length < 2) {
                        continue;
                    }
                    // First and last line are IMAP status codes. We have already
                    // checked, that the fetch returned true (OK), so we safely ignore
                    // those two lines.
                    StringBuilder b = new StringBuilder(2 * (rawMessage.length - 2));
                    for (int j = 1; j < rawMessage.length - 1; j++) {
                        if (j > 1) {
                            b.append("\n");
                        }
                        b.append(rawMessage[j]);
                    }
                    try {
                        MailMessage mailMessage = RawMailParser.parse(b.toString());
                        if (pendingDeletion.contains(mailMessage.id())) {
                            // Mark message as deleted
                            if (imap.store(i + ":" + i, "+FLAGS", "(\\Deleted)")) {
                                pendingDeletion.remove(mailMessage.id());
                            } else {
                                log.error("Could not mark mail message as deleted: " + mailMessage.id());
                            }
                        } else {
                            mailMessages.add(mailMessage);
                        }
                    } catch (MailParsingException e) {
                        log.error("Exception while parsing email after IMAP fetch", e);
                    }
                } else {
                    log.error("IMAP fetch failed. Will retry in next fetch cycle.");
                }
            }
            // Permanently delete emails marked for deletion
            if (!imap.expunge()) {
                log.error("Could not expunge IMAP emails");
            }
            dispatchMailProcessor(mailMessages, async);
        } finally {
            imap.logout();
        }
    } finally {
        imap.disconnect();
    }
}
#end_block

#method_before
private int reindexAccounts() throws Exception {
    monitor.beginTask("Reindex accounts", ProgressMonitor.UNKNOWN);
    List<String> reindexArgs = ImmutableList.of("--site-path", getSitePath().toString(), "--index", AccountSchemaDefinitions.NAME);
    System.out.println("Migration complete, reindexing accounts with:");
    System.out.println("  reindex " + reindexArgs.stream().collect(joining(" ")));
    Reindex reindexPgm = new Reindex();
    int exitCode = reindexPgm.main(reindexArgs.stream().toArray(String[]::new));
    monitor.endTask();
    return exitCode;
}
#method_after
private int reindexAccounts() throws Exception {
    monitor.beginTask("Reindex accounts", ProgressMonitor.UNKNOWN);
    String[] reindexArgs = { "--site-path", getSitePath().toString(), "--index", AccountSchemaDefinitions.NAME };
    System.out.println("Migration complete, reindexing accounts with:");
    System.out.println("  reindex " + String.join(" ", reindexArgs));
    Reindex reindexPgm = new Reindex();
    int exitCode = reindexPgm.main(reindexArgs);
    monitor.endTask();
    return exitCode;
}
#end_block

#method_before
@Override
public List<TagInfo> apply(ProjectResource resource) throws IOException, ResourceNotFoundException, BadRequestException {
    List<TagInfo> tags = new ArrayList<>();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(resource.getNameKey());
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        ProjectControl pctl = resource.getControl();
        Map<String, Ref> all = visibleTags(pctl, repo, repo.getRefDatabase().getRefs(Constants.R_TAGS));
        for (Ref ref : all.values()) {
            tags.add(createTagInfo(perm.ref(ref.getName()), ref, rw, pctl, links));
        }
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    return new RefFilter<TagInfo>(Constants.R_TAGS).start(start).limit(limit).subString(matchSubstring).regex(matchRegex).filter(tags);
}
#method_after
@Override
public List<TagInfo> apply(ProjectResource resource) throws IOException, ResourceNotFoundException, BadRequestException {
    List<TagInfo> tags = new ArrayList<>();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(resource.getNameKey());
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        ProjectControl pctl = resource.getControl();
        Map<String, Ref> all = visibleTags(pctl, repo, repo.getRefDatabase().getRefs(Constants.R_TAGS));
        for (Ref ref : all.values()) {
            tags.add(createTagInfo(perm.ref(ref.getName()), ref, rw, pctl.getProject().getNameKey(), links));
        }
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    return new RefFilter<TagInfo>(Constants.R_TAGS).start(start).limit(limit).subString(matchSubstring).regex(matchRegex).filter(tags);
}
#end_block

#method_before
public TagInfo get(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        String tagName = id.get();
        if (!tagName.startsWith(Constants.R_TAGS)) {
            tagName = Constants.R_TAGS + tagName;
        }
        Ref ref = repo.getRefDatabase().exactRef(tagName);
        ProjectControl pctl = resource.getControl();
        if (ref != null && !visibleTags(pctl, repo, ImmutableMap.of(ref.getName(), ref)).isEmpty()) {
            return createTagInfo(permissionBackend.user(pctl.getUser()).project(resource.getNameKey()).ref(ref.getName()), ref, rw, pctl, links);
        }
    }
    throw new ResourceNotFoundException(id);
}
#method_after
public TagInfo get(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        String tagName = id.get();
        if (!tagName.startsWith(Constants.R_TAGS)) {
            tagName = Constants.R_TAGS + tagName;
        }
        Ref ref = repo.getRefDatabase().exactRef(tagName);
        ProjectControl pctl = resource.getControl();
        if (ref != null && !visibleTags(pctl, repo, ImmutableMap.of(ref.getName(), ref)).isEmpty()) {
            return createTagInfo(permissionBackend.user(pctl.getUser()).project(resource.getNameKey()).ref(ref.getName()), ref, rw, pctl.getProject().getNameKey(), links);
        }
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
public static TagInfo createTagInfo(PermissionBackend.ForRef perm, Ref ref, RevWalk rw, ProjectControl pctl, WebLinks links) throws MissingObjectException, IOException {
    RevObject object = rw.parseAny(ref.getObjectId());
    boolean canDelete = perm.testOrFalse(RefPermission.DELETE);
    List<WebLinkInfo> webLinks = links.getTagLinks(pctl.getProject().getName(), ref.getName());
    if (object instanceof RevTag) {
        // Annotated or signed tag
        RevTag tag = (RevTag) object;
        PersonIdent tagger = tag.getTaggerIdent();
        return new TagInfo(ref.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), tagger != null ? CommonConverters.toGitPerson(tag.getTaggerIdent()) : null, canDelete, webLinks.isEmpty() ? null : webLinks);
    }
    // Lightweight tag
    return new TagInfo(ref.getName(), ref.getObjectId().getName(), canDelete, webLinks.isEmpty() ? null : webLinks);
}
#method_after
public static TagInfo createTagInfo(PermissionBackend.ForRef perm, Ref ref, RevWalk rw, Project.NameKey projectName, WebLinks links) throws MissingObjectException, IOException {
    RevObject object = rw.parseAny(ref.getObjectId());
    boolean canDelete = perm.testOrFalse(RefPermission.DELETE);
    List<WebLinkInfo> webLinks = links.getTagLinks(projectName.get(), ref.getName());
    if (object instanceof RevTag) {
        // Annotated or signed tag
        RevTag tag = (RevTag) object;
        PersonIdent tagger = tag.getTaggerIdent();
        return new TagInfo(ref.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), tagger != null ? CommonConverters.toGitPerson(tag.getTaggerIdent()) : null, canDelete, webLinks.isEmpty() ? null : webLinks);
    }
    // Lightweight tag
    return new TagInfo(ref.getName(), ref.getObjectId().getName(), canDelete, webLinks.isEmpty() ? null : webLinks);
}
#end_block

#method_before
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    PermissionBackend.ForRef perm = permissionBackend.user(identifiedUser).project(resource.getNameKey()).ref(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else {
            perm.check(RefPermission.CREATE);
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(perm, result, w, resource.getControl(), links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#method_after
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    PermissionBackend.ForRef perm = permissionBackend.user(identifiedUser).project(resource.getNameKey()).ref(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else {
            perm.check(RefPermission.CREATE);
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(perm, result, w, resource.getNameKey(), links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else if (!refControl.canPerform(Permission.CREATE)) {
            throw new AuthException("Cannot create tag \"" + ref + "\"");
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            ProjectControl pctl = resource.getControl();
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(result, w, refControl, pctl, links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#method_after
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else if (!refControl.canPerform(Permission.CREATE)) {
            throw new AuthException("Cannot create tag \"" + ref + "\"");
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                ProjectControl pctl = resource.getControl();
                return ListTags.createTagInfo(result, w, refControl, pctl, links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#end_block

#method_before
private void grantApprove(Project.NameKey project, AccountGroup.UUID groupUUID, boolean exclusive) throws Exception {
    grantLabel(Permission.LABEL + "Code-Review", -2, 2, project, "refs/heads/*", false, groupUUID, exclusive);
}
#method_after
private void grantApprove(Project.NameKey project, AccountGroup.UUID groupUUID, boolean exclusive) throws Exception {
    grantLabel("Code-Review", -2, 2, project, "refs/heads/*", false, groupUUID, exclusive);
}
#end_block

#method_before
private void blockApproveForChangeOwner(Project.NameKey project) throws Exception {
    blockLabel(Permission.LABEL + "Code-Review", -2, 2, SystemGroupBackend.CHANGE_OWNER, "refs/heads/*", project);
}
#method_after
private void blockApproveForChangeOwner(Project.NameKey project) throws Exception {
    blockLabel("Code-Review", -2, 2, SystemGroupBackend.CHANGE_OWNER, "refs/heads/*", project);
}
#end_block

#method_before
protected void blockLabel(String permission, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.block(cfg, permission, min, max, id, ref);
    saveProjectConfig(project, cfg);
}
#method_after
protected void blockLabel(String label, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.block(cfg, Permission.LABEL + label, min, max, id, ref);
    saveProjectConfig(project, cfg);
}
#end_block

#method_before
protected void grantLabel(String permission, int min, int max, Project.NameKey project, String ref, boolean force, AccountGroup.UUID groupUUID, boolean exclusive) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.setExclusiveGroup(exclusive);
        PermissionRule rule = Util.newRule(config, groupUUID);
        rule.setForce(force);
        rule.setMin(min);
        rule.setMax(max);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
protected void grantLabel(String label, int min, int max, Project.NameKey project, String ref, boolean force, AccountGroup.UUID groupUUID, boolean exclusive) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    String permission = Permission.LABEL + label;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.setExclusiveGroup(exclusive);
        PermissionRule rule = Util.newRule(config, groupUUID);
        rule.setForce(force);
        rule.setMin(min);
        rule.setMax(max);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    WorkQueue.Executor executor = getExecutor();
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(executor, cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.setAttribute(TASK, task);
        Future<?> f = getExecutor().submit(task);
        cont.addContinuationListener(new Listener(f));
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#end_block

#method_before
private WorkQueue.Executor getExecutor() {
    QueueType qt = capabilityFactory.create(user.get()).getQueueType();
    return queue.getQueue(qt);
}
#method_after
private ScheduledThreadPoolExecutor getExecutor() {
    QueueProvider.QueueType qt = limitsFactory.create(user.get()).getQueueType();
    return queue.getQueue(qt);
}
#end_block

#method_before
private int getPermittedLimit() {
    if (enforceVisibility) {
        return capabilityFactory.create(userProvider.get()).getRange(GlobalCapability.QUERY_LIMIT).getMax();
    }
    return Integer.MAX_VALUE;
}
#method_after
private int getPermittedLimit() {
    if (enforceVisibility) {
        return limitsFactory.create(userProvider.get()).getRange(GlobalCapability.QUERY_LIMIT).getMax();
    }
    return Integer.MAX_VALUE;
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc) throws AuthException, PermissionBackendException {
    PermissionBackend.WithUser perm = permissionBackend.user(self);
    if (self.get() != rsrc.getUser()) {
        perm.check(GlobalPermission.ADMINISTRATE_SERVER);
        perm = permissionBackend.user(rsrc.getUser());
    }
    Map<String, Object> have = new LinkedHashMap<>();
    for (GlobalOrPluginPermission p : perm.test(permissionsToTest())) {
        have.put(p.permissionName(), true);
    }
    AccountLimits cc = capabilityFactory.create(rsrc.getUser());
    addRanges(have, cc);
    addPriority(have, cc);
    return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
    }.getType());
}
#method_after
@Override
public Object apply(AccountResource rsrc) throws AuthException, PermissionBackendException {
    PermissionBackend.WithUser perm = permissionBackend.user(self);
    if (self.get() != rsrc.getUser()) {
        perm.check(GlobalPermission.ADMINISTRATE_SERVER);
        perm = permissionBackend.user(rsrc.getUser());
    }
    Map<String, Object> have = new LinkedHashMap<>();
    for (GlobalOrPluginPermission p : perm.test(permissionsToTest())) {
        have.put(p.permissionName(), true);
    }
    AccountLimits limits = limitsFactory.create(rsrc.getUser());
    addRanges(have, limits);
    addPriority(have, limits);
    return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
    }.getType());
}
#end_block

#method_before
private void addRanges(Map<String, Object> have, AccountLimits cc) {
    for (String name : GlobalCapability.getRangeNames()) {
        if (want(name) && cc.hasExplicitRange(name)) {
            have.put(name, new Range(cc.getRange(name)));
        }
    }
}
#method_after
private void addRanges(Map<String, Object> have, AccountLimits limits) {
    for (String name : GlobalCapability.getRangeNames()) {
        if (want(name) && limits.hasExplicitRange(name)) {
            have.put(name, new Range(limits.getRange(name)));
        }
    }
}
#end_block

#method_before
private void addPriority(Map<String, Object> have, AccountLimits cc) {
    QueueProvider.QueueType queue = cc.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
}
#method_after
private void addPriority(Map<String, Object> have, AccountLimits limits) {
    QueueProvider.QueueType queue = limits.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
}
#end_block

#method_before
@Override
public WorkQueue.Executor get() {
    return queues.getQueue(capabilityFactory.create(user).getQueueType());
}
#method_after
@Override
public ScheduledThreadPoolExecutor get() {
    return queues.getQueue(limitsFactory.create(user).getQueueType());
}
#end_block

#method_before
public int getEffectiveMaxBatchChangesLimit(CurrentUser user) {
    AccountLimits cap = capabilityFactory.create(user);
    if (cap.hasExplicitRange(BATCH_CHANGES_LIMIT)) {
        return cap.getRange(BATCH_CHANGES_LIMIT).getMax();
    }
    return systemMaxBatchChanges;
}
#method_after
public int getEffectiveMaxBatchChangesLimit(CurrentUser user) {
    AccountLimits limits = limitsFactory.create(user);
    if (limits.hasExplicitRange(BATCH_CHANGES_LIMIT)) {
        return limits.getRange(BATCH_CHANGES_LIMIT).getMax();
    }
    return systemMaxBatchChanges;
}
#end_block

