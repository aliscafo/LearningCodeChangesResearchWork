548
#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHostErrataPresenter.class, SubTabHostGeneralHostErrataPresenter.ViewDef.class, SubTabHostGeneralHostErrataView.class, SubTabHostGeneralHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Console Public Key
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(ErrataListWithDetailsPopupPresenterWidget.class, ErrataListWithDetailsPopupPresenterWidget.ViewDef.class, ErrataListWithDetailsPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHostErrataPresenter.class, SubTabHostGeneralHostErrataPresenter.ViewDef.class, SubTabHostGeneralHostErrataView.class, SubTabHostGeneralHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Console Public Key
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
}
#end_block

#method_before
public void addValueChangeHandler(final ValueChangeHandler<ErrataFilterValue> handler) {
    ValueChangeHandler<Boolean> internalHandler = new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            // one of the checkboxes changed, but get all three checkbox values for the evet
            ErrataFilterValue value = new ErrataFilterValue(securityCheckbox.getValue(), bugCheckbox.getValue(), enhancementCheckbox.getValue());
            handler.onValueChange(new ValueChangeEvent<ErrataFilterValue>(value) {
            });
        }
    };
    securityCheckbox.addValueChangeHandler(internalHandler);
    bugCheckbox.addValueChangeHandler(internalHandler);
    enhancementCheckbox.addValueChangeHandler(internalHandler);
}
#method_after
public void addValueChangeHandler(final ValueChangeHandler<ErrataFilterValue> handler) {
    ValueChangeHandler<Boolean> internalHandler = new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            // one of the checkboxes changed, but get all three checkbox values for the event
            ErrataFilterValue value = new ErrataFilterValue(securityCheckbox.getValue(), bugCheckbox.getValue(), enhancementCheckbox.getValue());
            handler.onValueChange(new ValueChangeEvent<ErrataFilterValue>(value) {
            });
        }
    };
    securityCheckbox.addValueChangeHandler(internalHandler);
    bugCheckbox.addValueChangeHandler(internalHandler);
    enhancementCheckbox.addValueChangeHandler(internalHandler);
}
#end_block

#method_before
private void buildErrataDetailPanel() {
    errataDetailPanel.clear();
    errataDetailFormPanel = new GeneralFormPanel();
    errataTitle = new Span();
    errataTitle.setStyleName(style.errataTitleLabel());
    FlowPanel errataTitlePanel = new FlowPanel();
    errataTitlePanel.setStyleName(style.errataTitlePanel());
    errataTitlePanel.add(errataTitle);
    errataDetailPanel.add(errataTitlePanel);
    // $NON-NLS-1$
    errataDetailPanel.setStyleName("testtest");
    errataDetailPanel.add(errataDetailFormPanel);
}
#method_after
private void buildErrataDetailPanel() {
    errataDetailPanel.clear();
    errataDetailFormPanel = new GeneralFormPanel();
    errataTitle = new Span();
    errataTitle.setStyleName(style.errataTitleLabel());
    FlowPanel errataTitlePanel = new FlowPanel();
    errataTitlePanel.setStyleName(style.errataTitlePanel());
    errataTitlePanel.add(errataTitle);
    errataDetailPanel.add(errataTitlePanel);
    errataDetailPanel.add(errataDetailFormPanel);
}
#end_block

#method_before
public void updateErrataDetailFormPanel(Erratum erratum) {
    // $NON-NLS-1$
    logger.info("updateErrataDetailFormPanel for " + erratum);
    buildErrataDetailPanel();
    errataTitle.setText(erratum.getTitle());
    FormBuilder formBuilder = new FormBuilder(errataDetailFormPanel, 1, 10);
    formBuilder.setRelativeColumnWidth(0, 3);
    formBuilder.addFormItem(new FormItem(constants.errataId(), new Span(erratum.getId()), 0, 0));
    // TODO format date
    formBuilder.addFormItem(new FormItem(constants.errataDateIssued(), new Span(erratum.getIssued().toString()), 1, 0));
    // TODO format
    formBuilder.addFormItem(new FormItem(constants.errataType(), new Span(erratum.getType().toString()), 2, 0));
    if (erratum.getSeverity() != null) {
        // TODO format
        formBuilder.addFormItem(new FormItem(constants.errataSeverity(), new Span(erratum.getSeverity().toString()), 3, 0));
    }
    formBuilder.addFormItem(new FormItem(constants.description(), new Span(erratum.getDescription().toString()), 4, 0));
    formBuilder.addFormItem(new FormItem(constants.solution(), new Span(erratum.getSolution()), 5, 0));
    formBuilder.addFormItem(new FormItem(constants.summary(), new Span(erratum.getSummary()), 6, 0));
    // $NON-NLS-1$
    formBuilder.addFormItem(new FormItem(constants.errataPackages(), new Span(StringUtils.join(erratum.getPackages(), ", ")), 7, 0));
}
#method_after
public void updateErrataDetailFormPanel(Erratum erratum) {
    buildErrataDetailPanel();
    errataTitle.setText(erratum.getTitle());
    // share the panel configuration with ErrataListWithDetailsPopupView
    ErrataListWithDetailsPopupView.buildErrataDetailForm(errataDetailFormPanel, erratum);
}
#end_block

#method_before
@Override
public void setMainTabSelectedItem(Erratum selectedItem) {
    // $NON-NLS-1$
    logger.info("setMainTabSelectedItem");
    updateErrataDetailFormPanel(selectedItem);
}
#method_after
@Override
public void setMainTabSelectedItem(Erratum selectedItem) {
    updateErrataDetailFormPanel(selectedItem);
}
#end_block

#method_before
private void initFilterPanel() {
    errataFilterPanel = new ErrataFilterPanel();
    errataFilterPanel.init(true, true, true);
    errataFilterPanel.addStyleName(style.filterPanel());
    // TODO shouldn't this be in a presenter?
    ValueChangeHandler<ErrataFilterValue> handler = new ValueChangeHandler<ErrataFilterValue>() {

        @Override
        public void onValueChange(ValueChangeEvent<ErrataFilterValue> event) {
            // $NON-NLS-1$
            logger.info("handling errata filter change");
            getModelProvider().getModel().setItemsFilter(event.getValue());
            getModelProvider().getModel().reFilter();
        }
    };
    errataFilterPanel.addValueChangeHandler(handler);
}
#method_after
private void initFilterPanel() {
    errataFilterPanel = new ErrataFilterPanel();
    errataFilterPanel.init(true, true, true);
    errataFilterPanel.addStyleName(style.filterPanel());
}
#end_block

#method_before
@Override
public void showErrorMessage(SafeHtml message) {
    // $NON-NLS-1$
    logger.fine(this.getClass().toString() + " setErrorMessage, hiding errata grid");
    tablePanel.setVisible(false);
    errorMessagePanel.clearMessages();
    errorMessagePanel.setVisible(true);
    errorMessagePanel.addMessage(message);
}
#method_after
@Override
public void showErrorMessage(SafeHtml message) {
    tablePanel.setVisible(false);
    errorMessagePanel.clearMessages();
    errorMessagePanel.setVisible(true);
    errorMessagePanel.addMessage(message);
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Erratum, HostListModel<Void>, HostErrataListModel> getHostErrataListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ErrataListWithDetailsPopupPresenterWidget> errataPopupProvider, final Provider<HostListModel<Void>> mainModelProvider, final Provider<HostErrataListModel> modelProvider, final Provider<HostErrataCountModel> countModelProvider) {
    SearchableDetailTabModelProvider<Erratum, HostListModel<Void>, HostErrataListModel> result = new SearchableDetailTabModelProvider<Erratum, HostListModel<Void>, HostErrataListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(HostErrataListModel source, UICommand lastExecutedCommand, Model windowModel) {
            ErrataListWithDetailsPopupPresenterWidget popup = errataPopupProvider.get();
            return popup;
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Erratum, HostListModel<Void>, HostErrataListModel> getHostErrataListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<HostListModel<Void>> mainModelProvider, final Provider<HostErrataListModel> modelProvider, final Provider<HostErrataCountModel> countModelProvider) {
    SearchableDetailTabModelProvider<Erratum, HostListModel<Void>, HostErrataListModel> result = new SearchableDetailTabModelProvider<Erratum, HostListModel<Void>, HostErrataListModel>(eventBus, defaultConfirmPopupProvider);
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public DetailTabModelProvider<HostListModel<Void>, HostErrataCountModel> getHostErrataCountProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ErrataListWithDetailsPopupPresenterWidget> errataPopupProvider, final Provider<HostErrataListModel> listModelProvider, final Provider<HostListModel<Void>> mainModelProvider, final Provider<HostErrataCountModel> modelProvider) {
    DetailTabModelProvider<HostListModel<Void>, HostErrataCountModel> result = new DetailTabModelProvider<HostListModel<Void>, HostErrataCountModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(HostErrataCountModel sourceModel, UICommand lastExecutedCommand, Model windowModel) {
            // TODO huh?     nope -- need to call init on the view
            ErrataListWithDetailsPopupPresenterWidget popup = errataPopupProvider.get();
            // popup.init(modelProvider.get());
            return popup;
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public DetailTabModelProvider<HostListModel<Void>, HostErrataCountModel> getHostErrataCountProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<HostErrataListWithDetailsPopupPresenterWidget> errataPopupProvider, final Provider<HostErrataListModel> listModelProvider, final Provider<HostListModel<Void>> mainModelProvider, final Provider<HostErrataCountModel> modelProvider) {
    DetailTabModelProvider<HostListModel<Void>, HostErrataCountModel> result = new DetailTabModelProvider<HostListModel<Void>, HostErrataCountModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(HostErrataCountModel source, UICommand lastExecutedCommand, Model windowModel) {
            return errataPopupProvider.get();
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
public void edit(AbstractErrataCountModel transferObj) {
    errataTableView.getErrataTable().setLoadingState(LoadingState.LOADING);
    if (transferObj.getMode() == Mode.HOST) {
        errataTableView.init(hostListModelProvider.get());
        hostListModelProvider.get().setGuid(transferObj.getGuid());
        hostListModelProvider.get().search();
    } else {
        errataTableView.init(vmListModelProvider.get());
        vmListModelProvider.get().setGuid(transferObj.getGuid());
        vmListModelProvider.get().search();
    }
    buildErrataDetailPanel();
    setErrataDetailPanelVisibilty(false);
    errataTableView.init(hostListModelProvider.get());
    errataTableView.edit();
}
#method_after
@Override
public void edit(AbstractErrataCountModel transferObj) {
    errataTableView.getErrataTable().setLoadingState(LoadingState.LOADING);
    model.setGuid(transferObj.getGuid());
    errataTableView.init(model);
    HasErrata entity = transferObj.getEntity();
    model.setEntity(entity);
    model.search();
    buildErrataDetailPanel();
    setErrataDetailPanelVisibilty(false);
    errataTableView.edit();
}
#end_block

#method_before
private void buildErrataDetailPanel() {
    errataDetailPanel = new FlowPanel();
    errataDetailFormPanel = new GeneralFormPanel();
    errataTitle = new Span();
    errataTitle.setStyleName(style.errataTitleLabel());
    FlowPanel errataTitlePanel = new FlowPanel();
    errataTitlePanel.setStyleName(style.errataTitlePanel());
    errataTitlePanel.add(errataTitle);
    errataDetailPanel.add(errataTitlePanel);
    // $NON-NLS-1$
    errataDetailPanel.setStyleName("testtest");
    errataDetailPanel.add(errataDetailFormPanel);
}
#method_after
private void buildErrataDetailPanel() {
    // TODO may be able to share this config with SubTabEngineErrataDetailsView
    errataDetailPanel = new FlowPanel();
    errataDetailFormPanel = new GeneralFormPanel();
    errataDetailFormPanel.addStyleName(style.errataDetailFormPanel());
    errataTitle = new Span();
    errataTitle.setStyleName(style.errataTitleLabel());
    FlowPanel errataTitlePanel = new FlowPanel();
    errataTitlePanel.setStyleName(style.errataTitlePanel());
    errataTitlePanel.add(errataTitle);
    errataDetailPanel.add(errataTitlePanel);
    errataDetailPanel.add(errataDetailFormPanel);
}
#end_block

#method_before
public void setErrataDetailPanelVisibilty(boolean visible) {
    // $NON-NLS-1$
    logger.info("updateErrataDetailPanelVisibilty");
    splitLayoutPanel.clear();
    if (visible) {
        splitLayoutPanel.addSouth(errataDetailPanel, SOUTH_SIZE);
    }
    splitLayoutPanel.add(errataTableView);
}
#method_after
public void setErrataDetailPanelVisibilty(boolean visible) {
    splitLayoutPanel.clear();
    if (visible) {
        splitLayoutPanel.addSouth(errataDetailPanel, SOUTH_SIZE);
    }
    splitLayoutPanel.add(errataTableView);
}
#end_block

#method_before
public void updateErrataDetailFormPanel(Erratum erratum) {
    // $NON-NLS-1$
    logger.info("updateErrataDetailFormPanel for " + erratum);
    errataTitle.setText(erratum.getTitle());
    FormBuilder formBuilder = new FormBuilder(errataDetailFormPanel, 1, 10);
    formBuilder.setRelativeColumnWidth(0, 3);
    formBuilder.addFormItem(new FormItem(constants.errataId(), new Span(erratum.getId()), 0, 0));
    // TODO format date
    formBuilder.addFormItem(new FormItem(constants.errataDateIssued(), new Span(erratum.getIssued().toString()), 1, 0));
    // TODO format
    formBuilder.addFormItem(new FormItem(constants.errataType(), new Span(erratum.getType().toString()), 2, 0));
    // TODO format //$NON-NLS-1$
    formBuilder.addFormItem(new FormItem(constants.errataSeverity(), new Span(erratum.getSeverity() == null ? "N/A" : erratum.getSeverity().toString()), 3, 0));
    formBuilder.addFormItem(new FormItem(constants.description(), new Span(erratum.getDescription().toString()), 4, 0));
    formBuilder.addFormItem(new FormItem(constants.solution(), new Span(erratum.getSolution()), 5, 0));
    formBuilder.addFormItem(new FormItem(constants.summary(), new Span(erratum.getSummary()), 6, 0));
    // $NON-NLS-1$
    formBuilder.addFormItem(new FormItem(constants.errataPackages(), new Span(StringUtils.join(erratum.getPackages(), ", ")), 7, 0));
}
#method_after
public void updateErrataDetailFormPanel(Erratum erratum) {
    errataTitle.setText(erratum.getTitle());
    buildErrataDetailForm(errataDetailFormPanel, erratum);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    // $NON-NLS-1$
    logger.info(this.getClass().toString() + " handling command");
    if (CLOSE.equals(command.getName())) {
        cancel();
    } else if (SHOW_SECURITY_COMMAND.equals(command.getName()) || SHOW_BUGS_COMMAND.equals(command.getName()) || SHOW_ENHANCEMENTS_COMMAND.equals(command.getName())) {
        onShowErrata();
    } else {
        super.executeCommand(command);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    if (CLOSE.equals(command.getName())) {
        cancel();
    } else if (SHOW_SECURITY_COMMAND.equals(command.getName()) || SHOW_BUGS_COMMAND.equals(command.getName()) || SHOW_ENHANCEMENTS_COMMAND.equals(command.getName())) {
        showErrataListWithDetailsPopup();
    } else {
        super.executeCommand(command);
    }
}
#end_block

#method_before
public void setErrataCounts(ErrataCounts errataCounts) {
    this.errataCounts.setEntity(errataCounts);
    // ^ publishes an EntityChange event, bus notifies the Presenter
    // $NON-NLS-1$
    logger.info("query called back setErrataCounts on count model, publishing an EntityChange event to the subscribers (hopefully the Presenter)");
}
#method_after
public void setErrataCounts(ErrataCounts errataCounts) {
    this.errataCounts.setEntity(errataCounts);
// ^ publishes an EntityChange event, bus notifies the Presenter
}
#end_block

#method_before
public void setMessage(String errorMessage) {
    super.setMessage(errorMessage);
    // ^ publishes an onPropertyChanged ("Message") event, bus notifies the Presenter
    // $NON-NLS-1$
    logger.info("query called back setMessage on count model, publishing a PropertyChanged event to the subscribers (hopefully the Presenter)");
}
#method_after
public void setMessage(String errorMessage) {
    super.setMessage(errorMessage);
// ^ publishes an onPropertyChanged ("Message") event, bus notifies the Presenter
}
#end_block

#method_before
public void runQuery(Guid guid) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            AbstractErrataCountModel errataCountModel = (AbstractErrataCountModel) model;
            VdcQueryReturnValue returnValueObject = (VdcQueryReturnValue) returnValue;
            ErrataCounts resultEntity = returnValueObject.getReturnValue();
            if (resultEntity != null && returnValueObject.getSucceeded()) {
                // $NON-NLS-1$
                logger.info(this.getClass().toString() + " errata counts query success");
                errataCountModel.setErrataCounts(resultEntity);
            } else {
                errataCountModel.setExceptionCode(returnValueObject.getExceptionString());
                // $NON-NLS-1$
                logger.info(this.getClass().toString() + " query exception: " + returnValueObject.getExceptionString());
            }
        }
    };
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    logger.info(this.getClass().toString() + " runQuery [" + getQueryType() + "] for id [" + guid + "]");
    Frontend.getInstance().runQuery(getQueryType(), new IdQueryParameters(guid), _asyncQuery);
}
#method_after
public void runQuery(Guid guid) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            AbstractErrataCountModel errataCountModel = (AbstractErrataCountModel) model;
            VdcQueryReturnValue returnValueObject = (VdcQueryReturnValue) returnValue;
            ErrataCounts resultEntity = returnValueObject.getReturnValue();
            if (resultEntity != null && returnValueObject.getSucceeded()) {
                errataCountModel.setErrataCounts(resultEntity);
            } else {
                errataCountModel.setMessage(// $NON-NLS-1$
                constants.katelloProblemRetrievingErrata() + " " + returnValueObject.getExceptionMessage());
            }
        }
    };
    Frontend.getInstance().runQuery(getQueryType(), new IdQueryParameters(guid), _asyncQuery);
}
#end_block

#method_before
protected void initCommands(Model m) {
    m.getCommands().add(UICommand.createDefaultOkUiCommand(CLOSE, this));
// TODO allow ok button too
}
#method_after
protected void initCommands(Model m) {
    m.getCommands().add(UICommand.createDefaultOkUiCommand(CLOSE, this));
}
#end_block

#method_before
@Override
protected String getListName() {
    // $NON-NLS-1$
    logger.fine(this.getClass().toString() + " getListName");
    // $NON-NLS-1$
    return "VmErrataListModel";
}
#method_after
@Override
protected String getListName() {
    // $NON-NLS-1$
    return "VmErrataListModel";
}
#end_block

#method_before
@ProxyEvent
public void onHostSelectionChange(HostSelectionChangeEvent event) {
    updateMainTabSelection(event.getSelectedItems());
    currentSelectedHost = event.getSelectedItems().get(0);
    currentErrataModel = getModelProvider().getModel();
    updateModel(currentErrataModel);
}
#method_after
@ProxyEvent
public void onHostSelectionChange(HostSelectionChangeEvent event) {
    updateMainTabSelection(event.getSelectedItems());
    currentSelectedHost = event.getSelectedItems().get(0);
    updateModel(currentErrataCountModel);
}
#end_block

#method_before
@Override
public void initializeHandlers() {
    super.initializeHandlers();
    registerHandler(getView().getTotalSecurity().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalSecurity().getCommand().execute();
        }
    }));
    registerHandler(getView().getTotalBugFix().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalBugFix().getCommand().execute();
        }
    }));
    registerHandler(getView().getTotalEnhancement().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalEnhancement().getCommand().execute();
        }
    }));
    // $NON-NLS-1$
    logger.info("subscribing to HostErrataCountModel changes");
    // Handle the counts changing -> simple view update.
    // 
    currentErrataModel.addErrataCountsChangeListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // $NON-NLS-1$
            logger.info("bus published message that the counts changed. update view.");
            // bus published message that the counts changed. update view.
            ErrataCounts counts = currentErrataModel.getErrataCounts();
            getView().showCounts(counts);
        }
    });
    // Handle the count model getting a query error -> simple view update.
    // 
    currentErrataModel.addErrorMessageChangeListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (currentErrataModel.getMessage() != null && !currentErrataModel.getMessage().isEmpty()) {
                // $NON-NLS-1$
                logger.info("bus published message that there was a query error. update view.");
                // bus published message that an error occurred communicating with Katello. Show the alert panel.
                getView().showErrorMessage(SafeHtmlUtils.fromString(currentErrataModel.getMessage()));
            }
        }
    });
}
#method_after
@Override
public void initializeHandlers() {
    super.initializeHandlers();
    registerHandler(getView().getTotalSecurity().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalSecurity().getCommand().execute();
        }
    }));
    registerHandler(getView().getTotalBugFix().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalBugFix().getCommand().execute();
        }
    }));
    registerHandler(getView().getTotalEnhancement().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalEnhancement().getCommand().execute();
        }
    }));
    // Handle the counts changing -> simple view update.
    // 
    currentErrataCountModel.addErrataCountsChangeListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // bus published message that the counts changed. update view.
            ErrataCounts counts = currentErrataCountModel.getErrataCounts();
            getView().showCounts(counts);
        }
    });
    // Handle the count model getting a query error -> simple view update.
    // 
    currentErrataCountModel.addErrorMessageChangeListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (currentErrataCountModel.getMessage() != null && !currentErrataCountModel.getMessage().isEmpty()) {
                // bus published message that an error occurred communicating with Katello. Show the alert panel.
                getView().showErrorMessage(SafeHtmlUtils.fromString(currentErrataCountModel.getMessage()));
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    // $NON-NLS-1$
    logger.info(this.getClass().toString() + " onBind");
    updateModel(currentErrataModel);
    getView().getTotalSecurity().setCommand(currentErrataModel.getShowSecurityCommand());
    getView().getTotalBugFix().setCommand(currentErrataModel.getShowBugsCommand());
    getView().getTotalEnhancement().setCommand(currentErrataModel.getShowEnhancementsCommand());
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    getView().getTotalSecurity().setCommand(currentErrataCountModel.getShowSecurityCommand());
    getView().getTotalBugFix().setCommand(currentErrataCountModel.getShowBugsCommand());
    getView().getTotalEnhancement().setCommand(currentErrataCountModel.getShowEnhancementsCommand());
}
#end_block

#method_before
private void updateModel(HostErrataCountModel model) {
    if (currentSelectedHost != null) {
        model.setGuid(currentSelectedHost.getId());
        model.setName(currentSelectedHost.getName());
        model.runQuery(currentSelectedHost.getId());
    }
}
#method_after
private void updateModel(HostErrataCountModel model) {
    if (currentSelectedHost != null) {
        model.setGuid(currentSelectedHost.getId());
        model.runQuery(currentSelectedHost.getId());
    }
}
#end_block

#method_before
@Override
protected void syncSearch() {
    super.syncSearch();
    // $NON-NLS-1$
    logger.info(this.getClass().toString() + " sync search");
    runQuery(getGuid());
}
#method_after
@Override
protected void syncSearch() {
    super.syncSearch();
    runQuery(getGuid());
}
#end_block

#method_before
private void runQuery(Guid guid) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object returnValue) {
            AbstractErrataListModel errataListModel = (AbstractErrataListModel) model;
            VdcQueryReturnValue returnValueObject = (VdcQueryReturnValue) returnValue;
            if (returnValueObject.getSucceeded()) {
                // $NON-NLS-1$
                logger.info(this.getClass().toString() + " errata list query success");
                unfilteredResultList = (List<Erratum>) returnValueObject.getReturnValue();
                // manual client-side filter
                // logger.info("setting unfiltered list [size " + unfilteredResultList.size() + "] of errata into list model"); //$NON-NLS-1$ //$NON-NLS-2$
                // setItems(unfilteredResultList);
                setItems(filter(unfilteredResultList));
            } else {
                errataListModel.setExceptionCode(returnValueObject.getExceptionString());
                // $NON-NLS-1$
                logger.info(this.getClass().toString() + " query exception: " + returnValueObject.getExceptionString());
            }
        }
    };
    // TODO remove -- testing errata and vms only
    // $NON-NLS-1$
    Guid hardcode = Guid.createGuidFromString("79de2c7d-f25f-4572-b79c-f75534e0d7ca");
    Frontend.getInstance().runQuery(VdcQueryType.GetErrataForHost, new IdQueryParameters(hardcode), _asyncQuery);
// logger.info(this.getClass().toString() + " runQuery [" + getQueryType() + "] for guid [" + guid + "]"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
// Frontend.getInstance().runQuery(getQueryType(), new IdQueryParameters(guid), _asyncQuery);
}
#method_after
private void runQuery(Guid guid) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object returnValue) {
            AbstractErrataListModel errataListModel = (AbstractErrataListModel) model;
            VdcQueryReturnValue returnValueObject = (VdcQueryReturnValue) returnValue;
            if (returnValueObject.getSucceeded()) {
                unfilteredResultList = (List<Erratum>) returnValueObject.getReturnValue();
                // manual client-side filter
                setItems(filter(unfilteredResultList));
            } else {
                errataListModel.setMessage(// $NON-NLS-1$
                constants.katelloProblemRetrievingErrata() + " " + returnValueObject.getExceptionMessage());
            }
        }
    };
    Frontend.getInstance().runQuery(getQueryType(), new IdQueryParameters(guid), _asyncQuery);
}
#end_block

#method_before
protected Collection<Erratum> filter(Collection<Erratum> resultList) {
    // if no filter, return original
    if (filter == null || (filter.isSecurity() && filter.isBugs() && filter.isEnhancements())) {
        return resultList;
    }
    List<Erratum> ret = new ArrayList<>();
    for (Erratum e : resultList) {
        if ((filter.isSecurity() && e.getType() == Erratum.ErrataType.SECURITY) || (filter.isBugs() && e.getType() == Erratum.ErrataType.BUGFIX) || (filter.isEnhancements() && e.getType() == Erratum.ErrataType.ENHANCEMENT)) {
            ret.add(e);
        }
    }
    return ret;
}
#method_after
protected Collection<EntityModel<Erratum>> filter(Collection<Erratum> resultList) {
    List<EntityModel<Erratum>> ret = new ArrayList<>();
    for (Erratum e : resultList) {
        if ((filter == null || (filter.isSecurity() && filter.isBugs() && filter.isEnhancements())) || (filter.isSecurity() && e.getType() == Erratum.ErrataType.SECURITY) || (filter.isBugs() && e.getType() == Erratum.ErrataType.BUGFIX) || (filter.isEnhancements() && e.getType() == Erratum.ErrataType.ENHANCEMENT)) {
            EntityModel<Erratum> erratum = new EntityModel<>();
            erratum.setEntity(e);
            ret.add(erratum);
        }
    }
    return ret;
}
#end_block

#method_before
@Override
protected VdcQueryType getQueryType() {
    // TODO need GetErrataCountsForVm
    return VdcQueryType.GetErrataCountsForHost;
}
#method_after
@Override
protected VdcQueryType getQueryType() {
    return VdcQueryType.GetErrataCountsForVm;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Erratum, VmListModel<Void>, VmErrataListModel> getVmErrataListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmErrataListModel> modelProvider) {
    SearchableDetailTabModelProvider<Erratum, VmListModel<Void>, VmErrataListModel> result = new SearchableDetailTabModelProvider<Erratum, VmListModel<Void>, VmErrataListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmErrataListModel source, UICommand lastExecutedCommand, Model windowModel) {
            return super.getModelPopup(source, lastExecutedCommand, windowModel);
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Erratum, VmListModel<Void>, VmErrataListModel> getVmErrataListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmErrataListModel> modelProvider) {
    SearchableDetailTabModelProvider<Erratum, VmListModel<Void>, VmErrataListModel> result = new SearchableDetailTabModelProvider<Erratum, VmListModel<Void>, VmErrataListModel>(eventBus, defaultConfirmPopupProvider);
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public DetailTabModelProvider<VmListModel<Void>, VmErrataCountModel> getVmErrataCountProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmErrataCountModel> modelProvider) {
    DetailTabModelProvider<VmListModel<Void>, VmErrataCountModel> result = new DetailTabModelProvider<VmListModel<Void>, VmErrataCountModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmErrataCountModel sourceModel, UICommand lastExecutedCommand, Model windowModel) {
            // TODO implement?
            return super.getModelPopup(sourceModel, lastExecutedCommand, windowModel);
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public DetailTabModelProvider<VmListModel<Void>, VmErrataCountModel> getVmErrataCountProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmErrataListWithDetailsPopupPresenterWidget> errataPopupProvider, final Provider<VmErrataCountModel> modelProvider) {
    DetailTabModelProvider<VmListModel<Void>, VmErrataCountModel> result = new DetailTabModelProvider<VmListModel<Void>, VmErrataCountModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmErrataCountModel source, UICommand lastExecutedCommand, Model windowModel) {
            return errataPopupProvider.get();
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
private void initFilterPanel() {
    ValueChangeHandler<ErrataFilterValue> handler = new ValueChangeHandler<ErrataFilterValue>() {

        @Override
        public void onValueChange(ValueChangeEvent<ErrataFilterValue> event) {
            // $NON-NLS-1$
            logger.info("handling errata filter change");
            errataListModel.setItemsFilter(event.getValue());
            errataListModel.reFilter();
        }
    };
    errataFilterPanel.addValueChangeHandler(handler);
}
#method_after
private void initFilterPanel() {
    // Handle the filter panel's checkboxes values changing -> simple view update (re-run client-side filter)
    // 
    ValueChangeHandler<ErrataFilterValue> handler = new ValueChangeHandler<ErrataFilterValue>() {

        @Override
        public void onValueChange(ValueChangeEvent<ErrataFilterValue> event) {
            errataListModel.setItemsFilter(event.getValue());
            errataListModel.reFilter();
        }
    };
    errataFilterPanel.addValueChangeHandler(handler);
}
#end_block

#method_before
public Erratum getSelectedErratum() {
    @SuppressWarnings({ "unchecked", "rawtypes" })
    SingleSelectionModel<Erratum> selectionModel = (SingleSelectionModel) errataTable.getSelectionModel();
    Erratum erratum = selectionModel.getSelectedObject();
    return erratum;
}
#method_after
public Erratum getSelectedErratum() {
    @SuppressWarnings({ "unchecked", "rawtypes" })
    SingleSelectionModel<EntityModel<Erratum>> selectionModel = (SingleSelectionModel) errataTable.getSelectionModel();
    Erratum erratum = selectionModel.getSelectedObject().getEntity();
    return erratum;
}
#end_block

#method_before
@Override
protected String getListName() {
    // $NON-NLS-1$
    logger.fine(this.getClass().toString() + " getListName");
    // $NON-NLS-1$
    return "EngineErrataListModel";
}
#method_after
@Override
protected String getListName() {
    // $NON-NLS-1$
    return "EngineErrataListModel";
}
#end_block

#method_before
public void getAllErrata(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Erratum>();
            }
            // Collections.sort((List<Erratum>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetErrataForSystem, new GetAllErrataParameters(), aQuery);
}
#method_after
public void getAllErrata(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Erratum>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetErrataForSystem, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecutePartially(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected String getListName() {
    // $NON-NLS-1$
    logger.fine(this.getClass().toString() + " getListName");
    // $NON-NLS-1$
    return "HostErrataListModel";
}
#method_after
@Override
protected String getListName() {
    // $NON-NLS-1$
    return "HostErrataListModel";
}
#end_block

#method_before
@ProxyEvent
public void onVirtualMachineSelectionChange(VirtualMachineSelectionChangeEvent event) {
    updateMainTabSelection(event.getSelectedItems());
    currentSelectedVm = null;
    if (event.getSelectedItems() != null && event.getSelectedItems().size() > 0) {
        currentSelectedVm = event.getSelectedItems().get(0);
        currentErrataModel = getModelProvider().getModel();
    }
    updateModel(currentErrataModel);
}
#method_after
@ProxyEvent
public void onVirtualMachineSelectionChange(VirtualMachineSelectionChangeEvent event) {
    updateMainTabSelection(event.getSelectedItems());
    currentSelectedVm = null;
    if (event.getSelectedItems() != null && !event.getSelectedItems().isEmpty()) {
        currentSelectedVm = event.getSelectedItems().get(0);
    }
    updateModel();
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    // $NON-NLS-1$
    logger.info(this.getClass().toString() + " onBind");
    currentErrataModel = getModelProvider().getModel();
    updateModel(currentErrataModel);
    getView().getTotalSecurity().setCommand(currentErrataModel.getShowSecurityCommand());
    getView().getTotalBugFix().setCommand(currentErrataModel.getShowBugsCommand());
    getView().getTotalEnhancement().setCommand(currentErrataModel.getShowEnhancementsCommand());
    registerHandler(getView().getTotalSecurity().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalSecurity().getCommand().execute();
        }
    }));
    registerHandler(getView().getTotalBugFix().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalBugFix().getCommand().execute();
        }
    }));
    registerHandler(getView().getTotalEnhancement().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalEnhancement().getCommand().execute();
        }
    }));
    // Handle the counts changing -> simple view update.
    // 
    currentErrataModel.addErrataCountsChangeListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // $NON-NLS-1$
            logger.info(this.getClass().toString() + ": bus published message that the counts changed. update view.");
            // bus published message that the counts changed. update view.
            ErrataCounts counts = currentErrataModel.getErrataCounts();
            getView().showCounts(counts);
        }
    });
    // Handle the count model getting a query error -> simple view update.
    // 
    currentErrataModel.addErrorMessageChangeListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            // $NON-NLS-1$
            logger.info(this.getClass().toString() + ": bus published message that there was a query error. update view.");
            // bus published message that an error occurred communicating with Katello. Show the alert panel.
            getView().showErrorMessage(SafeHtmlUtils.fromString(currentErrataModel.getMessage()));
        }
    });
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    getView().getTotalSecurity().setCommand(errataCountModel.getShowSecurityCommand());
    getView().getTotalBugFix().setCommand(errataCountModel.getShowBugsCommand());
    getView().getTotalEnhancement().setCommand(errataCountModel.getShowEnhancementsCommand());
    registerHandler(getView().getTotalSecurity().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalSecurity().getCommand().execute();
        }
    }));
    registerHandler(getView().getTotalBugFix().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalBugFix().getCommand().execute();
        }
    }));
    registerHandler(getView().getTotalEnhancement().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getTotalEnhancement().getCommand().execute();
        }
    }));
    // Handle the counts changing -> simple view update.
    // 
    errataCountModel.addErrataCountsChangeListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // bus published message that the counts changed. update view.
            ErrataCounts counts = errataCountModel.getErrataCounts();
            getView().showCounts(counts);
        }
    });
    // Handle the count model getting a query error -> simple view update.
    // 
    errataCountModel.addErrorMessageChangeListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("Message".equals(args.propertyName)) {
                // bus published message that an error occurred communicating with Katello. Show the alert panel.
                if (errataCountModel.getMessage() != null && !errataCountModel.getMessage().isEmpty()) {
                    getView().showErrorMessage(SafeHtmlUtils.fromString(errataCountModel.getMessage()));
                } else {
                    getView().clearErrorMessage();
                }
            }
        }
    });
}
#end_block

#method_before
private void updateModel(VmErrataCountModel model) {
    if (currentSelectedVm != null) {
        // Update the model with data from the backend
        model.setGuid(currentSelectedVm.getId());
        model.setName(currentSelectedVm.getName());
        model.runQuery(currentSelectedVm.getId());
    }
}
#method_after
private void updateModel() {
    if (currentSelectedVm != null) {
        // Update the model with data from the backend
        errataCountModel.setGuid(currentSelectedVm.getId());
        errataCountModel.setEntity(currentSelectedVm);
        errataCountModel.runQuery(currentSelectedVm.getId());
    }
}
#end_block

#method_before
@Override
protected PlaceRequest getMainTabRequest() {
    // $NON-NLS-1$
    logger.info(this.getClass().toString() + " getMainTabRequest");
    return PlaceRequestFactory.get(WebAdminApplicationPlaces.errataMainTabPlace);
}
#method_after
@Override
protected PlaceRequest getMainTabRequest() {
    return PlaceRequestFactory.get(WebAdminApplicationPlaces.errataMainTabPlace);
}
#end_block

#method_before
@Override
protected void fireTableSelectionChangeEvent() {
    // $NON-NLS-1$
    logger.info(this.getClass().toString() + " fireTableSelectionChangeEvent");
    ErrataSelectionChangeEvent.fire(this, getSelectedItems());
}
#method_after
@Override
protected void fireTableSelectionChangeEvent() {
    ErrataSelectionChangeEvent.fire(this, getSelectedItems());
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    // $NON-NLS-1$
    logger.info("onBind");
    // TODO need to setModel() ?
    getModel().retrieveEngineErrata();
    // Handle the list model getting a query error -> simple view update.
    // 
    getModel().addErrorMessageChangeListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            // $NON-NLS-1$
            logger.info(this.getClass().toString() + " eventRaised");
            if (getModel().getMessage() != null && !getModel().getMessage().isEmpty()) {
                // $NON-NLS-1$
                logger.info("bus published message that there was a query error. update view.");
                // bus published message that an error occurred communicating with Katello. Show the alert panel.
                getView().showErrorMessage(SafeHtmlUtils.fromString(getModel().getMessage()));
            } else if (getModel().getMessage() == null || getModel().getMessage().isEmpty()) {
                // $NON-NLS-1$
                logger.info("bus published message that there was not a query error. clearMessage() / show table.");
                getView().clearErrorMessage();
            }
        }
    });
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    getModel().retrieveEngineErrata();
    // Handle the list model getting a query error -> simple view update.
    // 
    getModel().addErrorMessageChangeListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (getModel().getMessage() != null && !getModel().getMessage().isEmpty()) {
                // bus published message that an error occurred communicating with Katello. Show the alert panel.
                getView().showErrorMessage(SafeHtmlUtils.fromString(getModel().getMessage()));
            } else if (getModel().getMessage() == null || getModel().getMessage().isEmpty()) {
                getView().clearErrorMessage();
            }
        }
    });
    // Handle the filter panel value changing -> simple view update (re-filter).
    // 
    getView().getErrataFilterPanel().addValueChangeHandler(new ValueChangeHandler<ErrataFilterValue>() {

        @Override
        public void onValueChange(ValueChangeEvent<ErrataFilterValue> event) {
            getModel().setItemsFilter(event.getValue());
            getModel().reFilter();
        }
    });
}
#end_block

#method_before
@Override
public void init(final AbstractErrataCountModel clickSource) {
    super.init(clickSource);
    AbstractErrataListModel model;
    if (clickSource.getMode() == Mode.HOST) {
        model = hostErrataListProvider.getModel();
    } else {
        model = vmErrataListProvider.getModel();
    }
    // Handle the query returning a new list of errata -> simple view update.
    // 
    model.addItemsChangeListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            // $NON-NLS-1$
            logger.info("bus says a new query result (list) is available");
            // getView().setItems(model.getItems());
            getView().showErrataList();
        }
    });
    // our view also has references to both list models, and needs to know what mode we're working in.
    getView().initMode(clickSource.getMode());
}
#method_after
@Override
public void init(final AbstractErrataCountModel clickSource) {
    super.init(clickSource);
    AbstractErrataListModel model = modelProvider.getModel();
    // Handle the query returning a new list of errata -> simple view update.
    // 
    model.addItemsChangeListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            getView().showErrataList();
        }
    });
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    // Handle the errata selection changing -> simple view update.
    // 
    getView().addErrataChangeSelectionHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            Erratum erratum = getView().getSelectedErratum();
            if (erratum == null) {
                getView().setErrataDetailPanelVisibilty(false);
            } else {
                getView().updateErrataDetailFormPanel(erratum);
                getView().setErrataDetailPanelVisibilty(true);
            }
        }
    });
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    // Handle the errata selection changing -> simple view update.
    // 
    getView().getErrataTable().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            Erratum erratum = getView().getSelectedErratum();
            if (erratum == null) {
                getView().setErrataDetailPanelVisibilty(false);
            } else {
                getView().updateErrataDetailFormPanel(erratum);
                getView().setErrataDetailPanelVisibilty(true);
            }
        }
    });
}
#end_block

#method_before
public static String format(String messagePattern, Object... args) {
    return MessageFormatter.arrayFormat(messagePattern, args).getMessage();
}
#method_after
public static String format(String messagePattern, Object arg) {
    return MessageFormatter.format(messagePattern, arg).getMessage();
}
#end_block

#method_before
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Object object = method.invoke(producer, args);
    if (method.getName().equals("produce") && spiedClasses.contains(object.getClass())) {
        object = spy(object);
    }
    return object;
}
#method_after
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Object object = method.invoke(producer, args);
    if (object != null && method.getName().equals("produce") && spiedClasses.contains(object.getClass())) {
        object = spy(object);
    }
    return object;
}
#end_block

#method_before
@Before
public void initTest() {
    PolicyUnitDaoImpl mock = mock(PolicyUnitDaoImpl.class);
    ClusterPolicyDaoImpl mock1 = mock(ClusterPolicyDaoImpl.class);
    when(dbFacade.getPolicyUnitDao()).thenReturn(mock);
    when(dbFacade.getClusterPolicyDao()).thenReturn(mock1);
    when(mock.getAll()).thenReturn(Collections.<PolicyUnit>emptyList());
    when(mock1.getAll()).thenReturn(Collections.<ClusterPolicy>emptyList());
}
#method_after
@Before
public void initTest() {
    PolicyUnitDao policyUnitDao = mock(PolicyUnitDao.class);
    ClusterPolicyDao clusterPolicyDao = mock(ClusterPolicyDao.class);
    when(dbFacade.getPolicyUnitDao()).thenReturn(policyUnitDao);
    when(dbFacade.getClusterPolicyDao()).thenReturn(clusterPolicyDao);
    when(policyUnitDao.getAll()).thenReturn(Collections.<PolicyUnit>emptyList());
    when(clusterPolicyDao.getAll()).thenReturn(Collections.<ClusterPolicy>emptyList());
}
#end_block

#method_before
@Deployment
public static JavaArchive createDeployment() {
    return ShrinkWrap.create(JavaArchive.class).addClasses(TestDeps.class, SchedulingManager.class).addAsManifestResource(EmptyAsset.INSTANCE, ArchivePaths.create("beans.xml"));
}
#method_after
@Deployment
public static JavaArchive createDeployment() {
    return ShrinkWrap.create(JavaArchive.class).addClasses(CommonTestMocks.class, SchedulingManager.class, ExternalSchedulerDiscovery.class, BasicMigrationHandler.class).addAsManifestResource(EmptyAsset.INSTANCE, ArchivePaths.create("beans.xml"));
}
#end_block

#method_before
@Test
public void testSchedule() throws Exception {
    verify(schedulingManager.get()).init();
}
#method_after
@Test
public void testSchedule() throws Exception {
    assertNotNull(schedulingManager.get());
    verify(schedulingManager.get()).init();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDao().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDao().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            if (!validate(new ClusterValidator(getDbFacade(), oldGroup, getCpuFlagsManagerHandler()).dataCenterVersionMismatch())) {
                result = false;
                addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDao().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(EngineMessage.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(EngineMessage.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDao().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDao().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldGroup, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDao().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(EngineMessage.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(EngineMessage.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    return result;
}
#end_block

#method_before
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && noCollapseWithSnapshots()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED, String.format("$VmName %1$s", getVmName()));
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        if (!validateAndSetVmFromExportDomain()) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    return true;
}
#method_after
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && isCopyCollapseDisabledWithSnapshots()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED, String.format("$VmName %1$s", getVmName()));
    }
    // Register can never happen with copyCollapse = true since there's no copy operation involved.
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        if (!validateAndSetVmFromExportDomain()) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    if (copyCollapseOrNoSnapshots()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    if (isCopyCollapseOrNoSnapshots()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    model.setHelpTag(HelpTag.editConsole);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = UICommand.createDefaultOkUiCommand("OnEditConsoleSave", this);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consolesFactory.getVmConsolesForVm(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    model.setHelpTag(HelpTag.editConsole);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = UICommand.createDefaultOkUiCommand("OnEditConsoleSave", this);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        if (VdcActionUtils.canExecute(Arrays.asList(vm), VM.class, VdcActionType.RemoveVm)) {
            EntityModel removeDisksCheckbox = new EntityModel(true);
            removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
            removeDisksCheckbox.setMessage(vm.getName());
            if (!Guid.Empty.equals(vm.getVmtGuid())) {
                updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
            }
            vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
        }
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(singleVmSelected && isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(singleVmSelected && isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItem() == null ? null : getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItem() == null ? null : getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consolesFactory.getVmConsolesForVm(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getSetConsoleKeyCommand()) {
        editConsoleKey();
    } else if ("OnAssignTags".equals(command.getName())) {
        // $NON-NLS-1$
        onAssignTags();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        preSave();
    } else if ("PreSavePhase2".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase2();
        cancelConfirmation();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if ("OnExport".equals(command.getName())) {
        // $NON-NLS-1$
        onExport();
    } else if ("OnExportNoTemplates".equals(command.getName())) {
        // $NON-NLS-1$
        onExportNoTemplates();
    } else if ("CancelConfirmation".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if ("OnRunOnce".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnNewTemplate".equals(command.getName())) {
        // $NON-NLS-1$
        onNewTemplate();
    } else if ("OnMigrate".equals(command.getName())) {
        // $NON-NLS-1$
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if ("OnShutdown".equals(command.getName())) {
        // $NON-NLS-1$
        onShutdown();
    } else if ("OnStop".equals(command.getName())) {
        // $NON-NLS-1$
        onStop();
    } else if ("OnReboot".equals(command.getName())) {
        // $NON-NLS-1$
        onReboot();
    } else if ("OnChangeCD".equals(command.getName())) {
        // $NON-NLS-1$
        onChangeCD();
    } else if ("OnSetConsoleKey".equals(command.getName())) {
        // $NON-NLS-1$
        onSetConsoleKey();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getSetConsoleKeyCommand()) {
        editConsoleKey();
    } else if ("OnAssignTags".equals(command.getName())) {
        // $NON-NLS-1$
        onAssignTags();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        preSave();
    } else if ("PreSavePhase2".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase2();
        cancelConfirmation();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if ("OnExport".equals(command.getName())) {
        // $NON-NLS-1$
        onExport();
    } else if ("OnExportNoTemplates".equals(command.getName())) {
        // $NON-NLS-1$
        onExportNoTemplates();
    } else if ("CancelConfirmation".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if ("OnRunOnce".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnNewTemplate".equals(command.getName())) {
        // $NON-NLS-1$
        onNewTemplate();
    } else if ("OnMigrate".equals(command.getName())) {
        // $NON-NLS-1$
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (command == getCancelConvertCommand()) {
        cancelConversion();
    } else if ("OnShutdown".equals(command.getName())) {
        // $NON-NLS-1$
        onShutdown();
    } else if ("OnStop".equals(command.getName())) {
        // $NON-NLS-1$
        onStop();
    } else if ("OnReboot".equals(command.getName())) {
        // $NON-NLS-1$
        onReboot();
    } else if ("OnChangeCD".equals(command.getName())) {
        // $NON-NLS-1$
        onChangeCD();
    } else if ("OnSetConsoleKey".equals(command.getName())) {
        // $NON-NLS-1$
        onSetConsoleKey();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consolesFactory.getVmConsolesForVm(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
public void initForemanProviders(final Guid selected) {
    AsyncQuery getProvidersQuery = new AsyncQuery();
    getProvidersQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object result) {
            List<Provider<OpenstackNetworkProviderProperties>> providers = (List<Provider<OpenstackNetworkProviderProperties>>) result;
            Provider<OpenstackNetworkProviderProperties> noneProvider = createNoneProvider();
            providers.add(0, noneProvider);
            ListModel<Provider<OpenstackNetworkProviderProperties>> providersListModel = getProviders();
            if (selected != null) {
                // Find the selected provider.
                for (Provider<OpenstackNetworkProviderProperties> provider : providers) {
                    if (provider.getId().equals(selected)) {
                        providersListModel.setItems(providers, provider);
                        break;
                    }
                }
            }
            if (providersListModel.getItems() == null || providersListModel.getItems().isEmpty()) {
                providersListModel.setItems(providers, providers.get(0));
            }
            providersListModel.setIsChangeable(true);
        }

        private Provider<OpenstackNetworkProviderProperties> createNoneProvider() {
            Provider<OpenstackNetworkProviderProperties> noneProvider = new Provider<>();
            noneProvider.setId(Guid.Empty);
            noneProvider.setName(messages.providerNone());
            return noneProvider;
        }
    };
    AsyncDataProvider.getInstance().getAllProvidersByType(getProvidersQuery, ProviderType.FOREMAN);
}
#method_after
public void initForemanProviders(final Guid selected) {
    AsyncQuery getProvidersQuery = new AsyncQuery();
    getProvidersQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object result) {
            List<Provider<OpenstackNetworkProviderProperties>> providers = (List<Provider<OpenstackNetworkProviderProperties>>) result;
            Provider<OpenstackNetworkProviderProperties> noneProvider = createNoneProvider();
            providers.add(0, noneProvider);
            ListModel<Provider<OpenstackNetworkProviderProperties>> providersListModel = getProviders();
            if (selected != null) {
                // Find the selected provider.
                for (Provider<OpenstackNetworkProviderProperties> provider : providers) {
                    if (provider.getId().equals(selected)) {
                        providersListModel.setItems(providers, provider);
                        break;
                    }
                }
            }
            if (providersListModel.getItems() == null || providersListModel.getItems().isEmpty()) {
                providersListModel.setItems(providers, providers.get(0));
            }
            providersListModel.setIsChangeable(true);
        }

        private Provider<OpenstackNetworkProviderProperties> createNoneProvider() {
            Provider<OpenstackNetworkProviderProperties> noneProvider = new Provider<>();
            noneProvider.setId(Guid.Empty);
            noneProvider.setName(constants.providerNone());
            return noneProvider;
        }
    };
    AsyncDataProvider.getInstance().getAllProvidersByType(getProvidersQuery, ProviderType.FOREMAN);
}
#end_block

#method_before
public boolean validate(boolean templateWithVersionRequired) {
    resetTabsValidity();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        validateNaming();
        getVmId().setIsValid(true);
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getVmId().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (!(getBehavior().isBlankTemplateBehavior())) {
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    }
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.FIRST_RUN, vmInitIsValid);
    getIcon().validateEntity(new IValidation[] { new IconWithOsDefaultValidation() });
    setValidTab(TabName.ICON_TAB, getIcon().getIsValid());
    boolean hwPartValid = validateHwPart();
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#method_after
public boolean validate(boolean templateWithVersionRequired) {
    resetTabsValidity();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        validateNaming();
        getVmId().setIsValid(true);
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getVmId().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (!(getBehavior().isBlankTemplateBehavior())) {
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    }
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.FIRST_RUN, vmInitIsValid);
    getIcon().validateEntity(new IValidation[] { new IconWithOsDefaultValidation() });
    setValidTab(TabName.ICON_TAB, getIcon().getIsValid());
    boolean hwPartValid = validateHwPart();
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    HostValidator validator = new HostValidator(getVds());
    return validate(validator.hostExists());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() == null || !new FenceValidator().isStartupTimeoutPassed() || !isQuietTimeFromLastActionPassed()) {
        log.error("Failed to run Fence script on vds '{}'.", getVdsName());
        alertIfPowerManagementOperationSkipped(RESTART, null);
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (getVds().getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal;
        retVal = runInternalAction(VdcActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!MonitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (skippedDueToFencingPolicy) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogableBase alb = new AuditLogableBase(getVds().getId());
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (!new FenceValidator().isStartupTimeoutPassed() || !isQuietTimeFromLastActionPassed()) {
        log.error("Failed to run Fence script on vds '{}'.", getVdsName());
        alertIfPowerManagementOperationSkipped(RESTART, null);
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (getVds().getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal;
        retVal = runInternalAction(VdcActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!MonitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = getDbFacade().getVdsGroupDao().get(getVds().getVdsGroupId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
            // Since the parent class run the command, we need to reinitialize the execution context
            if (this.getExecutionContext() != null) {
                this.getExecutionContext().setJob(getDbFacade().getJobDao().get(this.getJobId()));
            }
        }
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (skippedDueToFencingPolicy) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogableBase alb = new AuditLogableBase(getVds().getId());
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#end_block

#method_before
private void setStoragePoolNonOperational() {
    log.info("Fence failed on vds '{}' which is spm of pool '{}' - moving pool to non operational", getVds().getName(), getVds().getStoragePoolId());
    Job job = getContext().getExecutionContext().getJob();
    runInternalAction(VdcActionType.SetStoragePoolStatus, new SetStoragePoolStatusParameters(getVds().getStoragePoolId(), StoragePoolStatus.NotOperational, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM));
    getContext().getExecutionContext().setJob(job);
}
#method_after
private void setStoragePoolNonOperational() {
    log.info("Fence failed on vds '{}' which is spm of pool '{}' - moving pool to non operational", getVds().getName(), getVds().getStoragePoolId());
    CommandContext commandContext = getContext().clone();
    // CommandContext clone is 'shallow' and does not clone the internal ExecutionContext.
    // So ExecutionContext is cloned here manually to prevent a bug (BZ1145099).
    commandContext.withExecutionContext(new ExecutionContext(commandContext.getExecutionContext()));
    runInternalAction(VdcActionType.SetStoragePoolStatus, new SetStoragePoolStatusParameters(getVds().getStoragePoolId(), StoragePoolStatus.NotOperational, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM), commandContext);
}
#end_block

#method_before
public boolean isStartupTimeoutPassed() {
    return isStartupTimeoutPassed(new LinkedList<String>());
}
#method_after
public boolean isStartupTimeoutPassed() {
    // check if we are in the interval of X seconds from startup
    // if yes , system is still initializing , ignore fence operations
    Date waitTo = getBackend().getStartedAt().addSeconds((Integer) Config.getValue(ConfigValues.DisableFenceAtStartupInSec));
    Date now = new Date();
    if (!(waitTo.before(now) || waitTo.equals(now))) {
        return false;
    } else {
        return true;
    }
}
#end_block

#method_before
public boolean isStartupTimeoutPassed(List<String> messages) {
    // check if we are in the interval of X seconds from startup
    // if yes , system is still initializing , ignore fence operations
    Date waitTo = getBackend().getStartedAt().addSeconds((Integer) Config.getValue(ConfigValues.DisableFenceAtStartupInSec));
    Date now = new Date();
    if (!(waitTo.before(now) || waitTo.equals(now))) {
        messages.add(EngineMessage.VDS_FENCE_DISABLED_AT_SYSTEM_STARTUP_INTERVAL.name());
        return false;
    } else {
        return true;
    }
}
#method_after
public boolean isStartupTimeoutPassed(List<String> messages) {
    boolean startupTimeoutPassed = isStartupTimeoutPassed();
    if (!startupTimeoutPassed) {
        messages.add(EngineMessage.VDS_FENCE_DISABLED_AT_SYSTEM_STARTUP_INTERVAL.name());
    }
    return startupTimeoutPassed;
}
#end_block

#method_before
public Api getConnection() throws UnsecuredConnectionAttemptError, ServerException, IOException {
    if (api == null) {
        String url = String.format("%s://%s:%s/ovirt-engine/api", protocol, server, port);
        log.debug(String.format("Logging to %s as %s", url, username));
        api = new Api(url, username, password, true);
    }
    return api;
}
#method_after
public synchronized Api getConnection() throws UnsecuredConnectionAttemptError, ServerException, IOException {
    if (api == null) {
        String url = String.format("%s://%s:%s/ovirt-engine/api", protocol, server, port);
        log.debug(String.format("Logging to %s as %s", url, username));
        api = new Api(url, username, password, null, null, requestTimeout, true, true, null, false);
    }
    return api;
}
#end_block

#method_before
@Test
public void testReportConfigurationsOnHost() throws Exception {
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    ifaceQos.setOutAverageLinkshare(1);
    ifaceQos.setOutAverageUpperlimit(1);
    ifaceQos.setOutAverageRealtime(1);
    ReportedConfigurations reportedConfigurations = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = Arrays.asList(new ReportedConfiguration(ReportedConfigurationType.MTU, Integer.toString(iface.getMtu()), Integer.toString(network.getMtu()), true), new ReportedConfiguration(ReportedConfigurationType.BRIDGED, Boolean.toString(iface.isBridged()), Boolean.toString(network.isVmNetwork()), true), new ReportedConfiguration(ReportedConfigurationType.VLAN, Integer.toString(iface.getVlanId()), Integer.toString(network.getVlanId()), true), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_LINK_SHARE, ifaceQos.getOutAverageLinkshare().toString(), // $NON-NLS-1$
    "null", false), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_UPPER_LIMIT, ifaceQos.getOutAverageUpperlimit().toString(), // $NON-NLS-1$
    "null", false), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_REAL_TIME, ifaceQos.getOutAverageRealtime().toString(), // $NON-NLS-1$
    "null", false));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(6));
}
#method_after
@Test
public void testReportConfigurationsOnHost() throws Exception {
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    ifaceQos.setOutAverageLinkshare(1);
    ifaceQos.setOutAverageUpperlimit(1);
    ifaceQos.setOutAverageRealtime(1);
    ReportedConfigurations reportedConfigurations = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = Arrays.asList(new ReportedConfiguration(ReportedConfigurationType.MTU, Integer.toString(iface.getMtu()), Integer.toString(network.getMtu()), true), new ReportedConfiguration(ReportedConfigurationType.BRIDGED, Boolean.toString(iface.isBridged()), Boolean.toString(network.isVmNetwork()), true), new ReportedConfiguration(ReportedConfigurationType.VLAN, Integer.toString(iface.getVlanId()), Integer.toString(network.getVlanId()), true), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_LINK_SHARE, ifaceQos.getOutAverageLinkshare().toString(), null, false), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_UPPER_LIMIT, ifaceQos.getOutAverageUpperlimit().toString(), null, false), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_REAL_TIME, ifaceQos.getOutAverageRealtime().toString(), null, false));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(6));
}
#end_block

#method_before
public ReportedConfigurations add(ReportedConfigurationType type, boolean value, boolean clusterValue, boolean inSync) {
    reportedConfigurationList.add(new ReportedConfiguration(type, Boolean.toString(value), Boolean.toString(clusterValue), inSync));
    return this;
}
#method_after
public <T> ReportedConfigurations add(ReportedConfigurationType type, T actual, T expected, boolean inSync) {
    String actualValue = actual == null ? null : actual.toString();
    String expectedValue = expected == null ? null : expected.toString();
    reportedConfigurationList.add(new ReportedConfiguration(type, actualValue, expectedValue, inSync));
    return this;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof ReportedConfiguration)) {
        return false;
    }
    ReportedConfiguration that = (ReportedConfiguration) o;
    return Objects.equals(isInSync(), that.isInSync()) && Objects.equals(getType(), that.getType()) && Objects.equals(getValue(), that.getValue()) && Objects.equals(getClusterValue(), that.getClusterValue());
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof ReportedConfiguration)) {
        return false;
    }
    ReportedConfiguration that = (ReportedConfiguration) o;
    return Objects.equals(isInSync(), that.isInSync()) && Objects.equals(getType(), that.getType()) && Objects.equals(getActualValue(), that.getActualValue()) && Objects.equals(getExpectedValue(), that.getExpectedValue());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(getType(), getValue(), getClusterValue(), isInSync());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getType(), getActualValue(), getExpectedValue(), isInSync());
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            acquireHostDevicesLock();
            if (connectLunDisks(getVdsId()) && updateCinderDisksConnections()) {
                if (!checkRequiredHostDevicesAvailability()) {
                    // (while the host-device lock wasn't being held) we need to bail here
                    throw new EngineException(EngineError.HOST_DEVICES_TAKEN_BY_OTHER_VM);
                } else {
                    status = createVm();
                    ExecutionHandler.setAsyncJob(getExecutionContext(), true);
                    markHostDevicesAsUsed();
                }
            }
        } catch (EngineException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    cleanupPassthroughVnics();
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            releaseHostDevicesLock();
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            acquireHostDevicesLock();
            if (connectLunDisks(getVdsId()) && updateCinderDisksConnections()) {
                if (!checkRequiredHostDevicesAvailability()) {
                    // (while the host-device lock wasn't being held) we need to bail here
                    throw new EngineException(EngineError.HOST_DEVICES_TAKEN_BY_OTHER_VM);
                } else {
                    status = createVm();
                    ExecutionHandler.setAsyncJob(getExecutionContext(), true);
                    markHostDevicesAsUsed();
                }
            }
        } catch (EngineException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    cleanupPassthroughVnics();
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                case HOST_DEVICES_TAKEN_BY_OTHER_VM:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            releaseHostDevicesLock();
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
private void markHostDevicesAsUsed() {
    if (needsHostDevices) {
        hostDeviceManager.allocateVmHostDevices(getVmId());
    }
}
#method_after
private void markHostDevicesAsUsed() {
    if (needsHostDevices) {
        hostDeviceManager.allocateVmHostDevices(getVm());
    }
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(CpuFlagsManagerHandler.getCpuId(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine((getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getVdsGroup().getEmulatedMachine()));
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine((getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getVdsGroup().getEmulatedMachine()));
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#end_block

#method_before
public static LUNs parseLunFromXmlRpc(Map<String, Object> xlun) {
    LUNs lun = new LUNs();
    if (xlun.containsKey("GUID")) {
        lun.setLUN_id(xlun.get("GUID").toString());
    }
    if (xlun.containsKey("pvUUID")) {
        lun.setphysical_volume_id(xlun.get("pvUUID").toString());
    }
    if (xlun.containsKey("vgUUID")) {
        lun.setvolume_group_id(xlun.get("vgUUID").toString());
    } else {
        lun.setvolume_group_id("");
    }
    if (xlun.containsKey("vgName")) {
        lun.setStorageDomainId(Guid.createGuidFromString(xlun.get("vgName").toString()));
    }
    if (xlun.containsKey("serial")) {
        lun.setSerial(xlun.get("serial").toString());
    }
    if (xlun.containsKey(PATHSTATUS)) {
        Object[] temp = (Object[]) xlun.get(PATHSTATUS);
        Map<String, Object>[] pathStatus = null;
        if (temp != null) {
            lun.setPathsDictionary(new HashMap<String, Boolean>());
            lun.setPathsCapacity(new HashMap<String, Integer>());
            pathStatus = new Map[temp.length];
            for (int i = 0; i < temp.length; i++) {
                pathStatus[i] = (Map<String, Object>) temp[i];
            }
            for (Map xcon : pathStatus) {
                if (xcon.containsKey(LUN_FIELD)) {
                    lun.setLunMapping(Integer.parseInt(xcon.get(LUN_FIELD).toString()));
                }
                if (xcon.containsKey(PHYSICAL_DEVICE_FIELD) && xcon.containsKey(DEVICE_STATE_FIELD)) {
                    // set name and state - if active true, otherwise false
                    lun.getPathsDictionary().put(xcon.get(PHYSICAL_DEVICE_FIELD).toString(), DEVICE_ACTIVE_VALUE.equals(xcon.get(DEVICE_STATE_FIELD).toString()));
                }
                if (xcon.containsKey(PHYSICAL_DEVICE_FIELD) && xcon.containsKey(DEVICE_PATH_CAPACITY_FIELD)) {
                    // set name and capacity
                    Long size = IrsBrokerCommand.assignLongValue(xcon, DEVICE_PATH_CAPACITY_FIELD);
                    lun.getPathsCapacity().put(xcon.get(PHYSICAL_DEVICE_FIELD).toString(), SizeConverter.convert(size, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue());
                }
            }
        }
    }
    if (xlun.containsKey("vendorID")) {
        lun.setVendorId(xlun.get("vendorID").toString());
    }
    if (xlun.containsKey("productID")) {
        lun.setProductId(xlun.get("productID").toString());
    }
    lun.setLunConnections(new ArrayList<StorageServerConnections>());
    if (xlun.containsKey("pathlist")) {
        Object[] temp = (Object[]) xlun.get("pathlist");
        Map[] pathList = null;
        if (temp != null) {
            pathList = new Map[temp.length];
            for (int i = 0; i < temp.length; i++) {
                pathList[i] = (Map<String, Object>) temp[i];
            }
            for (Map xcon : pathList) {
                lun.getLunConnections().add(parseConnection(xcon));
            }
        }
    }
    Long size = IrsBrokerCommand.assignLongValue(xlun, "devcapacity");
    if (size == null) {
        size = IrsBrokerCommand.assignLongValue(xlun, "capacity");
    }
    if (size != null) {
        lun.setDeviceSize((int) (size / SizeConverter.BYTES_IN_GB));
    }
    if (xlun.containsKey("pvsize")) {
        Long pvSize = IrsBrokerCommand.assignLongValue(xlun, "pvsize");
        if (pvSize != null)
            lun.setPvSize(SizeConverter.convert(pvSize, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue());
    }
    if (xlun.containsKey("vendorID")) {
        lun.setVendorName(xlun.get("vendorID").toString());
    }
    if (xlun.containsKey(DEVTYPE_FIELD)) {
        String devtype = xlun.get(DEVTYPE_FIELD).toString();
        if (!DEVTYPE_VALUE_FCP.equalsIgnoreCase(devtype)) {
            lun.setLunType(StorageType.ISCSI);
        } else {
            lun.setLunType(StorageType.FCP);
        }
    }
    if (xlun.containsKey(STATUS)) {
        String status = xlun.get(STATUS).toString();
        lun.setStatus(EnumUtils.valueOf(LunStatus.class, status, true));
    }
    return lun;
}
#method_after
public static LUNs parseLunFromXmlRpc(Map<String, Object> xlun) {
    LUNs lun = new LUNs();
    if (xlun.containsKey("GUID")) {
        lun.setLUN_id(xlun.get("GUID").toString());
    }
    if (xlun.containsKey("pvUUID")) {
        lun.setphysical_volume_id(xlun.get("pvUUID").toString());
    }
    if (xlun.containsKey("vgUUID")) {
        lun.setvolume_group_id(xlun.get("vgUUID").toString());
    } else {
        lun.setvolume_group_id("");
    }
    if (xlun.containsKey("vgName")) {
        lun.setStorageDomainId(Guid.createGuidFromString(xlun.get("vgName").toString()));
    }
    if (xlun.containsKey("serial")) {
        lun.setSerial(xlun.get("serial").toString());
    }
    if (xlun.containsKey(PATHSTATUS)) {
        Object[] temp = (Object[]) xlun.get(PATHSTATUS);
        Map<String, Object>[] pathStatus = null;
        if (temp != null) {
            lun.setPathsDictionary(new HashMap<String, Boolean>());
            lun.setPathsCapacity(new HashMap<String, Integer>());
            pathStatus = new Map[temp.length];
            for (int i = 0; i < temp.length; i++) {
                pathStatus[i] = (Map<String, Object>) temp[i];
            }
            for (Map xcon : pathStatus) {
                if (xcon.containsKey(LUN_FIELD)) {
                    lun.setLunMapping(Integer.parseInt(xcon.get(LUN_FIELD).toString()));
                }
                if (xcon.containsKey(PHYSICAL_DEVICE_FIELD) && xcon.containsKey(DEVICE_STATE_FIELD)) {
                    // set name and state - if active true, otherwise false
                    lun.getPathsDictionary().put(xcon.get(PHYSICAL_DEVICE_FIELD).toString(), DEVICE_ACTIVE_VALUE.equals(xcon.get(DEVICE_STATE_FIELD).toString()));
                }
                if (xcon.containsKey(PHYSICAL_DEVICE_FIELD) && xcon.containsKey(DEVICE_PATH_CAPACITY_FIELD)) {
                    // set name and capacity
                    Long size = IrsBrokerCommand.assignLongValue(xcon, DEVICE_PATH_CAPACITY_FIELD);
                    lun.getPathsCapacity().put(xcon.get(PHYSICAL_DEVICE_FIELD).toString(), SizeConverter.convert(size, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue());
                }
            }
        }
    }
    if (xlun.containsKey("vendorID")) {
        lun.setVendorId(xlun.get("vendorID").toString());
    }
    if (xlun.containsKey("productID")) {
        lun.setProductId(xlun.get("productID").toString());
    }
    lun.setLunConnections(new ArrayList<StorageServerConnections>());
    if (xlun.containsKey("pathlist")) {
        Object[] temp = (Object[]) xlun.get("pathlist");
        Map[] pathList = null;
        if (temp != null) {
            pathList = new Map[temp.length];
            for (int i = 0; i < temp.length; i++) {
                pathList[i] = (Map<String, Object>) temp[i];
            }
            for (Map xcon : pathList) {
                lun.getLunConnections().add(parseConnection(xcon));
            }
        }
    }
    Long size = IrsBrokerCommand.assignLongValue(xlun, "devcapacity");
    if (size == null) {
        size = IrsBrokerCommand.assignLongValue(xlun, "capacity");
    }
    if (size != null) {
        lun.setDeviceSize((int) (size / SizeConverter.BYTES_IN_GB));
    }
    if (xlun.containsKey("pvsize")) {
        Long pvSize = IrsBrokerCommand.assignLongValue(xlun, "pvsize");
        if (pvSize != null)
            lun.setPvSize(SizeConverter.convert(pvSize, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue());
    }
    if (xlun.containsKey("vendorID")) {
        lun.setVendorName(xlun.get("vendorID").toString());
    }
    if (xlun.containsKey(DEVTYPE_FIELD)) {
        String devtype = xlun.get(DEVTYPE_FIELD).toString();
        if (DEVTYPE_VALUE_FCP.equalsIgnoreCase(devtype)) {
            lun.setLunType(StorageType.FCP);
        } else {
            lun.setLunType(StorageType.ISCSI);
        }
    }
    if (xlun.containsKey(STATUS)) {
        String status = xlun.get(STATUS).toString();
        lun.setStatus(EnumUtils.valueOf(LunStatus.class, status, true));
    }
    return lun;
}
#end_block

#method_before
public VmConsoles getVmConsoles() {
    return poolRepresentative == null ? consolesCache.getVmConsolesForVm((VM) getEntity()) : consolesCache.getVmConsolesForPool(poolRepresentative);
}
#method_after
public VmConsoles getVmConsoles() {
    return poolRepresentative == null ? consolesFactory.getVmConsolesForVm((VM) getEntity()) : consolesFactory.getVmConsolesForPool(poolRepresentative);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        if (VdcActionUtils.canExecute(Arrays.asList(vm), VM.class, VdcActionType.RemoveVm)) {
            EntityModel removeDisksCheckbox = new EntityModel(true);
            removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
            removeDisksCheckbox.setMessage(vm.getName());
            if (!Guid.Empty.equals(vm.getVmtGuid())) {
                updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
            }
            vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
        }
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(singleVmSelected && isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(singleVmSelected && isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getSetConsoleKeyCommand()) {
        editConsoleKey();
    } else if ("OnAssignTags".equals(command.getName())) {
        // $NON-NLS-1$
        onAssignTags();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        preSave();
    } else if ("PreSavePhase2".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase2();
        cancelConfirmation();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if ("OnExport".equals(command.getName())) {
        // $NON-NLS-1$
        onExport();
    } else if ("OnExportNoTemplates".equals(command.getName())) {
        // $NON-NLS-1$
        onExportNoTemplates();
    } else if ("CancelConfirmation".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if ("OnRunOnce".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnNewTemplate".equals(command.getName())) {
        // $NON-NLS-1$
        onNewTemplate();
    } else if ("OnMigrate".equals(command.getName())) {
        // $NON-NLS-1$
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if ("OnShutdown".equals(command.getName())) {
        // $NON-NLS-1$
        onShutdown();
    } else if ("OnStop".equals(command.getName())) {
        // $NON-NLS-1$
        onStop();
    } else if ("OnReboot".equals(command.getName())) {
        // $NON-NLS-1$
        onReboot();
    } else if ("OnChangeCD".equals(command.getName())) {
        // $NON-NLS-1$
        onChangeCD();
    } else if ("OnSetConsoleKey".equals(command.getName())) {
        // $NON-NLS-1$
        onSetConsoleKey();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getSetConsoleKeyCommand()) {
        editConsoleKey();
    } else if ("OnAssignTags".equals(command.getName())) {
        // $NON-NLS-1$
        onAssignTags();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        preSave();
    } else if ("PreSavePhase2".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase2();
        cancelConfirmation();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if ("OnExport".equals(command.getName())) {
        // $NON-NLS-1$
        onExport();
    } else if ("OnExportNoTemplates".equals(command.getName())) {
        // $NON-NLS-1$
        onExportNoTemplates();
    } else if ("CancelConfirmation".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if ("OnRunOnce".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnNewTemplate".equals(command.getName())) {
        // $NON-NLS-1$
        onNewTemplate();
    } else if ("OnMigrate".equals(command.getName())) {
        // $NON-NLS-1$
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (command == getCancelConvertCommand()) {
        cancelConversion();
    } else if ("OnShutdown".equals(command.getName())) {
        // $NON-NLS-1$
        onShutdown();
    } else if ("OnStop".equals(command.getName())) {
        // $NON-NLS-1$
        onStop();
    } else if ("OnReboot".equals(command.getName())) {
        // $NON-NLS-1$
        onReboot();
    } else if ("OnChangeCD".equals(command.getName())) {
        // $NON-NLS-1$
        onChangeCD();
    } else if ("OnSetConsoleKey".equals(command.getName())) {
        // $NON-NLS-1$
        onSetConsoleKey();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#end_block

#method_before
public void getDataCenterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterList(AsyncQuery aQuery) {
    getDataCenterList(aQuery, true);
}
#end_block

#method_before
public void getDataCenterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    // $NON-NLS-1$
    SearchParameters params = new SearchParameters("DataCenter: sortby name", SearchType.StoragePool);
    Frontend.getInstance().runQuery(VdcQueryType.Search, doRefresh ? params : params.withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getClusterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery) {
    getClusterList(aQuery, true);
}
#end_block

#method_before
public void getClusterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, doRefresh ? new VdcQueryParametersBase() : new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getHostList(AsyncQuery aQuery) {
    getHostListByStatus(aQuery, null);
}
#method_after
public void getHostList(AsyncQuery aQuery, boolean doRefresh) {
    getHostListByStatus(aQuery, null, doRefresh);
}
#end_block

#method_before
public void getHostListByStatus(AsyncQuery aQuery, VDSStatus status) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getHostListByStatus(AsyncQuery aQuery, VDSStatus status) {
    getHostListByStatus(aQuery, status, true);
}
#end_block

#method_before
public void getHostListByStatus(AsyncQuery aQuery, VDSStatus status) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getHostListByStatus(AsyncQuery aQuery, VDSStatus status, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, doRefresh ? searchParameters : searchParameters.withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getVolumeList(AsyncQuery aQuery, boolean doRefresh) {
    getVolumeList(aQuery, null, doRefresh);
}
#end_block

#method_before
public void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getVolumeList(AsyncQuery aQuery, String clusterName) {
    getVolumeList(aQuery, clusterName, true);
}
#end_block

#method_before
public void getAllProviders(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), aQuery);
}
#method_after
public void getAllProviders(AsyncQuery aQuery) {
    getAllProviders(aQuery, true);
}
#end_block

#method_before
public void getAllProviders(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), aQuery);
}
#method_after
public void getAllProviders(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, doRefresh ? new GetAllProvidersParameters() : new GetAllProvidersParameters().withoutRefresh(), aQuery);
}
#end_block

#method_before
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    return isRebootCommandExecutionAllowed(vms, false);
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecutePartially(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public List<IStorageModel> getExportStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsExportModel = new NfsStorageModel();
    models.add(nfsExportModel);
    PosixStorageModel posixExportModel = new PosixStorageModel();
    models.add(posixExportModel);
    GlusterStorageModel glusterExportModel = new GlusterStorageModel();
    models.add(glusterExportModel);
    addTypeToStorageModels(StorageDomainType.ImportExport, models);
    return models;
}
#method_after
public List<IStorageModel> getExportStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsExportModel = new NfsStorageModel();
    models.add(nfsExportModel);
    PosixStorageModel posixExportModel = new PosixStorageModel();
    models.add(posixExportModel);
    GlusterStorageModel glusterExportModel = new GlusterStorageModel();
    models.add(glusterExportModel);
    LocalStorageModel localExportStorageModel = new LocalStorageModel();
    models.add(localExportStorageModel);
    addTypeToStorageModels(StorageDomainType.ImportExport, models);
    return models;
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm), this);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    model.initForemanProviders(vm.getProviderId());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnSave", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm), this);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnSave", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        if (VdcActionUtils.canExecute(Arrays.asList(vm), VM.class, VdcActionType.RemoveVm)) {
            EntityModel removeDisksCheckbox = new EntityModel(true);
            removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
            removeDisksCheckbox.setMessage(vm.getName());
            if (!Guid.Empty.equals(vm.getVmtGuid())) {
                updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
            }
            vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
        }
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(singleVmSelected && isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmsBeingConverted());
}
#method_after
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(singleVmSelected && isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        if (vm.getStatus() == VMStatus.Down) {
            EntityModel removeDisksCheckbox = new EntityModel(true);
            removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
            removeDisksCheckbox.setMessage(vm.getName());
            if (!Guid.Empty.equals(vm.getVmtGuid())) {
                updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
            }
            vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
        }
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        if (VdcActionUtils.canExecute(Arrays.asList(vm), VM.class, VdcActionType.RemoveVm)) {
            EntityModel removeDisksCheckbox = new EntityModel(true);
            removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
            removeDisksCheckbox.setMessage(vm.getName());
            if (!Guid.Empty.equals(vm.getVmtGuid())) {
                updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
            }
            vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
        }
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && isRemoveCommandExecutionAllowed(items));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(singleVmSelected && isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    cpuFlagsManagerHandler = SimpleDependecyInjector.getInstance().get(CpuFlagsManagerHandler.class);
    updateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        updateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        updateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
        if (pair.getFirst().isHotsetAllowed()) {
            updateVmsStatic.AddHotsetFields(pair.getSecond().getName());
        }
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.UpdateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.RemoveVm);
}
#method_after
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    cpuFlagsManagerHandler = Injector.get(CpuFlagsManagerHandler.class);
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    updateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        updateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        updateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
        if (pair.getFirst().isHotsetAllowed()) {
            updateVmsStatic.AddHotsetFields(pair.getSecond().getName());
        }
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.UpdateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.RemoveVm);
}
#end_block

#method_before
private static boolean addDeviceUpdateOnNextRun(Guid vmId, EditableDeviceOnVmStatusField annotation, Object key, Object value, List<VmDeviceUpdate> updates) {
    return addDeviceUpdateOnNextRun(vmId, annotation.generalType(), annotation.type(), annotation.isReadOnly(), key, value, updates);
}
#method_after
private static boolean addDeviceUpdateOnNextRun(Guid vmId, EditableDeviceOnVmStatusField annotation, Object key, Object value, List<VmDeviceUpdate> updates) {
    return addDeviceUpdateOnNextRun(vmId, annotation.generalType(), annotation.type(), annotation.isReadOnly(), annotation.name(), key, value, updates);
}
#end_block

#method_before
private static boolean addDeviceUpdateOnNextRun(Guid vmId, VmDeviceGeneralType generalType, VmDeviceType type, boolean readOnly, Object key, Object value, List<VmDeviceUpdate> updates) {
    if (key != null) {
        VmDeviceGeneralType keyGeneralType = VmDeviceGeneralType.UNKNOWN;
        VmDeviceType keyType = VmDeviceType.UNKNOWN;
        if (key instanceof VmDeviceGeneralType) {
            keyGeneralType = (VmDeviceGeneralType) key;
        } else if (key instanceof VmDeviceType) {
            keyType = (VmDeviceType) key;
        } else if (key instanceof GraphicsType) {
            keyType = ((GraphicsType) key).getCorrespondingDeviceType();
        } else {
            log.warn("addDeviceUpdateOnNextRun: Unsupported map key type: " + key.getClass().getName());
            return false;
        }
        if (keyGeneralType != VmDeviceGeneralType.UNKNOWN) {
            generalType = keyGeneralType;
        }
        if (keyType != VmDeviceType.UNKNOWN) {
            type = keyType;
        }
    }
    // if device type is set to unknown, search by general type only
    // because some devices have more than one type, like sound can be ac97/ich6
    String typeName = type != VmDeviceType.UNKNOWN ? type.getName() : null;
    if (value == null) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, false)) {
            updates.add(new VmDeviceUpdate(generalType, type, readOnly, false));
        }
    } else if (value instanceof Boolean) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, (Boolean) value)) {
            updates.add(new VmDeviceUpdate(generalType, type, readOnly, (Boolean) value));
        }
    } else if (value instanceof VmDevice) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, (VmDevice) value)) {
            updates.add(new VmDeviceUpdate(generalType, type, readOnly, (VmDevice) value));
        }
    } else {
        log.warn("addDeviceUpdateOnNextRun: Unsupported value type: " + value.getClass().getName());
        return false;
    }
    return true;
}
#method_after
private static boolean addDeviceUpdateOnNextRun(Guid vmId, VmDeviceGeneralType generalType, VmDeviceType type, boolean readOnly, String name, Object key, Object value, List<VmDeviceUpdate> updates) {
    if (key != null) {
        VmDeviceGeneralType keyGeneralType = VmDeviceGeneralType.UNKNOWN;
        VmDeviceType keyType = VmDeviceType.UNKNOWN;
        if (key instanceof VmDeviceGeneralType) {
            keyGeneralType = (VmDeviceGeneralType) key;
        } else if (key instanceof VmDeviceType) {
            keyType = (VmDeviceType) key;
        } else if (key instanceof GraphicsType) {
            keyType = ((GraphicsType) key).getCorrespondingDeviceType();
        } else {
            log.warn("addDeviceUpdateOnNextRun: Unsupported map key type: " + key.getClass().getName());
            return false;
        }
        if (keyGeneralType != VmDeviceGeneralType.UNKNOWN) {
            generalType = keyGeneralType;
        }
        if (keyType != VmDeviceType.UNKNOWN) {
            type = keyType;
        }
    }
    // if device type is set to unknown, search by general type only
    // because some devices have more than one type, like sound can be ac97/ich6
    String typeName = type != VmDeviceType.UNKNOWN ? type.getName() : null;
    if (value == null) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, false)) {
            updates.add(new VmDeviceUpdate(generalType, type, readOnly, name, false));
        }
    } else if (value instanceof Boolean) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, (Boolean) value)) {
            updates.add(new VmDeviceUpdate(generalType, type, readOnly, name, (Boolean) value));
        }
    } else if (value instanceof VmDevice) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, (VmDevice) value)) {
            updates.add(new VmDeviceUpdate(generalType, type, readOnly, name, (VmDevice) value));
        }
    } else {
        log.warn("addDeviceUpdateOnNextRun: Unsupported value type: " + value.getClass().getName());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VDS vds = getDbFacade().getVdsDao().get(getParameters().getId());
    if (vds != null) {
        vds.setCpuName(cpuFlagsManagerHandler.findMaxServerCpuByFlags(vds.getCpuFlags(), vds.getVdsGroupCompatibilityVersion()));
    }
    getQueryReturnValue().setReturnValue(vds);
}
#method_after
@Override
protected void executeQueryCommand() {
    VDS vds = getDbFacade().getVdsDao().get(getParameters().getId());
    if (vds != null) {
        vds.setCpuName(getCpuFlagsManagerHandler().findMaxServerCpuByFlags(vds.getCpuFlags(), vds.getVdsGroupCompatibilityVersion()));
    }
    getQueryReturnValue().setReturnValue(vds);
}
#end_block

#method_before
protected void mockCpuFlagsManagerHandler() {
    SimpleDependecyInjector.getInstance().bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
}
#method_after
protected void mockCpuFlagsManagerHandler() {
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(cpuFlagsManagerHandler.allServerCpuList(getParameters().getVersion()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getCpuFlagsManagerHandler().allServerCpuList(getParameters().getVersion()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    String vdsGroupCpuName = getVds().getVdsGroupCpuName();
    VDSGroup grp = DbFacade.getInstance().getVdsGroupDao().get(getVds().getVdsGroupId());
    ServerCpu sc = cpuFlagsManagerHandler.findMaxServerCpuByFlags(getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
    if (sc == null) {
        // operational
        if (!StringUtils.isEmpty(getVds().getCpuFlags())) {
            foundCPU = false;
        } else {
            _hasFlags = false;
        }
        log.error("Could not find server cpu for server '{}' ({}), flags: '{}'", getVds().getName(), getVdsId(), getVds().getCpuFlags());
    }
    // Checks whether the host and the cluster have the same architecture
    if (_hasFlags && foundCPU) {
        if (grp.getArchitecture() != ArchitectureType.undefined && sc.getArchitecture() != grp.getArchitecture()) {
            architectureMatch = false;
            addCustomValue("VdsArchitecture", sc.getArchitecture().name());
            addCustomValue("VdsGroupArchitecture", grp.getArchitecture().name());
            SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.ARCHITECTURE_INCOMPATIBLE_WITH_CLUSTER);
            runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext(getContext()));
        } else {
            // if cluster doesn't have cpu then get the cpu from the vds
            if (StringUtils.isEmpty(vdsGroupCpuName)) {
                // update group with the cpu name
                grp.setCpuName(sc.getCpuName());
                grp.setArchitecture(sc.getArchitecture());
                updateMigrateOnError(grp);
                // use suppress in order to update group even if action fails
                // (out of the transaction)
                ManagementNetworkOnClusterOperationParameters tempVar = new ManagementNetworkOnClusterOperationParameters(grp);
                tempVar.setTransactionScopeOption(TransactionScopeOption.Suppress);
                tempVar.setIsInternalCommand(true);
                runInternalAction(VdcActionType.UpdateVdsGroup, tempVar);
                vdsGroupCpuName = sc.getCpuName();
            }
        }
    }
    // If the host CPU name is not found by the CpuFlagsManagerHandler class, report an error
    if (architectureMatch) {
        List<String> missingFlags = cpuFlagsManagerHandler.missingServerCpuFlags(vdsGroupCpuName, getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
        if (!StringUtils.isEmpty(getVds().getCpuFlags()) && (!foundCPU || missingFlags != null)) {
            if (missingFlags != null) {
                addCustomValue("CpuFlags", StringUtils.join(missingFlags, ", "));
                if (missingFlags.contains("nx")) {
                    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
                    auditLogDirector.log(logable, AuditLogType.CPU_FLAGS_NX_IS_MISSING);
                }
            }
            SetNonOperationalVdsParameters tempVar2 = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.CPU_TYPE_INCOMPATIBLE_WITH_CLUSTER);
            runInternalAction(VdcActionType.SetNonOperationalVds, tempVar2, ExecutionHandler.createInternalJobContext(getContext()));
        } else {
            // if no need to change to non operational then don't log the command
            setCommandShouldBeLogged(false);
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    String vdsGroupCpuName = getVds().getVdsGroupCpuName();
    VDSGroup grp = DbFacade.getInstance().getVdsGroupDao().get(getVds().getVdsGroupId());
    ServerCpu sc = getCpuFlagsManagerHandler().findMaxServerCpuByFlags(getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
    if (sc == null) {
        // operational
        if (!StringUtils.isEmpty(getVds().getCpuFlags())) {
            foundCPU = false;
        } else {
            _hasFlags = false;
        }
        log.error("Could not find server cpu for server '{}' ({}), flags: '{}'", getVds().getName(), getVdsId(), getVds().getCpuFlags());
    }
    // Checks whether the host and the cluster have the same architecture
    if (_hasFlags && foundCPU) {
        if (grp.getArchitecture() != ArchitectureType.undefined && sc.getArchitecture() != grp.getArchitecture()) {
            architectureMatch = false;
            addCustomValue("VdsArchitecture", sc.getArchitecture().name());
            addCustomValue("VdsGroupArchitecture", grp.getArchitecture().name());
            SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.ARCHITECTURE_INCOMPATIBLE_WITH_CLUSTER);
            runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext(getContext()));
        } else {
            // if cluster doesn't have cpu then get the cpu from the vds
            if (StringUtils.isEmpty(vdsGroupCpuName)) {
                // update group with the cpu name
                grp.setCpuName(sc.getCpuName());
                grp.setArchitecture(sc.getArchitecture());
                updateMigrateOnError(grp);
                // use suppress in order to update group even if action fails
                // (out of the transaction)
                ManagementNetworkOnClusterOperationParameters tempVar = new ManagementNetworkOnClusterOperationParameters(grp);
                tempVar.setTransactionScopeOption(TransactionScopeOption.Suppress);
                tempVar.setIsInternalCommand(true);
                runInternalAction(VdcActionType.UpdateVdsGroup, tempVar);
                vdsGroupCpuName = sc.getCpuName();
            }
        }
    }
    // If the host CPU name is not found by the CpuFlagsManagerHandler class, report an error
    if (architectureMatch) {
        List<String> missingFlags = getCpuFlagsManagerHandler().missingServerCpuFlags(vdsGroupCpuName, getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
        if (!StringUtils.isEmpty(getVds().getCpuFlags()) && (!foundCPU || missingFlags != null)) {
            if (missingFlags != null) {
                addCustomValue("CpuFlags", StringUtils.join(missingFlags, ", "));
                if (missingFlags.contains("nx")) {
                    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
                    auditLogDirector.log(logable, AuditLogType.CPU_FLAGS_NX_IS_MISSING);
                }
            }
            SetNonOperationalVdsParameters tempVar2 = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.CPU_TYPE_INCOMPATIBLE_WITH_CLUSTER);
            runInternalAction(VdcActionType.SetNonOperationalVds, tempVar2, ExecutionHandler.createInternalJobContext(getContext()));
        } else {
            // if no need to change to non operational then don't log the command
            setCommandShouldBeLogged(false);
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
protected ArchitectureType getArchitecture(VDSGroup group) {
    if (StringUtils.isNotEmpty(group.getCpuName())) {
        return cpuFlagsManagerHandler.getArchitectureByCpuName(group.getCpuName(), group.getCompatibilityVersion());
    }
    return group.getArchitecture();
}
#method_after
protected ArchitectureType getArchitecture(VDSGroup group) {
    if (StringUtils.isNotEmpty(group.getCpuName())) {
        return getCpuFlagsManagerHandler().getArchitectureByCpuName(group.getCpuName(), group.getCompatibilityVersion());
    }
    return group.getArchitecture();
}
#end_block

#method_before
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependecyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    initCpuFlagsManagerHandler();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    loadService(AutoStartVmsRunner.class);
    loadService(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependecyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    loadService(CpuFlagsManagerHandler.class);
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    loadService(AutoStartVmsRunner.class);
    loadService(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependecyInjector.getInstance().bind(DbFacade.class, dbFacade);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependecyInjector.getInstance().bind(DbFacade.class, dbFacade);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDao().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDao().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDao().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getCompatibilityVersion().compareTo(storagePool.getCompatibilityVersion()) < 0) {
                result = false;
                addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDao().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(EngineMessage.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(EngineMessage.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDao().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDao().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            if (!validate(new ClusterValidator(getDbFacade(), oldGroup).dataCenterVersionMismatch())) {
                result = false;
                addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDao().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(EngineMessage.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(EngineMessage.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    return result;
}
#end_block

#method_before
protected boolean checkIfCpusSameManufacture(VDSGroup group) {
    return cpuFlagsManagerHandler.checkIfCpusSameManufacture(group.getCpuName(), getVdsGroup().getCpuName(), getVdsGroup().getCompatibilityVersion());
}
#method_after
protected boolean checkIfCpusSameManufacture(VDSGroup group) {
    return getCpuFlagsManagerHandler().checkIfCpusSameManufacture(group.getCpuName(), getVdsGroup().getCpuName(), getVdsGroup().getCompatibilityVersion());
}
#end_block

#method_before
protected boolean checkIfCpusExist() {
    return cpuFlagsManagerHandler.checkIfCpusExist(getVdsGroup().getCpuName(), getVdsGroup().getCompatibilityVersion());
}
#method_after
protected boolean checkIfCpusExist() {
    return getCpuFlagsManagerHandler().checkIfCpusExist(getVdsGroup().getCpuName(), getVdsGroup().getCompatibilityVersion());
}
#end_block

#method_before
protected List<String> missingServerCpuFlags(VDS vds) {
    return cpuFlagsManagerHandler.missingServerCpuFlags(getVdsGroup().getCpuName(), vds.getCpuFlags(), getVdsGroup().getCompatibilityVersion());
}
#method_after
protected List<String> missingServerCpuFlags(VDS vds) {
    return getCpuFlagsManagerHandler().missingServerCpuFlags(getVdsGroup().getCpuName(), vds.getCpuFlags(), getVdsGroup().getCompatibilityVersion());
}
#end_block

#method_before
protected boolean isCpuUpdatable(VDSGroup cluster) {
    return cpuFlagsManagerHandler.isCpuUpdatable(cluster.getCpuName(), cluster.getCompatibilityVersion());
}
#method_after
protected boolean isCpuUpdatable(VDSGroup cluster) {
    return getCpuFlagsManagerHandler().isCpuUpdatable(cluster.getCpuName(), cluster.getCompatibilityVersion());
}
#end_block

#method_before
protected int compareCpuLevels(VDSGroup otherGroup) {
    return cpuFlagsManagerHandler.compareCpuLevels(getVdsGroup().getCpuName(), otherGroup.getCpuName(), otherGroup.getCompatibilityVersion());
}
#method_after
protected int compareCpuLevels(VDSGroup otherGroup) {
    return getCpuFlagsManagerHandler().compareCpuLevels(getVdsGroup().getCpuName(), otherGroup.getCpuName(), otherGroup.getCompatibilityVersion());
}
#end_block

#method_before
protected ArchitectureType getArchitecture() {
    if (StringUtils.isNotEmpty(getVdsGroup().getCpuName())) {
        return cpuFlagsManagerHandler.getArchitectureByCpuName(getVdsGroup().getCpuName(), getVdsGroup().getCompatibilityVersion());
    } else if (getVdsGroup().getArchitecture() == null) {
        return ArchitectureType.undefined;
    }
    return getVdsGroup().getArchitecture();
}
#method_after
protected ArchitectureType getArchitecture() {
    if (StringUtils.isNotEmpty(getVdsGroup().getCpuName())) {
        return getCpuFlagsManagerHandler().getArchitectureByCpuName(getVdsGroup().getCpuName(), getVdsGroup().getCompatibilityVersion());
    } else if (getVdsGroup().getArchitecture() == null) {
        return ArchitectureType.undefined;
    }
    return getVdsGroup().getArchitecture();
}
#end_block

#method_before
protected boolean validateClusterPolicy() {
    ClusterPolicy clusterPolicy = null;
    if (getVdsGroup().getClusterPolicyId() != null) {
        clusterPolicy = SchedulingManager.getInstance().getClusterPolicy(getVdsGroup().getClusterPolicyId());
    }
    if (clusterPolicy == null) {
        clusterPolicy = SchedulingManager.getInstance().getClusterPolicy(getVdsGroup().getClusterPolicyName());
        if (clusterPolicy == null) {
            return false;
        }
        getVdsGroup().setClusterPolicyId(clusterPolicy.getId());
    }
    Map<String, String> customPropertiesRegexMap = SchedulingManager.getInstance().getCustomPropertiesRegexMap(clusterPolicy);
    updateClusterPolicyProperties(getVdsGroup(), clusterPolicy, customPropertiesRegexMap);
    List<ValidationError> validationErrors = SimpleCustomPropertiesUtil.getInstance().validateProperties(customPropertiesRegexMap, getVdsGroup().getClusterPolicyProperties());
    if (!validationErrors.isEmpty()) {
        SimpleCustomPropertiesUtil.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    return true;
}
#method_after
protected boolean validateClusterPolicy() {
    ClusterPolicy clusterPolicy = null;
    if (getVdsGroup().getClusterPolicyId() != null) {
        clusterPolicy = schedulingManager.getClusterPolicy(getVdsGroup().getClusterPolicyId());
    }
    if (clusterPolicy == null) {
        clusterPolicy = schedulingManager.getClusterPolicy(getVdsGroup().getClusterPolicyName());
        if (clusterPolicy == null) {
            return false;
        }
        getVdsGroup().setClusterPolicyId(clusterPolicy.getId());
    }
    Map<String, String> customPropertiesRegexMap = schedulingManager.getCustomPropertiesRegexMap(clusterPolicy);
    updateClusterPolicyProperties(getVdsGroup(), clusterPolicy, customPropertiesRegexMap);
    List<ValidationError> validationErrors = SimpleCustomPropertiesUtil.getInstance().validateProperties(customPropertiesRegexMap, getVdsGroup().getClusterPolicyProperties());
    if (!validationErrors.isEmpty()) {
        SimpleCustomPropertiesUtil.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    return true;
}
#end_block

#method_before
public ValidationResult dataCenterVersionMismatch() {
    StoragePool dataCenter = getDataCenter();
    return ValidationResult.failWith(EngineMessage.VDS_GROUP_CANNOT_ADD_COMPATIBILITY_VERSION_WITH_LOWER_STORAGE_POOL).when(dataCenter != null && dataCenter.getCompatibilityVersion().compareTo(cluster.getCompatibilityVersion()) > 0);
}
#method_after
public ValidationResult dataCenterVersionMismatch() {
    StoragePool dataCenter = getDataCenter();
    return ValidationResult.failWith(EngineMessage.VDS_GROUP_CANNOT_ADD_COMPATIBILITY_VERSION_WITH_LOWER_STORAGE_POOL).when(dataCenter != null && (cluster.supportsVirtService() ? dataCenter.getCompatibilityVersion().compareTo(cluster.getCompatibilityVersion()) > 0 : false));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VDS host = getDbFacade().getVdsDao().get(getParameters().getId());
    ServerCpu sc = cpuFlagsManagerHandler.findMaxServerCpuByFlags(host.getCpuFlags(), host.getVdsGroupCompatibilityVersion());
    getQueryReturnValue().setReturnValue(sc == null ? ArchitectureType.undefined : sc.getArchitecture());
}
#method_after
@Override
protected void executeQueryCommand() {
    VDS host = getDbFacade().getVdsDao().get(getParameters().getId());
    ServerCpu sc = getCpuFlagsManagerHandler().findMaxServerCpuByFlags(host.getCpuFlags(), host.getVdsGroupCompatibilityVersion());
    getQueryReturnValue().setReturnValue(sc == null ? ArchitectureType.undefined : sc.getArchitecture());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<VM> vmsForCluster = getDbFacade().getInstance().getVmDao().getAllForVdsGroup(getParameters().getVdsGroupId());
    Map<String, String> highCpuVms = new HashMap<>();
    for (VM vm : vmsForCluster) {
        if (vm.getCustomCpuName() != null && !vm.getCustomCpuName().isEmpty()) {
            String vmCpuName = cpuFlagsManagerHandler.getCpuNameByCpuId(vm.getCustomCpuName(), cpuFlagsManagerHandler.getLatestDictionaryVersion());
            if (vmCpuName == null || cpuFlagsManagerHandler.compareCpuLevels(vmCpuName, getParameters().getNewCpuName(), cpuFlagsManagerHandler.getLatestDictionaryVersion()) > 0) {
                highCpuVms.put(vm.getName(), vm.getCustomCpuName());
            }
        }
    }
    getQueryReturnValue().setReturnValue(highCpuVms);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<VM> vmsForCluster = getDbFacade().getInstance().getVmDao().getAllForVdsGroup(getParameters().getVdsGroupId());
    Map<String, String> highCpuVms = new HashMap<>();
    for (VM vm : vmsForCluster) {
        if (vm.getCustomCpuName() != null && !vm.getCustomCpuName().isEmpty()) {
            String vmCpuName = getCpuFlagsManagerHandler().getCpuNameByCpuId(vm.getCustomCpuName(), getCpuFlagsManagerHandler().getLatestDictionaryVersion());
            if (vmCpuName == null || getCpuFlagsManagerHandler().compareCpuLevels(vmCpuName, getParameters().getNewCpuName(), getCpuFlagsManagerHandler().getLatestDictionaryVersion()) > 0) {
                highCpuVms.put(vm.getName(), vm.getCustomCpuName());
            }
        }
    }
    getQueryReturnValue().setReturnValue(highCpuVms);
}
#end_block

#method_before
@Test
public void versionDecreaseWithHost() {
    createCommandWithOlderVersion();
    setupCpu();
    VdsExist();
    canDoActionFailedWithReason(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
}
#method_after
@Test
public void versionDecreaseWithHost() {
    createCommandWithOlderVersion(true, false);
    setupCpu();
    VdsExist();
    canDoActionFailedWithReason(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
}
#end_block

#method_before
@Test
public void versionDecreaseNoHostsOrNetwork() {
    createCommandWithOlderVersion();
    setupCpu();
    StoragePoolDao storagePoolDao2 = Mockito.mock(StoragePoolDao.class);
    when(storagePoolDao2.get(any(Guid.class))).thenReturn(createStoragePoolLocalFS());
    doReturn(storagePoolDao2).when(cmd).getStoragePoolDao();
    assertTrue(cmd.canDoAction());
}
#method_after
@Test
public void versionDecreaseNoHostsOrNetwork() {
    createCommandWithOlderVersion(true, false);
    setupCpu();
    StoragePoolDao storagePoolDao2 = Mockito.mock(StoragePoolDao.class);
    when(storagePoolDao2.get(any(Guid.class))).thenReturn(createStoragePoolLocalFS());
    doReturn(storagePoolDao2).when(cmd).getStoragePoolDao();
    assertTrue(cmd.canDoAction());
}
#end_block

#method_before
@Test
public void versionDecreaseLowerVersionThanDC() {
    createCommandWithOlderVersion();
    StoragePoolDao storagePoolDao2 = Mockito.mock(StoragePoolDao.class);
    when(storagePoolDao2.get(any(Guid.class))).thenReturn(createStoragePoolLocalFSOldVersion());
    doReturn(storagePoolDao2).when(cmd).getStoragePoolDao();
    setupCpu();
    canDoActionFailedWithReason(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
}
#method_after
@Test
public void versionDecreaseLowerVersionThanDC() {
    createCommandWithOlderVersion(true, false);
    StoragePoolDao storagePoolDao2 = Mockito.mock(StoragePoolDao.class);
    when(storagePoolDao2.get(any(Guid.class))).thenReturn(createStoragePoolLocalFSOldVersion());
    doReturn(storagePoolDao2).when(cmd).getStoragePoolDao();
    doReturn(storagePoolDao2).when(dbFacadeMock).getStoragePoolDao();
    setupCpu();
    canDoActionFailedWithReason(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
}
#end_block

#method_before
private void createCommandWithOlderVersion() {
    createCommand(createVdsGroupWithOlderVersion());
}
#method_after
private void createCommandWithOlderVersion(boolean supportsVirtService, boolean supportsGlusterService) {
    createCommand(createVdsGroupWithOlderVersion(true, false));
}
#end_block

#method_before
private void createCommand(final VDSGroup group) {
    setValidCpuVersionMap();
    final ManagementNetworkOnClusterOperationParameters param;
    if (managementNetworkId == null) {
        param = new ManagementNetworkOnClusterOperationParameters(group);
    } else {
        param = new ManagementNetworkOnClusterOperationParameters(group, managementNetworkId);
    }
    SimpleDependecyInjector.getInstance().bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    cmd = spy(new UpdateVdsGroupCommand<>(param));
    doReturn(0).when(cmd).compareCpuLevels(any(VDSGroup.class));
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(storagePoolDao).when(cmd).getStoragePoolDao();
    doReturn(glusterVolumeDao).when(cmd).getGlusterVolumeDao();
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(networkDao).when(cmd).getNetworkDao();
    doReturn(defaultManagementNetworkFinder).when(cmd).getDefaultManagementNetworkFinder();
    doReturn(clusterFeatureDao).when(cmd).getClusterFeatureDao();
    doReturn(hostFeatureDao).when(cmd).getHostFeatureDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).validateClusterPolicy();
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(vdsGroupDao.get(any(Guid.class))).thenReturn(createDefaultVdsGroup());
    when(vdsGroupDao.getByName(anyString())).thenReturn(createDefaultVdsGroup());
    List<VDSGroup> vdsGroupList = new ArrayList<>();
    vdsGroupList.add(createDefaultVdsGroup());
    when(vdsGroupDao.getByName(anyString(), anyBoolean())).thenReturn(vdsGroupList);
}
#method_after
private void createCommand(final VDSGroup group) {
    setValidCpuVersionMap();
    final ManagementNetworkOnClusterOperationParameters param;
    if (managementNetworkId == null) {
        param = new ManagementNetworkOnClusterOperationParameters(group);
    } else {
        param = new ManagementNetworkOnClusterOperationParameters(group, managementNetworkId);
    }
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    cmd = spy(new UpdateVdsGroupCommand<>(param));
    doReturn(0).when(cmd).compareCpuLevels(any(VDSGroup.class));
    doReturn(cpuFlagsManagerHandler).when(cmd).getCpuFlagsManagerHandler();
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDao();
    doReturn(vdsGroupDao).when(dbFacadeMock).getVdsGroupDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(storagePoolDao).when(cmd).getStoragePoolDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(glusterVolumeDao).when(cmd).getGlusterVolumeDao();
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(networkDao).when(cmd).getNetworkDao();
    doReturn(defaultManagementNetworkFinder).when(cmd).getDefaultManagementNetworkFinder();
    doReturn(clusterFeatureDao).when(cmd).getClusterFeatureDao();
    doReturn(hostFeatureDao).when(cmd).getHostFeatureDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).validateClusterPolicy();
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(vdsGroupDao.get(any(Guid.class))).thenReturn(createDefaultVdsGroup());
    when(vdsGroupDao.getByName(anyString())).thenReturn(createDefaultVdsGroup());
    List<VDSGroup> vdsGroupList = new ArrayList<>();
    vdsGroupList.add(createDefaultVdsGroup());
    when(vdsGroupDao.getByName(anyString(), anyBoolean())).thenReturn(vdsGroupList);
}
#end_block

#method_before
private static VDSGroup createVdsGroupWithOlderVersion() {
    VDSGroup group = createNewVdsGroup();
    group.setCompatibilityVersion(VERSION_1_0);
    group.setStoragePoolId(DC_ID1);
    return group;
}
#method_after
private static VDSGroup createVdsGroupWithOlderVersion(boolean supportsVirtService, boolean supportsGlusterService) {
    VDSGroup group = createNewVdsGroup();
    group.setCompatibilityVersion(VERSION_1_0);
    group.setStoragePoolId(DC_ID1);
    group.setVirtService(supportsVirtService);
    group.setGlusterService(supportsGlusterService);
    return group;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(EngineMessage.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(EngineMessage.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(EngineMessage.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(cpuFlagsManagerHandler.findMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getCompatibilityVersion()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (getTargetCluster().supportsVirtService() && !StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(EngineMessage.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (!isDetachedSourceCluster() && !isSameManagementNetwork()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MANAGEMENT_NETWORK_CANNOT_BE_CHANGED);
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getCompatibilityVersion()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getCompatibilityVersion())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (FeatureSupported.networkCustomProperties(getSourceCluster().getCompatibilityVersion()) && !FeatureSupported.networkCustomProperties(getTargetCluster().getCompatibilityVersion())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.hasCustomProperties()) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(EngineMessage.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(EngineMessage.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(EngineMessage.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(getCpuFlagsManagerHandler().findMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getCompatibilityVersion()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (getTargetCluster().supportsVirtService() && !StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(EngineMessage.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (!isDetachedSourceCluster() && !isSameManagementNetwork()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MANAGEMENT_NETWORK_CANNOT_BE_CHANGED);
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getCompatibilityVersion()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getCompatibilityVersion())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (FeatureSupported.networkCustomProperties(getSourceCluster().getCompatibilityVersion()) && !FeatureSupported.networkCustomProperties(getTargetCluster().getCompatibilityVersion())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.hasCustomProperties()) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            // remove the server from resource manager and add it back
            initializeVds();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDao().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    if (targetClusterSupportsSetupNetworks()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            // remove the server from resource manager and add it back
            initializeVds();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDao().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    List<Network> clusterNetworks = networkDao.getAllForCluster(getTargetCluster().getId());
    HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, getVdsId(), interfaceDao.getAllInterfacesForVds(getVdsId()), Collections.<NetworkAttachment>emptyList(), clusterNetworks);
    persister.persistNetworkAttachments();
    if (targetClusterSupportsSetupNetworks()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#end_block

#method_before
private List<VDS> searchVDSsByDb() {
    return genericSearch(getDbFacade().getVdsDao(), true, new Filter<VDS>() {

        @Override
        public List<VDS> filter(List<VDS> data) {
            for (VDS vds : data) {
                vds.setCpuName(cpuFlagsManagerHandler.findMaxServerCpuByFlags(vds.getCpuFlags(), vds.getVdsGroupCompatibilityVersion()));
            }
            return data;
        }
    });
}
#method_after
private List<VDS> searchVDSsByDb() {
    return genericSearch(getDbFacade().getVdsDao(), true, new Filter<VDS>() {

        @Override
        public List<VDS> filter(List<VDS> data) {
            for (VDS vds : data) {
                vds.setCpuName(getCpuFlagsManagerHandler().findMaxServerCpuByFlags(vds.getCpuFlags(), vds.getVdsGroupCompatibilityVersion()));
            }
            return data;
        }
    });
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(cpuFlagsManagerHandler.getCpuId(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine((getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getVdsGroup().getEmulatedMachine()));
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine((getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getVdsGroup().getEmulatedMachine()));
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = schedulingManager.schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(cpuFlagsManagerHandler.getSupportedServerCpuList(cpuFlagsManagerHandler.getLatestDictionaryVersion(), getParameters().getMaxCpuName()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getCpuFlagsManagerHandler().getSupportedServerCpuList(getCpuFlagsManagerHandler().getLatestDictionaryVersion(), getParameters().getMaxCpuName()));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VM vm = getDbFacade().getVmDao().get(getParameters().getId());
    Provider<?> provider = getHostProvider(vm);
    if (vm == null) {
        failWith(EngineMessage.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        return;
    }
    if (provider == null) {
        failWith(EngineMessage.NO_FOREMAN_PROVIDER_FOR_ENGINE);
        return;
    }
    HostProviderProxy proxy = getHostProviderProxy(provider);
    // vm.getVmHost() == vm's hostname
    List<Erratum> errata = proxy.getErrataForHost(vm.getVmHost());
    ErrataCounts stats = new ErrataCounts();
    for (Erratum erratum : errata) {
        stats.addToCounts(erratum);
    }
    setReturnValue(stats);
}
#method_after
@Override
protected void executeQueryCommand() {
    VM vm = vmDao.get(getParameters().getId());
    Provider<?> provider = getHostProvider(vm);
    if (vm == null) {
        failWith(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return;
    }
    if (provider == null) {
        failWith(EngineMessage.NO_FOREMAN_PROVIDER_FOR_VM);
        return;
    }
    HostProviderProxy proxy = getHostProviderProxy(provider);
    // vm.getVmHost() == vm's hostname
    List<Erratum> errata = proxy.getErrataForHost(vm.getVmHost());
    ErrataCounts stats = new ErrataCounts();
    for (Erratum erratum : errata) {
        stats.addToCounts(erratum);
    }
    setReturnValue(stats);
}
#end_block

#method_before
private Provider<?> getHostProvider(VM vm) {
    return vm.getProviderId() == null ? null : getDbFacade().getProviderDao().get(vm.getProviderId());
}
#method_after
private Provider<?> getHostProvider(VM vm) {
    return vm.getProviderId() == null ? null : providerDao.get(vm.getProviderId());
}
#end_block

#method_before
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryType, parameters, isPublic, false, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    // translate error enums to text
                    result.setExceptionString(getAppErrorsTranslator().translateErrorTextSingle(result.getExceptionString()));
                    // $NON-NLS-1$ //$NON-NLS-2$
                    logger.log(Level.WARNING, "Failure while invoking runQuery [" + result.getExceptionString() + "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        // getEventsHandler().runQueryFailed(failedResult); // TODO why is this commented out?
                        handleNotLoggedInEvent(result.getExceptionString());
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                fireAsyncQuerySucceededEvent(callback.getModel());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                fireAsyncQueryFailedEvent(callback.getModel());
            }
        }
    });
    // raise the query started event.
    fireAsyncOperationStartedEvent(callback.getModel());
    if (isPublic) {
        getOperationManager().addPublicOperation(operation);
    } else {
        getOperationManager().addOperation(operation);
    }
}
#method_after
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryType, parameters, isPublic, false, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    // translate error enums to text
                    result.setExceptionMessage(getAppErrorsTranslator().translateErrorTextSingle(result.getExceptionString()));
                    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
                    logger.log(Level.WARNING, "Failure while invoking runQuery [" + result.getExceptionString() + ", " + result.getExceptionMessage() + "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        handleNotLoggedInEvent(result.getExceptionString());
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                fireAsyncQuerySucceededEvent(callback.getModel());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                fireAsyncQueryFailedEvent(callback.getModel());
            }
        }
    });
    // raise the query started event.
    fireAsyncOperationStartedEvent(callback.getModel());
    if (isPublic) {
        getOperationManager().addPublicOperation(operation);
    } else {
        getOperationManager().addOperation(operation);
    }
}
#end_block

#method_before
private void attachNetwork(Guid clusterId, NetworkCluster networkCluster, Network network) {
    getNetworkClusterDao().save(new NetworkCluster(clusterId, network.getId(), NetworkStatus.OPERATIONAL, false, networkCluster.isRequired(), false, false, false));
    List<VDS> hosts = getVdsDao().getAllForVdsGroup(clusterId);
    List<Network> clusterNetworks = networkDao.getAllForCluster(clusterId);
    for (VDS host : hosts) {
        HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, host.getId(), interfaceDao.getAllInterfacesForVds(host.getId()), Collections.<NetworkAttachment>emptyList(), clusterNetworks);
        persister.persistNetworkAttachments();
    }
    if (network.getCluster().isDisplay()) {
        final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDao(), getVmDao(), networkCluster, network.getName(), auditLogDirector);
        if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
            displayNetworkClusterHelper.warnOnActiveVm();
        }
        getNetworkClusterDao().setNetworkExclusivelyAsDisplay(clusterId, network.getId());
    }
    if (network.getCluster().isMigration()) {
        getNetworkClusterDao().setNetworkExclusivelyAsMigration(clusterId, network.getId());
    }
    NetworkClusterHelper.setStatus(clusterId, network);
}
#method_after
private void attachNetwork(Guid clusterId, NetworkCluster networkCluster, Network network) {
    getNetworkClusterDao().save(new NetworkCluster(clusterId, network.getId(), NetworkStatus.OPERATIONAL, false, networkCluster.isRequired(), false, false, false));
    List<VDS> hosts = vdsDao.getAllForVdsGroup(clusterId);
    List<Network> clusterNetworks = networkDao.getAllForCluster(clusterId);
    for (VDS host : hosts) {
        HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, host.getId(), interfaceDao.getAllInterfacesForVds(host.getId()), Collections.<NetworkAttachment>emptyList(), clusterNetworks);
        persister.persistNetworkAttachments();
    }
    if (network.getCluster().isDisplay()) {
        final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDao(), getVmDao(), networkCluster, network.getName(), auditLogDirector);
        if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
            displayNetworkClusterHelper.warnOnActiveVm();
        }
        getNetworkClusterDao().setNetworkExclusivelyAsDisplay(clusterId, network.getId());
    }
    if (network.getCluster().isMigration()) {
        getNetworkClusterDao().setNetworkExclusivelyAsMigration(clusterId, network.getId());
    }
    NetworkClusterHelper.setStatus(clusterId, network);
}
#end_block

#method_before
private void updateDB(ExternalSchedulerDiscoveryResult discoveryResult) {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    List<PolicyUnit> foundInBoth = new LinkedList<>();
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getFilters()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.FILTER);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getScores()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.WEIGHT);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getBalance()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.LOAD_BALANCING);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    allPolicyUnits.removeAll(foundInBoth);
    // found in the db but not found in discovery, mark as such
    markExternalPoliciesAsDisabled(allPolicyUnits);
}
#method_after
private void updateDB(ExternalSchedulerDiscoveryResult discoveryResult) {
    List<PolicyUnit> allPolicyUnits = policyUnitDao.getAll();
    List<PolicyUnit> foundInBoth = new LinkedList<>();
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getFilters()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.FILTER);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getScores()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.WEIGHT);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getBalance()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.LOAD_BALANCING);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    allPolicyUnits.removeAll(foundInBoth);
    // found in the db but not found in discovery, mark as such
    markExternalPoliciesAsDisabled(allPolicyUnits);
}
#end_block

#method_before
private void markExternalPoliciesAsDisabled(List<PolicyUnit> units) {
    for (PolicyUnit policyUnit : units) {
        if (!policyUnit.isInternal()) {
            policyUnit.setEnabled(false);
            getPolicyUnitDao().update(policyUnit);
        }
    }
}
#method_after
private void markExternalPoliciesAsDisabled(List<PolicyUnit> units) {
    for (PolicyUnit policyUnit : units) {
        if (!policyUnit.isInternal()) {
            policyUnit.setEnabled(false);
            policyUnitDao.update(policyUnit);
        }
    }
}
#end_block

#method_before
public void markAllExternalPoliciesAsDisabled() {
    markExternalPoliciesAsDisabled(getPolicyUnitDao().getAll());
}
#method_after
public void markAllExternalPoliciesAsDisabled() {
    markExternalPoliciesAsDisabled(policyUnitDao.getAll());
}
#end_block

#method_before
private void sendToDb(ExternalSchedulerDiscoveryUnit discovery, Guid policyUnitId, PolicyUnitType type) {
    PolicyUnit policy = createFromDiscoveryUnit(discovery, type);
    if (policyUnitId != null) {
        policy.setId(policyUnitId);
        getPolicyUnitDao().update(policy);
    } else {
        policy.setId(Guid.newGuid());
        getPolicyUnitDao().save(policy);
    }
}
#method_after
private void sendToDb(ExternalSchedulerDiscoveryUnit discovery, Guid policyUnitId, PolicyUnitType type) {
    PolicyUnit policy = createFromDiscoveryUnit(discovery, type);
    if (policyUnitId != null) {
        policy.setId(policyUnitId);
        policyUnitDao.update(policy);
    } else {
        policy.setId(Guid.newGuid());
        policyUnitDao.save(policy);
    }
}
#end_block

#method_before
@Override
public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
    parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
    Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
}
#method_after
@Override
public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
    parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
    backendInternal.runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
private SchedulingManager mockScheduler() {
    SchedulingManager mock = Mockito.mock(SchedulingManager.class);
    Mockito.when(mock.getClusterPolicies()).thenReturn(Collections.<ClusterPolicy>emptyList());
    return mock;
}
#method_after
private SchedulingManager mockScheduler() {
    SchedulingManager mock = mock(SchedulingManager.class);
    when(mock.getClusterPolicies()).thenReturn(Collections.<ClusterPolicy>emptyList());
    return mock;
}
#end_block

#method_before
protected VdsDao getVdsDao() {
    return DbFacade.getInstance().getVdsDao();
}
#method_after
protected VdsDao getVdsDao() {
    return dbFacade.getVdsDao();
}
#end_block

#method_before
protected VdsGroupDao getVdsGroupDao() {
    return DbFacade.getInstance().getVdsGroupDao();
}
#method_after
protected VdsGroupDao getVdsGroupDao() {
    return dbFacade.getVdsGroupDao();
}
#end_block

#method_before
protected VdsDynamicDao getVdsDynamicDao() {
    return DbFacade.getInstance().getVdsDynamicDao();
}
#method_after
protected VdsDynamicDao getVdsDynamicDao() {
    return dbFacade.getVdsDynamicDao();
}
#end_block

#method_before
protected PolicyUnitDao getPolicyUnitDao() {
    return DbFacade.getInstance().getPolicyUnitDao();
}
#method_after
protected PolicyUnitDao getPolicyUnitDao() {
    return dbFacade.getPolicyUnitDao();
}
#end_block

#method_before
protected ClusterPolicyDao getClusterPolicyDao() {
    return DbFacade.getInstance().getClusterPolicyDao();
}
#method_after
protected ClusterPolicyDao getClusterPolicyDao() {
    return dbFacade.getClusterPolicyDao();
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling(getPendingResourceManager());
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION, auditLogDirector);
                    log.info("Cluster '{}' fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN, auditLogDirector);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling(getPendingResourceManager());
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION, auditLogDirector);
                    log.info("Cluster '{}' fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN, auditLogDirector);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
@OnTimerMethodAnnotation("performLoadBalancing")
public void performLoadBalancing() {
    log.debug("Load Balancer timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    for (VDSGroup cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Pair<List<Guid>, Guid> balanceResult = null;
        if (policyUnit.getPolicyUnit().isEnabled()) {
            List<VDS> hosts = getVdsDao().getAllForVdsGroupWithoutMigrating(cluster.getId());
            if (policyUnit.getPolicyUnit().isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult != null && balanceResult.getSecond() != null) {
            migrationHandler.migrateVM(balanceResult.getFirst(), balanceResult.getSecond());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("performLoadBalancing")
public void performLoadBalancing() {
    log.debug("Load Balancer timer entered.");
    List<VDSGroup> clusters = getVdsGroupDao().getAll();
    for (VDSGroup cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Pair<List<Guid>, Guid> balanceResult = null;
        if (policyUnit.getPolicyUnit().isEnabled()) {
            List<VDS> hosts = getVdsDao().getAllForVdsGroupWithoutMigrating(cluster.getId());
            if (policyUnit.getPolicyUnit().isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult != null && balanceResult.getSecond() != null) {
            migrationHandler.migrateVM(balanceResult.getFirst(), balanceResult.getSecond());
        }
    }
}
#end_block

#method_before
protected ValidationResult hasSpaceForSnapshots() {
    Set<Guid> sdIds = ImagesHandler.getAllStorageIdsForImageIds(getVmImageDisks());
    MultipleStorageDomainsValidator msdValidator = getStorageDomainsValidator(sdIds);
    ValidationResult retVal = msdValidator.allDomainsWithinThresholds();
    if (retVal == ValidationResult.VALID) {
        return msdValidator.allDomainsHaveSpaceForNewDisks(getVmImageDisks());
    }
    return retVal;
}
#method_after
protected ValidationResult hasSpaceForSnapshots() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
    List<DiskImage> allDisks = ImagesHandler.filterImageDisks(disks, false, true, false);
    Set<Guid> sdIds = ImagesHandler.getAllStorageIdsForImageIds(allDisks);
    MultipleStorageDomainsValidator msdValidator = getStorageDomainsValidator(sdIds);
    ValidationResult retVal = msdValidator.allDomainsWithinThresholds();
    if (retVal == ValidationResult.VALID) {
        return msdValidator.allDomainsHaveSpaceForNewDisks(allDisks);
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(vdsGroupDAO.getClustersByClusterPolicyId(getParameters().getId()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(vdsGroupDao.getClustersByClusterPolicyId(getParameters().getId()));
}
#end_block

#method_before
@Test
public void testMd5Hash() throws Exception {
    String fingerprint1 = "1b:d3:aa:c3:67:4b:b5:55:a9:ff:19:0c:16:7e:d1:de";
    String goodfingerprint1 = "MD5:1b:d3:aa:c3:67:4b:b5:55:a9:ff:19:0c:16:7e:d1:de";
    assertEquals(goodfingerprint1, OpenSSHUtils.fixupKeyFingerprintHash(fingerprint1));
    assertEquals(goodfingerprint1, OpenSSHUtils.fixupKeyFingerprintHash(goodfingerprint1));
}
#method_after
@Test
public void testMd5Hash() throws Exception {
    String fingerprint1 = "1b:d3:aa:c3:67:4b:b5:55:a9:ff:19:0c:16:7e:d1:de";
    String goodfingerprint1 = "MD5:" + fingerprint1;
    assertEquals(goodfingerprint1, OpenSSHUtils.fixupKeyFingerprintHash(fingerprint1));
    assertEquals(goodfingerprint1, OpenSSHUtils.fixupKeyFingerprintHash(goodfingerprint1));
}
#end_block

#method_before
public ValidationResult networkIsSet() {
    return ValidationResult.failWith(EngineMessage.NETWORK_NOT_EXISTS).when(network == null);
}
#method_after
public ValidationResult networkIsSet() {
    // TODO MM: already used elsewhere, how to fix?
    return ValidationResult.failWith(EngineMessage.NETWORK_NOT_EXISTS).when(network == null);
}
#end_block

#method_before
protected List<VM> getVms() {
    if (vms == null) {
        vms = getDbFacade().getVmDao().getAllForNetwork(network.getId());
    }
    return vms;
}
#method_after
protected List<VM> getVms() {
    if (vms == null) {
        vms = getVmDao().getAllForNetwork(network.getId());
    }
    return vms;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged() && allowedNetworkLabelManipulation()) {
        return true;
    }
    final NetworkValidator validatorNew = new NetworkValidator(getNetwork());
    final UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork(), vdsDao, new VmInterfaceManager());
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notChangingDataCenterId(getNetwork().getDataCenterId())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && validate(validatorOld.notRenamingLabel(getNetwork().getLabel())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged() && allowedNetworkLabelManipulation()) {
        return true;
    }
    final NetworkValidator validatorNew = new NetworkValidator(vmDao, getNetwork());
    final UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork(), vmNetworkInterfaceDao, vdsGroupDao, vmDao);
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notChangingDataCenterId(getNetwork().getDataCenterId())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && validate(validatorOld.notRenamingLabel(getNetwork().getLabel())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#end_block

#method_before
public ValidationResult networkNotUsedByRunningVms() {
    final List<String> runningVmNames = new ArrayList<>();
    final List<VDS> hostsForNetwork = vdsDao.getAllForNetwork(network.getId());
    for (VDS host : hostsForNetwork) {
        final Version maxSupportedVersion = Collections.max(host.getSupportedClusterVersionsSet());
        if (!FeatureSupported.changeNetworkUnderBridgeInUseSupported(maxSupportedVersion)) {
            final List<String> activeVmsUsingNetworkOnHost = vmInterfaceManager.findActiveVmsUsingNetworks(host.getId(), Collections.singleton(network.getName()));
            runningVmNames.addAll(activeVmsUsingNetworkOnHost);
        }
    }
    return networkNotUsed(runningVmNames, EngineMessage.VAR__ENTITIES__VMS, EngineMessage.VAR__ENTITIES__VM);
}
#method_after
public ValidationResult networkNotUsedByRunningVms() {
    List<VM> runningVms = new ArrayList<>();
    List<VmNetworkInterface> vnics = vmNetworkInterfaceDao.getAllForNetwork(network.getId());
    Map<Guid, List<VmNetworkInterface>> vnicsByVmId = Entities.vmInterfacesByVmId(vnics);
    for (VM vm : getVms()) {
        if (vm.isRunningOrPaused()) {
            for (VmNetworkInterface nic : vnicsByVmId.get(vm.getId())) {
                if (VmNetworkCanBeUpdatedPredicate.getInstance().eval(nic)) {
                    runningVms.add(vm);
                    break;
                }
            }
        }
    }
    final List<VM> runningVmNotSupportNetworkChange = LinqUtils.filter(runningVms, new Predicate<VM>() {

        final Map<Guid, Version> clusterVersions = new HashMap<>();

        @Override
        public boolean eval(VM vm) {
            final Guid clusterId = vm.getVdsGroupId();
            Version clusterVersion = clusterVersions.get(clusterId);
            if (clusterVersion == null) {
                final VDSGroup cluster = vdsGroupDao.get(clusterId);
                clusterVersion = cluster.getCompatibilityVersion();
                clusterVersions.put(clusterId, clusterVersion);
            }
            return !FeatureSupported.changeNetworkUsedByVmSupported(clusterVersion);
        }
    });
    return networkNotUsed(runningVmNotSupportNetworkChange, EngineMessage.VAR__ENTITIES__VMS, EngineMessage.VAR__ENTITIES__VM);
}
#end_block

#method_before
@Before
public void setup() {
    validator = spy(new UpdateNetworkValidator(network, vdsDao, vmInterfaceManager));
}
#method_after
@Before
public void setup() {
    mockConfigRule.mockConfigValue(ConfigValues.ChangeNetworkUnderBridgeInUseSupported, Version.v3_5, false);
    mockConfigRule.mockConfigValue(ConfigValues.ChangeNetworkUnderBridgeInUseSupported, Version.v3_6, true);
    validator = new UpdateNetworkValidator(network, vmNetworkInterfaceDao, vdsGroupDao, vmDao);
}
#end_block

#method_before
private ValidationResult validateStatus(VDSStatus hostStatus) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL).unless(hostStatus == host.getStatus());
}
#method_after
private ValidationResult validateStatus(VDSStatus hostStatus) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL, ReplacementUtils.createSetVariableString("hostStatus", hostStatus.name())).unless(hostStatus == host.getStatus());
}
#end_block

#method_before
public ValidationResult validateStatusForEnrollCertificate() {
    return ValidationResult.failWith(EngineMessage.CANNOT_ENROLL_CERTIFICATE_HOST_STATUS_ILLEGAL).unless(host.getStatus() == VDSStatus.Maintenance);
}
#method_after
public ValidationResult validateStatusForEnrollCertificate() {
    return ValidationResult.failWith(EngineMessage.CANNOT_ENROLL_CERTIFICATE_HOST_STATUS_ILLEGAL).unless(host.getStatus() == VDSStatus.Maintenance || host.getStatus() == VDSStatus.InstallFailed);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            setVdsStatus(VDSStatus.Installing);
            try (final VdsMgmtPackages hostManager = new VdsMgmtPackages(getVds(), false)) {
                String correlationId = CorrelationIdTracker.getCorrelationId();
                if (StringUtils.isEmpty(correlationId)) {
                    correlationId = LoggedUtils.getObjectId(getVds());
                }
                hostManager.setCorrelationId(correlationId);
                hostManager.useDefaultKeyPair();
                hostManager.setCertificateEnrollment(true);
                hostManager.execute();
                logEvent(AuditLogType.HOST_CERTIFICATION_ENROLLMENT);
            } catch (final Exception e) {
                log.error("Failed to enroll certificate for host '{}': {}", getVds().getName(), e.getMessage());
                log.error("Exception", e);
                logEvent(AuditLogType.HOST_CERTIFICATION_ENROLLMENT_FAILED);
            } finally {
                setVdsStatus(VDSStatus.Maintenance);
            }
        }

        private void logEvent(AuditLogType eventType) {
            AuditLogableBase event = new AuditLogableBase();
            event.setVds(getVds());
            event.setUserName(getUserName());
            auditLogDirector.log(event, eventType);
        }
    });
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.HostEnrollCertificateInternal, getParameters(), cloneContextAndDetachFromParent());
    setSucceeded(true);
}
#end_block

#method_before
private void removeDeletedVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getId())) {
            idsToRemove.add(volume.getId());
            log.debug("Volume '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getVolumeDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing volumes from database!", e);
        }
    }
}
#method_after
private void removeDeletedVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getId())) {
            idsToRemove.add(volume.getId());
            log.debug("Volume '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
            // Set the gluster cli schedule enabled flag back to true
            if (Config.<String>getValue(ConfigValues.GlusterMetaVolumeName).equalsIgnoreCase(volume.getName())) {
                VDSGroup cluster = getClusterDao().get(clusterId);
                cluster.setGlusterCliBasedSchedulingOn(true);
                getClusterDao().update(cluster);
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getVolumeDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing volumes from database!", e);
        }
    }
}
#end_block

#method_before
private void disableCliSnapshotSchedulingFlag(VDSGroup cluster, GlusterVolumeEntity volume) {
    if (getGlusterUtil().isGlusterSnapshotSupported(cluster.getCompatibilityVersion(), cluster.getId()) && (Config.<String>getValue(ConfigValues.GlusterMetaVolumeName)).equalsIgnoreCase(volume.getName())) {
        VdcReturnValueBase returnValue = backend.runInternalAction(VdcActionType.DisableGlusterCliSnapshotScheduleInternal, new GlusterVolumeActionParameters(volume.getId(), false), ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.warn("Unbale to set volume snapshot scheduling flag to gluster CLI scheduler on cluster {}", cluster.getName());
        } else {
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_CLI_SNAPSHOT_SCHEDULE_DISABLED);
        }
    }
}
#method_after
private void disableCliSnapshotSchedulingFlag(VDSGroup cluster, GlusterVolumeEntity volume) {
    if (getGlusterUtil().isGlusterSnapshotSupported(cluster.getCompatibilityVersion(), cluster.getId()) && cluster.isGlusterCliBasedSchedulingOn() && (Config.<String>getValue(ConfigValues.GlusterMetaVolumeName)).equalsIgnoreCase(volume.getName())) {
        VdcReturnValueBase returnValue = backend.runInternalAction(VdcActionType.DisableGlusterCliSnapshotScheduleInternal, new GlusterVolumeActionParameters(volume.getId(), false), ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.warn("Unbale to set volume snapshot scheduling flag to gluster CLI scheduler on cluster {}", cluster.getName());
        } else {
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_CLI_SNAPSHOT_SCHEDULE_DISABLED);
        }
    }
}
#end_block

#method_before
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debug("Refreshing brick statuses for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshVolumeDetails(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            } finally {
                releaseLock(cluster.getId());
            }
            // While adding the volume to engine, the meta volume might not have been started and mounted at
            // required path, so explicitly invoke setting of the flag as part of volume data sync as well
            disableCliSnapshotSchedulingFlag(cluster, volume);
        }
    }
}
#method_after
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debug("Refreshing brick statuses for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshVolumeDetails(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#end_block

#method_before
private void loadDcNetworks(final Guid dataCenterId) {
    if (dataCenterId == null) {
        return;
    }
    final AsyncQuery getAllDataCenterNetworksQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final ClusterModel clusterModel = (ClusterModel) model;
            final List<Network> dcNetworks = (List<Network>) returnValue;
            clusterModel.getManagementNetwork().setItems(dcNetworks);
            if (defaultManagementNetworkCache.containsKey(dataCenterId)) {
                final Network defaultManagementNetwork = defaultManagementNetworkCache.get(dataCenterId);
                setSelectedDefaultManagementNetwork(clusterModel, defaultManagementNetwork);
            } else {
                final AsyncQuery getDefaultManagementNetworkQuery = new AsyncQuery(clusterModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        final Network defaultManagementNetwork = (Network) returnValue;
                        defaultManagementNetworkCache.put(dataCenterId, defaultManagementNetwork);
                        setSelectedDefaultManagementNetwork(clusterModel, defaultManagementNetwork);
                    }
                });
                AsyncDataProvider.getInstance().getDefaultManagementNetwork(getDefaultManagementNetworkQuery, dataCenterId);
            }
        }

        private void setSelectedDefaultManagementNetwork(ClusterModel clusterModel, Network defaultManagementNetwork) {
            if (defaultManagementNetwork != null) {
                clusterModel.getManagementNetwork().setSelectedItem(defaultManagementNetwork);
            }
        }
    });
    AsyncDataProvider.getInstance().getManagementNetworkCandidates(getAllDataCenterNetworksQuery, dataCenterId);
}
#method_after
private void loadDcNetworks(final Guid dataCenterId) {
    if (dataCenterId == null) {
        return;
    }
    final AsyncQuery getAllDataCenterNetworksQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final ClusterModel clusterModel = (ClusterModel) model;
            if (clusterModel.getDataCenter().getSelectedItem() == null) {
                return;
            }
            final List<Network> dcNetworks = (List<Network>) returnValue;
            clusterModel.getManagementNetwork().setItems(dcNetworks);
            if (defaultManagementNetworkCache.containsKey(dataCenterId)) {
                final Network defaultManagementNetwork = defaultManagementNetworkCache.get(dataCenterId);
                setSelectedDefaultManagementNetwork(clusterModel, defaultManagementNetwork);
            } else {
                final AsyncQuery getDefaultManagementNetworkQuery = new AsyncQuery(clusterModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        final Network defaultManagementNetwork = (Network) returnValue;
                        defaultManagementNetworkCache.put(dataCenterId, defaultManagementNetwork);
                        setSelectedDefaultManagementNetwork(clusterModel, defaultManagementNetwork);
                    }
                });
                AsyncDataProvider.getInstance().getDefaultManagementNetwork(getDefaultManagementNetworkQuery, dataCenterId);
            }
        }

        private void setSelectedDefaultManagementNetwork(ClusterModel clusterModel, Network defaultManagementNetwork) {
            if (defaultManagementNetwork != null) {
                clusterModel.getManagementNetwork().setSelectedItem(defaultManagementNetwork);
            }
        }
    });
    AsyncDataProvider.getInstance().getManagementNetworkCandidates(getAllDataCenterNetworksQuery, dataCenterId);
}
#end_block

#method_before
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    final StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            Version selectedVersion = clusterModel.getVersion().getSelectedItem();
            clusterModel.getVersion().setItems(versions);
            if (selectedVersion == null || !versions.contains(selectedVersion) || selectedVersion.compareTo(selectedDataCenter.getCompatibilityVersion()) > 0) {
                if (ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly)) {
                    clusterModel.getVersion().setSelectedItem(Linq.selectHighestVersion(versions));
                } else {
                    clusterModel.getVersion().setSelectedItem(selectedDataCenter.getCompatibilityVersion());
                }
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.firstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getCompatibilityVersion())));
            } else {
                clusterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterVersions(_asyncQuery, ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly) ? null : selectedDataCenter.getId());
    if (getManagementNetwork().getIsChangable()) {
        loadDcNetworks(selectedDataCenter.getId());
    }
}
#method_after
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    final StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        getManagementNetwork().setItems(Collections.<Network>emptyList());
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            Version selectedVersion = clusterModel.getVersion().getSelectedItem();
            clusterModel.getVersion().setItems(versions);
            if (selectedVersion == null || !versions.contains(selectedVersion) || selectedVersion.compareTo(selectedDataCenter.getCompatibilityVersion()) > 0) {
                if (ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly)) {
                    clusterModel.getVersion().setSelectedItem(Linq.selectHighestVersion(versions));
                } else {
                    clusterModel.getVersion().setSelectedItem(selectedDataCenter.getCompatibilityVersion());
                }
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.firstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getCompatibilityVersion())));
            } else {
                clusterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterVersions(_asyncQuery, ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly) ? null : selectedDataCenter.getId());
    if (getManagementNetwork().getIsChangable()) {
        loadDcNetworks(selectedDataCenter.getId());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartGlusterVolume, new GlusterVolumeActionVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().isForceAction()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        GlusterDBUtils.getInstance().updateVolumeStatus(getParameters().getVolumeId(), GlusterStatus.UP);
        GlusterSyncJob.getInstance().refreshVolumeDetails(upServer, getGlusterVolume());
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_START_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartGlusterVolume, new GlusterVolumeActionVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().isForceAction()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        GlusterDBUtils.getInstance().updateVolumeStatus(getParameters().getVolumeId(), GlusterStatus.UP);
        /* Refresh volume details once the volume is started.
             * A specific requirement for this was user might create a volume for the sake of using it for geo-replication.
             * However, for suggesting volumes eligible for session creation, the size information of the volume is very important.
             * Having the user to wait for the sync job to sync the volume detail might not be appropriate.
             */
        GlusterSyncJob.getInstance().refreshVolumeDetails(upServer, getGlusterVolumeDao().getById(getParameters().getVolumeId()));
    /* GlusterSyncJob.getInstance().refreshVolumeDetails(upServer, getGlusterVolume());
             * will not suffice bcoz, getGlusterVolume fetches new volume only if its not yet been fetched from db and hence, refreshVolumeDetails figures out
             * that the info about volume-bricks are stale and hence attempts a update and correspondingly raises events for brick state change.
             * But here in the previous step we changed the volumes state(To GlusterStatus.UP) due to a successful execution of start command.
             * Hence fetch the volume afresh after the state change and use it to refresh volume details.
             */
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_START_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    VolumeStatus status = GlusterVolumeUtils.getVolumeStatus(volume);
    ImageResource statusImage = getStatusImage(status);
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    sb.append(templates.statusTemplate(statusImageHtml, id));
}
#method_after
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    VolumeStatus status = GlusterVolumeUtils.getVolumeStatus(volume);
    ImageResource statusImage = getStatusImage(status);
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    if (status == VolumeStatus.ALL_BRICKS_DOWN || status == VolumeStatus.SOME_BRICKS_DOWN) {
        SafeHtml alertImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.alertImage()).getHTML());
        sb.append(templates.statusWithAlertTemplate(statusImageHtml, alertImageHtml, id));
    } else {
        sb.append(templates.statusTemplate(statusImageHtml, id));
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("closeConfirmationWindow")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.equals(getNewGeoRepSessionCommand())) {
        getGeoRepListModel().getNewSessionCommand().execute();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    } else if (command.equals(getStartVolumeProfilingCommand()) || command.getName().equals("startProfiling")) {
        // $NON-NLS-1$
        startVolumeProfiling();
    } else if (command.equals(getStopVolumeProfilingCommand()) || command.getName().equals("stopProfiling")) {
        // $NON-NLS-1$
        stopVolumeProfiling();
    } else if (command.equals(getShowVolumeProfileDetailsCommand()) || command.getName().equals("showProfileDetails")) {
        // $NON-NLS-1$
        showVolumeProfiling();
    } else if (command.getName().equalsIgnoreCase("closeProfileStats")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equalsIgnoreCase("CancelOptimizeForVirtStore")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equalsIgnoreCase("ConfirmOptimiseForVirtStore")) {
        // $NON-NLS-1$
        List<GlusterVolumeEntity> selectedVolumes = new ArrayList<GlusterVolumeEntity>();
        for (Object selectedVolume : getSelectedItems()) {
            selectedVolumes.add((GlusterVolumeEntity) selectedVolume);
        }
        optimizeVolumesForVirtStore(selectedVolumes);
    } else if (command.equals(getConfigureClusterSnapshotOptionsCommand())) {
        configureClusterSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("confirmConfigureClusterSnapshotOptions")) {
        // $NON-NLS-1$
        confirmConfigureClusterSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("onConfigureClusterSnapshotOptions")) {
        // $NON-NLS-1$
        onConfigureClusterSnapshotOptions();
    } else if (command.equals(getConfigureVolumeSnapshotOptionsCommand())) {
        configureVolumeSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("confirmConfigureVolumeSnapshotOptions")) {
        // $NON-NLS-1$
        confirmConfigureVolumeSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("onConfigureVolumeSnapshotOptions")) {
        // $NON-NLS-1$
        onConfigureVolumeSnapshotOptions();
    } else if (command.equals(getCreateSnapshotCommand())) {
        getSnapshotListModel().getCreateSnapshotCommand().execute();
    } else if (command.equals(getEditSnapshotScheduleCommand())) {
        getSnapshotListModel().getEditSnapshotScheduleCommand().execute();
    } else if (command.getName().equals("startVolumeWithForceOption")) {
        // $NON-NLS-1$
        onStartVolumeWithForce();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("closeConfirmationWindow")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.equals(getNewGeoRepSessionCommand())) {
        getGeoRepListModel().getNewSessionCommand().execute();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    } else if (command.equals(getStartVolumeProfilingCommand()) || command.getName().equals("startProfiling")) {
        // $NON-NLS-1$
        startVolumeProfiling();
    } else if (command.equals(getStopVolumeProfilingCommand()) || command.getName().equals("stopProfiling")) {
        // $NON-NLS-1$
        stopVolumeProfiling();
    } else if (command.equals(getShowVolumeProfileDetailsCommand()) || command.getName().equals("showProfileDetails")) {
        // $NON-NLS-1$
        showVolumeProfiling();
    } else if (command.getName().equalsIgnoreCase("closeProfileStats")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equalsIgnoreCase("CancelOptimizeForVirtStore")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equalsIgnoreCase("ConfirmOptimiseForVirtStore")) {
        // $NON-NLS-1$
        List<GlusterVolumeEntity> selectedVolumes = new ArrayList<GlusterVolumeEntity>();
        for (Object selectedVolume : getSelectedItems()) {
            selectedVolumes.add((GlusterVolumeEntity) selectedVolume);
        }
        optimizeVolumesForVirtStore(selectedVolumes);
    } else if (command.equals(getConfigureClusterSnapshotOptionsCommand())) {
        configureClusterSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("confirmConfigureClusterSnapshotOptions")) {
        // $NON-NLS-1$
        confirmConfigureClusterSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("onConfigureClusterSnapshotOptions")) {
        // $NON-NLS-1$
        onConfigureClusterSnapshotOptions();
    } else if (command.equals(getConfigureVolumeSnapshotOptionsCommand())) {
        configureVolumeSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("confirmConfigureVolumeSnapshotOptions")) {
        // $NON-NLS-1$
        confirmConfigureVolumeSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("onConfigureVolumeSnapshotOptions")) {
        // $NON-NLS-1$
        onConfigureVolumeSnapshotOptions();
    } else if (command.equals(getCreateSnapshotCommand())) {
        getSnapshotListModel().getCreateSnapshotCommand().execute();
    } else if (command.equals(getEditSnapshotScheduleCommand())) {
        getSnapshotListModel().getEditSnapshotScheduleCommand().execute();
    } else if (command.getName().equals("startVolumeWithForceOption")) {
        // $NON-NLS-1$
        prepareForStartVolume(false);
    }
}
#end_block

#method_before
private void start() {
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> downList = new ArrayList<VdcActionParametersBase>();
    ArrayList<String> volumesForForceStartWarning = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        VolumeStatus status = GlusterVolumeUtils.getVolumeStatus(volume);
        if (status == VolumeStatus.DOWN) {
            downList.add(new GlusterVolumeActionParameters(volume.getId(), false));
        } else if (status == VolumeStatus.ALL_BRICKS_DOWN || status == VolumeStatus.SOME_BRICKS_DOWN) {
            volumesForForceStartWarning.add(volume.getName());
        }
    }
    if (!downList.isEmpty()) {
        onStartVolume(downList);
    }
    if (!volumesForForceStartWarning.isEmpty()) {
        ConfirmationModel cModel = new ConfirmationModel();
        cModel.setHelpTag(HelpTag.volume_start);
        // $NON-NLS-1$
        cModel.setHashName("volume_start");
        setConfirmWindow(cModel);
        cModel.setMessage(ConstantsManager.getInstance().getConstants().startForceVolumeMessage());
        cModel.setTitle(ConstantsManager.getInstance().getConstants().confirmStartVolume());
        cModel.setForceLabel(ConstantsManager.getInstance().getConstants().startForceLabel());
        cModel.setItems(volumesForForceStartWarning);
        cModel.getForce().setIsAvailable(true);
        // $NON-NLS-1$
        cModel.getCommands().add(UICommand.createDefaultOkUiCommand("startVolumeWithForceOption", this));
        // $NON-NLS-1$
        cModel.getCommands().add(UICommand.createCancelUiCommand("closeConfirmationWindow", this));
    }
}
#method_after
private void start() {
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> volumesForForceStartWarning = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        VolumeStatus status = GlusterVolumeUtils.getVolumeStatus(volume);
        if (status == VolumeStatus.ALL_BRICKS_DOWN || status == VolumeStatus.SOME_BRICKS_DOWN) {
            volumesForForceStartWarning.add(volume.getName());
        }
    }
    prepareForStartVolume(true);
    if (!volumesForForceStartWarning.isEmpty()) {
        final ConfirmationModel cModel = new ConfirmationModel();
        cModel.setHelpTag(HelpTag.volume_start);
        // $NON-NLS-1$
        cModel.setHashName("volume_start");
        setConfirmWindow(cModel);
        cModel.setMessage(ConstantsManager.getInstance().getConstants().startForceVolumeMessage());
        cModel.setTitle(ConstantsManager.getInstance().getConstants().confirmStartVolume());
        cModel.setForceLabel(ConstantsManager.getInstance().getConstants().startForceLabel());
        cModel.setItems(volumesForForceStartWarning);
        cModel.getForce().setIsAvailable(true);
        cModel.getForce().setEntity(true);
        cModel.getForce().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                if (cModel.getCommands() != null && cModel.getCommands().get(0) != null) {
                    cModel.getCommands().get(0).setIsExecutionAllowed(cModel.getForce().getEntity());
                }
            }
        });
        // $NON-NLS-1$
        cModel.getCommands().add(UICommand.createDefaultOkUiCommand("startVolumeWithForceOption", this));
        // $NON-NLS-1$
        cModel.getCommands().add(UICommand.createCancelUiCommand("closeConfirmationWindow", this));
    }
}
#end_block

#method_before
@Override
protected boolean addVmImages() {
    if (getVmTemplate().getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        Collection<DiskImage> templateDisks = getVmTemplate().getDiskTemplateMap().values();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage disk : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateCloneOfTemplate, buildCreateCloneOfTemplateParameters(disk));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            }
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
            DiskImage newImage = (DiskImage) result.getActionReturnValue();
            getSrcDiskIdToTargetDiskIdMapping().put(disk.getId(), newImage.getId());
        }
        // Clone volumes for Cinder disk templates
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
        if (!cinderDisks.isEmpty()) {
            addVmCinderDisks(cinderDisks);
        }
    }
    return true;
}
#method_after
@Override
protected boolean addVmImages() {
    if (getVmTemplate().getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        Collection<DiskImage> templateDisks = getVmTemplate().getDiskTemplateMap().values();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage disk : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateCloneOfTemplate, buildCreateCloneOfTemplateParameters(disk));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            }
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
            DiskImage newImage = (DiskImage) result.getActionReturnValue();
            getSrcDiskIdToTargetDiskIdMapping().put(disk.getId(), newImage.getId());
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
        if (!cinderDisks.isEmpty()) {
            addVmCinderDisks(cinderDisks);
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#end_block

#method_before
protected void addVmCinderDisks(List<CinderDisk> cinderDisks) {
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContextAndDetachFromParent(), CINDERStorageHelper.getStorageEntities(cinderDisks));
    try {
        Map<Guid, Guid> diskImageMap = future.get().getActionReturnValue();
        srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error cloning Cinder disks from template disks.", e);
    }
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContextAndDetachFromParent(), CINDERStorageHelper.getStorageEntities(cinderDisks));
    try {
        Map<Guid, Guid> diskImageMap = future.get().getActionReturnValue();
        srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error cloning Cinder disks from template disks.", e);
    }
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    typeEditor.setTabIndex(nextTabIndex++);
    datacenterEditor.setTabIndex(nextTabIndex++);
    urlEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vmwarePropertiesWidget.setTabIndexes(nextTabIndex);
    requiresAuthenticationEditor.setTabIndex(nextTabIndex++);
    usernameEditor.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    tenantNameEditor.setTabIndex(nextTabIndex++);
    authUrlEditor.setTabIndex(nextTabIndex++);
    testButton.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    typeEditor.setTabIndex(nextTabIndex++);
    datacenterEditor.setTabIndex(nextTabIndex++);
    pluginTypeEditor.setTabIndex(nextTabIndex++);
    urlEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vmwarePropertiesWidget.setTabIndexes(nextTabIndex);
    requiresAuthenticationEditor.setTabIndex(nextTabIndex++);
    usernameEditor.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    tenantNameEditor.setTabIndex(nextTabIndex++);
    authUrlEditor.setTabIndex(nextTabIndex++);
    testButton.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public String toString() {
    return // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    "Erratum [id=" + id + ", title=" + title + ", type=" + type + ", severity=" + severity + // $NON-NLS-1$ //$NON-NLS-2$
    "]";
}
#method_after
@Override
public String toString() {
    ToStringBuilder builder = ToStringBuilder.forInstance(this);
    // $NON-NLS-1$
    builder.append("id", id);
    // $NON-NLS-1$
    builder.append("title", title);
    // $NON-NLS-1$
    builder.append("type", type);
    // $NON-NLS-1$
    builder.append("severity", severity);
    return builder.toString();
}
#end_block

#method_before
public int getCountByType(Erratum.ErrataType type) {
    int count = 0;
    for (Erratum e : errata) {
        if (e.getType() != null && e.getType() == type) {
            count++;
        }
    }
    return count;
}
#method_after
public int getCountByType(ErrataType type) {
    int count = 0;
    for (Erratum e : errata) {
        if (e.getType() == type) {
            count++;
        }
    }
    return count;
}
#end_block

#method_before
public int getCountBySeverity(Erratum.ErrataSeverity severity) {
    int count = 0;
    for (Erratum e : errata) {
        if (e.getSeverity() != null && e.getSeverity() == severity) {
            count++;
        }
    }
    return count;
}
#method_after
public int getCountBySeverity(ErrataSeverity severity) {
    int count = 0;
    for (Erratum e : errata) {
        if (e.getSeverity() == severity) {
            count++;
        }
    }
    return count;
}
#end_block

#method_before
public int getCountByTypeAndSeverity(Erratum.ErrataType type, Erratum.ErrataSeverity severity) {
    int count = 0;
    for (Erratum e : errata) {
        if (e.getType() != null && e.getType() == type && e.getSeverity() != null && e.getSeverity() == severity) {
            count++;
        }
    }
    return count;
}
#method_after
public int getCountByTypeAndSeverity(ErrataType type, ErrataSeverity severity) {
    int count = 0;
    for (Erratum e : errata) {
        if (e.getType() == type && e.getSeverity() == severity) {
            count++;
        }
    }
    return count;
}
#end_block

#method_before
public static Set<Set<Guid>> getUnifiedPositiveAffinityGroups(List<AffinityGroup> affinityGroups) {
    Set<Set<Guid>> uag = new HashSet<>();
    Map<Guid, Set<Guid>> vmIndex = new HashMap<>();
    // from any affinity group
    for (AffinityGroup ag : affinityGroups) {
        if (ag.getEntityIds() == null) {
            continue;
        }
        for (Guid id : ag.getEntityIds()) {
            Set<Guid> temp = new HashSet<>();
            temp.add(id);
            uag.add(temp);
            vmIndex.put(id, temp);
        }
    }
    // that contain the referenced VMs into one.
    for (AffinityGroup ag : affinityGroups) {
        if (ag.isPositive()) {
            Set<Guid> mergedGroup = new HashSet<>();
            if (ag.getEntityIds() == null) {
                continue;
            }
            for (Guid id : ag.getEntityIds()) {
                // Get the current groups VM(id) belongs to
                Set<Guid> existingGroup = vmIndex.get(id);
                // Merge it with the currently computed mergeGroup
                mergedGroup.addAll(existingGroup);
                // And remove it from the valid groups
                // (it will be re-added as part of a bigger group)
                uag.remove(existingGroup);
                // Update the per-VM index
                for (Guid vm : existingGroup) {
                    vmIndex.put(vm, mergedGroup);
                }
            }
            uag.add(mergedGroup);
        }
    }
    return uag;
}
#method_after
public static Set<Set<Guid>> getUnifiedPositiveAffinityGroups(List<AffinityGroup> affinityGroups) {
    Set<Set<Guid>> uag = new HashSet<>();
    Map<Guid, Set<Guid>> vmIndex = new HashMap<>();
    /**
     * Initialize the single element groups by taking all VMs that are referenced
     * from any affinity group
     */
    for (Iterator<AffinityGroup> it = affinityGroups.iterator(); it.hasNext(); ) {
        AffinityGroup ag = it.next();
        /*
             * This check is done in order to prevent getting NullPointerException when the entityIds list
             * is null. This can can happen when using the REST api to add an affinity group.
             */
        if (ag.getEntityIds() == null) {
            it.remove();
            continue;
        }
        for (Guid id : ag.getEntityIds()) {
            Set<Guid> temp = new HashSet<>();
            temp.add(id);
            uag.add(temp);
            vmIndex.put(id, temp);
        }
    }
    // that contain the referenced VMs into one.
    for (AffinityGroup ag : affinityGroups) {
        if (ag.isPositive()) {
            Set<Guid> mergedGroup = new HashSet<>();
            for (Guid id : ag.getEntityIds()) {
                // Get the current groups VM(id) belongs to
                Set<Guid> existingGroup = vmIndex.get(id);
                // Merge it with the currently computed mergeGroup
                mergedGroup.addAll(existingGroup);
                // And remove it from the valid groups
                // (it will be re-added as part of a bigger group)
                uag.remove(existingGroup);
                // Update the per-VM index
                for (Guid vm : existingGroup) {
                    vmIndex.put(vm, mergedGroup);
                }
            }
            uag.add(mergedGroup);
        }
    }
    return uag;
}
#end_block

#method_before
public static Map<String, List<String>> getBondNameToBondSlavesMap(List<? extends VdsNetworkInterface> nics) {
    Map<String, List<String>> bondToSlaves = new HashMap<>();
    for (VdsNetworkInterface nic : nics) {
        if (nic.isPartOfBond()) {
            String bondName = nic.getBondName();
            if (!bondToSlaves.containsKey(bondName)) {
                bondToSlaves.put(bondName, new ArrayList<String>());
            }
            bondToSlaves.get(bondName).add(nic.getName());
        }
    }
    return bondToSlaves;
}
#method_after
public static Map<String, List<String>> getBondNameToBondSlavesMap(Collection<? extends VdsNetworkInterface> nics) {
    Map<String, List<String>> bondToSlaves = new HashMap<>();
    for (VdsNetworkInterface nic : nics) {
        if (nic.isPartOfBond()) {
            String bondName = nic.getBondName();
            if (!bondToSlaves.containsKey(bondName)) {
                bondToSlaves.put(bondName, new ArrayList<String>());
            }
            bondToSlaves.get(bondName).add(nic.getName());
        }
    }
    return bondToSlaves;
}
#end_block

#method_before
public static List<VdsNetworkInterface> getBondsWithSlavesInformation(List<? extends VdsNetworkInterface> nics) {
    List<VdsNetworkInterface> bonds = new ArrayList<>();
    fillBondSlaves(nics);
    for (VdsNetworkInterface nic : nics) {
        if (nic.isBond()) {
            bonds.add(nic);
        }
    }
    return bonds;
}
#method_after
public static Collection<VdsNetworkInterface> getBondsWithSlavesInformation(Collection<? extends VdsNetworkInterface> nics) {
    List<VdsNetworkInterface> bonds = new ArrayList<>();
    fillBondSlaves(nics);
    for (VdsNetworkInterface nic : nics) {
        if (nic instanceof Bond) {
            bonds.add(nic);
        }
    }
    return bonds;
}
#end_block

#method_before
public static void fillBondSlaves(List<? extends VdsNetworkInterface> nics) {
    Map<String, List<String>> bondToSlaves = NetworkCommonUtils.getBondNameToBondSlavesMap(nics);
    for (VdsNetworkInterface nic : nics) {
        if (nic instanceof Bond) {
            Bond bond = (Bond) nic;
            bond.setSlaves(bondToSlaves.containsKey(bond.getName()) ? bondToSlaves.get(bond.getName()) : Collections.<String>emptyList());
        }
    }
}
#method_after
public static void fillBondSlaves(Collection<? extends VdsNetworkInterface> nics) {
    Map<String, List<String>> bondToSlaves = getBondNameToBondSlavesMap(nics);
    for (VdsNetworkInterface nic : nics) {
        if (nic instanceof Bond) {
            Bond bond = (Bond) nic;
            bond.setSlaves(bondToSlaves.containsKey(bond.getName()) ? bondToSlaves.get(bond.getName()) : Collections.<String>emptyList());
        }
    }
}
#end_block

#method_before
@Override
public Object put(Object key, Object value) {
    String stringKey = (String) key;
    boolean found = false;
    int numEnums = classes.length;
    // Skip testing validation messages
    if (!stringKey.startsWith(VALIDATION_PREFIX)) {
        for (int i = 0; i < numEnums && !found; ++i) {
            try {
                // Will throw an IllegalArgumentException if the key isn't an EnumConstant
                Enum.valueOf(classes[i], stringKey);
                found = true;
            } catch (IllegalArgumentException ignore) {
                log.debug(stringKey + " is not a key in " + classes[i].getName());
            }
        }
        if (!found) {
            StringBuilder sb = new StringBuilder("No translation for key [").append(stringKey).append("] in enums: [").append(classes[0].getName());
            // Start from the second class
            for (int i = 1; i < classes.length; ++i) {
                sb.append(", ").append(classes[i]);
            }
            sb.append(']');
            throw new MissingEnumTranslationException(sb.toString());
        }
    }
    return super.put(key, value);
}
#method_after
@Override
public Object put(Object key, Object value) {
    String stringKey = (String) key;
    boolean found = false;
    // Skip testing validation messages
    for (Class<? extends Enum> clazz : classes) {
        try {
            // Will throw an IllegalArgumentException if the key isn't an EnumConstant
            Enum.valueOf(clazz, stringKey);
            found = true;
            break;
        } catch (IllegalArgumentException ignore) {
            log.debug(stringKey + " is not a key in " + clazz.getName());
        }
    }
    if (!found) {
        StringBuilder sb = new StringBuilder("No translation for key [").append(stringKey).append("] in enums: [").append(classes[0].getName());
        // Start from the second class
        for (int i = 1; i < classes.length; ++i) {
            sb.append(", ").append(classes[i]);
        }
        sb.append(']');
        throw new MissingEnumTranslationException(sb.toString());
    }
    return super.put(key, value);
}
#end_block

#method_before
@Test
public void testRedundantMessages() throws IOException {
    PropertiesTestUtils.assertNoRedundantKeys(// $NON-NLS-1$
    PropertiesTestUtils.loadFileFromPath("src/main/resources/org/ovirt/engine/ui/frontend/AppErrors.properties"), EngineMessage.class, // $NON-NLS-1$
    EngineError.class);
}
#method_after
@Test
public void testRedundantMessages() throws IOException {
    PropertiesTestUtils.assertNoRedundantKeys(// $NON-NLS-1$
    PropertiesTestUtils.loadFileFromPath("src/main/resources/org/ovirt/engine/ui/frontend/AppErrors.properties"), EngineMessage.class, EngineError.class);
}
#end_block

#method_before
@Test
public void testRedundantMessages() throws IOException {
    PropertiesTestUtils.assertNoRedundantKeys(PropertiesTestUtils.loadFileFromPath("src/main/resources/bundles/AppErrors.properties"), EngineMessage.class, // $NON-NLS-1$
    EngineError.class);
}
#method_after
@Test
public void testRedundantMessages() throws IOException {
    PropertiesTestUtils.assertNoRedundantKeys(PropertiesTestUtils.loadFileFromPath("src/main/resources/bundles/AppErrors.properties"), EngineMessage.class, EngineError.class);
}
#end_block

#method_before
public static File loadFileFromPath(String relativePath) {
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    return new File(baseDir, relativePath);
}
#method_after
public static File loadFileFromPath(String relativePath) {
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    return new File(baseDir, relativePath);
}
#end_block

#method_before
public static void assertNoRedundantKeys(File file, Class<? extends Enum>... template) throws IOException {
    EnumTranslationProperties props = new EnumTranslationProperties(template);
    try (InputStream is = new FileInputStream(file)) {
        props.load(is);
    } catch (MissingEnumTranslationException exception) {
        fail("Check for redundant keys in " + file.getAbsolutePath() + " failed: " + exception.getMessage());
    }
}
#method_after
public static void assertNoRedundantKeys(File file, Class<? extends Enum<?>>... template) throws IOException {
    EnumTranslationProperties props = new EnumTranslationProperties(template);
    try (InputStream is = new FileInputStream(file)) {
        props.load(is);
    } catch (MissingEnumTranslationException exception) {
        fail("Check for redundant keys in " + file.getAbsolutePath() + " failed: " + exception.getMessage());
    }
}
#end_block

#method_before
@Test
public void testRedundantMessages() throws IOException {
    PropertiesTestUtils.assertNoRedundantKeys(// $NON-NLS-1$
    PropertiesTestUtils.loadFileFromPath("src/main/resources/org/ovirt/engine/ui/frontend/AppErrors.properties"), EngineMessage.class, // $NON-NLS-1$
    EngineError.class);
}
#method_after
@Test
public void testRedundantMessages() throws IOException {
    PropertiesTestUtils.assertNoRedundantKeys(// $NON-NLS-1$
    PropertiesTestUtils.loadFileFromPath("src/main/resources/org/ovirt/engine/ui/frontend/AppErrors.properties"), EngineMessage.class, EngineError.class);
}
#end_block

#method_before
protected void updateDefaultDisplayRelatedFields(final VmBase vmBase) {
    // Update display protocol selected item
    final Collection<DisplayType> displayTypes = model.getDisplayType().getItems();
    if (displayTypes == null || displayTypes.isEmpty()) {
        return;
    }
    // graphics
    Frontend.getInstance().runQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object modelFromCallback, Object returnValue) {
            deactivate();
            // select display protocol
            // first by default
            DisplayType displayProtocol = displayTypes.iterator().next();
            if (displayTypes.contains(vmBase.getDefaultDisplayType())) {
                // if display types contain DT of a vm, pick this one
                displayProtocol = vmBase.getDefaultDisplayType();
            }
            maybeSetSelectedItem(model.getDisplayType(), displayProtocol);
            Set<GraphicsType> graphicsTypes = new HashSet<GraphicsType>();
            List<GraphicsDevice> graphicsDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (GraphicsDevice graphicsDevice : graphicsDevices) {
                graphicsTypes.add(graphicsDevice.getGraphicsType());
            }
            UnitVmModel.GraphicsTypes selected = UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsTypes);
            if (selected != null && getModel().getGraphicsType().getItems().contains(selected)) {
                maybeSetSelectedItem(getModel().getGraphicsType(), selected);
            }
            maybeSetSelectedItem(model.getDisplayType(), displayProtocol);
            maybeSetSelectedItem(model.getNumOfMonitors(), vmBase.getNumOfMonitors());
            maybeSetSelectedItem(model.getUsbPolicy(), vmBase.getUsbPolicy());
            maybeSetEntity(model.getIsSmartcardEnabled(), vmBase.isSmartcardEnabled());
            maybeSetSingleQxlPci(vmBase);
            activate();
        }
    }));
}
#method_after
protected void updateDefaultDisplayRelatedFields(final VmBase vmBase) {
    // Update display protocol selected item
    final Collection<DisplayType> displayTypes = model.getDisplayType().getItems();
    if (displayTypes == null || displayTypes.isEmpty()) {
        return;
    }
    // graphics
    Frontend.getInstance().runQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object modelFromCallback, Object returnValue) {
            deactivate();
            // select display protocol
            // first by default
            DisplayType displayProtocol = displayTypes.iterator().next();
            if (displayTypes.contains(vmBase.getDefaultDisplayType())) {
                // if display types contain DT of a vm, pick this one
                displayProtocol = vmBase.getDefaultDisplayType();
            }
            maybeSetSelectedItem(model.getDisplayType(), displayProtocol);
            Set<GraphicsType> graphicsTypes = new HashSet<GraphicsType>();
            List<GraphicsDevice> graphicsDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (GraphicsDevice graphicsDevice : graphicsDevices) {
                graphicsTypes.add(graphicsDevice.getGraphicsType());
            }
            UnitVmModel.GraphicsTypes selected = UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsTypes);
            if (selected != null && getModel().getGraphicsType().getItems().contains(selected)) {
                maybeSetSelectedItem(getModel().getGraphicsType(), selected);
            }
            maybeSetSelectedItem(model.getNumOfMonitors(), vmBase.getNumOfMonitors());
            maybeSetSelectedItem(model.getUsbPolicy(), vmBase.getUsbPolicy());
            maybeSetEntity(model.getIsSmartcardEnabled(), vmBase.isSmartcardEnabled());
            maybeSetSingleQxlPci(vmBase);
            activate();
        }
    }));
}
#end_block

#method_before
public static File loadFileFromPath(String relativePath) {
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    return new File(baseDir, relativePath);
}
#method_after
public static File loadFileFromPath(String relativePath) {
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    return new File(baseDir, relativePath);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartGlusterVolume, new GlusterVolumeActionVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().isForceAction()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        GlusterDBUtils.getInstance().updateVolumeStatus(getParameters().getVolumeId(), GlusterStatus.UP);
        GlusterSyncJob.getInstance().refreshVolumeDetails(upServer, getGlusterVolumeDao().getById(getParameters().getVolumeId()));
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_START_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartGlusterVolume, new GlusterVolumeActionVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().isForceAction()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        GlusterDBUtils.getInstance().updateVolumeStatus(getParameters().getVolumeId(), GlusterStatus.UP);
        /* Refresh volume details once the volume is started.
             * A specific requirement for this was user might create a volume for the sake of using it for geo-replication.
             * However, for suggesting volumes eligible for session creation, the size information of the volume is very important.
             * Having the user to wait for the sync job to sync the volume detail might not be appropriate.
             */
        GlusterSyncJob.getInstance().refreshVolumeDetails(upServer, getGlusterVolumeDao().getById(getParameters().getVolumeId()));
    /* GlusterSyncJob.getInstance().refreshVolumeDetails(upServer, getGlusterVolume());
             * will not suffice bcoz, getGlusterVolume fetches new volume only if its not yet been fetched from db and hence, refreshVolumeDetails figures out
             * that the info about volume-bricks are stale and hence attempts a update and correspondingly raises events for brick state change.
             * But here in the previous step we changed the volumes state(To GlusterStatus.UP) due to a successful execution of start command.
             * Hence fetch the volume afresh after the state change and use it to refresh volume details.
             */
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_START_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_BRICK);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__ADD);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__GLUSTER_BRICK);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (!validate(createVolumeValidator().isForceCreateVolumeAllowed(getVdsGroup().getCompatibilityVersion(), getParameters().isForce()))) {
        return false;
    }
    if (getGlusterVolume().getVolumeType().isReplicatedType()) {
        if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isStripedType()) {
        if (getParameters().getStripeCount() > getGlusterVolume().getStripeCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_STRIPE_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getStripeCount() < getGlusterVolume().getStripeCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_STRIPE_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isDispersedType()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_ADD_BRICK_TO_DISPERSE_VOLUME_NOT_SUPPORTED);
        return false;
    }
    return updateBrickServerAndInterfaceNames(getParameters().getBricks(), true) && validateDuplicateBricks(getParameters().getBricks());
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (!validate(createVolumeValidator().isForceCreateVolumeAllowed(getVdsGroup().getCompatibilityVersion(), getParameters().isForce()))) {
        return false;
    }
    if (getGlusterVolume().getVolumeType().isReplicatedType()) {
        if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount() + 1) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isStripedType()) {
        if (getParameters().getStripeCount() > getGlusterVolume().getStripeCount() + 1) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_STRIPE_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getStripeCount() < getGlusterVolume().getStripeCount()) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_STRIPE_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isDispersedType()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_ADD_BRICK_TO_DISPERSE_VOLUME_NOT_SUPPORTED);
        return false;
    }
    return updateBrickServerAndInterfaceNames(getParameters().getBricks(), true) && validateDuplicateBricks(getParameters().getBricks());
}
#end_block

#method_before
private boolean checkAndMountMetaVolume(Set<Guid> newServerIds, GlusterVolumeEntity volume, GlusterGeoRepSession currentSession) {
    // Mount meta volume only if the current volume is master.
    if (!volume.getIsGeoRepMaster()) {
        return false;
    }
    // Mounting meta volume is required only if use_meta_volume is set to true for the session.
    if (!Boolean.parseBoolean(getDbFacade().getGlusterGeoRepDao().getGeoRepSessionConfigByKey(currentSession.getId(), "use_meta_volume").getValue())) {
        return false;
    }
    // Attempt meta-volume mount for all new nodes in accordance with the criteria.
    List<Callable<VDSReturnValue>> metaVolumeMountCallables = new ArrayList<>();
    for (final Guid currentNewServerId : newServerIds) {
        metaVolumeMountCallables.add(new Callable<VDSReturnValue>() {

            @Override
            public VDSReturnValue call() throws Exception {
                addCustomValue(GlusterConstants.VDS_NAME, getVdsDao().get(currentNewServerId).getName());
                addCustomValue(GlusterConstants.VDS_GROUP_NAME, getGlusterVolume().getVdsGroupName());
                VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.MountGlusterMetaVolume, new VdsIdVDSCommandParametersBase(currentNewServerId));
                if (vdsReturnValue.getSucceeded()) {
                    auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.GLUSTER_META_VOLUME_MOUNTED_ON_HOST);
                } else {
                    vdsReturnValue.getVdsError().setVdsId(currentNewServerId);
                    handleVdsError(AuditLogType.GLUSTER_META_VOLUME_MOUNT_FAILED_ON_HOST, vdsReturnValue.getVdsError().getMessage());
                }
                return vdsReturnValue;
            }
        });
    }
    List<VDSReturnValue> metaVolumeMountReturnValues = ThreadPoolUtil.invokeAll(metaVolumeMountCallables);
    for (VDSReturnValue currentReturnValue : metaVolumeMountReturnValues) {
        if (!currentReturnValue.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean checkAndMountMetaVolume(GlusterVolumeEntity volume) {
    boolean mountMetaVolume = false;
    Set<Guid> newServerIds = new HashSet<>();
    List<GlusterGeoRepSession> geoRepSessionsForVolumeAsMaster = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    // Mount meta volume only if the current volume is master.
    if (!volume.getIsGeoRepMaster()) {
        return false;
    }
    for (GlusterGeoRepSession currentSession : geoRepSessionsForVolumeAsMaster) {
        // Mounting meta volume is required only if use_meta_volume is set to true for the session.
        if (Boolean.parseBoolean(getDbFacade().getGlusterGeoRepDao().getGeoRepSessionConfigByKey(currentSession.getId(), "use_meta_volume").getValue())) {
            mountMetaVolume = true;
            newServerIds = getSlaveNodesSet(currentSession);
            break;
        }
    }
    if (!mountMetaVolume) {
        return false;
    }
    // Attempt meta-volume mount for all new nodes in accordance with the criteria.
    List<Callable<VDSReturnValue>> metaVolumeMountCallables = new ArrayList<>();
    for (final Guid currentNewServerId : newServerIds) {
        metaVolumeMountCallables.add(new Callable<VDSReturnValue>() {

            @Override
            public VDSReturnValue call() throws Exception {
                addCustomValue(GlusterConstants.VDS_NAME, getVdsDao().get(currentNewServerId).getName());
                addCustomValue(GlusterConstants.VDS_GROUP_NAME, getGlusterVolume().getVdsGroupName());
                VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.MountGlusterMetaVolume, new VdsIdVDSCommandParametersBase(currentNewServerId));
                if (vdsReturnValue.getSucceeded()) {
                    auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.GLUSTER_META_VOLUME_MOUNTED_ON_HOST);
                } else {
                    vdsReturnValue.getVdsError().setVdsId(currentNewServerId);
                    handleVdsError(AuditLogType.GLUSTER_META_VOLUME_MOUNT_FAILED_ON_HOST, vdsReturnValue.getVdsError().getMessage());
                }
                return vdsReturnValue;
            }
        });
    }
    List<VDSReturnValue> metaVolumeMountReturnValues = ThreadPoolUtil.invokeAll(metaVolumeMountCallables);
    for (VDSReturnValue currentReturnValue : metaVolumeMountReturnValues) {
        if (!currentReturnValue.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void postAddBrickHandleGeoRepCase(final List<GlusterBrickEntity> bricksList, final Set<Guid> newServerIds) {
    // newServerIds is the set of ids of the servers that were not part of the volume before this attempt of brick
    // addition.
    final GlusterVolumeEntity volume = getGlusterVolume();
    List<GlusterGeoRepSession> sessions = new ArrayList<>();
    // Get all sessions for which the volume is a master
    List<GlusterGeoRepSession> geoRepSessionsForVolumeAsMaster = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    if (geoRepSessionsForVolumeAsMaster != null && !geoRepSessionsForVolumeAsMaster.isEmpty()) {
        sessions.addAll(geoRepSessionsForVolumeAsMaster);
    }
    // Get session for which the volume is a slave
    GlusterGeoRepSession geoRepSessionForVolumeAsSlave = getDbFacade().getGlusterGeoRepDao().getGeoRepSessionBySlaveVolume(volume.getId());
    if (geoRepSessionForVolumeAsSlave != null) {
        sessions.add(geoRepSessionForVolumeAsSlave);
    }
    // If this volume is empty, nothing to do.
    if (sessions.isEmpty()) {
        return;
    }
    List<Callable<Boolean>> perSessionCallables = new ArrayList<Callable<Boolean>>();
    for (final GlusterGeoRepSession currentSession : sessions) {
        perSessionCallables.add(new Callable<Boolean>() {

            @Override
            public Boolean call() throws Exception {
                // Ids of servers on which steps like mount broker setup and/or passwordless ssh need to be done.
                Set<Guid> serverIdsToPrep = new HashSet<Guid>(newServerIds);
                // Assume current volume as master volume of current session
                GlusterVolumeEntity masterVolume = volume;
                boolean succeeded = true;
                addCustomValue(GlusterConstants.VOLUME_NAME, currentSession.getMasterVolumeName());
                addCustomValue(GlusterConstants.GEO_REP_SLAVE_VOLUME_NAME, currentSession.getSlaveVolumeName());
                addCustomValue(GlusterConstants.GEO_REP_USER, currentSession.getUserName());
                if (currentSession.getMasterVolumeId().equals(volume.getId())) {
                    // Invoking checkAndMountMetaVolume(newServerIds, volume, currentSession); here might not be appropriate as it would block the other steps also.
                    /*
                         * If the volume is master, and there are any new servers, serverIdsToPrep is a set of all slave
                         * servers. This is bcoz the new server's keys also need to be updated to all slave servers.
                         */
                    serverIdsToPrep = getSlaveNodesSet(currentSession);
                } else {
                    // If its slave and non-root session, do partial mount broker setup
                    if (!currentSession.getUserName().equalsIgnoreCase("root")) {
                        succeeded = evaluateReturnValue(errorType, getBackend().runInternalAction(VdcActionType.SetupGlusterGeoRepMountBrokerInternal, new SetUpMountBrokerParameters(volume.getClusterId(), serverIdsToPrep, volume.getName(), currentSession.getUserName())));
                        if (succeeded) {
                            auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.GLUSTER_SETUP_GEOREP_MOUNT_BROKER);
                        }
                    }
                    /*
                         * If the assumption that current volume is master, is invalid, which will be known here, update
                         * master volume correctly.
                         */
                    masterVolume = getGlusterVolumeDao().getById(currentSession.getMasterVolumeId());
                }
                if (succeeded) {
                    succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.SetUpPasswordLessSSHInternal, new SetUpPasswordLessSSHParameters(masterVolume.getClusterId(), serverIdsToPrep, currentSession.getUserName())));
                }
                if (succeeded) {
                    succeeded = checkAndMountMetaVolume(newServerIds, volume, currentSession);
                }
                if (succeeded) {
                    auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.SET_UP_PASSWORDLESS_SSH);
                    succeeded = evaluateReturnValue(errorType, runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(getClusterUtils().getRandomUpServer(masterVolume.getClusterId()).getId(), currentSession.getMasterVolumeName(), currentSession.getSlaveHostName(), currentSession.getSlaveVolumeName(), currentSession.getUserName(), true)));
                }
                if (currentSession.getStatus() == GeoRepSessionStatus.ACTIVE || currentSession.getStatus() == GeoRepSessionStatus.INITIALIZING) {
                    succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.StartGlusterVolumeGeoRep, new GlusterVolumeGeoRepSessionParameters(currentSession.getMasterVolumeId(), currentSession.getId(), true)));
                }
                return succeeded;
            }
        });
    }
    ThreadPoolUtil.invokeAll(perSessionCallables);
}
#method_after
private void postAddBrickHandleGeoRepCase(final List<GlusterBrickEntity> bricksList, final Set<Guid> newServerIds) {
    // newServerIds is the set of ids of the servers that were not part of the volume before this attempt of brick
    // addition.
    final GlusterVolumeEntity volume = getGlusterVolume();
    checkAndMountMetaVolume(volume);
    List<GlusterGeoRepSession> sessions = new ArrayList<>();
    // Get all sessions for which the volume is a master
    List<GlusterGeoRepSession> geoRepSessionsForVolumeAsMaster = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    if (geoRepSessionsForVolumeAsMaster != null && !geoRepSessionsForVolumeAsMaster.isEmpty()) {
        sessions.addAll(geoRepSessionsForVolumeAsMaster);
    }
    // Get session for which the volume is a slave
    GlusterGeoRepSession geoRepSessionForVolumeAsSlave = getDbFacade().getGlusterGeoRepDao().getGeoRepSessionBySlaveVolume(volume.getId());
    if (geoRepSessionForVolumeAsSlave != null) {
        sessions.add(geoRepSessionForVolumeAsSlave);
    }
    // If this volume is empty, nothing to do.
    if (sessions.isEmpty()) {
        return;
    }
    List<Callable<Boolean>> perSessionCallables = new ArrayList<Callable<Boolean>>();
    for (final GlusterGeoRepSession currentSession : sessions) {
        perSessionCallables.add(new Callable<Boolean>() {

            @Override
            public Boolean call() throws Exception {
                // Ids of servers on which steps like mount broker setup and/or passwordless ssh need to be done.
                Set<Guid> serverIdsToPrep = new HashSet<Guid>(newServerIds);
                // Assume current volume as master volume of current session
                GlusterVolumeEntity masterVolume = volume;
                boolean succeeded = true;
                addCustomValue(GlusterConstants.VOLUME_NAME, currentSession.getMasterVolumeName());
                addCustomValue(GlusterConstants.GEO_REP_SLAVE_VOLUME_NAME, currentSession.getSlaveVolumeName());
                addCustomValue(GlusterConstants.GEO_REP_USER, currentSession.getUserName());
                if (currentSession.getMasterVolumeId().equals(volume.getId())) {
                    // Invoking checkAndMountMetaVolume(newServerIds, volume, currentSession); here might not be appropriate as it would block the other steps also.
                    /*
                         * If the volume is master, and there are any new servers, serverIdsToPrep is a set of all slave
                         * servers. This is bcoz the new server's keys also need to be updated to all slave servers.
                         */
                    serverIdsToPrep = getSlaveNodesSet(currentSession);
                } else {
                    // If its slave and non-root session, do partial mount broker setup
                    if (!currentSession.getUserName().equalsIgnoreCase("root")) {
                        succeeded = evaluateReturnValue(errorType, getBackend().runInternalAction(VdcActionType.SetupGlusterGeoRepMountBrokerInternal, new SetUpMountBrokerParameters(volume.getClusterId(), serverIdsToPrep, volume.getName(), currentSession.getUserName())));
                        if (succeeded) {
                            auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.GLUSTER_SETUP_GEOREP_MOUNT_BROKER);
                        }
                    }
                    /*
                         * If the assumption that current volume is master, is invalid, which will be known here, update
                         * master volume correctly.
                         */
                    masterVolume = getGlusterVolumeDao().getById(currentSession.getMasterVolumeId());
                }
                if (succeeded) {
                    succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.SetUpPasswordLessSSHInternal, new SetUpPasswordLessSSHParameters(masterVolume.getClusterId(), serverIdsToPrep, currentSession.getUserName())));
                }
                if (succeeded) {
                    succeeded = checkAndMountMetaVolume(newServerIds, volume, currentSession);
                }
                if (succeeded) {
                    auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.SET_UP_PASSWORDLESS_SSH);
                    succeeded = evaluateReturnValue(errorType, runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(getClusterUtils().getRandomUpServer(masterVolume.getClusterId()).getId(), currentSession.getMasterVolumeName(), currentSession.getSlaveHostName(), currentSession.getSlaveVolumeName(), currentSession.getUserName(), true)));
                }
                if (currentSession.getStatus() == GeoRepSessionStatus.ACTIVE || currentSession.getStatus() == GeoRepSessionStatus.INITIALIZING) {
                    succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.StartGlusterVolumeGeoRep, new GlusterVolumeGeoRepSessionParameters(currentSession.getMasterVolumeId(), currentSession.getId(), true)));
                }
                return succeeded;
            }
        });
    }
    ThreadPoolUtil.invokeAll(perSessionCallables);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_GEOREP_CONFIG);
    addCanDoActionMessageVariable("configName", getParameters().getConfigKey());
    addCanDoActionMessageVariable("geoRepSessionKey", getGeoRepSession().getSessionKey());
    addCanDoActionMessageVariable("configValue", getParameters().getConfigValue());
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__SET);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__GLUSTER_GEOREP_CONFIG);
    addCanDoActionMessageVariable("configName", getParameters().getConfigKey());
    addCanDoActionMessageVariable("geoRepSessionKey", getGeoRepSession().getSessionKey());
    addCanDoActionMessageVariable("configValue", getParameters().getConfigValue());
}
#end_block

#method_before
@Override
protected org.ovirt.engine.api.model.UnmanagedNetwork doPopulate(org.ovirt.engine.api.model.UnmanagedNetwork model, UnmanagedNetwork entity) {
    return model;
}
#method_after
@Override
protected UnmanagedNetwork doPopulate(UnmanagedNetwork model, org.ovirt.engine.core.common.businessentities.UnmanagedNetwork entity) {
    return model;
}
#end_block

#method_before
@Override
public org.ovirt.engine.api.model.UnmanagedNetwork get() {
    return performGet(VdcQueryType.GetUnmanagedNetworkByVdsIdAndName, new UnmanagedNetworkParameters(hostId, id), Host.class);
}
#method_after
@Override
public UnmanagedNetwork get() {
    return performGet(VdcQueryType.GetUnmanagedNetworkByVdsIdAndName, new UnmanagedNetworkParameters(hostId, id), Host.class);
}
#end_block

#method_before
@Override
protected org.ovirt.engine.api.model.UnmanagedNetwork addParents(org.ovirt.engine.api.model.UnmanagedNetwork model) {
    Host host = new Host();
    model.setHost(host);
    model.getHost().setId(hostId.toString());
    if (model.isSetHostNic()) {
        model.getHostNic().setHost(host);
    }
    return model;
}
#method_after
@Override
protected UnmanagedNetwork addParents(UnmanagedNetwork model) {
    Host host = new Host();
    model.setHost(host);
    model.getHost().setId(hostId.toString());
    if (model.isSetHostNic()) {
        model.getHostNic().setHost(host);
    }
    return model;
}
#end_block

#method_before
private List<UnmanagedNetwork> getAllUnmanagedNetworksByVdsId() {
    return getBackendCollection(VdcQueryType.GetAllUnmanagedNetworksByVdsId, new IdQueryParameters(hostId));
}
#method_after
private List<org.ovirt.engine.core.common.businessentities.UnmanagedNetwork> getAllUnmanagedNetworksByVdsId() {
    return getBackendCollection(VdcQueryType.GetAllUnmanagedNetworksByVdsId, new IdQueryParameters(hostId));
}
#end_block

#method_before
private UnmanagedNetworks mapCollection(List<UnmanagedNetwork> unmanagedNetworks) {
    UnmanagedNetworks result = new UnmanagedNetworks();
    for (UnmanagedNetwork unmanagedNetwork : unmanagedNetworks) {
        result.getUnmanagedNetworks().add(addLinks(populate(map(unmanagedNetwork), null), Host.class));
    }
    return result;
}
#method_after
private UnmanagedNetworks mapCollection(List<org.ovirt.engine.core.common.businessentities.UnmanagedNetwork> unmanagedNetworks) {
    UnmanagedNetworks result = new UnmanagedNetworks();
    for (org.ovirt.engine.core.common.businessentities.UnmanagedNetwork unmanagedNetwork : unmanagedNetworks) {
        result.getUnmanagedNetworks().add(addLinks(populate(map(unmanagedNetwork), null), Host.class));
    }
    return result;
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(hostId);
    parameters.setRemovedUnmanagedNetworks(Collections.singletonList(id));
    return performAction(VdcActionType.HostSetupNetworks, parameters);
}
#method_after
@Override
protected Response performRemove(String id) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(hostId);
    parameters.setRemovedUnmanagedNetworks(Collections.singletonList(HexUtils.hex2string(id)));
    return performAction(VdcActionType.HostSetupNetworks, parameters);
}
#end_block

#method_before
@Override
protected org.ovirt.engine.api.model.UnmanagedNetwork doPopulate(org.ovirt.engine.api.model.UnmanagedNetwork model, UnmanagedNetwork entity) {
    return model;
}
#method_after
@Override
protected UnmanagedNetwork doPopulate(UnmanagedNetwork model, org.ovirt.engine.core.common.businessentities.UnmanagedNetwork entity) {
    return model;
}
#end_block

#method_before
@Override
protected org.ovirt.engine.api.model.UnmanagedNetwork addParents(org.ovirt.engine.api.model.UnmanagedNetwork model) {
    Host host = new Host();
    model.setHost(host);
    model.getHost().setId(hostId.toString());
    if (model.isSetHostNic()) {
        model.getHostNic().setHost(host);
    }
    return model;
}
#method_after
@Override
protected UnmanagedNetwork addParents(UnmanagedNetwork model) {
    Host host = new Host();
    model.setHost(host);
    model.getHost().setId(hostId.toString());
    if (model.isSetHostNic()) {
        model.getHostNic().setHost(host);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = UnmanagedNetwork.class, to = org.ovirt.engine.core.common.businessentities.UnmanagedNetwork.class)
public static org.ovirt.engine.core.common.businessentities.UnmanagedNetwork map(UnmanagedNetwork model, org.ovirt.engine.core.common.businessentities.UnmanagedNetwork template) {
    if (model == null) {
        return template;
    }
    org.ovirt.engine.core.common.businessentities.UnmanagedNetwork entity = template == null ? new org.ovirt.engine.core.common.businessentities.UnmanagedNetwork() : template;
    if (model.isSetId()) {
        entity.setId(HexUtils.hex2string(model.getName()));
    }
    if (model.isSetName()) {
        entity.setNetworkName(model.getName());
    }
    if (model.isSetHostNic()) {
        HostNIC hostNic = model.getHostNic();
        if (hostNic.isSetId()) {
            entity.setNicId(GuidUtils.asGuid(hostNic.getId()));
        }
        if (hostNic.isSetName()) {
            entity.setNicName(hostNic.getName());
        }
    }
    return entity;
}
#method_after
@Mapping(from = UnmanagedNetwork.class, to = org.ovirt.engine.core.common.businessentities.UnmanagedNetwork.class)
public static org.ovirt.engine.core.common.businessentities.UnmanagedNetwork map(UnmanagedNetwork model, org.ovirt.engine.core.common.businessentities.UnmanagedNetwork template) {
    if (model == null) {
        return template;
    }
    org.ovirt.engine.core.common.businessentities.UnmanagedNetwork entity = template == null ? new org.ovirt.engine.core.common.businessentities.UnmanagedNetwork() : template;
    if (model.isSetId()) {
        entity.setId(HexUtils.hex2string(model.getId()));
    }
    if (model.isSetName()) {
        entity.setNetworkName(model.getName());
    }
    if (model.isSetHostNic()) {
        HostNIC hostNic = model.getHostNic();
        if (hostNic.isSetId()) {
            entity.setNicId(GuidUtils.asGuid(hostNic.getId()));
        }
        if (hostNic.isSetName()) {
            entity.setNicName(hostNic.getName());
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class, to = NetworkAttachment.class)
public static NetworkAttachment map(org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity, NetworkAttachment template) {
    NetworkAttachment model = template == null ? new NetworkAttachment() : template;
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getNetworkId() != null) {
        model.setNetwork(new Network());
        model.getNetwork().setId(entity.getNetworkId().toString());
    }
    if (entity.getNicId() != null) {
        model.setHostNic(new HostNIC());
        model.getHostNic().setId(entity.getNicId().toString());
    }
    if (entity.hasProperties()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getProperties()));
    }
    if (entity.getReportedConfigurations() != null) {
        model.setReportedConfigurations(ReportedConfigurationsMapper.map(entity.getReportedConfigurations(), null));
    }
    org.ovirt.engine.core.common.businessentities.network.IpConfiguration entityIpConfiguration = entity.getIpConfiguration();
    if (entityIpConfiguration != null) {
        IpConfiguration modelIpConfiguration = new IpConfiguration();
        model.setIpConfiguration(modelIpConfiguration);
        modelIpConfiguration.setIPv4Configuration(new IPv4S());
        BootProtocol bootProtocol = BootProtocolMapper.map(entityIpConfiguration.getBootProtocol(), null);
        IPv4S iPv4Configuration = modelIpConfiguration.getIPv4Configuration();
        if (bootProtocol != null) {
            iPv4Configuration.setBootProtocol(bootProtocol.value());
        }
        if (entityIpConfiguration.getIPv4Addresses() != null) {
            mapIPv4Addresses(entityIpConfiguration, iPv4Configuration);
        }
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.api.model.NetworkAttachment.class, to = NetworkAttachment.class)
public static NetworkAttachment map(org.ovirt.engine.api.model.NetworkAttachment model, NetworkAttachment template) {
    NetworkAttachment entity = template == null ? new NetworkAttachment() : template;
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork() && model.getNetwork().isSetId()) {
        entity.setNetworkId(GuidUtils.asGuid(model.getNetwork().getId()));
    }
    if (model.isSetHostNic()) {
        HostNIC hostNic = model.getHostNic();
        if (hostNic.isSetId()) {
            entity.setNicId(GuidUtils.asGuid(hostNic.getId()));
        }
        if (hostNic.isSetName()) {
            entity.setNicName(hostNic.getName());
        }
    }
    if (model.isSetProperties()) {
        entity.setProperties(CustomPropertiesParser.toMap(model.getProperties()));
    }
    if (model.isSetOverrideConfiguration()) {
        entity.setOverrideConfiguration(model.isOverrideConfiguration());
    }
    if (model.isSetIpConfiguration() && model.getIpConfiguration().isSetIPv4Configuration()) {
        IPv4S ipv4configuration = model.getIpConfiguration().getIPv4Configuration();
        if (ipv4configuration != null) {
            entity.setIpConfiguration(new org.ovirt.engine.core.common.businessentities.network.IpConfiguration());
            if (ipv4configuration.isSetBootProtocol()) {
                NetworkBootProtocol networkBootProtocol = BootProtocolMapper.map(BootProtocol.fromValue(ipv4configuration.getBootProtocol()), null);
                if (networkBootProtocol != null) {
                    entity.getIpConfiguration().setBootProtocol(networkBootProtocol);
                }
            }
            if (!ipv4configuration.getIPv4Addresses().isEmpty()) {
                IPv4 ip4Address = ipv4configuration.getIPv4Addresses().get(0);
                if (ip4Address.isSetAddress()) {
                    entity.getIpConfiguration().setAddress(ip4Address.getAddress());
                }
                if (ip4Address.isSetNetmask()) {
                    entity.getIpConfiguration().setNetmask(ip4Address.getNetmask());
                }
                if (ip4Address.isSetGateway()) {
                    entity.getIpConfiguration().setGateway(ip4Address.getGateway());
                }
            }
        }
    }
    return entity;
}
#end_block

#method_before
@Override
public Host get() {
    // the "refreshcapabilities" action and removed in the future.
    if (isForce()) {
        performAction(VdcActionType.RefreshHostCapabilities, new VdsActionParameters(guid));
    }
    Host host = getVdsByVdsId();
    deprecatedAddLinksToAgents(host);
    return host;
}
#method_after
@Override
public Host get() {
    if (isForce()) {
        performAction(VdcActionType.RefreshHostCapabilities, new VdsActionParameters(guid));
    }
    return getVdsByVdsId();
}
#end_block

#method_before
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getVdsGroupId())) {
            performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    // deprecatedUpdateFenceAgents(incoming);
    Host host = performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
    deprecatedAddLinksToAgents(host);
    return host;
}
#method_after
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getVdsGroupId())) {
            performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    return performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
public Response install(Action action) {
    // REVISIT fencing options
    VDS vds = getEntity();
    validateEnums(Action.class, action);
    UpdateVdsActionParameters params = new UpdateVdsActionParameters(vds.getStaticData(), action.getRootPassword(), true);
    params = (UpdateVdsActionParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    if (vds.getVdsType() == VDSType.oVirtNode) {
        params.setReinstallOrUpgrade(true);
        if (action.isSetImage()) {
            params.setoVirtIsoFile(action.getImage());
        }
    }
    return doAction(VdcActionType.UpdateVds, params, action);
}
#method_after
@Override
public Response install(Action action) {
    // REVISIT fencing options
    VDS vds = getEntity();
    validateEnums(Action.class, action);
    UpdateVdsActionParameters params = new UpdateVdsActionParameters(vds.getStaticData(), action.getRootPassword(), true);
    params = (UpdateVdsActionParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    if (vds.getVdsType() == VDSType.oVirtNode) {
        params.setIsReinstallOrUpgrade(true);
        if (action.isSetImage()) {
            params.setoVirtIsoFile(action.getImage());
        }
    }
    return doAction(VdcActionType.UpdateVds, params, action);
}
#end_block

#method_before
@Override
public Response setupNetworks(Action action) {
    // verify if host exists to handle 404 status code.
    getVdsByVdsId();
    HostSetupNetworksParameters parameters = toParameters(action);
    return performAction(VdcActionType.HostSetupNetworks, parameters, action);
}
#method_after
@Override
public Response setupNetworks(Action action) {
    Host verifyIfHostExistsToHandle404StatusCode = getVdsByVdsId();
    HostSetupNetworksParameters parameters = toParameters(action);
    return performAction(VdcActionType.HostSetupNetworks, parameters, action);
}
#end_block

#method_before
private HostSetupNetworksParameters toParameters(Action action) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(guid);
    Map<Guid, NetworkAttachment> attachmentsById = getBackendNetworkAttachments();
    if (action.isSetNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getNetworkAttachments().add(attachment);
        }
    }
    if (action.isSetRemovedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getRemovedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getRemovedNetworkAttachments().add(attachment);
        }
    }
    BusinessEntityMap<Bond> bonds = getBackendHostBonds();
    if (action.isSetBonds()) {
        for (HostNIC bond : action.getBonds().getHostNics()) {
            parameters.getBonds().add(mapBonds(bonds, bond));
        }
    }
    if (action.isSetRemovedBonds()) {
        for (HostNIC bond : action.getRemovedBonds().getHostNics()) {
            parameters.getRemovedBonds().add(mapBonds(bonds, bond));
        }
    }
    if (action.isSetCheckConnectivity()) {
        parameters.setRollbackOnFailure(action.isCheckConnectivity());
    }
    if (action.isSetConnectivityTimeout()) {
        parameters.setConectivityTimeout(action.getConnectivityTimeout());
    }
    return parameters;
}
#method_after
private HostSetupNetworksParameters toParameters(Action action) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(guid);
    Map<Guid, NetworkAttachment> attachmentsById = getBackendNetworkAttachments();
    if (action.isSetNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getNetworkAttachments().add(attachment);
        }
    }
    if (action.isSetRemovedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getRemovedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getRemovedNetworkAttachments().add(attachment);
        }
    }
    BusinessEntityMap<Bond> bonds = getBackendHostBonds();
    if (action.isSetBonds()) {
        for (HostNIC bond : action.getBonds().getHostNics()) {
            parameters.getBonds().add(mapBonds(bonds, bond));
        }
    }
    if (action.isSetRemovedBonds()) {
        for (HostNIC bond : action.getRemovedBonds().getHostNics()) {
            parameters.getRemovedBonds().add(mapBonds(bonds, bond));
        }
    }
    parameters.setRollbackOnFailure(action.isSetCheckConnectivity() ? action.isCheckConnectivity() : false);
    if (action.isSetConnectivityTimeout()) {
        parameters.setConectivityTimeout(action.getConnectivityTimeout());
    }
    return parameters;
}
#end_block

#method_before
public Bond mapBonds(BusinessEntityMap<Bond> bonds, HostNIC model) {
    Mapper<HostNIC, Bond> hostNicMapper = getMapper(HostNIC.class, Bond.class);
    Bond bond;
    if (model.isSetId()) {
        Guid nicId = asGuid(model.getId());
        bond = hostNicMapper.map(model, bonds.get(nicId));
    } else {
        Bond template = model.isSetName() ? bonds.get(model.getName()) : null;
        bond = hostNicMapper.map(model, template);
    }
    return bond;
}
#method_after
public Bond mapBonds(BusinessEntityMap<Bond> bonds, HostNIC model) {
    Mapper<HostNIC, Bond> hostNicMapper = getMapper(HostNIC.class, Bond.class);
    Bond bond;
    if (model.isSetId()) {
        Guid nicId = asGuid(model.getId());
        bond = hostNicMapper.map(model, bonds.get(nicId));
    } else {
        Bond tempalte = model.isSetName() ? bonds.get(model.getName()) : null;
        bond = hostNicMapper.map(model, tempalte);
    }
    return bond;
}
#end_block

#method_before
@Override
public Response deactivate(Action action) {
    return doAction(VdcActionType.MaintenanceNumberOfVdss, new MaintenanceNumberOfVdssParameters(asList(guid), false, action.isSetReason() ? action.getReason() : null), action);
}
#method_after
@Override
public Response deactivate(Action action) {
    return doAction(VdcActionType.MaintenanceNumberOfVdss, new MaintenanceNumberOfVdssParameters(asList(guid), false), action);
}
#end_block

#method_before
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    StorageServerConnections cnx = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setconnection(iscsiDetails.getAddress());
    cnx.setiqn(iscsiDetails.getTarget());
    cnx.setstorage_type(StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setport(iscsiDetails.getPort().toString());
    } else {
        cnx.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setpassword(iscsiDetails.getPassword());
    }
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid);
    return doAction(VdcActionType.ConnectStorageToVds, connectionParms, action);
}
#method_after
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    StorageServerConnections cnx = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setconnection(iscsiDetails.getAddress());
    cnx.setiqn(iscsiDetails.getTarget());
    cnx.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setport(iscsiDetails.getPort().toString());
    } else {
        cnx.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setpassword(iscsiDetails.getPassword());
    }
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid);
    return doAction(VdcActionType.ConnectStorageToVds, connectionParms, action);
}
#end_block

#method_before
private DiscoverSendTargetsQueryParameters createDiscoveryQueryParams(Action action) {
    StorageServerConnections connectionDetails = getInitializedConnectionIscsiDetails(action);
    return new DiscoverSendTargetsQueryParameters(guid, connectionDetails);
}
#method_after
private DiscoverSendTargetsQueryParameters createDiscoveryQueryParams(Action action) {
    StorageServerConnections connectionDetails = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    connectionDetails.setconnection(iscsiDetails.getAddress());
    connectionDetails.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        connectionDetails.setport(iscsiDetails.getPort().toString());
    } else {
        connectionDetails.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        connectionDetails.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        connectionDetails.setpassword(iscsiDetails.getPassword());
    }
    return new DiscoverSendTargetsQueryParameters(guid, connectionDetails);
}
#end_block

#method_before
@Override
public Response fence(Action action) {
    validateParameters(action, "fenceType");
    FenceType fenceType = validateEnum(FenceType.class, action.getFenceType().toUpperCase());
    switch(fenceType) {
        case MANUAL:
            return fenceManually(action);
        case RESTART:
            return fence(action, VdcActionType.RestartVds, FenceActionType.RESTART);
        case START:
            return fence(action, VdcActionType.StartVds, FenceActionType.START);
        case STOP:
            return fence(action, VdcActionType.StopVds, FenceActionType.STOP);
        case STATUS:
            return getFenceStatus(action);
        default:
            return null;
    }
}
#method_after
@Override
public Response fence(Action action) {
    validateParameters(action, "fenceType");
    FenceType fenceType = validateEnum(FenceType.class, action.getFenceType().toUpperCase());
    switch(fenceType) {
        case MANUAL:
            return fenceManually(action);
        case RESTART:
            return fence(action, VdcActionType.RestartVds, FenceActionType.Restart);
        case START:
            return fence(action, VdcActionType.StartVds, FenceActionType.Start);
        case STOP:
            return fence(action, VdcActionType.StopVds, FenceActionType.Stop);
        case STATUS:
            return getFencingStatus(action);
        default:
            return null;
    }
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Host incoming, VDS entity) {
    VdsStatic updated = getMapper(modelType, VdsStatic.class).map(incoming, entity.getStaticData());
    UpdateVdsActionParameters updateParams = new UpdateVdsActionParameters(updated, incoming.getRootPassword(), false);
    // Updating Fence-agents is deprecated from this context, so the original, unchanged, list of agents is
    // passed to the engine.
    updateParams.setFenceAgents(entity.getFenceAgents());
    if (incoming.isSetOverrideIptables()) {
        updateParams.setOverrideFirewall(incoming.isOverrideIptables());
    }
    updateParams = (UpdateVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(incoming, (VdsOperationActionParameters) updateParams);
    return updateParams;
}
#method_after
@Override
public VdcActionParametersBase getParameters(Host incoming, VDS entity) {
    VdsStatic updated = getMapper(modelType, VdsStatic.class).map(incoming, entity.getStaticData());
    UpdateVdsActionParameters updateParams = new UpdateVdsActionParameters(updated, incoming.getRootPassword(), false);
    if (incoming.isSetOverrideIptables()) {
        updateParams.setOverrideFirewall(incoming.isOverrideIptables());
    }
    updateParams = (UpdateVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(incoming, (VdsOperationActionParameters) updateParams);
    return updateParams;
}
#end_block

#method_before
protected void verifyIfHostExistsToHandle404StatusCode() {
    Guid hostId = getHostId();
    // verify if host exists to handle 404 status code.
    getEntity(VDS.class, VdcQueryType.GetVdsByVdsId, new IdQueryParameters(hostId), hostId.toString(), true);
}
#method_after
protected void verifyIfHostExistsToHandle404StatusCode() {
    Guid hostId = getHostId();
    VDS verifyIfHostExistsToHandle404StatusCode = getEntity(VDS.class, VdcQueryType.GetVdsByVdsId, new IdQueryParameters(hostId), hostId.toString(), true);
}
#end_block

#method_before
@Override
public Response add(NetworkAttachment attachment) {
    validateParameters(attachment, "network.id");
    org.ovirt.engine.core.common.businessentities.network.NetworkAttachment networkAttachment = map(attachment);
    NetworkAttachmentParameters params = new NetworkAttachmentParameters(hostId, networkAttachment);
    return performCreate(VdcActionType.AddNetworkAttachment, params, new QueryIdResolver<Guid>(VdcQueryType.GetNetworkAttachmentById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(org.ovirt.engine.api.model.NetworkAttachment attachment) {
    validateParameters(attachment, "network.id");
    NetworkAttachment networkAttachment = map(attachment);
    NetworkAttachmentParameters params = new NetworkAttachmentParameters(hostId, networkAttachment);
    return performCreate(VdcActionType.AddNetworkAttachment, params, new QueryIdResolver<Guid>(VdcQueryType.GetNetworkAttachmentById, IdQueryParameters.class));
}
#end_block

#method_before
@Override
protected NetworkAttachment doPopulate(NetworkAttachment model, org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity) {
    return model;
}
#method_after
@Override
protected org.ovirt.engine.api.model.NetworkAttachment doPopulate(org.ovirt.engine.api.model.NetworkAttachment model, NetworkAttachment entity) {
    return model;
}
#end_block

#method_before
@Override
protected NetworkAttachment addLinks(NetworkAttachment model, Class<? extends BaseResource> suggestedParent, String... excludeSubCollectionMembers) {
    return super.addLinks(model, getParentClass());
}
#method_after
@Override
protected org.ovirt.engine.api.model.NetworkAttachment addLinks(org.ovirt.engine.api.model.NetworkAttachment model, Class<? extends BaseResource> suggestedParent, String... excludeSubCollectionMembers) {
    return super.addLinks(model, getParentClass());
}
#end_block

#method_before
private org.ovirt.engine.core.common.businessentities.network.NetworkAttachment getNetworkAttachment(String id) {
    return getEntity(org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class, VdcQueryType.GetNetworkAttachmentById, new IdQueryParameters(asGuidOr404(id)), "NetworkAttachment");
}
#method_after
private NetworkAttachment getNetworkAttachment(String id) {
    return getEntity(NetworkAttachment.class, VdcQueryType.GetNetworkAttachmentById, new IdQueryParameters(asGuidOr404(id)), "NetworkAttachment");
}
#end_block

#method_before
private NetworkAttachments mapCollection(List<org.ovirt.engine.core.common.businessentities.network.NetworkAttachment> networkAttachments) {
    NetworkAttachments collection = new NetworkAttachments();
    for (org.ovirt.engine.core.common.businessentities.network.NetworkAttachment networkAttachmentEntity : networkAttachments) {
        NetworkAttachment networkAttachmentModel = populate(map(networkAttachmentEntity), networkAttachmentEntity);
        collection.getNetworkAttachments().add(addLinks(networkAttachmentModel, getParentClass()));
    }
    return collection;
}
#method_after
private NetworkAttachments mapCollection(List<NetworkAttachment> networkAttachments) {
    NetworkAttachments collection = new NetworkAttachments();
    for (NetworkAttachment attachment : networkAttachments) {
        org.ovirt.engine.api.model.NetworkAttachment entity = populate(map(attachment), attachment);
        collection.getNetworkAttachments().add(addLinks(entity, getParentClass()));
    }
    return collection;
}
#end_block

#method_before
private boolean validNewOrModifiedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, host, managementNetworkUtil);
        String networkId = attachment.getNetworkId() == null ? "" : attachment.getNetworkId().toString();
        if (violations.addViolation(validator.networkAttachmentIsSet()) || // this is not network exist, but only network is set.
        violations.addViolation(validator.networkExists(), networkId) || violations.addViolation(networkActuallyExists(attachment.getNetworkId()), networkId) || violations.addViolation(validator.notExternalNetwork(), networkId) || violations.addViolation(validator.networkAttachedToCluster(), networkId) || violations.addViolation(validator.ipConfiguredForStaticBootProtocol(), networkId) || violations.addViolation(validator.bootProtocolSetForDisplayNetwork(), networkId) || // this is not nic exist, but only nic is set.
        violations.addViolation(validator.nicExists(), networkId) || violations.addViolation(nicActuallyExistsOrReferencesNewBond(attachment), networkId) || violations.addViolation(validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfaces)) || violations.addViolation(validator.networkNotChanged(attachmentsById.get(attachment.getId()))) || violations.addViolation(validator.validateGateway())) {
            passed = false;
        }
    }
    return passed;
}
#method_after
private boolean validNewOrModifiedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, host);
        String networkId = attachment.getNetworkId() == null ? "" : attachment.getNetworkId().toString();
        if (violations.addViolation(validator.networkAttachmentIsSet()) || // this is not network exist, but only network is set.
        violations.addViolation(validator.networkExists(), networkId) || violations.addViolation(networkActuallyExists(attachment.getNetworkId()), networkId) || violations.addViolation(validator.notExternalNetwork(), networkId) || violations.addViolation(validator.networkAttachedToCluster(), networkId) || violations.addViolation(validator.ipConfiguredForStaticBootProtocol(), networkId) || violations.addViolation(validator.bootProtocolSetForDisplayNetwork(), networkId) || // this is not nic exist, but only nic is set.
        violations.addViolation(validator.nicExists(), networkId) || violations.addViolation(nicActuallyExistsOrReferencesNewBond(attachment), networkId) || violations.addViolation(validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfaces)) || violations.addViolation(validator.networkNotChanged(attachmentsById.get(attachment.getId()))) || violations.addViolation(validator.validateGateway())) {
            passed = false;
        }
    }
    return passed;
}
#end_block

#method_before
private boolean validRemovedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getRemovedNetworkAttachments()) {
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachmentToValidate, host, managementNetworkUtil);
        if (violations.addViolation(validator.networkAttachmentIsSet()) || violations.addViolation(validator.notExternalNetwork()) || violations.addViolation(validator.notRemovingManagementNetwork()) || !notRemovingLabeledNetworks(attachment)) {
            passed = false;
        }
    }
    return passed;
}
#method_after
private boolean validRemovedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getRemovedNetworkAttachments()) {
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachmentToValidate, host);
        if (violations.addViolation(validator.networkAttachmentIsSet()) || violations.addViolation(validator.notExternalNetwork()) || violations.addViolation(validator.notRemovingManagementNetwork()) || !notRemovingLabeledNetworks(attachment)) {
            passed = false;
        }
    }
    return passed;
}
#end_block

#method_before
@Override
protected List<org.ovirt.engine.core.common.businessentities.network.NetworkAttachment> getNetworkAttachments() {
    verifyIfHostExistsToHandle404StatusCode();
    return getBackendCollection(VdcQueryType.GetNetworkAttachmentsByHostId, new IdQueryParameters(getHostId()));
}
#method_after
@Override
protected List<NetworkAttachment> getNetworkAttachments() {
    verifyIfHostExistsToHandle404StatusCode();
    return getBackendCollection(VdcQueryType.GetNetworkAttachmentsByHostId, new IdQueryParameters(getHostId()));
}
#end_block

#method_before
@Override
protected NetworkAttachment addParents(NetworkAttachment model) {
    Host host = new Host();
    model.setHost(host);
    model.getHost().setId(getHostId().toString());
    if (model.isSetHostNic()) {
        model.getHostNic().setHost(host);
    }
    return model;
}
#method_after
@Override
protected org.ovirt.engine.api.model.NetworkAttachment addParents(org.ovirt.engine.api.model.NetworkAttachment model) {
    Host host = new Host();
    model.setHost(host);
    model.getHost().setId(getHostId().toString());
    if (model.isSetHostNic()) {
        model.getHostNic().setHost(host);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = NetworkAttachment.class, to = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class)
public static org.ovirt.engine.core.common.businessentities.network.NetworkAttachment map(NetworkAttachment model, org.ovirt.engine.core.common.businessentities.network.NetworkAttachment template) {
    org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity = template == null ? new org.ovirt.engine.core.common.businessentities.network.NetworkAttachment() : template;
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork()) {
        Network networkModel = model.getNetwork();
        if (networkModel.isSetId()) {
            entity.setNetworkId(GuidUtils.asGuid(networkModel.getId()));
        }
        if (networkModel.isSetName()) {
            entity.setNetworkName(networkModel.getName());
        }
    }
    if (model.isSetHostNic()) {
        HostNIC hostNic = model.getHostNic();
        if (hostNic.isSetId()) {
            entity.setNicId(GuidUtils.asGuid(hostNic.getId()));
        }
        if (hostNic.isSetName()) {
            entity.setNicName(hostNic.getName());
        }
    }
    if (model.isSetProperties()) {
        entity.setProperties(CustomPropertiesParser.toMap(model.getProperties()));
    }
    if (model.isSetOverrideConfiguration()) {
        entity.setOverrideConfiguration(model.isOverrideConfiguration());
    }
    if (model.isSetIpConfiguration()) {
        IpConfiguration modelIpConfiguration = model.getIpConfiguration();
        if (modelIpConfiguration.isSetIPv4Configuration()) {
            IPv4S ipv4configuration = modelIpConfiguration.getIPv4Configuration();
            entity.setIpConfiguration(new org.ovirt.engine.core.common.businessentities.network.IpConfiguration());
            if (ipv4configuration.isSetBootProtocol()) {
                NetworkBootProtocol networkBootProtocol = BootProtocolMapper.map(BootProtocol.fromValue(ipv4configuration.getBootProtocol()), null);
                if (networkBootProtocol != null) {
                    entity.getIpConfiguration().setBootProtocol(networkBootProtocol);
                }
            }
            if (ipv4configuration.isSetIPv4Addresses()) {
                entity.getIpConfiguration().setIPv4Addresses(mapIPv4Addresses(ipv4configuration.getIPv4Addresses()));
            }
        }
    }
    return entity;
}
#method_after
@Mapping(from = NetworkAttachment.class, to = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class)
public static org.ovirt.engine.core.common.businessentities.network.NetworkAttachment map(NetworkAttachment model, org.ovirt.engine.core.common.businessentities.network.NetworkAttachment template) {
    org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity = template == null ? new org.ovirt.engine.core.common.businessentities.network.NetworkAttachment() : template;
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork()) {
        Network networkModel = model.getNetwork();
        if (networkModel.isSetId()) {
            entity.setNetworkId(GuidUtils.asGuid(networkModel.getId()));
        }
        if (networkModel.isSetName()) {
            entity.setNetworkName(networkModel.getName());
        }
    }
    if (model.isSetHostNic()) {
        HostNIC hostNic = model.getHostNic();
        if (hostNic.isSetId()) {
            entity.setNicId(GuidUtils.asGuid(hostNic.getId()));
        } else {
            entity.setNicId(null);
        }
        if (hostNic.isSetName()) {
            entity.setNicName(hostNic.getName());
        } else {
            entity.setNicName(null);
        }
    }
    if (model.isSetProperties()) {
        entity.setProperties(CustomPropertiesParser.toMap(model.getProperties()));
    }
    if (model.isSetIpAddressAssignments()) {
        entity.setIpConfiguration(new org.ovirt.engine.core.common.businessentities.network.IpConfiguration());
        IpAddressAssignments ipAddressAssignments = model.getIpAddressAssignments();
        entity.getIpConfiguration().setIPv4Addresses(new ArrayList<IPv4Address>());
        for (IpAddressAssignment ipAddressAssignment : ipAddressAssignments.getIpAddressAssignments()) {
            entity.getIpConfiguration().getIPv4Addresses().add(mapIpAddressAssignment(ipAddressAssignment));
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class, to = NetworkAttachment.class)
public static NetworkAttachment map(org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity, NetworkAttachment template) {
    NetworkAttachment model = template == null ? new NetworkAttachment() : template;
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getNetworkId() != null) {
        model.setNetwork(new Network());
        model.getNetwork().setId(entity.getNetworkId().toString());
    }
    if (entity.getNetworkName() != null) {
        if (model.getNetwork() == null) {
            model.setNetwork(new Network());
        }
        model.getNetwork().setName(entity.getNetworkName());
    }
    if (entity.getNicId() != null) {
        model.setHostNic(new HostNIC());
        model.getHostNic().setId(entity.getNicId().toString());
    }
    if (entity.hasProperties()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getProperties()));
    }
    if (entity.getReportedConfigurations() != null) {
        model.setReportedConfigurations(ReportedConfigurationsMapper.map(entity.getReportedConfigurations(), null));
    }
    org.ovirt.engine.core.common.businessentities.network.IpConfiguration entityIpConfiguration = entity.getIpConfiguration();
    if (entityIpConfiguration != null) {
        IpConfiguration modelIpConfiguration = new IpConfiguration();
        model.setIpConfiguration(modelIpConfiguration);
        modelIpConfiguration.setIPv4Configuration(new IPv4S());
        BootProtocol bootProtocol = BootProtocolMapper.map(entityIpConfiguration.getBootProtocol(), null);
        IPv4S iPv4Configuration = modelIpConfiguration.getIPv4Configuration();
        if (bootProtocol != null) {
            iPv4Configuration.setBootProtocol(bootProtocol.value());
        }
        if (entityIpConfiguration.getIPv4Addresses() != null) {
            mapIPv4Addresses(entityIpConfiguration, iPv4Configuration);
        }
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class, to = NetworkAttachment.class)
public static NetworkAttachment map(org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity, NetworkAttachment template) {
    NetworkAttachment model = template == null ? new NetworkAttachment() : template;
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getNetworkId() != null) {
        getModelNetwork(model).setId(entity.getNetworkId().toString());
    }
    if (entity.getNetworkName() != null) {
        if (model.getNetwork() == null) {
            model.setNetwork(new Network());
        }
        model.getNetwork().setName(entity.getNetworkName());
    }
    if (entity.getNicId() != null) {
        getModelHostNic(model).setId(entity.getNicId().toString());
    }
    if (entity.hasProperties()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getProperties()));
    }
    org.ovirt.engine.core.common.businessentities.network.IpConfiguration entityIpConfiguration = entity.getIpConfiguration();
    if (entityIpConfiguration != null && !entityIpConfiguration.getIPv4Addresses().isEmpty()) {
        model.setIpAddressAssignments(new IpAddressAssignments());
        for (IPv4Address iPv4Address : entityIpConfiguration.getIPv4Addresses()) {
            model.getIpAddressAssignments().getIpAddressAssignments().add(mapIpAddressAssignment(iPv4Address));
        }
    }
    if (entity.getReportedConfigurations() != null) {
        model.setReportedConfigurations(ReportedConfigurationsMapper.map(entity.getReportedConfigurations(), null));
    }
    return model;
}
#end_block

#method_before
@Override
public Response add(NetworkAttachment attachment) {
    org.ovirt.engine.core.common.businessentities.network.NetworkAttachment networkAttachment = map(attachment);
    NetworkAttachmentParameters params = new NetworkAttachmentParameters(hostId, networkAttachment);
    return performCreate(VdcActionType.AddNetworkAttachment, params, new QueryIdResolver<Guid>(VdcQueryType.GetNetworkAttachmentById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(NetworkAttachment attachment) {
    validateParameters(attachment, "network.id|name");
    org.ovirt.engine.core.common.businessentities.network.NetworkAttachment networkAttachment = map(attachment);
    NetworkAttachmentParameters params = new NetworkAttachmentParameters(hostId, networkAttachment);
    return performCreate(VdcActionType.AddNetworkAttachment, params, new QueryIdResolver<Guid>(VdcQueryType.GetNetworkAttachmentById, IdQueryParameters.class));
}
#end_block

#method_before
@Test
public void testEvalNegative() {
    Mockito.when(mockExternalNetworkPredicate.eval(mockNetwork)).thenReturn(true);
    assertFalse(underTest.eval(mockNetwork));
}
#method_after
@Test
public void testEvalNegative() {
    when(mockExternalNetworkPredicate.eval(mockNetwork)).thenReturn(true);
    assertFalse(underTest.eval(mockNetwork));
}
#end_block

#method_before
@Test
public void testEvalPositive() {
    Mockito.when(mockExternalNetworkPredicate.eval(mockNetwork)).thenReturn(false);
    assertTrue(underTest.eval(mockNetwork));
}
#method_after
@Test
public void testEvalPositive() {
    when(mockExternalNetworkPredicate.eval(mockNetwork)).thenReturn(false);
    assertTrue(underTest.eval(mockNetwork));
}
#end_block

#method_before
private void addBondToUpdateList(Bond bond) {
    for (Bond oldModifiedBond : hostSetupNetworksParametersData.newOrModifiedBonds) {
        if (oldModifiedBond.getName().equals(bond.getName())) {
            hostSetupNetworksParametersData.newOrModifiedBonds.remove(oldModifiedBond);
            break;
        }
    }
    hostSetupNetworksParametersData.newOrModifiedBonds.add(bond);
}
#method_after
private void addBondToUpdateList(Bond bond) {
    for (Iterator<Bond> iter = hostSetupNetworksParametersData.newOrModifiedBonds.iterator(); iter.hasNext(); ) {
        Bond oldModifiedBond = iter.next();
        if (oldModifiedBond.getName().equals(bond.getName())) {
            iter.remove();
            break;
        }
    }
    hostSetupNetworksParametersData.newOrModifiedBonds.add(bond);
}
#end_block

#method_before
public void removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(LogicalNetworkModel logicalNetwork, VdsNetworkInterface entity) {
    Network updatedNetwork = logicalNetwork.getNetwork();
    Guid updatedNetworkId = updatedNetwork.getId();
    Map<Guid, NetworkAttachment> networkIdToPreexistingNetworkAttachment = new MapNetworkAttachments(existingNetworkAttachments).byNetworkId();
    Map<Guid, NetworkAttachment> networkIdToNewOrUpdatedNetworkAttachments = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId();
    NetworkAttachment preexistingNetworkAttachment = networkIdToPreexistingNetworkAttachment.get(updatedNetworkId);
    Guid networkAttachmentId = preexistingNetworkAttachment == null ? null : preexistingNetworkAttachment.getId();
    NetworkAttachment previousUpdate = networkIdToNewOrUpdatedNetworkAttachments.get(updatedNetworkId);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.remove(previousUpdate);
    NetworkAttachment updatedNetworkAttachment = NetworkOperation.newNetworkAttachment(updatedNetwork, logicalNetwork.getAttachedToNic().getIface(), logicalNetwork.getVlanNicModel().getIface(), networkAttachmentId, hostSetupNetworksParametersData);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.add(updatedNetworkAttachment);
}
#method_after
public void removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(LogicalNetworkModel logicalNetwork, VdsNetworkInterface entity) {
    Network updatedNetwork = logicalNetwork.getNetwork();
    Guid updatedNetworkId = updatedNetwork.getId();
    Map<Guid, NetworkAttachment> networkIdToPreexistingNetworkAttachment = new MapNetworkAttachments(existingNetworkAttachments).byNetworkId();
    Map<Guid, NetworkAttachment> networkIdToNewOrUpdatedNetworkAttachments = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId();
    NetworkAttachment preexistingNetworkAttachment = networkIdToPreexistingNetworkAttachment.get(updatedNetworkId);
    Guid networkAttachmentId = preexistingNetworkAttachment == null ? null : preexistingNetworkAttachment.getId();
    NetworkAttachment previousUpdate = networkIdToNewOrUpdatedNetworkAttachments.get(updatedNetworkId);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.remove(previousUpdate);
    NetworkAttachment updatedNetworkAttachment = NetworkOperation.newNetworkAttachment(updatedNetwork, logicalNetwork.getAttachedToNic().getIface(), logicalNetwork.getVlanNicModel().getIface(), networkAttachmentId, hostSetupNetworksParametersData.networksToSync);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.add(updatedNetworkAttachment);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            BondNetworkInterfaceModel bondNetworkInterfaceModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
            for (NetworkInterfaceModel bondedModel : bondedModels) {
                bondedModel.setBond(bondNetworkInterfaceModel);
            }
            nicModels.put(nicName, bondNetworkInterfaceModel);
        } else {
            NetworkInterfaceModel nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), this);
            nicModels.put(nicName, nicModel);
        }
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            BondNetworkInterfaceModel bondNetworkInterfaceModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
            nicModels.put(nicName, bondNetworkInterfaceModel);
        } else {
            NetworkInterfaceModel nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), this);
            nicModels.put(nicName, nicModel);
        }
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
public static VmDynamic buildVMDynamicData(Map<String, Object> xmlRpcStruct) {
    VmDynamic vmdynamic = new VmDynamic();
    updateVMDynamicData(vmdynamic, xmlRpcStruct);
    return vmdynamic;
}
#method_after
public static VmDynamic buildVMDynamicData(Map<String, Object> xmlRpcStruct, VDS host) {
    VmDynamic vmdynamic = new VmDynamic();
    updateVMDynamicData(vmdynamic, xmlRpcStruct, host);
    return vmdynamic;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setVmHost(assignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = assignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(assignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(assignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(assignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        } else {
            vm.setGuestMemoryBuffered(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        } else {
            vm.setGuestMemoryCached(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        } else {
            vm.setGuestMemoryFree(null);
        }
    } else {
        vm.setGuestMemoryBuffered(null);
        vm.setGuestMemoryCached(null);
        vm.setGuestMemoryFree(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, xmlRpcStruct);
    }
    // Guest Timezone
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct, VDS host) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    if (xmlRpcStruct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(xmlRpcStruct, vm);
    if (xmlRpcStruct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(assignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_IP)) {
        vm.setVmIp(assignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    }
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, xmlRpcStruct);
    }
    // Guest Timezone
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#end_block

#method_before
private static void updateGraphicsInfoFromConf(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    GraphicsType vmGraphicsType = parseGraphicsType(xmlRpcStruct);
    if (vmGraphicsType == null) {
        log.warn("Can't set graphics data from XML.");
        return;
    }
    GraphicsInfo graphicsInfo = new GraphicsInfo();
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            graphicsInfo.setPort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.error("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            graphicsInfo.setPort(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.error("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            graphicsInfo.setTlsPort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.error("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        graphicsInfo.setIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    vm.getGraphicsInfos().put(vmGraphicsType, graphicsInfo);
}
#method_after
private static void updateGraphicsInfoFromConf(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    GraphicsType vmGraphicsType = parseGraphicsType(xmlRpcStruct);
    if (vmGraphicsType == null) {
        log.debug("graphics data missing in XML.");
        return;
    }
    GraphicsInfo graphicsInfo = new GraphicsInfo();
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            graphicsInfo.setPort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.error("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            graphicsInfo.setPort(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.error("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            graphicsInfo.setTlsPort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.error("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        graphicsInfo.setIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    vm.getGraphicsInfos().put(vmGraphicsType, graphicsInfo);
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    Map<String, Object> bondOptionsMap = (Map<String, Object>) bondProperties.get("opts");
                    String miimon = (String) bondOptionsMap.get("miimon");
                    String mode = (String) bondOptionsMap.get("mode");
                    bondOptions = String.format("mode=%s miimon=%s", mode, miimon);
                } else {
                    Map<String, Object> config = (Map<String, Object>) bondProperties.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    bond.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    Map<String, Object> bondOptionsMap = new HashMap<>();
                    bondOptionsMap.putAll((Map<String, Object>) bondProperties.get("opts"));
                    String bondOptionsString = "";
                    String mode = (String) bondOptionsMap.get("mode");
                    String miimon = (String) bondOptionsMap.get("miimon");
                    if (mode != null && miimon != null) {
                        bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                        bondOptionsMap.remove("mode");
                        bondOptionsMap.remove("miimon");
                    }
                    for (Map.Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                        bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                    }
                    bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                } else {
                    Map<String, Object> config = (Map<String, Object>) bondProperties.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    bond.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#end_block

#method_before
private void commitLabelChanges(List<VdsNetworkInterface> srcIfaces, VdsNetworkInterface dstIface) {
    NetworkOperation.moveLabels(srcIfaces, dstIface);
}
#method_after
private void commitLabelChanges(List<VdsNetworkInterface> srcIfaces, VdsNetworkInterface dstIface) {
    NetworkOperation.moveLabels(srcIfaces, dstIface, hostSetupNetworksParametersData);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            BondNetworkInterfaceModel bondNetworkInterfaceModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
            for (NetworkInterfaceModel bondedModel : bondedModels) {
                bondedModel.setBond(bondNetworkInterfaceModel);
            }
            nicModels.put(nicName, bondNetworkInterfaceModel);
        } else {
            NetworkInterfaceModel nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), this);
            nicModels.put(nicName, nicModel);
        }
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            BondNetworkInterfaceModel bondNetworkInterfaceModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
            nicModels.put(nicName, bondNetworkInterfaceModel);
        } else {
            NetworkInterfaceModel nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), this);
            nicModels.put(nicName, nicModel);
        }
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
public HostSetupNetworksParameters createHostSetupNetworksParameters() {
    HostSetupNetworksParameters result = new HostSetupNetworksParameters(getEntity().getId());
    result.setNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments);
    result.setRemovedNetworkAttachments(new HashSet<>(Entities.getIds(hostSetupNetworksParametersData.removedNetworkAttachments)));
    result.setBonds(hostSetupNetworksParametersData.newOrModifiedBonds);
    result.setRemovedBonds(new HashSet<>(Entities.getIds(hostSetupNetworksParametersData.removedBonds)));
    result.setRemovedUnmanagedNetworks(hostSetupNetworksParametersData.removedUnmanagedNetworks);
    result.setLabels(hostSetupNetworksParametersData.addedLabels);
    Set<String> removedLabels = new HashSet<>();
    // This is needed because HashMap.KeySet doesn't pass gwt serialization
    removedLabels.addAll(NicLabel.getNicLabelByLabel(hostSetupNetworksParametersData.removedLabels).keySet());
    result.setRemovedLabels(removedLabels);
    return result;
}
#method_after
public HostSetupNetworksParameters createHostSetupNetworksParameters() {
    HostSetupNetworksParameters result = new HostSetupNetworksParameters(getEntity().getId());
    result.setNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments);
    result.setRemovedNetworkAttachments(new HashSet<>(Entities.getIds(hostSetupNetworksParametersData.removedNetworkAttachments)));
    result.setBonds(hostSetupNetworksParametersData.newOrModifiedBonds);
    result.setRemovedBonds(new HashSet<>(Entities.getIds(hostSetupNetworksParametersData.removedBonds)));
    result.setRemovedUnmanagedNetworks(hostSetupNetworksParametersData.removedUnmanagedNetworks);
    result.setLabels(hostSetupNetworksParametersData.addedLabels);
    result.setRemovedLabels(Entities.objectNames(hostSetupNetworksParametersData.removedLabels));
    return result;
}
#end_block

#method_before
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkItemModel<?> op1 = getItemModel(op1Key, op1Type);
    NetworkItemModel<?> op2 = getItemModel(op2Key, op2Type);
    if (op1 == null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop) {
        onOperation(candidate, candidate.getCommand(op1, op2, hostSetupNetworksParametersData));
    }
    // raise the candidate event only if it was changed
    if (!candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
        currentCandidate = candidate;
        currentOp1 = op1;
        currentOp2 = op2;
        getOperationCandidateEvent().raise(this, new OperationCandidateEventArgs(candidate, op1, op2));
    }
    return !candidate.isNullOperation();
}
#method_after
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkInterfaceModel nic1 = null;
    LogicalNetworkModel network1 = null;
    NetworkInterfaceModel nic2 = null;
    LogicalNetworkModel network2 = null;
    if (NIC.equals(op1Type)) {
        nic1 = nicMap.get(op1Key);
    } else if (NETWORK.equals(op1Type)) {
        network1 = networkMap.get(op1Key);
    }
    if (NIC.equals(op2Type)) {
        nic2 = nicMap.get(op2Key);
    } else if (NETWORK.equals(op2Type)) {
        network2 = networkMap.get(op2Key);
    }
    NetworkItemModel<?> op1 = nic1 == null ? network1 : nic1;
    NetworkItemModel<?> op2 = nic2 == null ? network2 : nic2;
    return candidateOperation(op1, op2, drop);
}
#end_block

#method_before
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkItemModel<?> op1 = getItemModel(op1Key, op1Type);
    NetworkItemModel<?> op2 = getItemModel(op2Key, op2Type);
    if (op1 == null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop) {
        onOperation(candidate, candidate.getCommand(op1, op2, hostSetupNetworksParametersData));
    }
    // raise the candidate event only if it was changed
    if (!candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
        currentCandidate = candidate;
        currentOp1 = op1;
        currentOp2 = op2;
        getOperationCandidateEvent().raise(this, new OperationCandidateEventArgs(candidate, op1, op2));
    }
    return !candidate.isNullOperation();
}
#method_after
private boolean candidateOperation(NetworkItemModel<?> op1, NetworkItemModel<?> op2, boolean drop) {
    if (op1 == null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop) {
        onOperation(candidate, candidate.getCommand(op1, op2, allNics, allNetworkAttachments, hostSetupNetworksParameters));
    }
    // raise the candidate event only if it was changed
    if (!candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
        currentCandidate = candidate;
        currentOp1 = op1;
        currentOp2 = op2;
        getOperationCandidateEvent().raise(this, new OperationCandidateEventArgs(candidate, op1, op2));
    }
    return !candidate.isNullOperation();
}
#end_block

#method_before
public Map<NetworkOperation, List<NetworkCommand>> commandsFor(NetworkItemModel<?> item) {
    return operationFactory.commandsFor(item, hostSetupNetworksParametersData);
}
#method_after
public Map<NetworkOperation, List<NetworkCommand>> commandsFor(NetworkItemModel<?> item) {
    return operationFactory.commandsFor(item, allNics, allNetworkAttachments, hostSetupNetworksParameters);
}
#end_block

#method_before
private void commitLabelChanges(List<VdsNetworkInterface> srcIfaces, VdsNetworkInterface dstIface) {
    NetworkOperation.moveLabels(srcIfaces, dstIface);
}
#method_after
private void commitLabelChanges(NicLabelModel labelModel, VdsNetworkInterface iface, Collection<LogicalNetworkModel> potentialNetworks) {
    labelModel.commit(iface);
    NetworkInterfaceModel ifaceModel = nicMap.get(iface.getName());
    NetworkOperation.clearNetworks(ifaceModel, allNics, allNetworkAttachments, hostSetupNetworksParameters);
    NetworkOperation.attachNetworks(ifaceModel, new ArrayList<>(potentialNetworks), allNics, allNetworkAttachments, hostSetupNetworksParameters);
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNicModel().getIface() : logicalNetwork.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        if (logicalNetwork.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(logicalNetwork.getNetwork());
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getNetwork());
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
        networkDialogModel.getAddress().setEntity(entity.getAddress());
        networkDialogModel.getSubnet().setEntity(entity.getSubnet());
        networkDialogModel.getGateway().setEntity(entity.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(entity.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(entity.getBootProtocol());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(entity.isQosOverridden());
            if (entity.isQosOverridden()) {
                networkDialogModel.getQosModel().init(entity.getQos());
            } else {
                Guid qosId = logicalNetwork.getNetwork().getQosId();
                if (qosId != null) {
                    networkDialogModel.startProgress(null);
                    Frontend.getInstance().runQuery(VdcQueryType.GetQosById, new IdQueryParameters(qosId), new AsyncQuery(new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            networkDialogModel.getQosModel().init((HostNetworkQos) ((VdcQueryReturnValue) returnValue).getReturnValue());
                            networkDialogModel.stopProgress();
                        }
                    }));
                }
            }
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!logicalNetwork.getNetwork().isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(entity.getCustomProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetwork.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetwork.getName()));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                entity.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    entity.setAddress(networkDialogModel.getAddress().getEntity());
                    entity.setSubnet(networkDialogModel.getSubnet().getEntity());
                    entity.setGateway(networkDialogModel.getGateway().getEntity());
                }
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    boolean qosOverridden = networkDialogModel.getQosOverridden().getEntity();
                    HostNetworkQos qos = null;
                    entity.setQosOverridden(qosOverridden);
                    if (qosOverridden) {
                        qos = new HostNetworkQos();
                        networkDialogModel.getQosModel().flush(qos);
                    }
                    entity.setQos(qos);
                }
                if (networkDialogModel.getCustomPropertiesModel().getIsAvailable()) {
                    entity.setCustomProperties(KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()));
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetwork.getName());
                } else {
                    networksToSync.remove(logicalNetwork.getName());
                }
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetwork, entity);
                sourceListModel.setConfirmWindow(null);
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        editPopup = new SetupNetworksEditBondModel(entity, getFreeLabels(), labelToIface);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                String bondName = entity.getName();
                // TODO MM: why closing prior to validating changes?
                sourceListModel.setConfirmWindow(null);
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(bondDialogModel.getLabelsModel(), nicMap.get(bondName).getItems());
                if (validateLabelChanges(potentialNetworks)) {
                    setBondOptions(entity, bondDialogModel);
                    commitLabelChanges(bondDialogModel.getLabelsModel(), entity, potentialNetworks);
                    redraw();
                    Map<String, Bond> bondNameToBondMap = NetworkOperation.byName(hostSetupNetworksParameters.getBonds());
                    // delete old bond if present.
                    hostSetupNetworksParameters.getBonds().remove(bondNameToBondMap.get(bondName));
                    hostSetupNetworksParameters.getBonds().add((Bond) entity);
                } else {
                // TODO MM: where's else? (Why) We're not setting bonding mode if labels are not valid? And if they're not valid, why it's ok to close dialog?
                }
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  Interface Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        final HostNicModel interfacePopupModel = new HostNicModel(entity, getFreeLabels(), labelToIface);
        editPopup = interfacePopupModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!interfacePopupModel.validate()) {
                    return;
                }
                // TODO MM: why closing prior to validating changes?
                sourceListModel.setConfirmWindow(null);
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(interfacePopupModel.getLabelsModel(), nicMap.get(entity.getName()).getItems());
                if (validateLabelChanges(potentialNetworks)) {
                    commitLabelChanges(interfacePopupModel.getLabelsModel(), entity, potentialNetworks);
                    redraw();
                } else {
                // TODO MM: where's else?
                }
            }
        };
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNicModel().getEntity() : logicalNetwork.getAttachedToNic().getEntity();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        if (logicalNetwork.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(logicalNetwork.getEntity());
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getEntity());
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
        networkDialogModel.getAddress().setEntity(entity.getAddress());
        networkDialogModel.getSubnet().setEntity(entity.getSubnet());
        networkDialogModel.getGateway().setEntity(entity.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(entity.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(entity.getBootProtocol());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(entity.isQosOverridden());
            if (entity.isQosOverridden()) {
                networkDialogModel.getQosModel().init(entity.getQos());
            } else {
                Guid qosId = logicalNetwork.getEntity().getQosId();
                if (qosId != null) {
                    networkDialogModel.startProgress(null);
                    Frontend.getInstance().runQuery(VdcQueryType.GetQosById, new IdQueryParameters(qosId), new AsyncQuery(new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            networkDialogModel.getQosModel().init((HostNetworkQos) ((VdcQueryReturnValue) returnValue).getReturnValue());
                            networkDialogModel.stopProgress();
                        }
                    }));
                }
            }
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!logicalNetwork.getEntity().isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(entity.getCustomProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetwork.getName()));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                entity.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    entity.setAddress(networkDialogModel.getAddress().getEntity());
                    entity.setSubnet(networkDialogModel.getSubnet().getEntity());
                    entity.setGateway(networkDialogModel.getGateway().getEntity());
                }
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    boolean qosOverridden = networkDialogModel.getQosOverridden().getEntity();
                    HostNetworkQos qos = null;
                    entity.setQosOverridden(qosOverridden);
                    if (qosOverridden) {
                        qos = new HostNetworkQos();
                        networkDialogModel.getQosModel().flush(qos);
                    }
                    entity.setQos(qos);
                }
                if (networkDialogModel.getCustomPropertiesModel().getIsAvailable()) {
                    entity.setCustomProperties(KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()));
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetwork.getName());
                } else {
                    networksToSync.remove(logicalNetwork.getName());
                }
                Network updatedNetwork = logicalNetwork.getEntity();
                Guid updatedNetworkId = updatedNetwork.getId();
                Map<Guid, NetworkAttachment> networkIdToPreexistingNetworkAttachment = NetworkAttachment.mapByNetworkId(allNetworkAttachments);
                Map<Guid, NetworkAttachment> networkIdToNewOrUpdatedNetworkAttachments = NetworkAttachment.mapByNetworkId(hostSetupNetworksParameters.getNetworkAttachments());
                Guid networkAttachmentId = networkIdToPreexistingNetworkAttachment.get(updatedNetworkId).getId();
                NetworkAttachment previousUpdate = networkIdToNewOrUpdatedNetworkAttachments.get(updatedNetworkId);
                hostSetupNetworksParameters.getNetworkAttachments().remove(previousUpdate);
                NetworkAttachment updatedNetworkAttachment = NetworkOperation.newNetworkAttachment(updatedNetwork, entity, networkAttachmentId);
                hostSetupNetworksParameters.getNetworkAttachments().add(updatedNetworkAttachment);
                sourceListModel.setConfirmWindow(null);
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH || operation == NetworkOperation.JOIN_BONDS) {
        final SetupNetworksBondModel bondPopup;
        final List<VdsNetworkInterface> srcIfaces = new ArrayList<>();
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp1()).getIface());
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp2()).getIface());
        if (operation == NetworkOperation.BOND_WITH) {
            bondPopup = new SetupNetworksAddBondModel(getFreeBonds(), nextBondName);
        } else {
            bondPopup = new SetupNetworksJoinBondsModel(getFreeBonds(), (BondNetworkInterfaceModel) networkCommand.getOp1(), (BondNetworkInterfaceModel) networkCommand.getOp2());
        }
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                VdsNetworkInterface bond = new Bond(bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = new ArrayList<>();
                networks.addAll(nic1.getItems());
                networks.addAll(nic2.getItems());
                networkCommand.execute(bond);
                redraw();
                // Attach the previous networks
                commitNetworkChanges(bond, networks);
                // Attach previous labels
                commitLabelChanges(srcIfaces, bond);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else if (networkCommand.getOp1() == getNewNetworkLabelModel()) {
        final SetupNetworksLabelModel labelPopup = new SetupNetworksLabelModel(dcLabels);
        labelPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!labelPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                String label = labelPopup.getLabel().getEntity();
                dcLabels.add(label);
                NetworkOperation.LABEL.getCommand(new NetworkLabelModel(label, HostSetupNetworksModel.this), networkCommand.getOp2(), hostSetupNetworksParametersData).execute();
                redraw();
            }
        }));
        popupWindow = labelPopup;
    } else {
        // just execute the command
        networkCommand.execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#method_after
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH || operation == NetworkOperation.JOIN_BONDS) {
        final SetupNetworksBondModel bondPopup;
        VdsNetworkInterface iface1 = ((NetworkInterfaceModel) networkCommand.getOp1()).getEntity();
        VdsNetworkInterface iface2 = ((NetworkInterfaceModel) networkCommand.getOp2()).getEntity();
        if (operation == NetworkOperation.BOND_WITH) {
            bondPopup = new SetupNetworksAddBondModel(getFreeBonds(), nextBondName, Arrays.asList(iface1, iface2), getFreeLabels(), labelToIface);
        } else {
            bondPopup = new SetupNetworksJoinBondsModel(getFreeBonds(), (BondNetworkInterfaceModel) networkCommand.getOp1(), (BondNetworkInterfaceModel) networkCommand.getOp2(), getFreeLabels(), labelToIface);
        }
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = new ArrayList<>();
                networks.addAll(nic1.getItems());
                networks.addAll(nic2.getItems());
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(bondPopup.getLabelsModel(), networks);
                if (!validateLabelChanges(potentialNetworks)) {
                    return;
                }
                VdsNetworkInterface bond = new Bond(bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                networkCommand.execute(bond);
                redraw();
                // Attach the previous networks
                commitLabelChanges(bondPopup.getLabelsModel(), bond, potentialNetworks);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else {
        // just execute the command
        networkCommand.execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#end_block

#method_before
private void onNicsChanged() {
    operationFactory = new NetworkOperationFactory(getNetworks(), getNics());
    validate();
}
#method_after
protected void onNicsChanged() {
    operationFactory = new NetworkOperationFactory(getNetworks(), getNics());
    validate();
}
#end_block

#method_before
private void initAllModels(boolean fetchFromBackend) {
    if (fetchFromBackend) {
        // run query for networks, this chains the query for nics, and also stops progress when done
        startProgress(null);
        queryLabels();
    } else {
        initLabelModels();
        initNetworkModels();
        initNicModels();
    }
}
#method_after
private void initAllModels(boolean fetchFromBackend) {
    if (fetchFromBackend) {
        // run query for networks, this chains the query for nics, and also stops progress when done
        startProgress(null);
        queryNetworks();
    } else {
        initNetworkModels();
        initNicModels();
    }
}
#end_block

#method_before
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<>();
    for (Network network : allNetworks) {
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, this);
        networkModels.put(network.getName(), networkModel);
        if (networkModel.isManagement()) {
            managementNetworkModel = networkModel;
        }
        if (!network.isExternal()) {
            String label = network.getLabel();
            if (label != null) {
                // The network model is candidate to be drawn as part of the label.
                // This doesn't yet consider whether it actually exists on the interface.
                networkLabelMap.get(label).getNetworks().add(networkModel);
            }
        }
    }
    setNetworks(networkModels);
}
#method_after
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<>();
    networkLabelMap = new HashMap<>();
    for (Network network : allNetworks) {
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, this);
        networkModels.put(network.getName(), networkModel);
        if (!network.isExternal()) {
            NetworkLabelModel labelModel = networkLabelMap.get(network.getLabel());
            if (labelModel == null) {
                labelModel = new NetworkLabelModel(network.getLabel(), this);
                networkLabelMap.put(network.getLabel(), labelModel);
            }
            // The network model is candidate to be drawn as part of the label.
            // This doesn't yet consider whether it actually exists on the interface.
            labelModel.getNetworks().add(networkModel);
        }
    }
    setNetworks(networkModels);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface = new HashMap<>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    if (!labelModel.getNetworks().isEmpty()) {
                        nicLabels.add(labelModel);
                    }
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
private void initLabeledNetworksErrorMessages(List<LogicalNetworkModel> errorLabelNetworks, Map<String, NetworkInterfaceModel> nicModels) {
    for (LogicalNetworkModel networkModel : errorLabelNetworks) {
        NetworkInterfaceModel desiredNic = nicModels.get(labelToIface.get(networkModel.getNetwork().getLabel()));
        NetworkOperation operation = NetworkOperationFactory.operationFor(networkModel, desiredNic);
        UIMessages messages = ConstantsManager.getInstance().getMessages();
        // Should be attached but can't due to conflict
        if (operation.isNullOperation()) {
            networkModel.setErrorMessage(messages.networkLabelConflict(desiredNic.getName(), networkModel.getNetwork().getLabel()) + " " + // $NON-NLS-1$
            operation.getMessage(networkModel, desiredNic));
        } else {
            networkModel.setErrorMessage(messages.labeledNetworkNotAttached(desiredNic.getName(), networkModel.getNetwork().getLabel()));
        }
    }
}
#method_after
private void initLabeledNetworksErrorMessages(List<LogicalNetworkModel> errorLabelNetworks, Map<String, NetworkInterfaceModel> nicModels) {
    for (LogicalNetworkModel networkModel : errorLabelNetworks) {
        NetworkInterfaceModel desiredNic = nicModels.get(labelToIface.get(networkModel.getEntity().getLabel()));
        NetworkOperation operation = NetworkOperationFactory.operationFor(networkModel, desiredNic);
        UIMessages messages = ConstantsManager.getInstance().getMessages();
        // Should be attached but can't due to conflict
        if (operation.isNullOperation()) {
            networkModel.setErrorMessage(messages.networkLabelConflict(desiredNic.getName(), networkModel.getEntity().getLabel()) + " " + // $NON-NLS-1$
            operation.getMessage(networkModel, desiredNic));
        } else {
            networkModel.setErrorMessage(messages.labeledNetworkNotAttached(desiredNic.getName(), networkModel.getEntity().getLabel()));
        }
    }
}
#end_block

#method_before
private void queryLabels() {
    AsyncDataProvider.getInstance().getNetworkLabelsByDataCenterId(getEntity().getStoragePoolId(), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            dcLabels = (SortedSet<String>) returnValue;
            initLabelModels();
            // chain the networks query
            queryNetworks();
        }
    }));
}
#method_after
private void queryLabels() {
    AsyncDataProvider.getInstance().getNetworkLabelsByDataCenterId(getEntity().getStoragePoolId(), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            dcLabels = (SortedSet<String>) returnValue;
            initNicModels();
            stopProgress();
        }
    }));
}
#end_block

#method_before
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allBonds = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initNicModels();
            hostSetupNetworksParametersData.allNics = allNics;
            hostSetupNetworksParametersData.existingNetworkAttachments = existingNetworkAttachments;
            stopProgress();
        }
    };
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), asyncQuery);
}
#method_after
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allBonds = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // chain the DC labels query
            queryLabels();
        }
    };
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), asyncQuery);
}
#end_block

#method_before
private void queryNetworkAttachments() {
    // query for network attachments
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValueObj) {
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) returnValueObj;
            Object returnValue2 = returnValue.getReturnValue();
            HostSetupNetworksModel.this.existingNetworkAttachments = (List<NetworkAttachment>) returnValue2;
            // chain the vfsConfig query
            queryVfsConfig();
        }
    };
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkAttachmentsByHostId, params, asyncQuery);
}
#method_after
private void queryNetworkAttachments() {
    // query for network attachments
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValueObj) {
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) returnValueObj;
            Object returnValue2 = returnValue.getReturnValue();
            HostSetupNetworksModel.this.allNetworkAttachments = (List<NetworkAttachment>) returnValue2;
            // chain the free bonds query
            queryFreeBonds();
        }
    };
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkAttachmentsByHostId, params, asyncQuery);
}
#end_block

#method_before
private void validate() {
    // check if management network is attached
    if (!managementNetworkModel.isAttached()) {
        okCommand.getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().mgmtNotAttachedToolTip());
        okCommand.setIsExecutionAllowed(false);
    } else {
        okCommand.setIsExecutionAllowed(true);
    }
}
#method_after
private void validate() {
    // check if management network is attached
    LogicalNetworkModel mgmtNetwork = networkMap.get(HostInterfaceListModel.ENGINE_NETWORK_NAME);
    if (!mgmtNetwork.isAttached()) {
        okCommand.getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().mgmtNotAttachedToolTip());
        okCommand.setIsExecutionAllowed(false);
    } else {
        okCommand.setIsExecutionAllowed(true);
    }
}
#end_block

#method_before
public void postOnSetupNetworks() {
    // SetupNetworksParameters params = new SetupNetworksParameters();
    // params.setInterfaces(getAllNics());
    // params.setCheckConnectivity(getCheckConnectivity().getEntity());
    // params.setConectivityTimeout(getConnectivityTimeout().getEntity());
    // params.setVdsId(getEntity().getId());
    // params.setNetworksToSync(getNetworksToSync());
    SimpleAction closeAction = getCloseAction();
    // UiAction setupNetworks = new UiVdcAction(VdcActionType.SetupNetworks, params, this, true);
    // Logger.getLogger(getClass().getName()).severe("new labels: " + //$NON-NLS-1$
    // Arrays.toString(hostSetupNetworksParametersData.addedLabels.toArray()));
    // Logger.getLogger(getClass().getName()).severe("removed labels: " +  //$NON-NLS-1$
    // Arrays.toString(hostSetupNetworksParametersData.removedLabels.toArray()));
    HostSetupNetworksParameters hostSetupNetworksParameters = createHostSetupNetworksParameters();
    UiAction setupNetworksAction = new UiVdcAction(VdcActionType.HostSetupNetworks, hostSetupNetworksParameters, this, true);
    UiAction uiAction = setupNetworksAction.then(getVfsConfigAction()).then(getCommitNetworkChangesAction()).then(getLabelUnlabelUiAction());
    setupNetworksAction.onAllExecutionsFinish(closeAction);
    setupNetworksAction.runAction();
}
#method_after
public void postOnSetupNetworks() {
    final HostSetupNetworksModel model = (HostSetupNetworksModel) sourceListModel.getWindow();
    SetupNetworksParameters params = new SetupNetworksParameters();
    params.setInterfaces(model.getAllNics());
    params.setCheckConnectivity(model.getCheckConnectivity().getEntity());
    params.setConectivityTimeout(model.getConnectivityTimeout().getEntity());
    params.setVdsId(getEntity().getId());
    params.setNetworksToSync(model.getNetworksToSync());
    model.startProgress(null);
    // Frontend.getInstance().runAction(VdcActionType.SetupNetworks, params, new IFrontendActionAsyncCallback() {
    Frontend.getInstance().runAction(VdcActionType.HostSetupNetworks, hostSetupNetworksParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                EntityModel<Boolean> commitChanges = model.getCommitChanges();
                if (commitChanges.getEntity()) {
                    new SaveNetworkConfigAction(sourceListModel, model, getEntity()).execute();
                } else {
                    model.stopProgress();
                    sourceListModel.setWindow(null);
                    sourceListModel.search();
                }
            } else {
                model.stopProgress();
            }
        }
    });
}
#end_block

#method_before
public void breakBond() {
    // remove bond name
    for (NetworkInterfaceModel bonded : getBonded()) {
        bonded.getIface().setBondName(null);
    }
}
#method_after
public void breakBond() {
    // remove bond name
    for (NetworkInterfaceModel bonded : getBonded()) {
        bonded.getEntity().setBondName(null);
    }
}
#end_block

#method_before
public String getBondOptions() {
    return getIface().getBondOptions();
}
#method_after
public String getBondOptions() {
    return getEntity().getBondOptions();
}
#end_block

#method_before
private static NetworkOperation handleUnaryOperation(NetworkItemModel<?> op1, boolean isDrag) {
    // op1 is a bond, break it
    if (op1 instanceof BondNetworkInterfaceModel) {
        return NetworkOperation.BREAK_BOND;
    }
    // op1 is an interface, if it's bonded remove from bond
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel nic = (NetworkInterfaceModel) op1;
        if (nic.isBonded()) {
            return NetworkOperation.REMOVE_FROM_BOND;
        } else {
            return NetworkOperation.NULL_OPERATION;
        }
    }
    // op1 is a network, detach it if already attached to a NIC
    if (op1 instanceof LogicalNetworkModel) {
        LogicalNetworkModel network = (LogicalNetworkModel) op1;
        if (network.isAttached()) {
            if (!network.isManaged()) {
                if (isDrag) {
                    return NetworkOperation.NULL_OPERATION_UNMANAGED;
                } else {
                    return NetworkOperation.REMOVE_UNMANAGED_NETWORK;
                }
            } else {
                return NetworkOperation.DETACH_NETWORK;
            }
        } else {
            return NetworkOperation.NULL_OPERATION;
        }
    }
    // op1 is a label, if an interface is labelled with it - unlabel
    if (op1 instanceof NetworkLabelModel) {
        NetworkLabelModel label = (NetworkLabelModel) op1;
        if (label.isAttached()) {
            return NetworkOperation.UNLABEL;
        } else {
            return NetworkOperation.NULL_OPERATION;
        }
    }
    return NetworkOperation.NULL_OPERATION;
}
#method_after
private static NetworkOperation handleUnaryOperation(NetworkItemModel<?> op1, boolean isDrag) {
    // op1 is a bond, break it
    if (op1 instanceof BondNetworkInterfaceModel) {
        return NetworkOperation.BREAK_BOND;
    }
    // op1 is an interface, if it's bonded remove from bond
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel nic = (NetworkInterfaceModel) op1;
        if (nic.isBonded()) {
            return NetworkOperation.REMOVE_FROM_BOND;
        } else {
            return NetworkOperation.NULL_OPERATION;
        }
    }
    // op1 is a network, detach it if already attached to a NIC
    if (op1 instanceof LogicalNetworkModel) {
        LogicalNetworkModel network = (LogicalNetworkModel) op1;
        if (network.isAttached()) {
            if (!network.isManaged()) {
                if (isDrag) {
                    return NetworkOperation.NULL_OPERATION_UNMANAGED;
                } else {
                    return NetworkOperation.REMOVE_UNMANAGED_NETWORK;
                }
            } else {
                return NetworkOperation.DETACH_NETWORK;
            }
        } else {
            return NetworkOperation.NULL_OPERATION;
        }
    }
    return NetworkOperation.NULL_OPERATION;
}
#end_block

#method_before
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            // TODO MM: is there a place where 'A op A' is valid?
            return NetworkOperation.NULL_OPERATION;
        } else {
            networks.addAll(src.getItems());
        }
    } else if (op1 instanceof LogicalNetworkModel) {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (!networks.add((LogicalNetworkModel) op1)) {
            return NetworkOperation.NULL_OPERATION;
        }
    } else if (op1 instanceof NetworkLabelModel) {
        // op1 is a label, verify that it's not applied to the interface already labelled by it
        NetworkLabelModel src = (NetworkLabelModel) op1;
        if (dst.equals(src.getInterface())) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getNetworks());
    }
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BATCH_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getNetwork().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_TOO_MANY_NON_VLANS;
            }
        } else {
            if (nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BATCH_VM_WITH_VLANS;
                }
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    if (op1 instanceof NetworkLabelModel) {
        return NetworkOperation.LABEL;
    }
    return NetworkOperation.NULL_OPERATION;
}
#method_after
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            // TODO MM: is there a place where 'A op A' is valid?
            return NetworkOperation.NULL_OPERATION;
        } else {
            networks.addAll(((NetworkInterfaceModel) op1).getItems());
        }
    } else {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (op1 instanceof LogicalNetworkModel) {
            if (!networks.add((LogicalNetworkModel) op1)) {
                return NetworkOperation.NULL_OPERATION;
            }
        }
    }
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1 instanceof NetworkInterfaceModel) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BOND_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1 instanceof NetworkInterfaceModel) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BOND_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getEntity().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1 instanceof NetworkInterfaceModel) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BOND_TOO_MANY_NON_VLANS;
            }
        } else {
            if (nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1 instanceof NetworkInterfaceModel) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BOND_VM_WITH_VLANS;
                }
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    return NetworkOperation.NULL_OPERATION;
}
#end_block

#method_before
private static boolean noValidOperationForFirstOperand(NetworkItemModel<?> op1) {
    // no valid operation for external networks or networks attached via label
    if (op1 instanceof LogicalNetworkModel) {
        LogicalNetworkModel network = (LogicalNetworkModel) op1;
        if (network.getNetwork().isExternal() || network.isAttachedViaLabel()) {
            return true;
        }
    }
    return false;
}
#method_after
private static boolean noValidOperationForFirstOperand(NetworkItemModel<?> op1) {
    // no valid operation for external networks or networks attached via label
    if (op1 instanceof LogicalNetworkModel) {
        LogicalNetworkModel network = (LogicalNetworkModel) op1;
        if (network.getEntity().isExternal() || network.isAttachedViaLabel()) {
            return true;
        }
    }
    // no valid operation for network labels
    if (op1 instanceof NetworkLabelModel) {
        return true;
    }
    return false;
}
#end_block

#method_before
public Map<NetworkOperation, List<NetworkCommand>> commandsFor(NetworkItemModel<?> item, DataFromHostSetupNetworksModel dataFromHostSetupNetworksModel) {
    Map<NetworkOperation, List<NetworkCommand>> operations = new HashMap<>();
    // with nics
    for (NetworkInterfaceModel nic : nics) {
        NetworkOperation operation = operationFor(item, nic);
        if (!operation.isNullOperation()) {
            assertBinary(item, nic, operation);
            NetworkCommand command = operation.getCommand(item, nic, dataFromHostSetupNetworksModel);
            addToOperationMultiMap(operations, operation, command);
        }
    }
    // with networks
    for (LogicalNetworkModel network : allNetworks) {
        NetworkOperation operation = operationFor(item, network);
        if (!operation.isNullOperation()) {
            assertBinary(item, network, operation);
            NetworkCommand command = operation.getCommand(item, network, dataFromHostSetupNetworksModel);
            addToOperationMultiMap(operations, operation, command);
        }
    }
    // with self
    NetworkOperation operation = operationFor(item, null);
    if (!operation.isNullOperation()) {
        assert operation.isUnary() : // $NON-NLS-1$
        "Operation " + operation.name() + " is Binary, while a Uniary Operation is expected for " + // $NON-NLS-1$
        item.getName();
        NetworkCommand command = operation.getCommand(item, null, dataFromHostSetupNetworksModel);
        addToOperationMultiMap(operations, operation, command);
    }
    return operations;
}
#method_after
public Map<NetworkOperation, List<NetworkCommand>> commandsFor(NetworkItemModel<?> item, List<VdsNetworkInterface> allNics, List<NetworkAttachment> allNetworkAttachments, HostSetupNetworksParameters hostSetupNetworksParameters) {
    Map<NetworkOperation, List<NetworkCommand>> operations = new HashMap<>();
    // with nics
    for (NetworkInterfaceModel nic : nics) {
        NetworkOperation operation = operationFor(item, nic);
        if (!operation.isNullOperation()) {
            assertBinary(item, nic, operation);
            NetworkCommand command = operation.getCommand(item, nic, allNics, allNetworkAttachments, hostSetupNetworksParameters);
            addToOperationMultiMap(operations, operation, command);
        }
    }
    // with networks
    for (LogicalNetworkModel network : allNetworks) {
        NetworkOperation operation = operationFor(item, network);
        if (!operation.isNullOperation()) {
            assertBinary(item, network, operation);
            NetworkCommand command = operation.getCommand(item, network, allNics, allNetworkAttachments, hostSetupNetworksParameters);
            addToOperationMultiMap(operations, operation, command);
        }
    }
    // with self
    NetworkOperation operation = operationFor(item, null);
    if (!operation.isNullOperation()) {
        assert operation.isUnary() : // $NON-NLS-1$
        "Operation " + operation.name() + " is Binary, while a Uniary Operation is expected for " + // $NON-NLS-1$
        item.getName();
        NetworkCommand command = operation.getCommand(item, null, allNics, allNetworkAttachments, hostSetupNetworksParameters);
        addToOperationMultiMap(operations, operation, command);
    }
    return operations;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    when(logicalNetworkModelOfNetworkA.getNetwork()).thenReturn(networkA);
    when(logicalNetworkModelOfNetworkC.getNetwork()).thenReturn(networkC);
    when(networkInterfaceModelOfNicA.getIface()).thenReturn(nicA);
    when(networkInterfaceModelOfNicB.getIface()).thenReturn(nicB);
    when(networkInterfaceModelOfNicC.getIface()).thenReturn(nicC);
    when(networkInterfaceModelOfNicD.getIface()).thenReturn(nicD);
    // mock manager/resolver so it's possible to delegate from one NetworkOperation to another.
    ConstantsManager constantsManagerMock = Mockito.mock(ConstantsManager.class);
    UIMessages uiMessagesMock = Mockito.mock(UIMessages.class);
    when(constantsManagerMock.getMessages()).thenReturn(uiMessagesMock);
    // $NON-NLS-1$
    when(uiMessagesMock.detachNetwork(anyString())).thenReturn("doh");
    ConstantsManager.setInstance(constantsManagerMock);
    TypeResolver typeResolverMock = Mockito.mock(TypeResolver.class);
    TypeResolver.setInstance(typeResolverMock);
}
#method_after
@Before
public void setUp() throws Exception {
    when(logicalNetworkModelOfNetworkA.getEntity()).thenReturn(networkA);
    when(logicalNetworkModelOfNetworkC.getEntity()).thenReturn(networkC);
    when(networkInterfaceModelOfNicA.getEntity()).thenReturn(nicA);
    when(networkInterfaceModelOfNicB.getEntity()).thenReturn(nicB);
    when(networkInterfaceModelOfNicC.getEntity()).thenReturn(nicC);
    when(networkInterfaceModelOfNicD.getEntity()).thenReturn(nicD);
    // mock manager/resolver so it's possible to delegate from one NetworkOperation to another.
    ConstantsManager constantsManagerMock = Mockito.mock(ConstantsManager.class);
    UIMessages uiMessagesMock = Mockito.mock(UIMessages.class);
    when(constantsManagerMock.getMessages()).thenReturn(uiMessagesMock);
    // $NON-NLS-1$
    when(uiMessagesMock.detachNetwork(anyString())).thenReturn("doh");
    ConstantsManager.setInstance(constantsManagerMock);
    TypeResolver typeResolverMock = Mockito.mock(TypeResolver.class);
    TypeResolver.setInstance(typeResolverMock);
}
#end_block

#method_before
@Test
public void testCreatingBrandNewNetworkAttachment() throws Exception {
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    NetworkOperation.ATTACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, networkInterfaceModelOfNicA, dataFromHostSetupNetworksModel);
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(1));
    NetworkAttachment networkAttachment = dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.iterator().next();
    assertNetworkAttachment(networkAttachment, null, networkA.getId(), nicA.getId());
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.isEmpty(), is(true));
}
#method_after
@Test
public void testCreatingBrandNewNetworkAttachment() throws Exception {
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    NetworkOperation.ATTACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, networkInterfaceModelOfNicA, allNics, allNetworkAttachments, hsnp);
    assertThat(hsnp.getNetworkAttachments().size(), is(1));
    NetworkAttachment networkAttachment = hsnp.getNetworkAttachments().iterator().next();
    assertNetworkAttachment(networkAttachment, null, networkA.getId(), nicA.getId());
    assertThat(hsnp.getRemovedNetworkAttachments().isEmpty(), is(true));
}
#end_block

#method_before
@Test
public void testReattachingPreexistingNetworkAfterItsBeingDetached() throws Exception {
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA, networkAttachmentId);
    existingNetworkAttachments.add(networkAttachment);
    dataFromHostSetupNetworksModel.removedNetworkAttachments.add(networkAttachment);
    NetworkOperation.ATTACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, networkInterfaceModelOfNicA, dataFromHostSetupNetworksModel);
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(1));
    NetworkAttachment updatedNetworkAttachment = dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.iterator().next();
    assertNetworkAttachment(updatedNetworkAttachment, networkAttachmentId, networkA.getId(), nicA.getId());
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(0));
}
#method_after
@Test
public void testReattachingPreexistingNetworkAfterItsBeingDetached() throws Exception {
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA, networkAttachmentId);
    allNetworkAttachments.add(networkAttachment);
    hsnp.getRemovedNetworkAttachments().add(networkAttachment);
    NetworkOperation.ATTACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, networkInterfaceModelOfNicA, allNics, allNetworkAttachments, hsnp);
    assertThat(hsnp.getNetworkAttachments().size(), is(1));
    NetworkAttachment updatedNetworkAttachment = hsnp.getNetworkAttachments().iterator().next();
    assertNetworkAttachment(updatedNetworkAttachment, networkAttachmentId, networkA.getId(), nicA.getId());
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(0));
}
#end_block

#method_before
@Test
public void testReattachingPreexistingNetworkToDifferentNicAfterItsBeingDetached() throws Exception {
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    when(networkInterfaceModelOfNicA.getIface()).thenReturn(nicB);
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment formerAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA, networkAttachmentId);
    existingNetworkAttachments.add(formerAttachment);
    dataFromHostSetupNetworksModel.removedNetworkAttachments.add(formerAttachment);
    NetworkOperation.ATTACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, networkInterfaceModelOfNicA, dataFromHostSetupNetworksModel);
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(1));
    assertNetworkAttachment(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.iterator().next(), networkAttachmentId, networkA.getId(), nicB.getId());
}
#method_after
@Test
public void testReattachingPreexistingNetworkToDifferentNicAfterItsBeingDetached() throws Exception {
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    when(networkInterfaceModelOfNicA.getEntity()).thenReturn(nicB);
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment formerAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA, networkAttachmentId);
    allNetworkAttachments.add(formerAttachment);
    hsnp.getRemovedNetworkAttachments().add(formerAttachment);
    NetworkOperation.ATTACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, networkInterfaceModelOfNicA, allNics, allNetworkAttachments, hsnp);
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(0));
    assertThat(hsnp.getNetworkAttachments().size(), is(1));
    assertNetworkAttachment(hsnp.getNetworkAttachments().iterator().next(), networkAttachmentId, networkA.getId(), nicB.getId());
}
#end_block

#method_before
@Test
public void testDetachingPreexistingNetworkAttachment() throws Exception {
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA, networkAttachmentId);
    existingNetworkAttachments.add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.hasVlan()).thenReturn(false);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    NetworkOperation.DETACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, null, dataFromHostSetupNetworksModel);
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(1));
    Guid removedNetworkAttachmentId = dataFromHostSetupNetworksModel.removedNetworkAttachments.iterator().next().getId();
    // $NON-NLS-1$
    assertThat("id mismatch", removedNetworkAttachmentId, is(networkAttachmentId));
}
#method_after
@Test
public void testDetachingPreexistingNetworkAttachment() throws Exception {
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA, networkAttachmentId);
    allNetworkAttachments.add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.hasVlan()).thenReturn(false);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    NetworkOperation.DETACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, null, allNics, allNetworkAttachments, hsnp);
    assertThat(hsnp.getNetworkAttachments().size(), is(0));
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(1));
    NetworkAttachment removedNetworkAttachment = hsnp.getRemovedNetworkAttachments().iterator().next();
    assertNetworkAttachment(removedNetworkAttachment, networkAttachmentId, networkA.getId(), nicA.getId());
}
#end_block

#method_before
@Test
public void testDetachingPreviouslyAddedNetworkAttachment() throws Exception {
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA);
    dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.hasVlan()).thenReturn(false);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    NetworkOperation.DETACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, null, dataFromHostSetupNetworksModel);
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(0));
}
#method_after
@Test
public void testDetachingPreviouslyAddedNetworkAttachment() throws Exception {
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA);
    hsnp.getNetworkAttachments().add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.hasVlan()).thenReturn(false);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    NetworkOperation.DETACH_NETWORK.getTarget().executeNetworkCommand(logicalNetworkModelOfNetworkA, null, allNics, allNetworkAttachments, hsnp);
    assertThat(hsnp.getNetworkAttachments().size(), is(0));
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(0));
}
#end_block

#method_before
@Test
public void testBreakingExistingBond() throws Exception {
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.<LogicalNetworkModel>emptyList());
    when(bondNetworkInterfaceModelA.getIface()).thenReturn(existingBond);
    NetworkOperation.BREAK_BOND.getTarget().executeNetworkCommand(bondNetworkInterfaceModelA, null, dataFromHostSetupNetworksModel);
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedBonds.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedBonds.size(), is(1));
    Guid removedBondId = dataFromHostSetupNetworksModel.removedBonds.iterator().next().getId();
    // $NON-NLS-1$
    assertThat("id mismatch", removedBondId, is(existingBond.getId()));
}
#method_after
@Test
public void testBreakingExistingBond() throws Exception {
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.<LogicalNetworkModel>emptyList());
    when(bondNetworkInterfaceModelA.getEntity()).thenReturn(existingBond);
    NetworkOperation.BREAK_BOND.getTarget().executeNetworkCommand(bondNetworkInterfaceModelA, null, allNics, allNetworkAttachments, hsnp);
    assertThat(hsnp.getNetworkAttachments().size(), is(0));
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(0));
    assertThat(hsnp.getBonds().size(), is(0));
    assertThat(hsnp.getRemovedBonds().size(), is(1));
    assertBond(hsnp.getRemovedBonds().iterator().next(), existingBond.getId(), Arrays.asList(nicA, nicB));
}
#end_block

#method_before
@Test
public void testBreakingNewlyCreatedBond() throws Exception {
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.<LogicalNetworkModel>emptyList());
    when(bondNetworkInterfaceModelA.getIface()).thenReturn(newlyCreatedBond);
    NetworkOperation.BREAK_BOND.getTarget().executeNetworkCommand(bondNetworkInterfaceModelA, null, dataFromHostSetupNetworksModel);
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedBonds.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedBonds.size(), is(0));
}
#method_after
@Test
public void testBreakingNewlyCreatedBond() throws Exception {
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.<LogicalNetworkModel>emptyList());
    when(bondNetworkInterfaceModelA.getEntity()).thenReturn(newlyCreatedBond);
    NetworkOperation.BREAK_BOND.getTarget().executeNetworkCommand(bondNetworkInterfaceModelA, null, allNics, allNetworkAttachments, hsnp);
    assertThat(hsnp.getNetworkAttachments().size(), is(0));
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(0));
    assertThat(hsnp.getBonds().size(), is(0));
    assertThat(hsnp.getRemovedBonds().size(), is(0));
}
#end_block

#method_before
@Test
public void testBreakingExistingBondWithNetworkAttached() throws Exception {
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, existingBond);
    existingNetworkAttachments.add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.hasVlan()).thenReturn(false);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.singletonList(logicalNetworkModelOfNetworkA));
    when(bondNetworkInterfaceModelA.getIface()).thenReturn(existingBond);
    NetworkOperation.BREAK_BOND.getTarget().executeNetworkCommand(bondNetworkInterfaceModelA, null, dataFromHostSetupNetworksModel);
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(1));
    Guid removedNetworkAttachmentId = dataFromHostSetupNetworksModel.removedNetworkAttachments.iterator().next().getId();
    // $NON-NLS-1$
    assertThat("id mismatch", removedNetworkAttachmentId, nullValue());
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedBonds.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedBonds.size(), is(1));
    Guid removedBondId = dataFromHostSetupNetworksModel.removedBonds.iterator().next().getId();
    // $NON-NLS-1$
    assertThat("id mismatch", removedBondId, is(existingBond.getId()));
}
#method_after
@Test
public void testBreakingExistingBondWithNetworkAttached() throws Exception {
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, existingBond);
    allNetworkAttachments.add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.hasVlan()).thenReturn(false);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.singletonList(logicalNetworkModelOfNetworkA));
    when(bondNetworkInterfaceModelA.getEntity()).thenReturn(existingBond);
    NetworkOperation.BREAK_BOND.getTarget().executeNetworkCommand(bondNetworkInterfaceModelA, null, allNics, allNetworkAttachments, hsnp);
    assertThat(hsnp.getNetworkAttachments().size(), is(0));
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(1));
    assertNetworkAttachment(hsnp.getRemovedNetworkAttachments().iterator().next(), networkAttachment.getId(), networkA.getId(), existingBond.getId());
    assertThat(hsnp.getBonds().size(), is(0));
    assertThat(hsnp.getRemovedBonds().size(), is(1));
    assertBond(hsnp.getRemovedBonds().iterator().next(), existingBond.getId(), Arrays.asList(nicA, nicB));
}
#end_block

#method_before
@Test
public void testBondingTwoNicsWithReattachingNetworkAttachmentOnNewlyCreatedBond() throws Exception {
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA, networkAttachmentId);
    existingNetworkAttachments.add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    when(networkInterfaceModelOfNicA.getItems()).thenReturn(Collections.singletonList(logicalNetworkModelOfNetworkA));
    NetworkOperation.BOND_WITH.getTarget().executeNetworkCommand(networkInterfaceModelOfNicA, networkInterfaceModelOfNicB, dataFromHostSetupNetworksModel, newlyCreatedBond);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    // this is not part of BOND_WITH command, it's simply called after it. BOND_WITH is actually: "detach networks and create bond".
    // in production code, probably due to some problems with listeners, this is actually called three times, luckily each time overwriting previous call.
    NetworkOperation.attachNetworks(networkInterfaceModelOfNicA, Collections.singletonList(logicalNetworkModelOfNetworkA), dataFromHostSetupNetworksModel);
    // related network attachment will be updated, not removed and created new one.
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(1));
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(0));
    assertNetworkAttachment(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.iterator().next(), networkAttachmentId, networkA.getId(), nicA.getId());
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedBonds.size(), is(1));
    assertBond(dataFromHostSetupNetworksModel.newOrModifiedBonds.iterator().next(), null, Arrays.asList(nicA, nicB));
    assertThat(dataFromHostSetupNetworksModel.removedBonds.size(), is(0));
}
#method_after
@Test
public void testBondingTwoNicsWithReattachingNetworkAttachmentOnNewlyCreatedBond() throws Exception {
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, nicA, networkAttachmentId);
    allNetworkAttachments.add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    when(networkInterfaceModelOfNicA.getItems()).thenReturn(Collections.singletonList(logicalNetworkModelOfNetworkA));
    NetworkOperation.BOND_WITH.getTarget().executeNetworkCommand(networkInterfaceModelOfNicA, networkInterfaceModelOfNicB, allNics, allNetworkAttachments, hsnp, newlyCreatedBond);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    // this is not part of BOND_WITH command, it's simply called after it. BOND_WITH is actually: "detach networks and create bond".
    // in production code, probably due to some problems with listeners, this is actually called three times, luckily each time overwriting previous call.
    NetworkOperation.attachNetworks(networkInterfaceModelOfNicA, Collections.singletonList(logicalNetworkModelOfNetworkA), allNics, allNetworkAttachments, hsnp);
    // related network attachment will be updated, not removed and created new one.
    assertThat(hsnp.getNetworkAttachments().size(), is(1));
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(0));
    assertNetworkAttachment(hsnp.getNetworkAttachments().iterator().next(), networkAttachmentId, networkA.getId(), nicA.getId());
    assertThat(hsnp.getBonds().size(), is(1));
    assertBond(hsnp.getBonds().iterator().next(), null, Arrays.asList(nicA, nicB));
    assertThat(hsnp.getRemovedBonds().size(), is(0));
}
#end_block

#method_before
@Test
public void testReBondingTwoNicsWithReattachingNetworkAttachmentOnNewlyCreatedBond() throws Exception {
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    dataFromHostSetupNetworksModel.removedBonds.add(existingBond);
    NetworkOperation.BOND_WITH.getTarget().executeNetworkCommand(networkInterfaceModelOfNicA, networkInterfaceModelOfNicB, dataFromHostSetupNetworksModel, createBond(existingBondId, existingBondName, Collections.<VdsNetworkInterface>emptyList()));
    // related network attachment will be updated, not removed and created new one.
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedBonds.size(), is(1));
    assertBond(dataFromHostSetupNetworksModel.newOrModifiedBonds.iterator().next(), existingBondId, Arrays.asList(nicA, nicB));
    assertThat(dataFromHostSetupNetworksModel.removedBonds.size(), is(0));
}
#method_after
@Test
public void testReBondingTwoNicsWithReattachingNetworkAttachmentOnNewlyCreatedBond() throws Exception {
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(false);
    hsnp.getRemovedBonds().add(existingBond);
    NetworkOperation.BOND_WITH.getTarget().executeNetworkCommand(networkInterfaceModelOfNicA, networkInterfaceModelOfNicB, allNics, allNetworkAttachments, hsnp, createBond(existingBondId, existingBondName, Collections.<VdsNetworkInterface>emptyList()));
    // related network attachment will be updated, not removed and created new one.
    assertThat(hsnp.getNetworkAttachments().size(), is(0));
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(0));
    assertThat(hsnp.getBonds().size(), is(1));
    assertBond(hsnp.getBonds().iterator().next(), existingBondId, Arrays.asList(nicA, nicB));
    assertThat(hsnp.getRemovedBonds().size(), is(0));
}
#end_block

#method_before
@Test
public void testAddingNewNicWithNetworkAttachmentToExistingBondWithoutAnyAttachment() throws Exception {
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkC, nicC, networkAttachmentId);
    existingNetworkAttachments.add(networkAttachment);
    // this can be confusing. network *is* attached but it gets detached as a part of ADD_TO_BOND, so consulting this method, it will be detached.
    when(logicalNetworkModelOfNetworkC.isAttached()).thenReturn(true, false);
    when(networkInterfaceModelOfNicC.getItems()).thenReturn(Collections.singletonList(logicalNetworkModelOfNetworkC));
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.<LogicalNetworkModel>emptyList());
    when(bondNetworkInterfaceModelA.getIface()).thenReturn(existingBond);
    NetworkOperation.ADD_TO_BOND.getTarget().executeNetworkCommand(networkInterfaceModelOfNicC, bondNetworkInterfaceModelA, dataFromHostSetupNetworksModel);
    // related network attachment will be updated, not removed and created new one.
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(1));
    assertNetworkAttachment(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.iterator().next(), networkAttachmentId, networkC.getId(), existingBondId);
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedBonds.size(), is(1));
    assertBond(dataFromHostSetupNetworksModel.newOrModifiedBonds.iterator().next(), existingBondId, Arrays.asList(nicA, nicB, nicC));
    assertThat(dataFromHostSetupNetworksModel.removedBonds.size(), is(0));
}
#method_after
@Test
public void testAddingNewNicWithNetworkAttachmentToExistingBondWithoutAnyAttachment() throws Exception {
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkC, nicC, networkAttachmentId);
    allNetworkAttachments.add(networkAttachment);
    // this can be confusing. network *is* attached but it gets detached as a part of ADD_TO_BOND, so consulting this method, it will be detached.
    when(logicalNetworkModelOfNetworkC.isAttached()).thenReturn(true, false);
    when(networkInterfaceModelOfNicC.getItems()).thenReturn(Collections.singletonList(logicalNetworkModelOfNetworkC));
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.<LogicalNetworkModel>emptyList());
    when(bondNetworkInterfaceModelA.getEntity()).thenReturn(existingBond);
    NetworkOperation.ADD_TO_BOND.getTarget().executeNetworkCommand(networkInterfaceModelOfNicC, bondNetworkInterfaceModelA, allNics, allNetworkAttachments, hsnp);
    // related network attachment will be updated, not removed and created new one.
    assertThat(hsnp.getNetworkAttachments().size(), is(1));
    assertNetworkAttachment(hsnp.getNetworkAttachments().iterator().next(), networkAttachmentId, networkC.getId(), existingBondId);
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(0));
    assertThat(hsnp.getBonds().size(), is(1));
    assertBond(hsnp.getBonds().iterator().next(), existingBondId, Arrays.asList(nicA, nicB, nicC));
    assertThat(hsnp.getRemovedBonds().size(), is(0));
}
#end_block

#method_before
@Test
public void testRemoveSlaveFromBond() throws Exception {
    Bond bond = createBond(existingBondId, existingBondName, Arrays.asList(nicA, nicB, nicC));
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, bond, networkAttachmentId);
    existingNetworkAttachments.add(networkAttachment);
    when(bondNetworkInterfaceModelA.getIface()).thenReturn(bond);
    when(networkInterfaceModelOfNicA.getBond()).thenReturn(bondNetworkInterfaceModelA);
    when(bondNetworkInterfaceModelA.getIface()).thenReturn(bond);
    NetworkOperation.REMOVE_FROM_BOND.getTarget().executeNetworkCommand(networkInterfaceModelOfNicA, null, dataFromHostSetupNetworksModel);
    // related network attachment will be updated, not removed and created new one.
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedBonds.size(), is(1));
    assertBond(dataFromHostSetupNetworksModel.newOrModifiedBonds.iterator().next(), existingBondId, Arrays.asList(nicB, nicC));
    assertThat(dataFromHostSetupNetworksModel.removedBonds.size(), is(0));
}
#method_after
@Test
public void testRemoveSlaveFromBond() throws Exception {
    Bond bond = createBond(existingBondId, existingBondName, Arrays.asList(nicA, nicB, nicC));
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, bond, networkAttachmentId);
    allNetworkAttachments.add(networkAttachment);
    when(bondNetworkInterfaceModelA.getEntity()).thenReturn(bond);
    when(networkInterfaceModelOfNicA.getBond()).thenReturn(bondNetworkInterfaceModelA);
    when(bondNetworkInterfaceModelA.getEntity()).thenReturn(bond);
    NetworkOperation.REMOVE_FROM_BOND.getTarget().executeNetworkCommand(networkInterfaceModelOfNicA, null, allNics, allNetworkAttachments, hsnp);
    // related network attachment will be updated, not removed and created new one.
    assertThat(hsnp.getNetworkAttachments().size(), is(0));
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(0));
    assertThat(hsnp.getBonds().size(), is(1));
    assertBond(hsnp.getBonds().iterator().next(), existingBondId, Arrays.asList(nicB, nicC));
    assertThat(hsnp.getRemovedBonds().size(), is(0));
}
#end_block

#method_before
@Test
public void testJoiningBonds() throws Exception {
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, existingBond, networkAttachmentId);
    Guid bondBId = Guid.newGuid();
    // $NON-NLS-1$
    Bond bondB = createBond(bondBId, "bondB", Arrays.asList(nicC, nicD));
    existingNetworkAttachments.add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.singletonList(logicalNetworkModelOfNetworkA));
    when(bondNetworkInterfaceModelA.getIface()).thenReturn(existingBond);
    when(bondNetworkInterfaceModelA.getBonded()).thenReturn(Arrays.asList(networkInterfaceModelOfNicA, networkInterfaceModelOfNicB));
    when(bondNetworkInterfaceModelB.getItems()).thenReturn(Collections.<LogicalNetworkModel>emptyList());
    when(bondNetworkInterfaceModelB.getIface()).thenReturn(bondB);
    when(bondNetworkInterfaceModelB.getBonded()).thenReturn(Arrays.asList(networkInterfaceModelOfNicC, networkInterfaceModelOfNicD));
    NetworkOperation.JOIN_BONDS.getTarget().executeNetworkCommand(bondNetworkInterfaceModelA, bondNetworkInterfaceModelB, dataFromHostSetupNetworksModel, newlyCreatedBond);
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedNetworkAttachments.size(), is(0));
    assertThat(dataFromHostSetupNetworksModel.removedNetworkAttachments.size(), is(1));
    Guid removeNetworkAttachmentId = dataFromHostSetupNetworksModel.removedNetworkAttachments.iterator().next().getId();
    // $NON-NLS-1$
    assertThat("id mismatch", removeNetworkAttachmentId, is(networkAttachmentId));
    assertThat(dataFromHostSetupNetworksModel.newOrModifiedBonds.size(), is(1));
    assertBond(dataFromHostSetupNetworksModel.newOrModifiedBonds.iterator().next(), null, Arrays.asList(nicA, nicB, nicC, nicD));
    assertThat(dataFromHostSetupNetworksModel.removedBonds.size(), is(2));
    Iterator<Bond> removedBondsIterator = dataFromHostSetupNetworksModel.removedBonds.iterator();
    Guid firstRemovedBondId = removedBondsIterator.next().getId();
    // $NON-NLS-1$
    assertThat("id mismatch", firstRemovedBondId, is(existingBondId));
    Guid secondRemovedBondId = removedBondsIterator.next().getId();
    // $NON-NLS-1$
    assertThat("id mismatch", secondRemovedBondId, is(bondBId));
}
#method_after
@Test
public void testJoiningBonds() throws Exception {
    Guid networkAttachmentId = Guid.newGuid();
    NetworkAttachment networkAttachment = NetworkOperation.newNetworkAttachment(networkA, existingBond, networkAttachmentId);
    Guid bondBId = Guid.newGuid();
    // $NON-NLS-1$
    Bond bondB = createBond(bondBId, "bondB", Arrays.asList(nicC, nicD));
    allNetworkAttachments.add(networkAttachment);
    when(logicalNetworkModelOfNetworkA.isAttached()).thenReturn(true);
    when(bondNetworkInterfaceModelA.getItems()).thenReturn(Collections.singletonList(logicalNetworkModelOfNetworkA));
    when(bondNetworkInterfaceModelA.getEntity()).thenReturn(existingBond);
    when(bondNetworkInterfaceModelA.getBonded()).thenReturn(Arrays.asList(networkInterfaceModelOfNicA, networkInterfaceModelOfNicB));
    when(bondNetworkInterfaceModelB.getItems()).thenReturn(Collections.<LogicalNetworkModel>emptyList());
    when(bondNetworkInterfaceModelB.getEntity()).thenReturn(bondB);
    when(bondNetworkInterfaceModelB.getBonded()).thenReturn(Arrays.asList(networkInterfaceModelOfNicC, networkInterfaceModelOfNicD));
    NetworkOperation.JOIN_BONDS.getTarget().executeNetworkCommand(bondNetworkInterfaceModelA, bondNetworkInterfaceModelB, allNics, allNetworkAttachments, hsnp, newlyCreatedBond);
    assertThat(hsnp.getNetworkAttachments().size(), is(0));
    assertThat(hsnp.getRemovedNetworkAttachments().size(), is(1));
    assertNetworkAttachment(hsnp.getRemovedNetworkAttachments().iterator().next(), networkAttachmentId, networkA.getId(), existingBondId);
    assertThat(hsnp.getBonds().size(), is(1));
    assertBond(hsnp.getBonds().iterator().next(), null, Arrays.asList(nicA, nicB, nicC, nicD));
    assertThat(hsnp.getRemovedBonds().size(), is(2));
    Bond firstRemovedBond = hsnp.getRemovedBonds().get(0);
    assertBond(firstRemovedBond, existingBondId, Arrays.asList(nicA, nicB));
    Bond secondRemovedBond = hsnp.getRemovedBonds().get(1);
    assertBond(secondRemovedBond, bondBId, Arrays.asList(nicC, nicD));
}
#end_block

#method_before
@Override
public void executeCommand(UICommand uiCommand, Object... params) {
    NetworkCommand command = (NetworkCommand) uiCommand;
    NetworkItemModel<?> op1 = command.getOp1();
    NetworkItemModel<?> op2 = command.getOp2();
    executeNetworkCommand(op1, op2, command.getDataFromHostSetupNetworksModel(), params);
}
#method_after
@Override
public void executeCommand(UICommand uiCommand, Object... params) {
    NetworkCommand command = (NetworkCommand) uiCommand;
    NetworkItemModel<?> op1 = command.getOp1();
    NetworkItemModel<?> op2 = command.getOp2();
    List<VdsNetworkInterface> allNics = command.getAllNics();
    List<NetworkAttachment> allNetworkAttachments = command.getAllNetworkAttachments();
    HostSetupNetworksParameters hostSetupNetworksParameters = command.getHostSetupNetworksParameters();
    executeNetworkCommand(op1, op2, allNics, allNetworkAttachments, hostSetupNetworksParameters, params);
}
#end_block

#method_before
<T extends BusinessEntity<Guid> & Nameable> ValidationResult validateCoherentIdentification(String violatingEntityId, Guid referringId, String referringName, EngineMessage message, BusinessEntityMap<T> map) {
    return HostSetupNetworksValidator.validateCoherentIdentification(violatingEntityId, referringId, referringName, message, map);
}
#method_after
<T extends BusinessEntity<Guid> & Nameable> ValidationResult validateCoherentIdentification(String violatingEntityId, Guid referringId, String referringName, EngineMessage message, BusinessEntityMap<T> map) {
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(violatingEntityId, referringId, referringName, message, map);
}
#end_block

#method_before
ValidationResult nicActuallyExistsOrReferencesNewBond(NicLabel nicLabel) {
    if (nicLabel.getNicName() != null) {
        boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, bondsMap, nicLabel.getNicName(), nicLabel.getNicId());
        boolean nicIsBeingRemoved = nicLabel.getNicId() != null && params.getRemovedBonds().contains(nicLabel.getNicId());
        if (nicActuallyExistsOrReferencesNewBond && !nicIsBeingRemoved) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.INTERFACE_ON_NIC_LABEL_NOT_EXIST, ReplacementUtils.createSetVariableString("INTERFACE_ON_NIC_LABEL_NOT_EXIST_ENTITY", nicLabel.getLabel()), ReplacementUtils.createSetVariableString("interfaceName", nicLabel.getNicName()));
}
#method_after
ValidationResult nicActuallyExistsOrReferencesNewBond(NicLabel nicLabel) {
    if (nicLabel.getNicName() != null) {
        boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, bondsMap, nicLabel.getNicName(), nicLabel.getNicId());
        boolean nicIsBeingRemoved = nicLabel.getNicId() != null && params.getRemovedBonds().contains(nicLabel.getNicId());
        if (nicActuallyExistsOrReferencesNewBond && !nicIsBeingRemoved) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.INTERFACE_ON_NIC_LABEL_NOT_EXIST, ReplacementUtils.createSetVariableString("INTERFACE_ON_NIC_LABEL_NOT_EXIST_ENTITY", nicLabel.getLabel()), ReplacementUtils.createSetVariableString("interfaceName", nicLabel.getNicName() != null ? nicLabel.getNicName() : nicLabel.getNicId()));
}
#end_block

#method_before
boolean isNicActuallyExistsOrReferencesNewBond(BusinessEntityMap<VdsNetworkInterface> existingInterfacesMap, BusinessEntityMap<Bond> bondsMap, String nicName, Guid nicId) {
    return HostSetupNetworksValidator.isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, bondsMap, nicName, nicId);
}
#method_after
boolean isNicActuallyExistsOrReferencesNewBond(BusinessEntityMap<VdsNetworkInterface> existingInterfacesMap, BusinessEntityMap<Bond> bondsMap, String nicName, Guid nicId) {
    return hostSetupNetworksValidatorHelper.isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, bondsMap, nicName, nicId);
}
#end_block

#method_before
ValidationResult labelBeingAttachedToNonVlanNonSlaveInterface(NicLabel nicLabel) {
    String interfaceName = nicLabel.getNicName();
    boolean isBondSlave = shouldBeConfigureAsBondSlave(interfaceName);
    boolean isVlanDevice = NetworkUtils.isVlan(existingInterfacesMap.get(interfaceName));
    return ValidationResult.failWith(EngineMessage.LABEL_ATTACH_TO_IMPROPER_INTERFACE, ReplacementUtils.createSetVariableString("LABEL_ATTACH_TO_IMPROPER_INTERFACE_ENTITY", interfaceName)).when(isBondSlave || isVlanDevice);
}
#method_after
ValidationResult labelBeingAttachedToNonVlanNonSlaveInterface(NicLabel nicLabel) {
    String interfaceName = nicLabel.getNicName();
    boolean isBondSlave = shouldBeConfigureAsBondSlave(interfaceName);
    VdsNetworkInterface existingNic = existingInterfacesMap.get(interfaceName);
    boolean isVlanDevice = existingNic == null ? false : NetworkUtils.isVlan(existingNic);
    return ValidationResult.failWith(EngineMessage.LABEL_ATTACH_TO_IMPROPER_INTERFACE, ReplacementUtils.createSetVariableString("LABEL_ATTACH_TO_IMPROPER_INTERFACE_ENTITY", interfaceName)).when(isBondSlave || isVlanDevice);
}
#end_block

#method_before
private boolean shouldBeConfigureAsBondSlave(String interfaceName) {
    // Check if the interface was updated to be a bond's slave
    for (Bond bond : params.getBonds()) {
        if (bond.getSlaves().contains(interfaceName)) {
            return true;
        }
    }
    // The interface wasn't updated to be a slave, check if currently it is a slave.
    VdsNetworkInterface existingNic = existingInterfacesMap.get(interfaceName);
    if (existingNic.isPartOfBond()) {
        String bondName = existingNic.getBondName();
        boolean bondWasRemoved = params.getRemovedBonds().contains(bondName);
        boolean slaveWasRemovedFromBond = bondsMap.containsKey(bondName) ? !bondsMap.get(bondName).getSlaves().contains(interfaceName) : false;
        return !bondWasRemoved && !slaveWasRemovedFromBond;
    }
    return false;
}
#method_after
private boolean shouldBeConfigureAsBondSlave(String interfaceName) {
    // Check if the interface was updated to be a bond's slave
    for (Bond bond : params.getBonds()) {
        if (bond.getSlaves().contains(interfaceName)) {
            return true;
        }
    }
    // The interface wasn't updated to be a slave, check if currently it is a slave.
    VdsNetworkInterface existingNic = existingInterfacesMap.get(interfaceName);
    if (existingNic == null) {
        return false;
    }
    if (existingNic.isPartOfBond()) {
        String bondName = existingNic.getBondName();
        VdsNetworkInterface bond = existingInterfacesMap.get(bondName);
        boolean bondWasRemoved = params.getRemovedBonds().contains(bond.getId());
        boolean slaveWasRemovedFromBond = bondsMap.containsKey(bondName) ? !bondsMap.get(bondName).getSlaves().contains(interfaceName) : false;
        return !bondWasRemoved && !slaveWasRemovedFromBond;
    }
    return false;
}
#end_block

#method_before
ValidationResult labelBeingAttachedToValidBond(NicLabel nicLabel) {
    String interfaceName = nicLabel.getNicName();
    VdsNetworkInterface nic = existingInterfacesMap.get(interfaceName);
    if (nic instanceof Bond) {
        Bond bond = bondsMap.containsKey(interfaceName) ? bondsMap.get(interfaceName) : (Bond) nic;
        if (bond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.IMPROPER_BOND_IS_LABELED, ReplacementUtils.createSetVariableString("IMPROPER_BOND_IS_LABELED_ENTITY_ENTITY", bond.getName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult labelBeingAttachedToValidBond(NicLabel nicLabel) {
    String interfaceName = nicLabel.getNicName();
    VdsNetworkInterface nic = existingInterfacesMap.get(interfaceName);
    if (nic instanceof Bond) {
        Bond bond = bondsMap.containsKey(interfaceName) ? bondsMap.get(interfaceName) : (Bond) nic;
        if (bond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.IMPROPER_BOND_IS_LABELED, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_BOND_NAME, bond.getName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#end_block

#method_before
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkClusterDao, networkAttachmentDao, networkDao, vdsDao);
    return validator.validate();
}
#method_after
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkClusterDao, networkAttachmentDao, networkDao, vdsDao, Injector.get(HostSetupNetworksValidatorHelper.class));
    return validator.validate();
}
#end_block

#method_before
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = Entities.hostInterfacesByNetworkName(existingNics).get(existingNetworkAttachment.getNetworkName());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            return new ValidationResult(EngineMessage.NETWORKS_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", network.getName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = Entities.hostInterfacesByNetworkName(getExistingNics()).get(existingNetworkAttachment.getNetworkName());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            return new ValidationResult(EngineMessage.NETWORKS_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", network.getName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private List<VdsNetworkInterface> getExistingNics() {
    if (existingNics == null) {
        existingNics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getVdsId());
        for (VdsNetworkInterface iface : existingNics) {
            Network network = getNetworkBusinessEntityMap().get(iface.getNetworkName());
            HostNetworkQos hostNetworkQos = network == null ? null : qosDaoCache.get(network.getQosId());
            VdsNetworkInterface.NetworkImplementationDetails networkImplementationDetails = NetworkUtils.calculateNetworkImplementationDetails(network, hostNetworkQos, iface);
            iface.setNetworkImplementationDetails(networkImplementationDetails);
        }
    }
    return existingNics;
}
#method_after
private List<VdsNetworkInterface> getExistingNics() {
    if (existingNics == null) {
        existingNics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getVdsId());
        Map<String, List<String>> bondToSlaves = new HashMap<>();
        fillBondSlaves(bondToSlaves);
        for (VdsNetworkInterface iface : existingNics) {
            Network network = getNetworkBusinessEntityMap().get(iface.getNetworkName());
            HostNetworkQos hostNetworkQos = network == null ? null : qosDaoCache.get(network.getQosId());
            VdsNetworkInterface.NetworkImplementationDetails networkImplementationDetails = NetworkUtils.calculateNetworkImplementationDetails(network, hostNetworkQos, iface);
            iface.setNetworkImplementationDetails(networkImplementationDetails);
        }
    }
    return existingNics;
}
#end_block

#method_before
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    Map<String, VdsNetworkInterface> nicsToConfigureByName = getNicsToConfigureByNameWithoutLabelsUpdates();
    updateLabelsOnNicsToConfigure(nicsToConfigureByName);
    return new ArrayList<>(nicsToConfigureByName.values());
}
#method_after
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> nicsToConfigure = getNicsToConfigureWithoutLabelsUpdates();
    updateLabelsOnNicsToConfigure(nicsToConfigure);
    return nicsToConfigure;
}
#end_block

#method_before
private void updateLabelsOnNicsToConfigure(Map<String, VdsNetworkInterface> nicsToConfigureByName) {
    // Clear the labels from the removed bonds
    for (VdsNetworkInterface existingBondToRemove : getRemovedBonds()) {
        nicsToConfigureByName.get(existingBondToRemove.getName()).setLabels(null);
    }
    // Add labels to nics according to <code>getParameters().getLabels()</code>
    for (NicLabel nicLabel : getParameters().getLabels()) {
        VdsNetworkInterface nic = nicsToConfigureByName.get(nicLabel.getNicName());
        Set<String> labelsOnNic = nic.getLabels();
        if (labelsOnNic == null) {
            labelsOnNic = new HashSet<String>();
            nic.setLabels(labelsOnNic);
        }
        labelsOnNic.add(nicLabel.getLabel());
    }
    // Remove labels from nics according to <code>getParameters().getRemovedLabels()</code>
    Map<String, VdsNetworkInterface> labelToNic = getLabelToNic(nicsToConfigureByName.values());
    for (String removedLabel : getParameters().getRemovedLabels()) {
        VdsNetworkInterface nicWithLabel = labelToNic.get(removedLabel);
        nicWithLabel.getLabels().remove(removedLabel);
    }
}
#method_after
private void updateLabelsOnNicsToConfigure(List<VdsNetworkInterface> nicsToConfigure) {
    Map<String, VdsNetworkInterface> nicsToConfigureByName = Entities.entitiesByName(nicsToConfigure);
    clearLabelsFromRemovedBonds(nicsToConfigureByName);
    updateAddedModifiedLabelsOnNics(nicsToConfigureByName);
    updateRemovedLabelOnNics(nicsToConfigureByName);
}
#end_block

#method_before
private Map<String, VdsNetworkInterface> getLabelToNic(Collection<VdsNetworkInterface> nics) {
    Map<String, VdsNetworkInterface> labelToNic = new HashMap<>();
    for (VdsNetworkInterface nic : nics) {
        if (nic.getLabels() != null) {
            for (String label : nic.getLabels()) {
                labelToNic.put(label, nic);
            }
        }
    }
    return labelToNic;
}
#method_after
private Map<String, VdsNetworkInterface> getLabelToNic(Map<String, VdsNetworkInterface> nicsToConfigureByName) {
    Map<String, VdsNetworkInterface> labelToExistingNic = new HashMap<>();
    for (VdsNetworkInterface nic : nicsToConfigureByName.values()) {
        if (NetworkUtils.isLabeled(nic)) {
            for (String label : nic.getLabels()) {
                labelToExistingNic.put(label, nic);
            }
        }
    }
    return labelToExistingNic;
}
#end_block

#method_before
private void assertLabelBeingAttachedToNonVlanNonSlaveInterfaceFailed(HostSetupNetworksParameters params, VdsNetworkInterface attachLabelToNic) {
    List<VdsNetworkInterface> nics = Arrays.asList(attachLabelToNic);
    NicLabel nicLabel = new NicLabel(attachLabelToNic.getId(), attachLabelToNic.getName(), "lbl1");
    assertThat(createNicLabelValidator(params, nics).labelBeingAttachedToNonVlanNonSlaveInterface(nicLabel), failsWith(EngineMessage.LABEL_ATTACH_TO_IMPROPER_INTERFACE, ReplacementUtils.createSetVariableString("LABEL_ATTACH_TO_IMPROPER_INTERFACE_ENTITY", attachLabelToNic.getName())));
}
#method_after
private void assertLabelBeingAttachedToNonVlanNonSlaveInterfaceFailed(HostSetupNetworksParameters params, VdsNetworkInterface attachLabelToNic) {
    List<VdsNetworkInterface> nics = new ArrayList<>();
    nics.add(attachLabelToNic);
    if (attachLabelToNic.getBondName() != null) {
        Bond bond = new Bond(attachLabelToNic.getBondName());
        bond.setId(Guid.newGuid());
        nics.add(bond);
    }
    NicLabel nicLabel = new NicLabel(attachLabelToNic.getId(), attachLabelToNic.getName(), "lbl1");
    assertThat(createNicLabelValidator(params, nics).labelBeingAttachedToNonVlanNonSlaveInterface(nicLabel), failsWith(EngineMessage.LABEL_ATTACH_TO_IMPROPER_INTERFACE, ReplacementUtils.createSetVariableString("LABEL_ATTACH_TO_IMPROPER_INTERFACE_ENTITY", attachLabelToNic.getName())));
}
#end_block

#method_before
private void assertLabelBeingAttachedToValidBondFailed(HostSetupNetworksParameters params, VdsNetworkInterface nic) {
    List<VdsNetworkInterface> nics = Arrays.asList(nic);
    NicLabel nicLabel = new NicLabel(nic.getId(), nic.getName(), "lbl1");
    assertThat(createNicLabelValidator(params, nics).labelBeingAttachedToValidBond(nicLabel), failsWith(EngineMessage.IMPROPER_BOND_IS_LABELED, ReplacementUtils.createSetVariableString("IMPROPER_BOND_IS_LABELED_ENTITY_ENTITY", nic.getName())));
}
#method_after
private void assertLabelBeingAttachedToValidBondFailed(HostSetupNetworksParameters params, VdsNetworkInterface nic) {
    List<VdsNetworkInterface> nics = Arrays.asList(nic);
    NicLabel nicLabel = new NicLabel(nic.getId(), nic.getName(), "lbl1");
    assertThat(createNicLabelValidator(params, nics).labelBeingAttachedToValidBond(nicLabel), failsWith(EngineMessage.IMPROPER_BOND_IS_LABELED, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_BOND_NAME, nic.getName())));
}
#end_block

#method_before
private NicLabelValidator createNicLabelValidator(HostSetupNetworksParameters params, List<VdsNetworkInterface> nics) {
    NicLabelValidator validator = new NicLabelValidator(params, new BusinessEntityMap<>(nics), new BusinessEntityMap<>(params.getBonds()));
    return validator;
}
#method_after
private NicLabelValidator createNicLabelValidator(HostSetupNetworksParameters params, List<VdsNetworkInterface> nics) {
    NicLabelValidator validator = new NicLabelValidator(params, new BusinessEntityMap<>(nics), new BusinessEntityMap<>(params.getBonds()), new HostSetupNetworksValidatorHelper());
    return validator;
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap).validate();
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    return vr;
}
#method_after
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    return vr;
}
#end_block

#method_before
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return validateCoherentIdentification(violatingEntityId == null ? null : violatingEntityId.toString(), networkId, networkName, EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#method_after
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(String.valueOf(violatingEntityId), networkId, networkName, EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentIdentification(attachment.getId() == null ? null : attachment.getId().toString(), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(String.valueOf(attachment.getId()), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return validateCoherentIdentification(bond.getName(), nicId, nicName, message, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(bond.getName(), nicId, nicName, message, existingInterfacesMap);
}
#end_block

#method_before
private boolean isNicActuallyExistsOrReferencesNewBond(String nicName, Guid nicId) {
    return isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, bondsMap, nicName, nicId);
}
#method_after
private boolean isNicActuallyExistsOrReferencesNewBond(String nicName, Guid nicId) {
    return hostSetupNetworksValidatorHelper.isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, bondsMap, nicName, nicId);
}
#end_block

#method_before
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment attachment) {
    Network movedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = attachmentsById.get(attachment.getId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(attachment.getNicId());
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString(ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC_ENTITY, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#method_after
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment attachment) {
    Network movedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = attachmentsById.get(attachment.getId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(attachment.getNicId());
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString("networkName", movedNetwork.getName()), ReplacementUtils.createSetVariableString(ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC_ENTITY, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#end_block

#method_before
private Set<String> getLabelsToConfigureOnNic(String nicName) {
    VdsNetworkInterface existingNic = existingInterfacesMap.get(nicName);
    Set<String> labelsToConfigure = new HashSet<>();
    if (existingNic != null) {
        boolean nicWasRemoved = removedBondVdsNetworkInterfaceMap.containsKey(existingNic.getName());
        if (nicWasRemoved) {
            return null;
        }
        Set<String> oldLabels = existingNic.getLabels();
        if (oldLabels != null) {
            for (String label : oldLabels) {
                NicLabel nicLabel = nicLabelByLabel.get(label);
                boolean labelRemovedFromNic = params.getRemovedLabels().contains(label) || (nicLabel != null && nicLabel.getNicName() != existingNic.getName());
                if (!labelRemovedFromNic) {
                    labelsToConfigure.add(label);
                }
            }
        }
        for (NicLabel nicLabel : params.getLabels()) {
            if (existingNic.getName().equals(nicLabel.getNicName())) {
                labelsToConfigure.add(nicLabel.getLabel());
            }
        }
    }
    return labelsToConfigure;
}
#method_after
private Set<String> getLabelsToConfigureOnNic(String nicName) {
    VdsNetworkInterface existingNic = existingInterfacesMap.get(nicName);
    Set<String> labelsToConfigure = new HashSet<>();
    if (existingNic != null) {
        boolean nicWasRemoved = removedBondVdsNetworkInterfaceMap.containsKey(existingNic.getName());
        if (nicWasRemoved) {
            return null;
        }
        Set<String> oldLabels = existingNic.getLabels();
        if (oldLabels != null) {
            for (String label : oldLabels) {
                NicLabel nicLabel = nicLabelByLabel.get(label);
                boolean labelRemovedFromNic = params.getRemovedLabels().contains(label) || (nicLabel != null && !Objects.equals(nicLabel.getNicName(), existingNic.getName()));
                if (!labelRemovedFromNic) {
                    labelsToConfigure.add(label);
                }
            }
        }
        for (NicLabel nicLabel : params.getLabels()) {
            if (existingNic.getName().equals(nicLabel.getNicName())) {
                labelsToConfigure.add(nicLabel.getLabel());
            }
        }
    }
    return labelsToConfigure;
}
#end_block

#method_before
@Test
public void testNotMovingLabeledNetworkToDifferentNicWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setId(Guid.newGuid());
    existingNic.setName("nic1");
    VdsNetworkInterface existingNic2 = new VdsNetworkInterface();
    existingNic2.setId(Guid.newGuid());
    existingNic2.setName("nic2");
    Guid attachmentId = Guid.newGuid();
    NetworkAttachment existingNetworkAttachment = createNetworkAttachment(labeledNetwork, attachmentId);
    existingNetworkAttachment.setNicId(existingNic.getId());
    existingNetworkAttachment.setNicName(existingNic.getName());
    NetworkAttachment updatedNetworkAttachment = createNetworkAttachment(labeledNetwork, attachmentId);
    updatedNetworkAttachment.setNicId(existingNic2.getId());
    updatedNetworkAttachment.setNicName(existingNic2.getName());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(updatedNetworkAttachment));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Arrays.asList(existingNic, existingNic2), Collections.singletonList(existingNetworkAttachment), new BusinessEntityMap<>(Collections.singletonList(labeledNetwork)));
    assertThat(validator.notMovingLabeledNetworkToDifferentNic(updatedNetworkAttachment), failsWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC_ENTITY, label)));
}
#method_after
@Test
public void testNotMovingLabeledNetworkToDifferentNicWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setId(Guid.newGuid());
    existingNic.setName("nic1");
    VdsNetworkInterface existingNic2 = new VdsNetworkInterface();
    existingNic2.setId(Guid.newGuid());
    existingNic2.setName("nic2");
    Guid attachmentId = Guid.newGuid();
    NetworkAttachment existingNetworkAttachment = createNetworkAttachment(labeledNetwork, attachmentId);
    existingNetworkAttachment.setNicId(existingNic.getId());
    existingNetworkAttachment.setNicName(existingNic.getName());
    NetworkAttachment updatedNetworkAttachment = createNetworkAttachment(labeledNetwork, attachmentId);
    updatedNetworkAttachment.setNicId(existingNic2.getId());
    updatedNetworkAttachment.setNicName(existingNic2.getName());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(updatedNetworkAttachment));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Arrays.asList(existingNic, existingNic2), Collections.singletonList(existingNetworkAttachment), new BusinessEntityMap<>(Collections.singletonList(labeledNetwork)));
    assertThat(validator.notMovingLabeledNetworkToDifferentNic(updatedNetworkAttachment), failsWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString("networkName", labeledNetwork.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC_ENTITY, labeledNetwork.getLabel())));
}
#end_block

#method_before
private void notMovingLabeledNetworkToDifferentNicCommonTest(boolean nicContainslabel, boolean labelShouldBeRemovedFromNic, boolean labelShouldBeAddedToNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nicWithLabel");
    if (nicContainslabel) {
        nic.setLabels(new HashSet<>(Arrays.asList("lbl1")));
    }
    Network movedNetwork = createNetworkWithNameAndLabel("net", "lbl1");
    NetworkAttachment existingAttachment = createNetworkAttachment(movedNetwork, nic);
    NetworkAttachment updatedAttachment = new NetworkAttachment(existingAttachment);
    updatedAttachment.setNicId(Guid.newGuid());
    updatedAttachment.setNicName(nic.getName() + "not");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    if (labelShouldBeRemovedFromNic) {
        params.getRemovedLabels().add("lbl1");
    }
    if (labelShouldBeAddedToNic) {
        NicLabel nicLabel = new NicLabel(nic.getId(), nic.getName(), "lbl1");
        params.getLabels().add(nicLabel);
    }
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(params).setHost(host).setExistingInterfaces(Arrays.asList(nic)).setExistingAttachments(Arrays.asList(existingAttachment)).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Arrays.asList(movedNetwork))).build();
    if (valid) {
        assertThat(validator.notMovingLabeledNetworkToDifferentNic(updatedAttachment), isValid());
    } else {
        assertThat(validator.notMovingLabeledNetworkToDifferentNic(updatedAttachment), failsWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC_ENTITY, movedNetwork.getLabel())));
    }
}
#method_after
private void notMovingLabeledNetworkToDifferentNicCommonTest(boolean nicContainslabel, boolean labelShouldBeRemovedFromNic, boolean labelShouldBeAddedToNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nicWithLabel");
    if (nicContainslabel) {
        nic.setLabels(new HashSet<>(Arrays.asList("lbl1")));
    }
    Network movedNetwork = createNetworkWithNameAndLabel("net", "lbl1");
    NetworkAttachment existingAttachment = createNetworkAttachment(movedNetwork, nic);
    NetworkAttachment updatedAttachment = new NetworkAttachment(existingAttachment);
    updatedAttachment.setNicId(Guid.newGuid());
    updatedAttachment.setNicName(nic.getName() + "not");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    if (labelShouldBeRemovedFromNic) {
        params.getRemovedLabels().add("lbl1");
    }
    if (labelShouldBeAddedToNic) {
        NicLabel nicLabel = new NicLabel(nic.getId(), nic.getName(), "lbl1");
        params.getLabels().add(nicLabel);
    }
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(params).setHost(host).setExistingInterfaces(Arrays.asList(nic)).setExistingAttachments(Arrays.asList(existingAttachment)).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Arrays.asList(movedNetwork))).build();
    if (valid) {
        assertThat(validator.notMovingLabeledNetworkToDifferentNic(updatedAttachment), isValid());
    } else {
        assertThat(validator.notMovingLabeledNetworkToDifferentNic(updatedAttachment), failsWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString("networkName", movedNetwork.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC_ENTITY, movedNetwork.getLabel())));
    }
}
#end_block

#method_before
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, networkBusinessEntityMap, managementNetworkUtil, networkClusterDaoMock, networkAttachmentDaoMock, networkDaoMock, vdsDaoMock);
}
#method_after
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, networkBusinessEntityMap, managementNetworkUtil, networkClusterDaoMock, networkAttachmentDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper());
}
#end_block

#method_before
private HostSetupNetworksParameters createHostSetupNetworksParameters() {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(getVdsId());
    params.setRemovedLabels(new HashSet<>(Arrays.asList(getLabel())));
    return params;
}
#method_after
private HostSetupNetworksParameters createHostSetupNetworksParameters() {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(getVdsId());
    params.setRemovedLabels(Collections.singleton(getLabel()));
    return params;
}
#end_block

#method_before
public HostSetupNetworksParameters createSetupNetworkParams(VdsNetworkInterface nic) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(host.getId());
    NetworkAttachment managementAttachment = new NetworkAttachment();
    managementAttachment.setNetworkId(managementNetwork.getId());
    Map<String, VdsNetworkInterface> nicNameToNic = Entities.entitiesByName(host.getInterfaces());
    Guid baseNicId = nicNameToNic.get(NetworkUtils.stripVlan(nic)).getId();
    managementAttachment.setNicId(baseNicId);
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.getIPv4Addresses().add(createIPv4Address(nic));
    ipConfiguration.setBootProtocol(nic.getBootProtocol());
    managementAttachment.setIpConfiguration(ipConfiguration);
    parameters.getNetworkAttachments().add(managementAttachment);
    return parameters;
}
#method_after
public HostSetupNetworksParameters createSetupNetworkParams(VdsNetworkInterface nic) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(host.getId());
    NetworkAttachment managementAttachment = new NetworkAttachment();
    managementAttachment.setNetworkId(managementNetwork.getId());
    Map<String, VdsNetworkInterface> nicNameToNic = Entities.entitiesByName(host.getInterfaces());
    Guid baseNicId = nicNameToNic.get(NetworkUtils.stripVlan(nic)).getId();
    managementAttachment.setNicId(baseNicId);
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.getIPv4Addresses().add(createIPv4Address(nic));
    managementAttachment.setIpConfiguration(ipConfiguration);
    parameters.getNetworkAttachments().add(managementAttachment);
    return parameters;
}
#end_block

#method_before
public IPv4Address createIPv4Address(VdsNetworkInterface nic) {
    IPv4Address result = new IPv4Address();
    result.setAddress(nic.getAddress());
    result.setNetmask(nic.getSubnet());
    result.setGateway(nic.getGateway());
    return result;
}
#method_after
public IPv4Address createIPv4Address(VdsNetworkInterface nic) {
    IPv4Address result = new IPv4Address();
    result.setAddress(nic.getAddress());
    result.setNetmask(nic.getSubnet());
    result.setGateway(nic.getGateway());
    result.setBootProtocol(nic.getBootProtocol());
    return result;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments(getParameters(), getExistingAttachments(), getClusterNetworks());
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#end_block

#method_before
private boolean noChangesDetected() {
    return getNetworksToConfigure().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBondNames().isEmpty() && getRemovedUnmanagedNetworks().isEmpty();
}
#method_after
private boolean noChangesDetected() {
    return getNetworksToConfigure().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBondNames().isEmpty() && getRemovedUnmanagedNetworks().isEmpty() && getParameters().getLabels().isEmpty() && getParameters().getRemovedLabels().isEmpty();
}
#end_block

#method_before
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    Map<String, VdsNetworkInterface> nicsToConfigureByName = getNicsToConfigureByNameWithoutLabelsUpdates();
    updateLabelsOnNicsToConfigure(nicsToConfigureByName);
    return new ArrayList<>(nicsToConfigureByName.values());
}
#method_after
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> nicsToConfigure = getNicsToConfigureWithoutLabelsUpdates();
    updateLabelsOnNicsToConfigure(nicsToConfigure);
    return nicsToConfigure;
}
#end_block

#method_before
private void updateLabelsOnNicsToConfigure(Map<String, VdsNetworkInterface> nicsToConfigureByName) {
    // Clear the labels from the removed bonds
    for (VdsNetworkInterface existingBondToRemove : getRemovedBonds()) {
        nicsToConfigureByName.get(existingBondToRemove.getName()).setLabels(null);
    }
    // Add labels to nics according to <code>getParameters().getLabels()</code>
    for (NicLabel nicLabel : getParameters().getLabels()) {
        VdsNetworkInterface nic = nicsToConfigureByName.get(nicLabel.getNicName());
        Set<String> labelsOnNic = nic.getLabels();
        if (labelsOnNic == null) {
            labelsOnNic = new HashSet<String>();
            nic.setLabels(labelsOnNic);
        }
        labelsOnNic.add(nicLabel.getLabel());
    }
    // Remove labels from nics according to <code>getParameters().getRemovedLabels()</code>
    Map<String, VdsNetworkInterface> labelToNic = getLabelToNic(nicsToConfigureByName.values());
    for (String removedLabel : getParameters().getRemovedLabels()) {
        VdsNetworkInterface nicWithLabel = labelToNic.get(removedLabel);
        nicWithLabel.getLabels().remove(removedLabel);
    }
}
#method_after
private void updateLabelsOnNicsToConfigure(List<VdsNetworkInterface> nicsToConfigure) {
    Map<String, VdsNetworkInterface> nicsToConfigureByName = Entities.entitiesByName(nicsToConfigure);
    clearLabelsFromRemovedBonds(nicsToConfigureByName);
    updateAddedModifiedLabelsOnNics(nicsToConfigureByName);
    updateRemovedLabelOnNics(nicsToConfigureByName);
}
#end_block

#method_before
private Map<String, VdsNetworkInterface> getLabelToNic(Collection<VdsNetworkInterface> nics) {
    Map<String, VdsNetworkInterface> labelToNic = new HashMap<>();
    for (VdsNetworkInterface nic : nics) {
        if (nic.getLabels() != null) {
            for (String label : nic.getLabels()) {
                labelToNic.put(label, nic);
            }
        }
    }
    return labelToNic;
}
#method_after
private Map<String, VdsNetworkInterface> getLabelToNic(Map<String, VdsNetworkInterface> nicsToConfigureByName) {
    Map<String, VdsNetworkInterface> labelToExistingNic = new HashMap<>();
    for (VdsNetworkInterface nic : nicsToConfigureByName.values()) {
        if (NetworkUtils.isLabeled(nic)) {
            for (String label : nic.getLabels()) {
                labelToExistingNic.put(label, nic);
            }
        }
    }
    return labelToExistingNic;
}
#end_block

#method_before
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, networkBusinessEntityMap, managementNetworkUtil, networkClusterDaoMock, networkAttachmentDaoMock, networkDaoMock, vdsDaoMock);
}
#method_after
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, networkBusinessEntityMap, managementNetworkUtil, networkClusterDaoMock, networkAttachmentDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper());
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    return vr;
}
#method_after
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    return vr;
}
#end_block

#method_before
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return validateCoherentIdentification(violatingEntityId == null ? null : violatingEntityId.toString(), networkId, networkName, EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#method_after
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(String.valueOf(violatingEntityId), networkId, networkName, EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentIdentification(attachment.getId() == null ? null : attachment.getId().toString(), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(String.valueOf(attachment.getId()), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return validateCoherentIdentification(bond.getName(), nicId, nicName, message, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(bond.getName(), nicId, nicName, message, existingInterfacesMap);
}
#end_block

#method_before
private boolean isNicActuallyExistsOrReferencesNewBond(String nicName, Guid nicId) {
    return isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, bondsMap, nicName, nicId);
}
#method_after
private boolean isNicActuallyExistsOrReferencesNewBond(String nicName, Guid nicId) {
    return hostSetupNetworksValidatorHelper.isNicActuallyExistsOrReferencesNewBond(existingInterfacesMap, bondsMap, nicName, nicId);
}
#end_block

#method_before
private Set<String> getLabelsToConfigureOnNic(String nicName) {
    VdsNetworkInterface existingNic = existingInterfacesMap.get(nicName);
    Set<String> labelsToConfigure = new HashSet<>();
    if (existingNic != null) {
        boolean nicWasRemoved = removedBondVdsNetworkInterfaceMap.containsKey(existingNic.getName());
        if (nicWasRemoved) {
            return null;
        }
        Set<String> oldLabels = existingNic.getLabels();
        if (oldLabels != null) {
            for (String label : oldLabels) {
                NicLabel nicLabel = nicLabelByLabel.get(label);
                boolean labelRemovedFromNic = params.getRemovedLabels().contains(label) || (nicLabel != null && nicLabel.getNicName() != existingNic.getName());
                if (!labelRemovedFromNic) {
                    labelsToConfigure.add(label);
                }
            }
        }
        for (NicLabel nicLabel : params.getLabels()) {
            if (existingNic.getName().equals(nicLabel.getNicName())) {
                labelsToConfigure.add(nicLabel.getLabel());
            }
        }
    }
    return labelsToConfigure;
}
#method_after
private Set<String> getLabelsToConfigureOnNic(String nicName) {
    VdsNetworkInterface existingNic = existingInterfacesMap.get(nicName);
    Set<String> labelsToConfigure = new HashSet<>();
    if (existingNic != null) {
        boolean nicWasRemoved = removedBondVdsNetworkInterfaceMap.containsKey(existingNic.getName());
        if (nicWasRemoved) {
            return null;
        }
        Set<String> oldLabels = existingNic.getLabels();
        if (oldLabels != null) {
            for (String label : oldLabels) {
                NicLabel nicLabel = nicLabelByLabel.get(label);
                boolean labelRemovedFromNic = params.getRemovedLabels().contains(label) || (nicLabel != null && !Objects.equals(nicLabel.getNicName(), existingNic.getName()));
                if (!labelRemovedFromNic) {
                    labelsToConfigure.add(label);
                }
            }
        }
        for (NicLabel nicLabel : params.getLabels()) {
            if (existingNic.getName().equals(nicLabel.getNicName())) {
                labelsToConfigure.add(nicLabel.getLabel());
            }
        }
    }
    return labelsToConfigure;
}
#end_block

#method_before
private boolean isNicToConfigureContainTheLabel(String nicName, String label) {
    Set<String> labelsToConfigure = getLabelsToConfigureOnNic(nicName);
    return labelsToConfigure == null ? false : labelsToConfigure.contains(label);
}
#method_after
private boolean isNicToConfigureContainTheLabel(String nicName, String label) {
    Set<String> labelsToConfigure = getLabelsToConfigureOnNic(nicName);
    return labelsToConfigure != null && labelsToConfigure.contains(label);
}
#end_block

#method_before
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return validateCoherentIdentification(violatingEntityId == null ? null : violatingEntityId.toString(), networkId, networkName, EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#method_after
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return validateCoherentIdentification(String.valueOf(violatingEntityId), networkId, networkName, EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentIdentification(attachment.getId() == null ? null : attachment.getId().toString(), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentIdentification(String.valueOf(attachment.getId()), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (!(o instanceof NicLabel))
        return false;
    NicLabel that = (NicLabel) o;
    return Objects.equals(getNicId(), that.getNicId()) && Objects.equals(getNicName(), that.getNicName()) && Objects.equals(getLabel(), that.getLabel());
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof NicLabel)) {
        return false;
    }
    NicLabel that = (NicLabel) o;
    return Objects.equals(getNicId(), that.getNicId()) && Objects.equals(getNicName(), that.getNicName()) && Objects.equals(getLabel(), that.getLabel());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments(getParameters(), getExistingAttachments(), getClusterNetworks());
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#end_block

#method_before
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = Entities.hostInterfacesByNetworkName(existingNics).get(existingNetworkAttachment.getNetworkName());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            return new ValidationResult(EngineMessage.NETWORKS_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", network.getName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = Entities.hostInterfacesByNetworkName(getExistingNics()).get(existingNetworkAttachment.getNetworkName());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            return new ValidationResult(EngineMessage.NETWORKS_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", network.getName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private boolean noChangesDetected() {
    return getNetworksToConfigure().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBondNames().isEmpty() && getRemovedUnmanagedNetworks().isEmpty();
}
#method_after
private boolean noChangesDetected() {
    return getNetworksToConfigure().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBondNames().isEmpty() && getRemovedUnmanagedNetworks().isEmpty() && getParameters().getLabels().isEmpty() && getParameters().getRemovedLabels().isEmpty();
}
#end_block

#method_before
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    Map<String, VdsNetworkInterface> nicsToConfigureByName = getNicsToConfigureByNameWithoutLabelsUpdates();
    updateLabelsOnNicsToConfigure(nicsToConfigureByName);
    return new ArrayList<>(nicsToConfigureByName.values());
}
#method_after
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> nicsToConfigure = getNicsToConfigureWithoutLabelsUpdates();
    updateLabelsOnNicsToConfigure(nicsToConfigure);
    return nicsToConfigure;
}
#end_block

#method_before
private void updateLabelsOnNicsToConfigure(Map<String, VdsNetworkInterface> nicsToConfigureByName) {
    // Clear the labels from the removed bonds
    for (VdsNetworkInterface existingBondToRemove : getRemovedBonds()) {
        nicsToConfigureByName.get(existingBondToRemove.getName()).setLabels(null);
    }
    // Add labels to nics according to <code>getParameters().getLabels()</code>
    for (NicLabel nicLabel : getParameters().getLabels()) {
        VdsNetworkInterface nic = nicsToConfigureByName.get(nicLabel.getNicName());
        Set<String> labelsOnNic = nic.getLabels();
        if (labelsOnNic == null) {
            labelsOnNic = new HashSet<String>();
            nic.setLabels(labelsOnNic);
        }
        labelsOnNic.add(nicLabel.getLabel());
    }
    // Remove labels from nics according to <code>getParameters().getRemovedLabels()</code>
    Map<String, VdsNetworkInterface> labelToNic = getLabelToNic(nicsToConfigureByName.values());
    for (String removedLabel : getParameters().getRemovedLabels()) {
        VdsNetworkInterface nicWithLabel = labelToNic.get(removedLabel);
        nicWithLabel.getLabels().remove(removedLabel);
    }
}
#method_after
private void updateLabelsOnNicsToConfigure(List<VdsNetworkInterface> nicsToConfigure) {
    Map<String, VdsNetworkInterface> nicsToConfigureByName = Entities.entitiesByName(nicsToConfigure);
    clearLabelsFromRemovedBonds(nicsToConfigureByName);
    updateAddedModifiedLabelsOnNics(nicsToConfigureByName);
    updateRemovedLabelOnNics(nicsToConfigureByName);
}
#end_block

#method_before
private Map<String, VdsNetworkInterface> getLabelToNic(Collection<VdsNetworkInterface> nics) {
    Map<String, VdsNetworkInterface> labelToNic = new HashMap<>();
    for (VdsNetworkInterface nic : nics) {
        if (nic.getLabels() != null) {
            for (String label : nic.getLabels()) {
                labelToNic.put(label, nic);
            }
        }
    }
    return labelToNic;
}
#method_after
private Map<String, VdsNetworkInterface> getLabelToNic(Map<String, VdsNetworkInterface> nicsToConfigureByName) {
    Map<String, VdsNetworkInterface> labelToExistingNic = new HashMap<>();
    for (VdsNetworkInterface nic : nicsToConfigureByName.values()) {
        if (NetworkUtils.isLabeled(nic)) {
            for (String label : nic.getLabels()) {
                labelToExistingNic.put(label, nic);
            }
        }
    }
    return labelToExistingNic;
}
#end_block

#method_before
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return validateCoherentIdentification(violatingEntityId == null ? null : violatingEntityId.toString(), networkId, networkName, EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#method_after
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return validateCoherentIdentification(String.valueOf(violatingEntityId), networkId, networkName, EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentIdentification(attachment.getId() == null ? null : attachment.getId().toString(), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentIdentification(String.valueOf(attachment.getId()), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#end_block

#method_before
@PostConstruct
private void init() {
    hostedEngineVm = dbFacade.getVmDao().get(dbFacade.getVmStaticDao().getAllByName("HostedEngine").get(0).getId());
    VmHandler.updateDisksFromDb(hostedEngineVm);
    sd = dbFacade.getStorageDomainStaticDao().getByName(Config.<String>getValue(ConfigValues.HostedEngineStorageDomainName));
    sdConnection = dbFacade.getStorageServerConnectionDao().getAllForDomain(getStorageDomainStatic().getId()).get(0);
}
#method_after
@PostConstruct
private void init() {
    VmStatic vmStatic = dbFacade.getVmStaticDao().getAllByName(Config.<String>getValue(ConfigValues.HostedEngineVmName)).get(0);
    if (vmStatic != null) {
        hostedEngineVm = dbFacade.getVmDao().get(vmStatic.getId());
        VmHandler.updateDisksFromDb(hostedEngineVm);
        sd = dbFacade.getStorageDomainStaticDao().getByName(Config.<String>getValue(ConfigValues.HostedEngineStorageDomainName));
        if (sd != null) {
            sdConnection = dbFacade.getStorageServerConnectionDao().getAllForDomain(getStorageDomainStatic().getId()).get(0);
        }
    }
}
#end_block

#method_before
public Map<String, String> createVdsDeployParams(String hostname, String heAgentGateway) {
    HashMap params = new HashMap<>();
    VM heVm = getVm();
    params.put("fqdn", EngineLocalConfig.getInstance().getHost());
    params.put("vm_disk_id", getVmDisks().get(0).getImageId().toString());
    params.put("vm_disk_vol_id", getVmDisks().get(0).getImage().getDiskId().toString());
    params.put("vmid", heVm.getId().toString());
    params.put("storage", getStoragePath());
    params.put("conf", getBackupConfPath());
    params.put("host_id", offerHostId(getVm().getVdsGroupId()));
    params.put("domainType", getStorageType());
    params.put("spUUID", getVm().getStoragePoolId().toString());
    params.put("sdUUID", getStorageDomainStatic().getId().toString());
    params.put("connectionUUID", getConnection().getid().toString());
    params.put("iqn", getConnection().getiqn());
    params.put("portal", getConnection().getport());
    params.put("user", getConnection().getuser_name());
    params.put("password", getConnection().getpassword());
    params.put("port", getConnection().getport());
    params.put("ca_cert", getCaCertPath());
    params.put("ca_subject", hostname);
    params.put("vdsm_use_ssl", Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication).toString());
    params.put("gateway", heAgentGateway);
    return params;
}
#method_after
public Map<String, String> createVdsDeployParams(String hostname, String heAgentGateway) {
    if (hostedEngineVm == null) {
        return Collections.emptyMap();
    }
    HashMap params = new HashMap<>();
    params.put("fqdn", EngineLocalConfig.getInstance().getHost());
    params.put("vmid", hostedEngineVm.getId().toString());
    params.put("storage", sd.getConnection());
    params.put("conf", getBackupConfPath());
    params.put("host_id", offerHostId(hostedEngineVm.getVdsGroupId()));
    params.put("domainType", getStorageType());
    params.put("spUUID", hostedEngineVm.getStoragePoolId().toString());
    params.put("sdUUID", getStorageDomainStatic().getId().toString());
    params.put("connectionUUID", sdConnection.getid().toString());
    params.put("iqn", sdConnection.getiqn());
    params.put("portal", sdConnection.getport());
    params.put("user", sdConnection.getuser_name());
    params.put("password", sdConnection.getpassword());
    params.put("port", sdConnection.getport());
    params.put("ca_cert", getCaCertPath());
    params.put("ca_subject", hostname);
    params.put("vdsm_use_ssl", Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication).toString());
    params.put("gateway", heAgentGateway);
    if (hostedEngineVm.getDiskList() != null) {
        for (int i = 0; i < hostedEngineVm.getDiskList().size(); i++) {
            params.put("vm_disk_id[" + i + "]", hostedEngineVm.getDiskList().get(i).getImageId().toString());
            params.put("vm_disk_vol_id[" + i + "]", hostedEngineVm.getDiskList().get(i).getImage().getDiskId().toString());
        }
    }
    return params;
}
#end_block

#method_before
private String getStorageType() {
    StorageServerConnections connection = getConnection();
    switch(connection.getstorage_type()) {
        case NFS:
            if (connection.getNfsVersion() == NfsVersion.V4) {
                return "nfs4";
            } else {
                return "nfs3";
            }
        case ISCSI:
            return "iscsi";
        case GLUSTERFS:
            return "glusterfs";
        case FCP:
            return "fc";
    }
    throw new IllegalArgumentException("There is no legal storage type for the connection " + connection.toString());
}
#method_after
private String getStorageType() {
    switch(sdConnection.getstorage_type()) {
        case NFS:
            if (sdConnection.getNfsVersion() == NfsVersion.V4) {
                return "nfs4";
            } else {
                return "nfs3";
            }
        case ISCSI:
            return "iscsi";
        case GLUSTERFS:
            return "glusterfs";
        case FCP:
            return "fc";
    }
    throw new IllegalArgumentException("There is no legal storage type for the connection " + sdConnection.toString());
}
#end_block

#method_before
private String getCaCertPath() {
    return "/etc/pki/vdsm/libvirt-spice/ca-cert.pem";
}
#method_after
private String getCaCertPath() {
    return CA_CERT_PATH;
}
#end_block

#method_before
public boolean isVmManaged() {
    VM vm = getVm();
    return vm != null && vm.isManagedVm();
}
#method_after
public boolean isVmManaged() {
    return hostedEngineVm != null && hostedEngineVm.isManagedVm();
}
#end_block

#method_before
private ValidationResult validateStatus(VDSStatus hostStatus) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL, ReplacementUtils.createSetVariableString("hostStatus", host.getStatus().name())).unless(hostStatus == host.getStatus());
}
#method_after
private ValidationResult validateStatus(VDSStatus hostStatus) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL, ReplacementUtils.createSetVariableString("hostStatus", hostStatus.name())).unless(hostStatus == host.getStatus());
}
#end_block

#method_before
private void updateModifiedInterfaces() {
    List<VdsNetworkInterface> nicsForUpdate = prepareNicsForUpdate();
    if (!nicsForUpdate.isEmpty()) {
        interfaceDao.massUpdateInterfacesForVds(getNicsForUpdate());
    }
}
#method_after
private void updateModifiedInterfaces() {
    List<VdsNetworkInterface> nicsForUpdate = getNicsForUpdate();
    List<Guid> updateNicsIds = Entities.getIds(nicsForUpdate);
    if (!nicsForUpdate.isEmpty()) {
        interfaceDao.massClearNetworkFromNics(updateNicsIds);
        interfaceDao.massUpdateInterfacesForVds(nicsForUpdate);
    }
}
#end_block

#method_before
private List<VdsNetworkInterface> prepareNicsForUpdate() {
    List<VdsNetworkInterface> nicsForUpdate = new ArrayList<>();
    for (VdsNetworkInterface dbNic : dbNics) {
        if (reportedNicsByNames.containsKey(dbNic.getName())) {
            VdsNetworkInterface reportedNic = reportedNicsByNames.get(dbNic.getName());
            reportedNic.setId(dbNic.getId());
            if (!overrideNicWithUserConfiguration(reportedNic, userConfiguredNicsByName)) {
                reportedNic.overrideEngineManagedAttributes(dbNic);
            }
            nicsForUpdate.add(reportedNic);
        }
    }
    sortNicForUpdate(nicsForUpdate);
    return nicsForUpdate;
}
#method_after
private List<VdsNetworkInterface> prepareNicsForUpdate() {
    List<VdsNetworkInterface> nicsForUpdate = new ArrayList<>();
    for (VdsNetworkInterface dbNic : dbNics) {
        if (reportedNicsByNames.containsKey(dbNic.getName())) {
            VdsNetworkInterface reportedNic = reportedNicsByNames.get(dbNic.getName());
            reportedNic.setId(dbNic.getId());
            if (!overrideNicWithUserConfiguration(reportedNic, userConfiguredNicsByName)) {
                reportedNic.overrideEngineManagedAttributes(dbNic);
            }
            nicsForUpdate.add(reportedNic);
        }
    }
    return nicsForUpdate;
}
#end_block

#method_before
private void importHostedEngineVM(Map vmStruct) {
    VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(vmStruct);
    vm.setImages(VdsBrokerObjectsBuilder.buildDiskImagesFromDevices(vmStruct));
    vm.setInterfaces(VdsBrokerObjectsBuilder.buildVmNetworkInterfacesFromDevices(vmStruct));
    for (DiskImage diskImage : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), diskImage);
    }
    vm.setVdsGroupId(getVdsManager().getVdsGroupId());
    getVdsEventListener().importHostedEngineVm(vm);
}
#method_after
private void importHostedEngineVM(Map vmStruct) {
    VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(vmStruct);
    if (vm != null) {
        vm.setImages(VdsBrokerObjectsBuilder.buildDiskImagesFromDevices(vmStruct));
        vm.setInterfaces(VdsBrokerObjectsBuilder.buildVmNetworkInterfacesFromDevices(vmStruct));
        for (DiskImage diskImage : vm.getImages()) {
            vm.getDiskMap().put(Guid.newGuid(), diskImage);
        }
        vm.setVdsGroupId(getVdsManager().getVdsGroupId());
        getVdsEventListener().importHostedEngineVm(vm);
    }
}
#end_block

#method_before
public VM chooseNextVmToMigrate() {
    List<AffinityGroup> affinityGroupsList = getAllAffinityGroups();
    // Filtering all non enforcing groups (Leaving only hard affinity groups).
    for (Iterator<AffinityGroup> it = affinityGroupsList.iterator(); it.hasNext(); ) {
        AffinityGroup ag = it.next();
        if (!ag.isEnforcing()) {
            it.remove();
        }
    }
    Set<Set<Guid>> unifiedPositiveAffinityGroups = AffinityRulesUtils.getUnifiedPositiveAffinityGroups(affinityGroupsList);
    List<AffinityGroup> unifiedAffinityGroups = AffinityRulesUtils.setsToAffinityGroups(unifiedPositiveAffinityGroups);
    // Add negative affinity groups
    for (AffinityGroup ag : affinityGroupsList) {
        if (ag.isPositive()) {
            continue;
        }
        unifiedAffinityGroups.add(ag);
    }
    // Create a set of all VMs in affinity groups
    Set<Guid> allVms = new HashSet<>();
    for (AffinityGroup group : unifiedAffinityGroups) {
        allVms.addAll(group.getEntityIds());
    }
    Map<Guid, Guid> vmToHost = createMapOfVmToHost(allVms);
    // There is no need to migrate when no collision was detected
    Set<AffinityGroup> violatedAffinityGroups = checkForAffinityGroupViolations(unifiedAffinityGroups, vmToHost, FailMode.GET_ALL);
    if (violatedAffinityGroups.isEmpty()) {
        log.debug("No affinity group collision detected for cluster {}. Standing by.", clusterId);
        return null;
    }
    // Find a VM that is breaking the affinityGroup and can be theoretically migrated
    // - start with smaller Affinity Groups
    List<AffinityGroup> affGroupsBySize = new ArrayList<>(violatedAffinityGroups);
    Collections.sort(affGroupsBySize, new AffinityGroupComparator());
    for (AffinityGroup affinityGroup : affGroupsBySize) {
        Guid candidateVm;
        if (affinityGroup.isPositive()) {
            candidateVm = findVmViolatingPositiveAg(affinityGroup, vmToHost);
            log.info("Positive affinity group violation detected for VM {}", candidateVm);
        } else {
            candidateVm = findVmViolatingNegativeAg(affinityGroup, vmToHost);
            log.info("Negative affinity group violation detected for VM {}", candidateVm);
        }
        // No candidate found
        if (candidateVm == null) {
            continue;
        }
        // Test whether any migration is possible, this uses current AffinityGroup settings
        // and so won't allow more breakage
        VM vm = vmDao.get(candidateVm);
        VDSGroup cluster = vdsGroupDao.get(clusterId);
        boolean canMove = schedulingManager.canSchedule(cluster, vm, new ArrayList<Guid>(), new ArrayList<Guid>(), null, new ArrayList<String>());
        if (canMove) {
            log.debug("VM {} is a viable candidate for solving affinity group violation situation.", candidateVm);
            lastMigrations.add(new MigrationEntryDS(candidateVm, vmToHost.get(candidateVm)));
            return vm;
        }
        log.debug("VM {} is NOT a viable candidate for solving affinity group violation situation.", candidateVm);
    }
    // No possible migration..
    return null;
}
#method_after
public VM chooseNextVmToMigrate() {
    List<AffinityGroup> allHardAffinityGroups = getAllAffinityGroups();
    // Filtering all non enforcing groups (Leaving only hard affinity groups).
    for (Iterator<AffinityGroup> it = allHardAffinityGroups.iterator(); it.hasNext(); ) {
        AffinityGroup ag = it.next();
        if (!ag.isEnforcing()) {
            it.remove();
        }
    }
    Set<Set<Guid>> unifiedPositiveAffinityGroups = AffinityRulesUtils.getUnifiedPositiveAffinityGroups(allHardAffinityGroups);
    List<AffinityGroup> unifiedAffinityGroups = AffinityRulesUtils.setsToAffinityGroups(unifiedPositiveAffinityGroups);
    // Add negative affinity groups
    for (AffinityGroup ag : allHardAffinityGroups) {
        if (ag.isPositive()) {
            continue;
        }
        unifiedAffinityGroups.add(ag);
    }
    // Create a set of all VMs in affinity groups
    Set<Guid> allVms = new HashSet<>();
    for (AffinityGroup group : unifiedAffinityGroups) {
        allVms.addAll(group.getEntityIds());
    }
    Map<Guid, Guid> vmToHost = createMapOfVmToHost(allVms);
    // There is no need to migrate when no collision was detected
    Set<AffinityGroup> violatedAffinityGroups = checkForAffinityGroupViolations(unifiedAffinityGroups, vmToHost, FailMode.GET_ALL);
    if (violatedAffinityGroups.isEmpty()) {
        log.debug("No affinity group collision detected for cluster {}. Standing by.", clusterId);
        return null;
    }
    // Find a VM that is breaking the affinityGroup and can be theoretically migrated
    // - start with smaller Affinity Groups
    List<AffinityGroup> affGroupsBySize = new ArrayList<>(violatedAffinityGroups);
    Collections.sort(affGroupsBySize, new AffinityGroupComparator());
    for (AffinityGroup affinityGroup : affGroupsBySize) {
        Guid candidateVm;
        if (affinityGroup.isPositive()) {
            candidateVm = findVmViolatingPositiveAg(affinityGroup, vmToHost);
            log.info("Positive affinity group violation detected for VM {}", candidateVm);
        } else {
            candidateVm = findVmViolatingNegativeAg(affinityGroup, vmToHost);
            log.info("Negative affinity group violation detected for VM {}", candidateVm);
        }
        // No candidate found
        if (candidateVm == null) {
            continue;
        }
        // Test whether any migration is possible, this uses current AffinityGroup settings
        // and so won't allow more breakage
        VM vm = vmDao.get(candidateVm);
        VDSGroup cluster = vdsGroupDao.get(clusterId);
        boolean canMove = schedulingManager.canSchedule(cluster, vm, new ArrayList<Guid>(), new ArrayList<Guid>(), null, new ArrayList<String>());
        if (canMove) {
            log.debug("VM {} is a viable candidate for solving affinity group violation situation.", candidateVm);
            lastMigrations.add(new MigrationEntryDS(candidateVm, vmToHost.get(candidateVm)));
            return vm;
        }
        log.debug("VM {} is NOT a viable candidate for solving affinity group violation situation.", candidateVm);
    }
    // No possible migration..
    return null;
}
#end_block

#method_before
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus prevStatus = VMStatus.Unassigned;
        VmDynamic dynamicFromDb = null;
        if (dbVm != null) {
            prevStatus = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (prevStatus == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        } else {
            dynamicFromDb = getDbFacade().getVmDynamicDao().get(vdsmVm.getVmDynamic().getId());
            if (dynamicFromDb != null) {
                prevStatus = dynamicFromDb.getStatus();
            }
        }
        if (dbVm != null || dynamicFromDb != null) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && prevStatus == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (prevStatus != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic());
            }
        }
    }
}
#method_after
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus prevStatus = VMStatus.Unassigned;
        if (dbVm != null) {
            prevStatus = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (prevStatus == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        } else {
            VmDynamic dynamicFromDb = getDbFacade().getVmDynamicDao().get(vdsmVm.getVmDynamic().getId());
            if (dynamicFromDb != null) {
                prevStatus = dynamicFromDb.getStatus();
            }
        }
        if (prevStatus != VMStatus.Unassigned) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && prevStatus == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (prevStatus != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic());
            }
        }
    }
}
#end_block

#method_before
private void removeVmsFromCache() {
    if (dbVm != null && !stable) {
        proceedVmBeforeDeletion();
        boolean migrating = dbVm.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(dbVm);
        } else if (dbVm.getStatus() == VMStatus.PoweringDown) {
            clearVm(VmExitStatus.Normal, String.format("VM %s shutdown complete", dbVm.getName()), VmExitReason.Success);
        } else {
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", dbVm.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}({}) is running in db and not running in VDS '{}'", dbVm.getId(), dbVm.getName(), getVdsManager().getVdsName());
        if (!migrating && !rerun && vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            rerun = true;
            log.info("add VM '{}' to rerun treatment", dbVm.getName());
        } else // or reported from vdsm with error code
        if (dbVm.isAutoStartup() && !autoVmToRun && (vdsmVm == null || vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            autoVmToRun = true;
            log.info("add VM '{}' to HA rerun treatment", dbVm.getName());
        }
    }
}
#method_after
private void removeVmsFromCache() {
    if (dbVm != null && !stable) {
        // marks the vm was powered down by user but not reported as Down afterwards by vdsm
        boolean poweredDown = false;
        proceedVmBeforeDeletion();
        boolean migrating = dbVm.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(dbVm);
        } else if (dbVm.getStatus() == VMStatus.PoweringDown) {
            poweredDown = true;
            clearVm(VmExitStatus.Normal, String.format("VM %s shutdown complete", dbVm.getName()), VmExitReason.Success);
        } else {
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", dbVm.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}({}) is running in db and not running in VDS '{}'", dbVm.getId(), dbVm.getName(), getVdsManager().getVdsName());
        if (!migrating && !rerun && vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            rerun = true;
            log.info("add VM '{}' to rerun treatment", dbVm.getName());
        } else // or reported from vdsm with error code
        if (dbVm.isAutoStartup() && !autoVmToRun && (vdsmVm == null || vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) && !poweredDown) {
            autoVmToRun = true;
            log.info("add VM '{}' to HA rerun treatment", dbVm.getName());
        }
    }
}
#end_block

#method_before
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkItemModel<?> op1 = getItemModel(op1Key, op1Type);
    NetworkItemModel<?> op2 = getItemModel(op2Key, op2Type);
    if (op1 == null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop) {
        onOperation(candidate, candidate.getCommand(op1, op2, allNics));
    }
    // raise the candidate event only if it was changed
    if (!candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
        currentCandidate = candidate;
        currentOp1 = op1;
        currentOp2 = op2;
        getOperationCandidateEvent().raise(this, new OperationCandidateEventArgs(candidate, op1, op2));
    }
    return !candidate.isNullOperation();
}
#method_after
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkInterfaceModel nic1 = null;
    LogicalNetworkModel network1 = null;
    NetworkInterfaceModel nic2 = null;
    LogicalNetworkModel network2 = null;
    if (NIC.equals(op1Type)) {
        nic1 = nicMap.get(op1Key);
    } else if (NETWORK.equals(op1Type)) {
        network1 = networkMap.get(op1Key);
    }
    if (NIC.equals(op2Type)) {
        nic2 = nicMap.get(op2Key);
    } else if (NETWORK.equals(op2Type)) {
        network2 = networkMap.get(op2Key);
    }
    NetworkItemModel<?> op1 = nic1 == null ? network1 : nic1;
    NetworkItemModel<?> op2 = nic2 == null ? network2 : nic2;
    return candidateOperation(op1, op2, drop);
}
#end_block

#method_before
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkItemModel<?> op1 = getItemModel(op1Key, op1Type);
    NetworkItemModel<?> op2 = getItemModel(op2Key, op2Type);
    if (op1 == null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop) {
        onOperation(candidate, candidate.getCommand(op1, op2, allNics));
    }
    // raise the candidate event only if it was changed
    if (!candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
        currentCandidate = candidate;
        currentOp1 = op1;
        currentOp2 = op2;
        getOperationCandidateEvent().raise(this, new OperationCandidateEventArgs(candidate, op1, op2));
    }
    return !candidate.isNullOperation();
}
#method_after
private boolean candidateOperation(NetworkItemModel<?> op1, NetworkItemModel<?> op2, boolean drop) {
    if (op1 == null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop) {
        onOperation(candidate, candidate.getCommand(op1, op2, allNics));
    }
    // raise the candidate event only if it was changed
    if (!candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
        currentCandidate = candidate;
        currentOp1 = op1;
        currentOp2 = op2;
        getOperationCandidateEvent().raise(this, new OperationCandidateEventArgs(candidate, op1, op2));
    }
    return !candidate.isNullOperation();
}
#end_block

#method_before
private void commitLabelChanges(List<VdsNetworkInterface> srcIfaces, VdsNetworkInterface dstIface) {
    NetworkOperation.moveLabels(srcIfaces, dstIface);
}
#method_after
private void commitLabelChanges(NicLabelModel labelModel, VdsNetworkInterface iface, Collection<LogicalNetworkModel> potentialNetworks) {
    labelModel.commit(iface);
    NetworkInterfaceModel ifaceModel = nicMap.get(iface.getName());
    NetworkOperation.clearNetworks(ifaceModel, allNics);
    NetworkOperation.attachNetworks(ifaceModel, new ArrayList<>(potentialNetworks), allNics);
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNicModel().getIface() : logicalNetwork.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        if (logicalNetwork.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(logicalNetwork.getNetwork());
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getNetwork());
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
        networkDialogModel.getAddress().setEntity(entity.getAddress());
        networkDialogModel.getSubnet().setEntity(entity.getSubnet());
        networkDialogModel.getGateway().setEntity(entity.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(entity.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(entity.getBootProtocol());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(entity.isQosOverridden());
            if (entity.isQosOverridden()) {
                networkDialogModel.getQosModel().init(entity.getQos());
            } else {
                Guid qosId = logicalNetwork.getNetwork().getQosId();
                if (qosId != null) {
                    networkDialogModel.startProgress(null);
                    Frontend.getInstance().runQuery(VdcQueryType.GetQosById, new IdQueryParameters(qosId), new AsyncQuery(new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            networkDialogModel.getQosModel().init((HostNetworkQos) ((VdcQueryReturnValue) returnValue).getReturnValue());
                            networkDialogModel.stopProgress();
                        }
                    }));
                }
            }
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!logicalNetwork.getNetwork().isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(entity.getCustomProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetwork.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetwork.getName()));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                entity.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    entity.setAddress(networkDialogModel.getAddress().getEntity());
                    entity.setSubnet(networkDialogModel.getSubnet().getEntity());
                    entity.setGateway(networkDialogModel.getGateway().getEntity());
                }
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    boolean qosOverridden = networkDialogModel.getQosOverridden().getEntity();
                    HostNetworkQos qos = null;
                    entity.setQosOverridden(qosOverridden);
                    if (qosOverridden) {
                        qos = new HostNetworkQos();
                        networkDialogModel.getQosModel().flush(qos);
                    }
                    entity.setQos(qos);
                }
                if (networkDialogModel.getCustomPropertiesModel().getIsAvailable()) {
                    entity.setCustomProperties(KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()));
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetwork.getName());
                } else {
                    networksToSync.remove(logicalNetwork.getName());
                }
                sourceListModel.setConfirmWindow(null);
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        editPopup = new SetupNetworksEditBondModel(entity, getFreeLabels(), labelToIface);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(bondDialogModel.getLabelsModel(), nicMap.get(entity.getName()).getItems());
                if (validateLabelChanges(potentialNetworks)) {
                    setBondOptions(entity, bondDialogModel);
                    commitLabelChanges(bondDialogModel.getLabelsModel(), entity, potentialNetworks);
                    redraw();
                }
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  Interface Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        final HostNicModel interfacePopupModel = new HostNicModel(entity, getFreeLabels(), labelToIface);
        editPopup = interfacePopupModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!interfacePopupModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(interfacePopupModel.getLabelsModel(), nicMap.get(entity.getName()).getItems());
                if (validateLabelChanges(potentialNetworks)) {
                    commitLabelChanges(interfacePopupModel.getLabelsModel(), entity, potentialNetworks);
                    redraw();
                }
            }
        };
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNicModel().getEntity() : logicalNetwork.getAttachedToNic().getEntity();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        if (logicalNetwork.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(logicalNetwork.getEntity());
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getEntity());
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
        networkDialogModel.getAddress().setEntity(entity.getAddress());
        networkDialogModel.getSubnet().setEntity(entity.getSubnet());
        networkDialogModel.getGateway().setEntity(entity.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(entity.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(entity.getBootProtocol());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(entity.isQosOverridden());
            if (entity.isQosOverridden()) {
                networkDialogModel.getQosModel().init(entity.getQos());
            } else {
                Guid qosId = logicalNetwork.getEntity().getQosId();
                if (qosId != null) {
                    networkDialogModel.startProgress(null);
                    Frontend.getInstance().runQuery(VdcQueryType.GetQosById, new IdQueryParameters(qosId), new AsyncQuery(new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            networkDialogModel.getQosModel().init((HostNetworkQos) ((VdcQueryReturnValue) returnValue).getReturnValue());
                            networkDialogModel.stopProgress();
                        }
                    }));
                }
            }
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!logicalNetwork.getEntity().isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(entity.getCustomProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetwork.getName()));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                entity.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    entity.setAddress(networkDialogModel.getAddress().getEntity());
                    entity.setSubnet(networkDialogModel.getSubnet().getEntity());
                    entity.setGateway(networkDialogModel.getGateway().getEntity());
                }
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    boolean qosOverridden = networkDialogModel.getQosOverridden().getEntity();
                    HostNetworkQos qos = null;
                    entity.setQosOverridden(qosOverridden);
                    if (qosOverridden) {
                        qos = new HostNetworkQos();
                        networkDialogModel.getQosModel().flush(qos);
                    }
                    entity.setQos(qos);
                }
                if (networkDialogModel.getCustomPropertiesModel().getIsAvailable()) {
                    entity.setCustomProperties(KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()));
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetwork.getName());
                } else {
                    networksToSync.remove(logicalNetwork.getName());
                }
                sourceListModel.setConfirmWindow(null);
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH || operation == NetworkOperation.JOIN_BONDS) {
        final SetupNetworksBondModel bondPopup;
        final List<VdsNetworkInterface> srcIfaces = new ArrayList<>();
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp1()).getIface());
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp2()).getIface());
        if (operation == NetworkOperation.BOND_WITH) {
            bondPopup = new SetupNetworksAddBondModel(getFreeBonds(), nextBondName);
        } else {
            bondPopup = new SetupNetworksJoinBondsModel(getFreeBonds(), (BondNetworkInterfaceModel) networkCommand.getOp1(), (BondNetworkInterfaceModel) networkCommand.getOp2());
        }
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                VdsNetworkInterface bond = new Bond(bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = new ArrayList<>();
                networks.addAll(nic1.getItems());
                networks.addAll(nic2.getItems());
                networkCommand.execute(bond);
                redraw();
                // Attach the previous networks
                commitNetworkChanges(bond, networks);
                // Attach previous labels
                commitLabelChanges(srcIfaces, bond);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else if (networkCommand.getOp1() == getNewNetworkLabelModel()) {
        final SetupNetworksLabelModel labelPopup = new SetupNetworksLabelModel(dcLabels);
        labelPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!labelPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                String label = labelPopup.getLabel().getEntity();
                dcLabels.add(label);
                NetworkOperation.LABEL.getCommand(new NetworkLabelModel(label, HostSetupNetworksModel.this), networkCommand.getOp2(), allNics).execute();
                redraw();
            }
        }));
        popupWindow = labelPopup;
    } else {
        // just execute the command
        networkCommand.execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#method_after
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH || operation == NetworkOperation.JOIN_BONDS) {
        final SetupNetworksBondModel bondPopup;
        VdsNetworkInterface iface1 = ((NetworkInterfaceModel) networkCommand.getOp1()).getEntity();
        VdsNetworkInterface iface2 = ((NetworkInterfaceModel) networkCommand.getOp2()).getEntity();
        if (operation == NetworkOperation.BOND_WITH) {
            bondPopup = new SetupNetworksAddBondModel(getFreeBonds(), nextBondName, Arrays.asList(iface1, iface2), getFreeLabels(), labelToIface);
        } else {
            bondPopup = new SetupNetworksJoinBondsModel(getFreeBonds(), (BondNetworkInterfaceModel) networkCommand.getOp1(), (BondNetworkInterfaceModel) networkCommand.getOp2(), getFreeLabels(), labelToIface);
        }
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = new ArrayList<>();
                networks.addAll(nic1.getItems());
                networks.addAll(nic2.getItems());
                Collection<LogicalNetworkModel> potentialNetworks = computeLabelChanges(bondPopup.getLabelsModel(), networks);
                if (!validateLabelChanges(potentialNetworks)) {
                    return;
                }
                VdsNetworkInterface bond = new Bond(bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                networkCommand.execute(bond);
                redraw();
                // Attach the previous networks
                commitLabelChanges(bondPopup.getLabelsModel(), bond, potentialNetworks);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else {
        // just execute the command
        networkCommand.execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#end_block

#method_before
private void onNicsChanged() {
    operationFactory = new NetworkOperationFactory(getNetworks(), getNics());
    validate();
}
#method_after
protected void onNicsChanged() {
    operationFactory = new NetworkOperationFactory(getNetworks(), getNics());
    validate();
}
#end_block

#method_before
private void initAllModels(boolean fetchFromBackend) {
    if (fetchFromBackend) {
        // run query for networks, this chains the query for nics, and also stops progress when done
        startProgress(null);
        queryLabels();
    } else {
        initLabelModels();
        initNetworkModels();
        initNicModels();
    }
}
#method_after
private void initAllModels(boolean fetchFromBackend) {
    if (fetchFromBackend) {
        // run query for networks, this chains the query for nics, and also stops progress when done
        startProgress(null);
        queryNetworks();
    } else {
        initNetworkModels();
        initNicModels();
    }
}
#end_block

#method_before
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<>();
    for (Network network : allNetworks) {
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, this);
        networkModels.put(network.getName(), networkModel);
        if (networkModel.isManagement()) {
            managementNetworkModel = networkModel;
        }
        if (!network.isExternal()) {
            String label = network.getLabel();
            if (label != null) {
                // The network model is candidate to be drawn as part of the label.
                // This doesn't yet consider whether it actually exists on the interface.
                networkLabelMap.get(label).getNetworks().add(networkModel);
            }
        }
    }
    setNetworks(networkModels);
}
#method_after
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<>();
    networkLabelMap = new HashMap<>();
    for (Network network : allNetworks) {
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, this);
        networkModels.put(network.getName(), networkModel);
        if (!network.isExternal()) {
            NetworkLabelModel labelModel = networkLabelMap.get(network.getLabel());
            if (labelModel == null) {
                labelModel = new NetworkLabelModel(network.getLabel(), this);
                networkLabelMap.put(network.getLabel(), labelModel);
            }
            // The network model is candidate to be drawn as part of the label.
            // This doesn't yet consider whether it actually exists on the interface.
            labelModel.getNetworks().add(networkModel);
        }
    }
    setNetworks(networkModels);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface = new HashMap<>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    if (!labelModel.getNetworks().isEmpty()) {
                        nicLabels.add(labelModel);
                    }
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
private void initLabeledNetworksErrorMessages(List<LogicalNetworkModel> errorLabelNetworks, Map<String, NetworkInterfaceModel> nicModels) {
    for (LogicalNetworkModel networkModel : errorLabelNetworks) {
        NetworkInterfaceModel desiredNic = nicModels.get(labelToIface.get(networkModel.getNetwork().getLabel()));
        NetworkOperation operation = NetworkOperationFactory.operationFor(networkModel, desiredNic);
        UIMessages messages = ConstantsManager.getInstance().getMessages();
        // Should be attached but can't due to conflict
        if (operation.isNullOperation()) {
            networkModel.setErrorMessage(messages.networkLabelConflict(desiredNic.getName(), networkModel.getNetwork().getLabel()) + " " + // $NON-NLS-1$
            operation.getMessage(networkModel, desiredNic));
        } else {
            networkModel.setErrorMessage(messages.labeledNetworkNotAttached(desiredNic.getName(), networkModel.getNetwork().getLabel()));
        }
    }
}
#method_after
private void initLabeledNetworksErrorMessages(List<LogicalNetworkModel> errorLabelNetworks, Map<String, NetworkInterfaceModel> nicModels) {
    for (LogicalNetworkModel networkModel : errorLabelNetworks) {
        NetworkInterfaceModel desiredNic = nicModels.get(labelToIface.get(networkModel.getEntity().getLabel()));
        NetworkOperation operation = NetworkOperationFactory.operationFor(networkModel, desiredNic);
        UIMessages messages = ConstantsManager.getInstance().getMessages();
        // Should be attached but can't due to conflict
        if (operation.isNullOperation()) {
            networkModel.setErrorMessage(messages.networkLabelConflict(desiredNic.getName(), networkModel.getEntity().getLabel()) + " " + // $NON-NLS-1$
            operation.getMessage(networkModel, desiredNic));
        } else {
            networkModel.setErrorMessage(messages.labeledNetworkNotAttached(desiredNic.getName(), networkModel.getEntity().getLabel()));
        }
    }
}
#end_block

#method_before
private void queryLabels() {
    AsyncDataProvider.getInstance().getNetworkLabelsByDataCenterId(getEntity().getStoragePoolId(), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            dcLabels = (SortedSet<String>) returnValue;
            initLabelModels();
            // chain the networks query
            queryNetworks();
        }
    }));
}
#method_after
private void queryLabels() {
    AsyncDataProvider.getInstance().getNetworkLabelsByDataCenterId(getEntity().getStoragePoolId(), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            dcLabels = (SortedSet<String>) returnValue;
            initNicModels();
            stopProgress();
        }
    }));
}
#end_block

#method_before
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VdsNetworkInterface> bonds = ((VdcQueryReturnValue) returnValue).getReturnValue();
            allBonds = bonds;
            initNicModels();
            stopProgress();
        }
    };
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), asyncQuery);
}
#method_after
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VdsNetworkInterface> bonds = ((VdcQueryReturnValue) returnValue).getReturnValue();
            allBonds = bonds;
            // chain the DC labels query
            queryLabels();
        }
    };
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), asyncQuery);
}
#end_block

#method_before
private void queryInterfaces() {
    // query for interfaces
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValueObj) {
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) returnValueObj;
            Object returnValue2 = returnValue.getReturnValue();
            List<VdsNetworkInterface> allNics = (List<VdsNetworkInterface>) returnValue2;
            HostSetupNetworksModel.this.allNics = allNics;
            // chain the vfsConfig query
            queryVfsConfig();
        }
    };
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsInterfacesByVdsId, params, asyncQuery);
}
#method_after
private void queryInterfaces() {
    // query for interfaces
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValueObj) {
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) returnValueObj;
            Object returnValue2 = returnValue.getReturnValue();
            List<VdsNetworkInterface> allNics = (List<VdsNetworkInterface>) returnValue2;
            HostSetupNetworksModel.this.allNics = allNics;
            // chain the free bonds query
            queryFreeBonds();
        }
    };
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsInterfacesByVdsId, params, asyncQuery);
}
#end_block

#method_before
private void validate() {
    // check if management network is attached
    if (!managementNetworkModel.isAttached()) {
        okCommand.getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().mgmtNotAttachedToolTip());
        okCommand.setIsExecutionAllowed(false);
    } else {
        okCommand.setIsExecutionAllowed(true);
    }
}
#method_after
private void validate() {
    // check if management network is attached
    LogicalNetworkModel mgmtNetwork = networkMap.get(HostInterfaceListModel.ENGINE_NETWORK_NAME);
    if (!mgmtNetwork.isAttached()) {
        okCommand.getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().mgmtNotAttachedToolTip());
        okCommand.setIsExecutionAllowed(false);
    } else {
        okCommand.setIsExecutionAllowed(true);
    }
}
#end_block

#method_before
public void postOnSetupNetworks() {
    SetupNetworksParameters params = new SetupNetworksParameters();
    params.setInterfaces(getAllNics());
    params.setCheckConnectivity(getCheckConnectivity().getEntity());
    params.setConectivityTimeout(getConnectivityTimeout().getEntity());
    params.setVdsId(getEntity().getId());
    params.setNetworksToSync(getNetworksToSync());
    SimpleAction closeAction = getCloseAction();
    UiAction setupNetworks = new UiVdcAction(VdcActionType.SetupNetworks, params, this, true);
    setupNetworks.then(getVfsConfigAction()).then(getCommitNetworkChangesAction()).onAllExecutionsFinish(closeAction);
    setupNetworks.runAction();
}
#method_after
public void postOnSetupNetworks() {
    final HostSetupNetworksModel model = (HostSetupNetworksModel) sourceListModel.getWindow();
    SetupNetworksParameters params = new SetupNetworksParameters();
    params.setInterfaces(model.getAllNics());
    params.setCheckConnectivity(model.getCheckConnectivity().getEntity());
    params.setConectivityTimeout(model.getConnectivityTimeout().getEntity());
    params.setVdsId(getEntity().getId());
    params.setNetworksToSync(model.getNetworksToSync());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.SetupNetworks, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                EntityModel<Boolean> commitChanges = model.getCommitChanges();
                if (commitChanges.getEntity()) {
                    new SaveNetworkConfigAction(sourceListModel, model, getEntity()).execute();
                } else {
                    model.stopProgress();
                    sourceListModel.setWindow(null);
                    sourceListModel.search();
                }
            } else {
                model.stopProgress();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    final Map<Integer, VmIconIdSizePair> result = new HashMap<>();
    final List<VmIconDefault> iconDefaults = vmIconDefaultDao.getAll();
    for (VmIconDefault iconDefault : iconDefaults) {
        result.put(iconDefault.getOsId(), new VmIconIdSizePair(iconDefault.getSmallIconId(), iconDefault.getLargeIconId()));
    }
    if (!result.containsKey(OsRepository.DEFAULT_X86_OS)) {
        throw new RuntimeException("Default icon pair not found.");
    }
    setReturnValue(result);
}
#method_after
@Override
protected void executeQueryCommand() {
    final Map<Integer, VmIconIdSizePair> result = new HashMap<>();
    final List<VmIconDefault> iconDefaults = vmIconDefaultDao.getAll();
    for (VmIconDefault iconDefault : iconDefaults) {
        result.put(iconDefault.getOsId(), new VmIconIdSizePair(iconDefault.getSmallIconId(), iconDefault.getLargeIconId()));
    }
    if (!result.containsKey(OsRepository.DEFAULT_X86_OS)) {
        throw new EngineException(EngineError.DefaultIconPairNotFound);
    }
    setReturnValue(result);
}
#end_block

#method_before
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus prevStatus = VMStatus.Unassigned;
        VmDynamic dynamicFromDb = null;
        if (dbVm != null) {
            prevStatus = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (prevStatus == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        } else {
            dynamicFromDb = getDbFacade().getVmDynamicDao().get(vdsmVm.getVmDynamic().getId());
            if (dynamicFromDb != null) {
                prevStatus = dynamicFromDb.getStatus();
            }
        }
        if (dbVm != null || dynamicFromDb != null) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && prevStatus == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (prevStatus != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic());
            }
        }
    }
}
#method_after
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus prevStatus = VMStatus.Unassigned;
        if (dbVm != null) {
            prevStatus = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (prevStatus == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        } else {
            VmDynamic dynamicFromDb = getDbFacade().getVmDynamicDao().get(vdsmVm.getVmDynamic().getId());
            if (dynamicFromDb != null) {
                prevStatus = dynamicFromDb.getStatus();
            }
        }
        if (prevStatus != VMStatus.Unassigned) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && prevStatus == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (prevStatus != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic());
            }
        }
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    buildVmData();
    logCommandInfo();
    mVmReturn = getBroker().create(createInfo);
    proceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), mVmReturn.mVm, getVds());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    buildVmData();
    logCommandInfo();
    vmReturn = getBroker().create(createInfo);
    proceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), vmReturn.vm, getVds());
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return mVmListReturn.mStatus;
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return vmListReturn.status;
}
#end_block

#method_before
@Override
protected Object getReturnValueFromBroker() {
    return mVmListReturn;
}
#method_after
@Override
protected Object getReturnValueFromBroker() {
    return vmListReturn;
}
#end_block

#method_before
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setvolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        image.setDiskInterface(DiskInterface.VirtIO);
                    case "iscsi":
                        image.setDiskInterface(DiskInterface.VirtIO_SCSI);
                    case "ide":
                        image.setDiskInterface(DiskInterface.IDE);
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#method_after
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setvolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        image.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                        image.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        image.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    mVmReturn = getBroker().changeFloppy(mVmId.toString(), mIsoLocation);
    proceedProxyReturnValue();
    setReturnValue(VdsBrokerObjectsBuilder.buildVMDynamicData(mVmReturn.mVm, getVds()).getStatus());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    vmReturn = getBroker().changeFloppy(vmId.toString(), isoLocation);
    proceedProxyReturnValue();
    setReturnValue(VdsBrokerObjectsBuilder.buildVMDynamicData(vmReturn.vm, getVds()).getStatus());
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    mVmReturn = getBroker().changeDisk(mVmId.toString(), mIsoLocation);
    proceedProxyReturnValue();
    setReturnValue(VdsBrokerObjectsBuilder.buildVMDynamicData(mVmReturn.mVm, getVds()).getStatus());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    vmReturn = getBroker().changeDisk(vmId.toString(), isoLocation);
    proceedProxyReturnValue();
    setReturnValue(VdsBrokerObjectsBuilder.buildVMDynamicData(vmReturn.vm, getVds()).getStatus());
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    mVmReturn = getBroker().pause(mVmId.toString());
    proceedProxyReturnValue();
    setReturnValue(VdsBrokerObjectsBuilder.buildVMDynamicData(mVmReturn.mVm, getVds()).getStatus());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    vmReturn = getBroker().pause(vmId.toString());
    proceedProxyReturnValue();
    setReturnValue(VdsBrokerObjectsBuilder.buildVMDynamicData(vmReturn.vm, getVds()).getStatus());
}
#end_block

#method_before
@Test
public void testUpdate() {
    final E modifiedEntity = modifyEntity(getExistingEntity());
    getDao().update(modifiedEntity);
    EntityManagerHolder.getInstance().getThreadLocal().get().flush();
    E result = getDao().get(getExistingEntity().getId());
    assertNotNull(result);
    verifyEntityModification(result);
}
#method_after
@Test
public void testUpdate() {
    final E modifiedEntity = modifyEntity(getExistingEntity());
    getDao().update(modifiedEntity);
    entityManagerHolder.getEntityManager().flush();
    E result = getDao().get(getExistingEntity().getId());
    assertNotNull(result);
    verifyEntityModification(result);
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    final Reflections reflections = new Reflections("org.ovirt.engine");
    daoClasses = Collections.unmodifiableSet(reflections.getSubTypesOf(DAO.class));
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    final Reflections reflections = new Reflections("org.ovirt.engine");
    daoClasses = Collections.unmodifiableSet(reflections.getSubTypesOf(Dao.class));
}
#end_block

#method_before
@Test
@SuppressWarnings({ "rawtypes", "unchecked" })
public void testSingletonDaoAnnotationPresent() {
    for (Class daoClass : daoClasses) {
        if (isConcreteClass(daoClass)) {
            assertTrue("A concrete DAO class has to be annotated with @ApplicationScoped or @Singleton: " + daoClass.getCanonicalName(), daoClass.isAnnotationPresent(ApplicationScoped.class) || daoClass.isAnnotationPresent(Dependent.class) || daoClass.isAnnotationPresent(Singleton.class));
        }
    }
}
#method_after
@Test
@SuppressWarnings({ "rawtypes", "unchecked" })
public void testSingletonDaoAnnotationPresent() {
    for (Class daoClass : daoClasses) {
        if (isConcreteClass(daoClass)) {
            assertTrue("A concrete Dao class has to be annotated with @ApplicationScoped or @Singleton: " + daoClass.getCanonicalName(), daoClass.isAnnotationPresent(ApplicationScoped.class) || daoClass.isAnnotationPresent(Singleton.class));
        }
    }
}
#end_block

#method_before
@Test
public void testSingletonDaoAnnotationNotPresentOnAbstractClass() {
    for (Class daoClass : daoClasses) {
        if (isAbstractClass(daoClass)) {
            assertFalse("An abstract DAO class cannot be annotated with @ApplicationScoped or @Singleton: " + daoClass.getCanonicalName(), daoClass.isAnnotationPresent(ApplicationScoped.class) || daoClass.isAnnotationPresent(Singleton.class));
        }
    }
}
#method_after
@Test
public void testSingletonDaoAnnotationNotPresentOnAbstractClass() {
    for (Class daoClass : daoClasses) {
        if (isAbstractClass(daoClass)) {
            assertFalse("An abstract Dao class cannot be annotated with @ApplicationScoped or @Singleton: " + daoClass.getCanonicalName(), daoClass.isAnnotationPresent(ApplicationScoped.class) || daoClass.isAnnotationPresent(Singleton.class));
        }
    }
}
#end_block

#method_before
@Test
public void testSingletonDaoAnnotationNotPresentOnParametrizedClass() {
    for (Class daoClass : daoClasses) {
        if (isParametrizedClass(daoClass)) {
            assertFalse("A parametrized DAO class cannot be annotated with @ApplicationScoped or @Singleton: " + daoClass.getCanonicalName(), daoClass.isAnnotationPresent(ApplicationScoped.class) || daoClass.isAnnotationPresent(Singleton.class));
        }
    }
}
#method_after
@Test
public void testSingletonDaoAnnotationNotPresentOnParametrizedClass() {
    for (Class daoClass : daoClasses) {
        if (isParametrizedClass(daoClass)) {
            assertFalse("A parametrized Dao class cannot be annotated with @ApplicationScoped or @Singleton: " + daoClass.getCanonicalName(), daoClass.isAnnotationPresent(ApplicationScoped.class) || daoClass.isAnnotationPresent(Singleton.class));
        }
    }
}
#end_block

#method_before
@Override
public void beforeTestMethod(TestContext testContext) throws Exception {
    super.beforeTestMethod(testContext);
    EntityManagerFactory entityManagerFactory = testContext.getApplicationContext().getBean(EntityManagerFactory.class);
    em = EntityManagerHolder.getInstance().getThreadLocal().get();
    if (em == null || !em.isOpen()) {
        em = entityManagerFactory.createEntityManager();
        EntityManagerHolder.getInstance().getThreadLocal().set(em);
    }
    em.joinTransaction();
}
#method_after
@Override
public void beforeTestMethod(TestContext testContext) throws Exception {
    super.beforeTestMethod(testContext);
    entityManagerHolder = testContext.getApplicationContext().getBean(EntityManagerHolder.class);
    em = entityManagerHolder.getEntityManager();
    em.joinTransaction();
}
#end_block

#method_before
@Override
public void afterTestMethod(TestContext testContext) throws Exception {
    super.afterTestMethod(testContext);
    if (em.isOpen()) {
        em.close();
    }
    EntityManagerHolder.getInstance().getThreadLocal().set(null);
}
#method_after
@Override
public void afterTestMethod(TestContext testContext) throws Exception {
    super.afterTestMethod(testContext);
    if (em.isOpen()) {
        em.close();
    }
    entityManagerHolder.nullEntityManager();
}
#end_block

#method_before
@Override
public Map<Guid, VdcObjectType> getJobSubjectEntityByJobId(Guid jobId) {
    List<JobSubjectEntity> list = multipleResults(entityManager.createNamedQuery("JobSubjectEntity.getJobSubjectEntityByJobId", JobSubjectEntity.class).setParameter("jobId", jobId));
    Map<Guid, VdcObjectType> entityMap = new HashMap<Guid, VdcObjectType>();
    for (JobSubjectEntity jobSubjectEntity : list) {
        entityMap.put(jobSubjectEntity.getEntityId(), jobSubjectEntity.getEntityType());
    }
    return entityMap;
}
#method_after
@Override
public Map<Guid, VdcObjectType> getJobSubjectEntityByJobId(Guid jobId) {
    List<JobSubjectEntity> list = multipleResults(getEntityManager().createNamedQuery("JobSubjectEntity.getJobSubjectEntityByJobId", JobSubjectEntity.class).setParameter("jobId", jobId));
    Map<Guid, VdcObjectType> entityMap = new HashMap<Guid, VdcObjectType>();
    for (JobSubjectEntity jobSubjectEntity : list) {
        entityMap.put(jobSubjectEntity.getEntityId(), jobSubjectEntity.getEntityType());
    }
    return entityMap;
}
#end_block

#method_before
@Override
public List<Guid> getJobIdByEntityId(Guid entityId) {
    return multipleResults(entityManager.createNamedQuery("JobSubjectEntity.getJobIdByEntityId").setParameter("entityId", entityId));
}
#method_after
@Override
public List<Guid> getJobIdByEntityId(Guid entityId) {
    return multipleResults(getEntityManager().createNamedQuery("JobSubjectEntity.getJobIdByEntityId").setParameter("entityId", entityId));
}
#end_block

#method_before
@Override
public void save(T entity) {
    entityManager.joinTransaction();
    entityManager.merge(entity);
}
#method_after
@Override
public void save(T entity) {
    getEntityManager().merge(entity);
}
#end_block

#method_before
@Override
public void update(T entity) {
    entityManager.joinTransaction();
    entityManager.merge(entity);
}
#method_after
@Override
public void update(T entity) {
    getEntityManager().merge(entity);
}
#end_block

#method_before
@Override
public T get(ID id) {
    final T entity = entityManager.find(entityType, id);
    if (entity == null) {
        return null;
    }
    entityManager.detach(entity);
    return entity;
}
#method_after
@Override
@Transactional(readOnly = true)
public T get(ID id) {
    final T entity = getEntityManager().find(entityType, id);
    return entity;
}
#end_block

#method_before
@Override
public List<T> getAll() {
    final String qlString = String.format("select e from %s e", entityName);
    final TypedQuery<T> query = entityManager.createQuery(qlString, entityType);
    return multipleResults(query);
}
#method_after
@Override
@Transactional(readOnly = true)
public List<T> getAll() {
    final String qlString = String.format("select e from %s e", getEntityName());
    final TypedQuery<T> query = getEntityManager().createQuery(qlString, entityType);
    return multipleResults(query);
}
#end_block

#method_before
protected List<T> multipleResults(TypedQuery<T> query) {
    final List<T> resultList = query.getResultList();
    for (T entity : resultList) {
        entityManager.detach(entity);
    }
    return resultList;
}
#method_after
@Transactional(readOnly = true)
protected List<T> multipleResults(TypedQuery<T> query) {
    final List<T> resultList = query.getResultList();
    return resultList;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected <O> List<O> multipleResults(Query query) {
    final List<O> resultList = query.getResultList();
    if (!resultList.isEmpty()) {
        boolean isEntity = entityManager.getMetamodel().getEntities().contains(resultList.get(0));
        for (Object entity : resultList) {
            if (isEntity) {
                entityManager.detach(entity);
            }
        }
    }
    return resultList;
}
#method_after
@SuppressWarnings("unchecked")
@Transactional(readOnly = true)
protected <O> List<O> multipleResults(Query query) {
    final List<O> resultList = query.getResultList();
    return resultList;
}
#end_block

#method_before
protected T singleResult(TypedQuery<T> query) {
    try {
        final T entity = query.getSingleResult();
        entityManager.detach(entity);
        return entity;
    } catch (NoResultException nre) {
        return null;
    }
}
#method_after
@Transactional(readOnly = true)
protected T singleResult(TypedQuery<T> query) {
    try {
        final T entity = query.getSingleResult();
        // getEntityManager().detach(entity);
        return entity;
    } catch (NoResultException nre) {
        return null;
    }
}
#end_block

#method_before
public void remove(ID id) {
    final T entity = entityManager.find(entityType, id);
    if (entity == null) {
        LOG.warn("Trying to remove non-existent {} with id = '{}'", entityType.getSimpleName(), id);
    } else {
        remove(entity);
    }
}
#method_after
public void remove(ID id) {
    final T entity = getEntityManager().find(entityType, id);
    if (entity == null) {
        LOG.warn("Trying to remove non-existent {} with id = '{}'", entityType.getSimpleName(), id);
    } else {
        remove(entity);
    }
}
#end_block

#method_before
public void remove(T entity) {
    entityManager.joinTransaction();
    entityManager.remove(entity);
}
#method_after
public void remove(T entity) {
    getEntityManager().remove(entity);
}
#end_block

#method_before
protected void updateQuery(final Query query) {
    entityManager.joinTransaction();
    query.executeUpdate();
}
#method_after
protected void updateQuery(final Query query) {
    query.executeUpdate();
}
#end_block

#method_before
protected Object updateQueryGetResult(Query query) {
    entityManager.joinTransaction();
    return query.getSingleResult();
}
#method_after
protected Object updateQueryGetResult(Query query) {
    return query.getSingleResult();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public <T> boolean visit(final EditorContext<T> ctx) {
    final String absolutePath = ctx.getAbsolutePath();
    LeafValueEditor<T> currentLeafEditor = ctx.asLeafValueEditor();
    if (currentLeafEditor == null) {
        // Ignore non-leaf Editors
        return super.visit(ctx);
    }
    final LeafValueEditor<T> editor = getActualEditor(currentLeafEditor);
    // If this Editor implements HasValueChangeHandlers, register a value change listener
    if (editor instanceof HasValueChangeHandlers) {
        ((HasValueChangeHandlers<T>) editor).addValueChangeHandler(new ValueChangeHandler<T>() {

            @Override
            public void onValueChange(ValueChangeEvent<T> event) {
                setInModel(ctx, event.getSource(), event.getValue());
            }
        });
    }
    final UiCommonEditor<T> functionalEditor = getFunctionalEditor(currentLeafEditor);
    if (functionalEditor != null) {
        // Set tab index, unless it's being set manually (i.e. already been set)
        if (functionalEditor.getTabIndex() <= 0) {
            functionalEditor.setTabIndex(++tabIndexCounter);
        }
        // Add key press handler
        functionalEditor.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                if (KeyCodes.KEY_ENTER == event.getNativeEvent().getKeyCode()) {
                    setInModel(ctx, editor, editor.getValue());
                }
            }
        });
    }
    // Handle owner entity models
    if (ownerModels.containsKey(absolutePath)) {
        Model ownerModel = ownerModels.get(absolutePath);
        // If this editor edits a ListModel, initialize it
        if (editor instanceof TakesConstrainedValueListEditor && ownerModel instanceof ListModel) {
            updateMultiListEditor((TakesConstrainedValueListEditor<T>) editor, (ListModel) ownerModel);
        } else if (editor instanceof TakesConstrainedValueEditor && ownerModel instanceof ListModel) {
            updateListEditor((TakesConstrainedValueEditor<T>) editor, (ListModel) ownerModel);
        }
        if (functionalEditor != null) {
            // Register a property change listener on the owner entity model
            ownerModel.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

                @Override
                public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
                    Model ownerModel = (Model) sender;
                    String propName = args.propertyName;
                    // IsValid
                    if ("IsValid".equals(propName)) {
                        // $NON-NLS-1$
                        onIsValidPropertyChange(functionalEditor, ownerModel);
                    } else // IsChangable
                    if ("IsChangable".equals(propName)) {
                        // $NON-NLS-1$
                        onIsChangablePropertyChange(functionalEditor, ownerModel);
                    } else // ChangeProhibitionReason
                    if ("ChangeProhibitionReason".equals(propName)) {
                        // $NON-NLS-1$
                        onChangeProhibitionReasonChange(functionalEditor, ownerModel);
                    } else // IsAvailable
                    if ("IsAvailable".equals(propName)) {
                        // $NON-NLS-1$
                        onIsAvailablePropertyChange(functionalEditor, ownerModel);
                    }
                }
            });
            // Update editor since we might have missed property change
            // events fired as part of the entity model constructor
            onIsValidPropertyChange(functionalEditor, ownerModel);
            onIsChangablePropertyChange(functionalEditor, ownerModel);
            onChangeProhibitionReasonChange(functionalEditor, ownerModel);
            onIsAvailablePropertyChange(functionalEditor, ownerModel);
        }
    }
    // Register listeners
    eventMap.registerListener(absolutePath, "EntityChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            editor.setValue((T) ((EntityModel) sender).getEntity());
        }
    });
    eventMap.registerListener(absolutePath, "ItemsChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateListEditor((TakesConstrainedValueEditor<T>) editor, (ListModel) sender);
        }
    });
    eventMap.registerListener(absolutePath, "SelectedItemChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (editor instanceof TakesConstrainedValueListEditor && ownerModels.get(absolutePath) instanceof ListModel) {
                editor.setValue((T) Arrays.asList(((ListModel) sender).getSelectedItem()));
            } else {
                editor.setValue((T) ((ListModel) sender).getSelectedItem());
            }
        }
    });
    eventMap.registerListener(absolutePath, "SelectedItemsChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (editor instanceof TakesConstrainedValueListEditor && ownerModels.get(absolutePath) instanceof ListModel) {
                editor.setValue((T) ((ListModel) sender).getSelectedItems());
            }
        }
    });
    return super.visit(ctx);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public <T> boolean visit(final EditorContext<T> ctx) {
    final String absolutePath = ctx.getAbsolutePath();
    LeafValueEditor<T> currentLeafEditor = ctx.asLeafValueEditor();
    if (currentLeafEditor == null) {
        // Ignore non-leaf Editors
        return super.visit(ctx);
    }
    final LeafValueEditor<T> editor = getActualEditor(currentLeafEditor);
    // If this Editor implements HasValueChangeHandlers, register a value change listener
    if (editor instanceof HasValueChangeHandlers) {
        ((HasValueChangeHandlers<T>) editor).addValueChangeHandler(new ValueChangeHandler<T>() {

            @Override
            public void onValueChange(ValueChangeEvent<T> event) {
                setInModel(ctx, event.getSource(), event.getValue());
            }
        });
    }
    final UiCommonEditor<T> functionalEditor = getFunctionalEditor(currentLeafEditor);
    if (functionalEditor != null) {
        // Set tab index, unless it's being set manually (i.e. already been set)
        if (functionalEditor.getTabIndex() <= 0) {
            functionalEditor.setTabIndex(++tabIndexCounter);
        }
        // Add key press handler
        functionalEditor.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                if (KeyCodes.KEY_ENTER == event.getNativeEvent().getKeyCode()) {
                    setInModel(ctx, editor, editor.getValue());
                }
            }
        });
    }
    // Handle owner entity models
    if (ownerModels.containsKey(absolutePath)) {
        Model ownerModel = ownerModels.get(absolutePath);
        // If this editor edits a ListModel, initialize it
        if (editor instanceof TakesConstrainedValueListEditor && ownerModel instanceof ListModel) {
            updateListEditor((TakesConstrainedValueListEditor<T>) editor, (ListModel) ownerModel);
        } else if (editor instanceof TakesConstrainedValueEditor && ownerModel instanceof ListModel) {
            updateListEditor((TakesConstrainedValueEditor<T>) editor, (ListModel) ownerModel);
        }
        if (functionalEditor != null) {
            // Register a property change listener on the owner entity model
            ownerModel.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

                @Override
                public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
                    Model ownerModel = (Model) sender;
                    String propName = args.propertyName;
                    // IsValid
                    if ("IsValid".equals(propName)) {
                        // $NON-NLS-1$
                        onIsValidPropertyChange(functionalEditor, ownerModel);
                    } else // IsChangable
                    if ("IsChangable".equals(propName)) {
                        // $NON-NLS-1$
                        onIsChangablePropertyChange(functionalEditor, ownerModel);
                    } else // ChangeProhibitionReason
                    if ("ChangeProhibitionReason".equals(propName)) {
                        // $NON-NLS-1$
                        onChangeProhibitionReasonChange(functionalEditor, ownerModel);
                    } else // IsAvailable
                    if ("IsAvailable".equals(propName)) {
                        // $NON-NLS-1$
                        onIsAvailablePropertyChange(functionalEditor, ownerModel);
                    }
                }
            });
            // Update editor since we might have missed property change
            // events fired as part of the entity model constructor
            onIsValidPropertyChange(functionalEditor, ownerModel);
            onIsChangablePropertyChange(functionalEditor, ownerModel);
            onChangeProhibitionReasonChange(functionalEditor, ownerModel);
            onIsAvailablePropertyChange(functionalEditor, ownerModel);
        }
    }
    // Register listeners
    eventMap.registerListener(absolutePath, "EntityChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            editor.setValue((T) ((EntityModel) sender).getEntity());
        }
    });
    eventMap.registerListener(absolutePath, "ItemsChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateListEditor((TakesConstrainedValueEditor<T>) editor, (ListModel) sender);
        }
    });
    eventMap.registerListener(absolutePath, "SelectedItemChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            T selectedItem = (T) ((ListModel) sender).getSelectedItem();
            if (editor instanceof TakesConstrainedValueListEditor && ownerModels.get(absolutePath) instanceof ListModel) {
                editor.setValue((T) Arrays.asList(selectedItem));
            } else {
                editor.setValue(selectedItem);
            }
        }
    });
    eventMap.registerListener(absolutePath, "SelectedItemsChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (editor instanceof TakesConstrainedValueListEditor && ownerModels.get(absolutePath) instanceof ListModel) {
                ((TakesConstrainedValueListEditor) editor).setListValue((List<T>) ((ListModel) sender).getSelectedItems());
            }
        }
    });
    return super.visit(ctx);
}
#end_block

#method_before
<O> void updateListEditor(TakesConstrainedValueEditor<O> listEditor, ListModel<O> parentModel) {
    Collection<O> items = (Collection<O>) parentModel.getItems();
    if (items != null) {
        if (items.size() > 0) {
            O value;
            if (parentModel.getSelectedItem() != null) {
                value = (O) parentModel.getSelectedItem();
            } else {
                value = items.iterator().next();
                // Order is important
                parentModel.setSelectedItem(value);
            }
            listEditor.setValue(value);
        }
        listEditor.setAcceptableValues(items);
    }
}
#method_after
@SuppressWarnings("unchecked")
<O> void updateListEditor(TakesConstrainedValueEditor<O> listEditor, ListModel<O> parentModel) {
    Collection<O> items = (Collection<O>) parentModel.getItems();
    if (items != null) {
        if (items.size() > 0) {
            O value;
            if (parentModel.getSelectedItem() != null) {
                value = (O) parentModel.getSelectedItem();
            } else {
                value = items.iterator().next();
                // Order is important
                parentModel.setSelectedItem(value);
            }
            if (items.contains(value)) {
                if (listEditor instanceof TakesConstrainedValueListEditor) {
                    if (parentModel.getSelectedItems() != null) {
                        ((TakesConstrainedValueListEditor<O>) listEditor).setListValue(parentModel.getSelectedItems());
                    }
                } else {
                    listEditor.setValue(value);
                }
            }
        }
        if (listEditor instanceof TakesConstrainedValueListEditor) {
            ((TakesConstrainedValueListEditor<O>) listEditor).setAcceptableListValues(items);
        } else {
            listEditor.setAcceptableValues(items);
        }
    }
}
#end_block

#method_before
private void updateSelectedList() {
    Set<Integer> indexes = new HashSet<Integer>();
    // Reset the current selected values, we will locate the right selected values below.
    selectedList.clear();
    ListBox listBox = asListBox();
    // item and deselecting it, then at the end re-select them all. This avoids the loop.
    while (listBox.getSelectedIndex() >= 0) {
        int index = listBox.getSelectedIndex();
        listBox.setItemSelected(index, false);
        String selectedElem = listBox.getItemText(index);
        // Reverse lookup the typed value based on the string.
        T value = getTypedValue(selectedElem);
        selectedList.add(value);
        // Mark the index, so we can reselect at the end.
        indexes.add(index);
    }
    // Put back the selection.
    for (Integer index : indexes) {
        listBox.setItemSelected(index, true);
    }
}
#method_after
private void updateSelectedList() {
    Set<Integer> indexes = new HashSet<Integer>();
    // Reset the current selected values, we will locate the right selected values below.
    selectedList.clear();
    ListBox listBox = asListBox();
    // item and deselecting it, then at the end re-select them all. This avoids the loop.
    while (listBox.getSelectedIndex() >= 0) {
        int index = listBox.getSelectedIndex();
        listBox.setItemSelected(index, false);
        if (index >= 0 && index < typedItemList.size()) {
            T value = typedItemList.get(index);
            selectedList.add(value);
        }
        // Mark the index, so we can reselect at the end.
        indexes.add(index);
    }
    // Put back the selection.
    for (Integer index : indexes) {
        listBox.setItemSelected(index, true);
    }
}
#end_block

#method_before
@Override
public void setAcceptableValues(Collection<List<T>> newValues) {
    // Set a value in the super class, so calling setAcceptableValues doesn't add a null value and
    // potentially NPE if the renderer doesn't take kindly to getting a null value passed to it.
    super.setValue(newValues.iterator().next(), false);
    // Populate the list box.
    super.setAcceptableValues(newValues);
    // break if more than one type value renders to the same string.
    for (List<T> value : newValues) {
        putRenderedValueInMap(value);
    }
}
#method_after
@Override
public void setAcceptableValues(Collection<List<T>> newValues) {
    // Set a value in the super class, so calling setAcceptableValues doesn't add a null value and
    // potentially NPE if the renderer doesn't take kindly to getting a null value passed to it.
    super.setValue(newValues.iterator().next(), false);
    // Populate the list box.
    super.setAcceptableValues(newValues);
    // Store the rendered values so we can reverse them to find the right typed value. This will
    // break if more than one type value renders to the same string.
    itemIndex.clear();
    for (List<T> value : newValues) {
        addToItems(value);
        itemIndex.add(value.get(0));
    }
}
#end_block

#method_before
public static <T> TakesConstrainedValueListEditor<T> ofList(TakesValue<List<T>> peer, HasConstrainedValue<List<T>> peerWithConstraints, HasValueChangeHandlers<List<T>> peerWithValueChangeHandlers) {
    return new TakesConstrainedValueListEditor<T>(peer, peerWithConstraints, peerWithValueChangeHandlers);
}
#method_after
public static <T> TakesConstrainedValueListEditor<T> ofList(TakesListValue<T> peer, HasConstrainedValue<List<T>> peerWithConstraints, HasValueChangeHandlers<List<T>> peerWithValueChangeHandlers) {
    return new TakesConstrainedValueListEditor<T>(peer, peerWithConstraints, peerWithValueChangeHandlers);
}
#end_block

#method_before
public void getDataCenterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$
    doRefresh ? // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool) : // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool).withoutRefresh(), aQuery);
}
#method_after
public void getDataCenterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    // $NON-NLS-1$
    SearchParameters params = new SearchParameters("DataCenter: sortby name", SearchType.StoragePool);
    Frontend.getInstance().runQuery(VdcQueryType.Search, doRefresh ? params : params.withoutRefresh(), aQuery);
}
#end_block

#method_before
private void checkCanItemBeSelected(final IStorageModel item, StoragePool dataCenter, boolean isNoExportOrIsoStorageAttached) {
    if (!item.isSupportedInVersion(dataCenter.getCompatibilityVersion())) {
        updateItemSelectability(item, false);
        return;
    }
    boolean isExistingStorage = getModel().getStorage() != null && item.getType() == getModel().getStorage().getStorageType();
    // If we are in edit mode then the type of the entity edited should appear in the selection
    if (isExistingStorage) {
        updateItemSelectability(item, true);
        return;
    }
    boolean isExportDomain = item.getRole() == StorageDomainType.ImportExport;
    boolean isIsoDomain = item.getRole() == StorageDomainType.ISO;
    // export/import and ISO domains which can be added as NFS
    if (!(isExportDomain || isIsoDomain) && isLocalStorage(item) != dataCenter.isLocal()) {
        updateItemSelectability(item, false);
        return;
    }
    boolean isNoneDataCenter = dataCenter.getId().equals(StorageModel.UnassignedDataCenterId);
    boolean isDataDomain = item.getRole() == StorageDomainType.Data;
    // For 'None' data center we allow all data types and no ISO/Export, no reason for further checks
    if (isNoneDataCenter) {
        updateItemSelectability(item, isDataDomain);
        return;
    }
    boolean canAttachExportDomain = isNoExportOrIsoStorageAttached && dataCenter.getStatus() != StoragePoolStatus.Uninitialized;
    boolean canAttachIsoDomain = isNoExportOrIsoStorageAttached && dataCenter.getStatus() != StoragePoolStatus.Uninitialized;
    // local should only be available in a local DC.
    if (((isExportDomain && canAttachExportDomain) || (isIsoDomain && canAttachIsoDomain)) && (!isLocalStorage(item) || dataCenter.isLocal())) {
        updateItemSelectability(item, true);
        return;
    }
    if (isDataDomain) {
        if (isLocalStorage(item)) {
            updateItemSelectability(item, true);
            return;
        }
        if (AsyncDataProvider.getInstance().isMixedStorageDomainsSupported(dataCenter.getCompatibilityVersion())) {
            updateItemSelectability(item, true);
            return;
        } else {
            IdQueryParameters params = new IdQueryParameters(dataCenter.getId());
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageTypesInPoolByPoolId, params, new AsyncQuery(getModel(), new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    List<StorageType> storageTypes = ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                    for (StorageType storageType : storageTypes) {
                        if (storageType.isBlockDomain() != item.getType().isBlockDomain()) {
                            updateItemSelectability(item, false);
                            return;
                        }
                    }
                    updateItemSelectability(item, true);
                    return;
                }
            }));
            return;
        }
    }
    updateItemSelectability(item, false);
}
#method_after
private void checkCanItemBeSelected(final IStorageModel item, StoragePool dataCenter, boolean isNoExportOrIsoStorageAttached) {
    if (!item.isSupportedInVersion(dataCenter.getCompatibilityVersion())) {
        updateItemSelectability(item, false);
        return;
    }
    boolean isExistingStorage = getModel().getStorage() != null && item.getType() == getModel().getStorage().getStorageType();
    // If we are in edit mode then the type of the entity edited should appear in the selection
    if (isExistingStorage) {
        updateItemSelectability(item, true);
        return;
    }
    boolean isExportDomain = item.getRole() == StorageDomainType.ImportExport;
    boolean isIsoDomain = item.getRole() == StorageDomainType.ISO;
    // export/import and ISO domains which can be added as NFS
    if (!(isExportDomain || isIsoDomain) && isLocalStorage(item) != dataCenter.isLocal()) {
        updateItemSelectability(item, false);
        return;
    }
    boolean isNoneDataCenter = dataCenter.getId().equals(StorageModel.UnassignedDataCenterId);
    boolean isDataDomain = item.getRole() == StorageDomainType.Data;
    // For 'None' data center we allow all data types and no ISO/Export, no reason for further checks
    if (isNoneDataCenter) {
        updateItemSelectability(item, isDataDomain);
        return;
    }
    boolean canAttachExportDomain = isNoExportOrIsoStorageAttached && dataCenter.getStatus() != StoragePoolStatus.Uninitialized;
    boolean canAttachIsoDomain = isNoExportOrIsoStorageAttached && dataCenter.getStatus() != StoragePoolStatus.Uninitialized;
    // local storage should only be available in a local DC.
    boolean canAttachLocalStorage = !isLocalStorage(item) || dataCenter.isLocal();
    if (((isExportDomain && canAttachExportDomain) || (isIsoDomain && canAttachIsoDomain)) && canAttachLocalStorage) {
        updateItemSelectability(item, true);
        return;
    }
    if (isDataDomain) {
        if (isLocalStorage(item)) {
            updateItemSelectability(item, true);
            return;
        }
        if (AsyncDataProvider.getInstance().isMixedStorageDomainsSupported(dataCenter.getCompatibilityVersion())) {
            updateItemSelectability(item, true);
            return;
        } else {
            IdQueryParameters params = new IdQueryParameters(dataCenter.getId());
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageTypesInPoolByPoolId, params, new AsyncQuery(getModel(), new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    List<StorageType> storageTypes = ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                    for (StorageType storageType : storageTypes) {
                        if (storageType.isBlockDomain() != item.getType().isBlockDomain()) {
                            updateItemSelectability(item, false);
                            return;
                        }
                    }
                    updateItemSelectability(item, true);
                    return;
                }
            }));
            return;
        }
    }
    updateItemSelectability(item, false);
}
#end_block

#method_before
public ArrayList<IStorageModel> getSelectableModels() {
    // Filter un-selectable models
    ArrayList<IStorageModel> items = Linq.<IStorageModel>cast(getModel().getStorageModels());
    ArrayList<IStorageModel> filterredItems = new ArrayList<IStorageModel>();
    for (IStorageModel model : items) {
        if (((Model) model).getIsSelectable()) {
            filterredItems.add(model);
        }
    }
    return filterredItems;
}
#method_after
public ArrayList<IStorageModel> getSelectableModels() {
    // Filter un-selectable models
    ArrayList<IStorageModel> items = Linq.<IStorageModel>cast(getModel().getStorageModels());
    return getSelectableModels(items);
}
#end_block

#method_before
public ArrayList<IStorageModel> getSelectableModelsByRole() {
    // Filter un-selectable models
    StorageDomainType role = getModel().getAvailableStorageDomainTypeItems().getSelectedItem();
    ArrayList<IStorageModel> items = Linq.<IStorageModel>cast(getModel().getStorageModelsByRole(role));
    ArrayList<IStorageModel> filteredItems = new ArrayList<IStorageModel>();
    for (IStorageModel model : items) {
        if (((Model) model).getIsSelectable()) {
            filteredItems.add(model);
        }
    }
    return filteredItems;
}
#method_after
public ArrayList<IStorageModel> getSelectableModelsByRole() {
    StorageDomainType role = getModel().getAvailableStorageDomainTypeItems().getSelectedItem();
    ArrayList<IStorageModel> items = Linq.<IStorageModel>cast(getModel().getStorageModelsByRole(role));
    return getSelectableModels(items);
}
#end_block

#method_before
public ArrayList<IStorageModel> getSelectableModels() {
    // Filter un-selectable models
    ArrayList<IStorageModel> items = Linq.<IStorageModel>cast(getModel().getStorageModels());
    ArrayList<IStorageModel> filterredItems = new ArrayList<IStorageModel>();
    for (IStorageModel model : items) {
        if (((Model) model).getIsSelectable()) {
            filterredItems.add(model);
        }
    }
    return filterredItems;
}
#method_after
public ArrayList<IStorageModel> getSelectableModels(ArrayList<IStorageModel> storageItems) {
    // Filter un-selectable models
    ArrayList<IStorageModel> filteredItems = new ArrayList<IStorageModel>();
    for (IStorageModel model : storageItems) {
        if (((Model) model).getIsSelectable()) {
            filteredItems.add(model);
        }
    }
    return filteredItems;
}
#end_block

#method_before
private void initDataCenter() {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangeable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangeable(false);
                    getHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangeable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) // We are either adding a new storage or editing an unattached storage
        // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
        // [TODO: In case of an Unattached SD, choose only DCs of the same type]
        {
            AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    StorageModelBehavior storageModelBehavior = behavior;
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }));
        } else // "Edit Storage" mode:
        {
            AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }), getStorage().getId());
        }
    }
}
#method_after
private void initDataCenter() {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangeable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangeable(false);
                    getHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangeable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
            // We are either adding a new storage or editing an unattached storage
            // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
            // [TODO: In case of an Unattached SD, choose only DCs of the same type]
            AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    StorageModelBehavior storageModelBehavior = behavior;
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }));
        } else {
            // "Edit Storage" mode:
            AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }), getStorage().getId());
        }
    }
}
#end_block

#method_before
public void postUpdateHost(Collection<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getCurrentStorageItem() != null && getCurrentStorageItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.<VDS>emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts, selectedItem);
}
#method_after
public void postUpdateHost(Collection<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getCurrentStorageItem() != null && getCurrentStorageItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                // $NON-NLS-1$
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.<VDS>emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts, selectedItem);
}
#end_block

#method_before
void updateFormat() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getCurrentStorageItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangeable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getCurrentStorageItem().getRole().isDataDomain()) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getCurrentStorageItem().getType() == StorageType.NFS || getCurrentStorageItem().getType() == StorageType.LOCALFS) && (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getCurrentStorageItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getCurrentStorageItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangeable(true);
            if (getCurrentStorageItem().getType() != StorageType.POSIXFS && getCurrentStorageItem().getType() != StorageType.GLUSTERFS) {
                formats.add(StorageFormatType.V1);
            }
            if ((getCurrentStorageItem().getType() == StorageType.FCP || getCurrentStorageItem().getType() == StorageType.ISCSI) && getCurrentStorageItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#method_after
void updateFormat() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getCurrentStorageItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangeable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getCurrentStorageItem().getRole().isDataDomain()) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getCurrentStorageItem().getType() == StorageType.NFS || getCurrentStorageItem().getType() == StorageType.LOCALFS) && (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getCurrentStorageItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getCurrentStorageItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else {
            // Unassigned DC:
            if ((getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangeable(true);
            if (getCurrentStorageItem().getType() != StorageType.POSIXFS && getCurrentStorageItem().getType() != StorageType.GLUSTERFS) {
                formats.add(StorageFormatType.V1);
            }
            if ((getCurrentStorageItem().getType() == StorageType.FCP || getCurrentStorageItem().getType() == StorageType.ISCSI) && getCurrentStorageItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#end_block

#method_before
private void validateListItems(ListModel<?> listModel) {
    ValidationResult result = new NotEmptyValidation().validate(listModel.getSelectedItem());
    if (!result.getSuccess()) {
        listModel.setIsValid(false);
        for (String reason : result.getReasons()) {
            listModel.getInvalidityReasons().add(reason);
        }
    } else {
        listModel.setIsValid(true);
    }
}
#method_after
private void validateListItems(ListModel<?> listModel) {
    ValidationResult result = new NotEmptyValidation().validate(listModel.getSelectedItem());
    listModel.setIsValid(result.getSuccess());
    listModel.getInvalidityReasons().addAll(result.getReasons());
}
#end_block

#method_before
public void postStorageNameValidation() {
    if (// $NON-NLS-1$
    getLastExecutedCommand().getName().equals("OnSave")) {
        onSavePostNameValidation();
    }
}
#method_after
public void postStorageNameValidation() {
    if (getLastExecutedCommand().getName().equals("OnSave")) {
        // $NON-NLS-1$
        onSavePostNameValidation();
    }
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.propertyName.equals("storage_domain_shared_status")) {
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("storage_domain_shared_status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewDomainCommand()) {
        newDomain();
    } else if (command == getImportDomainCommand()) {
        importDomain();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getDestroyCommand()) {
        destroy();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "CancelConfirm".equals(command.getName())) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    "CancelImportConfirm".equals(command.getName())) {
        cancelImportConfirm();
    } else if (// $NON-NLS-1$
    "OnImport".equals(command.getName())) {
        onImport();
    } else if ("OnImportFile".equals(command.getName())) {
        // $NON-NLS-1$
        if (getConfirmWindow() != null && !((ConfirmationModel) getConfirmWindow()).validate()) {
            return;
        }
        cancelConfirm();
        getExistingStorageDomainList();
    } else if ("OnImportSan".equals(command.getName())) {
        // $NON-NLS-1$
        if (getConfirmWindow() != null && !((ConfirmationModel) getConfirmWindow()).validate()) {
            return;
        }
        cancelConfirm();
        onImportSanDomainApprove();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnDestroy".equals(command.getName())) {
        onDestroy();
    } else if (// $NON-NLS-1$
    "OnSaveSanStorage".equals(command.getName())) {
        onSaveSanStorage();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewDomainCommand()) {
        newDomain();
    } else if (command == getImportDomainCommand()) {
        importDomain();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getDestroyCommand()) {
        destroy();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("CancelConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirm();
    } else if ("CancelImportConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        cancelImportConfirm();
    } else if ("OnImport".equals(command.getName())) {
        // $NON-NLS-1$
        onImport();
    } else if ("OnImportFile".equals(command.getName())) {
        // $NON-NLS-1$
        if (getConfirmWindow() != null && !((ConfirmationModel) getConfirmWindow()).validate()) {
            return;
        }
        cancelConfirm();
        getExistingStorageDomainList();
    } else if ("OnImportSan".equals(command.getName())) {
        // $NON-NLS-1$
        if (getConfirmWindow() != null && !((ConfirmationModel) getConfirmWindow()).validate()) {
            return;
        }
        cancelConfirm();
        onImportSanDomainApprove();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnDestroy".equals(command.getName())) {
        // $NON-NLS-1$
        onDestroy();
    } else if ("OnSaveSanStorage".equals(command.getName())) {
        // $NON-NLS-1$
        onSaveSanStorage();
    }
}
#end_block

#method_before
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if (// $NON-NLS-1$
    "SaveNfs".equals(key)) {
        saveNfsStorage(context);
    } else if (// $NON-NLS-1$
    "SaveLocal".equals(key)) {
        saveLocalStorage(context);
    } else if (// $NON-NLS-1$
    "SavePosix".equals(key)) {
        savePosixStorage(context);
    } else if (// $NON-NLS-1$
    "SaveSan".equals(key)) {
        saveSanStorage(context);
    } else if (// $NON-NLS-1$
    "ImportFile".equals(key)) {
        importFileStorage(context);
    } else if (// $NON-NLS-1$
    "ImportSan".equals(key)) {
        importSanStorage(context);
    } else if (// $NON-NLS-1$
    "Finish".equals(key)) {
        getWindow().stopProgress();
        if ((Boolean) data.get(1)) {
            cancel();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#method_after
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if ("SaveNfs".equals(key)) {
        // $NON-NLS-1$
        saveNfsStorage(context);
    } else if ("SaveLocal".equals(key)) {
        // $NON-NLS-1$
        saveLocalStorage(context);
    } else if ("SavePosix".equals(key)) {
        // $NON-NLS-1$
        savePosixStorage(context);
    } else if ("SaveSan".equals(key)) {
        // $NON-NLS-1$
        saveSanStorage(context);
    } else if ("ImportFile".equals(key)) {
        // $NON-NLS-1$
        importFileStorage(context);
    } else if ("ImportSan".equals(key)) {
        // $NON-NLS-1$
        importSanStorage(context);
    } else if ("Finish".equals(key)) {
        // $NON-NLS-1$
        getWindow().stopProgress();
        if ((Boolean) data.get(1)) {
            cancel();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#end_block

#method_before
public void onAddCluster() {
    ClusterModel model = (ClusterModel) getWindow();
    VDSGroup cluster = new VDSGroup();
    if (model.getProgress() != null) {
        return;
    }
    if (// CPU is mandatory only if the
    !model.validate(model.getEnableOvirtService().getEntity())) // cluster is virt enabled
    {
        return;
    }
    // Save changes.
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    if (model.getClusterPolicy().getSelectedItem() != null) {
        ClusterPolicy selectedPolicy = model.getClusterPolicy().getSelectedItem();
        cluster.setClusterPolicyId(selectedPolicy.getId());
        cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVdsGroup, new ManagementNetworkOnClusterOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddCluster(result.getReturnValue());
        }
    }, this);
}
#method_after
public void onAddCluster() {
    ClusterModel model = (ClusterModel) getWindow();
    VDSGroup cluster = new VDSGroup();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(model.getEnableOvirtService().getEntity())) {
        // cluster is virt enabled
        return;
    }
    // Save changes.
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    if (model.getClusterPolicy().getSelectedItem() != null) {
        ClusterPolicy selectedPolicy = model.getClusterPolicy().getSelectedItem();
        cluster.setClusterPolicyId(selectedPolicy.getId());
        cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVdsGroup, new ManagementNetworkOnClusterOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddCluster(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    "AddCluster".equals(command.getName())) {
        addCluster();
    }
    if (// $NON-NLS-1$
    "AddHost".equals(command.getName())) {
        addHost();
    }
    if (// $NON-NLS-1$
    "SelectHost".equals(command.getName())) {
        selectHost();
    }
    if (// $NON-NLS-1$
    "AddDataStorage".equals(command.getName())) {
        addDataStorage();
    }
    if (// $NON-NLS-1$
    "AttachDataStorage".equals(command.getName())) {
        attachDataStorage();
    }
    if (// $NON-NLS-1$
    "AddIsoStorage".equals(command.getName())) {
        addIsoStorage();
    }
    if (// $NON-NLS-1$
    "AttachIsoStorage".equals(command.getName())) {
        attachIsoStorage();
    }
    if (// $NON-NLS-1$
    "OnAddCluster".equals(command.getName())) {
        onAddCluster();
    }
    if (// $NON-NLS-1$
    "OnSelectHost".equals(command.getName())) {
        onSelectHost();
    }
    if (// $NON-NLS-1$
    "OnAddHost".equals(command.getName())) {
        onAddHost();
    }
    if (// $NON-NLS-1$
    "OnAddStorage".equals(command.getName())) {
        onAddStorage();
    }
    if (// $NON-NLS-1$
    "OnSaveSanStorage".equals(command.getName())) {
        onSaveSanStorage();
    }
    if (// $NON-NLS-1$
    "OnAttachStorage".equals(command.getName())) {
        onAttachStorage();
    }
    if (// $NON-NLS-1$
    "AddLocalStorage".equals(command.getName())) {
        addLocalStorage();
    }
    if (// $NON-NLS-1$
    "OnConfirmPMHost".equals(command.getName())) {
        onConfirmPMHost();
    }
    if (// $NON-NLS-1$
    "CancelConfirm".equals(command.getName())) {
        cancelConfirm();
    }
    if (// $NON-NLS-1$
    "CancelConfirmWithFocus".equals(command.getName())) {
        cancelConfirmWithFocus();
    }
    if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if ("AddCluster".equals(command.getName())) {
        // $NON-NLS-1$
        addCluster();
    }
    if ("AddHost".equals(command.getName())) {
        // $NON-NLS-1$
        addHost();
    }
    if ("SelectHost".equals(command.getName())) {
        // $NON-NLS-1$
        selectHost();
    }
    if ("AddDataStorage".equals(command.getName())) {
        // $NON-NLS-1$
        addDataStorage();
    }
    if ("AttachDataStorage".equals(command.getName())) {
        // $NON-NLS-1$
        attachDataStorage();
    }
    if ("AddIsoStorage".equals(command.getName())) {
        // $NON-NLS-1$
        addIsoStorage();
    }
    if ("AttachIsoStorage".equals(command.getName())) {
        // $NON-NLS-1$
        attachIsoStorage();
    }
    if ("OnAddCluster".equals(command.getName())) {
        // $NON-NLS-1$
        onAddCluster();
    }
    if ("OnSelectHost".equals(command.getName())) {
        // $NON-NLS-1$
        onSelectHost();
    }
    if ("OnAddHost".equals(command.getName())) {
        // $NON-NLS-1$
        onAddHost();
    }
    if ("OnAddStorage".equals(command.getName())) {
        // $NON-NLS-1$
        onAddStorage();
    }
    if ("OnSaveSanStorage".equals(command.getName())) {
        // $NON-NLS-1$
        onSaveSanStorage();
    }
    if ("OnAttachStorage".equals(command.getName())) {
        // $NON-NLS-1$
        onAttachStorage();
    }
    if ("AddLocalStorage".equals(command.getName())) {
        // $NON-NLS-1$
        addLocalStorage();
    }
    if ("OnConfirmPMHost".equals(command.getName())) {
        // $NON-NLS-1$
        onConfirmPMHost();
    }
    if ("CancelConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirm();
    }
    if ("CancelConfirmWithFocus".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmWithFocus();
    }
    if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#end_block

#method_before
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if (// $NON-NLS-1$
    "SaveNfs".equals(key)) {
        saveNfsStorage(context);
    } else if (// $NON-NLS-1$
    "SaveLocal".equals(key)) {
        saveLocalStorage(context);
    } else if (// $NON-NLS-1$
    "SaveSan".equals(key)) {
        saveSanStorage(context);
    } else if (// $NON-NLS-1$
    "Finish".equals(key)) {
        getWindow().stopProgress();
        if ((Boolean) data.get(1)) {
            cancel();
            postAction();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#method_after
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if ("SaveNfs".equals(key)) {
        // $NON-NLS-1$
        saveNfsStorage(context);
    } else if ("SaveLocal".equals(key)) {
        // $NON-NLS-1$
        saveLocalStorage(context);
    } else if ("SaveSan".equals(key)) {
        // $NON-NLS-1$
        saveSanStorage(context);
    } else if ("Finish".equals(key)) {
        // $NON-NLS-1$
        getWindow().stopProgress();
        if ((Boolean) data.get(1)) {
            cancel();
            postAction();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#end_block

#method_before
private void initDataCenter() {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangeable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangeable(false);
                    getHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangeable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) // We are either adding a new storage or editing an unattached storage
        // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
        // [TODO: In case of an Unattached SD, choose only DCs of the same type]
        {
            AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    StorageModelBehavior storageModelBehavior = behavior;
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }));
        } else // "Edit Storage" mode:
        {
            AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }), getStorage().getId());
        }
    }
}
#method_after
private void initDataCenter() {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangeable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangeable(false);
                    getHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangeable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
            // We are either adding a new storage or editing an unattached storage
            // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
            // [TODO: In case of an Unattached SD, choose only DCs of the same type]
            AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    StorageModelBehavior storageModelBehavior = behavior;
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }));
        } else {
            // "Edit Storage" mode:
            AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }), getStorage().getId());
        }
    }
}
#end_block

#method_before
public void postUpdateHost(Collection<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getCurrentStorageItem() != null && getCurrentStorageItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.<VDS>emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts, selectedItem);
}
#method_after
public void postUpdateHost(Collection<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getCurrentStorageItem() != null && getCurrentStorageItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                // $NON-NLS-1$
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.<VDS>emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts, selectedItem);
}
#end_block

#method_before
void updateFormat() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getCurrentStorageItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangeable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getCurrentStorageItem().getRole().isDataDomain()) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getCurrentStorageItem().getType() == StorageType.NFS || getCurrentStorageItem().getType() == StorageType.LOCALFS) && (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getCurrentStorageItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getCurrentStorageItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangeable(true);
            if (getCurrentStorageItem().getType() != StorageType.POSIXFS && getCurrentStorageItem().getType() != StorageType.GLUSTERFS) {
                formats.add(StorageFormatType.V1);
            }
            if ((getCurrentStorageItem().getType() == StorageType.FCP || getCurrentStorageItem().getType() == StorageType.ISCSI) && getCurrentStorageItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#method_after
void updateFormat() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getCurrentStorageItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangeable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getCurrentStorageItem().getRole().isDataDomain()) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getCurrentStorageItem().getType() == StorageType.NFS || getCurrentStorageItem().getType() == StorageType.LOCALFS) && (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getCurrentStorageItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getCurrentStorageItem().getType().isBlockDomain() && dataCenter.getCompatibilityVersion().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getCompatibilityVersion().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else {
            // Unassigned DC:
            if ((getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangeable(true);
            if (getCurrentStorageItem().getType() != StorageType.POSIXFS && getCurrentStorageItem().getType() != StorageType.GLUSTERFS) {
                formats.add(StorageFormatType.V1);
            }
            if ((getCurrentStorageItem().getType() == StorageType.FCP || getCurrentStorageItem().getType() == StorageType.ISCSI) && getCurrentStorageItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#end_block

#method_before
private void validateListItems(ListModel<?> listModel) {
    ValidationResult result = new NotEmptyValidation().validate(listModel.getSelectedItem());
    if (!result.getSuccess()) {
        listModel.setIsValid(false);
        for (String reason : result.getReasons()) {
            listModel.getInvalidityReasons().add(reason);
        }
    } else {
        listModel.setIsValid(true);
    }
}
#method_after
private void validateListItems(ListModel<?> listModel) {
    ValidationResult result = new NotEmptyValidation().validate(listModel.getSelectedItem());
    listModel.setIsValid(result.getSuccess());
    listModel.getInvalidityReasons().addAll(result.getReasons());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void revealStorageView(StorageModel object) {
    StorageType storageType = storageTypeListEditor.asEditor().getActualEditor().getValue();
    StorageDomainType storageDomainType = domainFunctionListEditor.asEditor().getActualEditor().getValue();
    if (storageType == null || storageDomainType == null) {
        return;
    }
    switch(storageType) {
        case NFS:
            storageView = new NfsStorageView();
            break;
        case LOCALFS:
            storageView = new LocalStorageView();
            break;
        case POSIXFS:
            storageView = new PosixStorageView();
            break;
        case GLUSTERFS:
            storageView = new GlusterStorageView();
            break;
        case FCP:
            if (!object.getBehavior().isImport()) {
                storageView = new FcpStorageView(true);
            } else {
                storageView = new ImportFcpStorageView();
            }
            break;
        case ISCSI:
            if (!object.getBehavior().isImport()) {
                storageView = new IscsiStorageView(true);
            } else {
                storageView = new ImportIscsiStorageView();
            }
            break;
        default:
            break;
    }
    updateStorageItem(object);
    IStorageModel model = object.getCurrentStorageItem();
    // Re-apply element IDs on 'storageView' change
    ViewIdHandler.idHandler.generateAndSetIds(this);
    // Clear the current storage view
    specificStorageTypePanel.clear();
    // Add the new storage view and call focus on it if needed
    if (storageView != null && model != null) {
        storageView.edit(model);
        specificStorageTypePanel.add(storageView);
        if (!nameEditor.isVisible()) {
            storageView.focus();
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void revealStorageView(StorageModel object) {
    StorageType storageType = storageTypeListEditor.asEditor().getActualEditor().getValue();
    StorageDomainType storageDomainType = domainFunctionListEditor.asEditor().getActualEditor().getValue();
    if (storageType == null || storageDomainType == null) {
        return;
    }
    switch(storageType) {
        case NFS:
            storageView = new NfsStorageView();
            break;
        case LOCALFS:
            storageView = new LocalStorageView();
            break;
        case POSIXFS:
            storageView = new PosixStorageView();
            break;
        case GLUSTERFS:
            storageView = new GlusterStorageView();
            break;
        case FCP:
            if (!object.getBehavior().isImport()) {
                storageView = new FcpStorageView(true);
            } else {
                storageView = new ImportFcpStorageView();
            }
            break;
        case ISCSI:
            if (!object.getBehavior().isImport()) {
                storageView = new IscsiStorageView(true);
            } else {
                storageView = new ImportIscsiStorageView();
            }
            break;
        default:
            break;
    }
    updateStorageItem(object, storageType, storageDomainType);
    IStorageModel model = object.getCurrentStorageItem();
    // Re-apply element IDs on 'storageView' change
    ViewIdHandler.idHandler.generateAndSetIds(this);
    // Clear the current storage view
    specificStorageTypePanel.clear();
    // Add the new storage view and call focus on it if needed
    if (storageView != null && model != null) {
        storageView.edit(model);
        specificStorageTypePanel.add(storageView);
        if (!nameEditor.isVisible()) {
            storageView.focus();
        }
    }
}
#end_block

#method_before
private void updateStorageItem(StorageModel storageModel) {
    storageModel.updateCurrentStorageItem();
}
#method_after
private void updateStorageItem(StorageModel storageModel, StorageType storageType, StorageDomainType domainType) {
    storageModel.updateStorageSelectedItem(storageType, domainType);
}
#end_block

#method_before
private void updateStorageTypesByDomainType(StorageModel storageModel) {
    storageModel.updateStorageTypesByDomainType();
}
#method_after
private void updateStorageTypesByDomainType(StorageModel storageModel) {
    StorageDomainType storageDomainType = domainFunctionListEditor.asEditor().getActualEditor().getValue();
    storageModel.updateStorageTypesByDomainType(storageDomainType);
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            dataCenter_SelectedItemChanged();
        } else if (sender == getHost()) {
            host_SelectedItemChanged();
        } else if (sender == getAvailableStorageTypeItems()) {
            storageType_SelectedItemChanged();
        } else if (sender == getAvailableStorageDomainTypeItems()) {
            updateCurrentStorageItem();
        }
    } else if (ev.matchesDefinition(itemsChangedEventDefinition)) {
        storageItemsChanged();
    } else if (ev.matchesDefinition(NfsStorageModel.pathChangedEventDefinition)) {
        nfsStorageModel_PathChanged(sender, args);
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            dataCenter_SelectedItemChanged();
        } else if (sender == getHost()) {
            host_SelectedItemChanged();
        } else if (sender == getAvailableStorageTypeItems()) {
            storageType_SelectedItemChanged();
        } else if (sender == getAvailableStorageDomainTypeItems()) {
            StorageDomainType storageDomainType = getAvailableStorageDomainTypeItems().getSelectedItem();
            StorageType storageType = getAvailableStorageTypeItems().getSelectedItem();
            updateStorageSelectedItem(storageType, storageDomainType);
        }
    } else if (ev.matchesDefinition(itemsChangedEventDefinition)) {
        storageItemsChanged();
    } else if (ev.matchesDefinition(NfsStorageModel.pathChangedEventDefinition)) {
        nfsStorageModel_PathChanged(sender, args);
    }
}
#end_block

#method_before
protected void storageType_SelectedItemChanged() {
    updateCurrentStorageItem();
    if (getCurrentStorageItem() != null) {
        updateFormat();
        updateHost();
    }
    updateWipeAfterDelete();
}
#method_after
protected void storageType_SelectedItemChanged() {
    StorageType storageType = getAvailableStorageTypeItems().getSelectedItem();
    StorageDomainType storageDomainType = getAvailableStorageDomainTypeItems().getSelectedItem();
    updateStorageSelectedItem(storageType, storageDomainType);
    if (getCurrentStorageItem() != null) {
        updateFormat();
        updateHost();
    }
    updateWipeAfterDelete();
}
#end_block

#method_before
public void updateStorageTypesByDomainType() {
    StorageDomainType storageDomainType = getAvailableStorageDomainTypeItems().getSelectedItem();
    Set<StorageType> filteredStorageTypes = new LinkedHashSet<>();
    for (IStorageModel currModel : getItems()) {
        if (currModel.getRole() == storageDomainType) {
            filteredStorageTypes.add(currModel.getType());
        }
    }
    getAvailableStorageTypeItems().setItems(filteredStorageTypes);
}
#method_after
public void updateStorageTypesByDomainType(StorageDomainType storageDomainType) {
    Set<StorageType> filteredStorageTypes = new LinkedHashSet<>();
    for (IStorageModel currModel : getItems()) {
        if (currModel.getRole() == storageDomainType) {
            filteredStorageTypes.add(currModel.getType());
        }
    }
    getAvailableStorageTypeItems().setItems(filteredStorageTypes);
}
#end_block

#method_before
public void updateFormItem(FormItem item, int... valueWidths) {
    // You can only pass in 1 value parameter.
    assert valueWidths.length < 2;
    Widget valueWidget = item.resolveValueWidget();
    valueWidget.getElement().setId(// $NON-NLS-1$
    ElementIdUtils.createFormGridElementId(elementId, item.getColumn(), item.getRow(), "_value"));
    valueWidget.setStyleName(style.formPanelValue());
    boolean visible = item.getIsAvailable();
    Column widgetColumn = findColumn(item.getRow(), item.getColumn());
    if (widgetColumn != null) {
        IsWidget itemCell = widgetColumn.getWidget(0);
        if (itemCell instanceof Row) {
            Row itemCellRow = (Row) itemCell;
            // Update item visibility
            itemCellRow.setVisible(visible);
            List<Integer> sizesList = formSizeMap.get(item);
            int valueWidth;
            if (valueWidths.length == 1) {
                sizesList.set(1, valueWidths[0]);
                valueWidth = valueWidths[0];
            } else {
                valueWidth = sizesList.get(1);
            }
            if (itemCellRow.getWidgetCount() > 1) {
                // Clear out old value.
                itemCellRow.remove(1);
            }
            Column valueColumn = new Column(COL_PREFIX + valueWidth);
            valueColumn.add(valueWidget);
            itemCellRow.add(valueColumn);
        }
    }
}
#method_after
public void updateFormItem(FormItem item) {
    updateFormItem(item, null);
}
#end_block

#method_before
private void initClusterAndStorage(StoragePool dataCenter) {
    AsyncDataProvider.getInstance().getClusterByServiceList(new AsyncQuery(ImportVmFromExternalProviderModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            ArchitectureType targetArch = getTargetArchitecture();
            if (targetArch != null) {
                clusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, targetArch);
            }
            getCluster().setItems(clusters);
            // get storage domains
            AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(ImportVmFromExternalProviderModel.this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<StorageDomain> storageDomains = (List<StorageDomain>) returnValue;
                    // filter storage domains
                    List<StorageDomain> filteredStorageDomains = new ArrayList<>();
                    for (StorageDomain domain : storageDomains) {
                        if (Linq.isDataActiveStorageDomain(domain)) {
                            filteredStorageDomains.add(domain);
                        }
                    }
                    getStorage().setItems(filteredStorageDomains);
                    if (getClusterQuota().getIsAvailable()) {
                        initQuotaForStorageDomains();
                    } else {
                        initDisksStorageDomainsList();
                    }
                }
            }), getStoragePool().getId());
        }
    }), dataCenter.getId(), true, false);
}
#method_after
private void initClusterAndStorage(StoragePool dataCenter) {
    AsyncDataProvider.getInstance().getClusterByServiceList(new AsyncQuery(ImportVmFromExternalProviderModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            ArchitectureType targetArch = getTargetArchitecture();
            if (targetArch != null) {
                clusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, targetArch);
            }
            getCluster().setItems(clusters);
            getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
            // get storage domains
            AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(ImportVmFromExternalProviderModel.this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<StorageDomain> storageDomains = (List<StorageDomain>) returnValue;
                    // filter storage domains
                    List<StorageDomain> filteredStorageDomains = new ArrayList<>();
                    for (StorageDomain domain : storageDomains) {
                        if (Linq.isDataActiveStorageDomain(domain)) {
                            filteredStorageDomains.add(domain);
                        }
                    }
                    getStorage().setItems(filteredStorageDomains);
                    if (getClusterQuota().getIsAvailable()) {
                        initQuotaForStorageDomains();
                    } else {
                        initDisksStorageDomainsList();
                    }
                }
            }), getStoragePool().getId());
        }
    }), dataCenter.getId(), true, false);
}
#end_block

#method_before
private List<VdcActionParametersBase> buildImportVmFromExternalProviderParameters() {
    List<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object item : getItems()) {
        VM vm = ((ImportVmData) item).getVm();
        ImportVmFromExternalProviderParameters prm = new ImportVmFromExternalProviderParameters();
        prm.setVm(vm);
        prm.setUrl(url);
        prm.setUsername(username);
        prm.setPassword(password);
        prm.setProxyHostId(proxyHostId);
        prm.setDestDomainId(getStorage().getSelectedItem().getId());
        prm.setStoragePoolId(getStoragePool().getId());
        prm.setVdsGroupId(((VDSGroup) getCluster().getSelectedItem()).getId());
        prm.setVirtioDriversIso(getIso().getIsChangable() ? getIso().getSelectedItem() : null);
        if (getClusterQuota().getSelectedItem() != null && getClusterQuota().getIsAvailable()) {
            prm.setQuotaId(((Quota) getClusterQuota().getSelectedItem()).getId());
        }
        CpuProfile cpuProfile = getCpuProfiles().getSelectedItem();
        if (cpuProfile != null) {
            prm.setCpuProfileId(cpuProfile.getId());
        }
        prm.setForceOverride(true);
        prm.setCopyCollapse((Boolean) ((ImportVmData) item).getCollapseSnapshots().getEntity());
        for (Map.Entry<Guid, Disk> entry : vm.getDiskMap().entrySet()) {
            DiskImage disk = (DiskImage) entry.getValue();
            ImportDiskData importDiskData = getDiskImportData(disk.getDiskAlias());
            disk.setVolumeType(getAllocation().getSelectedItem());
            disk.setvolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(disk.getVolumeType(), getStorage().getSelectedItem().getStorageType()));
            if (getDiskImportData(disk.getDiskAlias()).getSelectedQuota() != null) {
                disk.setQuotaId(importDiskData.getSelectedQuota().getId());
            }
        }
        if (((ImportVmData) item).isExistsInSystem() || (Boolean) ((ImportVmData) item).getClone().getEntity()) {
            prm.setImportAsNewEntity(true);
            prm.setCopyCollapse(true);
        }
        prms.add(prm);
    }
    return prms;
}
#method_after
private List<VdcActionParametersBase> buildImportVmFromExternalProviderParameters() {
    List<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object item : getItems()) {
        VM vm = ((ImportVmData) item).getVm();
        ImportVmFromExternalProviderParameters prm = new ImportVmFromExternalProviderParameters();
        prm.setVm(vm);
        prm.setUrl(url);
        prm.setUsername(username);
        prm.setPassword(password);
        prm.setProxyHostId(proxyHostId);
        prm.setDestDomainId(getStorage().getSelectedItem().getId());
        prm.setStoragePoolId(getStoragePool().getId());
        prm.setVdsGroupId(((VDSGroup) getCluster().getSelectedItem()).getId());
        prm.setVirtioIsoName(getIso().getIsChangable() ? getIso().getSelectedItem() : null);
        if (getClusterQuota().getSelectedItem() != null && getClusterQuota().getIsAvailable()) {
            prm.setQuotaId(((Quota) getClusterQuota().getSelectedItem()).getId());
        }
        CpuProfile cpuProfile = getCpuProfiles().getSelectedItem();
        if (cpuProfile != null) {
            prm.setCpuProfileId(cpuProfile.getId());
        }
        prm.setForceOverride(true);
        prm.setCopyCollapse((Boolean) ((ImportVmData) item).getCollapseSnapshots().getEntity());
        for (Map.Entry<Guid, Disk> entry : vm.getDiskMap().entrySet()) {
            DiskImage disk = (DiskImage) entry.getValue();
            ImportDiskData importDiskData = getDiskImportData(disk.getDiskAlias());
            disk.setVolumeType(getAllocation().getSelectedItem());
            disk.setvolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(disk.getVolumeType(), getStorage().getSelectedItem().getStorageType()));
            if (getDiskImportData(disk.getDiskAlias()).getSelectedQuota() != null) {
                disk.setQuotaId(importDiskData.getSelectedQuota().getId());
            }
        }
        if (((ImportVmData) item).isExistsInSystem() || (Boolean) ((ImportVmData) item).getClone().getEntity()) {
            prm.setImportAsNewEntity(true);
            prm.setCopyCollapse(true);
        }
        prms.add(prm);
    }
    return prms;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testGetCapabilities() throws JsonParseException, JsonMappingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String capabilitiesJson = "{\"jsonrpc\": \"2.0\", \"id\": \"aed1feb4-42cf-4bf4-8ddf-852251152b68\", \"result\": {\"HBAInventory\": {\"iSCSI\": " + "[{\"InitiatorName\": \"iqn.1994-05.com.redhat:d990cf85cdeb\"}], \"FC\": []}, \"packages2\": {\"kernel\": {\"release\": \"200.fc19.x86_64\"," + " \"buildtime\": 1384356599.0, \"version\": \"3.11.8\"}, \"spice-server\": {\"release\": \"3.fc19\", \"buildtime\": 1383130020, " + "\"version\": \"0.12.4\"}, \"vdsm\": {\"release\": \"163.git9adad51.fc19\", \"buildtime\": 1385064768, \"version\": \"4.13.0\"}, " + "\"qemu-kvm\": {\"release\": \"13.fc19\", \"buildtime\": 1383700301, \"version\": \"1.4.2\"}, \"libvirt\": {\"release\": " + "\"1.fc19\", \"buildtime\": 1383765188, \"version\": \"1.0.5.7\"}, \"qemu-img\": {\"release\": \"13.fc19\", \"buildtime\": " + "1383700301, \"version\": \"1.4.2\"}, \"mom\": {\"release\": \"3.13.giteb3985f.fc19\", \"buildtime\": 1384283536, \"version\"" + ": \"0.3.2\"}}, \"cpuModel\": \"Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz\", \"hooks\": {}, \"cpuSockets\": \"1\", \"vmTypes\": " + "[\"kvm\"], \"networks\": {\"ovirtmgmt\": {\"iface\": \"ovirtmgmt\", \"addr\":" + " \"192.168.1.10\", \"cfg\": {\"DEFROUTE\": \"yes\", \"IPADDR\": \"192.168.1.10\", \"GATEWAY\": \"192.168.1.1\", \"DELAY\":" + " \"0\", \"NM_CONTROLLED\": \"no\", \"NETMASK\": \"255.255.255.0\", \"BOOTPROTO\": \"none\", \"STP\": \"no\", \"DEVICE\": " + "\"ovirtmgmt\", \"TYPE\": \"Bridge\", \"ONBOOT\": \"yes\"}, \"ipv6addrs\": [\"fe80::baca:3aff:fea9:77e2/64\"], \"gateway\":" + " \"192.168.1.1\", \"netmask\": \"255.255.255.0\", \"stp\": \"off\", \"bridged\": true, \"qosInbound\": \"\", \"qosOutbound\":" + " \"\", \"mtu\": \"1500\", \"ipv6gateway\": \"::\", \"ports\": [\"em1\"]}}, \"bridges\": {\"ovirtmgmt\": {\"addr\": \"192.168.1.10\"," + " \"cfg\": {\"DEFROUTE\": \"yes\", \"IPADDR\": \"192.168.1.10\", \"GATEWAY\": \"192.168.1.1\", \"DELAY\": \"0\", \"NM_CONTROLLED\":" + " \"no\", \"NETMASK\": \"255.255.255.0\", \"BOOTPROTO\": \"none\", \"STP\": \"no\", \"DEVICE\": \"ovirtmgmt\", \"TYPE\": \"Bridge\"," + " \"ONBOOT\": \"yes\"}, \"ipv6addrs\": [\"fe80::baca:3aff:fea9:77e2/64\"], \"mtu\": \"1500\", \"netmask\": \"255.255.255.0\", " + "\"stp\": \"off\", \"ipv6gateway\": \"::\", \"gateway\": \"192.168.1.1\", \"ports\": [\"em1\"]}}, \"uuid\": \"4C4C4544-0046-4E10-8032-B2C04F385A31\"," + " \"nics\": {\"em1\": {\"netmask\": \"\", \"addr\": \"\", \"hwaddr\": \"b8:ca:3a:a9:77:e2\", \"cfg\": {\"BRIDGE\": \"ovirtmgmt\", \"NM_CONTROLLED\":" + " \"no\", \"HWADDR\": \"b8:ca:3a:a9:77:e2\", \"STP\": \"no\", \"DEVICE\": \"em1\", \"ONBOOT\": \"yes\"}, \"ipv6addrs\": [\"fe80::baca:3aff:fea9:77e2/64\"]," + " \"speed\": 100, \"mtu\": \"1500\"}}, \"software_revision\": \"163\", \"clusterLevels\": [\"3.0\", \"3.1\", \"3.2\", \"3.3\"], \"cpuFlags\": " + "\"fpu,vme,de,pse,tsc,msr,pae,mce,cx8,apic,sep,mtrr,pge,mca,cmov,pat,pse36,clflush,dts,acpi,mmx,fxsr,sse,sse2,ss,ht,tm,pbe,syscall,nx,rdtscp,lm,constant_" + "tsc,arch_perfmon,pebs,bts,rep_good,nopl,xtopology,nonstop_tsc,aperfmperf,eagerfpu,pni,pclmulqdq,dtes64,monitor,ds_cpl,vmx,smx,est,tm2,ssse3,cx16,xtpr,pdcm," + "pcid,sse4_1,sse4_2,x2apic,popcnt,tsc_deadline_timer,aes,xsave,avx,f16c,rdrand,lahf_lm,ida,arat,epb,xsaveopt,pln,pts,dtherm,tpr_shadow,vnmi,flexpriority,ept," + "vpid,fsgsbase,smep,erms,model_Nehalem,model_Conroe,model_coreduo,model_core2duo,model_Penryn,model_Westmere,model_n270,model_SandyBridge\", \"ISCSIInitiatorName\"" + ": \"iqn.1994-05.com.redhat:d990cf85cdeb\", \"netConfigDirty\": \"False\", \"supportedENGINEs\": [\"3.0\", \"3.1\", \"3.2\", \"3.3\"], \"reservedMem\": \"321\"," + " \"bondings\": {\"bond0\": {\"netmask\": \"\", \"addr\": \"\", \"slaves\": [], \"hwaddr\": \"6e:31:40:a3:e3:d7\", \"cfg\": {}, \"ipv6addrs\": [], \"mtu\": \"1500\"}}," + " \"software_version\": \"4.13\", \"memSize\": \"15937\", \"cpuSpeed\": \"3400.000\", \"version_name\": \"Snow Man\", \"vlans\": {}, \"cpuCores\": \"4\", \"kvmEnabled\":" + " \"true\", \"guestOverhead\": \"65\", \"cpuThreads\": \"8\", \"emulatedMachines\": [\"pc\", \"q35\", \"isapc\", \"pc-0.10\", \"pc-0.11\", \"pc-0.12\", \"pc-0.13\", " + "\"pc-0.14\", \"pc-0.15\", \"pc-1.0\", \"pc-1.1\", \"pc-1.2\", \"pc-1.3\", \"none\"], \"operatingSystem\": {\"release\": \"4\", \"version\": \"19\", \"name\": \"Fedora\"}}}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(capabilitiesJson));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request);
    // Then
    VDSInfoReturnForXmlRpc vdsInfo = new VDSInfoReturnForXmlRpc(map);
    StatusForXmlRpc status = vdsInfo.mStatus;
    assertEquals("Done", status.mMessage);
    assertEquals(0, status.mCode);
    Map<String, Object> info = vdsInfo.mInfo;
    assertTrue(!info.isEmpty());
    Map<String, Object> bonds = (Map<String, Object>) info.get("bondings");
    for (Entry<String, Object> entry : bonds.entrySet()) {
        Map<String, Object> bond = (Map<String, Object>) entry.getValue();
        assertEquals(0, ((Object[]) bond.get("slaves")).length);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testGetCapabilities() throws JsonParseException, JsonMappingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String capabilitiesJson = "{\"jsonrpc\": \"2.0\", \"id\": \"aed1feb4-42cf-4bf4-8ddf-852251152b68\", \"result\": {\"HBAInventory\": {\"iSCSI\": " + "[{\"InitiatorName\": \"iqn.1994-05.com.redhat:d990cf85cdeb\"}], \"FC\": []}, \"packages2\": {\"kernel\": {\"release\": \"200.fc19.x86_64\"," + " \"buildtime\": 1384356599.0, \"version\": \"3.11.8\"}, \"spice-server\": {\"release\": \"3.fc19\", \"buildtime\": 1383130020, " + "\"version\": \"0.12.4\"}, \"vdsm\": {\"release\": \"163.git9adad51.fc19\", \"buildtime\": 1385064768, \"version\": \"4.13.0\"}, " + "\"qemu-kvm\": {\"release\": \"13.fc19\", \"buildtime\": 1383700301, \"version\": \"1.4.2\"}, \"libvirt\": {\"release\": " + "\"1.fc19\", \"buildtime\": 1383765188, \"version\": \"1.0.5.7\"}, \"qemu-img\": {\"release\": \"13.fc19\", \"buildtime\": " + "1383700301, \"version\": \"1.4.2\"}, \"mom\": {\"release\": \"3.13.giteb3985f.fc19\", \"buildtime\": 1384283536, \"version\"" + ": \"0.3.2\"}}, \"cpuModel\": \"Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz\", \"hooks\": {}, \"cpuSockets\": \"1\", \"vmTypes\": " + "[\"kvm\"], \"networks\": {\"ovirtmgmt\": {\"iface\": \"ovirtmgmt\", \"addr\":" + " \"192.168.1.10\", \"cfg\": {\"DEFROUTE\": \"yes\", \"IPADDR\": \"192.168.1.10\", \"GATEWAY\": \"192.168.1.1\", \"DELAY\":" + " \"0\", \"NM_CONTROLLED\": \"no\", \"NETMASK\": \"255.255.255.0\", \"BOOTPROTO\": \"none\", \"STP\": \"no\", \"DEVICE\": " + "\"ovirtmgmt\", \"TYPE\": \"Bridge\", \"ONBOOT\": \"yes\"}, \"ipv6addrs\": [\"fe80::baca:3aff:fea9:77e2/64\"], \"gateway\":" + " \"192.168.1.1\", \"netmask\": \"255.255.255.0\", \"stp\": \"off\", \"bridged\": true, \"qosInbound\": \"\", \"qosOutbound\":" + " \"\", \"mtu\": \"1500\", \"ipv6gateway\": \"::\", \"ports\": [\"em1\"]}}, \"bridges\": {\"ovirtmgmt\": {\"addr\": \"192.168.1.10\"," + " \"cfg\": {\"DEFROUTE\": \"yes\", \"IPADDR\": \"192.168.1.10\", \"GATEWAY\": \"192.168.1.1\", \"DELAY\": \"0\", \"NM_CONTROLLED\":" + " \"no\", \"NETMASK\": \"255.255.255.0\", \"BOOTPROTO\": \"none\", \"STP\": \"no\", \"DEVICE\": \"ovirtmgmt\", \"TYPE\": \"Bridge\"," + " \"ONBOOT\": \"yes\"}, \"ipv6addrs\": [\"fe80::baca:3aff:fea9:77e2/64\"], \"mtu\": \"1500\", \"netmask\": \"255.255.255.0\", " + "\"stp\": \"off\", \"ipv6gateway\": \"::\", \"gateway\": \"192.168.1.1\", \"ports\": [\"em1\"]}}, \"uuid\": \"4C4C4544-0046-4E10-8032-B2C04F385A31\"," + " \"nics\": {\"em1\": {\"netmask\": \"\", \"addr\": \"\", \"hwaddr\": \"b8:ca:3a:a9:77:e2\", \"cfg\": {\"BRIDGE\": \"ovirtmgmt\", \"NM_CONTROLLED\":" + " \"no\", \"HWADDR\": \"b8:ca:3a:a9:77:e2\", \"STP\": \"no\", \"DEVICE\": \"em1\", \"ONBOOT\": \"yes\"}, \"ipv6addrs\": [\"fe80::baca:3aff:fea9:77e2/64\"]," + " \"speed\": 100, \"mtu\": \"1500\"}}, \"software_revision\": \"163\", \"clusterLevels\": [\"3.0\", \"3.1\", \"3.2\", \"3.3\"], \"cpuFlags\": " + "\"fpu,vme,de,pse,tsc,msr,pae,mce,cx8,apic,sep,mtrr,pge,mca,cmov,pat,pse36,clflush,dts,acpi,mmx,fxsr,sse,sse2,ss,ht,tm,pbe,syscall,nx,rdtscp,lm,constant_" + "tsc,arch_perfmon,pebs,bts,rep_good,nopl,xtopology,nonstop_tsc,aperfmperf,eagerfpu,pni,pclmulqdq,dtes64,monitor,ds_cpl,vmx,smx,est,tm2,ssse3,cx16,xtpr,pdcm," + "pcid,sse4_1,sse4_2,x2apic,popcnt,tsc_deadline_timer,aes,xsave,avx,f16c,rdrand,lahf_lm,ida,arat,epb,xsaveopt,pln,pts,dtherm,tpr_shadow,vnmi,flexpriority,ept," + "vpid,fsgsbase,smep,erms,model_Nehalem,model_Conroe,model_coreduo,model_core2duo,model_Penryn,model_Westmere,model_n270,model_SandyBridge\", \"ISCSIInitiatorName\"" + ": \"iqn.1994-05.com.redhat:d990cf85cdeb\", \"netConfigDirty\": \"False\", \"supportedENGINEs\": [\"3.0\", \"3.1\", \"3.2\", \"3.3\"], \"reservedMem\": \"321\"," + " \"bondings\": {\"bond0\": {\"netmask\": \"\", \"addr\": \"\", \"slaves\": [], \"hwaddr\": \"6e:31:40:a3:e3:d7\", \"cfg\": {}, \"ipv6addrs\": [], \"mtu\": \"1500\"}}," + " \"software_version\": \"4.13\", \"memSize\": \"15937\", \"cpuSpeed\": \"3400.000\", \"version_name\": \"Snow Man\", \"vlans\": {}, \"cpuCores\": \"4\", \"kvmEnabled\":" + " \"true\", \"guestOverhead\": \"65\", \"cpuThreads\": \"8\", \"emulatedMachines\": [\"pc\", \"q35\", \"isapc\", \"pc-0.10\", \"pc-0.11\", \"pc-0.12\", \"pc-0.13\", " + "\"pc-0.14\", \"pc-0.15\", \"pc-1.0\", \"pc-1.1\", \"pc-1.2\", \"pc-1.3\", \"none\"], \"operatingSystem\": {\"release\": \"4\", \"version\": \"19\", \"name\": \"Fedora\"}}}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(capabilitiesJson));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request);
    // Then
    VDSInfoReturnForXmlRpc vdsInfo = new VDSInfoReturnForXmlRpc(map);
    StatusForXmlRpc status = vdsInfo.status;
    assertEquals("Done", status.message);
    assertEquals(0, status.code);
    Map<String, Object> info = vdsInfo.info;
    assertTrue(!info.isEmpty());
    Map<String, Object> bonds = (Map<String, Object>) info.get("bondings");
    for (Entry<String, Object> entry : bonds.entrySet()) {
        Map<String, Object> bond = (Map<String, Object>) entry.getValue();
        assertEquals(0, ((Object[]) bond.get("slaves")).length);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testEmptyListVDS() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"3a0a4c64-1b67-4b48-bc31-e4e0cb7538b1\", \"result\": []}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("vmList").withResponseType(Object[].class);
    // Then
    VMListReturnForXmlRpc vmList = new VMListReturnForXmlRpc(map);
    StatusForXmlRpc status = vmList.mStatus;
    assertEquals("Done", status.mMessage);
    assertEquals(0, status.mCode);
    assertEquals(0, vmList.mVmList.length);
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testEmptyListVDS() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"3a0a4c64-1b67-4b48-bc31-e4e0cb7538b1\", \"result\": []}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("vmList").withResponseType(Object[].class);
    // Then
    VMListReturnForXmlRpc vmList = new VMListReturnForXmlRpc(map);
    StatusForXmlRpc status = vmList.status;
    assertEquals("Done", status.message);
    assertEquals(0, status.code);
    assertEquals(0, vmList.vmList.length);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testShortList() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"ae80f5c4-0f63-4c2e-aed6-5372f07a14c1\", \"result\": [\"e4a0fc02-c5ad-4b35-b2d0-5a4b6557c06b\"]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("vmList").withResponseType(Object[].class).withSubTypeClazz(new HashMap<String, Object>().getClass()).withSubtypeKey("vmId");
    // Then
    VMListReturnForXmlRpc vmList = new VMListReturnForXmlRpc(map);
    StatusForXmlRpc status = vmList.mStatus;
    assertEquals("Done", status.mMessage);
    assertEquals(0, status.mCode);
    assertEquals(1, vmList.mVmList.length);
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testShortList() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"ae80f5c4-0f63-4c2e-aed6-5372f07a14c1\", \"result\": [\"e4a0fc02-c5ad-4b35-b2d0-5a4b6557c06b\"]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("vmList").withResponseType(Object[].class).withSubTypeClazz(new HashMap<String, Object>().getClass()).withSubtypeKey("vmId");
    // Then
    VMListReturnForXmlRpc vmList = new VMListReturnForXmlRpc(map);
    StatusForXmlRpc status = vmList.status;
    assertEquals("Done", status.message);
    assertEquals(0, status.code);
    assertEquals(1, vmList.vmList.length);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testAddDomain() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"4b0838b3-f940-4780-b2f0-fd56c1fbc573\", \"result\": [{\"status\": 0, \"id\": \"00000000-0000-0000-0000-000000000000\"}]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    // Then
    ServerConnectionStatusReturnForXmlRpc status = new ServerConnectionStatusReturnForXmlRpc(map);
    assertEquals("Done", status.getXmlRpcStatus().mMessage);
    assertEquals(0, status.getXmlRpcStatus().mCode);
    assertEquals(1, status.mStatusList.length);
    Map<String, Object> result = status.mStatusList[0];
    assertEquals(0, result.get("status"));
    assertEquals("00000000-0000-0000-0000-000000000000", result.get("id"));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testAddDomain() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"4b0838b3-f940-4780-b2f0-fd56c1fbc573\", \"result\": [{\"status\": 0, \"id\": \"00000000-0000-0000-0000-000000000000\"}]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    // Then
    ServerConnectionStatusReturnForXmlRpc status = new ServerConnectionStatusReturnForXmlRpc(map);
    assertEquals("Done", status.getXmlRpcStatus().message);
    assertEquals(0, status.getXmlRpcStatus().code);
    assertEquals(1, status.statusList.length);
    Map<String, Object> result = status.statusList[0];
    assertEquals(0, result.get("status"));
    assertEquals("00000000-0000-0000-0000-000000000000", result.get("id"));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testGetIsoListWithoutIsos() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"c1796b67-8932-4e90-a6f9-aa68266493f8\", \"result\": []}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("iso_list").withResponseType(Object[].class);
    // Then
    FileStatsReturnForXmlRpc isoList = new FileStatsReturnForXmlRpc(map);
    assertEquals("Done", isoList.getXmlRpcStatus().mMessage);
    assertEquals(0, isoList.getXmlRpcStatus().mCode);
    assertEquals(0, isoList.getFileStats().size());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testGetIsoListWithoutIsos() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"c1796b67-8932-4e90-a6f9-aa68266493f8\", \"result\": []}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("iso_list").withResponseType(Object[].class);
    // Then
    FileStatsReturnForXmlRpc isoList = new FileStatsReturnForXmlRpc(map);
    assertEquals("Done", isoList.getXmlRpcStatus().message);
    assertEquals(0, isoList.getXmlRpcStatus().code);
    assertEquals(0, isoList.getFileStats().size());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testGetIsoListWithImage() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"8d38c4c9-3fdb-4663-993a-dc65488875bb\", \"result\": [\"Fedora-Live-Desktop-x86_64-19-1.iso\"]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("isolist").withResponseType(Object[].class);
    // Then
    FileStatsReturnForXmlRpc isoList = new FileStatsReturnForXmlRpc(map);
    assertEquals("Done", isoList.getXmlRpcStatus().mMessage);
    assertEquals(0, isoList.getXmlRpcStatus().mCode);
    assertEquals(1, isoList.getFileStats().size());
    assertEquals("Fedora-Live-Desktop-x86_64-19-1.iso", isoList.getFileStats().keySet().iterator().next());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testGetIsoListWithImage() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"8d38c4c9-3fdb-4663-993a-dc65488875bb\", \"result\": [\"Fedora-Live-Desktop-x86_64-19-1.iso\"]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("isolist").withResponseType(Object[].class);
    // Then
    FileStatsReturnForXmlRpc isoList = new FileStatsReturnForXmlRpc(map);
    assertEquals("Done", isoList.getXmlRpcStatus().message);
    assertEquals(0, isoList.getXmlRpcStatus().code);
    assertEquals(1, isoList.getFileStats().size());
    assertEquals("Fedora-Live-Desktop-x86_64-19-1.iso", isoList.getFileStats().keySet().iterator().next());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testGetVMList() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"e32621e5-753f-45b8-b071-2eb929408efd\", \"result\": [{\"status\": \"Up\", \"vmId\": \"dd4d61c3-5128-4c26-ae71-0dbe5081ea93\"}]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("vmList").withResponseType(Object[].class);
    // Then
    VMListReturnForXmlRpc vmList = new VMListReturnForXmlRpc(map);
    assertEquals("Done", vmList.mStatus.mMessage);
    assertEquals(0, vmList.mStatus.mCode);
    assertEquals(1, vmList.mVmList.length);
    assertEquals("dd4d61c3-5128-4c26-ae71-0dbe5081ea93", (String) vmList.mVmList[0].get("vmId"));
    assertEquals("Up", (String) vmList.mVmList[0].get("status"));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testGetVMList() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"e32621e5-753f-45b8-b071-2eb929408efd\", \"result\": [{\"status\": \"Up\", \"vmId\": \"dd4d61c3-5128-4c26-ae71-0dbe5081ea93\"}]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("vmList").withResponseType(Object[].class);
    // Then
    VMListReturnForXmlRpc vmList = new VMListReturnForXmlRpc(map);
    assertEquals("Done", vmList.status.message);
    assertEquals(0, vmList.status.code);
    assertEquals(1, vmList.vmList.length);
    assertEquals("dd4d61c3-5128-4c26-ae71-0dbe5081ea93", (String) vmList.vmList[0].get("vmId"));
    assertEquals("Up", (String) vmList.vmList[0].get("status"));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testGetVMListIdsOnly() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"e9968b53-7450-4059-83e6-d3569f7024ec\", \"result\": [\"1397d80b-1c48-4d4a-acf9-ebd669bf3b25\"]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("vmList").withResponseType(Object[].class);
    // Then
    VMListReturnForXmlRpc vmList = new VMListReturnForXmlRpc(map);
    assertEquals("Done", vmList.mStatus.mMessage);
    assertEquals(0, vmList.mStatus.mCode);
    assertEquals(1, vmList.mVmList.length);
    assertEquals("1397d80b-1c48-4d4a-acf9-ebd669bf3b25", (String) vmList.mVmList[0].get("vmId"));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testGetVMListIdsOnly() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"e9968b53-7450-4059-83e6-d3569f7024ec\", \"result\": [\"1397d80b-1c48-4d4a-acf9-ebd669bf3b25\"]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("vmList").withResponseType(Object[].class);
    // Then
    VMListReturnForXmlRpc vmList = new VMListReturnForXmlRpc(map);
    assertEquals("Done", vmList.status.message);
    assertEquals(0, vmList.status.code);
    assertEquals(1, vmList.vmList.length);
    assertEquals("1397d80b-1c48-4d4a-acf9-ebd669bf3b25", (String) vmList.vmList[0].get("vmId"));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testStoragePoolInfo() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"609b5787-ab3a-485b-8ed8-0bc9a27eda27\", \"result\": {\"info\": {\"spm_id\": 1, \"master_uuid\": \"05a0ad59-1259-4353-b40b-34eb80d8590a\"," + " \"name\": \"Default\", \"version\": \"0\", \"domains\": \"05a0ad59-1259-4353-b40b-34eb80d8590a:Active,6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324:Active,4192b643-fae9-4c1c-8b8b-9c9c6cc10523:Active\", " + "\"pool_status\": \"connected\", \"isoprefix\": \"/rhev/data-center/mnt/192.168.1.10:_export_iso/6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324/images/11111111-1111-1111-1111-111111111111\", " + "\"type\": \"NFS\", \"master_ver\": 1, \"lver\": 0}, \"dominfo\": {\"05a0ad59-1259-4353-b40b-34eb80d8590a\": {\"status\": \"Active\", \"diskfree\": \"43887099904\", \"isoprefix\": \"\"," + " \"alerts\": [], \"disktotal\": \"52710866944\", \"version\": 0}, \"6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324\": {\"status\": \"Active\", \"diskfree\": \"43887099904\", \"isoprefix\": " + "\"/rhev/data-center/mnt/192.168.1.10:_export_iso/6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324/images/11111111-1111-1111-1111-111111111111\", \"alerts\": [], \"disktotal\": \"52710866944\", " + "\"version\": 0}, \"4192b643-fae9-4c1c-8b8b-9c9c6cc10523\": {\"status\": \"Active\", \"isoprefix\": \"\", \"alerts\": [], \"version\": -1}}}}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withIgnoreResponseKey();
    // Then
    StoragePoolInfoReturnForXmlRpc storagePoolInfo = new StoragePoolInfoReturnForXmlRpc(map);
    assertEquals("Done", storagePoolInfo.getXmlRpcStatus().mMessage);
    assertEquals(0, storagePoolInfo.getXmlRpcStatus().mCode);
    Set<String> keys = storagePoolInfo.mDomainsList.keySet();
    assertEquals(3, keys.size());
    assertTrue(keys.contains("05a0ad59-1259-4353-b40b-34eb80d8590a"));
    assertTrue(keys.contains("6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324"));
    assertTrue(keys.contains("4192b643-fae9-4c1c-8b8b-9c9c6cc10523"));
    Map<String, Object> info = storagePoolInfo.mStoragePoolInfo;
    assertEquals("/rhev/data-center/mnt/192.168.1.10:_export_iso/6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324/images/11111111-1111-1111-1111-111111111111", info.get("isoprefix"));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testStoragePoolInfo() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"609b5787-ab3a-485b-8ed8-0bc9a27eda27\", \"result\": {\"info\": {\"spm_id\": 1, \"master_uuid\": \"05a0ad59-1259-4353-b40b-34eb80d8590a\"," + " \"name\": \"Default\", \"version\": \"0\", \"domains\": \"05a0ad59-1259-4353-b40b-34eb80d8590a:Active,6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324:Active,4192b643-fae9-4c1c-8b8b-9c9c6cc10523:Active\", " + "\"pool_status\": \"connected\", \"isoprefix\": \"/rhev/data-center/mnt/192.168.1.10:_export_iso/6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324/images/11111111-1111-1111-1111-111111111111\", " + "\"type\": \"NFS\", \"master_ver\": 1, \"lver\": 0}, \"dominfo\": {\"05a0ad59-1259-4353-b40b-34eb80d8590a\": {\"status\": \"Active\", \"diskfree\": \"43887099904\", \"isoprefix\": \"\"," + " \"alerts\": [], \"disktotal\": \"52710866944\", \"version\": 0}, \"6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324\": {\"status\": \"Active\", \"diskfree\": \"43887099904\", \"isoprefix\": " + "\"/rhev/data-center/mnt/192.168.1.10:_export_iso/6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324/images/11111111-1111-1111-1111-111111111111\", \"alerts\": [], \"disktotal\": \"52710866944\", " + "\"version\": 0}, \"4192b643-fae9-4c1c-8b8b-9c9c6cc10523\": {\"status\": \"Active\", \"isoprefix\": \"\", \"alerts\": [], \"version\": -1}}}}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withIgnoreResponseKey();
    // Then
    StoragePoolInfoReturnForXmlRpc storagePoolInfo = new StoragePoolInfoReturnForXmlRpc(map);
    assertEquals("Done", storagePoolInfo.getXmlRpcStatus().message);
    assertEquals(0, storagePoolInfo.getXmlRpcStatus().code);
    Set<String> keys = storagePoolInfo.domainsList.keySet();
    assertEquals(3, keys.size());
    assertTrue(keys.contains("05a0ad59-1259-4353-b40b-34eb80d8590a"));
    assertTrue(keys.contains("6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324"));
    assertTrue(keys.contains("4192b643-fae9-4c1c-8b8b-9c9c6cc10523"));
    Map<String, Object> info = storagePoolInfo.storagePoolInfo;
    assertEquals("/rhev/data-center/mnt/192.168.1.10:_export_iso/6ca00a0d-3f1d-4762-b5ff-c58a6a0a0324/images/11111111-1111-1111-1111-111111111111", info.get("isoprefix"));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testActivateDomain() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"5ba8294b-afd7-4810-968d-607703a7bd93\", \"result\": true}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("storageStatus").withResponseType(String.class);
    // Then
    StorageStatusReturnForXmlRpc storageStatus = new StorageStatusReturnForXmlRpc(map);
    assertEquals("Done", storageStatus.getXmlRpcStatus().mMessage);
    assertEquals(0, storageStatus.getXmlRpcStatus().mCode);
    assertEquals("true", storageStatus.mStorageStatus);
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testActivateDomain() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"5ba8294b-afd7-4810-968d-607703a7bd93\", \"result\": true}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("storageStatus").withResponseType(String.class);
    // Then
    StorageStatusReturnForXmlRpc storageStatus = new StorageStatusReturnForXmlRpc(map);
    assertEquals("Done", storageStatus.getXmlRpcStatus().message);
    assertEquals(0, storageStatus.getXmlRpcStatus().code);
    assertEquals("true", storageStatus.storageStatus);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testVolumeCreate() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"e8ea1fa9-d819-4c41-ae9c-b103a236fb29\", \"result\": {\"uuid\": \"4f84eef5-8f8b-4732-babd-0a860cf0d1b9\"}}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withIgnoreResponseKey();
    // Then
    OneUuidReturnForXmlRpc oneuuid = new OneUuidReturnForXmlRpc(map);
    assertEquals("Done", oneuuid.getXmlRpcStatus().mMessage);
    assertEquals(0, oneuuid.getXmlRpcStatus().mCode);
    assertEquals("4f84eef5-8f8b-4732-babd-0a860cf0d1b9", UUID.fromString(oneuuid.mUuid).toString());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testVolumeCreate() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, TimeoutException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"e8ea1fa9-d819-4c41-ae9c-b103a236fb29\", \"result\": {\"uuid\": \"4f84eef5-8f8b-4732-babd-0a860cf0d1b9\"}}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withIgnoreResponseKey();
    // Then
    OneUuidReturnForXmlRpc oneuuid = new OneUuidReturnForXmlRpc(map);
    assertEquals("Done", oneuuid.getXmlRpcStatus().message);
    assertEquals(0, oneuuid.getXmlRpcStatus().code);
    assertEquals("4f84eef5-8f8b-4732-babd-0a860cf0d1b9", UUID.fromString(oneuuid.uuid).toString());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testDiscoverSendTargets() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"9afac443-3473-454d-b6c7-80f0b7876ff7\", \"result\": [\"10.35.16.25:3260,1 iqn.1994-05.com.redhat.com:ahadas-iscsi\"," + " \"10.35.16.25:3260,1 iqn.1994-05.com.redhat.com:sgotliv-iscsi\", \"10.35.16.25:3260,1 iqn.1994-05.com.redhat.com:sgotliv-iscsi2\", " + "\"10.35.16.25:3260,1 iqn.1994-05.com.redhat:nsoffer-target1\", \"10.35.16.25:3260,1 iqn.1994-05.com.redhat:nsoffer-target2\"," + " \"10.35.16.25:3260,1 iqn.1994-05.com.redhat:pkliczew\", \"10.35.16.25:3260,1 iqn.1994-05.com.redhat:ybronhei-target\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:achub-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:ashakarc-iscsi\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:derez-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:drankevi-iscsi\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:ecohen-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:gchaplik-iscsi\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:mkolesnik-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:mpastern-iscsi\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:oliel-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:oliel-iscsi2\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:tnisan-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-06.com.redhat:jchoate-iscsi\", \"10.35.16.25:3260,1 iqn.2011-06.com.redhat:msalem-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-06.com.redhat:ofrenkel-iscsi\", \"10.35.16.25:3260,1 iqn.2011-08.com.redhat:mlipchuk-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-08.com.redhat:oourfali1\", \"10.35.16.25:3260,1 iqn.2011-08.com.redhat:shavivi1\", \"10.35.16.25:3260,1 iqn.2011-08.com.redhat:shavivi2\"," + " \"10.35.16.25:3260,1 iqn.2011-09.com.redhat:masayag-iscsi\", \"10.35.16.25:3260,1 iqn.2012-01.com.redhat:storage-negative-test1\", \"10.35.16.25:3260,1 iqn.2012-03.com.redhat:rami-api\"," + " \"10.35.16.25:3260,1 iqn.2012-04.com.redhat:rhevm-em1\", \"10.35.16.25:3260,1 iqn.2012-06.com.redhat:rgolan1\", \"10.35.16.25:3260,1 iqn.2012-06.com.redhat:tnisan1\"," + " \"10.35.16.25:3260,1 iqn.2012-09.com.redhat.com:omasad1\", \"10.35.16.25:3260,1 iqn.2012-12.com.redhat.com:rnori\", \"10.35.16.25:3260,1 iqn.2013-01.redhat.com:vered1\"," + " \"10.35.16.25:3260,1 iqn.2013-04.redhat.com:abonas-target1\", \"10.35.16.25:3260,1 iqn.2013-04.redhat.com:abonas-target2\", \"10.35.16.25:3260,1 iqn.2013-04.redhat.com:mtayer1\"]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("fullTargets");
    IQNListReturnForXmlRpc list = new IQNListReturnForXmlRpc(map);
    assertEquals("Done", list.getXmlRpcStatus().mMessage);
    assertEquals(0, list.getXmlRpcStatus().mCode);
    assertEquals(37, parseFullTargets(list.getIqnList()).size());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testDiscoverSendTargets() throws JsonProcessingException, IOException, InterruptedException, ExecutionException, ClientConnectionException {
    // Given
    String json = "{\"jsonrpc\": \"2.0\", \"id\": \"9afac443-3473-454d-b6c7-80f0b7876ff7\", \"result\": [\"10.35.16.25:3260,1 iqn.1994-05.com.redhat.com:ahadas-iscsi\"," + " \"10.35.16.25:3260,1 iqn.1994-05.com.redhat.com:sgotliv-iscsi\", \"10.35.16.25:3260,1 iqn.1994-05.com.redhat.com:sgotliv-iscsi2\", " + "\"10.35.16.25:3260,1 iqn.1994-05.com.redhat:nsoffer-target1\", \"10.35.16.25:3260,1 iqn.1994-05.com.redhat:nsoffer-target2\"," + " \"10.35.16.25:3260,1 iqn.1994-05.com.redhat:pkliczew\", \"10.35.16.25:3260,1 iqn.1994-05.com.redhat:ybronhei-target\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:achub-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:ashakarc-iscsi\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:derez-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:drankevi-iscsi\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:ecohen-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:gchaplik-iscsi\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:mkolesnik-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:mpastern-iscsi\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:oliel-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:oliel-iscsi2\", \"10.35.16.25:3260,1 iqn.2011-05.com.redhat:tnisan-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-06.com.redhat:jchoate-iscsi\", \"10.35.16.25:3260,1 iqn.2011-06.com.redhat:msalem-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-06.com.redhat:ofrenkel-iscsi\", \"10.35.16.25:3260,1 iqn.2011-08.com.redhat:mlipchuk-iscsi\"," + " \"10.35.16.25:3260,1 iqn.2011-08.com.redhat:oourfali1\", \"10.35.16.25:3260,1 iqn.2011-08.com.redhat:shavivi1\", \"10.35.16.25:3260,1 iqn.2011-08.com.redhat:shavivi2\"," + " \"10.35.16.25:3260,1 iqn.2011-09.com.redhat:masayag-iscsi\", \"10.35.16.25:3260,1 iqn.2012-01.com.redhat:storage-negative-test1\", \"10.35.16.25:3260,1 iqn.2012-03.com.redhat:rami-api\"," + " \"10.35.16.25:3260,1 iqn.2012-04.com.redhat:rhevm-em1\", \"10.35.16.25:3260,1 iqn.2012-06.com.redhat:rgolan1\", \"10.35.16.25:3260,1 iqn.2012-06.com.redhat:tnisan1\"," + " \"10.35.16.25:3260,1 iqn.2012-09.com.redhat.com:omasad1\", \"10.35.16.25:3260,1 iqn.2012-12.com.redhat.com:rnori\", \"10.35.16.25:3260,1 iqn.2013-01.redhat.com:vered1\"," + " \"10.35.16.25:3260,1 iqn.2013-04.redhat.com:abonas-target1\", \"10.35.16.25:3260,1 iqn.2013-04.redhat.com:abonas-target2\", \"10.35.16.25:3260,1 iqn.2013-04.redhat.com:mtayer1\"]}";
    ObjectMapper mapper = new ObjectMapper();
    JsonRpcResponse response = JsonRpcResponse.fromJsonNode(mapper.readTree(json));
    Future<JsonRpcResponse> future = mock(Future.class);
    when(future.get()).thenReturn(response);
    JsonRpcClient client = mock(JsonRpcClient.class);
    JsonRpcRequest request = mock(JsonRpcRequest.class);
    when(client.call(request)).thenReturn(future);
    // When
    Map<String, Object> map = new FutureMap(client, request).withResponseKey("fullTargets");
    IQNListReturnForXmlRpc list = new IQNListReturnForXmlRpc(map);
    assertEquals("Done", list.getXmlRpcStatus().message);
    assertEquals(0, list.getXmlRpcStatus().code);
    assertEquals(37, parseFullTargets(list.getIqnList()).size());
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    Iterator<Entry<Guid, CommandContainer>> iterator = cmdCallbackMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CommandContainer> entry = iterator.next();
        if (--entry.getValue().executionCountdown > 1) {
            continue;
        }
        Guid cmdId = entry.getKey();
        CommandCallback callback = entry.getValue().callback;
        CommandStatus status = coco.getCommandStatus(cmdId);
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                    callback.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case SUCCEEDED:
                    callback.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case ACTIVE:
                    if (coco.getCommandEntity(cmdId).isExecuted()) {
                        callback.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if (CommandStatus.FAILED.equals(status) || (CommandStatus.SUCCEEDED.equals(status) && !errorInCallback)) {
                coco.updateCallbackNotified(cmdId);
                iterator.remove();
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                entry.getValue().executionDelay = Math.min(maxDelay, entry.getValue().executionDelay * 2);
                entry.getValue().executionCountdown = entry.getValue().executionDelay;
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    Iterator<Entry<Guid, CommandContainer>> iterator = cmdCallbackMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CommandContainer> entry = iterator.next();
        // Decrement counter; execute if it reaches 0
        if ((entry.getValue().remainingDelay -= pollingRate) > 0) {
            continue;
        }
        Guid cmdId = entry.getKey();
        CommandCallback callback = entry.getValue().callback;
        CommandStatus status = coco.getCommandStatus(cmdId);
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                    callback.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case SUCCEEDED:
                    callback.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case ACTIVE:
                    if (coco.getCommandEntity(cmdId).isExecuted()) {
                        callback.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if (CommandStatus.FAILED.equals(status) || (CommandStatus.SUCCEEDED.equals(status) && !errorInCallback)) {
                coco.updateCallbackNotified(cmdId);
                iterator.remove();
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                entry.getValue().initialDelay = Math.min(maxDelay, entry.getValue().initialDelay * 2);
                entry.getValue().remainingDelay = entry.getValue().initialDelay;
            }
        }
    }
}
#end_block

#method_before
public void addToCallbackMap(CommandEntity cmdEntity) {
    if (!cmdCallbackMap.containsKey(cmdEntity.getId())) {
        CommandBase<?> cmd = coco.retrieveCommand(cmdEntity.getId());
        if (cmd != null && cmd.getCallback() != null) {
            cmdCallbackMap.put(cmdEntity.getId(), new CommandContainer(cmd.getCallback(), 1));
        }
    }
}
#method_after
public void addToCallbackMap(CommandEntity cmdEntity) {
    if (!cmdCallbackMap.containsKey(cmdEntity.getId())) {
        CommandBase<?> cmd = coco.retrieveCommand(cmdEntity.getId());
        if (cmd != null && cmd.getCallback() != null) {
            cmdCallbackMap.put(cmdEntity.getId(), new CommandContainer(cmd.getCallback(), pollingRate));
        }
    }
}
#end_block

#method_before
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext, SubjectEntity... subjectEntities) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    CommandCallback callBack = command.getCallback();
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, callBack != null);
    coco.persistCommandAssociatedEntities(buildCommandAssociatedEntities(command.getCommandId(), subjectEntities));
    if (callBack != null) {
        cmdCallbackMap.put(command.getCommandId(), new CommandContainer(callBack, 1));
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.error("Failed to submit command to executor service, command '{}' status has been set to FAILED", command.getCommandId());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext, SubjectEntity... subjectEntities) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    CommandCallback callBack = command.getCallback();
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, callBack != null);
    coco.persistCommandAssociatedEntities(buildCommandAssociatedEntities(command.getCommandId(), subjectEntities));
    if (callBack != null) {
        cmdCallbackMap.put(command.getCommandId(), new CommandContainer(callBack, pollingRate));
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.error("Failed to submit command to executor service, command '{}' status has been set to FAILED", command.getCommandId());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    Iterator<Entry<Guid, CommandContainer>> iterator = cmdCallbackMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CommandContainer> entry = iterator.next();
        if (--entry.getValue().executionCountdown > 1) {
            continue;
        }
        Guid cmdId = entry.getKey();
        CommandCallback callback = entry.getValue().callback;
        CommandStatus status = coco.getCommandStatus(cmdId);
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                    callback.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case SUCCEEDED:
                    callback.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case ACTIVE:
                    if (coco.getCommandEntity(cmdId).isExecuted()) {
                        callback.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if (CommandStatus.FAILED.equals(status) || (CommandStatus.SUCCEEDED.equals(status) && !errorInCallback)) {
                coco.updateCallbackNotified(cmdId);
                iterator.remove();
                // When a child finishes, its parent's callback should execute shortly thereafter
                Guid rootCommandId = coco.getCommandEntity(entry.getKey()).getRootCommandId();
                if (!Guid.Empty.equals(rootCommandId) && cmdCallbackMap.containsKey(rootCommandId)) {
                    cmdCallbackMap.get(rootCommandId).executionDelay = 1;
                    cmdCallbackMap.get(rootCommandId).executionCountdown = 1;
                }
            } else if (status != coco.getCommandStatus(cmdId)) {
                entry.getValue().executionDelay = 1;
                entry.getValue().executionCountdown = 1;
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                entry.getValue().executionDelay = Math.min(maxDelay, entry.getValue().executionDelay * 2);
                entry.getValue().executionCountdown = entry.getValue().executionDelay;
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    Iterator<Entry<Guid, CommandContainer>> iterator = cmdCallbackMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CommandContainer> entry = iterator.next();
        // Decrement counter; execute if it reaches 0
        if ((entry.getValue().remainingDelay -= pollingRate) > 0) {
            continue;
        }
        Guid cmdId = entry.getKey();
        CommandCallback callback = entry.getValue().callback;
        CommandStatus status = coco.getCommandStatus(cmdId);
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                    callback.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case SUCCEEDED:
                    callback.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case ACTIVE:
                    if (coco.getCommandEntity(cmdId).isExecuted()) {
                        callback.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if (CommandStatus.FAILED.equals(status) || (CommandStatus.SUCCEEDED.equals(status) && !errorInCallback)) {
                coco.updateCallbackNotified(cmdId);
                iterator.remove();
                // When a child finishes, its parent's callback should execute shortly thereafter
                Guid rootCommandId = coco.getCommandEntity(entry.getKey()).getRootCommandId();
                if (!Guid.isNullOrEmpty(rootCommandId) && cmdCallbackMap.containsKey(rootCommandId)) {
                    cmdCallbackMap.get(rootCommandId).initialDelay = pollingRate;
                    cmdCallbackMap.get(rootCommandId).remainingDelay = pollingRate;
                }
            } else if (status != coco.getCommandStatus(cmdId)) {
                entry.getValue().initialDelay = pollingRate;
                entry.getValue().remainingDelay = pollingRate;
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                entry.getValue().initialDelay = Math.min(maxDelay, entry.getValue().initialDelay * 2);
                entry.getValue().remainingDelay = entry.getValue().initialDelay;
            }
        }
    }
}
#end_block

#method_before
public void addToCallbackMap(CommandEntity cmdEntity) {
    if (!cmdCallbackMap.containsKey(cmdEntity.getId())) {
        CommandBase<?> cmd = coco.retrieveCommand(cmdEntity.getId());
        if (cmd != null && cmd.getCallback() != null) {
            cmdCallbackMap.put(cmdEntity.getId(), new CommandContainer(cmd.getCallback(), 1));
        }
    }
}
#method_after
public void addToCallbackMap(CommandEntity cmdEntity) {
    if (!cmdCallbackMap.containsKey(cmdEntity.getId())) {
        CommandBase<?> cmd = coco.retrieveCommand(cmdEntity.getId());
        if (cmd != null && cmd.getCallback() != null) {
            cmdCallbackMap.put(cmdEntity.getId(), new CommandContainer(cmd.getCallback(), pollingRate));
        }
    }
}
#end_block

#method_before
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext, SubjectEntity... subjectEntities) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    CommandCallback callBack = command.getCallback();
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, callBack != null);
    coco.persistCommandAssociatedEntities(buildCommandAssociatedEntities(command.getCommandId(), subjectEntities));
    if (callBack != null) {
        cmdCallbackMap.put(command.getCommandId(), new CommandContainer(callBack, 1));
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.error("Failed to submit command to executor service, command '{}' status has been set to FAILED", command.getCommandId());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext, SubjectEntity... subjectEntities) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    CommandCallback callBack = command.getCallback();
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, callBack != null);
    coco.persistCommandAssociatedEntities(buildCommandAssociatedEntities(command.getCommandId(), subjectEntities));
    if (callBack != null) {
        cmdCallbackMap.put(command.getCommandId(), new CommandContainer(callBack, pollingRate));
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.error("Failed to submit command to executor service, command '{}' status has been set to FAILED", command.getCommandId());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<Map<String, String>>(Arrays.asList(disks))).withParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<Map<String, String>>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
}
#method_after
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
}
#end_block

#method_before
protected String getVmIsBeingImportedMessage() {
    StringBuilder builder = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_BEING_IMPORTED.name());
    if (getVmName() != null) {
        builder.append(String.format("$VmName %1$s", getVmName()));
    }
    return builder.toString();
}
#method_after
protected String getVmIsBeingImportedMessage() {
    StringBuilder builder = new StringBuilder(EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_IMPORTED.name());
    if (getVmName() != null) {
        builder.append(String.format("$VmName %1$s", getVmName()));
    }
    return builder.toString();
}
#end_block

#method_before
// /////////////////
// // Sync Part ////
// /////////////////
@Override
protected boolean canDoAction() {
    if (getVds() != null && getVds().getStatus() != VDSStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    if (getVds() == null && !selectProxyHost()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    return true;
}
#method_after
// /////////////////
// // Sync Part ////
// /////////////////
@Override
protected boolean canDoAction() {
    if (getVds() != null && getVds().getStatus() != VDSStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    if (getVds() == null && !selectProxyHost()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    return true;
}
#end_block

#method_before
private boolean selectProxyHost() {
    List<VDS> activeHosts = getVdsDAO().getAllForStoragePoolAndStatus(getStoragePoolId(), VDSStatus.Up);
    if (activeHosts.isEmpty()) {
        return false;
    }
    VDS activeHost = activeHosts.get(0);
    setVds(activeHost);
    // update the parameters for the end-action phase
    getParameters().setProxyHostId(activeHost.getId());
    return true;
}
#method_after
private boolean selectProxyHost() {
    List<VDS> activeHosts = getVdsDao().getAllForStoragePoolAndStatus(getStoragePoolId(), VDSStatus.Up);
    if (activeHosts.isEmpty()) {
        return false;
    }
    VDS activeHost = activeHosts.get(0);
    setVds(activeHost);
    // update the parameters for the end-action phase
    getParameters().setProxyHostId(activeHost.getId());
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    try {
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.ConvertVm, buildConvertParameters());
        if (retValue.getSucceeded()) {
            getVdsManager().addV2VJobInfoForVm(getVmId(), JobStatus.WAIT_FOR_START);
            setSucceeded(true);
        } else {
            log.error("Failed to convert VM");
            setCommandStatus(CommandStatus.FAILED);
        }
    } catch (VdcBLLException e) {
        log.error("Failed to convert VM", e);
        setCommandStatus(CommandStatus.FAILED);
    }
}
#method_after
@Override
protected void executeVmCommand() {
    try {
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.ConvertVm, buildConvertParameters());
        if (retValue.getSucceeded()) {
            getVdsManager().addV2VJobInfoForVm(getVmId(), JobStatus.WAIT_FOR_START);
            setSucceeded(true);
        } else {
            log.error("Failed to convert VM");
            setCommandStatus(CommandStatus.FAILED);
        }
    } catch (EngineException e) {
        log.error("Failed to convert VM", e);
        setCommandStatus(CommandStatus.FAILED);
    }
}
#end_block

#method_before
private ConvertVmVDSParameters buildConvertParameters() {
    ConvertVmVDSParameters parameters = new ConvertVmVDSParameters(getVdsId());
    parameters.setUrl(getParameters().getUrl());
    parameters.setUsername(getParameters().getUsername());
    parameters.setPassword(getParameters().getPassword());
    parameters.setDisks(getParameters().getDisks());
    parameters.setVmId(getVmId());
    parameters.setVmName(getVmName());
    parameters.setStoragePoolId(getStoragePoolId());
    parameters.setStorageDomainId(getStorageDomainId());
    parameters.setVirtioIsoPath(getParameters().getVirtioIsoPath());
    return parameters;
}
#method_after
private ConvertVmVDSParameters buildConvertParameters() {
    ConvertVmVDSParameters parameters = new ConvertVmVDSParameters(getVdsId());
    parameters.setUrl(getParameters().getUrl());
    parameters.setUsername(getParameters().getUsername());
    parameters.setPassword(getParameters().getPassword());
    parameters.setDisks(getParameters().getDisks());
    parameters.setVmId(getVmId());
    parameters.setVmName(getVmName());
    parameters.setStoragePoolId(getStoragePoolId());
    parameters.setStorageDomainId(getStorageDomainId());
    parameters.setVirtioIsoPath(getVirtioIsoPath());
    return parameters;
}
#end_block

#method_before
// //////////////////
// // Async Part ////
// //////////////////
@Override
protected void endSuccessfully() {
    getReturnValue().setEndActionTryAgain(false);
    try {
        addImportedDevices(readVmFromOvf(getOvfOfConvertedVm()));
        setSucceeded(true);
    } catch (VdcBLLException e) {
        log.info("failed to add devices to converted vm");
        removeVm();
    } finally {
        deleteV2VJob();
    }
}
#method_after
// //////////////////
// // Async Part ////
// //////////////////
@Override
protected void endSuccessfully() {
    getReturnValue().setEndActionTryAgain(false);
    try {
        addImportedDevices(readVmFromOvf(getOvfOfConvertedVm()));
        setSucceeded(true);
    } catch (EngineException e) {
        log.info("failed to add devices to converted vm");
        removeVm();
    } finally {
        deleteV2VJob();
    }
}
#end_block

#method_before
private VM readVmFromOvf(String ovf) {
    try {
        return new OvfHelper().readVmFromOvf(ovf);
    } catch (OvfReaderException e) {
        log.debug("failed to parse a given ovf configuration: \n " + ovf, e);
        auditLog(this, AuditLogType.IMPORTEXPORT_INVALID_OVF);
        throw new VdcBLLException();
    }
}
#method_after
private VM readVmFromOvf(String ovf) {
    try {
        return new OvfHelper().readVmFromOvf(ovf);
    } catch (OvfReaderException e) {
        log.debug("failed to parse a given ovf configuration: \n " + ovf, e);
        auditLog(this, AuditLogType.IMPORTEXPORT_INVALID_OVF);
        throw new EngineException();
    }
}
#end_block

#method_before
private String getOvfOfConvertedVm() {
    VDSReturnValue retValue = runVdsCommand(VDSCommandType.GetConvertedOvf, new VdsAndVmIDVDSParametersBase(getVdsId(), getVmId()));
    if (!retValue.getSucceeded()) {
        auditLog(this, AuditLogType.IMPORTEXPORT_CANNOT_GET_OVF);
        throw new VdcBLLException();
    }
    return (String) retValue.getReturnValue();
}
#method_after
private String getOvfOfConvertedVm() {
    VDSReturnValue retValue = runVdsCommand(VDSCommandType.GetConvertedOvf, new VdsAndVmIDVDSParametersBase(getVdsId(), getVmId()));
    if (!retValue.getSucceeded()) {
        auditLog(this, AuditLogType.IMPORTEXPORT_CANNOT_GET_OVF);
        throw new EngineException();
    }
    return (String) retValue.getReturnValue();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getStorageDomain() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    if (!getStorageDomain().getStoragePoolId().equals(getStoragePoolId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_AND_CLUSTER_IN_DIFFERENT_POOL);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
    }
    if (getStorageDomain().getStatus() != StorageDomainStatus.Active) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
    }
    if (getVdsId() != null && !validate(validateRequestedProxyHost())) {
        return false;
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateUniqueVmName()) {
        return false;
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!validateStorageSpace()) {
        return false;
    }
    if (getParameters().getVirtioIsoName() != null && getActiveIsoDomainId() == null) {
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getStorageDomain() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    if (!getStorageDomain().getStoragePoolId().equals(getStoragePoolId())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_AND_CLUSTER_IN_DIFFERENT_POOL);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
    }
    if (getStorageDomain().getStatus() != StorageDomainStatus.Active) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
    }
    if (getVdsId() != null && !validate(validateRequestedProxyHost())) {
        return false;
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateUniqueVmName()) {
        return false;
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!validateStorageSpace()) {
        return false;
    }
    if (getParameters().getVirtioIsoName() != null && getActiveIsoDomainId() == null) {
        return failCanDoAction(EngineMessage.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    return true;
}
#end_block

#method_before
private ValidationResult validateRequestedProxyHost() {
    if (getVds() == null) {
        return new ValidationResult(VdcBllMessages.VDS_DOES_NOT_EXIST);
    }
    if (!getStoragePoolId().equals(getVds().getStoragePoolId())) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VDS_NOT_IN_DEST_STORAGE_POOL);
    }
    if (getVds().getStatus() != VDSStatus.Up) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateRequestedProxyHost() {
    if (getVds() == null) {
        return new ValidationResult(EngineMessage.VDS_DOES_NOT_EXIST);
    }
    if (!getStoragePoolId().equals(getVds().getStoragePoolId())) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VDS_NOT_IN_DEST_STORAGE_POOL);
    }
    if (getVds().getStatus() != VDSStatus.Up) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private Guid createDisk(DiskImage image) {
    image.setDiskAlias(renameDiskAlias(image.getDiskAlias()));
    image.setDiskInterface(DiskInterface.VirtIO);
    AddDiskParameters diskParameters = new AddDiskParameters(getVmId(), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.AddDisk, diskParameters);
    if (!vdcReturnValueBase.getSucceeded()) {
        throw new VdcBLLException(vdcReturnValueBase.getFault().getError(), "Failed to create disk!");
    }
    getTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
    return vdcReturnValueBase.getActionReturnValue();
}
#method_after
private Guid createDisk(DiskImage image) {
    image.setDiskAlias(renameDiskAlias(image.getDiskAlias()));
    image.setDiskInterface(DiskInterface.VirtIO);
    AddDiskParameters diskParameters = new AddDiskParameters(getVmId(), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.AddDisk, diskParameters);
    if (!vdcReturnValueBase.getSucceeded()) {
        throw new EngineException(vdcReturnValueBase.getFault().getError(), "Failed to create disk!");
    }
    getTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
    return vdcReturnValueBase.getActionReturnValue();
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    endActionOnDisks();
    String virtioIsoPath = getVirtioIsoPath();
    // Lock will be acquired by the convert command.
    // Note that the VM is not locked for a short period of time. This should be fixed
    // when locks that are passed by caller could be released by command's callback.
    freeLock();
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.ConvertVm, buildConvertVmParameters(virtioIsoPath), cloneContextAndDetachFromParent());
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    endActionOnDisks();
    // Lock will be acquired by the convert command.
    // Note that the VM is not locked for a short period of time. This should be fixed
    // when locks that are passed by caller could be released by command's callback.
    freeLock();
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.ConvertVm, buildConvertVmParameters(), cloneContextAndDetachFromParent());
    setSucceeded(true);
}
#end_block

#method_before
private ConvertVmParameters buildConvertVmParameters(String virtioIsoPath) {
    ConvertVmParameters parameters = new ConvertVmParameters(getVmId());
    parameters.setUrl(getParameters().getUrl());
    parameters.setUsername(getParameters().getUsername());
    parameters.setPassword(getParameters().getPassword());
    parameters.setVmName(getVmName());
    parameters.setDisks(getDisks());
    parameters.setStoragePoolId(getStoragePoolId());
    parameters.setStorageDomainId(getStorageDomainId());
    parameters.setProxyHostId(getParameters().getProxyHostId());
    parameters.setVdsGroupId(getVdsGroupId());
    parameters.setVirtioIsoPath(virtioIsoPath);
    return parameters;
}
#method_after
private ConvertVmParameters buildConvertVmParameters() {
    ConvertVmParameters parameters = new ConvertVmParameters(getVmId());
    parameters.setUrl(getParameters().getUrl());
    parameters.setUsername(getParameters().getUsername());
    parameters.setPassword(getParameters().getPassword());
    parameters.setVmName(getVmName());
    parameters.setDisks(getDisks());
    parameters.setStoragePoolId(getStoragePoolId());
    parameters.setStorageDomainId(getStorageDomainId());
    parameters.setProxyHostId(getParameters().getProxyHostId());
    parameters.setVdsGroupId(getVdsGroupId());
    parameters.setVirtioIsoName(getParameters().getVirtioIsoName());
    return parameters;
}
#end_block

#method_before
private VMStatsRefresher getRefresherForVds(VdsManager vdsManager) {
    Version version = vdsManager.getCompatibilityVersion();
    VDS vds = vdsManager.getCopyVds();
    if (FeatureSupported.jsonProtocol(version) && VdsProtocol.STOMP == vds.getProtocol() && FeatureSupported.vmStatsEvents(version)) {
        PollAllVmStatsOnlyRefresher allVmStatsRefresher = Injector.injectMembers(new PollAllVmStatsOnlyRefresher(vdsManager));
        return new EventVMStatsRefresher(vdsManager, allVmStatsRefresher);
    }
    return new PollListAndAllVmStatsRefresher(vdsManager);
}
#method_after
private VMStatsRefresher getRefresherForVds(VdsManager vdsManager) {
    Version version = vdsManager.getCompatibilityVersion();
    VDS vds = vdsManager.getCopyVds();
    if (FeatureSupported.jsonProtocol(version) && VdsProtocol.STOMP == vds.getProtocol() && FeatureSupported.vmStatsEvents(version)) {
        return new EventVMStatsRefresher(vdsManager);
    }
    return new PollListAndAllVmStatsRefresher(vdsManager);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    updateIteration();
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        mUnrespondedAttempts.set(0);
                        setLastUpdate();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtime info failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    updateIteration();
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        unrespondedAttempts.set(0);
                        setLastUpdate();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtime info failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("recoverFromError")
public void recoverFromError() {
    VDS vds = dbFacade.getVdsDao().get(getVdsId());
    /**
     * Move cachedVds to Up status from error
     */
    if (vds != null && vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        dbFacade.getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
        log.info("Settings host '{}' to up after {} failed attempts to run a VM", vds.getName(), mFailedToRunVmAttempts);
        mFailedToRunVmAttempts.set(0);
    }
}
#method_after
@OnTimerMethodAnnotation("recoverFromError")
public void recoverFromError() {
    VDS vds = dbFacade.getVdsDao().get(getVdsId());
    /**
     * Move cachedVds to Up status from error
     */
    if (vds != null && vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        dbFacade.getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
        log.info("Settings host '{}' to up after {} failed attempts to run a VM", vds.getName(), failedToRunVmAttempts);
        failedToRunVmAttempts.set(0);
    }
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        resourceManager.runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = getSchedulUtil();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        auditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString()), AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.info("Vds '{}' moved to Error mode after {} attempts. Time: {}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (failedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && failedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        resourceManager.runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = getSchedulUtil();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        auditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString()), AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.info("Vds '{}' moved to Error mode after {} attempts. Time: {}", vds.getName(), failedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
public void succeededToRunVm(Guid vmId) {
    mUnrespondedAttempts.set(0);
    resourceManager.succededToRunVm(vmId, getVdsId());
}
#method_after
public void succeededToRunVm(Guid vmId) {
    unrespondedAttempts.set(0);
    resourceManager.succededToRunVm(vmId, getVdsId());
}
#end_block

#method_before
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
        if (isHostInGracePeriod(false)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
                logChangeStatusToConnecting(timeoutToFence);
            } else {
                saveToDb = false;
            }
            mUnrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVMsToUnknown();
                    logHostFailToRespond(ex, timeoutToFence);
                    resourceManager.getEventListener().vdsNotResponding(cachedVds);
                } else {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                }
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#method_after
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
        if (isHostInGracePeriod(false)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
                logChangeStatusToConnecting(timeoutToFence);
            } else {
                saveToDb = false;
            }
            unrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVMsToUnknown();
                    logHostFailToRespond(ex, timeoutToFence);
                    resourceManager.getEventListener().vdsNotResponding(cachedVds);
                } else {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                }
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#end_block

#method_before
public boolean isHostInGracePeriod(boolean sshSoftFencingExecuted) {
    long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
    int unrespondedAttemptsBarrier = Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount);
    if (sshSoftFencingExecuted) {
        // SSH Soft Fencing has already been executed, increase timeout to see if host is OK
        timeoutToFence = timeoutToFence * 2;
        unrespondedAttemptsBarrier = unrespondedAttemptsBarrier * 2;
    }
    return mUnrespondedAttempts.get() < unrespondedAttemptsBarrier || (lastUpdate + timeoutToFence) > System.currentTimeMillis();
}
#method_after
public boolean isHostInGracePeriod(boolean sshSoftFencingExecuted) {
    long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
    int unrespondedAttemptsBarrier = Config.<Integer>getValue(ConfigValues.VDSAttemptsToResetCount);
    if (sshSoftFencingExecuted) {
        // SSH Soft Fencing has already been executed, increase timeout to see if host is OK
        timeoutToFence = timeoutToFence * 2;
        unrespondedAttemptsBarrier = unrespondedAttemptsBarrier * 2;
    }
    return unrespondedAttempts.get() < unrespondedAttemptsBarrier || (lastUpdate + timeoutToFence) > System.currentTimeMillis();
}
#end_block

#method_before
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = new AuditLogableBase(cachedVds.getId());
    logable.updateCallStackFromThrowable(ex);
    auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
}
#method_after
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = new AuditLogableBase(cachedVds.getId());
    logable.updateCallStackFromThrowable(ex);
    if (ex.getCause() instanceof java.net.UnknownHostException) {
        auditLogDirector.log(logable, AuditLogType.VDS_UNKNOWN_HOST);
    } else {
        auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
    }
}
#end_block

#method_before
public boolean getbeforeFirstRefresh() {
    return mBeforeFirstRefresh;
}
#method_after
public boolean getbeforeFirstRefresh() {
    return beforeFirstRefresh;
}
#end_block

#method_before
public void setbeforeFirstRefresh(boolean value) {
    mBeforeFirstRefresh = value;
}
#method_after
public void setbeforeFirstRefresh(boolean value) {
    beforeFirstRefresh = value;
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    _result = getIrsProxy().getStoragePoolInfo(getParameters().getStoragePoolId().toString());
    proceedProxyReturnValue();
    StoragePool sp = VdsBrokerObjectsBuilder.buildStoragePool(_result.storagePoolInfo);
    Guid masterId = Guid.Empty;
    if (_result.storagePoolInfo.containsKey("master_uuid")) {
        masterId = new Guid(_result.storagePoolInfo.get("master_uuid").toString());
    }
    sp.setId(getParameters().getStoragePoolId());
    ArrayList<StorageDomain> domList = ParseStorageDomainList(_result.domainsList, masterId);
    KeyValuePairCompat<StoragePool, List<StorageDomain>> list = new KeyValuePairCompat<StoragePool, List<StorageDomain>>(sp, domList);
    setReturnValue(list);
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    result = getIrsProxy().getStoragePoolInfo(getParameters().getStoragePoolId().toString());
    proceedProxyReturnValue();
    StoragePool sp = VdsBrokerObjectsBuilder.buildStoragePool(result.storagePoolInfo);
    Guid masterId = Guid.Empty;
    if (result.storagePoolInfo.containsKey("master_uuid")) {
        masterId = new Guid(result.storagePoolInfo.get("master_uuid").toString());
    }
    sp.setId(getParameters().getStoragePoolId());
    ArrayList<StorageDomain> domList = ParseStorageDomainList(result.domainsList, masterId);
    KeyValuePairCompat<StoragePool, List<StorageDomain>> list = new KeyValuePairCompat<StoragePool, List<StorageDomain>>(sp, domList);
    setReturnValue(list);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return _result.getXmlRpcStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getXmlRpcStatus();
}
#end_block

#method_before
public static VDSReturnValue handleVdsResult(VDSReturnValue result) {
    if (StringUtils.isNotEmpty(result.getExceptionString())) {
        throw new EngineException(result.getVdsError() != null ? result.getVdsError().getCode() : EngineError.ENGINE, result.getExceptionString());
    }
    return result;
}
#method_after
public static VDSReturnValue handleVdsResult(VDSReturnValue result) {
    if (StringUtils.isNotEmpty(result.getExceptionString())) {
        throw new EngineException(result.getVdsError() != null ? result.getVdsError().getCode() : EngineError.ENGINE, result.getExceptionString(), result);
    }
    return result;
}
#end_block

#method_before
public boolean failover() {
    Guid vdsId = currentVdsId;
    nullifyInternalProxies();
    boolean performFailover = false;
    if (vdsId != null) {
        try {
            VDSReturnValue statusResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vdsId, _storagePoolId));
            if (statusResult != null && statusResult.getSucceeded() && (((SpmStatusResult) statusResult.getReturnValue()).getSpmStatus() == SpmStatus.SPM || ((SpmStatusResult) statusResult.getReturnValue()).getSpmStatus() == SpmStatus.Contend)) {
                performFailover = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsId, _storagePoolId)).getSucceeded();
            } else {
                performFailover = true;
            }
        } catch (Exception ex) {
            // try to failover to another host if failed to get spm
            // status or stop spm
            // (in case currentVdsId has wrong id for some reason)
            log.error("Could not get spm status on host '{}' for spmStop: {}", vdsId, ex.getMessage());
            log.debug("Exception", ex);
            performFailover = true;
        }
    }
    if (performFailover) {
        log.info("Irs placed on server '{}' failed. Proceed Failover", vdsId);
        triedVdssList.add(vdsId);
        return true;
    } else {
        log.error("IRS failover failed - cant allocate vds server");
        return false;
    }
}
#method_after
public boolean failover() {
    Guid vdsId = currentVdsId;
    nullifyInternalProxies();
    boolean performFailover = false;
    if (vdsId != null) {
        try {
            VDSReturnValue statusResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vdsId, _storagePoolId));
            if (statusResult != null && statusResult.getSucceeded() && (((SpmStatusResult) statusResult.getReturnValue()).getSpmStatus() == SpmStatus.SPM || ((SpmStatusResult) statusResult.getReturnValue()).getSpmStatus() == SpmStatus.Contend)) {
                performFailover = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsId, _storagePoolId)).getSucceeded();
            } else {
                performFailover = true;
            }
        } catch (Exception ex) {
            // try to failover to another host if failed to get spm
            // status or stop spm
            // (in case currentVdsId has wrong id for some reason)
            log.error("Could not get spm status on host '{}' for spmStop: {}", vdsId, ex.getMessage());
            log.debug("Exception", ex);
            performFailover = true;
        }
    }
    if (performFailover) {
        log.info("Irs placed on server '{}' failed. Proceed Failover", vdsId);
        triedVdssList.add(vdsId);
        return true;
    } else {
        log.error("IRS failover failed - can't allocate vds server");
        return false;
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    _result = getBroker().getStorageDomainsList(getParameters().getStoragePoolId().toString(), getParameters().getStorageDomainType().getValue(), getParameters().getStorageType() != null ? Integer.valueOf(getParameters().getStorageType().getValue()).toString() : "", ((getParameters().getPath()) != null) ? getParameters().getPath() : "");
    proceedProxyReturnValue();
    ArrayList<Guid> domains = new ArrayList<Guid>();
    for (String domain : _result.storageDomainList) {
        domains.add(new Guid(domain));
    }
    setReturnValue(domains);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    result = getBroker().getStorageDomainsList(getParameters().getStoragePoolId().toString(), getParameters().getStorageDomainType().getValue(), getParameters().getStorageType() != null ? Integer.valueOf(getParameters().getStorageType().getValue()).toString() : "", ((getParameters().getPath()) != null) ? getParameters().getPath() : "");
    proceedProxyReturnValue();
    ArrayList<Guid> domains = new ArrayList<Guid>();
    for (String domain : result.storageDomainList) {
        domains.add(new Guid(domain));
    }
    setReturnValue(domains);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return _result.getXmlRpcStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getXmlRpcStatus();
}
#end_block

#method_before
@Override
protected Object getReturnValueFromBroker() {
    return _result;
}
#method_after
@Override
protected Object getReturnValueFromBroker() {
    return result;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    String storageDomainId = getParameters().getStorageDomainId().toString();
    List<String> deviceList = getParameters().getDeviceList();
    String[] deviceArray = deviceList.toArray(new String[deviceList.size()]);
    boolean isForce = getParameters().isForce();
    boolean supportForceCreateVG = Config.<Boolean>getValue(ConfigValues.SupportForceCreateVG, getVds().getVdsGroupCompatibilityVersion().toString());
    _result = supportForceCreateVG ? getBroker().createVG(storageDomainId, deviceArray, isForce) : getBroker().createVG(storageDomainId, deviceArray);
    proceedProxyReturnValue();
    setReturnValue(_result.uuid);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    String storageDomainId = getParameters().getStorageDomainId().toString();
    List<String> deviceList = getParameters().getDeviceList();
    String[] deviceArray = deviceList.toArray(new String[deviceList.size()]);
    boolean isForce = getParameters().isForce();
    boolean supportForceCreateVG = Config.<Boolean>getValue(ConfigValues.SupportForceCreateVG, getVds().getVdsGroupCompatibilityVersion().toString());
    result = supportForceCreateVG ? getBroker().createVG(storageDomainId, deviceArray, isForce) : getBroker().createVG(storageDomainId, deviceArray);
    proceedProxyReturnValue();
    setReturnValue(result.uuid);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return _result.getXmlRpcStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getXmlRpcStatus();
}
#end_block

#method_before
@Override
protected Object getReturnValueFromBroker() {
    return _result;
}
#method_after
@Override
protected Object getReturnValueFromBroker() {
    return result;
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    vmsRefresher.updateIteration();
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        unrespondedAttempts.set(0);
                        setLastUpdate();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtime info failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    updateIteration();
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        unrespondedAttempts.set(0);
                        setLastUpdate();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtime info failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependecyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.initDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    loadService(AutoStartVmsRunner.class);
    loadService(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependecyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.initDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    loadService(AutoStartVmsRunner.class);
    loadService(QuotaManager.class);
    loadService(CertificationValidityChecker.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
public DiskImage createDisk(Guid domainId) {
    DiskImage newCreatedDiskImage = new DiskImage();
    newCreatedDiskImage.setDiskInterface(DiskInterface.IDE);
    newCreatedDiskImage.setWipeAfterDelete(false);
    newCreatedDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
    newCreatedDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
    newCreatedDiskImage.setShareable(shouldOvfStoreBeShareable());
    newCreatedDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(domainId)));
    newCreatedDiskImage.setSize(SizeConverter.BYTES_IN_MB * 128);
    newCreatedDiskImage.setvolumeFormat(VolumeFormat.RAW);
    newCreatedDiskImage.setVolumeType(VolumeType.Preallocated);
    newCreatedDiskImage.setDescription("OVF store for domain " + domainId);
    Date creationDate = new Date();
    newCreatedDiskImage.setCreationDate(creationDate);
    newCreatedDiskImage.setLastModified(creationDate);
    return newCreatedDiskImage;
}
#method_after
public DiskImage createDisk(Guid domainId) {
    DiskImage createdDiskImage = new DiskImage();
    createdDiskImage.setDiskInterface(DiskInterface.IDE);
    createdDiskImage.setWipeAfterDelete(false);
    createdDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
    createdDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
    createdDiskImage.setShareable(shouldOvfStoreBeShareable());
    createdDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(domainId)));
    createdDiskImage.setSize(SizeConverter.BYTES_IN_MB * 128);
    createdDiskImage.setvolumeFormat(VolumeFormat.RAW);
    createdDiskImage.setVolumeType(VolumeType.Preallocated);
    createdDiskImage.setDescription("OVF store for domain " + domainId);
    Date creationDate = new Date();
    createdDiskImage.setCreationDate(creationDate);
    createdDiskImage.setLastModified(creationDate);
    return createdDiskImage;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    _result = getBroker().getStorageDomainStats(getParameters().getStorageDomainId().toString());
    proceedProxyReturnValue();
    StorageDomain domain = buildStorageDynamicFromXmlRpcStruct(_result.storageStats);
    domain.setId(getParameters().getStorageDomainId());
    setReturnValue(domain);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    result = getBroker().getStorageDomainStats(getParameters().getStorageDomainId().toString());
    proceedProxyReturnValue();
    StorageDomain domain = buildStorageDynamicFromXmlRpcStruct(result.storageStats);
    domain.setId(getParameters().getStorageDomainId());
    setReturnValue(domain);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return _result.getXmlRpcStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getXmlRpcStatus();
}
#end_block

#method_before
@Override
protected Object getReturnValueFromBroker() {
    return _result;
}
#method_after
@Override
protected Object getReturnValueFromBroker() {
    return result;
}
#end_block

#method_before
public StorageDomain getStorageDomain() {
    if (_storageDomain == null && getStorageDomainId() != null) {
        if (storagePoolId != null && getStoragePool() != null) {
            _storageDomain = getStorageDomainDao().getForStoragePool(getStorageDomainId(), getStoragePool().getId());
        }
        if (_storageDomain == null) {
            final List<StorageDomain> storageDomainList = getStorageDomainDao().getAllForStorageDomain(getStorageDomainId());
            if (storageDomainList.size() != 0) {
                _storageDomain = storageDomainList.get(0);
                for (final StorageDomain storageDomainFromList : storageDomainList) {
                    if (storageDomainFromList.getStatus() == StorageDomainStatus.Active) {
                        _storageDomain = storageDomainFromList;
                        break;
                    }
                }
            }
        }
    }
    return _storageDomain;
}
#method_after
public StorageDomain getStorageDomain() {
    if (storageDomain == null && getStorageDomainId() != null) {
        if (storagePoolId != null && getStoragePool() != null) {
            storageDomain = getStorageDomainDao().getForStoragePool(getStorageDomainId(), getStoragePool().getId());
        }
        if (storageDomain == null) {
            final List<StorageDomain> storageDomainList = getStorageDomainDao().getAllForStorageDomain(getStorageDomainId());
            if (storageDomainList.size() != 0) {
                storageDomain = storageDomainList.get(0);
                for (final StorageDomain storageDomainFromList : storageDomainList) {
                    if (storageDomainFromList.getStatus() == StorageDomainStatus.Active) {
                        storageDomain = storageDomainFromList;
                        break;
                    }
                }
            }
        }
    }
    return storageDomain;
}
#end_block

#method_before
public void setStorageDomain(final StorageDomain value) {
    _storageDomain = value;
}
#method_after
public void setStorageDomain(final StorageDomain value) {
    storageDomain = value;
}
#end_block

#method_before
public Guid getStorageDomainId() {
    if (_storageDomain != null) {
        return _storageDomain.getId();
    }
    return storageDomainId;
}
#method_after
public Guid getStorageDomainId() {
    if (storageDomain != null) {
        return storageDomain.getId();
    }
    return storageDomainId;
}
#end_block

#method_before
public StoragePool getStoragePool() {
    if (_storagePool == null && getStoragePoolId() != null && !Guid.Empty.equals(getStoragePoolId())) {
        _storagePool = getStoragePoolDao().get(getStoragePoolId());
    }
    return _storagePool;
}
#method_after
public StoragePool getStoragePool() {
    if (storagePool == null && getStoragePoolId() != null && !Guid.Empty.equals(getStoragePoolId())) {
        storagePool = getStoragePoolDao().get(getStoragePoolId());
    }
    return storagePool;
}
#end_block

#method_before
public void setStoragePool(final StoragePool value) {
    _storagePool = value;
}
#method_after
public void setStoragePool(final StoragePool value) {
    storagePool = value;
}
#end_block

#method_before
public Guid getStoragePoolId() {
    if (storagePoolId == null) {
        if (_storagePool != null) {
            storagePoolId = _storagePool.getId();
        } else if (getStorageDomain() != null) {
            storagePoolId = getStorageDomain().getStoragePoolId();
        }
    }
    return storagePoolId;
}
#method_after
public Guid getStoragePoolId() {
    if (storagePoolId == null) {
        if (storagePool != null) {
            storagePoolId = storagePool.getId();
        } else if (getStorageDomain() != null) {
            storagePoolId = getStorageDomain().getStoragePoolId();
        }
    }
    return storagePoolId;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    _result = getBroker().getStorageDomainInfo(getParameters().getStorageDomainId().toString());
    proceedProxyReturnValue();
    Pair<StorageDomainStatic, Guid> pairSdStatic = BuildStorageStaticFromXmlRpcStruct(_result.storageInfo);
    pairSdStatic.getFirst().setId(getParameters().getStorageDomainId());
    setReturnValue(pairSdStatic);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    result = getBroker().getStorageDomainInfo(getParameters().getStorageDomainId().toString());
    proceedProxyReturnValue();
    Pair<StorageDomainStatic, Guid> pairSdStatic = BuildStorageStaticFromXmlRpcStruct(result.storageInfo);
    pairSdStatic.getFirst().setId(getParameters().getStorageDomainId());
    setReturnValue(pairSdStatic);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return _result.getXmlRpcStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getXmlRpcStatus();
}
#end_block

#method_before
@Override
protected Object getReturnValueFromBroker() {
    return _result;
}
#method_after
@Override
protected Object getReturnValueFromBroker() {
    return result;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    _result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), String.valueOf(getParameters().getSCSIFencing()).toLowerCase(), Config.<Integer>getValue(ConfigValues.MaxNumberOfHostsInStoragePool), getParameters().getStoragePoolFormatType().getValue());
    proceedProxyReturnValue();
    Guid taskId = new Guid(_result.uuid);
    AsyncTaskStatus taskStatus;
    log.info("spmStart polling started: taskId '{}'", taskId);
    do {
        // TODO: make configurable
        ThreadUtils.sleep(1000);
        taskStatus = (AsyncTaskStatus) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetTaskStatus, new HSMTaskGuidBaseVDSCommandParameters(vdsId, taskId)).getReturnValue();
        log.debug("spmStart polling - task status: '{}'", taskStatus.getStatus());
    } while (taskStatus.getStatus() != AsyncTaskStatusEnum.finished && taskStatus.getStatus() != AsyncTaskStatusEnum.unknown);
    log.info("spmStart polling ended: taskId '{}' task status '{}'", taskId, taskStatus.getStatus());
    if (!taskStatus.getTaskEndedSuccessfully()) {
        log.error("Start SPM Task failed - result: '{}', message: {}", taskStatus.getResult(), taskStatus.getMessage());
    }
    SpmStatusResult spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vdsId, getParameters().getStoragePoolId())).getReturnValue();
    if (spmStatus != null) {
        log.info("spmStart polling ended, spm status: {}", spmStatus.getSpmStatus());
    } else {
        log.error("spmStart polling ended, failed to get the spm status");
    }
    try {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMClearTask, new HSMTaskGuidBaseVDSCommandParameters(vdsId, taskId));
    } catch (Exception e) {
        log.error("Could not clear spmStart task '{}', continuing with SPM selection: {}", taskId, e.getMessage());
        log.debug("Exception", e);
    }
    setReturnValue(spmStatus);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), String.valueOf(getParameters().getSCSIFencing()).toLowerCase(), Config.<Integer>getValue(ConfigValues.MaxNumberOfHostsInStoragePool), getParameters().getStoragePoolFormatType().getValue());
    proceedProxyReturnValue();
    Guid taskId = new Guid(result.uuid);
    AsyncTaskStatus taskStatus;
    log.info("spmStart polling started: taskId '{}'", taskId);
    do {
        // TODO: make configurable
        ThreadUtils.sleep(1000);
        taskStatus = (AsyncTaskStatus) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetTaskStatus, new HSMTaskGuidBaseVDSCommandParameters(vdsId, taskId)).getReturnValue();
        log.debug("spmStart polling - task status: '{}'", taskStatus.getStatus());
    } while (taskStatus.getStatus() != AsyncTaskStatusEnum.finished && taskStatus.getStatus() != AsyncTaskStatusEnum.unknown);
    log.info("spmStart polling ended: taskId '{}' task status '{}'", taskId, taskStatus.getStatus());
    if (!taskStatus.getTaskEndedSuccessfully()) {
        log.error("Start SPM Task failed - result: '{}', message: {}", taskStatus.getResult(), taskStatus.getMessage());
    }
    SpmStatusResult spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(vdsId, getParameters().getStoragePoolId())).getReturnValue();
    if (spmStatus != null) {
        log.info("spmStart polling ended, spm status: {}", spmStatus.getSpmStatus());
    } else {
        log.error("spmStart polling ended, failed to get the spm status");
    }
    try {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMClearTask, new HSMTaskGuidBaseVDSCommandParameters(vdsId, taskId));
    } catch (Exception e) {
        log.error("Could not clear spmStart task '{}', continuing with SPM selection: {}", taskId, e.getMessage());
        log.debug("Exception", e);
    }
    setReturnValue(spmStatus);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return _result.getXmlRpcStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getXmlRpcStatus();
}
#end_block

#method_before
@Override
protected Object getReturnValueFromBroker() {
    return _result;
}
#method_after
@Override
protected Object getReturnValueFromBroker() {
    return result;
}
#end_block

#method_before
protected DiskImage getDiskImage() {
    if (_diskImage == null) {
        _diskImage = getImage();
    }
    return _diskImage;
}
#method_after
protected DiskImage getDiskImage() {
    if (diskImage == null) {
        diskImage = getImage();
    }
    return diskImage;
}
#end_block

#method_before
protected void setDiskImage(DiskImage value) {
    _diskImage = value;
}
#method_after
protected void setDiskImage(DiskImage value) {
    diskImage = value;
}
#end_block

#method_before
protected Guid getImageGroupId() {
    if (_imageGroupId.equals(Guid.Empty)) {
        _imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    }
    return _imageGroupId;
}
#method_after
protected Guid getImageGroupId() {
    if (imageGroupId.equals(Guid.Empty)) {
        imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    }
    return imageGroupId;
}
#end_block

#method_before
protected void setImageGroupId(Guid value) {
    _imageGroupId = value;
}
#method_after
protected void setImageGroupId(Guid value) {
    imageGroupId = value;
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    _result = getIrsProxy().activateStorageDomain(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString());
    proceedProxyReturnValue();
    setReturnValue(_result.storageStatus);
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    result = getIrsProxy().activateStorageDomain(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString());
    proceedProxyReturnValue();
    setReturnValue(result.storageStatus);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return _result.getXmlRpcStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getXmlRpcStatus();
}
#end_block

#method_before
@Override
protected Object getReturnValueFromBroker() {
    return _result;
}
#method_after
@Override
protected Object getReturnValueFromBroker() {
    return result;
}
#end_block

#method_before
protected void proceedProxyReturnValue() {
    EngineError returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().message);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().message);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().message);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().message);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case HOT_PLUG_UNPLUG_CPU_ERROR:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
        case V2V_JOB_DOESNT_EXIST:
        case V2V_NO_SUCH_OVF:
        case V2V_JOB_NOT_DONE:
        case V2V_JOB_ALREADY_EXIST:
        case UnsupportedGlusterVolumeReplicaCountError:
            if (this instanceof IrsBrokerCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().message);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().message));
            }
            break;
        case VDS_NETWORK_ERROR:
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().message);
            break;
        default:
            log.error("Failed in '{}' method", getCommandName());
            outEx = createException();
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().message);
    outEx.setVdsError(tempVar);
    logToAudit();
    throw outEx;
}
#method_after
protected void proceedProxyReturnValue() {
    EngineError returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().message);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().message);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().message);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().message);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case HOT_PLUG_UNPLUG_CPU_ERROR:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
        case V2V_JOB_DOESNT_EXIST:
        case V2V_NO_SUCH_OVF:
        case V2V_JOB_NOT_DONE:
        case V2V_JOB_ALREADY_EXIST:
        case UnsupportedGlusterVolumeReplicaCountError:
            if (this instanceof IrsBrokerCommand || this instanceof StorageDomainMetadataCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().message);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().message));
            }
            break;
        case VDS_NETWORK_ERROR:
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().message);
            break;
        default:
            log.error("Failed in '{}' method", getCommandName());
            outEx = createException();
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().message);
    outEx.setVdsError(tempVar);
    logToAudit();
    throw outEx;
}
#end_block

#method_before
public static AuditLogCleanupManager getInstance() {
    return _instance;
}
#method_after
public static AuditLogCleanupManager getInstance() {
    return instance;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    _result = getBroker().getAllTasksStatuses();
    proceedProxyReturnValue();
    setReturnValue(parseTaskStatusList(_result.taskStatusList));
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    result = getBroker().getAllTasksStatuses();
    proceedProxyReturnValue();
    setReturnValue(parseTaskStatusList(result.taskStatusList));
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return _result.getXmlRpcStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getXmlRpcStatus();
}
#end_block

#method_before
// overrides the value of the status that is being checked in the
// proceedProxyReturnValue method.
// Used when multiple calls to proceedProxyReturnValue are needed within
// the same VDSCommand on different status values, for example, a regular
// verb
protected void updateReturnStatus(StatusForXmlRpc newReturnStatus) {
    _result.setXmlRpcStatus(newReturnStatus);
}
#method_after
// overrides the value of the status that is being checked in the
// proceedProxyReturnValue method.
// Used when multiple calls to proceedProxyReturnValue are needed within
// the same VDSCommand on different status values, for example, a regular
// verb
protected void updateReturnStatus(StatusForXmlRpc newReturnStatus) {
    result.setXmlRpcStatus(newReturnStatus);
}
#end_block

#method_before
@Override
protected Object getReturnValueFromBroker() {
    return _result;
}
#method_after
@Override
protected Object getReturnValueFromBroker() {
    return result;
}
#end_block

#method_before
@Override
public void parseArguments(List<String> args) throws Exception {
    args.remove(0);
    Properties props = new Properties();
    try (InputStream in = InfoServiceImpl.class.getResourceAsStream("info.properties");
        Reader reader = new InputStreamReader(in, Charset.forName("UTF-8"))) {
        props.load(reader);
    }
    Map<String, String> substitutions = (Map) context.get(ContextKeys.CLI_PARSER_SUBSTITUTIONS);
    ArgumentsParser parser = new ArgumentsParser(props, "module");
    parser.getSubstitutions().putAll(substitutions);
    parser.parse(args);
    Map<String, Object> moduleArgs = parser.getParsedArgs();
    if ((Boolean) moduleArgs.get("help")) {
        System.out.format("Usage: %s", parser.getUsage());
        throw new ExitException("Help", 0);
    }
    if (!parser.getErrors().isEmpty()) {
        for (Throwable t : parser.getErrors()) {
            System.err.format("FATAL: %s%n", t.getMessage());
        }
        throw new ExitException("Parsing error", 1);
    }
    if (args.size() < 1) {
        System.err.println("Action not provided");
        throw new ExitException("Action not provided", 1);
    }
    try {
        action = Action.valueOf(args.get(0).toUpperCase().replace("-", "_"));
    } catch (IllegalArgumentException e) {
        System.err.printf("Invalid action '%s'%n", args.get(0));
        throw new ExitException("Invalid action", 1);
    }
    argMap = action.parse(substitutions, props, args);
}
#method_after
@Override
public void parseArguments(List<String> args) throws Exception {
    args.remove(0);
    Properties props = new Properties();
    try (InputStream in = InfoServiceImpl.class.getResourceAsStream("info.properties");
        Reader reader = new InputStreamReader(in, Charset.forName("UTF-8"))) {
        props.load(reader);
    }
    Map<String, String> substitutions = (Map) context.get(ContextKeys.CLI_PARSER_SUBSTITUTIONS);
    ArgumentsParser parser = new ArgumentsParser(props, "module");
    parser.getSubstitutions().putAll(substitutions);
    parser.parse(args);
    Map<String, Object> moduleArgs = parser.getParsedArgs();
    if ((Boolean) moduleArgs.get("help")) {
        System.out.format("Usage: %s", parser.getUsage());
        throw new ExitException("Help", 0);
    }
    if (!parser.getErrors().isEmpty()) {
        for (Throwable t : parser.getErrors()) {
            log.error(t.getMessage());
        }
        throw new ExitException("Parsing error", 1);
    }
    if (args.size() < 1) {
        log.error("Action not provided");
        throw new ExitException("Action not provided", 1);
    }
    try {
        action = Action.valueOf(args.get(0).toUpperCase().replace("-", "_"));
    } catch (IllegalArgumentException e) {
        log.error("Invalid action '{}'", args.get(0));
        throw new ExitException("Invalid action", 1);
    }
    argMap = action.parse(substitutions, props, args);
}
#end_block

#method_before
@Override
public Response add(InstanceType instanceType) {
    validateParameters(instanceType, "name");
    VmStatic vmStatic = getMapper(InstanceType.class, VmStatic.class).map(instanceType, new VmStatic());
    VM vm = new VM();
    vm.setStaticData(vmStatic);
    String name = instanceType.getName();
    String description = "";
    if (instanceType.isSetDescription()) {
        description = instanceType.getDescription();
    }
    vm.setVmDescription(description);
    AddVmTemplateParameters addInstanceTypeParameters = new AddVmTemplateParameters(vm, name, description);
    addInstanceTypeParameters.setTemplateType(VmEntityType.INSTANCE_TYPE);
    addInstanceTypeParameters.setVmTemplateId(null);
    addInstanceTypeParameters.setPublicUse(true);
    addInstanceTypeParameters.setConsoleEnabled(instanceType.getConsole() != null && instanceType.getConsole().isSetEnabled() ? instanceType.getConsole().isEnabled() : false);
    addInstanceTypeParameters.setVirtioScsiEnabled(instanceType.isSetVirtioScsi() && instanceType.getVirtioScsi().isSetEnabled() ? instanceType.getVirtioScsi().isEnabled() : null);
    if (instanceType.isSetSoundcardEnabled()) {
        addInstanceTypeParameters.setSoundDeviceEnabled(instanceType.isSoundcardEnabled());
    }
    return performCreate(VdcActionType.AddVmTemplate, addInstanceTypeParameters, new QueryIdResolver<Guid>(VdcQueryType.GetInstanceType, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(InstanceType instanceType) {
    validateParameters(instanceType, "name");
    VmStatic vmStatic = getMapper(InstanceType.class, VmStatic.class).map(instanceType, new VmStatic());
    VM vm = new VM();
    vm.setStaticData(vmStatic);
    String name = instanceType.getName();
    String description = "";
    if (instanceType.isSetDescription()) {
        description = instanceType.getDescription();
    }
    vm.setVmDescription(description);
    AddVmTemplateParameters addInstanceTypeParameters = new AddVmTemplateParameters(vm, name, description);
    addInstanceTypeParameters.setTemplateType(VmEntityType.INSTANCE_TYPE);
    addInstanceTypeParameters.setVmTemplateId(null);
    addInstanceTypeParameters.setPublicUse(true);
    addInstanceTypeParameters.setConsoleEnabled(instanceType.getConsole() != null && instanceType.getConsole().isSetEnabled() ? instanceType.getConsole().isEnabled() : false);
    addInstanceTypeParameters.setVirtioScsiEnabled(instanceType.isSetVirtioScsi() && instanceType.getVirtioScsi().isSetEnabled() ? instanceType.getVirtioScsi().isEnabled() : null);
    if (instanceType.isSetSoundcardEnabled()) {
        addInstanceTypeParameters.setSoundDeviceEnabled(instanceType.isSoundcardEnabled());
    }
    DisplayHelper.setGraphicsToParams(instanceType.getDisplay(), addInstanceTypeParameters);
    Response response = performCreate(VdcActionType.AddVmTemplate, addInstanceTypeParameters, new QueryIdResolver<Guid>(VdcQueryType.GetInstanceType, GetVmTemplateParameters.class));
    Template result = (Template) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
    }
    return response;
}
#end_block

#method_before
@Override
public InstanceType update(InstanceType incoming) {
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetInstanceType, GetVmTemplateParameters.class), VdcActionType.UpdateVmTemplate, new UpdateParametersProvider());
}
#method_after
@Override
public InstanceType update(InstanceType incoming) {
    InstanceType instanceType = performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetInstanceType, GetVmTemplateParameters.class), VdcActionType.UpdateVmTemplate, new UpdateParametersProvider());
    if (instanceType != null) {
        DisplayHelper.adjustDisplayData(this, instanceType);
    }
    return instanceType;
}
#end_block

#method_before
public static void main(String... args) {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        setupLogger();
        ArgumentsParser parser;
        Map<String, ModuleService> moduleServices = loadModules(ModuleService.class);
        final Map<String, String> substitutions = new HashMap<>();
        substitutions.put("@ENGINE_ETC@", ENGINE_ETC);
        substitutions.put("@PROGRAM_NAME@", PROGRAM_NAME);
        substitutions.put("@MODULE_LIST@", getModules(moduleServices));
        try (InputStream stream = ExtensionsToolExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "core");
            parser.getSubstitutions().putAll(substitutions);
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        if ((Boolean) argMap.get("help") || (cmdArgs.size() > 0 && cmdArgs.get(0).equals("help"))) {
            System.out.format("Usage: %s", parser.getUsage());
            throw new ExitException("Help", 0);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ExitException("Version", 0);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                log.error(t.getMessage());
                log.debug(t.getMessage(), t);
            }
            throw new ExitException("Parsing error", 1);
        }
        if (cmdArgs.size() < 1) {
            log.error("Please provide module.");
            throw new ExitException("Module not provided", 1);
        }
        String module = cmdArgs.get(0);
        ModuleService moduleService = moduleServices.get(module);
        if (moduleService == null) {
            log.error("No such '{}' module exists.", module);
            throw new ExitException(1);
        }
        moduleService.parseArguments(cmdArgs);
        log.info("========================================================================");
        log.info("============================ Initialization ============================");
        log.info("========================================================================");
        loadExtensions(moduleService, argMap);
        log.info("========================================================================");
        log.info("============================== Execution ===============================");
        log.info("========================================================================");
        moduleService.run();
        exitStatus = 0;
    } catch (ExitException e) {
        log.debug(e.getMessage(), e);
        exitStatus = e.getExitCode();
    } catch (Throwable t) {
        log.error(t.getMessage() != null ? t.getMessage() : t.getClass().getName());
        log.debug("Exception:", t);
    }
    log.debug("Exiting with status '{}'", exitStatus);
    System.exit(exitStatus);
}
#method_after
public static void main(String... args) {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        final Map<String, String> contextSubstitutions = new HashMap<>();
        contextSubstitutions.put("@ENGINE_ETC@", ENGINE_ETC);
        contextSubstitutions.put("@PROGRAM_NAME@", PROGRAM_NAME);
        context.put(ModuleService.ContextKeys.CLI_PARSER_SUBSTITUTIONS, contextSubstitutions);
        setupLogger();
        ArgumentsParser parser;
        Map<String, ModuleService> moduleServices = loadModules(ModuleService.class);
        final Map<String, String> substitutions = new HashMap<>(contextSubstitutions);
        substitutions.put("@MODULE_LIST@", getModules(moduleServices));
        try (InputStream stream = ExtensionsToolExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "core");
            parser.getSubstitutions().putAll(substitutions);
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        if ((Boolean) argMap.get("help") || (cmdArgs.size() > 0 && cmdArgs.get(0).equals("help"))) {
            System.out.format("Usage: %s", parser.getUsage());
            throw new ExitException("Help", 0);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ExitException("Version", 0);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                log.error(t.getMessage());
                log.debug(t.getMessage(), t);
            }
            throw new ExitException("Parsing error", 1);
        }
        if (cmdArgs.size() < 1) {
            log.error("Please provide module.");
            throw new ExitException("Module not provided", 1);
        }
        String module = cmdArgs.get(0);
        ModuleService moduleService = moduleServices.get(module);
        if (moduleService == null) {
            log.error("No such '{}' module exists.", module);
            throw new ExitException(1);
        }
        moduleService.parseArguments(cmdArgs);
        log.info("========================================================================");
        log.info("============================ Initialization ============================");
        log.info("========================================================================");
        ExtensionsManager extensionsManager = new ExtensionsManager();
        extensionsManager.getGlobalContext().put(Base.GlobalContextKeys.APPLICATION_NAME, Base.ApplicationNames.OVIRT_ENGINE_EXTENSIONS_TOOL);
        context.put(ModuleService.ContextKeys.EXTENSION_MANAGER, extensionsManager);
        loadExtensions(extensionsManager, moduleService, argMap);
        log.info("========================================================================");
        log.info("============================== Execution ===============================");
        log.info("========================================================================");
        moduleService.run();
        exitStatus = 0;
    } catch (ExitException e) {
        log.debug(e.getMessage(), e);
        exitStatus = e.getExitCode();
    } catch (Throwable t) {
        log.error(t.getMessage() != null ? t.getMessage() : t.getClass().getName());
        log.debug("Exception:", t);
    }
    log.debug("Exiting with status '{}'", exitStatus);
    System.exit(exitStatus);
}
#end_block

#method_before
private static void loadExtensions(ModuleService moduleService, Map<String, Object> argMap) {
    ExtensionsManager extensionsManager = new ExtensionsManager();
    extensionsManager.getGlobalContext().put(Base.GlobalContextKeys.APPLICATION_NAME, Base.ApplicationNames.OVIRT_ENGINE_EXTENSIONS_TOOL);
    moduleService.getContext().put(ModuleService.EXTENSION_MANAGER, extensionsManager);
    List<File> files = (List<File>) argMap.get("extension-file");
    if (files == null) {
        files = listFiles(((String) argMap.get("extensions-dir")), "properties");
    }
    List<String> loadedExtensions = new LinkedList<>();
    for (File f : files) {
        log.debug("Loading extension file '{}'", f.getName());
        try {
            loadedExtensions.add(extensionsManager.load(f));
        } catch (Exception ex) {
            log.error("Extension '{}' load failed (ignored): {}", f.getName(), ex.getMessage());
            log.debug("Exception:", ex);
        }
    }
    for (String extension : loadedExtensions) {
        try {
            extensionsManager.initialize(extension);
            log.debug("Extension '{}' initialized", extension);
        } catch (Exception ex) {
            log.error("Extension '{}' initialization failed (ignored): {}", extension, ex.getMessage());
            log.debug("Exception:", ex);
        }
    }
    extensionsManager.dump();
}
#method_after
private static void loadExtensions(ExtensionsManager extensionsManager, ModuleService moduleService, Map<String, Object> argMap) {
    List<File> files = (List<File>) argMap.get("extension-file");
    if (files == null) {
        files = listFiles(((String) argMap.get("extensions-dir")), "properties");
    }
    List<String> loadedExtensions = new LinkedList<>();
    for (File f : files) {
        log.debug("Loading extension file '{}'", f.getName());
        try {
            loadedExtensions.add(extensionsManager.load(f));
        } catch (Exception ex) {
            log.error("Extension '{}' load failed (ignored): {}", f.getName(), ex.getMessage());
            log.debug("Exception:", ex);
        }
    }
    for (String extension : loadedExtensions) {
        try {
            extensionsManager.initialize(extension);
            log.debug("Extension '{}' initialized", extension);
        } catch (Exception ex) {
            log.error("Extension '{}' initialization failed (ignored): {}", extension, ex.getMessage());
            log.debug("Exception:", ex);
        }
    }
    extensionsManager.dump();
}
#end_block

#method_before
private static Map<String, ModuleService> loadModules(Class cls) {
    Map<String, ModuleService> modules = new HashMap<>();
    if (cls != null) {
        Map<String, String> parserSubs = new HashMap<>();
        parserSubs.put("PROGRAM_NAME", PROGRAM_NAME);
        ExtMap context = new ExtMap().mput(ModuleService.CLI_PARSER_SUBSTITUTIONS, parserSubs);
        ServiceLoader<ModuleService> loader = ServiceLoader.load(cls);
        for (ModuleService module : loader) {
            modules.put(module.getName(), module);
            module.setContext(context);
        }
    }
    log.debug("Loaded modules: {}", modules.keySet());
    return modules;
}
#method_after
private static Map<String, ModuleService> loadModules(Class cls) {
    Map<String, ModuleService> modules = new HashMap<>();
    if (cls != null) {
        ServiceLoader<ModuleService> loader = ServiceLoader.load(cls);
        for (ModuleService module : loader) {
            modules.put(module.getName(), module);
            module.setContext(context);
        }
    }
    log.debug("Loaded modules: {}", modules.keySet());
    return modules;
}
#end_block

#method_before
@Override
public void parseArguments(List<String> args) throws Exception {
    final Map<String, String> substitutions = new HashMap<>();
    substitutions.put("@PROGRAM_NAME@", (String) ((Map) context.get(ModuleService.CLI_PARSER_SUBSTITUTIONS)).get("PROGRAM_NAME"));
    args.remove(0);
    Properties props = new Properties();
    try (InputStream in = LoggerServiceImpl.class.getResourceAsStream("arguments.properties");
        Reader reader = new InputStreamReader(in)) {
        props.load(reader);
    }
    ArgumentsParser parser = new ArgumentsParser(props, "module");
    parser.getSubstitutions().putAll(substitutions);
    parser.parse(args);
    Map<String, Object> moduleArgs = parser.getParsedArgs();
    if ((Boolean) moduleArgs.get("help")) {
        System.out.format("Usage: %s", parser.getUsage());
        throw new ExitException("Help", 0);
    }
    if (!parser.getErrors().isEmpty()) {
        for (Throwable t : parser.getErrors()) {
            System.err.format("FATAL: %s%n", t.getMessage());
        }
        throw new ExitException("Parsing error", 1);
    }
    if (args.size() < 1) {
        System.err.println("Action not provided");
        throw new ExitException("Action not provided", 1);
    }
    try {
        action = Action.valueOf(args.get(0).toUpperCase().replace("-", "_"));
    } catch (IllegalArgumentException e) {
        System.err.printf("Invalid action '%s'%n", args.get(0));
        throw new ExitException("Invalid action", 1);
    }
    argMap = action.parse(substitutions, props, args);
}
#method_after
@Override
public void parseArguments(List<String> args) throws Exception {
    args.remove(0);
    Properties props = new Properties();
    try (InputStream in = LoggerServiceImpl.class.getResourceAsStream("arguments.properties");
        Reader reader = new InputStreamReader(in, Charset.forName("UTF-8"))) {
        props.load(reader);
    }
    Map<String, String> substitutions = (Map) context.get(ContextKeys.CLI_PARSER_SUBSTITUTIONS);
    ArgumentsParser parser = new ArgumentsParser(props, "module");
    parser.getSubstitutions().putAll(substitutions);
    parser.parse(args);
    Map<String, Object> moduleArgs = parser.getParsedArgs();
    if ((Boolean) moduleArgs.get("help")) {
        System.out.format("Usage: %s", parser.getUsage());
        throw new ExitException("Help", 0);
    }
    if (!parser.getErrors().isEmpty()) {
        for (Throwable t : parser.getErrors()) {
            System.err.format("FATAL: %s%n", t.getMessage());
        }
        throw new ExitException("Parsing error", 1);
    }
    if (args.size() < 1) {
        System.err.println("Action not provided");
        throw new ExitException("Action not provided", 1);
    }
    try {
        action = Action.valueOf(args.get(0).toUpperCase().replace("-", "_"));
    } catch (IllegalArgumentException e) {
        System.err.printf("Invalid action '%s'%n", args.get(0));
        throw new ExitException("Invalid action", 1);
    }
    argMap = action.parse(substitutions, props, args);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    try {
        executeQueryCommandChecked();
    } catch (IOException ex) {
        log.error("Failed to create signed websocket proxy ticket.", ex);
        log.debug("Exception", ex);
        getQueryReturnValue().setSucceeded(false);
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    try {
        executeQueryCommandChecked();
    } catch (IOException ex) {
        throw new EngineException(EngineError.FailedToCreateWebsocketProxyTicket, new RuntimeException(ex));
    }
}
#end_block

#method_before
private GraphicsInfo getGraphicsInfo() {
    final VM vm = getDbFacade().getVmDao().get(getParameters().getVmId());
    return vm.getGraphicsInfos().get(getParameters().getGraphicsType());
}
#method_after
private GraphicsInfo getGraphicsInfo() {
    final VM vm = vmDao.get(getParameters().getVmId(), getUserID(), getParameters().isFiltered());
    if (vm == null) {
        throw new EngineException(EngineError.VMCantBeObtained, String.format("vmid=%s", getParameters().getVmId()));
    }
    final GraphicsInfo graphicsInfo = vm.getGraphicsInfos().get(getParameters().getGraphicsType());
    if (graphicsInfo == null) {
        throw new EngineException(EngineError.GraphicsConsoleCantBeObtained, String.format("vmid=%s console=%s", getParameters().getVmId(), getParameters().getGraphicsType()));
    }
    return graphicsInfo;
}
#end_block

#method_before
private void initConditions() {
    when(dbFacade.getVdsGroupDao()).thenReturn(groupDAO);
    when(groupDAO.get((Guid) any())).thenReturn(cluster);
    when(dbFacade.getInterfaceDao()).thenReturn(interfaceDao);
    when(interfaceDao.getAllInterfacesForVds(((Guid) any()))).thenReturn(Collections.<VdsNetworkInterface>emptyList());
}
#method_after
private void initConditions() {
    when(dbFacade.getVdsGroupDao()).thenReturn(groupDao);
    when(groupDao.get((Guid) any())).thenReturn(cluster);
    when(dbFacade.getInterfaceDao()).thenReturn(interfaceDao);
    when(interfaceDao.getAllInterfacesForVds(((Guid) any()))).thenReturn(Collections.<VdsNetworkInterface>emptyList());
}
#end_block

#method_before
private void saveCpuStatisticsDataToDb() {
    final List<CpuStatistics> cpuStatisticsToSave = new ArrayList<>();
    cpuStatisticsToSave.addAll(vds.getStatisticsData().getCpuCoreStatistics());
    if (!cpuStatisticsToSave.isEmpty()) {
        List<CpuStatistics> dbCpuStats = getDbFacade().getVdsCpuStatisticsDAO().getAllCpuStatisticsByVdsId(vds.getId());
        if (dbCpuStats.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getVdsCpuStatisticsDAO().massSaveCpuStatistics(cpuStatisticsToSave, vds.getId());
                    return null;
                }
            });
        } else {
            boolean needRemoveAndSave = isRemvoeAndSaveVdsCpuStatsNeeded(cpuStatisticsToSave, dbCpuStats);
            if (needRemoveAndSave) {
                TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                    @Override
                    public Void runInTransaction() {
                        getDbFacade().getVdsCpuStatisticsDAO().removeAllCpuStatisticsByVdsId(vds.getId());
                        getDbFacade().getVdsCpuStatisticsDAO().massSaveCpuStatistics(cpuStatisticsToSave, vds.getId());
                        return null;
                    }
                });
            } else {
                TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                    @Override
                    public Void runInTransaction() {
                        getDbFacade().getVdsCpuStatisticsDAO().massUpdateCpuStatistics(cpuStatisticsToSave, vds.getId());
                        return null;
                    }
                });
            }
        }
    }
}
#method_after
private void saveCpuStatisticsDataToDb() {
    final List<CpuStatistics> cpuStatisticsToSave = new ArrayList<>();
    cpuStatisticsToSave.addAll(vds.getStatisticsData().getCpuCoreStatistics());
    if (!cpuStatisticsToSave.isEmpty()) {
        List<CpuStatistics> dbCpuStats = getDbFacade().getVdsCpuStatisticsDao().getAllCpuStatisticsByVdsId(vds.getId());
        if (dbCpuStats.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getVdsCpuStatisticsDao().massSaveCpuStatistics(cpuStatisticsToSave, vds.getId());
                    return null;
                }
            });
        } else {
            boolean needRemoveAndSave = isRemvoeAndSaveVdsCpuStatsNeeded(cpuStatisticsToSave, dbCpuStats);
            if (needRemoveAndSave) {
                TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                    @Override
                    public Void runInTransaction() {
                        getDbFacade().getVdsCpuStatisticsDao().removeAllCpuStatisticsByVdsId(vds.getId());
                        getDbFacade().getVdsCpuStatisticsDao().massSaveCpuStatistics(cpuStatisticsToSave, vds.getId());
                        return null;
                    }
                });
            } else {
                TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                    @Override
                    public Void runInTransaction() {
                        getDbFacade().getVdsCpuStatisticsDao().massUpdateCpuStatistics(cpuStatisticsToSave, vds.getId());
                        return null;
                    }
                });
            }
        }
    }
}
#end_block

#method_before
private void saveNumaStatisticsDataToDb() {
    final List<VdsNumaNode> vdsNumaNodesToSave = new ArrayList<>();
    List<VdsNumaNode> updateNumaNodes = vds.getNumaNodeList();
    if (!updateNumaNodes.isEmpty()) {
        List<VdsNumaNode> dbVdsNumaNodes = getDbFacade().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
        Map<Integer, VdsNumaNode> nodesMap = new HashMap<>();
        for (VdsNumaNode node : dbVdsNumaNodes) {
            nodesMap.put(node.getIndex(), node);
        }
        for (VdsNumaNode node : updateNumaNodes) {
            VdsNumaNode dbNode = nodesMap.get(node.getIndex());
            if (dbNode != null) {
                if (node.getNumaNodeStatistics() != null) {
                    dbNode.setNumaNodeStatistics(node.getNumaNodeStatistics());
                    vdsNumaNodesToSave.add(dbNode);
                }
            }
        }
    }
    if (!vdsNumaNodesToSave.isEmpty()) {
        getDbFacade().getVdsNumaNodeDAO().massUpdateNumaNodeStatistics(vdsNumaNodesToSave);
    }
}
#method_after
private void saveNumaStatisticsDataToDb() {
    final List<VdsNumaNode> vdsNumaNodesToSave = new ArrayList<>();
    List<VdsNumaNode> updateNumaNodes = vds.getNumaNodeList();
    if (!updateNumaNodes.isEmpty()) {
        List<VdsNumaNode> dbVdsNumaNodes = getDbFacade().getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vds.getId());
        Map<Integer, VdsNumaNode> nodesMap = new HashMap<>();
        for (VdsNumaNode node : dbVdsNumaNodes) {
            nodesMap.put(node.getIndex(), node);
        }
        for (VdsNumaNode node : updateNumaNodes) {
            VdsNumaNode dbNode = nodesMap.get(node.getIndex());
            if (dbNode != null) {
                if (node.getNumaNodeStatistics() != null) {
                    dbNode.setNumaNodeStatistics(node.getNumaNodeStatistics());
                    vdsNumaNodesToSave.add(dbNode);
                }
            }
        }
    }
    if (!vdsNumaNodesToSave.isEmpty()) {
        getDbFacade().getVdsNumaNodeDao().massUpdateNumaNodeStatistics(vdsNumaNodesToSave);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
    if (updateAvailable) {
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLogDirector.log(auditLog, AuditLogType.HOST_UPDATES_ARE_AVAILABLE);
    }
}
#method_after
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
}
#end_block

#method_before
public void updateNumaData(final VDS vds) {
    if (vds.getNumaNodeList() == null || vds.getNumaNodeList().isEmpty()) {
        return;
    }
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = dbFacade.getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!numaNodesToRemove.isEmpty()) {
                dbFacade.getVdsNumaNodeDAO().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
            }
            if (!numaNodesToUpdate.isEmpty()) {
                dbFacade.getVdsNumaNodeDAO().massUpdateNumaNode(numaNodesToUpdate);
            }
            if (!numaNodesToSave.isEmpty()) {
                dbFacade.getVdsNumaNodeDAO().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
            }
            return null;
        }
    });
}
#method_after
public void updateNumaData(final VDS vds) {
    if (vds.getNumaNodeList() == null || vds.getNumaNodeList().isEmpty()) {
        return;
    }
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = dbFacade.getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!numaNodesToRemove.isEmpty()) {
                dbFacade.getVdsNumaNodeDao().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
            }
            if (!numaNodesToUpdate.isEmpty()) {
                dbFacade.getVdsNumaNodeDao().massUpdateNumaNode(numaNodesToUpdate);
            }
            if (!numaNodesToSave.isEmpty()) {
                dbFacade.getVdsNumaNodeDao().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
            }
            return null;
        }
    });
}
#end_block

#method_before
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = new AuditLogableBase(cachedVds.getId());
    logable.updateCallStackFromThrowable(ex);
    auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
}
#method_after
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = new AuditLogableBase(cachedVds.getId());
    logable.updateCallStackFromThrowable(ex);
    if (ex.getCause() instanceof java.net.UnknownHostException) {
        auditLogDirector.log(logable, AuditLogType.VDS_UNKNOWN_HOST);
    } else {
        auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
    if (updateAvailable) {
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLogDirector.log(auditLog, AuditLogType.HOST_UPDATES_ARE_AVAILABLE);
    }
}
#method_after
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
}
#end_block

#method_before
public void updateNumaData(final VDS vds) {
    if (vds.getNumaNodeList() == null || vds.getNumaNodeList().isEmpty()) {
        return;
    }
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = dbFacade.getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!numaNodesToRemove.isEmpty()) {
                dbFacade.getVdsNumaNodeDAO().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
            }
            if (!numaNodesToUpdate.isEmpty()) {
                dbFacade.getVdsNumaNodeDAO().massUpdateNumaNode(numaNodesToUpdate);
            }
            if (!numaNodesToSave.isEmpty()) {
                dbFacade.getVdsNumaNodeDAO().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
            }
            return null;
        }
    });
}
#method_after
public void updateNumaData(final VDS vds) {
    if (vds.getNumaNodeList() == null || vds.getNumaNodeList().isEmpty()) {
        return;
    }
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = dbFacade.getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!numaNodesToRemove.isEmpty()) {
                dbFacade.getVdsNumaNodeDao().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
            }
            if (!numaNodesToUpdate.isEmpty()) {
                dbFacade.getVdsNumaNodeDao().massUpdateNumaNode(numaNodesToUpdate);
            }
            if (!numaNodesToSave.isEmpty()) {
                dbFacade.getVdsNumaNodeDao().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
            }
            return null;
        }
    });
}
#end_block

#method_before
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = new AuditLogableBase(cachedVds.getId());
    logable.updateCallStackFromThrowable(ex);
    auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
}
#method_after
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = new AuditLogableBase(cachedVds.getId());
    logable.updateCallStackFromThrowable(ex);
    if (ex.getCause() instanceof java.net.UnknownHostException) {
        auditLogDirector.log(logable, AuditLogType.VDS_UNKNOWN_HOST);
    } else {
        auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
    }
}
#end_block

#method_before
@Override
public void startMonitoring() {
    super.startMonitoring();
    this.resourceManager.subscribe(new EventSubscriber(manager.getVdsHostname() + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                List<Pair<VM, VmInternalData>> changedVms = new ArrayList<>();
                List<Pair<VM, VmInternalData>> devicesChangedVms = new ArrayList<>();
                convertEvent(changedVms, devicesChangedVms, map);
                if (!changedVms.isEmpty() || !devicesChangedVms.isEmpty()) {
                    new VmsMonitoring(manager, changedVms, devicesChangedVms, auditLogDirector, System.nanoTime()).perform();
                }
            } finally {
                subscription.request(1);
            }
        }

        @SuppressWarnings("unchecked")
        private void convertEvent(List<Pair<VM, VmInternalData>> changedVms, List<Pair<VM, VmInternalData>> devicesChangedVms, Map<String, Object> map) {
            Double notifyTime = VdsBrokerObjectsBuilder.removeNotifyTimeFromVmStatusEvent(map);
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                Guid vmid = new Guid((String) entry.getKey());
                VM dbVm = dbFacade.getVmDao().get(vmid);
                if (dbVm == null) {
                    log.error("failed to fetch VM '{}' from db. Status remain unchanged", vmid);
                    return;
                }
                VmInternalData vdsmVm = createVmInternalData(dbVm, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                // and process once the migration is done
                if (dbVm.getRunOnVds() == null || dbVm.getRunOnVds().equals(manager.getVdsId()) || (!dbVm.getRunOnVds().equals(manager.getVdsId()) && vdsmVm.getVmDynamic().getStatus() == VMStatus.Up)) {
                    if (vdsmVm != null) {
                        changedVms.add(new Pair<>(dbVm, vdsmVm));
                    }
                    if (isDevicesChanged(dbVm, vdsmVm)) {
                        devicesChangedVms.add(new Pair<>(dbVm, vdsmVm));
                    }
                }
            }
        }

        private VmInternalData createVmInternalData(VM dbVm, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            return new VmInternalData(VdsBrokerObjectsBuilder.buildVmDynamicFromEvent(dbVm.getDynamicData(), xmlRpcStruct), dbVm.getStatisticsData(), notifyTime);
        }

        @Override
        public void onError(Throwable t) {
        }

        @Override
        public void onComplete() {
        }
    });
}
#method_after
@Override
public void startMonitoring() {
    super.startMonitoring();
    this.resourceManager.subscribe(new EventSubscriber(manager.getVdsHostname() + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                printEventInDebug(map);
                List<Pair<VM, VmInternalData>> changedVms = new ArrayList<>();
                List<Pair<VM, VmInternalData>> devicesChangedVms = new ArrayList<>();
                convertEvent(changedVms, devicesChangedVms, map);
                if (!changedVms.isEmpty() || !devicesChangedVms.isEmpty()) {
                    getVmsMonitoring(changedVms, devicesChangedVms).perform();
                }
            } finally {
                subscription.request(1);
            }
        }

        private void printEventInDebug(Map<String, Object> map) {
            if (!log.isDebugEnabled()) {
                return;
            }
            StringBuilder sb = new StringBuilder();
            XmlRpcObjectDescriptor.toStringBuilder(map, sb);
            log.debug("processing event for host {} data:\n{}", manager.getVdsName(), sb);
        }

        private VmsMonitoring getVmsMonitoring(List<Pair<VM, VmInternalData>> changedVms, List<Pair<VM, VmInternalData>> devicesChangedVms) {
            return new VmsMonitoring(manager, changedVms, devicesChangedVms, auditLogDirector, System.nanoTime());
        }

        @SuppressWarnings("unchecked")
        private void convertEvent(List<Pair<VM, VmInternalData>> changedVms, List<Pair<VM, VmInternalData>> devicesChangedVms, Map<String, Object> map) {
            Double notifyTime = VdsBrokerObjectsBuilder.removeNotifyTimeFromVmStatusEvent(map);
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                Guid vmid = new Guid((String) entry.getKey());
                VM dbVm = dbFacade.getVmDao().get(vmid);
                VmInternalData vdsmVm;
                if (dbVm == null) {
                    vdsmVm = createVmInternalData(vmid, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                } else {
                    vdsmVm = createVmInternalData(dbVm, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                    // if dbVm runs on different host, monitoring expect it to be null
                    if (!manager.getVdsId().equals(dbVm.getRunOnVds())) {
                        dbVm = null;
                    }
                }
                changedVms.add(new Pair<>(dbVm, vdsmVm));
                if (isDevicesChanged(dbVm, vdsmVm)) {
                    devicesChangedVms.add(new Pair<>(dbVm, vdsmVm));
                }
            }
        }

        private VmInternalData createVmInternalData(Guid vmId, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            VM fakeVm = new VM();
            fakeVm.setId(vmId);
            return createVmInternalData(fakeVm, xmlRpcStruct, notifyTime);
        }

        private VmInternalData createVmInternalData(VM dbVm, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            return new VmInternalData(VdsBrokerObjectsBuilder.buildVmDynamicFromEvent(dbVm.getDynamicData(), xmlRpcStruct), dbVm.getStatisticsData(), notifyTime);
        }

        @Override
        public void onError(Throwable t) {
        }

        @Override
        public void onComplete() {
        }
    });
}
#end_block

#method_before
@Override
@OnTimerMethodAnnotation("perform")
public void perform() {
    // we still want to fetch GetAllVmStats as we did before
    if (this.manager.isMonitoringNeeded() && getRefreshStatistics()) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(this.manager);
        long fetchTime = System.nanoTime();
        fetcher.fetch();
        new VmsMonitoring(this.manager, fetcher.getChangedVms(), fetcher.getVmsWithChangedDevices(), this.auditLogDirector, fetchTime).perform();
    }
    updateIteration();
}
#method_after
@Override
@OnTimerMethodAnnotation("perform")
public void perform() {
    // we still want to fetch GetAllVmStats as we did before
    if (this.manager.isMonitoringNeeded() && getRefreshStatistics()) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(this.manager);
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            new VmsMonitoring(this.manager, fetcher.getChangedVms(), fetcher.getVmsWithChangedDevices(), this.auditLogDirector, fetchTime, true).perform();
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", manager.getVdsName());
        }
    }
    updateIteration();
}
#end_block

#method_before
@Override
@OnTimerMethodAnnotation("perform")
public void perform() {
    if (manager.isMonitoringNeeded()) {
        VmsListFetcher fetcher = getRefreshStatistics() ? new VmsStatisticsFetcher(manager) : new VmsListFetcher(manager);
        long fetchTime = System.nanoTime();
        fetcher.fetch();
        new VmsMonitoring(manager, fetcher.getChangedVms(), fetcher.getVmsWithChangedDevices(), auditLogDirector, fetchTime).perform();
    }
    updateIteration();
}
#method_after
@Override
@OnTimerMethodAnnotation("perform")
public void perform() {
    if (manager.isMonitoringNeeded()) {
        VmsListFetcher fetcher = getRefreshStatistics() ? new VmsStatisticsFetcher(manager) : new VmsListFetcher(manager);
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            getVmsMonitoring(fetcher, fetchTime).perform();
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", manager.getVdsName());
        }
    }
    updateIteration();
}
#end_block

#method_before
protected void updateIteration() {
    refreshIteration = refreshIteration++ % NUMBER_VMS_REFRESHES_BEFORE_SAVE;
}
#method_after
protected void updateIteration() {
    refreshIteration = (++refreshIteration) % NUMBER_VMS_REFRESHES_BEFORE_SAVE;
}
#end_block

#method_before
private static void loadExtensions(ModuleService moduleService, Map<String, Object> argMap) {
    ExtensionsManager extensionsManager = new ExtensionsManager();
    extensionsManager.getGlobalContext().put(Base.GlobalContextKeys.APPLICATION_NAME, Base.ApplicationNames.OVIRT_ENGINE_EXTENSIONS_TOOL);
    moduleService.getContext().put(ModuleService.EXTENSION_MANAGER, extensionsManager);
    List<File> files = (List<File>) argMap.get("extension-file");
    if (files == null) {
        files = listFiles(((String) argMap.get("extensions-dir")), "properties");
    }
    List<String> loadedExtensions = new LinkedList<>();
    for (File f : files) {
        log.debug("Loading extension file '{}'", f.getName());
        try {
            loadedExtensions.add(extensionsManager.load(f));
        } catch (Exception ex) {
            log.error("Can't load extension '{}', ignoring.", f.getName());
            log.debug("Exception:", ex);
        }
    }
    for (String extension : loadedExtensions) {
        extensionsManager.initialize(extension);
        log.debug("Extension '{}' initialized", extension);
    }
    extensionsManager.dump();
}
#method_after
private static void loadExtensions(ModuleService moduleService, Map<String, Object> argMap) {
    ExtensionsManager extensionsManager = new ExtensionsManager();
    extensionsManager.getGlobalContext().put(Base.GlobalContextKeys.APPLICATION_NAME, Base.ApplicationNames.OVIRT_ENGINE_EXTENSIONS_TOOL);
    moduleService.getContext().put(ModuleService.EXTENSION_MANAGER, extensionsManager);
    List<File> files = (List<File>) argMap.get("extension-file");
    if (files == null) {
        files = listFiles(((String) argMap.get("extensions-dir")), "properties");
    }
    List<String> loadedExtensions = new LinkedList<>();
    for (File f : files) {
        log.debug("Loading extension file '{}'", f.getName());
        try {
            loadedExtensions.add(extensionsManager.load(f));
        } catch (Exception ex) {
            log.error("Extension '{}' load failed (ignored): {}", f.getName(), ex.getMessage());
            log.debug("Exception:", ex);
        }
    }
    for (String extension : loadedExtensions) {
        try {
            extensionsManager.initialize(extension);
            log.debug("Extension '{}' initialized", extension);
        } catch (Exception ex) {
            log.error("Extension '{}' initialization failed (ignored): {}", extension, ex.getMessage());
            log.debug("Exception:", ex);
        }
    }
    extensionsManager.dump();
}
#end_block

#method_before
private static Map<String, ModuleService> loadModules(Class cls) {
    Map<String, ModuleService> modules = new HashMap<>();
    if (cls != null) {
        Map<String, ExtensionProxy> proxies = new HashMap<>();
        ExtMap context = new ExtMap().mput(ModuleService.PROGRAM_NAME, PROGRAM_NAME);
        ServiceLoader<ModuleService> loader = ServiceLoader.load(cls);
        for (ModuleService module : loader) {
            modules.put(module.getName(), module);
            module.setContext(context);
        }
    }
    log.debug("Loaded modules: {}", modules.keySet());
    return modules;
}
#method_after
private static Map<String, ModuleService> loadModules(Class cls) {
    Map<String, ModuleService> modules = new HashMap<>();
    if (cls != null) {
        ExtMap context = new ExtMap().mput(ModuleService.PROGRAM_NAME, PROGRAM_NAME);
        ServiceLoader<ModuleService> loader = ServiceLoader.load(cls);
        for (ModuleService module : loader) {
            modules.put(module.getName(), module);
            module.setContext(context);
        }
    }
    log.debug("Loaded modules: {}", modules.keySet());
    return modules;
}
#end_block

#method_before
public void testEcho(String message) throws InterruptedException, ExecutionException, ClientConnectionException, IllegalAccessException {
    final BlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(5);
    Future<ReactorListener> futureListener = this.listeningReactor.createListener(HOSTNAME, 0, new EventListener() {

        @Override
        public void onAcccept(final ReactorClient client) {
            client.addEventListener(new MessageListener() {

                @Override
                public void onMessageReceived(byte[] message) {
                    try {
                        client.sendMessage(message);
                    } catch (ClientConnectionException e) {
                        fail();
                    }
                }
            });
        }
    });
    ReactorListener listener = futureListener.get();
    assertNotNull(listener);
    CertCallbackImpl certCallback = new CertCallbackImpl();
    ReactorClient client = this.sendingReactor.createClient(HOSTNAME, listener.getPort(), certCallback);
    client.setClientPolicy(new StompClientPolicy(180000, 0, 1000000, DEFAULT_REQUEST_QUEUE, DEFAULT_RESPONSE_QUEUE));
    client.addEventListener(new ReactorClient.MessageListener() {

        @Override
        public void onMessageReceived(byte[] message) {
            queue.add(message);
        }
    });
    client.connect();
    client.sendMessage(message.getBytes());
    byte[] response = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    assertNotNull(response);
    assertEquals(message, new String(response, UTF8));
    client.sendMessage(message.getBytes());
    response = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    SSLClient.Context context = certCallback.getContext();
    assertNotNull(context);
    List<Certificate> peerCertificates = context.getPeerCertificates();
    assertNotNull(peerCertificates);
    assertFalse(peerCertificates.isEmpty());
    assertNotNull(context.getAttribute(PEER_CERTIFICATES));
    client.close();
    listener.close();
    assertNotNull(response);
    assertEquals(message, new String(response, UTF8));
}
#method_after
public void testEcho(String message) throws InterruptedException, ExecutionException, ClientConnectionException, IllegalAccessException {
    final BlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(5);
    Future<ReactorListener> futureListener = this.listeningReactor.createListener(HOSTNAME, 0, new EventListener() {

        @Override
        public void onAcccept(final ReactorClient client) {
            client.addEventListener(new MessageListener() {

                @Override
                public void onMessageReceived(byte[] message) {
                    try {
                        client.sendMessage(message);
                    } catch (ClientConnectionException e) {
                        fail();
                    }
                }
            });
        }
    });
    ReactorListener listener = futureListener.get();
    assertNotNull(listener);
    ReactorClient client = this.sendingReactor.createClient(HOSTNAME, listener.getPort());
    client.setClientPolicy(new StompClientPolicy(180000, 0, 1000000, DEFAULT_REQUEST_QUEUE, DEFAULT_RESPONSE_QUEUE));
    client.addEventListener(new ReactorClient.MessageListener() {

        @Override
        public void onMessageReceived(byte[] message) {
            queue.add(message);
        }
    });
    client.connect();
    client.sendMessage(message.getBytes());
    byte[] response = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    assertNotNull(response);
    assertEquals(message, new String(response, UTF8));
    client.sendMessage(message.getBytes());
    response = queue.poll(TIMEOUT_SEC, TimeUnit.SECONDS);
    List<Certificate> peerCertificates = client.getPeerCertificates();
    assertNotNull(peerCertificates);
    assertFalse(peerCertificates.isEmpty());
    client.close();
    listener.close();
    assertNotNull(response);
    assertEquals(message, new String(response, UTF8));
}
#end_block

#method_before
private Runnable pendingOperations() throws IOException, ClientConnectionException {
    if (this.nioEngine == null) {
        return null;
    }
    if (this.certCallback != null) {
        this.certCallback.registerSslSession(this.nioEngine.getSSLEngine().getSession());
    }
    return nioEngine.process();
}
#method_after
private Runnable pendingOperations() throws IOException, ClientConnectionException {
    if (this.nioEngine == null) {
        return null;
    }
    return nioEngine.process();
}
#end_block

#method_before
private static ImageResource getPoolVmImageResource(VmType vmType, boolean nextRunConfigurationExists) {
    switch(vmType) {
        case Desktop:
            return nextRunConfigurationExists ? resources.manyDesktopsChangesImage() : resources.manyDesktopsImage();
        case Server:
            return nextRunConfigurationExists ? resources.manyServersChangesImage() : resources.manyServersImage();
        default:
            return null;
    }
}
#method_after
private static ImageResource getPoolVmImageResource(VmType vmType, boolean nextRunConfigurationExists) {
    switch(vmType) {
        case Server:
            return nextRunConfigurationExists ? resources.manyServersChangesImage() : resources.manyServersImage();
        case Desktop:
        default:
            return nextRunConfigurationExists ? resources.manyDesktopsChangesImage() : resources.manyDesktopsImage();
    }
}
#end_block

#method_before
public static boolean isPublicKeyValid(String publicKey) {
    String[] words = publicKey.split("\\s+", 3);
    if (words.length != 3) {
        return false;
    }
    if (!words[0].matches("^[\\p{Alpha}\\p{Digit}-]*$")) {
        return false;
    }
    if (!Base64.isArrayByteBase64(words[1].getBytes())) {
        return false;
    }
    return true;
}
#method_after
public static boolean isPublicKeyValid(String publicKey) {
    /*
         * An OpenSSH public key consists of:
         * [mandatory] The key type
         * [mandatory] A chunk of PEM-encoded data (PEM is a specific type of Base64 encoding)
         * [optional] A comment
         */
    String[] words = publicKey.split("\\s+", 3);
    if (words.length < 2) {
        return false;
    }
    /*
         * As per http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html
         * these character class are US-ASCII only.
         */
    if (!words[0].matches("^[\\p{Alpha}\\p{Digit}-]*$")) {
        return false;
    }
    if (!isBase64(words[1].getBytes())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    String sshPublicKey = getParameters().getUserProfile().getSshPublicKey();
    if (sshPublicKey == null || sshPublicKey.isEmpty()) {
        // the user wants to wipe out its own key, and we're fine with that.
        return true;
    }
    // else it is either a new or replacement key. In both cases, must be a valid key.
    if (!OpenSSHUtils.isPublicKeyValid(sshPublicKey)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_PUBLIC_SSH_KEY);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    String sshPublicKey = getParameters().getUserProfile().getSshPublicKey();
    if (sshPublicKey == null || sshPublicKey.isEmpty()) {
        // the user wants to wipe out its own key, and we're fine with that.
        return true;
    }
    // else it is either a new or replacement key. In both cases, must be a valid key.
    if (!OpenSSHUtils.isPublicKeyValid(sshPublicKey)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INVALID_PUBLIC_SSH_KEY);
    }
    return true;
}
#end_block

#method_before
public VM chooseNextVmToMigrate() {
    List<AffinityGroup> allAffinityGroups = getAllAffinityGroups();
    Set<Set<Guid>> unifiedPositiveAffinityGroups = getUnifiedPositiveAffinityGroups(allAffinityGroups);
    List<AffinityGroup> unifiedAffinityGroups = setsToAffinityGroups(unifiedPositiveAffinityGroups);
    // Add negative affinity groups
    for (AffinityGroup ag : allAffinityGroups) {
        if (ag.isPositive()) {
            continue;
        }
        unifiedAffinityGroups.add(ag);
    }
    // Create a set of all VMs in affinity groups
    Set<Guid> allVms = new HashSet<>();
    for (AffinityGroup group : unifiedAffinityGroups) {
        allVms.addAll(group.getEntityIds());
    }
    Map<Guid, Guid> vmToHost = new HashMap<>();
    // There is no need to migrate when no collision was detected
    Set<AffinityGroup> violatedAffinityGroups = checkForAffinityGroupViolations(unifiedAffinityGroups, vmToHost, FailMode.GET_ALL);
    if (violatedAffinityGroups.isEmpty()) {
        log.debug("No affinity group collision detected for cluster {}. Standing by.", clusterId);
        return null;
    }
    // Find a VM that is breaking the affinityGroup and can be theoretically migrated
    // - start with smaller Affinity Groups
    List<AffinityGroup> affGroupsBySize = new ArrayList<>(violatedAffinityGroups);
    Collections.sort(affGroupsBySize, new AffinityGroupComparator());
    for (AffinityGroup affinityGroup : affGroupsBySize) {
        Guid candidateVm;
        if (affinityGroup.isPositive()) {
            candidateVm = findVmViolatingPositiveAg(affinityGroup, vmToHost);
            log.info("Positive affinity group violation detected for VM {}", candidateVm);
        } else {
            candidateVm = findVmViolatingNegativeAg(affinityGroup, vmToHost);
            log.info("Negative affinity group violation detected for VM {}", candidateVm);
        }
        // No candidate found
        if (candidateVm == null) {
            continue;
        }
        // Test whether any migration is possible, this uses current AffinityGroup settings
        // and so won't allow more breakage
        VM vm = vmDao.get(candidateVm);
        VDSGroup cluster = vdsGroupDao.get(clusterId);
        boolean canMove = schedulingManager.canSchedule(cluster, vm, new ArrayList<Guid>(), new ArrayList<Guid>(), null, new ArrayList<String>());
        if (canMove) {
            log.debug("VM {} is a viable candidate for solving affinity group violation situation.", candidateVm);
            lastMigrations.add(new MigrationEntryDS(candidateVm, vmToHost.get(candidateVm)));
            return vm;
        }
        log.debug("VM {} is NOT a viable candidate for solving affinity group violation situation.", candidateVm);
    }
    // No possible migration..
    return null;
}
#method_after
public VM chooseNextVmToMigrate() {
    List<AffinityGroup> allAffinityGroups = getAllAffinityGroups();
    Set<Set<Guid>> unifiedPositiveAffinityGroups = AffinityRulesUtils.getUnifiedPositiveAffinityGroups(allAffinityGroups);
    List<AffinityGroup> unifiedAffinityGroups = AffinityRulesUtils.setsToAffinityGroups(unifiedPositiveAffinityGroups);
    // Add negative affinity groups
    for (AffinityGroup ag : allAffinityGroups) {
        if (ag.isPositive()) {
            continue;
        }
        unifiedAffinityGroups.add(ag);
    }
    // Create a set of all VMs in affinity groups
    Set<Guid> allVms = new HashSet<>();
    for (AffinityGroup group : unifiedAffinityGroups) {
        allVms.addAll(group.getEntityIds());
    }
    Map<Guid, Guid> vmToHost = createMapOfVmToHost(allVms);
    // There is no need to migrate when no collision was detected
    Set<AffinityGroup> violatedAffinityGroups = checkForAffinityGroupViolations(unifiedAffinityGroups, vmToHost, FailMode.GET_ALL);
    if (violatedAffinityGroups.isEmpty()) {
        log.debug("No affinity group collision detected for cluster {}. Standing by.", clusterId);
        return null;
    }
    // Find a VM that is breaking the affinityGroup and can be theoretically migrated
    // - start with smaller Affinity Groups
    List<AffinityGroup> affGroupsBySize = new ArrayList<>(violatedAffinityGroups);
    Collections.sort(affGroupsBySize, new AffinityGroupComparator());
    for (AffinityGroup affinityGroup : affGroupsBySize) {
        Guid candidateVm;
        if (affinityGroup.isPositive()) {
            candidateVm = findVmViolatingPositiveAg(affinityGroup, vmToHost);
            log.info("Positive affinity group violation detected for VM {}", candidateVm);
        } else {
            candidateVm = findVmViolatingNegativeAg(affinityGroup, vmToHost);
            log.info("Negative affinity group violation detected for VM {}", candidateVm);
        }
        // No candidate found
        if (candidateVm == null) {
            continue;
        }
        // Test whether any migration is possible, this uses current AffinityGroup settings
        // and so won't allow more breakage
        VM vm = vmDao.get(candidateVm);
        VDSGroup cluster = vdsGroupDao.get(clusterId);
        boolean canMove = schedulingManager.canSchedule(cluster, vm, new ArrayList<Guid>(), new ArrayList<Guid>(), null, new ArrayList<String>());
        if (canMove) {
            log.debug("VM {} is a viable candidate for solving affinity group violation situation.", candidateVm);
            lastMigrations.add(new MigrationEntryDS(candidateVm, vmToHost.get(candidateVm)));
            return vm;
        }
        log.debug("VM {} is NOT a viable candidate for solving affinity group violation situation.", candidateVm);
    }
    // No possible migration..
    return null;
}
#end_block

#method_before
private Guid findVmViolatingNegativeAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) {
    Map<Guid, Guid> firstAssignment = new HashMap<>();
    Set<Guid> violatingVms = new HashSet<>();
    // the vm and the previous occupant as candidates for migration
    for (Guid vm : affinityGroup.getEntityIds()) {
        Guid host = vmToHost.get(vm);
        if (firstAssignment.containsKey(host)) {
            violatingVms.add(vm);
            violatingVms.add(firstAssignment.get(host));
        } else {
            firstAssignment.put(host, vm);
        }
    }
    List<Guid> violatingVmsArray = new ArrayList<>(violatingVms);
    // Select random VM from the selected host
    int index = new Random().nextInt(violatingVmsArray.size());
    return violatingVmsArray.get(index);
}
#method_after
private Guid findVmViolatingNegativeAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) {
    Map<Guid, Guid> firstAssignment = new HashMap<>();
    Set<Guid> violatingVms = new HashSet<>();
    // the vm and the previous occupant as candidates for migration
    for (Guid vm : affinityGroup.getEntityIds()) {
        Guid host = vmToHost.get(vm);
        // Ignore stopped VMs
        if (host == null) {
            continue;
        }
        if (firstAssignment.containsKey(host)) {
            violatingVms.add(vm);
            violatingVms.add(firstAssignment.get(host));
        } else {
            firstAssignment.put(host, vm);
        }
    }
    List<Guid> violatingVmsArray = new ArrayList<>(violatingVms);
    // Select random VM from the selected host
    int index = new Random().nextInt(violatingVmsArray.size());
    return violatingVmsArray.get(index);
}
#end_block

#method_before
private Guid findVmViolatingPositiveAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) {
    Map<Guid, List<Guid>> hostCount = new HashMap<>();
    // Prepare affinity group related host counts
    for (Guid vm : affinityGroup.getEntityIds()) {
        Guid host = vmToHost.get(vm);
        if (hostCount.containsKey(host)) {
            hostCount.get(host).add(vm);
        } else {
            hostCount.put(host, new ArrayList<Guid>());
            hostCount.get(host).add(vm);
        }
    }
    // Select the host with the least amount of VMs
    Guid host = chooseCandidateHostForMigration(hostCount);
    if (host == null) {
        return null;
    }
    // Select random VM from the selected host
    int index = new Random().nextInt(hostCount.get(host).size());
    return hostCount.get(host).get(index);
}
#method_after
private Guid findVmViolatingPositiveAg(AffinityGroup affinityGroup, Map<Guid, Guid> vmToHost) {
    Map<Guid, List<Guid>> hostCount = new HashMap<>();
    // Prepare affinity group related host counts
    for (Guid vm : affinityGroup.getEntityIds()) {
        Guid host = vmToHost.get(vm);
        // Ignore stopped VMs
        if (host == null) {
            continue;
        }
        if (hostCount.containsKey(host)) {
            hostCount.get(host).add(vm);
        } else {
            hostCount.put(host, new ArrayList<Guid>());
            hostCount.get(host).add(vm);
        }
    }
    // Select the host with the least amount of VMs
    Guid host = chooseCandidateHostForMigration(hostCount);
    if (host == null) {
        return null;
    }
    // Select random VM from the selected host
    int index = new Random().nextInt(hostCount.get(host).size());
    return hostCount.get(host).get(index);
}
#end_block

#method_before
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
        if (pair.getFirst().isHotsetAllowed()) {
            mUpdateVmsStatic.AddHotsetFields(pair.getSecond().getName());
        }
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#method_after
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
        if (pair.getFirst().isHotsetAllowed()) {
            mUpdateVmsStatic.AddHotsetFields(pair.getSecond().getName());
        }
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.UpdateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.RemoveVm);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    createSnapshotsForDisks();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    createSnapshotsForDisks();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#end_block

#method_before
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setParentHasTasks(!cachedImagesDisks.isEmpty());
    return withRootCommandInfo(createParams, getActionType());
}
#method_after
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setParentHasTasks(!cachedImagesDisks.isEmpty() || getMemoryImageBuilder().isCreateTasks());
    return withRootCommandInfo(createParams, getActionType());
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    if (CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size() > 1) {
        log.info("There are still running CoCo tasks");
        return;
    }
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    if (CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size() > 1) {
        log.info("There are still running CoCo tasks");
        return;
    }
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    thawVm();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
private void handleVdsLiveSnapshotFailure(EngineException e) {
    log.warn("Could not perform live snapshot due to error, VM will still be configured to the new created" + " snapshot: {}", e.getMessage());
    log.debug("Exception", e);
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    auditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#method_after
private void handleVdsLiveSnapshotFailure(EngineException e) {
    handleVmFailure(e, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, "Could not perform live snapshot due to error, VM will still be configured to the new created" + " snapshot: {}");
}
#end_block

#method_before
public ValidationResult validateAddProvider() {
    if (getStoragePool() != null) {
        return validateAttachStorageDomain();
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateAddProvider() {
    ValidationResult cinderValidation = isCinderAlreadyExists();
    if (!cinderValidation.isValid()) {
        return cinderValidation;
    }
    if (getStoragePool() != null) {
        return validateAttachStorageDomain();
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@OnTimerMethodAnnotation("refresh")
public void refresh() {
    log.debug("Affinity Rules Enforcement Manager interval reached.");
    if (AreClusterIterator == null || !AreClusterIterator.hasNext()) {
        AreClusterIterator = perClusterMap.values().iterator();
    }
    AffinityRulesEnforcementPerCluster perCluster;
    while (true) {
        if (!AreClusterIterator.hasNext()) {
            return;
        }
        perCluster = AreClusterIterator.next();
        log.debug("Checking affinity rules compliance for cluster {}", perCluster.getClusterId());
        if (perCluster.checkIfCurrentlyMigrating()) {
            currentInterval = getRegularInterval();
            log.debug("Migration in progress, checking different cluster.");
            continue;
        }
        break;
    }
    // Current migration complete.
    if (perCluster.lastMigrationFailed()) {
        perCluster.updateMigrationFailure();
    }
    if (perCluster.getMigrationTries() >= getMaximumMigrationTries()) {
        currentInterval = getStandbyInterval();
        perCluster.setMigrationTries(0);
        return;
    } else if (currentInterval > getRegularInterval()) {
        currentInterval = getRegularInterval();
        perCluster.setMigrationTries(0);
    }
    VM vm;
    vm = perCluster.chooseNextVmToMigrate();
    // No action for the current cluster, check if other clusters are OK
    while (vm == null && AreClusterIterator.hasNext()) {
        perCluster = AreClusterIterator.next();
        if (perCluster.checkIfCurrentlyMigrating()) {
            log.debug("Migration in progress, checking different cluster.");
            continue;
        }
        vm = perCluster.chooseNextVmToMigrate();
    }
    // All affinity groups are enforced lowering the wake-up frequency
    if (vm == null) {
        currentInterval = getStandbyInterval();
        return;
    }
    // Affinity Group fix needed, initiate the migration
    Guid vmToMigrate = vm.getId();
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
    parameters.setInitialHosts(new ArrayList<>(getInitialHosts()));
    VdcReturnValueBase migrationStatus = Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
    perCluster.updateMigrationStatus(migrationStatus);
    currentInterval = getRegularInterval();
}
#method_after
@OnTimerMethodAnnotation("refresh")
public void refresh() {
    log.debug("Affinity Rules Enforcement Manager interval reached.");
    if (AreClusterIterator == null || !AreClusterIterator.hasNext()) {
        AreClusterIterator = perClusterMap.values().iterator();
    }
    AffinityRulesEnforcementPerCluster perCluster;
    while (true) {
        if (!AreClusterIterator.hasNext()) {
            return;
        }
        perCluster = AreClusterIterator.next();
        log.debug("Checking affinity rules compliance for cluster {}", perCluster.getClusterId());
        if (perCluster.checkIfCurrentlyMigrating()) {
            currentInterval = getRegularInterval();
            log.debug("Migration in progress, checking different cluster.");
            continue;
        }
        break;
    }
    // Current migration complete.
    if (perCluster.lastMigrationFailed()) {
        perCluster.updateMigrationFailure();
    }
    if (perCluster.getMigrationTries() >= getMaximumMigrationTries()) {
        currentInterval = getStandbyInterval();
        perCluster.setMigrationTries(0);
        return;
    } else if (currentInterval > getRegularInterval()) {
        currentInterval = getRegularInterval();
        perCluster.setMigrationTries(0);
    }
    VM vm;
    vm = perCluster.chooseNextVmToMigrate();
    // No action for the current cluster, check if other clusters are OK
    while (vm == null && AreClusterIterator.hasNext()) {
        perCluster = AreClusterIterator.next();
        if (perCluster.checkIfCurrentlyMigrating()) {
            log.debug("Migration in progress, checking different cluster.");
            continue;
        }
        vm = perCluster.chooseNextVmToMigrate();
    }
    // All affinity groups are enforced lowering the wake-up frequency
    if (vm == null) {
        currentInterval = getStandbyInterval();
        return;
    }
    // Affinity Group fix needed, initiate the migration
    Guid vmToMigrate = vm.getId();
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
    parameters.setInitialHosts(new ArrayList<>(getInitialHosts()));
    VdcReturnValueBase migrationStatus = executeMigration(parameters);
    perCluster.updateMigrationStatus(migrationStatus);
    currentInterval = getRegularInterval();
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setVdsGroupId(parameterMasterVm.getVdsGroupId());
        // API backward compatibility
        if (parameters.isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(parameterMasterVm.getVmType() == VmType.Desktop);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        mImages.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getVdsGroup() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setVdsGroupCompatibilityVersion(getVdsGroup().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getVdsGroup().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setVdsGroupId(parameterMasterVm.getVdsGroupId());
        // API backward compatibility
        if (parameters.isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(parameterMasterVm.getVmType() == VmType.Desktop);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getVdsGroup(), getParameters().getGraphicsDevices());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        mImages.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getVdsGroup() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setVdsGroupCompatibilityVersion(getVdsGroup().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getVdsGroup().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    switch(getVm().getStatus()) {
        case Unassigned:
        case Down:
        case ImageIllegal:
        case ImageLocked:
            break;
        case Suspended:
            return failCanDoAction(EngineMessage.VM_CANNOT_REMOVE_VM_WHEN_STATUS_IS_NOT_DOWN);
        default:
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    if (getVm().getVmPoolId() != null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    // enable to remove vms without images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    if (!validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    Collection<Disk> vmDisks = getVm().getDiskMap().values();
    List<DiskImage> vmImages = ImagesHandler.filterImageDisks(vmDisks, true, false, true);
    vmImages.addAll(ImagesHandler.filterDisksBasedOnCinder(vmDisks));
    if (!vmImages.isEmpty()) {
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
        if (!getParameters().getForce() && !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    // Handle VM status with ImageLocked
    VmValidator vmValidator = new VmValidator(getVm());
    ValidationResult vmLockedValidatorResult = vmValidator.vmNotLocked();
    if (!vmLockedValidatorResult.isValid()) {
        // without force remove, we can't remove the VM
        if (!getParameters().getForce()) {
            return failCanDoAction(vmLockedValidatorResult.getMessage());
        }
        // If it is force, we cannot remove if there are task
        if (CommandCoordinatorUtil.hasTasksByStoragePoolId(getVm().getStoragePoolId())) {
            return failCanDoAction(EngineMessage.VM_CANNOT_REMOVE_HAS_RUNNING_TASKS);
        }
    }
    if (getParameters().isRemoveDisks() && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    switch(getVm().getStatus()) {
        case Unassigned:
        case Down:
        case ImageIllegal:
        case ImageLocked:
            break;
        case Suspended:
            return failCanDoAction(EngineMessage.VM_CANNOT_REMOVE_VM_WHEN_STATUS_IS_NOT_DOWN);
        default:
            return (getVm().isHostedEngine() && isInternalExecution()) || failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    if (getVm().getVmPoolId() != null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    // enable to remove vms without images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    if (!validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    Collection<Disk> vmDisks = getVm().getDiskMap().values();
    List<DiskImage> vmImages = ImagesHandler.filterImageDisks(vmDisks, true, false, true);
    vmImages.addAll(ImagesHandler.filterDisksBasedOnCinder(vmDisks));
    if (!vmImages.isEmpty()) {
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
        if (!getParameters().getForce() && !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    // Handle VM status with ImageLocked
    VmValidator vmValidator = new VmValidator(getVm());
    ValidationResult vmLockedValidatorResult = vmValidator.vmNotLocked();
    if (!vmLockedValidatorResult.isValid()) {
        // without force remove, we can't remove the VM
        if (!getParameters().getForce()) {
            return failCanDoAction(vmLockedValidatorResult.getMessage());
        }
        // If it is force, we cannot remove if there are task
        if (CommandCoordinatorUtil.hasTasksByStoragePoolId(getVm().getStoragePoolId())) {
            return failCanDoAction(EngineMessage.VM_CANNOT_REMOVE_HAS_RUNNING_TASKS);
        }
    }
    if (getParameters().isRemoveDisks() && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Before
public void setup() {
    initVdsGroup();
    initMocks();
    arem = new AffinityRulesEnforcementManager() {

        @Override
        public void wakeup() {
            this.auditLogDirector = _auditLogDirector;
            this.vdsDao = _vdsDao;
            this.vdsGroupDao = _vdsGroupDao;
            doReturn(new TestingAffinityRulesEnforcementPerCluster()).when(_perClusterProvider).get();
            this.perClusterProvider = _perClusterProvider;
            super.wakeup();
            addInjectionsToPerClusterObjects();
        }

        @Override
        public void refresh() {
            addInjectionsToPerClusterObjects();
            super.refresh();
        }

        private void addInjectionsToPerClusterObjects() {
            // Adding affinity group dao to all perCluster objects in the maps.
            for (Entry<VDSGroup, AffinityRulesEnforcementPerCluster> entry : arem.perClusterMap.entrySet()) {
                AffinityRulesEnforcementPerCluster perCluster = perClusterProvider.get();
                perCluster.setClusterId(entry.getKey().getId());
                entry.setValue(perCluster);
            }
        }

        @Override
        protected List<VDSGroup> getClusters() {
            List<VDSGroup> vdsGroups = new ArrayList<>();
            vdsGroups.add(cluster);
            return vdsGroups;
        }
    };
    arem.wakeup();
    arem.refresh();
    for (AffinityRulesEnforcementPerCluster perCluster : arem.perClusterMap.values()) {
        perCluster.wakeup();
    }
}
#method_after
@Before
public void setup() {
    initVdsGroup();
    initMocks();
    arem = new AffinityRulesEnforcementManager() {

        @Override
        public void wakeup() {
            this.auditLogDirector = _auditLogDirector;
            this.vdsDao = _vdsDao;
            this.vdsGroupDao = _vdsGroupDao;
            doReturn(new TestingAffinityRulesEnforcementPerCluster()).when(_perClusterProvider).get();
            this.perClusterProvider = _perClusterProvider;
            super.wakeup();
            addInjectionsToPerClusterObjects();
        }

        @Override
        public void refresh() {
            addInjectionsToPerClusterObjects();
            super.refresh();
        }

        private void addInjectionsToPerClusterObjects() {
            // Adding affinity group dao to all perCluster objects in the maps.
            for (Entry<VDSGroup, AffinityRulesEnforcementPerCluster> entry : arem.perClusterMap.entrySet()) {
                AffinityRulesEnforcementPerCluster perCluster = perClusterProvider.get();
                perCluster.setClusterId(entry.getKey().getId());
                perCluster.setSchedulingManager(schedulingManager);
                entry.setValue(perCluster);
            }
        }

        @Override
        protected List<VDSGroup> getClusters() {
            List<VDSGroup> vdsGroups = new ArrayList<>();
            vdsGroups.add(cluster);
            return vdsGroups;
        }

        @Override
        protected VdcReturnValueBase executeMigration(MigrateVmParameters parameters) {
            return null;
        }
    };
    arem.wakeup();
    arem.refresh();
    for (AffinityRulesEnforcementPerCluster perCluster : arem.perClusterMap.values()) {
        perCluster.wakeup();
    }
}
#end_block

#method_before
protected void initMocks() {
    injectorRule.bind(SchedulerUtilQuartzImpl.class, scheduler);
    when(scheduler.scheduleAFixedDelayJob(any(), anyString(), any(Class[].class), any(Object[].class), anyLong(), anyLong(), any(TimeUnit.class))).thenReturn("jobId");
}
#method_after
protected void initMocks() {
    injectorRule.bind(SchedulerUtilQuartzImpl.class, scheduler);
    when(scheduler.scheduleAFixedDelayJob(any(), anyString(), any(Class[].class), any(Object[].class), anyLong(), anyLong(), any(TimeUnit.class))).thenReturn("jobId");
    when(schedulingManager.canSchedule(any(VDSGroup.class), any(VM.class), anyListOf(Guid.class), anyListOf(Guid.class), anyListOf(Guid.class), anyListOf(String.class))).thenReturn(true);
}
#end_block

#method_before
@Test
public void testAddPending() throws Exception {
    PendingResourceManager manager = new PendingResourceManager();
    VDS host = new VDS();
    host.setId(Guid.newGuid());
    VM vm1 = new VM();
    vm1.setId(Guid.newGuid());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    manager.addPending(new PendingVM(host, vm1));
    manager.addPending(new PendingMemory(host, vm1, 768));
    manager.addPending(new PendingCpuCores(host, vm1, 1));
    manager.addPending(new PendingVM(host, vm2));
    manager.addPending(new PendingMemory(host, vm2, 1024));
    manager.addPending(new PendingCpuCores(host, vm2, 10));
    Set<Guid> pending = PendingVM.collectForHost(manager, host.getId());
    assertEquals(2, pending.size());
    assertEquals(11, PendingCpuCores.collectForHost(manager, host.getId()));
    assertEquals(1024 + 768, PendingMemory.collectForHost(manager, host.getId()));
}
#method_after
@Test
public void testAddPending() throws Exception {
    PendingResourceManager manager = new PendingResourceManager();
    VDS host = new VDS();
    host.setId(Guid.newGuid());
    VM vm1 = new VM();
    vm1.setId(Guid.newGuid());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    manager.addPending(new PendingVM(host, vm1));
    manager.addPending(new PendingMemory(host, vm1, 768));
    manager.addPending(new PendingCpuCores(host, vm1, 1));
    manager.addPending(new PendingVM(host, vm2));
    manager.addPending(new PendingMemory(host, vm2, 1024));
    manager.addPending(new PendingCpuCores(host, vm2, 10));
    Set<Guid> pending = PendingVM.collectForHost(manager, host.getId());
    assertEquals(2, pending.size());
    assertEquals(11, PendingCpuCores.collectForHost(manager, host.getId()));
    assertEquals(1024 + 768, PendingMemory.collectForHost(manager, host.getId()));
    assertEquals(host.getId(), PendingVM.getScheduledHost(manager, vm1));
    assertEquals(host.getId(), PendingVM.getScheduledHost(manager, vm2));
}
#end_block

#method_before
public static void main(String... args) {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        setupLogger();
        ArgumentsParser parser;
        Map<String, ModuleService> moduleServices = loadModules(ModuleService.class);
        final Map<String, String> substitutions = new HashMap<>();
        substitutions.put("@ENGINE_ETC@", ENGINE_ETC);
        substitutions.put("@PROGRAM_NAME@", PROGRAM_NAME);
        substitutions.put("@MODULE_LIST@", getModules(moduleServices));
        try (InputStream stream = ExtensionsToolExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "core");
            parser.getSubstitutions().putAll(substitutions);
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        if ((Boolean) argMap.get("help") || (cmdArgs.size() > 0 && cmdArgs.get(0).equals("help"))) {
            System.out.format("Usage: %s", parser.getUsage());
            throw new ExitException("Help", 0);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ExitException("Version", 0);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                logger.error(t.getMessage());
                logger.debug(t.getMessage(), t);
            }
            throw new ExitException("Parsing error", 1);
        }
        if (cmdArgs.size() < 1) {
            logger.error("Please provide module.");
            throw new ExitException("Module not provided", 1);
        }
        String module = cmdArgs.get(0);
        ModuleService moduleService = moduleServices.get(module);
        if (moduleService == null) {
            logger.error("No such '{}' module exists.", module);
            throw new ExitException(1);
        }
        moduleService.parseArguments(cmdArgs);
        loadExtensions(moduleService, argMap);
        moduleService.run();
    } catch (ExitException e) {
        logger.debug(e.getMessage(), e);
        exitStatus = e.getExitCode();
    } catch (Throwable t) {
        String message = t.getMessage() != null ? t.getMessage() : t.getClass().getName();
        logger.error(message);
        logger.debug("Exception:", t);
    }
    logger.debug("Exiting with status '{}'", exitStatus);
    System.exit(exitStatus);
}
#method_after
public static void main(String... args) {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        setupLogger();
        ArgumentsParser parser;
        Map<String, ModuleService> moduleServices = loadModules(ModuleService.class);
        final Map<String, String> substitutions = new HashMap<>();
        substitutions.put("@ENGINE_ETC@", ENGINE_ETC);
        substitutions.put("@PROGRAM_NAME@", PROGRAM_NAME);
        substitutions.put("@MODULE_LIST@", getModules(moduleServices));
        try (InputStream stream = ExtensionsToolExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "core");
            parser.getSubstitutions().putAll(substitutions);
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        if ((Boolean) argMap.get("help") || (cmdArgs.size() > 0 && cmdArgs.get(0).equals("help"))) {
            System.out.format("Usage: %s", parser.getUsage());
            throw new ExitException("Help", 0);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ExitException("Version", 0);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                logger.error(t.getMessage());
                logger.debug(t.getMessage(), t);
            }
            throw new ExitException("Parsing error", 1);
        }
        if (cmdArgs.size() < 1) {
            logger.error("Please provide module.");
            throw new ExitException("Module not provided", 1);
        }
        String module = cmdArgs.get(0);
        ModuleService moduleService = moduleServices.get(module);
        if (moduleService == null) {
            logger.error("No such '{}' module exists.", module);
            throw new ExitException(1);
        }
        moduleService.parseArguments(cmdArgs);
        logger.info("========================================================================");
        logger.info("============================ Initialization ============================");
        logger.info("========================================================================");
        loadExtensions(moduleService, argMap);
        logger.info("========================================================================");
        logger.info("============================== Execution ===============================");
        logger.info("========================================================================");
        moduleService.run();
        exitStatus = 0;
    } catch (ExitException e) {
        logger.debug(e.getMessage(), e);
        exitStatus = e.getExitCode();
    } catch (Throwable t) {
        logger.error(t.getMessage() != null ? t.getMessage() : t.getClass().getName());
        logger.debug("Exception:", t);
    }
    logger.debug("Exiting with status '{}'", exitStatus);
    System.exit(exitStatus);
}
#end_block

#method_before
private static void loadExtensions(ModuleService moduleService, Map<String, Object> argMap) {
    ExtensionsManager extensionsManager = new ExtensionsManager();
    moduleService.getContext().put(ModuleService.EXTENSION_MANAGER, extensionsManager);
    Map<String, ExtensionProxy> proxies = moduleService.getContext().get(ModuleService.EXTENSIONS_MAP);
    List<File> files = (List<File>) argMap.get("extension-file");
    if (files == null) {
        files = listFiles(((String) argMap.get("extensions-dir")), "properties");
    }
    for (File f : files) {
        logger.debug("Loading extension file '{}'", f.getName());
        try {
            proxies.put(extensionsManager.load(f), null);
        } catch (Exception ex) {
            logger.error("Can't load extension '{}', ignoring.", f.getName());
            logger.debug("Exception:", ex);
        }
    }
    for (Map.Entry<String, ExtensionProxy> entry : proxies.entrySet()) {
        extensionsManager.initialize(entry.getKey());
        entry.setValue(extensionsManager.getExtensionByName(entry.getKey()));
        logger.debug("Extension '{}' initialized", entry.getKey());
    }
}
#method_after
private static void loadExtensions(ModuleService moduleService, Map<String, Object> argMap) {
    ExtensionsManager extensionsManager = new ExtensionsManager();
    moduleService.getContext().put(ModuleService.EXTENSION_MANAGER, extensionsManager);
    Map<String, ExtensionProxy> proxies = moduleService.getContext().get(ModuleService.EXTENSIONS_MAP);
    List<File> files = (List<File>) argMap.get("extension-file");
    if (files == null) {
        files = listFiles(((String) argMap.get("extensions-dir")), "properties");
    }
    for (File f : files) {
        logger.debug("Loading extension file '{}'", f.getName());
        try {
            proxies.put(extensionsManager.load(f), null);
        } catch (Exception ex) {
            logger.error("Can't load extension '{}', ignoring.", f.getName());
            logger.debug("Exception:", ex);
        }
    }
    for (Map.Entry<String, ExtensionProxy> entry : proxies.entrySet()) {
        extensionsManager.initialize(entry.getKey());
        entry.setValue(extensionsManager.getExtensionByName(entry.getKey()));
        logger.debug("Extension '{}' initialized", entry.getKey());
    }
    extensionsManager.dump();
}
#end_block

#method_before
protected void doUpdateManagedFieldsFrom(final VmBase vmBase) {
    if (vmBase == null) {
        model.stopProgress();
        return;
    }
    deactivate();
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getIoThreadsEnabled(), vmBase.getNumOfIoThreads() != 0);
    maybeSetEntity(model.getNumOfIoThreads(), vmBase.getNumOfIoThreads());
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getTotalCPUCores(), Integer.toString(vmBase.getNumOfCpus()));
    model.setBootSequence(vmBase.getDefaultBootSequence());
    List<MigrationSupport> supportedModes = (List<MigrationSupport>) getModel().getMigrationMode().getItems();
    if (supportedModes.contains(vmBase.getMigrationSupport())) {
        maybeSetSelectedItem(getModel().getMigrationMode(), vmBase.getMigrationSupport());
    }
    maybeSetEntity(model.getIsHighlyAvailable(), vmBase.isAutoStartup());
    maybeSetSelectedItem(model.getNumOfSockets(), vmBase.getNumOfSockets());
    maybeSetSelectedItem(model.getCoresPerSocket(), vmBase.getCpuPerSocket());
    maybeSetSelectedItem(model.getEmulatedMachine(), vmBase.getCustomEmulatedMachine());
    maybeSetSelectedItem(model.getCustomCpu(), vmBase.getCustomCpuName());
    model.setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
    priorityUtil.initPriority(vmBase.getPriority());
    updateDefaultDisplayRelatedFields(vmBase);
    if (vmBase.getMinAllocatedMem() != 0) {
        model.getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
    }
    activate();
    AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            deactivate();
            getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
            activate();
            Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    deactivate();
                    List<String> consoleDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
                    activate();
                    postDoUpdateManagedFieldsFrom(vmBase);
                }
            }));
        }
    }), vmBase.getId());
}
#method_after
protected void doUpdateManagedFieldsFrom(final VmBase vmBase) {
    if (vmBase == null) {
        model.stopProgress();
        return;
    }
    deactivate();
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getIoThreadsEnabled(), vmBase.getNumOfIoThreads() != 0);
    maybeSetEntity(model.getNumOfIoThreads(), vmBase.getNumOfIoThreads());
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getTotalCPUCores(), Integer.toString(vmBase.getNumOfCpus()));
    model.setBootSequence(vmBase.getDefaultBootSequence());
    List<MigrationSupport> supportedModes = (List<MigrationSupport>) getModel().getMigrationMode().getItems();
    if (supportedModes.contains(vmBase.getMigrationSupport())) {
        maybeSetSelectedItem(getModel().getMigrationMode(), vmBase.getMigrationSupport());
    }
    maybeSetEntity(model.getIsHighlyAvailable(), vmBase.isAutoStartup());
    maybeSetSelectedItem(model.getNumOfSockets(), vmBase.getNumOfSockets());
    maybeSetSelectedItem(model.getCoresPerSocket(), vmBase.getCpuPerSocket());
    maybeSetSelectedItem(model.getEmulatedMachine(), vmBase.getCustomEmulatedMachine());
    maybeSetSelectedItem(model.getCustomCpu(), vmBase.getCustomCpuName());
    model.setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
    priorityUtil.initPriority(vmBase.getPriority(), new PriorityUtil.PriorityUpdatingCallbacks() {

        @Override
        public void beforeUpdates() {
            deactivate();
        }

        @Override
        public void afterUpdates() {
            activate();
        }
    });
    updateDefaultDisplayRelatedFields(vmBase);
    if (vmBase.getMinAllocatedMem() != 0) {
        model.getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
    }
    activate();
    AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            deactivate();
            getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
            activate();
            Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    deactivate();
                    List<String> consoleDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
                    activate();
                    postDoUpdateManagedFieldsFrom(vmBase);
                }
            }));
        }
    }), vmBase.getId());
}
#end_block

