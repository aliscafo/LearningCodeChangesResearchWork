357
#method_before
@Override
public Optional<Long> getTargetPower(PortNumber port, Object component) {
    try {
        NetconfSession session = getNetconfSession(did());
        if (session == null) {
            log.error("discoverPortDetails called with null session for {}", did());
            return Optional.of(NO_POWER);
        }
        StringBuilder sb = new StringBuilder();
        sb.append(RPC_TAG_NETCONF_BASE).append("<get>").append("<filter type='subtree'>").append("<components xmlns='http://openconfig.net/yang/platform'/>").append("</filter>").append("</get>").append(RPC_CLOSE_TAG);
        CompletableFuture<String> fut = session.rpc(sb.toString());
        String rpcReply = fut.get();
        XMLConfiguration xconf = (XMLConfiguration) XmlConfigParser.loadXmlString(rpcReply);
        xconf.setExpressionEngine(new XPathExpressionEngine());
        HierarchicalConfiguration targetOutputPowers = xconf.configurationAt("data/components/component/optical-channel/config/target-output-power");
        log.info("target output power is: {}", targetOutputPowers.toString());
        return Optional.of(NO_POWER);
    } catch (Exception e) {
        log.error("Exception getTargetPower() {}", did(), e);
        return Optional.of(NO_POWER);
    }
}
#method_after
@Override
public Optional<Long> getTargetPower(PortNumber port, OchSignal component) {
    NetconfSession session = getNetconfSession(did());
    if (session == null) {
        log.error("discoverPortDetails called with null session for {}", did());
        return Optional.of(NO_POWER);
    }
    String filter = parsePort(port, component, null);
    StringBuilder rpcReq = new StringBuilder();
    rpcReq.append(RPC_TAG_NETCONF_BASE).append("<get>").append("<filter type='subtree'>").append(filter).append("</filter>").append("</get>").append(RPC_CLOSE_TAG);
    XMLConfiguration xconf = executeRpc(session, rpcReq.toString());
    HierarchicalConfiguration config = xconf.configurationAt("data/components/component/optical-channel/config");
    long power = Float.valueOf(config.getString("target-output-power")).longValue();
    return Optional.of(power);
}
#end_block

#method_before
@Override
public void setTargetPower(PortNumber port, Object component, long power) {
    // FIXME
    log.warn("Not Implemented Yet!");
}
#method_after
@Override
public void setTargetPower(PortNumber port, OchSignal component, long power) {
    NetconfSession session = getNetconfSession(did());
    if (session == null) {
        log.error("setTargetPower called with null session for {}", did());
        return;
    }
    String editConfig = parsePort(port, component, power);
    StringBuilder rpcReq = new StringBuilder();
    rpcReq.append(RPC_TAG_NETCONF_BASE).append("<edit-config>").append("<target><running/></target>").append("<config>").append(editConfig).append("</config>").append("</edit-config>").append(RPC_CLOSE_TAG);
    XMLConfiguration xconf = executeRpc(session, rpcReq.toString());
    // The successful reply should be "<rpc-reply ...><ok /></rpc-reply>"
    if (!xconf.getRoot().getChild(0).getName().equals("ok")) {
        log.error("The <edit-config> operation to set target-output-power of Port({}:{}) is failed.", port.toString(), component.toString());
    }
}
#end_block

#method_before
@Override
public Optional<Long> currentPower(PortNumber port, Object component) {
    // FIXME
    log.warn("Not Implemented Yet!");
    return Optional.empty();
}
#method_after
@Override
public Optional<Long> currentPower(PortNumber port, OchSignal component) {
    // FIXME
    log.warn("Not Implemented Yet!");
    return Optional.empty();
}
#end_block

#method_before
@Override
public Optional<Range<Long>> getTargetPowerRange(PortNumber port, Object component) {
    // FIXME
    log.warn("Not Implemented Yet!");
    return Optional.empty();
}
#method_after
@Override
public Optional<Range<Long>> getTargetPowerRange(PortNumber port, OchSignal component) {
    // FIXME
    log.warn("Not Implemented Yet!");
    return Optional.empty();
}
#end_block

#method_before
@Override
public Optional<Range<Long>> getInputPowerRange(PortNumber port, Object component) {
    // FIXME
    log.warn("Not Implemented Yet!");
    return Optional.empty();
}
#method_after
@Override
public Optional<Range<Long>> getInputPowerRange(PortNumber port, OchSignal component) {
    // FIXME
    log.warn("Not Implemented Yet!");
    return Optional.empty();
}
#end_block

#method_before
@Override
public List<PortNumber> getPorts(Object component) {
    // FIXME
    log.warn("Not Implemented Yet!");
    return new ArrayList<PortNumber>();
}
#method_after
@Override
public List<PortNumber> getPorts(OchSignal component) {
    // FIXME
    log.warn("Not Implemented Yet!");
    return new ArrayList<PortNumber>();
}
#end_block

#method_before
private void processRouteAddedInternal(Collection<ResolvedRoute> routes) {
    if (!isReady()) {
        log.info("System is not ready. Skip adding route for {}", routes);
        return;
    }
    log.info("processRouteAddedInternal. routes={}", routes);
    if (routes.size() > 2) {
        log.info("Route {} has more than two next hops. Do not process route change", routes);
        return;
    }
    Set<ConnectPoint> allLocations = Sets.newHashSet();
    Set<IpPrefix> allPrefixes = Sets.newHashSet();
    routes.forEach(route -> {
        allLocations.addAll(srManager.nextHopLocations(route));
        allPrefixes.add(route.prefix());
    });
    log.debug("RouteAdded. populateSubnet {}, {}", allLocations, allPrefixes);
    srManager.defaultRoutingHandler.populateSubnet(allLocations, allPrefixes);
    routes.forEach(route -> {
        IpPrefix prefix = route.prefix();
        MacAddress nextHopMac = route.nextHopMac();
        VlanId nextHopVlan = route.nextHopVlan();
        Set<ConnectPoint> locations = srManager.nextHopLocations(route);
        locations.forEach(location -> {
            log.debug("RouteAdded. addSubnet {}, {}", location, prefix);
            srManager.deviceConfiguration.addSubnet(location, prefix);
            log.debug("RouteAdded populateRoute {}, {}, {}, {}", location, prefix, nextHopMac, nextHopVlan);
            srManager.defaultRoutingHandler.populateRoute(location.deviceId(), prefix, nextHopMac, nextHopVlan, location.port());
        });
    });
}
#method_after
private void processRouteAddedInternal(Collection<ResolvedRoute> routes) {
    if (!isReady()) {
        log.info("System is not ready. Skip adding route for {}", routes);
        return;
    }
    log.info("processRouteAddedInternal. routes={}", routes);
    if (routes.size() > 2) {
        log.info("Route {} has more than two next hops. Do not process route change", routes);
        return;
    }
    Set<ConnectPoint> allLocations = Sets.newHashSet();
    Set<IpPrefix> allPrefixes = Sets.newHashSet();
    routes.forEach(route -> {
        allLocations.addAll(srManager.nextHopLocations(route));
        allPrefixes.add(route.prefix());
    });
    log.debug("RouteAdded. populateSubnet {}, {}", allLocations, allPrefixes);
    srManager.defaultRoutingHandler.populateSubnet(allLocations, allPrefixes);
    routes.forEach(route -> {
        IpPrefix prefix = route.prefix();
        MacAddress nextHopMac = route.nextHopMac();
        VlanId nextHopVlan = route.nextHopVlan();
        Set<ConnectPoint> locations = srManager.nextHopLocations(route);
        locations.forEach(location -> {
            log.debug("RouteAdded. addSubnet {}, {}", location, prefix);
            srManager.deviceConfiguration.addSubnet(location, prefix);
            log.debug("RouteAdded populateRoute {}, {}, {}, {}", location, prefix, nextHopMac, nextHopVlan);
            srManager.defaultRoutingHandler.populateRoute(location.deviceId(), prefix, nextHopMac, nextHopVlan, location.port(), false);
        });
    });
}
#end_block

#method_before
private void processRouteUpdatedInternal(Set<ResolvedRoute> routes, Set<ResolvedRoute> oldRoutes) {
    if (!isReady()) {
        log.info("System is not ready. Skip updating route for {} -> {}", oldRoutes, routes);
        return;
    }
    log.info("processRouteUpdatedInternal. routes={}, oldRoutes={}", routes, oldRoutes);
    if (routes.size() > 2) {
        log.info("Route {} has more than two next hops. Do not process route change", routes);
        return;
    }
    Set<ConnectPoint> allLocations = Sets.newHashSet();
    Set<IpPrefix> allPrefixes = Sets.newHashSet();
    routes.forEach(route -> {
        allLocations.addAll(srManager.nextHopLocations(route));
        allPrefixes.add(route.prefix());
    });
    // Revoke subnet from all locations and reset oldRoutes such that system will be reprogrammed from scratch
    if (oldRoutes.size() > 2) {
        log.info("Revoke subnet {} and reset oldRoutes");
        srManager.defaultRoutingHandler.revokeSubnet(allPrefixes);
        oldRoutes = Sets.newHashSet();
    }
    log.debug("RouteUpdated. populateSubnet {}, {}", allLocations, allPrefixes);
    srManager.defaultRoutingHandler.populateSubnet(allLocations, allPrefixes);
    Set<ResolvedRoute> toBeRemoved = Sets.difference(oldRoutes, routes).immutableCopy();
    Set<ResolvedRoute> toBeAdded = Sets.difference(routes, oldRoutes).immutableCopy();
    toBeRemoved.forEach(route -> {
        srManager.nextHopLocations(route).forEach(oldLocation -> {
            if (toBeAdded.stream().map(srManager::nextHopLocations).flatMap(Set::stream).map(ConnectPoint::deviceId).noneMatch(deviceId -> deviceId.equals(oldLocation.deviceId()))) {
                IpPrefix prefix = route.prefix();
                log.debug("RouteUpdated. removeSubnet {}, {}", oldLocation, prefix);
                srManager.deviceConfiguration.removeSubnet(oldLocation, prefix);
            // We don't remove the flow on the old location in occasion of two next hops becoming one
            // since the populateSubnet will point the old location to the new location via spine.
            }
        });
    });
    toBeAdded.forEach(route -> {
        IpPrefix prefix = route.prefix();
        MacAddress nextHopMac = route.nextHopMac();
        VlanId nextHopVlan = route.nextHopVlan();
        Set<ConnectPoint> locations = srManager.nextHopLocations(route);
        locations.forEach(location -> {
            log.debug("RouteUpdated. addSubnet {}, {}", location, prefix);
            srManager.deviceConfiguration.addSubnet(location, prefix);
            log.debug("RouteUpdated. populateRoute {}, {}, {}, {}", location, prefix, nextHopMac, nextHopVlan);
            srManager.defaultRoutingHandler.populateRoute(location.deviceId(), prefix, nextHopMac, nextHopVlan, location.port());
        });
    });
}
#method_after
private void processRouteUpdatedInternal(Set<ResolvedRoute> routes, Set<ResolvedRoute> oldRoutes) {
    if (!isReady()) {
        log.info("System is not ready. Skip updating route for {} -> {}", oldRoutes, routes);
        return;
    }
    log.info("processRouteUpdatedInternal. routes={}, oldRoutes={}", routes, oldRoutes);
    if (routes.size() > 2) {
        log.info("Route {} has more than two next hops. Do not process route change", routes);
        return;
    }
    Set<ConnectPoint> allLocations = Sets.newHashSet();
    Set<IpPrefix> allPrefixes = Sets.newHashSet();
    routes.forEach(route -> {
        allLocations.addAll(srManager.nextHopLocations(route));
        allPrefixes.add(route.prefix());
    });
    // Revoke subnet from all locations and reset oldRoutes such that system will be reprogrammed from scratch
    if (oldRoutes.size() > 2) {
        log.info("Revoke subnet {} and reset oldRoutes");
        srManager.defaultRoutingHandler.revokeSubnet(allPrefixes);
        oldRoutes = Sets.newHashSet();
    }
    log.debug("RouteUpdated. populateSubnet {}, {}", allLocations, allPrefixes);
    srManager.defaultRoutingHandler.populateSubnet(allLocations, allPrefixes);
    Set<ResolvedRoute> toBeRemoved = Sets.difference(oldRoutes, routes).immutableCopy();
    Set<ResolvedRoute> toBeAdded = Sets.difference(routes, oldRoutes).immutableCopy();
    toBeRemoved.forEach(route -> {
        srManager.nextHopLocations(route).forEach(oldLocation -> {
            if (toBeAdded.stream().map(srManager::nextHopLocations).flatMap(Set::stream).map(ConnectPoint::deviceId).noneMatch(deviceId -> deviceId.equals(oldLocation.deviceId()))) {
                IpPrefix prefix = route.prefix();
                log.debug("RouteUpdated. removeSubnet {}, {}", oldLocation, prefix);
                srManager.deviceConfiguration.removeSubnet(oldLocation, prefix);
            // We don't remove the flow on the old location in occasion of two next hops becoming one
            // since the populateSubnet will point the old location to the new location via spine.
            }
        });
    });
    toBeAdded.forEach(route -> {
        IpPrefix prefix = route.prefix();
        MacAddress nextHopMac = route.nextHopMac();
        VlanId nextHopVlan = route.nextHopVlan();
        Set<ConnectPoint> locations = srManager.nextHopLocations(route);
        locations.forEach(location -> {
            log.debug("RouteUpdated. addSubnet {}, {}", location, prefix);
            srManager.deviceConfiguration.addSubnet(location, prefix);
            log.debug("RouteUpdated. populateRoute {}, {}, {}, {}", location, prefix, nextHopMac, nextHopVlan);
            srManager.defaultRoutingHandler.populateRoute(location.deviceId(), prefix, nextHopMac, nextHopVlan, location.port(), false);
        });
    });
}
#end_block

#method_before
private void processRouteRemovedInternal(Collection<ResolvedRoute> routes) {
    if (!isReady()) {
        log.info("System is not ready. Skip removing route for {}", routes);
        return;
    }
    log.info("processRouteRemovedInternal. routes={}", routes);
    Set<IpPrefix> allPrefixes = Sets.newHashSet();
    routes.forEach(route -> {
        allPrefixes.add(route.prefix());
    });
    log.debug("RouteRemoved. revokeSubnet {}", allPrefixes);
    srManager.defaultRoutingHandler.revokeSubnet(allPrefixes);
    routes.forEach(route -> {
        IpPrefix prefix = route.prefix();
        MacAddress nextHopMac = route.nextHopMac();
        VlanId nextHopVlan = route.nextHopVlan();
        Set<ConnectPoint> locations = srManager.nextHopLocations(route);
        locations.forEach(location -> {
            log.debug("RouteRemoved. removeSubnet {}, {}", location, prefix);
            srManager.deviceConfiguration.removeSubnet(location, prefix);
            // We don't need to call revokeRoute again since revokeSubnet will remove the prefix
            // from all devices, including the ones that next hop attaches to.
            // Also remove redirection flows on the pair device if exists.
            Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(location.deviceId());
            Optional<PortNumber> pairLocalPort = srManager.getPairLocalPort(location.deviceId());
            if (pairDeviceId.isPresent() && pairLocalPort.isPresent()) {
                // NOTE: Since the pairLocalPort is trunk port, use assigned vlan of original port
                // when the host is untagged
                VlanId vlanId = Optional.ofNullable(srManager.getInternalVlanId(location)).orElse(nextHopVlan);
                log.debug("RouteRemoved. revokeRoute {}, {}, {}, {}", location, prefix, nextHopMac, nextHopVlan);
                srManager.defaultRoutingHandler.revokeRoute(pairDeviceId.get(), prefix, nextHopMac, vlanId, pairLocalPort.get());
            }
        });
    });
}
#method_after
private void processRouteRemovedInternal(Collection<ResolvedRoute> routes) {
    if (!isReady()) {
        log.info("System is not ready. Skip removing route for {}", routes);
        return;
    }
    log.info("processRouteRemovedInternal. routes={}", routes);
    Set<IpPrefix> allPrefixes = Sets.newHashSet();
    routes.forEach(route -> {
        allPrefixes.add(route.prefix());
    });
    log.debug("RouteRemoved. revokeSubnet {}", allPrefixes);
    srManager.defaultRoutingHandler.revokeSubnet(allPrefixes);
    routes.forEach(route -> {
        IpPrefix prefix = route.prefix();
        MacAddress nextHopMac = route.nextHopMac();
        VlanId nextHopVlan = route.nextHopVlan();
        Set<ConnectPoint> locations = srManager.nextHopLocations(route);
        locations.forEach(location -> {
            log.debug("RouteRemoved. removeSubnet {}, {}", location, prefix);
            srManager.deviceConfiguration.removeSubnet(location, prefix);
            // We don't need to call revokeRoute again since revokeSubnet will remove the prefix
            // from all devices, including the ones that next hop attaches to.
            // Also remove redirection flows on the pair device if exists.
            Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(location.deviceId());
            Optional<PortNumber> pairLocalPort = srManager.getPairLocalPort(location.deviceId());
            if (pairDeviceId.isPresent() && pairLocalPort.isPresent()) {
                // NOTE: Since the pairLocalPort is trunk port, use assigned vlan of original port
                // when the host is untagged
                VlanId vlanId = Optional.ofNullable(srManager.getInternalVlanId(location)).orElse(nextHopVlan);
                log.debug("RouteRemoved. revokeRoute {}, {}, {}, {}", location, prefix, nextHopMac, nextHopVlan);
                srManager.defaultRoutingHandler.revokeRoute(pairDeviceId.get(), prefix, nextHopMac, vlanId, pairLocalPort.get(), false);
            }
        });
    });
}
#end_block

#method_before
void processHostMovedEvent(HostEvent event) {
    log.info("processHostMovedEvent {}", event);
    MacAddress hostMac = event.subject().mac();
    VlanId hostVlanId = event.subject().vlan();
    // map of nextId for prev port in each device
    Map<DeviceId, Integer> nextIdMap = new HashMap<>();
    affectedRoutes(hostMac, hostVlanId).forEach(affectedRoute -> {
        IpPrefix prefix = affectedRoute.prefix();
        Set<HostLocation> prevLocations = event.prevSubject().locations();
        Set<HostLocation> newLocations = event.subject().locations();
        Set<ConnectPoint> connectPoints = newLocations.stream().map(l -> (ConnectPoint) l).collect(Collectors.toSet());
        log.debug("HostMoved. populateSubnet {}, {}", newLocations, prefix);
        srManager.defaultRoutingHandler.populateSubnet(connectPoints, Sets.newHashSet(prefix));
        Set<DeviceId> newDeviceIds = newLocations.stream().map(HostLocation::deviceId).collect(Collectors.toSet());
        // For each old location
        Sets.difference(prevLocations, newLocations).forEach(prevLocation -> {
            DefaultGroupHandler grpHandler = srManager.getGroupHandler(prevLocation.deviceId());
            VlanId vlanId = Optional.ofNullable(srManager.getInternalVlanId(prevLocation)).orElse(hostVlanId);
            // find next Id for each old port, add to map
            int nextId = grpHandler.getNextIdForHostPort(prevLocation.deviceId(), hostMac, vlanId, prevLocation.port());
            log.debug("HostMoved. NextId For Host {}, {}, {}, {} {}", prevLocation, prefix, hostMac, vlanId, nextId);
            // TODO : add check for invalid next Id
            nextIdMap.put(prevLocation.deviceId(), nextId);
        /* TODO : check what to do here
                // Remove flows for unchanged IPs only when the host moves from a switch to another.
                // Otherwise, do not remove and let the adding part update the old flow
                if (!newDeviceIds.contains(prevLocation.deviceId())) {
                    log.debug("HostMoved. removeSubnet {}, {}", prevLocation, prefix);
                    srManager.deviceConfiguration.removeSubnet(prevLocation, prefix);

                    log.debug("HostMoved. revokeRoute {}, {}, {}, {}", prevLocation, prefix, hostMac, hostVlanId);
                    srManager.defaultRoutingHandler.revokeRoute(prevLocation.deviceId(), prefix,
                            hostMac, hostVlanId, prevLocation.port());
                }
                */
        });
        // For each new location, add all new IPs.
        Sets.difference(newLocations, prevLocations).forEach(newLocation -> {
            /*
                log.debug("HostMoved. addSubnet {}, {}", newLocation, prefix);
                srManager.deviceConfiguration.addSubnet(newLocation, prefix);

                log.debug("HostMoved. populateRoute {}, {}, {}, {}", newLocation, prefix, hostMac, hostVlanId);
                srManager.defaultRoutingHandler.populateRoute(newLocation.deviceId(), prefix,
                        hostMac, hostVlanId, newLocation.port());
                */
            DefaultGroupHandler grpHandler = srManager.getGroupHandler(newLocation.deviceId());
            VlanId vlanId = Optional.ofNullable(srManager.getInternalVlanId(newLocation)).orElse(hostVlanId);
            // use nextIdMap to send new port details to update the nextId group bucket
            log.debug("HostMoved. update L3 Ucast Group Bucket {}, {}, {} --> {}", newLocation, hostMac, vlanId, nextIdMap.get(newLocation.deviceId()));
            grpHandler.updateL3UcastGroupBucket(newLocation.deviceId(), hostMac, vlanId, newLocation.port(), nextIdMap.get(newLocation.deviceId()));
        });
    });
}
#method_after
void processHostMovedEvent(HostEvent event) {
    log.info("processHostMovedEvent {}", event);
    MacAddress hostMac = event.subject().mac();
    VlanId hostVlanId = event.subject().vlan();
    // map of nextId for prev port in each device
    Map<DeviceId, Integer> nextIdMap = new HashMap<>();
    affectedRoutes(hostMac, hostVlanId).forEach(affectedRoute -> {
        IpPrefix prefix = affectedRoute.prefix();
        Set<HostLocation> prevLocations = event.prevSubject().locations();
        Set<HostLocation> newLocations = event.subject().locations();
        Set<ConnectPoint> connectPoints = newLocations.stream().map(l -> (ConnectPoint) l).collect(Collectors.toSet());
        log.debug("HostMoved. populateSubnet {}, {}", newLocations, prefix);
        srManager.defaultRoutingHandler.populateSubnet(connectPoints, Sets.newHashSet(prefix));
        Set<DeviceId> newDeviceIds = newLocations.stream().map(HostLocation::deviceId).collect(Collectors.toSet());
        // Set of deviceIDs of the previous locations where the host was connected
        // Used to determine if host moved to different connect points
        // on same device or moved to a different device altogether
        Set<DeviceId> oldDeviceIds = prevLocations.stream().map(HostLocation::deviceId).collect(Collectors.toSet());
        // For each old location
        Sets.difference(prevLocations, newLocations).forEach(prevLocation -> {
            // find next Id for each old port, add to map
            int nextId = srManager.getNextIdForHostPort(prevLocation.deviceId(), hostMac, hostVlanId, prevLocation.port());
            log.debug("HostMoved. NextId For Host {}, {}, {}, {} {}", prevLocation, prefix, hostMac, hostVlanId, nextId);
            nextIdMap.put(prevLocation.deviceId(), nextId);
            // Otherwise, do not remove and let the adding part update the old flow
            if (newDeviceIds.contains(prevLocation.deviceId())) {
                return;
            }
            log.debug("HostMoved. removeSubnet {}, {}", prevLocation, prefix);
            srManager.deviceConfiguration.removeSubnet(prevLocation, prefix);
            // Do not remove flow from a device if the route is still reachable via its pair device.
            // populateSubnet will update the flow to point to its pair device via spine.
            DeviceId pairDeviceId = srManager.getPairDeviceId(prevLocation.deviceId()).orElse(null);
            if (newLocations.stream().anyMatch(n -> n.deviceId().equals(pairDeviceId))) {
                return;
            }
            log.debug("HostMoved. revokeRoute {}, {}, {}, {}", prevLocation, prefix, hostMac, hostVlanId);
            srManager.defaultRoutingHandler.revokeRoute(prevLocation.deviceId(), prefix, hostMac, hostVlanId, prevLocation.port(), false);
        });
        // For each new location, add all new IPs.
        Sets.difference(newLocations, prevLocations).forEach(newLocation -> {
            log.debug("HostMoved. addSubnet {}, {}", newLocation, prefix);
            srManager.deviceConfiguration.addSubnet(newLocation, prefix);
            // its a new connect point, not a move from an existing device, populateRoute
            if (!oldDeviceIds.contains(newLocation.deviceId())) {
                log.debug("HostMoved. populateRoute {}, {}, {}, {}", newLocation, prefix, hostMac, hostVlanId);
                srManager.defaultRoutingHandler.populateRoute(newLocation.deviceId(), prefix, hostMac, hostVlanId, newLocation.port(), false);
            } else {
                // update same flow to point to new nextObj
                VlanId vlanId = Optional.ofNullable(srManager.getInternalVlanId(newLocation)).orElse(hostVlanId);
                // use nextIdMap to send new port details to update the nextId group bucket
                log.debug("HostMoved. update L3 Ucast Group Bucket {}, {}, {} --> {}", newLocation, hostMac, vlanId, nextIdMap.get(newLocation.deviceId()));
                srManager.updateMacVlanTreatment(newLocation.deviceId(), hostMac, vlanId, newLocation.port(), nextIdMap.get(newLocation.deviceId()));
            }
        });
    });
}
#end_block

#method_before
void populateRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort) {
    log.debug("Populate direct routing entry for route {} at {}:{}", prefix, deviceId, outPort);
    ForwardingObjective.Builder fwdBuilder;
    try {
        fwdBuilder = routingFwdObjBuilder(deviceId, prefix, hostMac, hostVlanId, outPort, false);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting direct populateRoute");
        return;
    }
    if (fwdBuilder == null) {
        log.warn("Aborting host routing table entry due " + "to error for dev:{} route:{}", deviceId, prefix);
        return;
    }
    int nextId = fwdBuilder.add().nextId();
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Direct routing rule for route {} populated. nextId={}", prefix, nextId), (objective, error) -> log.warn("Failed to populate direct routing rule for route {}: {}", prefix, error));
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(context));
    rulePopulationCounter.incrementAndGet();
}
#method_after
void populateRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort, boolean directHost) {
    log.debug("Populate direct routing entry for route {} at {}:{}", prefix, deviceId, outPort);
    ForwardingObjective.Builder fwdBuilder;
    try {
        fwdBuilder = routingFwdObjBuilder(deviceId, prefix, hostMac, hostVlanId, outPort, directHost, false);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting direct populateRoute");
        return;
    }
    if (fwdBuilder == null) {
        log.warn("Aborting host routing table entry due " + "to error for dev:{} route:{}", deviceId, prefix);
        return;
    }
    int nextId = fwdBuilder.add().nextId();
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Direct routing rule for route {} populated. nextId={}", prefix, nextId), (objective, error) -> log.warn("Failed to populate direct routing rule for route {}: {}", prefix, error));
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.add(context));
    rulePopulationCounter.incrementAndGet();
}
#end_block

#method_before
void revokeRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort) {
    log.debug("revokeRoute : Revoke IP table entry for route {} at {}:{}", prefix, deviceId, outPort);
    ForwardingObjective.Builder fwdBuilder;
    try {
        fwdBuilder = routingFwdObjBuilder(deviceId, prefix, hostMac, hostVlanId, outPort, true);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting revokeIpRuleForHost.");
        return;
    }
    if (fwdBuilder == null) {
        log.warn("revokeRoute : Aborting host routing table entries due " + "to error for dev:{} route:{}", deviceId, prefix);
        return;
    }
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("revokeRoute : IP rule for route {} revoked", prefix), (objective, error) -> log.warn("revokeRoute : Failed to revoke IP rule for route {}: {}", prefix, error));
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.remove(context));
}
#method_after
void revokeRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort, boolean directHost) {
    log.debug("Revoke IP table entry for route {} at {}:{}", prefix, deviceId, outPort);
    ForwardingObjective.Builder fwdBuilder;
    try {
        fwdBuilder = routingFwdObjBuilder(deviceId, prefix, hostMac, hostVlanId, outPort, directHost, true);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting revokeIpRuleForHost.");
        return;
    }
    if (fwdBuilder == null) {
        log.warn("Aborting host routing table entries due " + "to error for dev:{} route:{}", deviceId, prefix);
        return;
    }
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("IP rule for route {} revoked", prefix), (objective, error) -> log.warn("Failed to revoke IP rule for route {}: {}", prefix, error));
    srManager.flowObjectiveService.forward(deviceId, fwdBuilder.remove(context));
}
#end_block

#method_before
private ForwardingObjective.Builder routingFwdObjBuilder(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort, boolean revoke) throws DeviceConfigNotFoundException {
    MacAddress deviceMac;
    deviceMac = config.getDeviceMac(deviceId);
    ConnectPoint connectPoint = new ConnectPoint(deviceId, outPort);
    VlanId untaggedVlan = srManager.getUntaggedVlanId(connectPoint);
    Set<VlanId> taggedVlans = srManager.getTaggedVlanId(connectPoint);
    VlanId nativeVlan = srManager.getNativeVlanId(connectPoint);
    // Create route selector
    TrafficSelector.Builder sbuilder = buildIpSelectorFromIpPrefix(prefix);
    // Create route treatment
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(deviceMac).setOutput(outPort);
    // Create route meta
    TrafficSelector.Builder mbuilder = DefaultTrafficSelector.builder();
    // Adjust the meta according to VLAN configuration
    if (taggedVlans.contains(hostVlanId)) {
        tbuilder.setVlanId(hostVlanId);
    } else if (hostVlanId.equals(VlanId.NONE)) {
        if (untaggedVlan != null) {
            mbuilder.matchVlanId(untaggedVlan);
        } else if (nativeVlan != null) {
            mbuilder.matchVlanId(nativeVlan);
        } else {
            log.warn("Untagged nexthop {}/{} is not allowed on {} without untagged or native vlan", hostMac, hostVlanId, connectPoint);
            return null;
        }
    } else {
        log.warn("Tagged nexthop {}/{} is not allowed on {} without VLAN listed" + " in tagged vlan", hostMac, hostVlanId, connectPoint);
        return null;
    }
    // if the objective is to revoke an existing rule, and for some reason
    // the next-objective does not exist, then a new one should not be created
    int nextObjId = srManager.getMacVlanNextObjectiveId(deviceId, hostMac, hostVlanId, tbuilder.build(), mbuilder.build(), !revoke);
    if (nextObjId == -1) {
        // Warning log will come from getMacVlanNextObjective method
        return null;
    }
    return DefaultForwardingObjective.builder().withSelector(sbuilder.build()).nextStep(nextObjId).fromApp(srManager.appId).makePermanent().withPriority(getPriorityFromPrefix(prefix)).withFlag(ForwardingObjective.Flag.SPECIFIC);
}
#method_after
/**
 * Returns a forwarding objective builder for routing rules.
 * <p>
 * The forwarding objective routes packets destined to a given prefix to
 * given port on given device with given destination MAC.
 *
 * @param deviceId device ID
 * @param prefix prefix that need to be routed
 * @param hostMac MAC address of the nexthop
 * @param hostVlanId Vlan ID of the nexthop
 * @param outPort port where the nexthop attaches to
 * @param revoke true if forwarding objective is meant to revoke forwarding rule
 * @param directHost host is direct or indirect
 * @return forwarding objective builder
 * @throws DeviceConfigNotFoundException if given device is not configured
 */
private ForwardingObjective.Builder routingFwdObjBuilder(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort, boolean directHost, boolean revoke) throws DeviceConfigNotFoundException {
    MacAddress deviceMac;
    deviceMac = config.getDeviceMac(deviceId);
    int nextObjId = -1;
    ConnectPoint connectPoint = new ConnectPoint(deviceId, outPort);
    VlanId untaggedVlan = srManager.getUntaggedVlanId(connectPoint);
    Set<VlanId> taggedVlans = srManager.getTaggedVlanId(connectPoint);
    VlanId nativeVlan = srManager.getNativeVlanId(connectPoint);
    // Create route selector
    TrafficSelector.Builder sbuilder = buildIpSelectorFromIpPrefix(prefix);
    // Create route treatment
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(deviceMac).setOutput(outPort);
    // Create route meta
    TrafficSelector.Builder mbuilder = DefaultTrafficSelector.builder();
    // Adjust the meta according to VLAN configuration
    if (taggedVlans.contains(hostVlanId)) {
        tbuilder.setVlanId(hostVlanId);
    } else if (hostVlanId.equals(VlanId.NONE)) {
        if (untaggedVlan != null) {
            mbuilder.matchVlanId(untaggedVlan);
        } else if (nativeVlan != null) {
            mbuilder.matchVlanId(nativeVlan);
        } else {
            log.warn("Untagged nexthop {}/{} is not allowed on {} without untagged or native vlan", hostMac, hostVlanId, connectPoint);
            return null;
        }
    } else {
        log.warn("Tagged nexthop {}/{} is not allowed on {} without VLAN listed" + " in tagged vlan", hostMac, hostVlanId, connectPoint);
        return null;
    }
    if (directHost) {
        // if the objective is to revoke an existing rule, and for some reason
        // the next-objective does not exist, then a new one should not be created
        nextObjId = srManager.getPortNextObjectiveId(deviceId, outPort, tbuilder.build(), mbuilder.build(), !revoke);
    } else {
        // if the objective is to revoke an existing rule, and for some reason
        // the next-objective does not exist, then a new one should not be created
        nextObjId = srManager.getMacVlanNextObjectiveId(deviceId, hostMac, hostVlanId, tbuilder.build(), mbuilder.build(), !revoke);
    }
    if (nextObjId == -1) {
        // Warning log will come from getMacVlanNextObjective method
        return null;
    }
    return DefaultForwardingObjective.builder().withSelector(sbuilder.build()).nextStep(nextObjId).fromApp(srManager.appId).makePermanent().withPriority(getPriorityFromPrefix(prefix)).withFlag(ForwardingObjective.Flag.SPECIFIC);
}
#end_block

#method_before
boolean populateIpRuleForSubnet(DeviceId targetSw, Set<IpPrefix> subnets, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops) {
    for (IpPrefix subnet : subnets) {
        if (!populateIpRuleForRouter(targetSw, subnet, destSw1, destSw2, nextHops)) {
            return false;
        }
    }
    return true;
}
#method_after
boolean populateIpRuleForSubnet(DeviceId targetSw, Set<IpPrefix> subnets, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops) {
    // Get pair device of the target switch
    Optional<DeviceId> pairDev = srManager.getPairDeviceId(targetSw);
    // Route simplification will be off in case of the nexthop location at target switch is down
    // (routing through spine case)
    boolean routeSimplOff = pairDev.isPresent() && pairDev.get().equals(destSw1) && destSw2 == null;
    // If the target device is another leaf in the network
    if (srManager.routeSimplification && !routeSimplOff) {
        for (IpPrefix subnet : subnets) {
            // If route simplification applies
            if (routeSimplifierUtils.hasLeafExclusionEnabledForPrefix(subnet)) {
                // scenarios will not work properly.
                continue;
            }
            // populate the route in the remaning scenarios
            if (!populateIpRuleForRouter(targetSw, subnet, destSw1, destSw2, nextHops)) {
                return false;
            }
        }
    } else {
        // Populate IP flow rules for all the subnets.
        for (IpPrefix subnet : subnets) {
            if (!populateIpRuleForRouter(targetSw, subnet, destSw1, destSw2, nextHops)) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
public int getMacVlanNextObjectiveId(MacAddress macAddr, VlanId vlanId, TrafficTreatment treatment, TrafficSelector meta, boolean createIfMissing) {
    Integer nextId = macVlanNextObjStore.get(new MacVlanNextObjectiveStoreKey(deviceId, macAddr, VlanId.NONE));
    if (nextId != null) {
        return nextId;
    }
    log.debug("getMacVlanNextObjectiveId in device {}: Next objective id " + "not found for host : {} .. {}", deviceId, macAddr, (createIfMissing) ? "creating" : "aborting");
    if (!createIfMissing) {
        return -1;
    }
    /* create missing next objective */
    createGroupFromMacVlan(macAddr, vlanId, treatment, meta);
    nextId = macVlanNextObjStore.get(new MacVlanNextObjectiveStoreKey(deviceId, macAddr, vlanId));
    if (nextId == null) {
        log.warn("getMacVlanNextObjectiveId: unable to create next obj" + "for dev:{} host:{}/{}", deviceId, macAddr, vlanId);
        return -1;
    }
    return nextId;
}
#method_after
public int getMacVlanNextObjectiveId(MacAddress macAddr, VlanId vlanId, TrafficTreatment treatment, TrafficSelector meta, boolean createIfMissing) {
    Integer nextId = macVlanNextObjStore.get(new MacVlanNextObjectiveStoreKey(deviceId, macAddr, vlanId));
    if (nextId != null) {
        return nextId;
    }
    log.debug("getMacVlanNextObjectiveId in device {}: Next objective id " + "not found for host : {}/{} .. {}", deviceId, macAddr, vlanId, (createIfMissing) ? "creating" : "aborting");
    if (!createIfMissing) {
        return -1;
    }
    /* create missing next objective */
    nextId = createGroupFromMacVlan(macAddr, vlanId, treatment, meta);
    if (nextId == null) {
        log.warn("getMacVlanNextObjectiveId: unable to create next obj" + "for dev:{} host:{}/{}", deviceId, macAddr, vlanId);
        return -1;
    }
    return nextId;
}
#end_block

#method_before
public void createGroupFromMacVlan(MacAddress macAddr, VlanId vlanId, TrafficTreatment treatment, TrafficSelector meta) {
    int nextId = flowObjectiveService.allocateNextId();
    MacVlanNextObjectiveStoreKey key = new MacVlanNextObjectiveStoreKey(deviceId, macAddr, vlanId);
    NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.SIMPLE).addTreatment(treatment).fromApp(appId).withMeta(meta);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupFromMacVlan installed " + "NextObj {} on {}", nextId, deviceId), (objective, error) -> {
        log.warn("createGroupFromMacVlan failed to install NextObj {} on {}: {}", nextId, deviceId, error);
        srManager.invalidateNextObj(objective.id());
    });
    NextObjective nextObj = nextObjBuilder.add(context);
    flowObjectiveService.next(deviceId, nextObj);
    log.debug("createGroupFromMacVlan: Submited next objective {} in device {} " + "for host {}/{}", nextId, deviceId, macAddr, vlanId);
    macVlanNextObjStore.put(key, nextId);
}
#method_after
public int createGroupFromMacVlan(MacAddress macAddr, VlanId vlanId, TrafficTreatment treatment, TrafficSelector meta) {
    int nextId = flowObjectiveService.allocateNextId();
    MacVlanNextObjectiveStoreKey key = new MacVlanNextObjectiveStoreKey(deviceId, macAddr, vlanId);
    NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.SIMPLE).addTreatment(treatment).fromApp(appId).withMeta(meta);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupFromMacVlan installed " + "NextObj {} on {}", nextId, deviceId), (objective, error) -> {
        log.warn("createGroupFromMacVlan failed to install NextObj {} on {}: {}", nextId, deviceId, error);
        srManager.invalidateNextObj(objective.id());
    });
    NextObjective nextObj = nextObjBuilder.add(context);
    flowObjectiveService.next(deviceId, nextObj);
    log.debug("createGroupFromMacVlan: Submited next objective {} in device {} " + "for host {}/{}", nextId, deviceId, macAddr, vlanId);
    macVlanNextObjStore.put(key, nextId);
    return nextId;
}
#end_block

#method_before
/* end macvlan */
public void createGroupFromPort(PortNumber portNum, TrafficTreatment treatment, TrafficSelector meta) {
    int nextId = flowObjectiveService.allocateNextId();
    PortNextObjectiveStoreKey key = new PortNextObjectiveStoreKey(deviceId, portNum, treatment, meta);
    NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.SIMPLE).addTreatment(treatment).fromApp(appId).withMeta(meta);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupFromPort installed " + "NextObj {} on {}", nextId, deviceId), (objective, error) -> {
        log.warn("createGroupFromPort failed to install NextObj {} on {}: {}", nextId, deviceId, error);
        srManager.invalidateNextObj(objective.id());
    });
    NextObjective nextObj = nextObjBuilder.add(context);
    flowObjectiveService.next(deviceId, nextObj);
    log.debug("createGroupFromPort: Submited next objective {} in device {} " + "for port {}", nextId, deviceId, portNum);
    portNextObjStore.put(key, nextId);
}
#method_after
public void createGroupFromPort(PortNumber portNum, TrafficTreatment treatment, TrafficSelector meta) {
    int nextId = flowObjectiveService.allocateNextId();
    PortNextObjectiveStoreKey key = new PortNextObjectiveStoreKey(deviceId, portNum, treatment, meta);
    NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.SIMPLE).addTreatment(treatment).fromApp(appId).withMeta(meta);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupFromPort installed " + "NextObj {} on {}", nextId, deviceId), (objective, error) -> {
        log.warn("createGroupFromPort failed to install NextObj {} on {}: {}", nextId, deviceId, error);
        srManager.invalidateNextObj(objective.id());
    });
    NextObjective nextObj = nextObjBuilder.add(context);
    flowObjectiveService.next(deviceId, nextObj);
    log.debug("createGroupFromPort: Submited next objective {} in device {} " + "for port {}", nextId, deviceId, portNum);
    portNextObjStore.put(key, nextId);
}
#end_block

#method_before
public int getNextIdForHostPort(DeviceId deviceId, MacAddress hostMac, VlanId hostVlanId, PortNumber port) {
    MacAddress deviceMac;
    try {
        deviceMac = deviceConfig.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " in getNextIdForHostPort");
        return -1;
    }
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(deviceMac).setOutput(port);
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(hostVlanId).build();
    int nextId = srManager.getMacVlanNextObjectiveId(deviceId, hostMac, hostVlanId, tbuilder.build(), metadata, true);
    log.debug("getNextId : hostMac {}, deviceMac {}, port {}, hostVlanId {} Treatment {} Meta {} nextId {} ", hostMac, deviceMac, port, hostVlanId, tbuilder.build(), metadata, nextId);
    // TODO need a -1 check for above next ID ?
    return nextId;
}
#method_after
public int getNextIdForHostPort(MacAddress hostMac, VlanId hostVlanId, PortNumber port) {
    MacAddress deviceMac;
    try {
        deviceMac = deviceConfig.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " in getNextIdForHostPort");
        return -1;
    }
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(deviceMac).setVlanId(hostVlanId).setOutput(port);
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(hostVlanId).build();
    int nextId = getMacVlanNextObjectiveId(hostMac, hostVlanId, tbuilder.build(), metadata, true);
    log.debug("getNextId : hostMac {}, deviceMac {}, port {}, hostVlanId {} Treatment {} Meta {} nextId {} ", hostMac, deviceMac, port, hostVlanId, tbuilder.build(), metadata, nextId);
    return nextId;
}
#end_block

#method_before
public void updateL3UcastGroupBucket(DeviceId deviceId, MacAddress hostMac, VlanId hostVlanId, PortNumber port, int nextId) {
    MacAddress deviceMac;
    try {
        deviceMac = deviceConfig.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " in updateL3UcastGroupBucket");
        return;
    }
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(hostVlanId).build();
    int grpId = l2GroupId(hostVlanId, port.toLong());
    GroupId groupId = GroupId.valueOf(grpId);
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(deviceMac).setVlanId(hostVlanId).popVlan().setOutput(port);
    log.debug(" update L3Ucast : deviceMac {}, port {}, host {}/{}, nextid {} groupId {}, Treatment {} Meta {}", deviceMac, port, hostMac, hostVlanId, nextId, groupId, tbuilder.build(), metadata);
    NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.SIMPLE).fromApp(appId).addTreatment(tbuilder.build()).withMeta(metadata);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug(" NextId {} successfully updated host {} vlan {} with port {}", nextId, hostMac, hostVlanId, port), (objective, error) -> {
        log.warn(" NextId {} failed to update host {} vlan {} with port {}, error : {}", nextId, hostMac, hostVlanId, port, error);
        srManager.invalidateNextObj(objective.id());
    });
    NextObjective nextObj = nextObjBuilder.l3Modify(context);
    flowObjectiveService.next(deviceId, nextObj);
}
#method_after
public void updateL3UcastGroupBucket(MacAddress hostMac, VlanId hostVlanId, PortNumber port, int nextId) {
    MacAddress deviceMac;
    try {
        deviceMac = deviceConfig.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " in updateL3UcastGroupBucket");
        return;
    }
    TrafficSelector metadata = DefaultTrafficSelector.builder().matchVlanId(hostVlanId).build();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    tbuilder.deferred().setEthDst(hostMac).setEthSrc(deviceMac).setVlanId(hostVlanId).setOutput(port);
    log.debug(" update L3Ucast : deviceMac {}, port {}, host {}/{}, nextid {}, Treatment {} Meta {}", deviceMac, port, hostMac, hostVlanId, nextId, tbuilder.build(), metadata);
    NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.SIMPLE).fromApp(appId).addTreatment(tbuilder.build()).withMeta(metadata);
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug(" NextId {} successfully updated host {} vlan {} with port {}", nextId, hostMac, hostVlanId, port), (objective, error) -> {
        log.warn(" NextId {} failed to update host {} vlan {} with port {}, error : {}", nextId, hostMac, hostVlanId, port, error);
        srManager.invalidateNextObj(objective.id());
    });
    NextObjective nextObj = nextObjBuilder.modify(context);
    flowObjectiveService.next(deviceId, nextObj);
}
#end_block

#method_before
@Override
public String toString() {
    return " Device: " + deviceId + " Host: " + macAddr + "/" + vlanId;
}
#method_after
@Override
public String toString() {
    return toStringHelper(getClass()).add("deviceId", deviceId).add("vlanId", vlanId).add("macAddr", macAddr).toString();
}
#end_block

#method_before
private GroupInfo prepareL3UnicastGroup(NextObjective nextObj, NextGroup next) {
    ImmutableList.Builder<GroupInfo> groupInfoBuilder = ImmutableList.builder();
    TrafficTreatment treatment = nextObj.next().iterator().next();
    VlanId assignedVlan = readVlanFromSelector(nextObj.meta());
    if (assignedVlan == null) {
        log.warn("VLAN ID required by simple next obj is missing. Abort.");
        fail(nextObj, ObjectiveError.BADPARAMS);
    // return; TODO
    }
    List<GroupInfo> l2GroupInfos = prepareL2InterfaceGroup(nextObj, assignedVlan);
    GroupDescription l2InterfaceGroupDesc = l2GroupInfos.get(0).innerMostGroupDesc();
    GroupKey l2groupkey = l2InterfaceGroupDesc.appCookie();
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    MacAddress srcMac;
    MacAddress dstMac;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    dstMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthDst(dstMac);
                    break;
                case ETH_SRC:
                    srcMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthSrc(srcMac);
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    break;
                default:
                    break;
            }
        } else {
            log.debug("Driver does not handle this type of TrafficTreatment" + " instruction in l2l3chain:  {} - {}", ins.type(), ins);
        }
    }
    GroupId l2groupId = new GroupId(l2InterfaceGroupDesc.givenGroupId());
    outerTtb.group(l2groupId);
    // we need the top level group's key to point the flow to it
    List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
    GroupKey l3groupkey = gkeys.get(0).peekFirst();
    GroupId grpId = groupService.getGroup(deviceId, l3groupkey).id();
    int l3groupId = grpId.id();
    // create the l3unicast group description to wait for the
    // l2 interface group to be processed
    GroupBucket l3UnicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
    GroupDescription l3UnicastGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3UnicastGroupBucket)), l3groupkey, l3groupId, nextObj.appId());
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(l3UnicastGroupDescription, 1, false, deviceId);
    updatePendingGroups(l2groupkey, gce);
    log.debug("Trying L3-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextObj.id());
    groupInfoBuilder.add(new GroupInfo(l2InterfaceGroupDesc, l3UnicastGroupDescription));
    return groupInfoBuilder.build().iterator().next();
}
#method_after
private GroupInfo prepareL3UnicastGroup(NextObjective nextObj, NextGroup next) {
    ImmutableList.Builder<GroupInfo> groupInfoBuilder = ImmutableList.builder();
    TrafficTreatment treatment = nextObj.next().iterator().next();
    VlanId assignedVlan = readVlanFromSelector(nextObj.meta());
    if (assignedVlan == null) {
        log.warn("VLAN ID required by next obj is missing. Abort.");
        return null;
    }
    List<GroupInfo> l2GroupInfos = prepareL2InterfaceGroup(nextObj, assignedVlan);
    GroupDescription l2InterfaceGroupDesc = l2GroupInfos.get(0).innerMostGroupDesc();
    GroupKey l2groupkey = l2InterfaceGroupDesc.appCookie();
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    MacAddress srcMac;
    MacAddress dstMac;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    dstMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthDst(dstMac);
                    break;
                case ETH_SRC:
                    srcMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthSrc(srcMac);
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    outerTtb.setVlanId(vlanid);
                    break;
                default:
                    break;
            }
        } else {
            log.debug("Driver does not handle this type of TrafficTreatment" + " instruction in l2l3chain:  {} - {}", ins.type(), ins);
        }
    }
    GroupId l2groupId = new GroupId(l2InterfaceGroupDesc.givenGroupId());
    outerTtb.group(l2groupId);
    // we need the top level group's key to point the flow to it
    List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
    GroupKey l3groupkey = gkeys.get(0).peekFirst();
    GroupId grpId = groupService.getGroup(deviceId, l3groupkey).id();
    int l3groupId = grpId.id();
    // create the l3unicast group description to wait for the
    // l2 interface group to be processed
    GroupBucket l3UnicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
    GroupDescription l3UnicastGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3UnicastGroupBucket)), l3groupkey, l3groupId, nextObj.appId());
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(l3UnicastGroupDescription, 1, false, deviceId);
    updatePendingGroups(l2groupkey, gce);
    log.debug("Trying L3-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextObj.id());
    groupInfoBuilder.add(new GroupInfo(l2InterfaceGroupDesc, l3UnicastGroupDescription));
    return groupInfoBuilder.build().iterator().next();
}
#end_block

#method_before
/**
 * Modify buckets in the L2 interface group.
 *
 * @param nextObjective a next objective that contains information for the
 *                      buckets to be modified in the group
 * @param next the representation of the existing group-chains for this next
 *             objective, from which the innermost group buckets to remove are determined
 */
protected void modifyBucketFromGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.SIMPLE) {
        log.warn("ModifyBucketFromGroup cannot be applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    VlanId assignedVlan = readVlanFromSelector(nextObjective.meta());
    if (assignedVlan == null) {
        log.warn("VLAN ID required by simple next obj is missing. Abort.");
        fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    List<GroupInfo> groupInfos = prepareL2InterfaceGroup(nextObjective, assignedVlan);
    // There is only one L2 interface group in this case
    GroupDescription l2InterfaceGroupDesc = groupInfos.get(0).innerMostGroupDesc();
    // Replace group bucket for L2 interface group
    groupService.setBucketsForGroup(deviceId, l2InterfaceGroupDesc.appCookie(), l2InterfaceGroupDesc.buckets(), l2InterfaceGroupDesc.appCookie(), l2InterfaceGroupDesc.appId());
    // potentially stale copy of allActiveKeys
    synchronized (flowObjectiveStore) {
        List<Deque<GroupKey>> modifiedGroupKeys = Lists.newArrayList();
        ArrayDeque<GroupKey> top = new ArrayDeque<>();
        top.add(l2InterfaceGroupDesc.appCookie());
        modifiedGroupKeys.add(top);
        flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(modifiedGroupKeys, nextObjective));
    }
}
#method_after
protected void modifyBucketFromGroup(NextObjective nextObjective, NextGroup nextGroup) {
    switch(nextObjective.type()) {
        case SIMPLE:
            Collection<TrafficTreatment> treatments = nextObjective.next();
            if (treatments.size() != 1) {
                log.error("Next Objectives of type Simple should only have a " + "single Traffic Treatment. Next Objective Id:{}", nextObjective.id());
                fail(nextObjective, ObjectiveError.BADPARAMS);
                return;
            }
            modifySimpleNextObjective(nextObjective, nextGroup);
            break;
        default:
            fail(nextObjective, ObjectiveError.UNKNOWN);
            log.warn("Unknown next objective type {}", nextObjective.type());
    }
}
#end_block

#method_before
protected void modifyBucketInL3Group(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.SIMPLE) {
        log.debug("ModifyBucketInL3Group cannot be applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    // get l3 group
    GroupInfo groupInfo = prepareL3UnicastGroup(nextObjective, next);
    GroupDescription l3UnicastGroupDesc = groupInfo.nextGroupDesc();
    // Replace group bucket for L3 UC interface group
    groupService.setBucketsForGroup(deviceId, l3UnicastGroupDesc.appCookie(), l3UnicastGroupDesc.buckets(), l3UnicastGroupDesc.appCookie(), l3UnicastGroupDesc.appId());
    // create object for local and distributed storage
    Deque<GroupKey> gkeyChain = new ArrayDeque<>();
    gkeyChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
    gkeyChain.addFirst(groupInfo.nextGroupDesc().appCookie());
    List<Deque<GroupKey>> allGroupKeys = Lists.newArrayList();
    allGroupKeys.add(gkeyChain);
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObjective);
    // store l3groupkey with the ofdpaNextGroup for the nextObjective that depends on it
    updatePendingNextObjective(groupInfo.nextGroupDesc().appCookie(), ofdpaGrp);
    // potentially stale copy of allActiveKeys
    synchronized (flowObjectiveStore) {
        List<Deque<GroupKey>> modifiedGroupKeys = Lists.newArrayList();
        ArrayDeque<GroupKey> top = new ArrayDeque<>();
        top.add(l3UnicastGroupDesc.appCookie());
        // l2 group key
        top.add(groupInfo.innerMostGroupDesc().appCookie());
        modifiedGroupKeys.add(top);
        flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(modifiedGroupKeys, nextObjective));
    }
}
#method_after
protected void modifyBucketInL3Group(NextObjective nextObjective, NextGroup next) {
    // get l3 group
    GroupInfo groupInfo = prepareL3UnicastGroup(nextObjective, next);
    if (groupInfo == null) {
        log.warn("Null groupInfo retrieved for next obj. Abort.");
        fail(nextObjective, ObjectiveError.BADPARAMS);
        return;
    }
    GroupDescription l3UnicastGroupDesc = groupInfo.nextGroupDesc();
    // Replace group bucket for L3 UC interface group
    groupService.setBucketsForGroup(deviceId, l3UnicastGroupDesc.appCookie(), l3UnicastGroupDesc.buckets(), l3UnicastGroupDesc.appCookie(), l3UnicastGroupDesc.appId());
    // create object for local and distributed storage
    Deque<GroupKey> gkeyChain = new ArrayDeque<>();
    gkeyChain.addFirst(groupInfo.innerMostGroupDesc().appCookie());
    gkeyChain.addFirst(groupInfo.nextGroupDesc().appCookie());
    List<Deque<GroupKey>> allGroupKeys = Lists.newArrayList();
    allGroupKeys.add(gkeyChain);
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObjective);
    // store l3groupkey with the ofdpaNextGroup for the nextObjective that depends on it
    updatePendingNextObjective(groupInfo.nextGroupDesc().appCookie(), ofdpaGrp);
    // potentially stale copy of allActiveKeys
    synchronized (flowObjectiveStore) {
        List<Deque<GroupKey>> modifiedGroupKeys = Lists.newArrayList();
        ArrayDeque<GroupKey> top = new ArrayDeque<>();
        top.add(l3UnicastGroupDesc.appCookie());
        // l2 group key
        top.add(groupInfo.innerMostGroupDesc().appCookie());
        modifiedGroupKeys.add(top);
        flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(modifiedGroupKeys, nextObjective));
    }
}
#end_block

#method_before
@Override
public void next(NextObjective nextObjective) {
    NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
    switch(nextObjective.op()) {
        case ADD:
            if (nextGroup != null) {
                log.warn("Cannot add next {} that already exists in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {} in dev {} - add group", nextObjective.id(), deviceId);
            groupHandler.addGroup(nextObjective);
            break;
        case ADD_TO_EXISTING:
            if (nextGroup != null) {
                log.debug("Processing NextObjective id {} in dev {} - add bucket", nextObjective.id(), deviceId);
                groupHandler.addBucketToGroup(nextObjective, nextGroup);
            } else {
                // it is possible that group-chain has not been fully created yet
                log.debug("Waiting to add bucket to group for next-id:{} in dev:{}", nextObjective.id(), deviceId);
                // by design multiple pending bucket is allowed for the group
                groupHandler.pendingBuckets.compute(nextObjective.id(), (nextId, pendBkts) -> {
                    if (pendBkts == null) {
                        pendBkts = Sets.newHashSet();
                    }
                    pendBkts.add(nextObjective);
                    return pendBkts;
                });
            }
            break;
        case REMOVE:
            if (nextGroup == null) {
                log.warn("Cannot remove next {} that does not exist in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {}  in dev {} - remove group", nextObjective.id(), deviceId);
            groupHandler.removeGroup(nextObjective, nextGroup);
            break;
        case REMOVE_FROM_EXISTING:
            if (nextGroup == null) {
                log.warn("Cannot remove from next {} that does not exist in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {} in dev {} - remove bucket", nextObjective.id(), deviceId);
            groupHandler.removeBucketFromGroup(nextObjective, nextGroup);
            break;
        case MODIFY:
            if (nextGroup == null) {
                log.warn("Cannot modify next {} that does not exist in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {} in dev {} group {} - modify bucket", nextObjective.id(), deviceId, nextGroup);
            groupHandler.modifyBucketFromGroup(nextObjective, nextGroup);
            break;
        case MODIFY_L3:
            if (nextGroup == null) {
                log.warn("Cannot modify next {} that does not exist in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.warn("Processing NextObjective id {} in dev {} group {} - modify bucket", nextObjective.id(), deviceId, nextGroup);
            groupHandler.modifyBucketInL3Group(nextObjective, nextGroup);
            break;
        case VERIFY:
            if (nextGroup == null) {
                log.warn("Cannot verify next {} that does not exist in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {} in dev {} - verify", nextObjective.id(), deviceId);
            groupHandler.verifyGroup(nextObjective, nextGroup);
            break;
        default:
            log.warn("Unsupported operation {}", nextObjective.op());
    }
}
#method_after
@Override
public void next(NextObjective nextObjective) {
    NextGroup nextGroup = flowObjectiveStore.getNextGroup(nextObjective.id());
    switch(nextObjective.op()) {
        case ADD:
            if (nextGroup != null) {
                log.warn("Cannot add next {} that already exists in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {} in dev {} - add group", nextObjective.id(), deviceId);
            groupHandler.addGroup(nextObjective);
            break;
        case ADD_TO_EXISTING:
            if (nextGroup != null) {
                log.debug("Processing NextObjective id {} in dev {} - add bucket", nextObjective.id(), deviceId);
                groupHandler.addBucketToGroup(nextObjective, nextGroup);
            } else {
                // it is possible that group-chain has not been fully created yet
                log.debug("Waiting to add bucket to group for next-id:{} in dev:{}", nextObjective.id(), deviceId);
                // by design multiple pending bucket is allowed for the group
                groupHandler.pendingBuckets.compute(nextObjective.id(), (nextId, pendBkts) -> {
                    if (pendBkts == null) {
                        pendBkts = Sets.newHashSet();
                    }
                    pendBkts.add(nextObjective);
                    return pendBkts;
                });
            }
            break;
        case REMOVE:
            if (nextGroup == null) {
                log.warn("Cannot remove next {} that does not exist in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {}  in dev {} - remove group", nextObjective.id(), deviceId);
            groupHandler.removeGroup(nextObjective, nextGroup);
            break;
        case REMOVE_FROM_EXISTING:
            if (nextGroup == null) {
                log.warn("Cannot remove from next {} that does not exist in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {} in dev {} - remove bucket", nextObjective.id(), deviceId);
            groupHandler.removeBucketFromGroup(nextObjective, nextGroup);
            break;
        case MODIFY:
            if (nextGroup == null) {
                log.warn("Cannot modify next {} that does not exist in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {} in dev {} group {} - modify bucket", nextObjective.id(), deviceId, nextGroup);
            groupHandler.modifyBucketFromGroup(nextObjective, nextGroup);
            break;
        case VERIFY:
            if (nextGroup == null) {
                log.warn("Cannot verify next {} that does not exist in device {}", nextObjective.id(), deviceId);
                return;
            }
            log.debug("Processing NextObjective id {} in dev {} - verify", nextObjective.id(), deviceId);
            groupHandler.verifyGroup(nextObjective, nextGroup);
            break;
        default:
            log.warn("Unsupported operation {}", nextObjective.op());
    }
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    mainEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-main", "%d", log));
    hostEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-host", "%d", log));
    routeEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-route", "%d", log));
    mcastEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("sr-event-mcast", "%d", log));
    packetExecutor = Executors.newSingleThreadExecutor(groupedThreads("sr-packet", "%d", log));
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map macvlannextobjectivestore");
    EventuallyConsistentMapBuilder<MacVlanNextObjectiveStoreKey, Integer> macVlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    macVlanNextObjStore = macVlanNextObjMapBuilder.withName("macvlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    topologyHandler = new TopologyHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    topologyService.addListener(topologyListener);
    mastershipService.addListener(mastershipListener);
    clusterService.addListener(clusterListener);
    linkHandler.init();
    l2TunnelHandler.init();
    synchronized (networkConfigCompletionLock) {
        networkConfigCompletion.whenComplete((value, ex) -> {
            // setting to null for easier fall through
            networkConfigCompletion = null;
            // process all queued events
            queuedEvents.forEach(event -> {
                mainEventExecutor.execute(new InternalEventHandler(event));
            });
        });
    }
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    mainEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/sr", "event-main-%d", log));
    hostEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/sr", "event-host-%d", log));
    routeEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/sr", "event-route-%d", log));
    mcastEventExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/sr", "event-mcast-%d", log));
    packetExecutor = Executors.newSingleThreadExecutor(groupedThreads("onos/sr", "packet-%d", log));
    neighborExecutor = Executors.newFixedThreadPool(DEFAULT_POOL_SIZE, groupedThreads("onos/sr", "neighbor-%d", log));
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map macvlannextobjectivestore");
    EventuallyConsistentMapBuilder<MacVlanNextObjectiveStoreKey, Integer> macVlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    macVlanNextObjStore = macVlanNextObjMapBuilder.withName("macvlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    compCfgService.preSetProperty("org.onosproject.provider.lldp.impl.LldpLinkProvider", "staleLinkAge", "15000");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "allowDuplicateIps", "false");
    compCfgService.registerProperties(getClass());
    modified(context);
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    linkHandler = new LinkHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new DefaultL2TunnelHandler(this);
    topologyHandler = new TopologyHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    log.info("Configuring network before adding listeners");
    cfgListener.configureNetwork();
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    topologyService.addListener(topologyListener);
    mastershipService.addListener(mastershipListener);
    clusterService.addListener(clusterListener);
    linkHandler.init();
    l2TunnelHandler.init();
    synchronized (networkConfigCompletionLock) {
        networkConfigCompletion.whenComplete((value, ex) -> {
            // setting to null for easier fall through
            networkConfigCompletion = null;
            // process all queued events
            queuedEvents.forEach(event -> {
                mainEventExecutor.execute(new InternalEventHandler(event));
            });
        });
    }
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    mainEventExecutor.shutdown();
    hostEventExecutor.shutdown();
    routeEventExecutor.shutdown();
    mcastEventExecutor.shutdown();
    packetExecutor.shutdown();
    mainEventExecutor = null;
    hostEventExecutor = null;
    routeEventExecutor = null;
    mcastEventExecutor = null;
    packetExecutor = null;
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    topologyService.removeListener(topologyListener);
    mastershipService.removeListener(mastershipListener);
    clusterService.removeListener(clusterListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.forEach((k, v) -> v.shutdown());
    groupHandlerMap.clear();
    defaultRoutingHandler.shutdown();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    macVlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    mainEventExecutor.shutdown();
    hostEventExecutor.shutdown();
    routeEventExecutor.shutdown();
    mcastEventExecutor.shutdown();
    packetExecutor.shutdown();
    neighborExecutor.shutdown();
    mainEventExecutor = null;
    hostEventExecutor = null;
    routeEventExecutor = null;
    mcastEventExecutor = null;
    packetExecutor = null;
    neighborExecutor = null;
    cfgService.removeListener(cfgListener);
    cfgService.unregisterConfigFactory(deviceConfigFactory);
    cfgService.unregisterConfigFactory(appConfigFactory);
    cfgService.unregisterConfigFactory(xConnectConfigFactory);
    cfgService.unregisterConfigFactory(mcastConfigFactory);
    compCfgService.unregisterProperties(getClass(), false);
    hostService.removeListener(hostListener);
    packetService.removeProcessor(processor);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    multicastRouteService.removeListener(mcastListener);
    routeService.removeListener(routeListener);
    topologyService.removeListener(topologyListener);
    mastershipService.removeListener(mastershipListener);
    clusterService.removeListener(clusterListener);
    neighbourResolutionService.unregisterNeighbourHandlers(appId);
    processor = null;
    linkListener = null;
    deviceListener = null;
    groupHandlerMap.forEach((k, v) -> v.shutdown());
    groupHandlerMap.clear();
    defaultRoutingHandler.shutdown();
    dsNextObjStore.destroy();
    vlanNextObjStore.destroy();
    macVlanNextObjStore.destroy();
    portNextObjStore.destroy();
    tunnelStore.destroy();
    policyStore.destroy();
    mcastHandler.terminate();
    log.info("Stopped");
}
#end_block

#method_before
@Modified
private void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    if (properties == null) {
        return;
    }
    String strActiveProving = Tools.get(properties, "activeProbing");
    boolean expectActiveProbing = Boolean.parseBoolean(strActiveProving);
    if (expectActiveProbing != activeProbing) {
        activeProbing = expectActiveProbing;
        log.info("{} active probing", activeProbing ? "Enabling" : "Disabling");
    }
    String strSymmetricProving = Tools.get(properties, "symmetricProbing");
    boolean expectSymmetricProbing = Boolean.parseBoolean(strSymmetricProving);
    if (expectSymmetricProbing != symmetricProbing) {
        symmetricProbing = expectSymmetricProbing;
        log.info("{} symmetric probing", symmetricProbing ? "Enabling" : "Disabling");
    }
    String strSingleHomedDown = Tools.get(properties, "singleHomedDown");
    boolean expectSingleHomedDown = Boolean.parseBoolean(strSingleHomedDown);
    if (expectSingleHomedDown != singleHomedDown) {
        singleHomedDown = expectSingleHomedDown;
        log.info("{} downing of single homed hosts for lost uplinks", singleHomedDown ? "Enabling" : "Disabling");
        if (singleHomedDown && linkHandler != null) {
            hostService.getHosts().forEach(host -> host.locations().forEach(loc -> {
                if (interfaceService.isConfigured(loc)) {
                    linkHandler.checkUplinksForHost(loc);
                }
            }));
        } else {
            log.warn("Disabling singleHomedDown does not re-enable already " + "downed ports for single-homed hosts");
        }
    }
}
#method_after
@Modified
private void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    if (properties == null) {
        return;
    }
    String strActiveProving = Tools.get(properties, "activeProbing");
    boolean expectActiveProbing = Boolean.parseBoolean(strActiveProving);
    if (expectActiveProbing != activeProbing) {
        activeProbing = expectActiveProbing;
        log.info("{} active probing", activeProbing ? "Enabling" : "Disabling");
    }
    String strSymmetricProving = Tools.get(properties, "symmetricProbing");
    boolean expectSymmetricProbing = Boolean.parseBoolean(strSymmetricProving);
    if (expectSymmetricProbing != symmetricProbing) {
        symmetricProbing = expectSymmetricProbing;
        log.info("{} symmetric probing", symmetricProbing ? "Enabling" : "Disabling");
    }
    String strSingleHomedDown = Tools.get(properties, "singleHomedDown");
    boolean expectSingleHomedDown = Boolean.parseBoolean(strSingleHomedDown);
    if (expectSingleHomedDown != singleHomedDown) {
        singleHomedDown = expectSingleHomedDown;
        log.info("{} downing of single homed hosts for lost uplinks", singleHomedDown ? "Enabling" : "Disabling");
        if (singleHomedDown && linkHandler != null) {
            hostService.getHosts().forEach(host -> host.locations().forEach(loc -> {
                if (interfaceService.isConfigured(loc)) {
                    linkHandler.checkUplinksForHost(loc);
                }
            }));
        } else {
            log.warn("Disabling singleHomedDown does not re-enable already " + "downed ports for single-homed hosts");
        }
    }
    String strRouteSimplification = Tools.get(properties, "routeSimplification");
    boolean expectRouteSimplification = Boolean.parseBoolean(strRouteSimplification);
    if (expectRouteSimplification != routeSimplification) {
        routeSimplification = expectRouteSimplification;
        log.info("{} route simplification", routeSimplification ? "Enabling" : "Disabling");
    }
}
#end_block

#method_before
void processHostMovedEvent(HostEvent event) {
    Host host = event.subject();
    MacAddress hostMac = host.mac();
    VlanId hostVlanId = host.vlan();
    Set<HostLocation> prevLocations = event.prevSubject().locations();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    Set<HostLocation> newLocations = host.locations();
    Set<IpAddress> newIps = host.ipAddresses();
    log.info("Host {}/{} is moved from {} to {}", hostMac, hostVlanId, prevLocations, newLocations);
    Set<DeviceId> newDeviceIds = newLocations.stream().map(HostLocation::deviceId).collect(Collectors.toSet());
    // For each old location
    Sets.difference(prevLocations, newLocations).forEach(prevLocation -> {
        // Remove routing rules for old IPs
        Sets.difference(prevIps, newIps).forEach(ip -> processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true));
        // Redirect the flows to pair link if configured
        // Note: Do not continue removing any rule
        Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(prevLocation.deviceId());
        Optional<PortNumber> pairLocalPort = srManager.getPairLocalPort(prevLocation.deviceId());
        if (pairDeviceId.isPresent() && pairLocalPort.isPresent() && newLocations.stream().anyMatch(location -> location.deviceId().equals(pairDeviceId.get()))) {
            // NOTE: Since the pairLocalPort is trunk port, use assigned vlan of original port
            // when the host is untagged
            VlanId vlanId = Optional.ofNullable(srManager.getInternalVlanId(prevLocation)).orElse(hostVlanId);
            processBridgingRule(prevLocation.deviceId(), pairLocalPort.get(), hostMac, vlanId, false);
            newIps.forEach(ip -> processRoutingRule(prevLocation.deviceId(), pairLocalPort.get(), hostMac, vlanId, ip, false));
            return;
        }
        // Otherwise, do not remove and let the adding part update the old flow
        if (!newDeviceIds.contains(prevLocation.deviceId())) {
            processBridgingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, true);
            Sets.intersection(prevIps, newIps).forEach(ip -> processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true));
        }
        // Otherwise, do not remove and let the adding part update the old flow
        if (newLocations.stream().noneMatch(newLocation -> {
            VlanId oldAssignedVlan = srManager.getInternalVlanId(prevLocation);
            VlanId newAssignedVlan = srManager.getInternalVlanId(newLocation);
            // Host is tagged and the new location has the host vlan in vlan-tagged
            return srManager.getTaggedVlanId(newLocation).contains(hostVlanId) || (oldAssignedVlan != null && newAssignedVlan != null && // Host is untagged and the new location has the same assigned vlan
            oldAssignedVlan.equals(newAssignedVlan));
        })) {
            processBridgingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, true);
        }
        // Remove routing rules for unchanged IPs if none of the subnet of new location contains
        // the IP. Otherwise, do not remove and let the adding part update the old flow
        Sets.intersection(prevIps, newIps).forEach(ip -> {
            if (newLocations.stream().noneMatch(newLocation -> srManager.deviceConfiguration.inSameSubnet(newLocation, ip))) {
                processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true);
            }
        });
    });
    // For each new location, add all new IPs.
    Sets.difference(newLocations, prevLocations).forEach(newLocation -> {
        processBridgingRule(newLocation.deviceId(), newLocation.port(), hostMac, hostVlanId, false);
        newIps.forEach(ip -> processRoutingRule(newLocation.deviceId(), newLocation.port(), hostMac, hostVlanId, ip, false));
        // But will also cover [1A/x] -> [1A/y] -> [1A/y, 1B/y]
        if (srManager.activeProbing) {
            srManager.getPairDeviceId(newLocation.deviceId()).ifPresent(pairDeviceId -> srManager.getPairLocalPort(pairDeviceId).ifPresent(pairRemotePort -> probe(host, newLocation, pairDeviceId, pairRemotePort)));
        }
    });
    // For each unchanged location, add new IPs and remove old IPs.
    Sets.intersection(newLocations, prevLocations).forEach(unchangedLocation -> {
        Sets.difference(prevIps, newIps).forEach(ip -> processRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, hostVlanId, ip, true));
        Sets.difference(newIps, prevIps).forEach(ip -> processRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, hostVlanId, ip, false));
        // Verify existing location and see if it is still valid
        srManager.probingService.probeHost(host, unchangedLocation, ProbeMode.VERIFY);
    });
    // ensure dual-homed host locations have viable uplinks
    if (newLocations.size() > prevLocations.size() || srManager.singleHomedDown) {
        newLocations.forEach(loc -> {
            if (srManager.mastershipService.isLocalMaster(loc.deviceId())) {
                srManager.linkHandler.checkUplinksForHost(loc);
            }
        });
    }
}
#method_after
void processHostMovedEvent(HostEvent event) {
    Host host = event.subject();
    MacAddress hostMac = host.mac();
    VlanId hostVlanId = host.vlan();
    Set<HostLocation> prevLocations = event.prevSubject().locations();
    Set<IpAddress> prevIps = event.prevSubject().ipAddresses();
    Set<HostLocation> newLocations = host.locations();
    Set<IpAddress> newIps = host.ipAddresses();
    log.info("Host {}/{} is moved from {} to {}", hostMac, hostVlanId, prevLocations, newLocations);
    Set<DeviceId> newDeviceIds = newLocations.stream().map(HostLocation::deviceId).collect(Collectors.toSet());
    // For each old location
    Sets.difference(prevLocations, newLocations).forEach(prevLocation -> {
        // Remove routing rules for old IPs
        Sets.difference(prevIps, newIps).forEach(ip -> processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true));
        // Redirect the flows to pair link if configured
        // Note: Do not continue removing any rule
        Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(prevLocation.deviceId());
        Optional<PortNumber> pairLocalPort = srManager.getPairLocalPort(prevLocation.deviceId());
        if (pairDeviceId.isPresent() && pairLocalPort.isPresent() && newLocations.stream().anyMatch(location -> location.deviceId().equals(pairDeviceId.get())) && newLocations.stream().noneMatch(location -> location.deviceId().equals(prevLocation.deviceId()))) {
            // NOTE: Since the pairLocalPort is trunk port, use assigned vlan of original port
            // when the host is untagged
            VlanId vlanId = Optional.ofNullable(srManager.getInternalVlanId(prevLocation)).orElse(hostVlanId);
            processBridgingRule(prevLocation.deviceId(), pairLocalPort.get(), hostMac, vlanId, false);
            newIps.forEach(ip -> processRoutingRule(prevLocation.deviceId(), pairLocalPort.get(), hostMac, vlanId, ip, false));
            return;
        }
        // Otherwise, do not remove and let the adding part update the old flow
        if (!newDeviceIds.contains(prevLocation.deviceId())) {
            processBridgingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, true);
            Sets.intersection(prevIps, newIps).forEach(ip -> processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true));
        }
        // Otherwise, do not remove and let the adding part update the old flow
        if (newLocations.stream().noneMatch(newLocation -> {
            VlanId oldAssignedVlan = srManager.getInternalVlanId(prevLocation);
            VlanId newAssignedVlan = srManager.getInternalVlanId(newLocation);
            // Host is tagged and the new location has the host vlan in vlan-tagged
            return srManager.getTaggedVlanId(newLocation).contains(hostVlanId) || (oldAssignedVlan != null && newAssignedVlan != null && // Host is untagged and the new location has the same assigned vlan
            oldAssignedVlan.equals(newAssignedVlan));
        })) {
            processBridgingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, true);
        }
        // Remove routing rules for unchanged IPs if none of the subnet of new location contains
        // the IP. Otherwise, do not remove and let the adding part update the old flow
        Sets.intersection(prevIps, newIps).forEach(ip -> {
            if (newLocations.stream().noneMatch(newLocation -> srManager.deviceConfiguration.inSameSubnet(newLocation, ip))) {
                processRoutingRule(prevLocation.deviceId(), prevLocation.port(), hostMac, hostVlanId, ip, true);
            }
        });
    });
    // For each new location, add all new IPs.
    Sets.difference(newLocations, prevLocations).forEach(newLocation -> {
        processBridgingRule(newLocation.deviceId(), newLocation.port(), hostMac, hostVlanId, false);
        newIps.forEach(ip -> processRoutingRule(newLocation.deviceId(), newLocation.port(), hostMac, hostVlanId, ip, false));
        // But will also cover [1A/x] -> [1A/y] -> [1A/y, 1B/y]
        if (srManager.activeProbing) {
            srManager.getPairDeviceId(newLocation.deviceId()).ifPresent(pairDeviceId -> srManager.getPairLocalPort(pairDeviceId).ifPresent(pairRemotePort -> probe(host, newLocation, pairDeviceId, pairRemotePort)));
        }
    });
    // For each unchanged location, add new IPs and remove old IPs.
    Sets.intersection(newLocations, prevLocations).forEach(unchangedLocation -> {
        Sets.difference(prevIps, newIps).forEach(ip -> processRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, hostVlanId, ip, true));
        Sets.difference(newIps, prevIps).forEach(ip -> processRoutingRule(unchangedLocation.deviceId(), unchangedLocation.port(), hostMac, hostVlanId, ip, false));
        // Verify existing location and see if it is still valid
        srManager.probingService.probeHost(host, unchangedLocation, ProbeMode.VERIFY);
    });
    // ensure dual-homed host locations have viable uplinks
    if (newLocations.size() > prevLocations.size() || srManager.singleHomedDown) {
        newLocations.forEach(loc -> {
            if (srManager.mastershipService.isLocalMaster(loc.deviceId())) {
                srManager.linkHandler.checkUplinksForHost(loc);
            }
        });
    }
}
#end_block

#method_before
private void processRoutingRule(DeviceId deviceId, PortNumber port, MacAddress mac, VlanId vlanId, IpAddress ip, boolean revoke) {
    ConnectPoint location = new ConnectPoint(deviceId, port);
    if (!srManager.deviceConfiguration.inSameSubnet(location, ip)) {
        log.info("{} is not included in the subnet config of {}/{}. Ignored.", ip, deviceId, port);
        return;
    }
    log.info("{} routing rule for {} at {}", revoke ? "Revoking" : "Populating", ip, location);
    if (revoke) {
        srManager.defaultRoutingHandler.revokeHostRoute(deviceId, ip.toIpPrefix(), mac, vlanId, port);
    } else {
        srManager.defaultRoutingHandler.populateHostRoute(deviceId, ip.toIpPrefix(), mac, vlanId, port);
    }
}
#method_after
private void processRoutingRule(DeviceId deviceId, PortNumber port, MacAddress mac, VlanId vlanId, IpAddress ip, boolean revoke) {
    ConnectPoint location = new ConnectPoint(deviceId, port);
    if (!srManager.deviceConfiguration.inSameSubnet(location, ip)) {
        log.info("{} is not included in the subnet config of {}/{}. Ignored.", ip, deviceId, port);
        return;
    }
    log.info("{} routing rule for {} at {}", revoke ? "Revoking" : "Populating", ip, location);
    if (revoke) {
        srManager.defaultRoutingHandler.revokeRoute(deviceId, ip.toIpPrefix(), mac, vlanId, port, true);
    } else {
        srManager.defaultRoutingHandler.populateRoute(deviceId, ip.toIpPrefix(), mac, vlanId, port, true);
    }
}
#end_block

#method_before
void processIntfIpUpdatedEvent(ConnectPoint cp, Set<IpPrefix> ipPrefixSet, boolean install) {
    Set<Host> hosts = hostService.getConnectedHosts(cp);
    if (hosts == null || hosts.size() == 0) {
        log.debug("processIntfIpUpdatedEvent: No hosts connected to {}", cp);
        return;
    }
    // Check whether the host IP address is in the interface's subnet
    hosts.forEach(host -> host.ipAddresses().forEach(hostIpAddress -> {
        ipPrefixSet.forEach(ipPrefix -> {
            if (install && ipPrefix.contains(hostIpAddress)) {
                srManager.defaultRoutingHandler.populateHostRoute(cp.deviceId(), hostIpAddress.toIpPrefix(), host.mac(), host.vlan(), cp.port());
            } else if (!install && ipPrefix.contains(hostIpAddress)) {
                srManager.defaultRoutingHandler.revokeHostRoute(cp.deviceId(), hostIpAddress.toIpPrefix(), host.mac(), host.vlan(), cp.port());
            }
        });
    }));
}
#method_after
void processIntfIpUpdatedEvent(ConnectPoint cp, Set<IpPrefix> ipPrefixSet, boolean install) {
    Set<Host> hosts = hostService.getConnectedHosts(cp);
    if (hosts == null || hosts.size() == 0) {
        log.debug("processIntfIpUpdatedEvent: No hosts connected to {}", cp);
        return;
    }
    // Check whether the host IP address is in the interface's subnet
    hosts.forEach(host -> host.ipAddresses().forEach(hostIpAddress -> {
        ipPrefixSet.forEach(ipPrefix -> {
            if (install && ipPrefix.contains(hostIpAddress)) {
                srManager.defaultRoutingHandler.populateRoute(cp.deviceId(), hostIpAddress.toIpPrefix(), host.mac(), host.vlan(), cp.port(), true);
            } else if (!install && ipPrefix.contains(hostIpAddress)) {
                srManager.defaultRoutingHandler.revokeRoute(cp.deviceId(), hostIpAddress.toIpPrefix(), host.mac(), host.vlan(), cp.port(), true);
            }
        });
    }));
}
#end_block

#method_before
void populateRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort) {
    if (shouldProgram(deviceId)) {
        srManager.routingRulePopulator.populateRoute(deviceId, prefix, hostMac, hostVlanId, outPort);
    }
}
#method_after
void populateRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort, boolean directHost) {
    if (shouldProgram(deviceId)) {
        srManager.routingRulePopulator.populateRoute(deviceId, prefix, hostMac, hostVlanId, outPort, directHost);
    }
}
#end_block

#method_before
void revokeRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort) {
    if (shouldProgram(deviceId)) {
        srManager.routingRulePopulator.revokeRoute(deviceId, prefix, hostMac, hostVlanId, outPort);
    }
}
#method_after
void revokeRoute(DeviceId deviceId, IpPrefix prefix, MacAddress hostMac, VlanId hostVlanId, PortNumber outPort, boolean directHost) {
    if (shouldProgram(deviceId)) {
        srManager.routingRulePopulator.revokeRoute(deviceId, prefix, hostMac, hostVlanId, outPort, directHost);
    }
}
#end_block

#method_before
private void resetEvents(Dpid dpid) {
    FlowStatsCollector collector = simpleCollectors.get(dpid);
    if (collector != null) {
        collector.resetEvents();
    }
}
#method_after
private void resetEvents(Dpid dpid) {
    SwitchDataCollector collector;
    if (adaptiveFlowSampling) {
        collector = afsCollectors.get(dpid);
    } else {
        collector = simpleCollectors.get(dpid);
    }
    if (collector != null) {
        collector.resetEvents();
    }
}
#end_block

#method_before
private void recordEvents(Dpid dpid, int events) {
    FlowStatsCollector collector = simpleCollectors.get(dpid);
    if (collector != null) {
        collector.recordEvents(events);
    }
}
#method_after
private void recordEvents(Dpid dpid, int events) {
    SwitchDataCollector collector;
    if (adaptiveFlowSampling) {
        collector = afsCollectors.get(dpid);
    } else {
        collector = simpleCollectors.get(dpid);
    }
    if (collector != null) {
        collector.recordEvents(events);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(Dpid.uri(dpid));
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(deviceId, removed, getDriver(deviceId)).build();
            providerService.flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg, getDriver(deviceId));
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.TABLE) {
                pushTableStatistics(dpid, (OFTableStatsReply) msg);
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW_LIGHTWEIGHT) {
                pushFlowLightWeightMetrics(dpid, (OFFlowLightweightStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            handleErrorMsg(deviceId, msg);
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(Dpid.uri(dpid));
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(deviceId, removed, getDriver(deviceId)).build();
            providerService.flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                // Let's unblock first the collector
                SwitchDataCollector collector;
                if (adaptiveFlowSampling) {
                    collector = afsCollectors.get(dpid);
                } else {
                    collector = simpleCollectors.get(dpid);
                }
                if (collector != null) {
                    collector.received();
                }
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg, getDriver(deviceId));
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.TABLE) {
                pushTableStatistics(dpid, (OFTableStatsReply) msg);
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW_LIGHTWEIGHT) {
                pushFlowLightWeightMetrics(dpid, (OFFlowLightweightStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            handleErrorMsg(deviceId, msg);
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
public long getWindowCount(int slots) {
    checkArgument(slots <= windowSlots, "Requested window must be less than the total window slots");
    long sum = 0;
    for (int i = 0; i < slots; i++) {
        int currentIndex = headSlot - i;
        if (currentIndex < 0) {
            currentIndex = counters.size() + currentIndex;
        }
        sum += counters.get(currentIndex).get();
    }
    return sum;
}
#method_after
public long getWindowCount(int slots) {
    checkArgument(slots <= windowSlots, "Requested window must be less than the total window slots");
    long sum = 0;
    slots = min(slots, counters.size());
    for (int i = 0; i < slots; i++) {
        int currentIndex = headSlot - i;
        if (currentIndex < 0) {
            currentIndex = counters.size() + currentIndex;
        }
        sum += counters.get(currentIndex).get();
    }
    return sum;
}
#end_block

#method_before
public double getWindowRate(int slots) {
    return getWindowCount(slots) / (double) slots;
}
#method_after
public double getWindowRate(int slots) {
    return getWindowCount(slots) / (double) min(slots, counters.size());
}
#end_block

#method_before
void advanceHead() {
    counters.get(slotAfter(headSlot)).set(0);
    headSlot = slotAfter(headSlot);
    totalSlots.incrementAndGet();
}
#method_after
void advanceHead() {
    if (counters.size() - 1 < slotAfter(headSlot)) {
        counters.add(0, new AtomicLong(0));
    } else {
        counters.get(slotAfter(headSlot)).set(0);
        headSlot = slotAfter(headSlot);
    }
    totalSlots.incrementAndGet();
}
#end_block

#method_before
synchronized void adjustPollInterval(int pollInterval) {
    this.pollInterval = pollInterval;
    pollTask.cancel();
    pollTask = new PollTimerTask();
    timer.scheduleAtFixedRate(pollTask, pollInterval * SECONDS, pollInterval * 1000);
}
#method_after
synchronized void adjustPollInterval(int pollInterval) {
    this.pollInterval = pollInterval;
    if (pollTask != null) {
        pollTask.cancel();
    }
    // If we went through start - let's schedule it
    if (loadCounter != null) {
        pollTask = new PollTimerTask();
        timer.scheduleAtFixedRate(pollTask, pollInterval * SECONDS, pollInterval * SECONDS);
    }
}
#end_block

#method_before
synchronized void resetEvents() {
    loadCounter.destroy();
    loadCounter = new SlidingWindowCounter(LOAD_WINDOW);
    if (paused.compareAndSet(true, false)) {
        resume();
    }
}
#method_after
@Override
public synchronized void resetEvents() {
    loadCounter.clear();
    if (paused.compareAndSet(true, false)) {
        resume();
    }
    // Let's reset also waiting, the reply can be discarded/lost
    // during a change of mastership
    waiting.set(false);
}
#end_block

#method_before
void recordEvents(int events) {
    loadCounter.incrementCount(events);
}
#method_after
@Override
public void recordEvents(int events) {
    SlidingWindowCounter loadCounter = this.loadCounter;
    if (loadCounter != null) {
        loadCounter.incrementCount(events);
    }
}
#end_block

#method_before
@Override
public void run() {
    if (isUnderHighLoad()) {
        if (paused.compareAndSet(false, true)) {
            pause();
        }
    } else if (paused.compareAndSet(true, false)) {
        resume();
    }
}
#method_after
@Override
public void run() {
    if (isHighLoad()) {
        if (paused.compareAndSet(false, true)) {
            pause();
        }
    } else if (isLowLoad()) {
        if (paused.compareAndSet(true, false)) {
            resume();
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        // batch was pushed immediately prior to this task running.
        if (isUnderHighLoad()) {
            log.debug("Skipping stats collection for {} due to high load", sw.getStringId());
            return;
        }
        log.trace("Collecting stats for {}", sw.getStringId());
        OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(sw.factory().matchWildcardAll()).setTableId(TableId.ALL).setOutPort(OFPort.NO_MASK).build();
        sw.sendMsg(request);
    }
}
#method_after
@Override
public void run() {
    // Check whether we are still waiting a previous reply
    if (sw.getRole() == RoleState.MASTER && !waiting.get()) {
        // batch was pushed immediately prior to this task running.
        if (isHighLoad()) {
            log.debug("Skipping stats collection for {} due to high load; rate: {}; overall: {}", sw.getStringId(), loadCounter.getWindowRate(PAUSE_WINDOW), loadCounter.getWindowRate(HIGH_WINDOW));
            return;
        } else {
            log.debug("Permitting stats collection for {}; rate: {}; overall: {}", sw.getStringId(), loadCounter.getWindowRate(PAUSE_WINDOW), loadCounter.getWindowRate(HIGH_WINDOW));
        }
        log.trace("Collecting stats for {}", sw.getStringId());
        OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(sw.factory().matchWildcardAll()).setTableId(TableId.ALL).setOutPort(OFPort.NO_MASK).build();
        sw.sendMsg(request);
        // Other flow stats will not be asked
        // if we don't see first the reply of this request
        waiting.set(true);
    }
}
#end_block

#method_before
public synchronized void start() {
    // Initially start polling quickly. Then drop down to configured value
    log.debug("Starting Stats collection thread for {}", sw.getStringId());
    pauseTask = new PauseTimerTask();
    timer.scheduleAtFixedRate(pauseTask, 1 * SECONDS, 1 * SECONDS);
    pollTask = new PollTimerTask();
    timer.scheduleAtFixedRate(pollTask, 1 * SECONDS, pollInterval * SECONDS);
}
#method_after
public synchronized void start() {
    // Initially start polling quickly. Then drop down to configured value
    log.debug("Starting Stats collection thread for {}", sw.getStringId());
    loadCounter = new SlidingWindowCounter(HIGH_WINDOW);
    pauseTask = new PauseTimerTask();
    timer.scheduleAtFixedRate(pauseTask, 1 * SECONDS, 1 * SECONDS);
    pollTask = new PollTimerTask();
    timer.scheduleAtFixedRate(pollTask, 1 * SECONDS, pollInterval * SECONDS);
}
#end_block

#method_before
private synchronized void pause() {
    if (pollTask != null) {
        log.debug("Pausing stats collection for {}", sw.getStringId());
        pollTask.cancel();
        pollTask = null;
    }
}
#method_after
private synchronized void pause() {
    if (pollTask != null) {
        log.debug("Pausing stats collection for {}; rate: {}; overall: {}", sw.getStringId(), loadCounter.getWindowRate(PAUSE_WINDOW), loadCounter.getWindowRate(HIGH_WINDOW));
        pollTask.cancel();
        pollTask = null;
    }
}
#end_block

#method_before
private synchronized void resume() {
    log.debug("Resuming stats collection for {}", sw.getStringId());
    pollTask = new PollTimerTask();
    timer.scheduleAtFixedRate(pollTask, 1 * SECONDS, pollInterval * SECONDS);
}
#method_after
private synchronized void resume() {
    log.debug("Resuming stats collection for {}; rate: {}; overall: {}", sw.getStringId(), loadCounter.getWindowRate(PAUSE_WINDOW), loadCounter.getWindowRate(HIGH_WINDOW));
    pollTask = new PollTimerTask();
    timer.scheduleAtFixedRate(pollTask, pollInterval * SECONDS, pollInterval * SECONDS);
}
#end_block

#method_before
public synchronized void stop() {
    if (pauseTask != null) {
        pauseTask.cancel();
        pauseTask = null;
    }
    if (pollTask != null) {
        log.debug("Stopping Stats collection thread for {}", sw.getStringId());
        pollTask.cancel();
        pollTask = null;
    }
}
#method_after
public synchronized void stop() {
    if (pauseTask != null) {
        pauseTask.cancel();
        pauseTask = null;
    }
    if (pollTask != null) {
        log.debug("Stopping Stats collection thread for {}", sw.getStringId());
        pollTask.cancel();
        pollTask = null;
    }
    if (loadCounter != null) {
        loadCounter.destroy();
        loadCounter = null;
    }
}
#end_block

#method_before
private void addSubnetConfig(ConnectPoint cp, Set<InterfaceIpAddress> ipAddressSet) {
    Set<IpPrefix> ipPrefixSet = ipAddressSet.stream().map(InterfaceIpAddress::subnetAddress).collect(Collectors.toSet());
    Set<InterfaceIpAddress> deviceIntfIpAddrs = interfaceService.getInterfaces().stream().filter(intf -> intf.connectPoint().deviceId().equals(cp.deviceId())).filter(intf -> !intf.connectPoint().equals(cp)).flatMap(intf -> intf.ipAddressesList().stream()).collect(Collectors.toSet());
    // 1. Partial subnet population
    // Add routing rules for newly added subnet, which does not also exist in
    // other interfaces in the same device
    Set<IpPrefix> deviceIpPrefixSet = deviceIntfIpAddrs.stream().map(InterfaceIpAddress::subnetAddress).collect(Collectors.toSet());
    defaultRoutingHandler.populateSubnet(Collections.singleton(cp), ipPrefixSet.stream().filter(ipPrefix -> !deviceIpPrefixSet.contains(ipPrefix)).collect(Collectors.toSet()), null);
    // 2. Interface IP punts
    // Add IP punts for new Intf address
    Set<IpAddress> deviceIpAddrs = deviceIntfIpAddrs.stream().map(InterfaceIpAddress::ipAddress).collect(Collectors.toSet());
    ipAddressSet.stream().map(InterfaceIpAddress::ipAddress).filter(interfaceIpAddress -> !deviceIpAddrs.contains(interfaceIpAddress)).forEach(interfaceIpAddress -> routingRulePopulator.populateSingleIpPunts(cp.deviceId(), interfaceIpAddress));
    // 3. Host unicast routing rule
    // Add unicast routing rule
    hostEventExecutor.execute(() -> hostHandler.processIntfIpUpdatedEvent(cp, ipPrefixSet, true));
}
#method_after
private void addSubnetConfig(ConnectPoint cp, Set<InterfaceIpAddress> ipAddressSet) {
    Set<IpPrefix> ipPrefixSet = ipAddressSet.stream().map(InterfaceIpAddress::subnetAddress).collect(Collectors.toSet());
    Set<InterfaceIpAddress> deviceIntfIpAddrs = interfaceService.getInterfaces().stream().filter(intf -> intf.connectPoint().deviceId().equals(cp.deviceId())).filter(intf -> !intf.connectPoint().equals(cp)).flatMap(intf -> intf.ipAddressesList().stream()).collect(Collectors.toSet());
    // 1. Partial subnet population
    // Add routing rules for newly added subnet, which does not also exist in
    // other interfaces in the same device
    Set<IpPrefix> deviceIpPrefixSet = deviceIntfIpAddrs.stream().map(InterfaceIpAddress::subnetAddress).collect(Collectors.toSet());
    defaultRoutingHandler.populateSubnet(Collections.singleton(cp), ipPrefixSet.stream().filter(ipPrefix -> !deviceIpPrefixSet.contains(ipPrefix)).collect(Collectors.toSet()));
    // 2. Interface IP punts
    // Add IP punts for new Intf address
    Set<IpAddress> deviceIpAddrs = deviceIntfIpAddrs.stream().map(InterfaceIpAddress::ipAddress).collect(Collectors.toSet());
    ipAddressSet.stream().map(InterfaceIpAddress::ipAddress).filter(interfaceIpAddress -> !deviceIpAddrs.contains(interfaceIpAddress)).forEach(interfaceIpAddress -> routingRulePopulator.populateSingleIpPunts(cp.deviceId(), interfaceIpAddress));
    // 3. Host unicast routing rule
    // Add unicast routing rule
    hostEventExecutor.execute(() -> hostHandler.processIntfIpUpdatedEvent(cp, ipPrefixSet, true));
}
#end_block

#method_before
private boolean hasLeafExclusionEnabledForType(Route.Source s) {
    return leafExclusionRouteTypes.contains(s);
}
#method_after
private boolean hasLeafExclusionEnabledForType(Route.Source s) {
    return LEAF_EXCLUSION_ROUTE_TYPES.contains(s);
}
#end_block

#method_before
boolean populateIpRuleForSubnet(DeviceId targetSw, Set<IpPrefix> subnets, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops, DeviceId srcSw) {
    // Otherwise, populate all the configured subnets.
    if (srcSw == null) {
        RouteSimplifierUtils routeSimplifierUtils = new RouteSimplifierUtils(srManager);
        subnets = subnets.stream().filter(subnet -> srManager.routeSimplification && !routeSimplifierUtils.hasLeafExclusionEnabledForPrefix(subnet)).collect(Collectors.toSet());
    }
    for (IpPrefix subnet : subnets) {
        if (!populateIpRuleForRouter(targetSw, subnet, destSw1, destSw2, nextHops)) {
            return false;
        }
    }
    return true;
}
#method_after
boolean populateIpRuleForSubnet(DeviceId targetSw, Set<IpPrefix> subnets, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops) {
    // Get pair device of the target switch
    Optional<DeviceId> pairDev = srManager.getPairDeviceId(targetSw);
    // Route simplification will be off in case of the nexthop location at target switch is down
    // (routing through spine case)
    boolean routeSimplOff = pairDev.isPresent() && pairDev.get().equals(destSw1) && destSw2 == null;
    // If the target device is another leaf in the network
    if (srManager.routeSimplification && !routeSimplOff) {
        for (IpPrefix subnet : subnets) {
            // If route simplification applies
            if (routeSimplifierUtils.hasLeafExclusionEnabledForPrefix(subnet)) {
                // scenarios will not work properly.
                continue;
            }
            // populate the route in the remaning scenarios
            if (!populateIpRuleForRouter(targetSw, subnet, destSw1, destSw2, nextHops)) {
                return false;
            }
        }
    } else {
        // Populate IP flow rules for all the subnets.
        for (IpPrefix subnet : subnets) {
            if (!populateIpRuleForRouter(targetSw, subnet, destSw1, destSw2, nextHops)) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean isNext(WorkflowContext context) throws WorkflowException {
    if (strOfDevIdOverlay == null) {
        strOfDevIdOverlay = OvsUtil.buildOfDeviceId(IpAddress.valueOf(strMgmtIp), DEVID_IDX_BRIDGE_OVERLAY).toString();
    }
    if (strOfDevIdUnderlay == null) {
        strOfDevIdUnderlay = OvsUtil.buildOfDeviceId(IpAddress.valueOf(strMgmtIp), DEVID_IDX_BRIDGE_UNDERLAY_NOVA).toString();
    }
    if (isOverlayDevicePresent && context.getService(DeviceService.class).getDevice(DeviceId.deviceId(strOfDevIdOverlay)) == null) {
        isOverlayDevicePresent = false;
    }
    if (isUnderlayDevicePresent && context.getService(DeviceService.class).getDevice(DeviceId.deviceId(strOfDevIdUnderlay)) == null) {
        isUnderlayDevicePresent = false;
    }
    return (isOverlayDevicePresent || isUnderlayDevicePresent);
}
#method_after
@Override
public boolean isNext(WorkflowContext context) throws WorkflowException {
    boolean isOfDevicePresent = true;
    if (ofDevId == null) {
        ofDevId = JsonNodeFactory.instance.objectNode();
        ofDevId.put(String.valueOf(DEVID_IDX_BRIDGE_OVERLAY), OvsUtil.buildOfDeviceId(IpAddress.valueOf(strMgmtIp), DEVID_IDX_BRIDGE_OVERLAY).toString());
        ofDevId.put(String.valueOf(DEVID_IDX_BRIDGE_UNDERLAY_NOVA), OvsUtil.buildOfDeviceId(IpAddress.valueOf(strMgmtIp), DEVID_IDX_BRIDGE_UNDERLAY_NOVA).toString());
    }
    if (context.getService(DeviceService.class).getDevice(DeviceId.deviceId(ofDevId.get(String.valueOf(DEVID_IDX_BRIDGE_OVERLAY)).asText())) == null) {
        isOfDevicePresent = false;
    }
    if (context.getService(DeviceService.class).getDevice(DeviceId.deviceId(ofDevId.get(String.valueOf(DEVID_IDX_BRIDGE_UNDERLAY_NOVA)).asText())) == null) {
        isOfDevicePresent = false;
    }
    return isOfDevicePresent;
}
#end_block

#method_before
@Override
public void process(WorkflowContext context) throws WorkflowException {
    strOfDevIdOverlay = OvsUtil.buildOfDeviceId(IpAddress.valueOf(strMgmtIp), DEVID_IDX_BRIDGE_OVERLAY).toString();
    strOfDevIdUnderlay = OvsUtil.buildOfDeviceId(IpAddress.valueOf(strMgmtIp), DEVID_IDX_BRIDGE_UNDERLAY_NOVA).toString();
    DeviceAdminService adminService = context.getService(DeviceAdminService.class);
    Set<String> eventHints = Sets.newHashSet(strOfDevIdOverlay, strOfDevIdUnderlay);
    context.waitAnyCompletion(DeviceEvent.class, eventHints, () -> {
        adminService.removeDevice(DeviceId.deviceId(strOfDevIdOverlay));
        adminService.removeDevice(DeviceId.deviceId(strOfDevIdUnderlay));
    }, TIMEOUT_DEVICE_CREATION_MS);
}
#method_after
@Override
public void process(WorkflowContext context) throws WorkflowException {
    DeviceAdminService adminService = context.getService(DeviceAdminService.class);
    String ofDevIdOverlay;
    String ofDevIdUnderlay;
    if (ofDevId == null) {
        ofDevId = JsonNodeFactory.instance.objectNode();
        ofDevId.put(String.valueOf(DEVID_IDX_BRIDGE_OVERLAY), OvsUtil.buildOfDeviceId(IpAddress.valueOf(strMgmtIp), DEVID_IDX_BRIDGE_OVERLAY).toString());
        ofDevId.put(String.valueOf(DEVID_IDX_BRIDGE_UNDERLAY_NOVA), OvsUtil.buildOfDeviceId(IpAddress.valueOf(strMgmtIp), DEVID_IDX_BRIDGE_UNDERLAY_NOVA).toString());
    }
    ofDevIdOverlay = ofDevId.get(String.valueOf(DEVID_IDX_BRIDGE_OVERLAY)).asText();
    ofDevIdUnderlay = ofDevId.get(String.valueOf(DEVID_IDX_BRIDGE_UNDERLAY_NOVA)).asText();
    Set<String> eventHints = Sets.newHashSet(ofDevIdOverlay, ofDevIdUnderlay);
    context.waitAnyCompletion(DeviceEvent.class, eventHints, () -> {
        adminService.removeDevice(DeviceId.deviceId(ofDevIdOverlay));
        adminService.removeDevice(DeviceId.deviceId(ofDevIdUnderlay));
    }, TIMEOUT_DEVICE_CREATION_MS);
}
#end_block

#method_before
private PortDescription applyAllPortOps(DeviceId did, PortDescription desc) {
    return applyAllPortOps(new ConnectPoint(did, desc.portNumber()), desc, Optional.empty());
}
#method_after
private PortDescription applyAllPortOps(DeviceId did, PortDescription desc) {
    return applyAllPortOps(new ConnectPoint(did, desc.portNumber()), desc);
}
#end_block

#method_before
private PortDescription applyAllPortOps(ConnectPoint cpt, PortDescription desc, Optional<Config> prevConfig) {
    PortDescription work = desc;
    for (PortConfigOperator portOp : portOps) {
        work = portOp.combine(cpt, work, prevConfig);
    }
    return portAnnotationOp.combine(cpt, work, prevConfig);
}
#method_after
private PortDescription applyAllPortOps(ConnectPoint cpt, PortDescription desc) {
    PortDescription work = desc;
    for (PortConfigOperator portOp : portOps) {
        work = portOp.combine(cpt, work);
    }
    return portAnnotationOp.combine(cpt, work);
}
#end_block

#method_before
private static SparseAnnotations combine(OpticalPortConfig opc, SparseAnnotations an) {
    DefaultAnnotations.Builder b = DefaultAnnotations.builder();
    b.putAll(an);
    if (!opc.staticPort().isEmpty()) {
        b.set(AnnotationKeys.STATIC_PORT, opc.staticPort());
    }
    if (opc.staticLambda().isPresent()) {
        b.set(AnnotationKeys.STATIC_LAMBDA, String.valueOf(opc.staticLambda().get()));
    }
    // The following may not need to be carried.
    if (!opc.name().isEmpty()) {
        b.set(AnnotationKeys.PORT_NAME, opc.name());
    }
    return b.build();
}
#method_after
@Override
public PortDescription combine(ConnectPoint cp, PortDescription descr) {
    checkNotNull(cp);
    // must be removed if we need type override
    if (descr != null && !optical.contains(descr.type())) {
        return descr;
    }
    OpticalPortConfig opc = lookupConfig(cp);
    if (descr == null || opc == null) {
        return descr;
    }
    PortNumber number = descr.portNumber();
    // handle PortNumber "name" portion
    if (!opc.name().isEmpty()) {
        number = PortNumber.portNumber(descr.portNumber().toLong(), opc.name());
    }
    // handle additional annotations
    SparseAnnotations annotations = combine(opc, descr.annotations());
    // (Future work) handle type overwrite?
    Type type = firstNonNull(opc.type(), descr.type());
    if (type != descr.type()) {
        // TODO: Do we need to be able to overwrite Port.Type?
        log.warn("Port type overwrite requested for {}. Ignoring.", cp);
    }
    return updateDescription(number, annotations, descr);
}
#end_block

#method_before
@Override
public PortDescription combine(ConnectPoint cp, PortDescription descr, Optional<Config> prevConfig) {
    checkNotNull(cp);
    // must be removed if we need type override
    if (descr != null && !optical.contains(descr.type())) {
        return descr;
    }
    OpticalPortConfig opc = lookupConfig(cp);
    if (descr == null || opc == null) {
        return descr;
    }
    PortNumber number = descr.portNumber();
    // handle PortNumber "name" portion
    if (!opc.name().isEmpty()) {
        number = PortNumber.portNumber(descr.portNumber().toLong(), opc.name());
    }
    // handle additional annotations
    SparseAnnotations annotations = combine(opc, descr.annotations());
    // (Future work) handle type overwrite?
    Type type = firstNonNull(opc.type(), descr.type());
    if (type != descr.type()) {
        // TODO: Do we need to be able to overwrite Port.Type?
        log.warn("Port type overwrite requested for {}. Ignoring.", cp);
    }
    return updateDescription(number, annotations, descr);
}
#method_after
@Override
public PortDescription combine(ConnectPoint cp, PortDescription descr, Optional<Config> prevConf) {
    return combine(cp, descr);
}
#end_block

#method_before
default PortDescription combine(DeviceId did, PortDescription descr) {
    return combine(new ConnectPoint(did, descr.portNumber()), descr, Optional.empty());
}
#method_after
default PortDescription combine(DeviceId did, PortDescription descr) {
    return combine(new ConnectPoint(did, descr.portNumber()), descr);
}
#end_block

#method_before
@Override
public PortDescription combine(ConnectPoint cp, PortDescription descr, Optional<Config> prevConfig) {
    PortAnnotationConfig cfg = lookupConfig(cp);
    Map<String, String> annotations = new HashMap<>();
    if (cfg != null) {
        annotations.putAll(cfg.annotations());
    }
    Builder builder = DefaultAnnotations.builder();
    builder.putAll(descr.annotations());
    if (prevConfig.isPresent()) {
        PortAnnotationConfig prevDeviceAnnotationConfig = (PortAnnotationConfig) prevConfig.get();
        for (String key : prevDeviceAnnotationConfig.annotations().keySet()) {
            if (!annotations.containsKey(key)) {
                builder.remove(key);
            }
        }
    }
    builder.putAll(annotations);
    return DefaultPortDescription.builder(descr).annotations(builder.build()).build();
}
#method_after
@Override
public PortDescription combine(ConnectPoint cp, PortDescription descr) {
    PortAnnotationConfig cfg = lookupConfig(cp);
    if (cfg == null) {
        return descr;
    }
    Map<String, String> annotations = cfg.annotations();
    if (annotations.isEmpty()) {
        return descr;
    }
    Builder builder = DefaultAnnotations.builder();
    builder.putAll(descr.annotations());
    builder.putAll(annotations);
    return DefaultPortDescription.builder(descr).annotations(builder.build()).build();
}
#end_block

#method_before
void createReqRpc(List<CharSequence> nodes) {
    Document doc;
    try {
        doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
    } catch (ParserConfigurationException e) {
        printlog("Unexpected error", e);
        throw new IllegalStateException(e);
    }
    // netconf rpc boilerplate part without message-id
    Element rpc = doc.createElementNS("urn:ietf:params:xml:ns:netconf:base:1.0", "rpc");
    doc.appendChild(rpc);
    Element editConfig = doc.createElement("edit-config");
    rpc.appendChild(editConfig);
    Element target = doc.createElement("target");
    editConfig.appendChild(target);
    target.appendChild(doc.createElement("candidate"));
    Element config = doc.createElement("config");
    config.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xc", "urn:ietf:params:xml:ns:netconf:base:1.0");
    editConfig.appendChild(config);
    for (CharSequence node : nodes) {
        Document ldoc = toDocument(CharSource.wrap(node));
        Element cfgRoot = ldoc.getDocumentElement();
        // is everything as merge, ok?
        cfgRoot.setAttribute("xc:operation", "merge");
        // move (or copy) node to another Document
        config.appendChild(Optional.ofNullable(doc.adoptNode(cfgRoot)).orElseGet(() -> doc.importNode(cfgRoot, true)));
    }
    /* Capture the RPC request in a variable to send */
    String rpcReq = String.valueOf(XmlString.prettifyXml(toCharSequence(doc)));
    String rpcReply = null;
    /* send the RPC request along with a commit message */
    if (uri != null) {
        NetconfSession netconfSession = getNetconfSession(DeviceId.deviceId(uri));
        try {
            printlog("Sending an RPC request\n{}", XmlString.prettifyXml(rpcReq));
            rpcReply = netconfSession.rpc(toCharSequence(doc, false).toString()).join();
            if (!rpcReply.contains("<ok/>")) {
                log.error("Got back an error RPC response");
            } else {
                printlog("{}", "Got back a successful RPC response. Committing the state.");
                rpcReply = netconfSession.doWrappedRpc("<commit/>");
            }
        } catch (NetconfException netconfException) {
            log.error("Exception occurred while sending the RPC Request: {}", netconfException);
        }
        printlog("{}", rpcReply);
    }
}
#method_after
void createReqRpc(List<CharSequence> nodes) {
    Document doc;
    try {
        doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
    } catch (ParserConfigurationException e) {
        printlog("Unexpected error", e);
        throw new IllegalStateException(e);
    }
    // netconf rpc boilerplate part without message-id
    Element rpc = doc.createElementNS(netconfNamespaceUri, rpcElement);
    doc.appendChild(rpc);
    Element editConfig = doc.createElement(editConfigTag);
    rpc.appendChild(editConfig);
    Element target = doc.createElement(targetTag);
    editConfig.appendChild(target);
    target.appendChild(doc.createElement(candidateTag));
    Element config = doc.createElement(configTag);
    config.setAttributeNS(xmlNamespaceUri, xmlNamespaceQualifiedName, xmlNamespaceValue);
    editConfig.appendChild(config);
    for (CharSequence node : nodes) {
        Document ldoc = toDocument(CharSource.wrap(node));
        Element cfgRoot = ldoc.getDocumentElement();
        // is everything as merge, ok?
        cfgRoot.setAttribute(attributeName, attributeValue);
        // move (or copy) node to another Document
        config.appendChild(Optional.ofNullable(doc.adoptNode(cfgRoot)).orElseGet(() -> doc.importNode(cfgRoot, true)));
    }
    /* Capture the RPC request in a variable to send */
    String rpcReq = String.valueOf(XmlString.prettifyXml(toCharSequence(doc)));
    String rpcReply = null;
    /* send the RPC request along with a commit message */
    if (uri != null) {
        NetconfSession netconfSession = getNetconfSession(DeviceId.deviceId(uri));
        try {
            printlog("Sending an RPC request\n{}", XmlString.prettifyXml(rpcReq));
            rpcReply = netconfSession.rpc(toCharSequence(doc, false).toString()).join();
            if (!rpcReply.contains(netconfOkTag)) {
                log.error("Got back an error RPC response");
            } else {
                printlog("{}", "Got back a successful RPC response. Committing the state.");
                rpcReply = netconfSession.doWrappedRpc(commitTag);
            }
        } catch (NetconfException netconfException) {
            log.error("Exception occurred while sending the RPC Request: {}", netconfException);
        }
        printlog("{}", rpcReply);
    }
}
#end_block

#method_before
@Test
public void testDeviceDescription() throws IOException, ConfigurationException {
    String input = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<rpc-reply xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" message-id=\"2\">\n" + "  <data>\n" + "    <components xmlns=\"http://openconfig.net/yang/platform\">\n" + "      <component>\n" + "        <name>shelf-1</name>\n" + "        <config>\n" + "          <name>shelf-1</name>\n" + "        </config>\n" + "        <state>\n" + "          <name>shelf-1</name>\n" + "          <type xmlns:oc-platform-types=\"http://openconfig.net/yang/platform-types\">" + "oc-platform-types:CHASSIS</type>\n" + "          <id>1</id>\n" + "          <description>BDT6-T600</description>\n" + "          <mfg-name>FUJITSU</mfg-name>\n" + "          <hardware-version>01</hardware-version>\n" + "          <software-version>1.1.1</software-version>\n" + "          <serial-no>00026</serial-no>\n" + "          <part-no>FC9569T600</part-no>\n" + "          <oper-status xmlns:oc-platform-types=\"http://openconfig.net/yang/platform-types\">" + "oc-platform-types:ACTIVE</oper-status>\n" + "          <temperature>\n" + "            <instant>0.0</instant>\n" + "            <interval>900000000000</interval>\n" + "          </temperature>\n" + "          <memory>\n" + "            <available>1997</available>\n" + "            <utilized>632</utilized>\n" + "          </memory>\n" + "        </state>\n" + "        <subcomponents>\n" + "          <subcomponent>\n" + "            <name>slot-1/0</name>\n" + "            <config>\n" + "              <name>slot-1/0</name>\n" + "            </config>\n" + "            <state>\n" + "              <name>slot-1/0</name>\n" + "            </state>\n" + "          </subcomponent>\n" + "          <subcomponent>\n" + "            <name>slot-1/1</name>\n" + "            <config>\n" + "              <name>slot-1/1</name>\n" + "            </config>\n" + "            <state>\n" + "              <name>slot-1/1</name>\n" + "            </state>\n" + "          </subcomponent>\n" + "          <subcomponent>\n" + "            <name>fan-1/FAN1</name>\n" + "            <config>\n" + "              <name>fan-1/FAN1</name>\n" + "            </config>\n" + "            <state>\n" + "              <name>fan-1/FAN1</name>\n" + "            </state>\n" + "          </subcomponent>\n" + "          <subcomponent>\n" + "            <name>fan-1/FAN2</name>\n" + "            <config>\n" + "              <name>fan-1/FAN2</name>\n" + "            </config>\n" + "            <state>\n" + "              <name>fan-1/FAN2</name>\n" + "            </state>\n" + "          </subcomponent>\n" + "          <subcomponent>\n" + "            <name>fan-1/FAN3</name>\n" + "            <config>\n" + "              <name>fan-1/FAN3</name>\n" + "            </config>\n" + "            <state>\n" + "              <name>fan-1/FAN3</name>\n" + "            </state>\n" + "          </subcomponent>\n" + "          <subcomponent>\n" + "            <name>fan-1/FAN4</name>\n" + "            <config>\n" + "              <name>fan-1/FAN4</name>\n" + "            </config>\n" + "            <state>\n" + "              <name>fan-1/FAN4</name>\n" + "            </state>\n" + "          </subcomponent>\n" + "          <subcomponent>\n" + "            <name>fan-1/FAN5</name>\n" + "            <config>\n" + "              <name>fan-1/FAN5</name>\n" + "            </config>\n" + "            <state>\n" + "              <name>fan-1/FAN5</name>\n" + "            </state>\n" + "          </subcomponent>\n" + "          <subcomponent>\n" + "            <name>psu-1/PWR1</name>\n" + "            <config>\n" + "              <name>psu-1/PWR1</name>\n" + "            </config>\n" + "            <state>\n" + "              <name>psu-1/PWR1</name>\n" + "            </state>\n" + "          </subcomponent>\n" + "          <subcomponent>\n" + "            <name>psu-1/PWR2</name>\n" + "            <config>\n" + "              <name>psu-1/PWR2</name>\n" + "            </config>\n" + "            <state>\n" + "              <name>psu-1/PWR2</name>\n" + "            </state>\n" + "          </subcomponent>\n" + "        </subcomponents>\n" + "        <cpu>\n" + "          <utilization xmlns=\"http://openconfig.net/yang/platform/cpu\">\n" + "            <state>\n" + "              <instant>8</instant>\n" + "              <avg>9</avg>\n" + "              <min>8</min>\n" + "              <max>11</max>\n" + "              <interval>600000000000</interval>\n" + "            </state>\n" + "          </utilization>\n" + "        </cpu>\n" + "      </component>\n" + "    </components>\n" + "  </data>\n" + "</rpc-reply>\n";
    FujitsuOpenConfigDeviceDiscovery fujitsuOpenConfigDeviceDiscovery = new FujitsuOpenConfigDeviceDiscovery();
    XMLConfiguration deviceCfg = new XMLConfiguration();
    deviceCfg.load(CharSource.wrap(input).openStream());
    DeviceDescription deviceDescription = fujitsuOpenConfigDeviceDiscovery.parseDeviceInformation(deviceCfg);
    assertEquals(deviceDescription.manufacturer(), contains("Fujitsu"));
    assertEquals(deviceDescription.swVersion(), "1.1.1");
}
#method_after
@Test
public void testDeviceDescription() throws IOException, ConfigurationException, URISyntaxException {
    FujitsuOpenConfigDeviceDiscovery fujitsuOpenConfigDeviceDiscovery = new FujitsuOpenConfigDeviceDiscovery();
    URI uri = new URI(DEVICE_ID);
    XMLConfiguration xmlCfg = (XMLConfiguration) XmlConfigParser.loadXmlString(DEVICE_DISCOVERY_INPUT);
    xmlCfg.load(CharSource.wrap(DEVICE_DISCOVERY_INPUT).openStream());
    DeviceDescription deviceDescription = fujitsuOpenConfigDeviceDiscovery.parseDeviceInformation(uri, xmlCfg);
    assertEquals(deviceDescription.manufacturer(), DEVICE_MANUFACTURER);
    assertEquals(deviceDescription.swVersion(), SW_VERSION);
}
#end_block

#method_before
@Test
public void testPortDescription() throws IOException, ConfigurationException {
    String input = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<rpc-reply xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" message-id=\"2\">\n" + "   <data>\n" + "      <components xmlns=\"http://openconfig.net/yang/platform\">\n" + "         <component>\n" + "            <name>transceiver-1/1/0/C1</name>\n" + "            <config>\n" + "               <name>transceiver-1/1/0/C1</name>\n" + "            </config>\n" + "            <state>\n" + "               <name>transceiver-1/1/0/C1</name>\n" + "               <type>TRANSCEIVER</type>\n" + "               <id>C1</id>\n" + "               <description />\n" + "               <mfg-name />\n" + "               <hardware-version />\n" + "               <serial-no />\n" + "               <part-no />\n" + "               <oper-status xmlns:oc-platform-types=\"http://openconfig.net/yang/platform-types\">" + "oc-platform-types:INACTIVE</oper-status>\n" + "            </state>\n" + "            <transceiver xmlns=\"http://openconfig.net/yang/platform/transceiver\">\n" + "               <config>\n" + "                  <enabled>true</enabled>\n" + "                  <form-factor-preconf xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor-preconf>\n" + "               </config>\n" + "               <state>\n" + "                  <enabled>true</enabled>\n" + "                  <form-factor-preconf xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor-preconf>\n" + "                  <form-factor xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor>\n" + "                  <output-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </output-power>\n" + "                  <input-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </input-power>\n" + "                  <laser-bias-current>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </laser-bias-current>\n" + "               </state>\n" + "            </transceiver>\n" + "         </component>\n" + "         <component>\n" + "            <name>transceiver-1/1/0/C2</name>\n" + "            <config>\n" + "               <name>transceiver-1/1/0/C2</name>\n" + "            </config>\n" + "            <state>\n" + "               <name>transceiver-1/1/0/C2</name>\n" + "               <type>TRANSCEIVER</type>\n" + "               <id>C2</id>\n" + "               <description />\n" + "               <mfg-name />\n" + "               <hardware-version />\n" + "               <serial-no />\n" + "               <part-no />\n" + "               <oper-status xmlns:oc-platform-types=\"http://openconfig.net/yang/platform-types\">" + "oc-platform-types:INACTIVE</oper-status>\n" + "            </state>\n" + "            <transceiver xmlns=\"http://openconfig.net/yang/platform/transceiver\">\n" + "               <config>\n" + "                  <enabled>true</enabled>\n" + "                  <form-factor-preconf xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor-preconf>\n" + "               </config>\n" + "               <state>\n" + "                  <enabled>true</enabled>\n" + "                  <form-factor-preconf xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor-preconf>\n" + "                  <form-factor xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor>\n" + "                  <output-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </output-power>\n" + "                  <input-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </input-power>\n" + "                  <laser-bias-current>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </laser-bias-current>\n" + "               </state>\n" + "            </transceiver>\n" + "         </component>\n" + "         <component>\n" + "            <name>transceiver-1/1/0/C3</name>\n" + "            <config>\n" + "               <name>transceiver-1/1/0/C3</name>\n" + "            </config>\n" + "            <state>\n" + "               <name>transceiver-1/1/0/C3</name>\n" + "               <type>TRANSCEIVER</type>\n" + "               <id>C3</id>\n" + "               <description />\n" + "               <mfg-name />\n" + "               <hardware-version />\n" + "               <serial-no />\n" + "               <part-no />\n" + "               <oper-status xmlns:oc-platform-types=" + "\"http://openconfig.net/yang/platform-types\">oc-platform-types:INACTIVE</oper-status>\n" + "            </state>\n" + "            <transceiver xmlns=\"http://openconfig.net/yang/platform/transceiver\">\n" + "               <config>\n" + "                  <enabled>true</enabled>\n" + "                  <form-factor-preconf xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor-preconf>\n" + "               </config>\n" + "               <state>\n" + "                  <enabled>true</enabled>\n" + "                  <form-factor-preconf xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor-preconf>\n" + "                  <form-factor xmlns:oc-opt-types=\"http://openconfig.net/yang/transport-types\">" + "oc-opt-types:QSFP28</form-factor>\n" + "                  <output-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </output-power>\n" + "                  <input-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </input-power>\n" + "                  <laser-bias-current>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </laser-bias-current>\n" + "               </state>\n" + "            </transceiver>\n" + "         </component>\n" + "         <component>\n" + "            <name>transceiver-1/1/0/C4</name>\n" + "            <config>\n" + "               <name>transceiver-1/1/0/C4</name>\n" + "            </config>\n" + "            <state>\n" + "               <name>transceiver-1/1/0/C4</name>\n" + "               <type>TRANSCEIVER</type>\n" + "               <id>C4</id>\n" + "               <description />\n" + "               <mfg-name />\n" + "               <hardware-version />\n" + "               <serial-no />\n" + "               <part-no />\n" + "               <oper-status xmlns:oc-platform-types=" + "\"http://openconfig.net/yang/platform-types\">oc-platform-types:INACTIVE</oper-status>\n" + "            </state>\n" + "            <transceiver xmlns=\"http://openconfig.net/yang/platform/transceiver\">\n" + "               <config>\n" + "                  <enabled>true</enabled>\n" + "                  <form-factor-preconf xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor-preconf>\n" + "               </config>\n" + "               <state>\n" + "                  <enabled>true</enabled>\n" + "                  <form-factor-preconf xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor-preconf>\n" + "                  <form-factor xmlns:oc-opt-types=" + "\"http://openconfig.net/yang/transport-types\">oc-opt-types:QSFP28</form-factor>\n" + "                  <output-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </output-power>\n" + "                  <input-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </input-power>\n" + "                  <laser-bias-current>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </laser-bias-current>\n" + "               </state>\n" + "            </transceiver>\n" + "         </component>\n" + "         <component>\n" + "            <name>port-1/1/0/E1</name>\n" + "            <config>\n" + "               <name>port-1/1/0/E1</name>\n" + "            </config>\n" + "            <state>\n" + "               <name>port-1/1/0/E1</name>\n" + "               <type xmlns:oc-platform-types=" + "\"http://openconfig.net/yang/platform-types\">oc-platform-types:PORT</type>\n" + "               <id>E1</id>\n" + "               <description />\n" + "               <mfg-name />\n" + "               <hardware-version />\n" + "               <serial-no />\n" + "               <part-no />\n" + "               <oper-status xmlns:oc-platform-types=" + "\"http://openconfig.net/yang/platform-types\">oc-platform-types:INACTIVE</oper-status>\n" + "            </state>\n" + "            <subcomponents>\n" + "               <subcomponent>\n" + "                  <name>otsi-1/1/0/E1</name>\n" + "                  <config>\n" + "                     <name>otsi-1/1/0/E1</name>\n" + "                  </config>\n" + "                  <state>\n" + "                     <name>otsi-1/1/0/E1</name>\n" + "                  </state>\n" + "               </subcomponent>\n" + "            </subcomponents>\n" + "         </component>\n" + "         <component>\n" + "            <name>otsi-1/1/0/E1</name>\n" + "            <config>\n" + "               <name>otsi-1/1/0/E1</name>\n" + "            </config>\n" + "            <state>\n" + "               <name>otsi-1/1/0/E1</name>\n" + "               <type>OPTICAL_CHANNEL</type>\n" + "               <id>E1</id>\n" + "               <mfg-name />\n" + "               <hardware-version />\n" + "               <serial-no />\n" + "               <part-no />\n" + "               <oper-status xmlns:oc-platform-types=" + "\"http://openconfig.net/yang/platform-types\">oc-platform-types:INACTIVE</oper-status>\n" + "            </state>\n" + "            <optical-channel xmlns=\"http://openconfig.net/yang/terminal-device\">\n" + "               <config>\n" + "                  <frequency>0</frequency>\n" + "                  <target-output-power>1.0</target-output-power>\n" + "                  <operational-mode>5</operational-mode>\n" + "               </config>\n" + "               <state>\n" + "                  <frequency>0</frequency>\n" + "                  <target-output-power>1.0</target-output-power>\n" + "                  <operational-mode>5</operational-mode>\n" + "                  <output-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </output-power>\n" + "                  <input-power>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </input-power>\n" + "                  <laser-bias-current>\n" + "                     <instant>-99.9</instant>\n" + "                     <interval>900000000000</interval>\n" + "                  </laser-bias-current>\n" + "                  <chromatic-dispersion>\n" + "                     <instant>-99.9</instant>\n" + "                  </chromatic-dispersion>\n" + "                  <polarization-mode-dispersion>\n" + "                     <instant>-99.9</instant>\n" + "                  </polarization-mode-dispersion>\n" + "               </state>\n" + "            </optical-channel>\n" + "         </component>\n" + "      </components>\n" + "   </data>\n" + "</rpc-reply>";
    XMLConfiguration portCfg = new XMLConfiguration();
    portCfg.load(CharSource.wrap(input).openStream());
    FujitsuOpenConfigDeviceDiscovery fujitsuOpenConfigDeviceDiscovery = new FujitsuOpenConfigDeviceDiscovery();
    List<PortDescription> t600Ports = fujitsuOpenConfigDeviceDiscovery.parse1FinityPorts(portCfg);
    assertThat(t600Ports.size(), is(5));
    PortDescription portDescription;
    portDescription = t600Ports.get(0);
    assertThat(portDescription.portNumber().name(), is("transceiver-1/1/0/C1"));
    assertThat(portDescription.annotations().value(OC_NAME), is("transceiver-1/1/0/C1"));
    assertThat(portDescription.annotations().value(OC_TYPE), is("TRANSCEIVER"));
    assertThat(portDescription.annotations().value(ODTN_PORT_TYPE), is(FujitsuOpenConfigDeviceDiscovery.OdtnPortType.CLIENT.value()));
    assertThat(portDescription.type(), is(Port.Type.PACKET));
    portDescription = t600Ports.get(4);
    assertThat(portDescription.portNumber().name(), is("otsi-1/1/0/E1"));
    assertThat(portDescription.annotations().value(OC_NAME), is("otsi-1/1/0/E1"));
    assertThat(portDescription.annotations().value(OC_TYPE), is("OPTICAL_CHANNEL"));
    assertThat(portDescription.annotations().value(ODTN_PORT_TYPE), is(FujitsuOpenConfigDeviceDiscovery.OdtnPortType.LINE.value()));
    assertThat(portDescription.type(), is(Port.Type.OCH));
}
#method_after
@Test
public void testPortDescription() throws IOException, ConfigurationException {
    XMLConfiguration portCfg = new XMLConfiguration();
    portCfg.load(CharSource.wrap(PORT_INPUT).openStream());
    FujitsuOpenConfigDeviceDiscovery fujitsuOpenConfigDeviceDiscovery = new FujitsuOpenConfigDeviceDiscovery();
    List<PortDescription> t600Ports = fujitsuOpenConfigDeviceDiscovery.parse1FinityPorts(portCfg);
    assertThat(t600Ports.size(), is(5));
    PortDescription portDescription;
    portDescription = t600Ports.get(0);
    assertThat(portDescription.portNumber().name(), is(TRANSCEIVER_COMPONENT_1));
    assertThat(portDescription.annotations().value(OC_NAME), is(TRANSCEIVER_COMPONENT_1));
    assertThat(portDescription.annotations().value(OC_TYPE), is(TRANSCEIVER));
    assertThat(portDescription.annotations().value(ODTN_PORT_TYPE), is(FujitsuOpenConfigDeviceDiscovery.OdtnPortType.CLIENT.value()));
    assertThat(portDescription.type(), is(Port.Type.PACKET));
    portDescription = t600Ports.get(4);
    assertThat(portDescription.portNumber().name(), is(OPTICAL_CHANNEL_COMPONENT_1));
    assertThat(portDescription.annotations().value(OC_NAME), is(OPTICAL_CHANNEL_COMPONENT_1));
    assertThat(portDescription.annotations().value(OC_TYPE), is(OPTICAL_CHANNEL));
    assertThat(portDescription.annotations().value(ODTN_PORT_TYPE), is(FujitsuOpenConfigDeviceDiscovery.OdtnPortType.LINE.value()));
    assertThat(portDescription.type(), is(Port.Type.OCH));
}
#end_block

#method_before
@VisibleForTesting
public List<PortDescription> parse1FinityPorts(HierarchicalConfiguration xmlCfg) {
    List<PortDescription> portDescriptions = Lists.newArrayList();
    List<HierarchicalConfiguration> subTrees = checkNotNull(xmlCfg.configurationsAt("data.components.component"));
    for (HierarchicalConfiguration portConfig : subTrees) {
        String portTypeSubComponent = checkNotNull(portConfig.configurationAt("state").getString("type"));
        if (portTypeSubComponent.contains(OPTICAL_CHANNEL)) {
            portDescriptions.add(parseLineSideComponent(portConfig));
        } else if (portTypeSubComponent.contains(TRANSCEIVER)) {
            portDescriptions.add(parseClientSideComponent(portConfig));
        }
    }
    return portDescriptions;
}
#method_after
@VisibleForTesting
public List<PortDescription> parse1FinityPorts(HierarchicalConfiguration xmlCfg) {
    List<PortDescription> portDescriptions = Lists.newArrayList();
    List<HierarchicalConfiguration> subTrees = checkNotNull(xmlCfg.configurationsAt(PORT_COMPONENT_PATH));
    for (HierarchicalConfiguration portConfig : subTrees) {
        String portTypeSubComponent = checkNotNull(portConfig.configurationAt(COMPONENT_STATE).getString(COMPONENT_TYPE));
        if (portTypeSubComponent.contains(OPTICAL_CHANNEL)) {
            portDescriptions.add(parsePortComponent(OPTICAL_CHANNEL.toString(), Type.OCH, OdtnPortType.LINE.value(), portConfig));
        } else if (portTypeSubComponent.contains(TRANSCEIVER)) {
            portDescriptions.add(parsePortComponent(TRANSCEIVER.toString(), Type.PACKET, OdtnPortType.CLIENT.value(), portConfig));
        }
    }
    return portDescriptions;
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    NetconfSession netconfSession = checkNotNull(getNetconfSession());
    String requestedComponent = null;
    try {
        requestedComponent = netconfSession.doWrappedRpc(buildGetComponentRequest("shelf-1"));
    } catch (NetconfException netconfException) {
        log.error("Unable to send the request via netconf: {}\n" + "Getting default Device Description Details", netconfException);
        return new DefaultDeviceDescription(handler().data().deviceId().uri(), Device.Type.OTN, "FUJITSU", "", "", "", new ChassisId("1"));
    }
    return parseDeviceInformation(XmlConfigParser.loadXml(new ByteArrayInputStream(requestedComponent.getBytes())));
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    NetconfSession netconfSession = checkNotNull(getNetconfSession());
    String requestedComponent = null;
    try {
        requestedComponent = netconfSession.doWrappedRpc(buildGetComponentRequest("shelf-1"));
    } catch (NetconfException netconfException) {
        log.error("Unable to send the request via netconf: {}\n" + "Getting default Device Description Details", netconfException);
    }
    XMLConfiguration xmlCfg = (XMLConfiguration) XmlConfigParser.loadXmlString(requestedComponent);
    return parseDeviceInformation(handler().data().deviceId().uri(), xmlCfg);
}
#end_block

#method_before
@VisibleForTesting
public DeviceDescription parseDeviceInformation(HierarchicalConfiguration xmlCfg) {
    String mfgName = null;
    String hwVersion = null;
    String swVersion = null;
    String serialNumber = null;
    String chassisId = null;
    List<HierarchicalConfiguration> subTrees = checkNotNull(xmlCfg.configurationsAt("data.components.component"));
    for (HierarchicalConfiguration componentConfig : subTrees) {
        String componentName = componentConfig.getString("name");
        if (componentName.equalsIgnoreCase("shelf-1")) {
            mfgName = componentConfig.configurationAt("state").getString("mfg-name");
            hwVersion = componentConfig.configurationAt("state").getString("hardware-version");
            swVersion = componentConfig.configurationAt("state").getString("software-version");
            serialNumber = componentConfig.configurationAt("state").getString("serial-no");
            chassisId = componentConfig.configurationAt("state").getString("id");
        }
    }
    return new DefaultDeviceDescription(handler().data().deviceId().uri(), Device.Type.OTN, mfgName, hwVersion, swVersion, serialNumber, new ChassisId(chassisId));
}
#method_after
@VisibleForTesting
public DeviceDescription parseDeviceInformation(URI uri, XMLConfiguration xmlCfg) {
    String mfgName = "FUJITSU";
    String hwVersion = null;
    String swVersion = null;
    String serialNumber = null;
    String chassisId = "1";
    mfgName = xmlCfg.getString(MFG_NAME_TREE_PATH, mfgName);
    swVersion = xmlCfg.getString(SW_VERSION_TREE_PATH, swVersion);
    hwVersion = xmlCfg.getString(HW_VERSION_TREE_PATH, hwVersion);
    serialNumber = xmlCfg.getString(SERIAL_NUMBER_TREE_PATH, serialNumber);
    chassisId = xmlCfg.getString(CHASSIS_ID_TREE_PATH, chassisId);
    return new DefaultDeviceDescription(uri, Device.Type.OTN, mfgName, hwVersion, swVersion, serialNumber, new ChassisId(chassisId));
}
#end_block

#method_before
private String buildGetComponentRequest(String componentName) {
    return "<get>\n" + "  <filter type=\"subtree\">\n" + "  <components xmlns=\"http://openconfig.net/yang/platform\">\n" + "    <component>\n" + "        <name>" + componentName + "</name>\n" + "    </component>\n" + "  </components>\n" + "  </filter>\n" + "</get>";
}
#method_after
private String buildGetComponentRequest(String componentName) {
    StringBuilder filter = new StringBuilder();
    filter.append("<components xmlns=\"http://openconfig.net/yang/platform\">");
    filter.append("<component>");
    filter.append("<name>");
    filter.append(componentName);
    filter.append("</name>");
    filter.append("</component>");
    filter.append("</components>");
    return filteredGetBuilder(filter.toString());
}
#end_block

#method_before
private String buildGetComponentsRequest() {
    return "<get>\n" + "    <filter type=\"subtree\">\n" + "    <components xmlns=\"http://openconfig.net/yang/platform\">\n" + "    </components>\n" + "    </filter>\n" + "</get>\n";
}
#method_after
private String buildGetComponentsRequest() {
    StringBuilder filter = new StringBuilder();
    filter.append("<components xmlns=\"http://openconfig.net/yang/platform\">");
    filter.append("</components>");
    return filteredGetBuilder(filter.toString());
}
#end_block

#method_before
@Override
public List<CharSequence> enable(String component, boolean enable) {
    String terminalDevice = null;
    try {
        terminalDevice = getNetconfSession().doWrappedRpc(buildGetTerminalDevice());
    } catch (NetconfException e) {
        log.error("Exception occured while retreiveing rpc {}", e);
        return Collections.emptyList();
    }
    Long index = parseLogicalChannelIndex(XmlConfigParser.loadXml(new ByteArrayInputStream(terminalDevice.getBytes())), component);
    List<DataNode> dataNodes = LogicalChannel.enable(index, "", enable);
    ResourceId resourceId = ResourceId.builder().build();
    return Lists.transform(dataNodes, dataNode -> toCharSequence(toXmlCompositeStream(toCompositeData(toResourceData(resourceId, dataNode)))));
}
#method_after
@Override
public List<CharSequence> enable(String component, boolean enable) {
    String terminalDevice = null;
    try {
        terminalDevice = getNetconfSession().doWrappedRpc(buildGetTerminalDevice());
    } catch (NetconfException e) {
        log.error("Exception occurred while retrieving rpc {}", e);
        return Collections.emptyList();
    }
    Long index = parseLogicalChannelIndex(XmlConfigParser.loadXml(new ByteArrayInputStream(terminalDevice.getBytes())), component);
    if (index == null) {
        log.error(" Component {} not found in the terminal device", component);
        return Collections.emptyList();
    }
    ResourceId resourceId = ResourceId.builder().build();
    List<DataNode> dataNodes = LogicalChannel.enable(index, "", enable);
    return Lists.transform(dataNodes, dataNode -> toCharSequence(toXmlCompositeStream(toCompositeData(toResourceData(resourceId, dataNode)))));
}
#end_block

#method_before
private Long parseLogicalChannelIndex(HierarchicalConfiguration terminalDevice, String component) {
    if (terminalDevice.equals(null) || component.equals(null)) {
        log.info("Nothing to parse in logical channels");
        return null;
    }
    Long channelIndex = null;
    List<HierarchicalConfiguration> subTrees = checkNotNull(terminalDevice.configurationsAt("data.terminal-device.logical-channels.channel"));
    for (HierarchicalConfiguration channelConfig : subTrees) {
        String channel = channelConfig.configurationAt("config").getString("trib-protocol");
        if (channel.contains("PROT_100GE")) {
            String transceiver = channelConfig.configurationAt("ingress").configurationAt("config").getString("transceiver");
            if (transceiver.toLowerCase().equalsIgnoreCase(component)) {
                channelIndex = Long.parseLong(channelConfig.configurationAt("config").getString("index"));
                break;
            }
            log.info("{}", transceiver.toString());
        }
        log.info("{}", channel);
    }
    return new Long(channelIndex);
}
#method_after
private Long parseLogicalChannelIndex(HierarchicalConfiguration terminalDevice, String component) {
    if (terminalDevice.equals(null) || component.equals(null)) {
        log.debug("Nothing to parse in logical channels");
        return null;
    }
    Long channelIndex = null;
    List<HierarchicalConfiguration> subTrees = checkNotNull(terminalDevice.configurationsAt(TERMINAL_DEVICE_LOGICAL_CHANNEL));
    for (HierarchicalConfiguration channelConfig : subTrees) {
        String channel = channelConfig.configurationAt(LOGICAL_CHANNEL_CONFIG).getString(LOGICAL_CHANNEL_TRIB_PROTOCOL);
        log.debug("{}", channel);
        if (channel.contains(ETHERNET_PROTOCOL_100_G)) {
            String transceiver = channelConfig.configurationAt(LOGICAL_CHANNEL_INGRESS).configurationAt(LOGICAL_CHANNEL_CONFIG).getString(TERMINAL_DEVICE_TRANSCEIVER);
            log.debug("{}", transceiver);
            if (transceiver.toLowerCase().equalsIgnoreCase(component)) {
                channelIndex = Long.parseLong(channelConfig.configurationAt(LOGICAL_CHANNEL_CONFIG).getString(LOGICAL_CHANNEL_CONFIG_INDEX));
                break;
            }
        }
    }
    return new Long(channelIndex);
}
#end_block

#method_before
GnoiSystemClient getClientByKey() {
    final GnoiClientKey clientKey = clientKey();
    if (clientKey == null) {
        return null;
    }
    return handler().get(GnoiController.class).getClient(clientKey);
}
#method_after
GnoiClient getClientByKey() {
    final GnoiClientKey clientKey = clientKey();
    if (clientKey == null) {
        return null;
    }
    return handler().get(GnoiController.class).getClient(clientKey);
}
#end_block

#method_before
@Override
protected GnoiSystemClient createClientInstance(GnoiClientKey clientKey, ManagedChannel channel) {
    return new GnoiSystemClientImpl(clientKey, channel, this);
}
#method_after
@Override
protected GnoiClient createClientInstance(GnoiClientKey clientKey, ManagedChannel channel) {
    return new GnoiClientImpl(clientKey, channel, this);
}
#end_block

#method_before
@Override
public boolean isReachable() {
    final GnoiSystemClient client = getClientByKey();
    return client != null && client.isServerReachable();
}
#method_after
@Override
public boolean isReachable() {
    final GnoiClient client = getClientByKey();
    return client != null && client.isServerReachable();
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> probeReachability() {
    final GnoiSystemClient client = getClientByKey();
    if (client == null) {
        return completedFuture(false);
    }
    return client.probeService();
}
#method_after
@Override
public CompletableFuture<Boolean> probeReachability() {
    final GnoiClient client = getClientByKey();
    if (client == null) {
        return completedFuture(false);
    }
    return client.probeService();
}
#end_block

#method_before
@Override
protected void doExecute() {
    DeviceService deviceService = get(DeviceService.class);
    DeviceAdminService deviceAdminService = get(DeviceAdminService.class);
    Device dev = deviceService.getDevice(DeviceId.deviceId(uri));
    if (dev == null) {
        print(" %s", "Device does not exist");
        return;
    }
    DriverService service = get(DriverService.class);
    DeviceId deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    SystemReboot systemReboot = h.behaviour(SystemReboot.class);
    systemReboot.time();
}
#method_after
@Override
protected void doExecute() {
    Device dev = get(DeviceService.class).getDevice(DeviceId.deviceId(deviceId));
    if (dev == null) {
        print(" %s", "Device does not exist");
        return;
    }
    if (dev.is(BasicSystemOperations.class)) {
        try {
            CompletableFuture<Long> timeFuture = dev.as(BasicSystemOperations.class).time();
            print("Current time on the device: %s %d", deviceId, timeFuture.get());
        } catch (InterruptedException | ExecutionException e) {
            log.error("Exception while getting system time for device" + deviceId, e);
        }
    } else {
        log.error("Device does not support {} behaviour", BasicSystemOperations.class.getName());
    }
}
#end_block

#method_before
@Override
protected void doExecute() {
    DeviceService deviceService = get(DeviceService.class);
    DeviceAdminService deviceAdminService = get(DeviceAdminService.class);
    Device dev = deviceService.getDevice(DeviceId.deviceId(uri));
    if (dev == null) {
        print(" %s", "Device does not exist");
        return;
    }
    DriverService service = get(DriverService.class);
    DeviceId deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    SystemReboot systemReboot = h.behaviour(SystemReboot.class);
    systemReboot.reboot();
}
#method_after
@Override
protected void doExecute() {
    Device dev = get(DeviceService.class).getDevice(DeviceId.deviceId(deviceId));
    if (dev == null) {
        print(" %s", "Device does not exist");
        return;
    }
    if (dev.is(BasicSystemOperations.class)) {
        print("Reboot for the device %s issued", deviceId);
        dev.as(BasicSystemOperations.class).reboot().whenComplete((future, error) -> {
            if (error == null) {
                print("Reboot for the device %s succeed.", deviceId);
            } else {
                log.error("Exception while rebooting device " + deviceId, error);
            }
        });
    } else {
        log.error("Device does not support {} behaviour", BasicSystemOperations.class.getName());
    }
}
#end_block

#method_before
@Override
public List<String> getWorkletTypeList() {
    return workletTypeList;
}
#method_after
@Override
public List<String> getWorkletTypeList() {
    return ImmutableList.copyOf(workletTypeList);
}
#end_block

#method_before
@Override
public void invokeWorkflow(JsonNode worklowDescJson) throws WorkflowException {
    log.info("invokeWorkflow: {}", worklowDescJson);
    Workplace workplace = workplaceStore.getWorkplace(Workplace.SYSTEM_WORKPLACE);
    if (Objects.isNull(workplace)) {
        throw new WorkflowException("Invalid system workplace");
    }
    Workflow workflow = workflowStore.get(URI.create(WorkplaceWorkflow.WF_CREATE_WORKFLOW));
    if (Objects.isNull(workflow)) {
        throw new WorkflowException("Invalid workflow " + WorkplaceWorkflow.WF_CREATE_WORKFLOW);
    }
    checkDataType(worklowDescJson);
    WorkflowContext context = workflow.buildSystemContext(workplace, new JsonDataModelTree(worklowDescJson));
    workflowExecutionService.execInitWorklet(context);
}
#method_after
@Override
public void invokeWorkflow(JsonNode worklowDescJson) throws WorkflowException {
    log.info("invokeWorkflow: {}", worklowDescJson);
    Workplace workplace = workplaceStore.getWorkplace(Workplace.SYSTEM_WORKPLACE);
    if (Objects.isNull(workplace)) {
        throw new WorkflowException("Invalid system workplace");
    }
    Workflow workflow = workflowStore.get(URI.create(worklowDescJson.get("id").asText()));
    if (Objects.isNull(workflow)) {
        throw new WorkflowException("Invalid Workflow");
    }
    if (!checkWorkflowSchema(workflow, worklowDescJson)) {
        throw new WorkflowException("Invalid Workflow " + worklowDescJson.get("id").asText());
    }
    Workflow wfCreationWf = workflowStore.get(URI.create(WorkplaceWorkflow.WF_CREATE_WORKFLOW));
    if (Objects.isNull(wfCreationWf)) {
        throw new WorkflowException("Invalid workflow " + WorkplaceWorkflow.WF_CREATE_WORKFLOW);
    }
    WorkflowContext context = wfCreationWf.buildSystemContext(workplace, new JsonDataModelTree(worklowDescJson));
    workflowExecutionService.execInitWorklet(context);
}
#end_block

#method_before
@Modified
private void modified(ComponentContext context) {
    if (context == null) {
        log.info("Default config");
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    int newMaxArp;
    int newMaxDhcp;
    int newMaxNS;
    int newMaxNA;
    int newMaxDhcp6Direct;
    int newMaxDhcp6Indirect;
    try {
        String s = get(properties, "maxArp");
        newMaxArp = isNullOrEmpty(s) ? maxArp : Integer.parseInt(s.trim());
        s = get(properties, "maxDhcp");
        newMaxDhcp = isNullOrEmpty(s) ? maxDhcp : Integer.parseInt(s.trim());
        s = get(properties, "maxNS");
        newMaxNS = isNullOrEmpty(s) ? maxNS : Integer.parseInt(s.trim());
        s = get(properties, "maxNA");
        newMaxNA = isNullOrEmpty(s) ? maxNA : Integer.parseInt(s.trim());
        s = get(properties, "maxDhcp6Direct");
        newMaxDhcp6Direct = isNullOrEmpty(s) ? maxDhcp6Direct : Integer.parseInt(s.trim());
        s = get(properties, "maxDhcp6Indirect");
        newMaxDhcp6Indirect = isNullOrEmpty(s) ? maxDhcp6Indirect : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newMaxArp = MAX_ARP;
        newMaxDhcp = MAX_DHCP;
        newMaxNS = MAX_NS;
        newMaxNA = MAX_NA;
        newMaxDhcp6Direct = MAX_DHCP6_DIRECT;
        newMaxDhcp6Indirect = MAX_DHCP6_INDIRECT;
    }
    if (newMaxArp != maxArp) {
        maxArp = newMaxArp;
        mapCounterFilter.get("ARPFilter").setMaxCounter(maxArp);
    }
    if (newMaxDhcp != maxDhcp) {
        maxDhcp = newMaxDhcp;
        mapCounterFilter.get("DHCPFilter").setMaxCounter(maxDhcp);
    }
    if (newMaxNS != maxNS) {
        maxNS = newMaxNS;
        mapCounterFilter.get("NSFilter").setMaxCounter(maxNS);
    }
    if (newMaxNA != maxNA) {
        maxNA = newMaxNA;
        mapCounterFilter.get("NAFilter").setMaxCounter(maxNA);
    }
    if (newMaxDhcp6Direct != maxDhcp6Direct) {
        maxDhcp6Direct = newMaxDhcp6Direct;
        mapCounterFilter.get("DHCP6DirectFilter").setMaxCounter(maxDhcp6Direct);
    }
    if (newMaxDhcp6Indirect != maxDhcp6Indirect) {
        maxDhcp6Indirect = newMaxDhcp6Indirect;
        mapCounterFilter.get("DHCP6IndirectFilter").setMaxCounter(maxDhcp6Indirect);
    }
    log.info("Reconfigured maxArp: {} maxDhcp: {} maxNS: {} maxNA: {} maxDhcp6Direct: {} maxDhcp6Indirect: {}", maxArp, maxDhcp, maxNS, maxNA, maxDhcp6Direct, maxDhcp6Indirect);
}
#method_after
@Modified
private void modified(ComponentContext context) {
    if (context == null) {
        log.info("Default config");
        return;
    }
    checkChangeInPps(context);
    checkChangeInWinSize(context);
    checkChangeInGuardTime(context);
    checkChangeInWinThres(context);
    log.info("Reconfigured ppsArp: {} ppsDhcp: {} ppsNs: {} ppsNa: {} " + "ppsDhcp6Direct: {} ppsDhcp6Indirect: {} ppsIcmp: {} ppsIcmp6: {}", ppsArp, ppsDhcp, ppsNs, ppsNa, ppsDhcp6Direct, ppsDhcp6Indirect, ppsIcmp, ppsIcmp6);
    log.info("Reconfigured winSizeArp: {} winSizeDhcp: {} winSizeNs: {} winSizeNa: {} " + "winSizeDhcp6Direct: {} winSizeDhcp6Indirect: {} winSizeIcmp: {} winSizeIcmp6: {}", winSizeArp, winSizeDhcp, winSizeNs, winSizeNa, winSizeDhcp6Direct, winSizeDhcp6Indirect, winSizeIcmp, winSizeIcmp6);
    log.info("Reconfigured guardTimeArp: {} guardTimeDhcp: {} guardTimeNs: {} guardTimeNa: {} " + "guardTimeDhcp6Direct: {} guardTimeDhcp6Indirect: {} guardTimeIcmp: {} guardTimeIcmp6: {}", guardTimeArp, guardTimeDhcp, guardTimeNs, guardTimeNa, guardTimeDhcp6Direct, guardTimeDhcp6Indirect, guardTimeIcmp, guardTimeIcmp6);
    log.info("Reconfigured winThresArp: {} winThresDhcp: {} winThresNs: {} winThresNa: {} " + "winThresDhcp6Direct: {} winThresDhcp6Indirect: {} winThresIcmp: {} winThresIcmp6: {}", winThresArp, winThresDhcp, winThresNs, winThresNa, winThresDhcp6Direct, winThresDhcp6Indirect, winThresIcmp, winThresIcmp6);
}
#end_block

#method_before
private void createAllFilters() {
    DefaultPacketInFilter filter;
    ArpPacketClassifier arp = new ArpPacketClassifier();
    filter = new DefaultPacketInFilter(maxArp, "ARPFilter", arp);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    DhcpPacketClassifier dhcp4 = new DhcpPacketClassifier();
    filter = new DefaultPacketInFilter(maxDhcp, "DHCPFilter", dhcp4);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    Dhcp6DirectPacketClassifier dhcp6Direct = new Dhcp6DirectPacketClassifier();
    filter = new DefaultPacketInFilter(maxDhcp6Direct, "DHCP6DirectFilter", dhcp6Direct);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    Dhcp6IndirectPacketClassifier dhcp6Indirect = new Dhcp6IndirectPacketClassifier();
    filter = new DefaultPacketInFilter(maxDhcp6Indirect, "DHCP6IndirectFilter", dhcp6Indirect);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    NAPacketClassifier na = new NAPacketClassifier();
    filter = new DefaultPacketInFilter(maxNA, "NAFilter", na);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    NSPacketClassifier ns = new NSPacketClassifier();
    filter = new DefaultPacketInFilter(maxNS, "NSFilter", ns);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
}
#method_after
private void createAllFilters() {
    DefaultPacketInFilter filter;
    ArpPacketClassifier arp = new ArpPacketClassifier();
    filter = new DefaultPacketInFilter(ppsArp, winSizeArp, guardTimeArp, winThresArp, ARP_FILTER, arp);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    DhcpPacketClassifier dhcp4 = new DhcpPacketClassifier();
    filter = new DefaultPacketInFilter(ppsDhcp, winSizeDhcp, guardTimeDhcp, winThresDhcp, DHCP_FILTER, dhcp4);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    Dhcp6DirectPacketClassifier dhcp6Direct = new Dhcp6DirectPacketClassifier();
    filter = new DefaultPacketInFilter(ppsDhcp6Direct, winSizeDhcp6Direct, guardTimeDhcp6Direct, winThresDhcp6Direct, DHCP6_DIRECT_FILTER, dhcp6Direct);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    Dhcp6IndirectPacketClassifier dhcp6Indirect = new Dhcp6IndirectPacketClassifier();
    filter = new DefaultPacketInFilter(ppsDhcp6Direct, winSizeDhcp6Direct, guardTimeDhcp6Direct, winThresDhcp6Direct, DHCP6_INDIRECT_FILTER, dhcp6Indirect);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    NAPacketClassifier na = new NAPacketClassifier();
    filter = new DefaultPacketInFilter(ppsNa, winSizeNa, guardTimeNa, winThresNa, NA_FILTER, na);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    NSPacketClassifier ns = new NSPacketClassifier();
    filter = new DefaultPacketInFilter(ppsNs, winSizeNs, guardTimeNs, winThresNs, NS_FILTER, ns);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    IcmpPacketClassifier icmp = new IcmpPacketClassifier();
    filter = new DefaultPacketInFilter(ppsIcmp, winSizeIcmp, guardTimeIcmp, winThresIcmp, ICMP_FILTER, icmp);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
    Icmp6PacketClassifier icmp6 = new Icmp6PacketClassifier();
    filter = new DefaultPacketInFilter(ppsIcmp6, winSizeIcmp6, guardTimeIcmp6, winThresIcmp6, ICMP6_FILTER, icmp6);
    packetService.addFilter(filter);
    mapCounterFilter.put(filter.name(), filter);
}
#end_block

#method_before
private void removeAllFilters() {
    List<PacketInFilter> filters = packetService.getFilters();
    if (filters == null) {
        return;
    }
    for (PacketInFilter filter : filters) {
        packetService.removeFilter(filter);
        mapCounterFilter.remove(filter.name());
    }
}
#method_after
private void removeAllFilters() {
    packetService.clearFilters();
    mapCounterFilter.clear();
}
#end_block

#method_before
@Before
public void setUp() {
    manager = new PacketThrottleManager();
    manager.configService = new TestComponentConfigService();
    manager.packetService = new MockPacketService();
    manager.activate();
}
#method_after
@Before
public void setUp() {
    manager = new PacketThrottleManager();
    manager.configService = new TestComponentConfig();
    manager.packetService = new MockPacketService();
    manager.activate();
}
#end_block

#method_before
@Test
public void testFilter() {
    DefaultPacketInFilter filter;
    ArpPacketClassifier arp = new ArpPacketClassifier();
    filter = new DefaultPacketInFilter(10, "ARPFilter", arp);
    manager.packetService.addFilter(filter);
    assertEquals(7, manager.packetService.getFilters().size());
    manager.packetService.removeFilter(filter);
    assertEquals(6, manager.packetService.getFilters().size());
}
#method_after
@Test
public void testFilter() {
    DefaultPacketInFilter filter;
    ArpPacketClassifier arp = new ArpPacketClassifier();
    filter = new DefaultPacketInFilter(100, 500, 10, 10, PacketThrottleManager.ARP_FILTER, arp);
    manager.packetService.addFilter(filter);
    assertEquals(9, manager.packetService.getFilters().size());
    manager.packetService.removeFilter(filter);
    assertEquals(8, manager.packetService.getFilters().size());
}
#end_block

#method_before
private FilterAction prePacketProcess(PacketContext context) {
    FilterAction filterAction = FilterAction.FILTER_INVALID;
    for (PacketInFilter filter : filters) {
        filterAction = filter.preProcess(context);
        if (filterAction == FilterAction.FILTER_DISABLED) {
            if (log.isTraceEnabled()) {
                log.trace("{} filter is disabled during pre processing", filter.name());
            }
            break;
        }
        if (filterAction == FilterAction.PACKET_DENY) {
            if (log.isTraceEnabled()) {
                log.trace("{} overflow counter after dropping packet is: {}", filter.name(), filter.droppedPackets());
            }
            break;
        }
        if (filterAction == FilterAction.PACKET_ALLOW) {
            if (log.isTraceEnabled()) {
                log.trace("{} counter after picked for processing is: {}", filter.name(), filter.pendingPackets());
            }
            break;
        }
    }
    return filterAction;
}
#method_after
private FilterAction prePacketProcess(PacketContext context) {
    FilterAction filterAction = FilterAction.FILTER_INVALID;
    for (PacketInFilter filter : filters) {
        filterAction = filter.preProcess(context);
        if (filterAction == FilterAction.FILTER_DISABLED) {
            if (log.isTraceEnabled()) {
                log.trace("{}: filter is disabled during pre processing", filter.name());
            }
            continue;
        }
        if (filterAction == FilterAction.PACKET_DENY) {
            if (log.isTraceEnabled()) {
                log.trace("{}: overflow counter after dropping packet is: {}", filter.name(), filter.droppedPackets());
            }
            break;
        }
        if (filterAction == FilterAction.PACKET_ALLOW) {
            if (log.isTraceEnabled()) {
                log.trace("{}: counter after picked for processing is: {}", filter.name(), filter.pendingPackets());
            }
            break;
        }
    }
    return filterAction;
}
#end_block

#method_before
@Override
public void processPacket(PacketContext context) {
    FilterAction filterAction = prePacketProcess(context);
    if (filterAction == FilterAction.PACKET_DENY) {
        if (log.isTraceEnabled()) {
            log.trace("The packet is dropped as crossed the maxcount");
        }
        return;
    }
    // TODO filter packets sent to processors based on registrations
    for (ProcessorEntry entry : processors) {
        try {
            if (log.isTraceEnabled()) {
                log.trace("Starting packet processing by {}", entry.processor().getClass().getName());
            }
            long start = System.nanoTime();
            entry.processor().process(context);
            entry.addNanos(System.nanoTime() - start);
            if (log.isTraceEnabled()) {
                log.trace("Finished packet processing by {}", entry.processor().getClass().getName());
            }
        } catch (Exception e) {
            log.warn("Packet processor {} threw an exception", entry.processor(), e);
        }
    }
    postPacketProcess(context);
}
#method_after
@Override
public void processPacket(PacketContext context) {
    FilterAction filterAction = prePacketProcess(context);
    if (filterAction == FilterAction.PACKET_DENY) {
        if (log.isTraceEnabled()) {
            log.trace("The packet is dropped as crossed the maxcount");
        }
        return;
    }
    // TODO filter packets sent to processors based on registrations
    for (ProcessorEntry entry : processors) {
        try {
            if (log.isTraceEnabled()) {
                log.trace("Starting packet processing by {}", entry.processor().getClass().getName());
            }
            long start = System.nanoTime();
            entry.processor().process(context);
            entry.addNanos(System.nanoTime() - start);
            if (log.isTraceEnabled()) {
                log.trace("Finished packet processing by {}", entry.processor().getClass().getName());
            }
        } catch (Exception e) {
            log.warn("Packet processor {} threw an exception", entry.processor(), e);
        }
    }
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("/routes-count")
public Response getRoutesCount() {
    RouteService service = get(RouteService.class);
    ObjectNode root = mapper().createObjectNode();
    service.getRouteTables().forEach(table -> {
        Collection<RouteInfo> routes = service.getRoutes(table);
        root.put(table.name() + "PrefixCount", routes.stream().count());
    });
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("/routes/count")
public Response getRoutesCount() {
    RouteService service = get(RouteService.class);
    ObjectNode root = mapper().createObjectNode();
    service.getRouteTables().forEach(table -> {
        Collection<RouteInfo> routes = service.getRoutes(table);
        root.put(table.name() + "PrefixCount", routes.stream().count());
    });
    return ok(root).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("/routes-type-count")
public Response getRoutesCountByType() {
    RouteService service = get(RouteService.class);
    ObjectNode root = mapper().createObjectNode();
    service.getRouteTables().forEach(table -> {
        List<Route> staticRoutes = new ArrayList<>();
        List<Route> fpmRoutes = new ArrayList<>();
        List<Route> ripRoutes = new ArrayList<>();
        List<Route> dhcpRoutes = new ArrayList<>();
        List<Route> dhcpLQRoutes = new ArrayList<>();
        List<Route> bgpRoutes = new ArrayList<>();
        List<Route> routes = service.getRoutes(table).stream().flatMap(ri -> ri.allRoutes().stream()).map(ResolvedRoute::route).collect(Collectors.toList());
        routes.forEach(route -> {
            if (route.source().toString().equals(Route.Source.STATIC.toString())) {
                staticRoutes.add(route);
            }
            if (route.source().toString().equals(Route.Source.FPM.toString())) {
                fpmRoutes.add(route);
            }
            if (route.source().toString().equals(Route.Source.RIP.toString())) {
                ripRoutes.add(route);
            }
            if (route.source().toString().equals(Route.Source.DHCP.toString())) {
                dhcpRoutes.add(route);
            }
            if (route.source().toString().equals(Route.Source.DHCPLQ.toString())) {
                dhcpLQRoutes.add(route);
            }
            if (route.source().toString().equals(Route.Source.BGP.toString())) {
                bgpRoutes.add(route);
            }
        });
        root.put(table.name() + "StaticRouteCount", staticRoutes.size());
        root.put(table.name() + "FpmRouteCount", fpmRoutes.size());
        root.put(table.name() + "RipRouteCount", ripRoutes.size());
        root.put(table.name() + "DhcpRouteCount", dhcpRoutes.size());
        root.put(table.name() + "DhcpLQRouteCount", dhcpLQRoutes.size());
        root.put(table.name() + "BgpRouteCount", bgpRoutes.size());
        root.put(table.name() + "TotalRouteCount", routes.stream().count());
    });
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("/routes/types/count")
public Response getRoutesCountByType() {
    RouteService service = get(RouteService.class);
    ObjectNode root = mapper().createObjectNode();
    service.getRouteTables().forEach(table -> {
        List<Route> staticRoutes = new ArrayList<>();
        List<Route> fpmRoutes = new ArrayList<>();
        List<Route> ripRoutes = new ArrayList<>();
        List<Route> dhcpRoutes = new ArrayList<>();
        List<Route> dhcpLQRoutes = new ArrayList<>();
        List<Route> bgpRoutes = new ArrayList<>();
        List<Route> routes = service.getRoutes(table).stream().flatMap(ri -> ri.allRoutes().stream()).map(ResolvedRoute::route).collect(Collectors.toList());
        routes.forEach(route -> {
            if (route.source() == Route.Source.STATIC) {
                staticRoutes.add(route);
            }
            if (route.source() == Route.Source.FPM) {
                fpmRoutes.add(route);
            }
            if (route.source() == Route.Source.RIP) {
                ripRoutes.add(route);
            }
            if (route.source() == Route.Source.DHCP) {
                dhcpRoutes.add(route);
            }
            if (route.source() == Route.Source.DHCPLQ) {
                dhcpLQRoutes.add(route);
            }
            if (route.source() == Route.Source.BGP) {
                bgpRoutes.add(route);
            }
        });
        root.put(table.name() + "StaticRouteCount", staticRoutes.size());
        root.put(table.name() + "FpmRouteCount", fpmRoutes.size());
        root.put(table.name() + "RipRouteCount", ripRoutes.size());
        root.put(table.name() + "DhcpRouteCount", dhcpRoutes.size());
        root.put(table.name() + "DhcpLQRouteCount", dhcpLQRoutes.size());
        root.put(table.name() + "BgpRouteCount", bgpRoutes.size());
        root.put(table.name() + "TotalRouteCount", routes.stream().count());
    });
    return ok(root).build();
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    switch(event.type()) {
        case DEVICE_ADDED:
        case DEVICE_AVAILABILITY_CHANGED:
            log.debug("Device either added or availability changed {}", event.subject().id());
            devEventExecutor.execute(() -> {
                if (deviceService.isAvailable(event.subject().id())) {
                    log.debug("Device is now available {}", event.subject().id());
                    getAndInitDevicePipeliner(event.subject().id());
                } else {
                    log.debug("Device is no longer available {}", event.subject().id());
                }
            });
            break;
        case DEVICE_UPDATED:
            // Invalidate pipeliner and handler caches if the driver name
            // device annotation changed.
            devEventExecutor.execute(() -> {
                invalidatePipelinerIfNecessary(event.subject());
            });
            break;
        case DEVICE_REMOVED:
            // evict Pipeliner and Handler cache, when
            // the Device was administratively removed.
            // 
            // System expect the user to clear all existing flows,
            // before removing device, especially if they intend to
            // replace driver/pipeliner assigned to the device.
            devEventExecutor.execute(() -> {
                driverHandlers.remove(event.subject().id());
                pipeliners.remove(event.subject().id());
            });
            break;
        case DEVICE_SUSPENDED:
            break;
        case PORT_ADDED:
            break;
        case PORT_UPDATED:
            break;
        case PORT_REMOVED:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    if (devEventExecutor != null) {
        switch(event.type()) {
            case DEVICE_ADDED:
            case DEVICE_AVAILABILITY_CHANGED:
                log.debug("Device either added or availability changed {}", event.subject().id());
                devEventExecutor.execute(() -> {
                    if (deviceService.isAvailable(event.subject().id())) {
                        log.debug("Device is now available {}", event.subject().id());
                        getAndInitDevicePipeliner(event.subject().id());
                    } else {
                        log.debug("Device is no longer available {}", event.subject().id());
                    }
                });
                break;
            case DEVICE_UPDATED:
                // Invalidate pipeliner and handler caches if the driver name
                // device annotation changed.
                devEventExecutor.execute(() -> invalidatePipelinerIfNecessary(event.subject()));
                break;
            case DEVICE_REMOVED:
                // evict Pipeliner and Handler cache, when
                // the Device was administratively removed.
                // 
                // System expect the user to clear all existing flows,
                // before removing device, especially if they intend to
                // replace driver/pipeliner assigned to the device.
                devEventExecutor.execute(() -> {
                    driverHandlers.remove(event.subject().id());
                    pipeliners.remove(event.subject().id());
                });
                break;
            case DEVICE_SUSPENDED:
                break;
            case PORT_ADDED:
                break;
            case PORT_UPDATED:
                break;
            case PORT_REMOVED:
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    switch(event.type()) {
        case DEVICE_ADDED:
            devEventExecutor.execute(() -> {
                updateIgnoreVlanConfigs();
            });
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            devEventExecutor.execute(() -> {
                deviceAvailabilityChanged(device);
            });
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    if (devEventExecutor != null) {
        Device device = event.subject();
        switch(event.type()) {
            case DEVICE_ADDED:
                devEventExecutor.execute(this::updateIgnoreVlanConfigs);
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                devEventExecutor.execute(() -> deviceAvailabilityChanged(device));
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
@Override
public void waitCompletion(Class<? extends Event> eventType, String eventHint, WorkExecutor eventGenerator, long timeoutMs) {
    this.completionEventType = eventType;
    if (Objects.isNull(this.completionEventHint)) {
        this.completionEventHint = new HashSet<>();
    }
    if (Objects.nonNull(eventHint)) {
        this.completionEventHint.add(eventHint);
    }
    this.completionEventGenerator = eventGenerator;
    this.completionEventTimeoutMs = timeoutMs;
}
#method_after
@Override
public void waitCompletion(Class<? extends Event> eventType, String eventHint, WorkExecutor eventGenerator, long timeoutMs) {
    this.completionEventType = eventType;
    this.completionEventHintSet = new HashSet<>();
    this.completionEventHintSet.add(eventHint);
    this.completionEventGenerator = eventGenerator;
    this.completionEventTimeoutMs = timeoutMs;
}
#end_block

#method_before
@Override
public void waitAnyCompletion(Class<? extends Event> eventType, Set<String> eventHint, WorkExecutor eventGenerator, long timeoutMs) {
    this.completionEventType = eventType;
    if (Objects.isNull(this.completionEventHint)) {
        this.completionEventHint = new HashSet<>();
    }
    if (Objects.nonNull(eventHint)) {
        this.completionEventHint.addAll(eventHint);
    }
    this.completionEventGenerator = eventGenerator;
    this.completionEventTimeoutMs = timeoutMs;
}
#method_after
@Override
public void waitAnyCompletion(Class<? extends Event> eventType, Set<String> eventHint, WorkExecutor eventGenerator, long timeoutMs) {
    this.completionEventType = eventType;
    this.completionEventHintSet = new HashSet<>();
    this.completionEventHintSet.addAll(eventHint);
    this.completionEventGenerator = eventGenerator;
    this.completionEventTimeoutMs = timeoutMs;
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.contexteventmapstore");
    log.info("appId=" + appId);
    KryoNamespace eventMapNamespace = KryoNamespace.newBuilder().register(KryoNamespaces.API).build();
    eventMapTree = storageService.<String>documentTreeBuilder().withSerializer(Serializer.using(eventMapNamespace)).withName("context-event-map-store").withOrdering(Ordering.INSERTION).buildDocumentTree();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.contexteventmapstore");
    log.info("appId=" + appId);
    KryoNamespace eventMapNamespace = KryoNamespace.newBuilder().register(KryoNamespaces.API).build();
    eventMapTree = storageService.<String>documentTreeBuilder().withSerializer(Serializer.using(eventMapNamespace)).withName("context-event-map-store").withOrdering(Ordering.INSERTION).buildDocumentTree();
    hintSetPerCxtMap = storageService.<String, Set<String>>eventuallyConsistentMapBuilder().withName("workflow-event-hint-per-cxt").withSerializer(eventMapNamespace).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    eventMapTree.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    eventMapTree.destroy();
    hintSetPerCxtMap.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void registerEventMap(String eventType, Set<String> eventHintSet, String contextName, String programCounterString) throws WorkflowException {
    List<String> elementList = new ArrayList<>();
    elementList.add("root");
    elementList.addAll(eventHintSet);
    elementList.add(contextName);
    DocumentPath dpath = DocumentPath.from(elementList);
    String currentWorkletType = completeVersioned(eventMapTree.get(dpath));
    if (currentWorkletType == null) {
        complete(eventMapTree.createRecursive(dpath, programCounterString));
    } else {
        complete(eventMapTree.replace(dpath, programCounterString, currentWorkletType));
    }
}
#method_after
@Override
public void registerEventMap(String eventType, Set<String> eventHintSet, String contextName, String programCounterString) throws WorkflowException {
    for (String eventHint : eventHintSet) {
        // Insert in eventCxtPerHintMap
        DocumentPath dpathForCxt = DocumentPath.from(Lists.newArrayList("root", eventType, eventHint, contextName));
        String currentWorkletType = completeVersioned(eventMapTree.get(dpathForCxt));
        if (currentWorkletType == null) {
            complete(eventMapTree.createRecursive(dpathForCxt, programCounterString));
        } else {
            complete(eventMapTree.replace(dpathForCxt, programCounterString, currentWorkletType));
        }
        log.trace("RegisterEventMap for eventType:{}, eventSet:{}, contextName:{}, pc:{}", eventType, eventHintSet, contextName, programCounterString);
    }
    hintSetPerCxtMap.put(contextName, eventHintSet);
    log.trace("RegisterEventMap in hintSetPerCxt for " + "eventType:{}, eventSet:{}, contextName:{}, pc:{}", eventType, eventHintSet, contextName, programCounterString);
}
#end_block

#method_before
@Override
public void unregisterEventMap(String eventType, Set<String> eventHintSet, String contextName) throws WorkflowException {
    List<String> elementList = new ArrayList<>();
    elementList.add("root");
    elementList.addAll(eventHintSet);
    elementList.add(contextName);
    DocumentPath contextPath = DocumentPath.from(elementList);
    complete(eventMapTree.removeNode(contextPath));
}
#method_after
@Override
public void unregisterEventMap(String eventType, String contextName) throws WorkflowException {
    Set<String> hints = hintSetPerCxtMap.get(contextName);
    for (String eventHint : hints) {
        // Remove from eventCxtPerHintMap
        complete(eventMapTree.removeNode(DocumentPath.from(Lists.newArrayList("root", eventType, eventHint, contextName))));
        log.trace("UnregisterEventMap from eventCxtPerHintMap for eventType:{}, eventSet:{}, contextName:{}", eventType, eventHint, contextName);
    }
    hintSetPerCxtMap.remove(contextName);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof EventTask)) {
        return false;
    }
    return Objects.equals(this.eventType(), ((EventTask) obj).eventType()) && Objects.equals(this.eventHint(), ((EventTask) obj).eventHint());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (!(obj instanceof EventTask)) {
        return false;
    }
    return Objects.equals(this.eventType(), ((EventTask) obj).eventType()) && Objects.equals(this.eventHintSet(), ((EventTask) obj).eventHint());
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("context", context()).add("programCounter", programCounter()).add("eventType", eventType()).add("eventHint", eventHint()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("context", context()).add("programCounter", programCounter()).add("eventType", eventType()).add("eventHint", eventHintSet()).toString();
}
#end_block

#method_before
@Override
public void eventMapTrigger(Event event, EventHintSupplier supplier) {
    if (event.subject() instanceof SystemWorkflowContext) {
        return;
    }
    Map<String, String> eventMap;
    Set<String> eventHint;
    try {
        eventHint = supplier.apply(event);
    } catch (Throwable e) {
        log.error("Exception: ", e);
        return;
    }
    if (eventHint == null) {
        // do nothing
        log.error("Invalid eventHint, event: {}", event);
        return;
    }
    try {
        eventMap = eventMapStore.getEventMap(event.getClass().getName(), eventHint);
    } catch (WorkflowException e) {
        log.error("Exception: ", e);
        return;
    }
    if (Objects.isNull(eventMap) || eventMap.isEmpty()) {
        // do nothing;
        log.debug("Invalid eventMap, event: {}", event);
        return;
    }
    for (Map.Entry<String, String> entry : eventMap.entrySet()) {
        String contextName = entry.getKey();
        String strProgramCounter = entry.getValue();
        ProgramCounter pc;
        try {
            pc = ProgramCounter.valueOf(strProgramCounter);
        } catch (IllegalArgumentException e) {
            log.error("Exception: ", e);
            return;
        }
        WorkflowContext context = workplaceStore.getContext(contextName);
        if (Objects.isNull(context)) {
            log.info("Invalid context: {}, event: {}", contextName, event);
            continue;
        }
        EventTask eventtask = null;
        try {
            eventtask = EventTask.builder().event(event).eventHint(eventHint).context(context).programCounter(pc).build();
        } catch (WorkflowException e) {
            log.error("Exception: ", e);
        }
        log.debug("eventtaskAccumulator.add: task: {}", eventtask);
        if (!Objects.isNull(eventtask)) {
            eventtaskAccumulator.add(eventtask);
        }
    }
}
#method_after
@Override
public void eventMapTrigger(Event event, EventHintSupplier supplier) {
    if (event.subject() instanceof SystemWorkflowContext) {
        return;
    }
    Map<String, String> eventMap;
    String eventHint;
    try {
        eventHint = supplier.apply(event);
    } catch (Throwable e) {
        log.error("Exception: ", e);
        return;
    }
    if (eventHint == null) {
        // do nothing
        log.error("Invalid eventHint, event: {}", event);
        return;
    }
    try {
        eventMap = eventMapStore.getEventMapByHint(event.getClass().getName(), eventHint);
    } catch (WorkflowException e) {
        log.error("Exception: ", e);
        return;
    }
    if (Objects.isNull(eventMap) || eventMap.isEmpty()) {
        // do nothing;
        log.debug("Invalid eventMap, event: {}", event);
        return;
    }
    for (Map.Entry<String, String> entry : eventMap.entrySet()) {
        String contextName = entry.getKey();
        String strProgramCounter = entry.getValue();
        ProgramCounter pc;
        try {
            pc = ProgramCounter.valueOf(strProgramCounter);
        } catch (IllegalArgumentException e) {
            log.error("Exception: ", e);
            return;
        }
        WorkflowContext context = workplaceStore.getContext(contextName);
        if (Objects.isNull(context)) {
            log.info("Invalid context: {}, event: {}", contextName, event);
            continue;
        }
        EventTask eventtask = null;
        try {
            eventtask = EventTask.builder().event(event).eventHint(eventHint).context(context).programCounter(pc).build();
        } catch (WorkflowException e) {
            log.error("Exception: ", e);
        }
        log.debug("eventtaskAccumulator.add: task: {}", eventtask);
        if (!Objects.isNull(eventtask)) {
            eventtaskAccumulator.add(eventtask);
        }
    }
}
#end_block

#method_before
@Override
public void registerEventMap(Class<? extends Event> eventType, Set<String> eventHintSet, String contextName, String programCounterString) throws WorkflowException {
    eventMapStore.registerEventMap(eventType.getName(), eventHintSet, contextName, programCounterString);
    for (int i = 0; i < MAX_REGISTER_EVENTMAP_WAITS; i++) {
        Map<String, String> eventMap = eventMapStore.getEventMap(eventType.getName(), eventHintSet);
        if (eventMap != null && eventMap.containsKey(contextName)) {
            return;
        }
        try {
            log.info("sleep {}", i);
            Thread.sleep(10L * (i + 1));
        } catch (InterruptedException e) {
            log.error("Exception: ", e);
            Thread.currentThread().interrupt();
        }
    }
}
#method_after
@Override
public void registerEventMap(Class<? extends Event> eventType, Set<String> eventHintSet, String contextName, String programCounterString) throws WorkflowException {
    eventMapStore.registerEventMap(eventType.getName(), eventHintSet, contextName, programCounterString);
    for (String eventHint : eventHintSet) {
        for (int i = 0; i < MAX_REGISTER_EVENTMAP_WAITS; i++) {
            Map<String, String> eventMap = eventMapStore.getEventMapByHint(eventType.getName(), eventHint);
            if (eventMap != null && eventMap.containsKey(contextName)) {
                break;
            }
            try {
                log.info("sleep {}", i);
                Thread.sleep(10L * (i + 1));
            } catch (InterruptedException e) {
                log.error("Exception: ", e);
                Thread.currentThread().interrupt();
            }
        }
    }
}
#end_block

#method_before
@Override
protected void post(WorkflowDataEvent event) {
    if (event.subject() == null || !isRelevant(event.subject())) {
        log.debug("ignore event {}", event);
        return;
    }
    // trigger next worklet selection
    WorkflowData dataModelContainer = event.subject();
    switch(event.type()) {
        case INSERT:
        case UPDATE:
            if (dataModelContainer.triggerNext()) {
                log.debug("workflowAccumulator.add: {}", dataModelContainer);
                workflowAccumulator.add(dataModelContainer);
            } else {
                log.debug("pass-workflowAccumulator.add: {}", dataModelContainer);
            }
            break;
        case REMOVE:
            break;
        default:
    }
    // trigger EventTask for WorkflowDataEvent
    eventMapTriggerExecutor.submit(() -> eventMapTrigger(event, // event hint supplier
    (ev) -> {
        if (ev == null || ev.subject() == null) {
            return null;
        }
        if (ev.subject() instanceof WorkflowData) {
            return Sets.newHashSet(((WorkflowData) ev.subject()).name());
        } else {
            return null;
        }
    }));
}
#method_after
@Override
protected void post(WorkflowDataEvent event) {
    if (event.subject() == null || !isRelevant(event.subject())) {
        log.debug("ignore event {}", event);
        return;
    }
    // trigger next worklet selection
    WorkflowData dataModelContainer = event.subject();
    switch(event.type()) {
        case INSERT:
        case UPDATE:
            if (dataModelContainer.triggerNext()) {
                log.debug("workflowAccumulator.add: {}", dataModelContainer);
                workflowAccumulator.add(dataModelContainer);
            } else {
                log.debug("pass-workflowAccumulator.add: {}", dataModelContainer);
            }
            break;
        case REMOVE:
            break;
        default:
    }
    // trigger EventTask for WorkflowDataEvent
    eventMapTriggerExecutor.submit(() -> eventMapTrigger(event, // event hint supplier
    (ev) -> {
        if (ev == null || ev.subject() == null) {
            return null;
        }
        if (ev.subject() instanceof WorkflowData) {
            return ((WorkflowData) ev.subject()).name();
        } else {
            return null;
        }
    }));
}
#end_block

#method_before
private EventTask execEventTask(EventTask task) {
    Map<String, String> eventMap = null;
    try {
        eventMap = eventMapStore.getEventMap(task.event().getClass().getName(), task.eventHint());
    } catch (WorkflowException e) {
        log.error("Exception: {}, trace: {}", e, Lists.newArrayList(e.getStackTrace()));
        return task;
    }
    if (Objects.isNull(eventMap) || eventMap.isEmpty()) {
        return task;
    }
    if (Objects.isNull(eventMap.get(task.context().name()))) {
        return task;
    }
    log.debug("execEventTask- task: {}, hash: {}", task, stringHash(task.context().distributor()));
    WorkflowContext context = (WorkflowContext) (task.context());
    Workflow workflow = workflowStore.get(context.workflowId());
    if (workflow == null) {
        log.error("Invalid workflow {}", context.workflowId());
        return task;
    }
    WorkflowContext latestContext = workplaceStore.getContext(context.name());
    if (latestContext == null) {
        log.error("Invalid workflow context {}", context.name());
        return task;
    }
    try {
        if (!Objects.equals(latestContext.current(), task.programCounter())) {
            log.error("Current worklet({}) is not mismatched with task work({}). Ignored.", latestContext.current(), task.programCounter());
            return task;
        }
        Worklet worklet = workflow.getWorkletInstance(task.programCounter().workletType());
        if (Worklet.Common.COMPLETED.equals(worklet) || Worklet.Common.INIT.equals(worklet)) {
            log.error("Current worklet is {}, Ignored", worklet);
            return task;
        }
        initWorkletExecution(latestContext);
        log.info("{} worklet.isCompleted:{}", latestContext.name(), worklet.tag());
        log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
        dataModelInjector.inject(worklet, latestContext);
        boolean completed = worklet.isCompleted(latestContext, task.event());
        dataModelInjector.inhale(worklet, latestContext);
        if (completed) {
            log.info("{} worklet.isCompleted(true):{}", latestContext.name(), worklet.tag());
            log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
            eventMapStore.unregisterEventMap(task.eventType(), task.eventHint(), latestContext.name());
            // completed case
            // increase program counter
            ProgramCounter pc = latestContext.current();
            latestContext.setCurrent(workflow.increased(pc));
            workplaceStore.commitContext(latestContext.name(), latestContext, true);
            return null;
        } else {
            log.info("{} worklet.isCompleted(false):{}", latestContext.name(), worklet.tag());
            log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
            workplaceStore.commitContext(latestContext.name(), latestContext, false);
        }
    } catch (WorkflowException e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    } catch (StorageException e) {
        log.error("Exception: ", e);
    // StorageException does not commit context.
    } catch (Exception e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    }
    return task;
}
#method_after
private EventTask execEventTask(EventTask task) {
    if (!eventMapStore.isEventMapPresent(task.context().name())) {
        log.trace("EventMap doesnt exist for taskcontext:{}", task.context().name());
        return task;
    }
    log.debug("execEventTask- task: {}, hash: {}", task, stringHash(task.context().distributor()));
    WorkflowContext context = (WorkflowContext) (task.context());
    Workflow workflow = workflowStore.get(context.workflowId());
    if (workflow == null) {
        log.error("Invalid workflow {}", context.workflowId());
        return task;
    }
    WorkflowContext latestContext = workplaceStore.getContext(context.name());
    if (latestContext == null) {
        log.error("Invalid workflow context {}", context.name());
        return task;
    }
    try {
        if (!Objects.equals(latestContext.current(), task.programCounter())) {
            log.error("Current worklet({}) is not mismatched with task work({}). Ignored.", latestContext.current(), task.programCounter());
            return task;
        }
        Worklet worklet = workflow.getWorkletInstance(task.programCounter().workletType());
        if (Worklet.Common.COMPLETED.equals(worklet) || Worklet.Common.INIT.equals(worklet)) {
            log.error("Current worklet is {}, Ignored", worklet);
            return task;
        }
        initWorkletExecution(latestContext);
        log.info("{} worklet.isCompleted:{}", latestContext.name(), worklet.tag());
        log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
        dataModelInjector.inject(worklet, latestContext);
        boolean completed = worklet.isCompleted(latestContext, task.event());
        dataModelInjector.inhale(worklet, latestContext);
        if (completed) {
            log.info("{} worklet.isCompleted(true):{}", latestContext.name(), worklet.tag());
            log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
            eventMapStore.unregisterEventMap(task.eventType(), latestContext.name());
            // completed case
            // increase program counter
            ProgramCounter pc = latestContext.current();
            latestContext.setCurrent(workflow.increased(pc));
            workplaceStore.commitContext(latestContext.name(), latestContext, true);
            return null;
        } else {
            log.info("{} worklet.isCompleted(false):{}", latestContext.name(), worklet.tag());
            log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
            workplaceStore.commitContext(latestContext.name(), latestContext, false);
        }
    } catch (WorkflowException e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    } catch (StorageException e) {
        log.error("Exception: ", e);
    // StorageException does not commit context.
    } catch (Exception e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    }
    return task;
}
#end_block

#method_before
private HandlerTask execEventTimeoutTask(EventTimeoutTask task) {
    Map<String, String> eventMap = null;
    try {
        eventMap = eventMapStore.getEventMap(task.eventType(), task.eventHint());
    } catch (WorkflowException e) {
        log.error("execEventTimeoutTask: Exception: {}, trace: {}", e, Lists.newArrayList(e.getStackTrace()));
        return task;
    }
    if (Objects.isNull(eventMap) || eventMap.isEmpty()) {
        return task;
    }
    if (Objects.isNull(eventMap.get(task.context().name()))) {
        return task;
    }
    log.debug("execEventTimeoutTask- task: {}, hash: {}", task, stringHash(task.context().distributor()));
    WorkflowContext context = (WorkflowContext) (task.context());
    Workflow workflow = workflowStore.get(context.workflowId());
    if (workflow == null) {
        log.error("execEventTimeoutTask: Invalid workflow {}", context.workflowId());
        return task;
    }
    WorkflowContext latestContext = workplaceStore.getContext(context.name());
    if (latestContext == null) {
        log.error("execEventTimeoutTask: Invalid workflow context {}", context.name());
        return task;
    }
    try {
        if (!Objects.equals(latestContext.current(), task.programCounter())) {
            log.error("execEventTimeoutTask: Current worklet({}) is not mismatched with task work({}). Ignored.", latestContext.current(), task.programCounter());
            return task;
        }
        Worklet worklet = workflow.getWorkletInstance(task.programCounter().workletType());
        if (worklet == Worklet.Common.COMPLETED || worklet == Worklet.Common.INIT) {
            log.error("execEventTimeoutTask: Current worklet is {}, Ignored", worklet);
            return task;
        }
        initWorkletExecution(latestContext);
        eventMapStore.unregisterEventMap(task.eventType(), task.eventHint(), latestContext.name());
        log.info("{} worklet.timeout(for event):{}", latestContext.name(), worklet.tag());
        log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
        dataModelInjector.inject(worklet, latestContext);
        worklet.timeout(latestContext);
        dataModelInjector.inhale(worklet, latestContext);
        log.info("{} worklet.timeout(for event)(done):{}", latestContext.name(), worklet.tag());
        log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
        workplaceStore.commitContext(latestContext.name(), latestContext, latestContext.triggerNext());
    } catch (WorkflowException e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    } catch (StorageException e) {
        log.error("Exception: ", e);
    // StorageException does not commit context.
    } catch (Exception e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    }
    return task;
}
#method_after
private HandlerTask execEventTimeoutTask(EventTimeoutTask task) {
    if (!eventMapStore.isEventMapPresent(task.context().name())) {
        log.trace("EventMap doesnt exist for taskcontext:{}", task.context().name());
        return task;
    }
    log.debug("execEventTimeoutTask- task: {}, hash: {}", task, stringHash(task.context().distributor()));
    WorkflowContext context = (WorkflowContext) (task.context());
    Workflow workflow = workflowStore.get(context.workflowId());
    if (workflow == null) {
        log.error("execEventTimeoutTask: Invalid workflow {}", context.workflowId());
        return task;
    }
    WorkflowContext latestContext = workplaceStore.getContext(context.name());
    if (latestContext == null) {
        log.error("execEventTimeoutTask: Invalid workflow context {}", context.name());
        return task;
    }
    try {
        if (!Objects.equals(latestContext.current(), task.programCounter())) {
            log.error("execEventTimeoutTask: Current worklet({}) is not mismatched with task work({}). Ignored.", latestContext.current(), task.programCounter());
            return task;
        }
        Worklet worklet = workflow.getWorkletInstance(task.programCounter().workletType());
        if (worklet == Worklet.Common.COMPLETED || worklet == Worklet.Common.INIT) {
            log.error("execEventTimeoutTask: Current worklet is {}, Ignored", worklet);
            return task;
        }
        initWorkletExecution(latestContext);
        eventMapStore.unregisterEventMap(task.eventType(), latestContext.name());
        log.info("{} worklet.timeout(for event):{}", latestContext.name(), worklet.tag());
        log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
        dataModelInjector.inject(worklet, latestContext);
        worklet.timeout(latestContext);
        dataModelInjector.inhale(worklet, latestContext);
        log.info("{} worklet.timeout(for event)(done):{}", latestContext.name(), worklet.tag());
        log.trace("{} task:{}, context: {}", latestContext.name(), task, latestContext);
        workplaceStore.commitContext(latestContext.name(), latestContext, latestContext.triggerNext());
    } catch (WorkflowException e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    } catch (StorageException e) {
        log.error("Exception: ", e);
    // StorageException does not commit context.
    } catch (Exception e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    }
    return task;
}
#end_block

#method_before
private WorkflowContext execWorkflowContext(WorkflowContext context) {
    Workflow workflow = workflowStore.get(context.workflowId());
    if (workflow == null) {
        log.error("Invalid workflow {}", context.workflowId());
        return null;
    }
    final WorkflowContext latestContext = workplaceStore.getContext(context.name());
    if (latestContext == null) {
        log.error("Invalid workflow context {}", context.name());
        return null;
    }
    initWorkletExecution(latestContext);
    try {
        final ProgramCounter pc = workflow.next(latestContext);
        final Worklet worklet = workflow.getWorkletInstance(pc.workletType());
        if (worklet == Worklet.Common.INIT) {
            log.error("workflow.next gave INIT. It cannot be executed (context: {})", context.name());
            return latestContext;
        }
        latestContext.setCurrent(pc);
        if (worklet == Worklet.Common.COMPLETED) {
            if (workflow.attributes().contains(REMOVE_AFTER_COMPLETE)) {
                workplaceStore.removeContext(latestContext.name());
                return null;
            } else {
                latestContext.setState(WorkflowState.IDLE);
                workplaceStore.commitContext(latestContext.name(), latestContext, false);
                return latestContext;
            }
        }
        log.info("{} worklet.process:{}", latestContext.name(), worklet.tag());
        log.trace("{} context: {}", latestContext.name(), latestContext);
        dataModelInjector.inject(worklet, latestContext);
        worklet.process(latestContext);
        dataModelInjector.inhale(worklet, latestContext);
        log.info("{} worklet.process(done): {}", latestContext.name(), worklet.tag());
        log.trace("{} context: {}", latestContext.name(), latestContext);
        if (latestContext.completionEventType() != null) {
            if (latestContext.completionEventGenerator() == null) {
                String msg = String.format("Invalid exepecting event(%s), generator(%s)", latestContext.completionEventType(), latestContext.completionEventGenerator());
                throw new WorkflowException(msg);
            }
            registerEventMap(latestContext.completionEventType(), latestContext.completionEventHint(), latestContext.name(), pc.toString());
            latestContext.completionEventGenerator().apply();
            if (latestContext.completionEventTimeout() != 0L) {
                final EventTimeoutTask eventTimeoutTask = EventTimeoutTask.builder().context(latestContext).programCounter(pc).eventType(latestContext.completionEventType().getName()).eventHintSet(latestContext.completionEventHint()).build();
                timerChain.schedule(latestContext.completionEventTimeout(), () -> {
                    eventtaskAccumulator.add(eventTimeoutTask);
                });
            }
        } else {
            if (latestContext.completionEventTimeout() != 0L) {
                final TimeoutTask timeoutTask = TimeoutTask.builder().context(latestContext).programCounter(pc).build();
                timerChain.schedule(latestContext.completionEventTimeout(), () -> {
                    eventtaskAccumulator.add(timeoutTask);
                });
            } else {
                // completed case
                // increase program counter
                latestContext.setCurrent(workflow.increased(pc));
            }
        }
        workplaceStore.commitContext(latestContext.name(), latestContext, latestContext.triggerNext());
    } catch (WorkflowException e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    } catch (StorageException e) {
        log.error("Exception: ", e);
    // StorageException does not commit context.
    } catch (Exception e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    }
    return latestContext;
}
#method_after
private WorkflowContext execWorkflowContext(WorkflowContext context) {
    Workflow workflow = workflowStore.get(context.workflowId());
    if (workflow == null) {
        log.error("Invalid workflow {}", context.workflowId());
        return null;
    }
    final WorkflowContext latestContext = workplaceStore.getContext(context.name());
    if (latestContext == null) {
        log.error("Invalid workflow context {}", context.name());
        return null;
    }
    initWorkletExecution(latestContext);
    try {
        final ProgramCounter pc = workflow.next(latestContext);
        final Worklet worklet = workflow.getWorkletInstance(pc.workletType());
        if (worklet == Worklet.Common.INIT) {
            log.error("workflow.next gave INIT. It cannot be executed (context: {})", context.name());
            return latestContext;
        }
        latestContext.setCurrent(pc);
        if (worklet == Worklet.Common.COMPLETED) {
            if (workflow.attributes().contains(REMOVE_AFTER_COMPLETE)) {
                workplaceStore.removeContext(latestContext.name());
                return null;
            } else {
                latestContext.setState(WorkflowState.IDLE);
                workplaceStore.commitContext(latestContext.name(), latestContext, false);
                return latestContext;
            }
        }
        log.info("{} worklet.process:{}", latestContext.name(), worklet.tag());
        log.trace("{} context: {}", latestContext.name(), latestContext);
        dataModelInjector.inject(worklet, latestContext);
        worklet.process(latestContext);
        dataModelInjector.inhale(worklet, latestContext);
        log.info("{} worklet.process(done): {}", latestContext.name(), worklet.tag());
        log.trace("{} context: {}", latestContext.name(), latestContext);
        if (latestContext.completionEventType() != null) {
            if (latestContext.completionEventGenerator() == null) {
                String msg = String.format("Invalid exepecting event(%s), generator(%s)", latestContext.completionEventType(), latestContext.completionEventGenerator());
                throw new WorkflowException(msg);
            }
            registerEventMap(latestContext.completionEventType(), latestContext.completionEventHints(), latestContext.name(), pc.toString());
            latestContext.completionEventGenerator().apply();
            if (latestContext.completionEventTimeout() != 0L) {
                final EventTimeoutTask eventTimeoutTask = EventTimeoutTask.builder().context(latestContext).programCounter(pc).eventType(latestContext.completionEventType().getName()).eventHintSet(latestContext.completionEventHints()).build();
                timerChain.schedule(latestContext.completionEventTimeout(), () -> {
                    eventtaskAccumulator.add(eventTimeoutTask);
                });
            }
        } else {
            if (latestContext.completionEventTimeout() != 0L) {
                final TimeoutTask timeoutTask = TimeoutTask.builder().context(latestContext).programCounter(pc).build();
                timerChain.schedule(latestContext.completionEventTimeout(), () -> {
                    eventtaskAccumulator.add(timeoutTask);
                });
            } else {
                // completed case
                // increase program counter
                latestContext.setCurrent(workflow.increased(pc));
            }
        }
        workplaceStore.commitContext(latestContext.name(), latestContext, latestContext.triggerNext());
    } catch (WorkflowException e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    } catch (StorageException e) {
        log.error("Exception: ", e);
    // StorageException does not commit context.
    } catch (Exception e) {
        log.error("Exception: ", e);
        latestContext.setCause(e.getMessage());
        latestContext.setState(WorkflowState.EXCEPTION);
        workplaceStore.commitContext(latestContext.name(), latestContext, false);
    }
    return latestContext;
}
#end_block

#method_before
private void generateAclFlow(AclRule rule, DeviceId deviceId) {
    if (rule == null || aclStore.checkIfRuleWorksInDevice(rule.id(), deviceId)) {
        return;
    }
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    FlowEntry.Builder flowEntry = DefaultFlowEntry.builder();
    if (rule.srcMac() != null) {
        selectorBuilder.matchEthSrc(rule.srcMac());
    }
    if (rule.dstMac() != null) {
        selectorBuilder.matchEthDst(rule.dstMac());
    }
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4);
    if (rule.srcIp() != null) {
        selectorBuilder.matchIPSrc(rule.srcIp());
        if (rule.dstIp() != null) {
            selectorBuilder.matchIPDst(rule.dstIp());
        }
    } else {
        selectorBuilder.matchIPDst(rule.dstIp());
    }
    if (rule.srcIp6() != null) {
        selectorBuilder.matchIPv6Src(rule.srcIp6());
        if (rule.dstIp6() != null) {
            selectorBuilder.matchIPv6Dst(rule.dstIp6());
        }
    } else {
        selectorBuilder.matchIPv6Dst(rule.dstIp6());
    }
    if (rule.ipProto() != 0) {
        selectorBuilder.matchIPProtocol(Integer.valueOf(rule.ipProto()).byteValue());
    }
    if (rule.dscp() != 0) {
        selectorBuilder.matchIPDscp(Byte.valueOf(rule.dscp()));
    }
    if (rule.dstTpPort() != 0) {
        switch(rule.ipProto()) {
            case IPv4.PROTOCOL_TCP:
                selectorBuilder.matchTcpDst(TpPort.tpPort(rule.dstTpPort()));
                break;
            case IPv4.PROTOCOL_UDP:
                selectorBuilder.matchUdpDst(TpPort.tpPort(rule.dstTpPort()));
                break;
            default:
                break;
        }
    }
    if (rule.srcTpPort() != 0) {
        switch(rule.ipProto()) {
            case IPv4.PROTOCOL_TCP:
                selectorBuilder.matchTcpSrc(TpPort.tpPort(rule.srcTpPort()));
                break;
            case IPv4.PROTOCOL_UDP:
                selectorBuilder.matchUdpSrc(TpPort.tpPort(rule.srcTpPort()));
                break;
            default:
                break;
        }
    }
    if (rule.action() == AclRule.Action.ALLOW) {
        treatment.add(Instructions.createOutput(PortNumber.CONTROLLER));
    }
    flowEntry.forDevice(deviceId);
    flowEntry.withPriority(aclStore.getPriorityByDevice(deviceId));
    flowEntry.withSelector(selectorBuilder.build());
    flowEntry.withTreatment(treatment.build());
    flowEntry.fromApp(appId);
    flowEntry.makePermanent();
    // install flow rule
    flowRuleService.applyFlowRules(flowEntry.build());
    log.debug("ACL flow rule {} is installed in {}.", flowEntry.build(), deviceId);
    aclStore.addRuleToFlowMapping(rule.id(), flowEntry.build());
    aclStore.addRuleToDeviceMapping(rule.id(), deviceId);
}
#method_after
private void generateAclFlow(AclRule rule, DeviceId deviceId) {
    if (rule == null || aclStore.checkIfRuleWorksInDevice(rule.id(), deviceId)) {
        return;
    }
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    FlowEntry.Builder flowEntry = DefaultFlowEntry.builder();
    if (rule.srcMac() != null) {
        selectorBuilder.matchEthSrc(rule.srcMac());
    }
    if (rule.dstMac() != null) {
        selectorBuilder.matchEthDst(rule.dstMac());
    }
    if (rule.srcIp() != null || rule.dstIp() != null) {
        selectorBuilder.matchEthType(Ethernet.TYPE_IPV4);
        if (rule.srcIp() != null) {
            selectorBuilder.matchIPSrc(rule.srcIp());
            if (rule.dstIp() != null) {
                selectorBuilder.matchIPDst(rule.dstIp());
            }
        } else {
            selectorBuilder.matchIPDst(rule.dstIp());
        }
    } else {
        selectorBuilder.matchEthType(Ethernet.TYPE_IPV6);
        if (rule.srcIp6() != null) {
            selectorBuilder.matchIPv6Src(rule.srcIp6());
            if (rule.dstIp6() != null) {
                selectorBuilder.matchIPv6Dst(rule.dstIp6());
            }
        } else {
            selectorBuilder.matchIPv6Dst(rule.dstIp6());
        }
    }
    if (rule.ipProto() != 0) {
        selectorBuilder.matchIPProtocol(Integer.valueOf(rule.ipProto()).byteValue());
    }
    if (rule.dscp() != 0) {
        selectorBuilder.matchIPDscp(Byte.valueOf(rule.dscp()));
    }
    if (rule.dstTpPort() != 0) {
        switch(rule.ipProto()) {
            case IPv4.PROTOCOL_TCP:
                selectorBuilder.matchTcpDst(TpPort.tpPort(rule.dstTpPort()));
                break;
            case IPv4.PROTOCOL_UDP:
                selectorBuilder.matchUdpDst(TpPort.tpPort(rule.dstTpPort()));
                break;
            default:
                break;
        }
    }
    if (rule.srcTpPort() != 0) {
        switch(rule.ipProto()) {
            case IPv4.PROTOCOL_TCP:
                selectorBuilder.matchTcpSrc(TpPort.tpPort(rule.srcTpPort()));
                break;
            case IPv4.PROTOCOL_UDP:
                selectorBuilder.matchUdpSrc(TpPort.tpPort(rule.srcTpPort()));
                break;
            default:
                break;
        }
    }
    if (rule.action() == AclRule.Action.ALLOW) {
        treatment.add(Instructions.createOutput(PortNumber.CONTROLLER));
    }
    flowEntry.forDevice(deviceId);
    flowEntry.withPriority(aclStore.getPriorityByDevice(deviceId));
    flowEntry.withSelector(selectorBuilder.build());
    flowEntry.withTreatment(treatment.build());
    flowEntry.fromApp(appId);
    flowEntry.makePermanent();
    // install flow rule
    flowRuleService.applyFlowRules(flowEntry.build());
    log.debug("ACL flow rule {} is installed in {}.", flowEntry.build(), deviceId);
    aclStore.addRuleToFlowMapping(rule.id(), flowEntry.build());
    aclStore.addRuleToDeviceMapping(rule.id(), deviceId);
}
#end_block

#method_before
public AclRule build() {
    checkState(srcIp != null && dstIp != null && srcIp6 != null && dstIp6 != null, "Either srcIp or dstIp must be assigned.");
    checkState(ipProto == 0 || ipProto == IPv4.PROTOCOL_ICMP || ipProto == IPv4.PROTOCOL_TCP || ipProto == IPv4.PROTOCOL_UDP || ipProto == IPv6.PROTOCOL_ICMP6 || ipProto == IPv6.PROTOCOL_TCP || ipProto == IPv6.PROTOCOL_UDP, "ipProto must be assigned to TCP, UDP, or ICMP.");
    return new AclRule(srcMac, dstMac, srcIp, dstIp, srcIp6, dstIp6, ipProto, dscp, dstTpPort, srcTpPort, action);
}
#method_after
public AclRule build() {
    boolean assigned = true, notAssigned = false;
    checkState(!((srcIp != null || dstIp != null) && (srcIp6 != null || dstIp6 != null)), "Either Ipv4 or Ipv6 must be assigned.");
    checkState((srcIp != null || dstIp != null) ? assigned : (srcIp6 != null || dstIp6 != null) ? assigned : notAssigned, "Either srcIp or dstIp must be assigned.");
    checkState(ipProto == 0 || ipProto == IPv4.PROTOCOL_ICMP || ipProto == IPv4.PROTOCOL_TCP || ipProto == IPv4.PROTOCOL_UDP || ipProto == IPv6.PROTOCOL_ICMP6 || ipProto == IPv6.PROTOCOL_TCP || ipProto == IPv6.PROTOCOL_UDP, "ipProto must be assigned to TCP, UDP, or ICMP.");
    return new AclRule(srcMac, dstMac, srcIp, dstIp, srcIp6, dstIp6, ipProto, dscp, dstTpPort, srcTpPort, action);
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getFlows() {
    final Iterable<Device> devices = get(DeviceService.class).getDevices();
    FlowRuleService service = get(FlowRuleService.class);
    for (final Device device : devices) {
        final Iterable<FlowEntry> flowEntries = service.getFlowEntries(device.id());
        if (flowEntries != null) {
            for (final FlowEntry entry : flowEntries) {
                flowsNode.add(codec(FlowEntry.class).encode(entry, this));
            }
        }
    }
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getFlows() {
    ObjectNode root = mapper().createObjectNode();
    ArrayNode flowsNode = root.putArray(FLOWS);
    FlowRuleService service = get(FlowRuleService.class);
    Iterable<Device> devices = get(DeviceService.class).getDevices();
    for (Device device : devices) {
        Iterable<FlowEntry> flowEntries = service.getFlowEntries(device.id());
        if (flowEntries != null) {
            for (FlowEntry entry : flowEntries) {
                flowsNode.add(codec(FlowEntry.class).encode(entry, this));
            }
        }
    }
    return ok(root).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("pending")
public Response getPendingFlows() {
    FlowRuleService service = get(FlowRuleService.class);
    final Iterable<Device> devices = get(DeviceService.class).getDevices();
    for (final Device device : devices) {
        final Iterable<FlowEntry> flowEntries = service.getFlowEntries(device.id());
        if (flowEntries != null) {
            for (final FlowEntry entry : flowEntries) {
                if ((entry.state() == FlowEntry.FlowEntryState.PENDING_ADD) || (entry.state() == FlowEntry.FlowEntryState.PENDING_REMOVE)) {
                    flowsNode.add(codec(FlowEntry.class).encode(entry, this));
                }
            }
        }
    }
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("pending")
public Response getPendingFlows() {
    ObjectNode root = mapper().createObjectNode();
    ArrayNode flowsNode = root.putArray(FLOWS);
    FlowRuleService service = get(FlowRuleService.class);
    Iterable<Device> devices = get(DeviceService.class).getDevices();
    for (Device device : devices) {
        Iterable<FlowEntry> flowEntries = service.getFlowEntries(device.id());
        if (flowEntries != null) {
            for (FlowEntry entry : flowEntries) {
                if ((entry.state() == FlowEntry.FlowEntryState.PENDING_ADD) || (entry.state() == FlowEntry.FlowEntryState.PENDING_REMOVE)) {
                    flowsNode.add(codec(FlowEntry.class).encode(entry, this));
                }
            }
        }
    }
    return ok(root).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("table/{tableId}")
public Response getTableFlows(@PathParam("tableId") int tableId) {
    FlowRuleService service = get(FlowRuleService.class);
    final Iterable<Device> devices = get(DeviceService.class).getDevices();
    for (final Device device : devices) {
        final Iterable<FlowEntry> flowEntries = service.getFlowEntries(device.id());
        if (flowEntries != null) {
            for (final FlowEntry entry : flowEntries) {
                if (((IndexTableId) entry.table()).id() == tableId) {
                    flowsNode.add(codec(FlowEntry.class).encode(entry, this));
                }
            }
        }
    }
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("table/{tableId}")
public Response getTableFlows(@PathParam("tableId") int tableId) {
    ObjectNode root = mapper().createObjectNode();
    ArrayNode flowsNode = root.putArray(FLOWS);
    FlowRuleService service = get(FlowRuleService.class);
    Iterable<Device> devices = get(DeviceService.class).getDevices();
    for (Device device : devices) {
        Iterable<FlowEntry> flowEntries = service.getFlowEntries(device.id());
        if (flowEntries != null) {
            for (FlowEntry entry : flowEntries) {
                if (((IndexTableId) entry.table()).id() == tableId) {
                    flowsNode.add(codec(FlowEntry.class).encode(entry, this));
                }
            }
        }
    }
    return ok(root).build();
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFlows(@QueryParam("appId") String appId, InputStream stream) {
    FlowRuleService service = get(FlowRuleService.class);
    try {
        ObjectNode jsonTree = readTreeFromStream(mapper(), stream);
        ArrayNode flowsArray = nullIsIllegal((ArrayNode) jsonTree.get(FLOWS), FLOW_ARRAY_REQUIRED);
        if (appId != null) {
            flowsArray.forEach(flowJson -> ((ObjectNode) flowJson).put("appId", appId));
        }
        List<FlowRule> rules = codec(FlowRule.class).decode(flowsArray, this);
        service.applyFlowRules(rules.toArray(new FlowRule[rules.size()]));
        rules.forEach(flowRule -> {
            ObjectNode flowNode = mapper().createObjectNode();
            flowNode.put(DEVICE_ID, flowRule.deviceId().toString()).put(FLOW_ID, Long.toString(flowRule.id().value()));
            flowsNode.add(flowNode);
        });
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.ok(root).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFlows(@QueryParam("appId") String appId, InputStream stream) {
    FlowRuleService service = get(FlowRuleService.class);
    ObjectNode root = mapper().createObjectNode();
    ArrayNode flowsNode = root.putArray(FLOWS);
    try {
        ObjectNode jsonTree = readTreeFromStream(mapper(), stream);
        ArrayNode flowsArray = nullIsIllegal((ArrayNode) jsonTree.get(FLOWS), FLOW_ARRAY_REQUIRED);
        if (appId != null) {
            flowsArray.forEach(flowJson -> ((ObjectNode) flowJson).put("appId", appId));
        }
        List<FlowRule> rules = codec(FlowRule.class).decode(flowsArray, this);
        service.applyFlowRules(rules.toArray(new FlowRule[rules.size()]));
        rules.forEach(flowRule -> {
            ObjectNode flowNode = mapper().createObjectNode();
            flowNode.put(DEVICE_ID, flowRule.deviceId().toString()).put(FLOW_ID, Long.toString(flowRule.id().value()));
            flowsNode.add(flowNode);
        });
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.ok(root).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
// TODO: we need to add "/device" suffix to the path to differentiate with appId
@Path("{deviceId}")
public Response getFlowByDeviceId(@PathParam("deviceId") String deviceId) {
    FlowRuleService service = get(FlowRuleService.class);
    final Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (flowEntries == null || !flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    for (final FlowEntry entry : flowEntries) {
        flowsNode.add(codec(FlowEntry.class).encode(entry, this));
    }
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
// TODO: we need to add "/device" suffix to the path to differentiate with appId
@Path("{deviceId}")
public Response getFlowByDeviceId(@PathParam("deviceId") String deviceId) {
    FlowRuleService service = get(FlowRuleService.class);
    ObjectNode root = mapper().createObjectNode();
    ArrayNode flowsNode = root.putArray(FLOWS);
    Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (flowEntries == null || !flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    for (FlowEntry entry : flowEntries) {
        flowsNode.add(codec(FlowEntry.class).encode(entry, this));
    }
    return ok(root).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/{flowId}")
public Response getFlowByDeviceIdAndFlowId(@PathParam("deviceId") String deviceId, @PathParam("flowId") long flowId) {
    FlowRuleService service = get(FlowRuleService.class);
    final Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (flowEntries == null || !flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    for (final FlowEntry entry : flowEntries) {
        if (entry.id().value() == flowId) {
            flowsNode.add(codec(FlowEntry.class).encode(entry, this));
        }
    }
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/{flowId}")
public Response getFlowByDeviceIdAndFlowId(@PathParam("deviceId") String deviceId, @PathParam("flowId") long flowId) {
    FlowRuleService service = get(FlowRuleService.class);
    ObjectNode root = mapper().createObjectNode();
    ArrayNode flowsNode = root.putArray(FLOWS);
    Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (flowEntries == null || !flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    for (FlowEntry entry : flowEntries) {
        if (entry.id().value() == flowId) {
            flowsNode.add(codec(FlowEntry.class).encode(entry, this));
        }
    }
    return ok(root).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("application/{appId}")
public Response getFlowByAppId(@PathParam("appId") String appId) {
    FlowRuleService service = get(FlowRuleService.class);
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    final Iterable<FlowEntry> flowEntries = service.getFlowEntriesById(idInstant);
    flowEntries.forEach(flow -> flowsNode.add(codec(FlowEntry.class).encode(flow, this)));
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("application/{appId}")
public Response getFlowByAppId(@PathParam("appId") String appId) {
    ObjectNode root = mapper().createObjectNode();
    ArrayNode flowsNode = root.putArray(FLOWS);
    ApplicationService appService = get(ApplicationService.class);
    ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    Iterable<FlowEntry> flowEntries = get(FlowRuleService.class).getFlowEntriesById(idInstant);
    flowEntries.forEach(flow -> flowsNode.add(codec(FlowEntry.class).encode(flow, this)));
    return ok(root).build();
}
#end_block

#method_before
@DELETE
@Produces(MediaType.APPLICATION_JSON)
@Path("application/{appId}")
public Response removeFlowByAppId(@PathParam("appId") String appId) {
    FlowRuleService service = get(FlowRuleService.class);
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    service.removeFlowRulesById(idInstant);
    return Response.noContent().build();
}
#method_after
@DELETE
@Produces(MediaType.APPLICATION_JSON)
@Path("application/{appId}")
public Response removeFlowByAppId(@PathParam("appId") String appId) {
    FlowRuleService service = get(FlowRuleService.class);
    ApplicationService appService = get(ApplicationService.class);
    ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    service.removeFlowRulesById(idInstant);
    return Response.noContent().build();
}
#end_block

#method_before
@DELETE
@Path("{deviceId}/{flowId}")
public Response deleteFlowByDeviceIdAndFlowId(@PathParam("deviceId") String deviceId, @PathParam("flowId") long flowId) {
    FlowRuleService service = get(FlowRuleService.class);
    final Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (!flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    StreamSupport.stream(flowEntries.spliterator(), false).filter(entry -> entry.id().value() == flowId).forEach(service::removeFlowRules);
    return Response.noContent().build();
}
#method_after
@DELETE
@Path("{deviceId}/{flowId}")
public Response deleteFlowByDeviceIdAndFlowId(@PathParam("deviceId") String deviceId, @PathParam("flowId") long flowId) {
    FlowRuleService service = get(FlowRuleService.class);
    Iterable<FlowEntry> flowEntries = service.getFlowEntries(DeviceId.deviceId(deviceId));
    if (!flowEntries.iterator().hasNext()) {
        throw new ItemNotFoundException(DEVICE_NOT_FOUND);
    }
    StreamSupport.stream(flowEntries.spliterator(), false).filter(entry -> entry.id().value() == flowId).forEach(service::removeFlowRules);
    return Response.noContent().build();
}
#end_block

#method_before
private PortDescription toPortDescriptionInternal(HierarchicalConfiguration component) {
    Map<String, String> annotations = new HashMap<>();
    String name = component.getString("name");
    String type = component.getString("state/type");
    checkNotNull(name, "name not found");
    checkNotNull(type, "state/type not found");
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_NAME, name);
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_TYPE, type);
    component.configurationsAt("properties/property").forEach(property -> {
        String pn = property.getString("name");
        String pv = property.getString("state/value");
        annotations.put(pn, pv);
    });
    if (type.equals("oc-platform-types:PORT")) {
        String subComponentName = component.getString("subcomponents/subcomponent/name");
        String[] textStr = subComponentName.split("-");
        String portComponentType = textStr[0];
        String portComponentIndex = textStr[textStr.length - 1];
        if (portComponentType.equals(OPTICAL_CHANNEL)) {
            annotations.putIfAbsent(PORT_TYPE, OdtnPortType.LINE.value());
            annotations.putIfAbsent(ONOS_PORT_INDEX, portComponentIndex.toString());
            annotations.putIfAbsent(CONNECTION_ID, "the-only-one");
            OchSignal signalId = OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, 1);
            return OchPortHelper.ochPortDescription(PortNumber.portNumber(Long.parseLong(portComponentIndex)), true, // TODO Client signal to be discovered
            OduSignalType.ODU4, true, signalId, DefaultAnnotations.builder().putAll(annotations).build());
        } else if (portComponentType.equals(TRANSCEIVER)) {
            Builder builder = DefaultPortDescription.builder();
            annotations.putIfAbsent(PORT_TYPE, OdtnPortType.CLIENT.value());
            annotations.putIfAbsent(ONOS_PORT_INDEX, portComponentIndex.toString());
            annotations.putIfAbsent(CONNECTION_ID, "the-only-one");
            builder.withPortNumber(PortNumber.portNumber(Long.parseLong(portComponentIndex), subComponentName));
            builder.type(Type.PACKET);
            builder.annotations(DefaultAnnotations.builder().putAll(annotations).build());
            return builder.build();
        } else {
            log.debug("Unknown port component type {}", type);
            return null;
        }
    } else {
        log.debug("Another component type {}", type);
        return null;
    }
}
#method_after
private PortDescription toPortDescriptionInternal(HierarchicalConfiguration component) {
    Map<String, String> annotations = new HashMap<>();
    String name = component.getString("name");
    String type = component.getString("state/type");
    checkNotNull(name, "name not found");
    checkNotNull(type, "state/type not found");
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_NAME, name);
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_TYPE, type);
    component.configurationsAt("properties/property").forEach(property -> {
        String pn = property.getString("name");
        String pv = property.getString("state/value");
        annotations.put(pn, pv);
    });
    if (type.equals("oc-platform-types:PORT")) {
        String subComponentName = component.getString("subcomponents/subcomponent/name");
        String[] textStr = subComponentName.split("-");
        String portComponentType = textStr[0];
        String portComponentIndex = textStr[textStr.length - 1];
        if (portComponentType.equals(OPTICAL_CHANNEL)) {
            annotations.putIfAbsent(PORT_TYPE, OdtnPortType.LINE.value());
            annotations.putIfAbsent(ONOS_PORT_INDEX, portComponentIndex.toString());
            annotations.putIfAbsent(CONNECTION_ID, "connection" + portComponentIndex.toString());
            OchSignal signalId = OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, 1);
            return OchPortHelper.ochPortDescription(PortNumber.portNumber(Long.parseLong(portComponentIndex)), true, // TODO Client signal to be discovered
            OduSignalType.ODU4, true, signalId, DefaultAnnotations.builder().putAll(annotations).build());
        } else if (portComponentType.equals(TRANSCEIVER)) {
            Builder builder = DefaultPortDescription.builder();
            annotations.putIfAbsent(PORT_TYPE, OdtnPortType.CLIENT.value());
            annotations.putIfAbsent(ONOS_PORT_INDEX, portComponentIndex.toString());
            annotations.putIfAbsent(CONNECTION_ID, "connection" + portComponentIndex.toString());
            builder.withPortNumber(PortNumber.portNumber(Long.parseLong(portComponentIndex), subComponentName));
            builder.type(Type.PACKET);
            builder.annotations(DefaultAnnotations.builder().putAll(annotations).build());
            return builder.build();
        } else {
            log.debug("Unknown port component type {}", type);
            return null;
        }
    } else {
        log.debug("Another component type {}", type);
        return null;
    }
}
#end_block

#method_before
private HostId parseHost(JsonNode node) {
    MacAddress mac = MacAddress.valueOf(node.get("mac").asText());
    VlanId vlanId = VlanId.vlanId((short) node.get("vlan").asInt(VlanId.UNTAGGED));
    if (null == node.get("locations")) {
        throw new IllegalArgumentException("locaiton doesn't specified");
    }
    Iterator<JsonNode> locationNodes = node.get("locations").elements();
    Set<HostLocation> locations = new HashSet<>();
    while (locationNodes.hasNext()) {
        JsonNode locationNode = locationNodes.next();
        String deviceAndPort = locationNode.get("elementId").asText() + "/" + locationNode.get("port").asText();
        HostLocation hostLocation = new HostLocation(ConnectPoint.deviceConnectPoint(deviceAndPort), 0);
        locations.add(hostLocation);
    }
    if (null == node.get("ipAddresses")) {
        throw new IllegalArgumentException("ipAddress doesn't specified");
    }
    Iterator<JsonNode> ipNodes = node.get("ipAddresses").elements();
    Set<IpAddress> ips = new HashSet<>();
    while (ipNodes.hasNext()) {
        ips.add(IpAddress.valueOf(ipNodes.next().asText()));
    }
    // try to remove elements from json node after reading them
    SparseAnnotations annotations = annotations(removeElements(node, REMOVAL_KEYS));
    // Update host inventory
    HostId hostId = HostId.hostId(mac, vlanId);
    DefaultHostDescription desc = new DefaultHostDescription(mac, vlanId, locations, ips, true, annotations);
    hostProviderService.hostDetected(hostId, desc, false);
    return hostId;
}
#method_after
private HostId parseHost(JsonNode node) {
    MacAddress mac = MacAddress.valueOf(node.get("mac").asText());
    VlanId vlanId = VlanId.vlanId((short) node.get("vlan").asInt(VlanId.UNTAGGED));
    if (null == node.get("locations")) {
        throw new IllegalArgumentException("location isn't specified");
    }
    Iterator<JsonNode> locationNodes = node.get("locations").elements();
    Set<HostLocation> locations = new HashSet<>();
    while (locationNodes.hasNext()) {
        JsonNode locationNode = locationNodes.next();
        String deviceAndPort = locationNode.get("elementId").asText() + "/" + locationNode.get("port").asText();
        HostLocation hostLocation = new HostLocation(ConnectPoint.deviceConnectPoint(deviceAndPort), 0);
        locations.add(hostLocation);
    }
    if (null == node.get("ipAddresses")) {
        throw new IllegalArgumentException("ipAddress isn't specified");
    }
    Iterator<JsonNode> ipNodes = node.get("ipAddresses").elements();
    Set<IpAddress> ips = new HashSet<>();
    while (ipNodes.hasNext()) {
        ips.add(IpAddress.valueOf(ipNodes.next().asText()));
    }
    // try to remove elements from json node after reading them
    SparseAnnotations annotations = annotations(removeElements(node, REMOVAL_KEYS));
    // Update host inventory
    HostId hostId = HostId.hostId(mac, vlanId);
    DefaultHostDescription desc = new DefaultHostDescription(mac, vlanId, locations, ips, true, annotations);
    hostProviderService.hostDetected(hostId, desc, false);
    return hostId;
}
#end_block

#method_before
private void injectModel(Worklet worklet, WorkflowContext context, Field field, JsonDataModel model) throws WorkflowException {
    DataModelFieldBehavior behavior = injectTypeMap.get(field.getType());
    if (Objects.isNull(behavior)) {
        throw new WorkflowException("Not supported type(field.getType()");
    }
    behavior.apply(worklet, context, field, model);
}
#method_after
private void injectModel(Worklet worklet, WorkflowContext context, Field field, JsonDataModel model) throws WorkflowException {
    DataModelFieldBehavior behavior = injectTypeMap.get(field.getType());
    if (Objects.isNull(behavior)) {
        throw new WorkflowException("Not supported type(" + field.getType() + ")");
    }
    behavior.apply(worklet, context, field, model);
}
#end_block

#method_before
private void inhaleModel(Worklet worklet, WorkflowContext context, Field field, JsonDataModel model) throws WorkflowException {
    DataModelFieldBehavior behavior = inhaleTypeMap.get(field.getType());
    if (Objects.isNull(behavior)) {
        throw new WorkflowException("Not supported type(field.getType()");
    }
    behavior.apply(worklet, context, field, model);
}
#method_after
private void inhaleModel(Worklet worklet, WorkflowContext context, Field field, JsonDataModel model) throws WorkflowException {
    DataModelFieldBehavior behavior = inhaleTypeMap.get(field.getType());
    if (Objects.isNull(behavior)) {
        throw new WorkflowException("Not supported type(" + field.getType() + ")");
    }
    behavior.apply(worklet, context, field, model);
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    Map<String, MacAddress> macAddressMap = getMacAddressesByInterface();
    List<PortDescription> ports = Lists.newArrayList();
    DeviceId deviceId = checkNotNull(handler().data().deviceId());
    try {
        Optional<JsonNode> result = AristaUtils.retrieveCommandResult(handler(), SHOW_INTERFACES_STATUS);
        if (!result.isPresent()) {
            log.warn("Unable to get interfaces status information.", deviceId);
            return ports;
        }
        JsonNode jsonNode = result.get().findValue(INTERFACE_STATUSES);
        jsonNode.fieldNames().forEachRemaining(name -> {
            JsonNode interfaceNode = jsonNode.get(name);
            Long bandwidth = interfaceNode.path(BANDWIDTH).asLong() / MBPS;
            String macAddress = macAddressMap.containsKey(name) ? macAddressMap.get(name).toString() : "";
            SparseAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.BANDWIDTH, bandwidth.toString()).set(AnnotationKeys.NAME, name).set(AnnotationKeys.PORT_NAME, name).set(AnnotationKeys.PORT_MAC, macAddress).set(LINK_STATUS, interfaceNode.path(LINK_STATUS).asText()).set(LINE_PROTOCOL_STATUS, interfaceNode.path(LINE_PROTOCOL_STATUS).asText()).set(INTERFACE_TYPE, interfaceNode.path(INTERFACE_TYPE).asText()).build();
            int portNumber;
            try {
                portNumber = getPortNumber(name);
            } catch (Exception e) {
                log.debug("Interface does not have port number: {}", name);
                return;
            }
            PortDescription portDescription = DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(portNumber)).isEnabled(true).type(Port.Type.FIBER).portSpeed(bandwidth).annotations(annotations).build();
            ports.add(portDescription);
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
    }
    return ports;
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    Map<String, MacAddress> macAddressMap = getMacAddressesByInterface();
    List<PortDescription> ports = Lists.newArrayList();
    DeviceId deviceId = checkNotNull(handler().data().deviceId());
    try {
        Optional<JsonNode> result = AristaUtils.retrieveCommandResult(handler(), SHOW_INTERFACES_STATUS);
        if (!result.isPresent()) {
            log.warn("{} Device unable to get interfaces status information.", deviceId);
            return ports;
        }
        JsonNode jsonNode = result.get().findValue(INTERFACE_STATUSES);
        jsonNode.fieldNames().forEachRemaining(name -> {
            JsonNode interfaceNode = jsonNode.get(name);
            Long bandwidth = interfaceNode.path(BANDWIDTH).asLong() / MBPS;
            String macAddress = macAddressMap.containsKey(name) ? macAddressMap.get(name).toString() : "";
            SparseAnnotations annotations = DefaultAnnotations.builder().set(AnnotationKeys.BANDWIDTH, bandwidth.toString()).set(AnnotationKeys.NAME, name).set(AnnotationKeys.PORT_NAME, name).set(AnnotationKeys.PORT_MAC, macAddress).set(LINK_STATUS, interfaceNode.path(LINK_STATUS).asText()).set(LINE_PROTOCOL_STATUS, interfaceNode.path(LINE_PROTOCOL_STATUS).asText()).set(INTERFACE_TYPE, interfaceNode.path(INTERFACE_TYPE).asText()).build();
            int portNumber;
            try {
                portNumber = getPortNumber(name);
            } catch (Exception e) {
                log.debug("Interface does not have port number: {}", name);
                return;
            }
            PortDescription portDescription = DefaultPortDescription.builder().withPortNumber(PortNumber.portNumber(portNumber)).isEnabled(true).type(Port.Type.FIBER).portSpeed(bandwidth).annotations(annotations).build();
            ports.add(portDescription);
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
    }
    return ports;
}
#end_block

#method_before
private Map<String, MacAddress> getMacAddressesByInterface() {
    DeviceId deviceId = checkNotNull(handler().data().deviceId());
    Map<String, MacAddress> macAddressMap = new HashMap();
    try {
        Optional<JsonNode> result = AristaUtils.retrieveCommandResult(handler(), SHOW_INTERFACES);
        if (!result.isPresent()) {
            log.warn("Unable to get interface information.", deviceId);
            return macAddressMap;
        }
        JsonNode jsonNode = result.get().findValue(INTERFACES);
        jsonNode.fieldNames().forEachRemaining(name -> {
            JsonNode interfaceNode = jsonNode.get(name);
            JsonNode macAddressNode = interfaceNode.get(BURNED_IN_ADDRESS);
            if (macAddressNode == null) {
                log.debug("Interface does not have {}: {}", BURNED_IN_ADDRESS, name);
                return;
            }
            String macAddress = macAddressNode.asText("");
            if (macAddress.isEmpty()) {
                macAddressNode = interfaceNode.get(PHYSICAL_ADDRESS);
                if (macAddressNode == null) {
                    log.debug("Interface does not have {}: {}", PHYSICAL_ADDRESS, name);
                    return;
                }
                macAddress = macAddressNode.asText("");
                if (macAddress.isEmpty()) {
                    log.debug("Interface does not have any mac address: {}", name);
                    return;
                }
            }
            try {
                macAddressMap.put(name, MacAddress.valueOf(macAddress));
            } catch (IllegalArgumentException e) {
                log.error("Cannot parse macAddress: {}", macAddress);
            }
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
    }
    return macAddressMap;
}
#method_after
private Map<String, MacAddress> getMacAddressesByInterface() {
    DeviceId deviceId = checkNotNull(handler().data().deviceId());
    Map<String, MacAddress> macAddressMap = new HashMap();
    try {
        Optional<JsonNode> result = AristaUtils.retrieveCommandResult(handler(), SHOW_INTERFACES);
        if (!result.isPresent()) {
            log.warn("{} Device unable to get interface information.", deviceId);
            return macAddressMap;
        }
        JsonNode jsonNode = result.get().findValue(INTERFACES);
        jsonNode.fieldNames().forEachRemaining(name -> {
            JsonNode interfaceNode = jsonNode.get(name);
            JsonNode macAddressNode = interfaceNode.get(BURNED_IN_ADDRESS);
            if (macAddressNode == null) {
                log.debug("Interface does not have {}: {}", BURNED_IN_ADDRESS, name);
                return;
            }
            String macAddress = macAddressNode.asText("");
            if (macAddress.isEmpty()) {
                macAddressNode = interfaceNode.get(PHYSICAL_ADDRESS);
                if (macAddressNode == null) {
                    log.debug("Interface does not have {}: {}", PHYSICAL_ADDRESS, name);
                    return;
                }
                macAddress = macAddressNode.asText("");
                if (macAddress.isEmpty()) {
                    log.debug("Interface does not have any mac address: {}", name);
                    return;
                }
            }
            try {
                macAddressMap.put(name, MacAddress.valueOf(macAddress));
            } catch (IllegalArgumentException e) {
                log.error("Cannot parse macAddress: {}", macAddress);
            }
        });
    } catch (Exception e) {
        log.error("Exception occurred because of {}, trace: {}", e, e.getStackTrace());
    }
    return macAddressMap;
}
#end_block

#method_before
private ObjectNode getDhcpRelayServersJsonOutput() {
    ObjectNode node = mapper().createObjectNode();
    if (getDefaultDhcpServers().size() != 0) {
        node.put("Default-DHCP-Servers", getDefaultDhcpServers());
    }
    if (getIndirectDhcpServers().size() != 0) {
        node.put("Indirect-DHCP-Servers", getIndirectDhcpServers());
    }
    if (dhcpRelayRecords().size() != 0) {
        node.put("DHCP-Relay-Records([D]:Directly-Connected)", dhcpRelayRecords());
    }
    return node;
}
#method_after
private ObjectNode getDhcpRelayServersJsonOutput() {
    ObjectNode node = mapper().createObjectNode();
    if (getDefaultDhcpServers().size() != 0) {
        node.put("Default-DHCP-Servers", getDefaultDhcpServers());
    }
    if (getIndirectDhcpServers().size() != 0) {
        node.put("Indirect-DHCP-Servers", getIndirectDhcpServers());
    }
    if (dhcpRelayRecords().size() != 0) {
        node.put("DHCP-Relay-Records", dhcpRelayRecords());
    }
    return node;
}
#end_block

#method_before
protected void printFlows(Device d, List<FlowEntry> flows, CoreService coreService) {
    List<FlowEntry> filteredFlows = filterFlows(flows);
    boolean empty = filteredFlows == null || filteredFlows.isEmpty();
    print("deviceId=%s, flowRuleCount=%d", d.id(), empty ? 0 : filteredFlows.size());
    if (empty || countOnly) {
        return;
    }
    for (FlowEntry f : filteredFlows) {
        if (shortOutput) {
            print(SHORT_FORMAT, f.state(), f.bytes(), f.packets(), f.table(), f.priority(), f.selector().criteria(), printTreatment(f.treatment()));
        } else {
            ApplicationId appId = coreService.getAppId(f.appId());
            print(LONG_FORMAT, Long.toHexString(f.id().value()), f.state(), f.bytes(), f.packets(), f.life(), f.liveType(), f.priority(), f.table(), appId != null ? appId.name() : "<none>", null, f.selector().criteria(), f.treatment());
        }
    }
}
#method_after
protected void printFlows(Device d, List<FlowEntry> flows, CoreService coreService) {
    List<FlowEntry> filteredFlows = filterFlows(flows);
    boolean empty = filteredFlows == null || filteredFlows.isEmpty();
    print("deviceId=%s, flowRuleCount=%d", d.id(), empty ? 0 : filteredFlows.size());
    if (empty || countOnly) {
        return;
    }
    for (FlowEntry f : filteredFlows) {
        if (shortOutput) {
            print(SHORT_FORMAT, f.state(), f.bytes(), f.packets(), f.table(), f.priority(), f.selector().criteria(), printTreatment(f.treatment()));
        } else {
            ApplicationId appId = coreService.getAppId(f.appId());
            print(LONG_FORMAT, Long.toHexString(f.id().value()), f.state(), f.bytes(), f.packets(), f.life(), f.liveType(), f.priority(), f.table(), appId != null ? appId.name() : "<none>", f.selector().criteria(), f.treatment());
        }
    }
}
#end_block

#method_before
protected void printFlows(Device d, List<FlowEntry> flows, CoreService coreService) {
    List<FlowEntry> filteredFlows = flows.stream().filter(f -> contentFilter.filter(f)).collect(Collectors.toList());
    boolean empty = filteredFlows == null || filteredFlows.isEmpty();
    print("deviceId=%s, flowRuleCount=%d", d.id(), empty ? 0 : filteredFlows.size());
    if (empty || countOnly) {
        return;
    }
    for (FlowEntry f : filteredFlows) {
        if (shortOutput) {
            print(SHORT_FORMAT, f.state(), f.bytes(), f.packets(), f.tableId(), f.priority(), f.selector().criteria(), printTreatment(f.treatment()));
        } else {
            ApplicationId appId = coreService.getAppId(f.appId());
            print(LONG_FORMAT, Long.toHexString(f.id().value()), f.state(), f.bytes(), f.packets(), f.life(), f.liveType(), f.priority(), f.tableId(), appId != null ? appId.name() : "<none>", null, f.selector().criteria(), f.treatment());
        }
    }
}
#method_after
protected void printFlows(Device d, List<FlowEntry> flows, CoreService coreService) {
    List<FlowEntry> filteredFlows = flows.stream().filter(f -> contentFilter.filter(f)).collect(Collectors.toList());
    boolean empty = filteredFlows == null || filteredFlows.isEmpty();
    print("deviceId=%s, flowRuleCount=%d", d.id(), empty ? 0 : filteredFlows.size());
    if (empty || countOnly) {
        return;
    }
    for (FlowEntry f : filteredFlows) {
        if (shortOutput) {
            print(SHORT_FORMAT, f.state(), f.bytes(), f.packets(), f.tableId(), f.priority(), f.selector().criteria(), printTreatment(f.treatment()));
        } else {
            ApplicationId appId = coreService.getAppId(f.appId());
            print(LONG_FORMAT, Long.toHexString(f.id().value()), f.state(), f.bytes(), f.packets(), f.life(), f.liveType(), f.priority(), f.tableId(), appId != null ? appId.name() : "<none>", f.selector().criteria(), f.treatment());
        }
    }
}
#end_block

#method_before
private Intent decode(ObjectNode json) {
    JsonNode ingressJson = json.get(INGRESS_POINT);
    if (!ingressJson.isObject()) {
        throw new IllegalArgumentException(JSON_INVALID);
    }
    ConnectPoint ingress = codec(ConnectPoint.class).decode((ObjectNode) ingressJson, this);
    JsonNode egressJson = json.get(EGRESS_POINT);
    if (!egressJson.isObject()) {
        throw new IllegalArgumentException(JSON_INVALID);
    }
    ConnectPoint egress = codec(ConnectPoint.class).decode((ObjectNode) egressJson, this);
    JsonNode bidirectionalJson = json.get(BIDIRECTIONAL);
    boolean bidirectional = bidirectionalJson != null ? bidirectionalJson.asBoolean() : false;
    JsonNode signalJson = json.get(SIGNAL);
    OchSignal signal = null;
    if (signalJson != null) {
        if (!signalJson.isObject()) {
            throw new IllegalArgumentException(JSON_INVALID);
        } else {
            signal = OchSignalCodec.decode((ObjectNode) signalJson);
        }
    }
    String appIdString = nullIsIllegal(json.get(APP_ID), APP_ID + MISSING_MEMBER_MESSAGE).asText();
    CoreService service = getService(CoreService.class);
    ApplicationId appId = nullIsNotFound(service.getAppId(appIdString), E_APP_ID_NOT_FOUND);
    Key key = null;
    DeviceService deviceService = get(DeviceService.class);
    JsonNode suggestedPathJson = json.get(SUGGESTEDPATH);
    DefaultPath suggestedPath = null;
    LinkService linkService = get(LinkService.class);
    if (suggestedPathJson != null) {
        if (!suggestedPathJson.isObject()) {
            throw new IllegalArgumentException(JSON_INVALID);
        } else {
            ArrayNode linksJson = nullIsIllegal((ArrayNode) suggestedPathJson.get("links"), "Suggested path specified without links");
            List<Link> listLinks = new ArrayList<>();
            for (JsonNode node : linksJson) {
                String srcString = node.get("src").asText();
                String dstString = node.get("dst").asText();
                ConnectPoint srcConnectPoint = ConnectPoint.fromString(srcString);
                ConnectPoint dstConnectPoint = ConnectPoint.fromString(dstString);
                Link link = linkService.getLink(srcConnectPoint, dstConnectPoint);
                if (link == null) {
                    log.info("Not existing link in the suggested path src {} dst {})", srcConnectPoint, dstConnectPoint);
                    throw new IllegalArgumentException("Not existing link in the suggested path");
                }
                listLinks.add(link);
            }
            if ((!listLinks.get(0).src().deviceId().equals(ingress.deviceId())) || (!listLinks.get(0).src().port().equals(ingress.port())) || (!listLinks.get(listLinks.size() - 1).dst().deviceId().equals(egress.deviceId())) || (!listLinks.get(listLinks.size() - 1).dst().port().equals(egress.port()))) {
                throw new IllegalArgumentException("Suggested path not compatible with ingress or egress connect points");
            }
            if (!isPathContiguous(listLinks)) {
                throw new IllegalArgumentException("Links specified in the suggested path are not contiguous");
            }
            suggestedPath = new DefaultPath(PROVIDER_ID, listLinks, new ScalarWeight(1));
            log.debug("OpticalIntent along suggestedPath {}", suggestedPath);
        }
    }
    return createExplicitOpticalIntent(ingress, egress, deviceService, key, appId, bidirectional, signal, suggestedPath);
}
#method_after
private Intent decode(ObjectNode json) {
    JsonNode ingressJson = json.get(INGRESS_POINT);
    if (!ingressJson.isObject()) {
        throw new IllegalArgumentException(JSON_INVALID);
    }
    ConnectPoint ingress = codec(ConnectPoint.class).decode((ObjectNode) ingressJson, this);
    JsonNode egressJson = json.get(EGRESS_POINT);
    if (!egressJson.isObject()) {
        throw new IllegalArgumentException(JSON_INVALID);
    }
    ConnectPoint egress = codec(ConnectPoint.class).decode((ObjectNode) egressJson, this);
    JsonNode bidirectionalJson = json.get(BIDIRECTIONAL);
    boolean bidirectional = bidirectionalJson != null ? bidirectionalJson.asBoolean() : false;
    JsonNode signalJson = json.get(SIGNAL);
    OchSignal signal = null;
    if (signalJson != null) {
        if (!signalJson.isObject()) {
            throw new IllegalArgumentException(JSON_INVALID);
        } else {
            signal = OchSignalCodec.decode((ObjectNode) signalJson);
        }
    }
    String appIdString = nullIsIllegal(json.get(APP_ID), APP_ID + MISSING_MEMBER_MESSAGE).asText();
    CoreService service = getService(CoreService.class);
    ApplicationId appId = nullIsNotFound(service.getAppId(appIdString), E_APP_ID_NOT_FOUND);
    Key key = null;
    DeviceService deviceService = get(DeviceService.class);
    JsonNode suggestedPathJson = json.get(SUGGESTEDPATH);
    DefaultPath suggestedPath = null;
    LinkService linkService = get(LinkService.class);
    if (suggestedPathJson != null) {
        if (!suggestedPathJson.isObject()) {
            throw new IllegalArgumentException(JSON_INVALID);
        } else {
            ArrayNode linksJson = nullIsIllegal((ArrayNode) suggestedPathJson.get("links"), "Suggested path specified without links");
            List<Link> listLinks = new ArrayList<>();
            for (JsonNode node : linksJson) {
                String srcString = node.get("src").asText();
                String dstString = node.get("dst").asText();
                ConnectPoint srcConnectPoint = ConnectPoint.fromString(srcString);
                ConnectPoint dstConnectPoint = ConnectPoint.fromString(dstString);
                Link link = linkService.getLink(srcConnectPoint, dstConnectPoint);
                if (link == null) {
                    log.warn("Not existing link in the suggested path src {} dst {}", srcConnectPoint, dstConnectPoint);
                    throw new IllegalArgumentException("Not existing link in the suggested path");
                }
                listLinks.add(link);
            }
            if ((!listLinks.get(0).src().deviceId().equals(ingress.deviceId())) || (!listLinks.get(0).src().port().equals(ingress.port())) || (!listLinks.get(listLinks.size() - 1).dst().deviceId().equals(egress.deviceId())) || (!listLinks.get(listLinks.size() - 1).dst().port().equals(egress.port()))) {
                throw new IllegalArgumentException("Suggested path not compatible with ingress or egress connect points");
            }
            if (!isPathContiguous(listLinks)) {
                throw new IllegalArgumentException("Links specified in the suggested path are not contiguous");
            }
            suggestedPath = new DefaultPath(PROVIDER_ID, listLinks, new ScalarWeight(1));
            log.debug("OpticalIntent along suggestedPath {}", suggestedPath);
        }
    }
    return createExplicitOpticalIntent(ingress, egress, deviceService, key, appId, bidirectional, signal, suggestedPath);
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        log.debug("No component configuration");
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    String[] values = ((String) properties.get("ofdpaBasedDrivers")).split(",");
    ofdpaBasedDrivers.clear();
    for (String val : values) {
        val = val.trim();
        if (val.length() > 0) {
            ofdpaBasedDrivers.add(val);
        }
    }
    log.debug("OFDPA based driver list update ({}) to {}", ofdpaBasedDrivers.size(), ofdpaBasedDrivers);
}
#method_after
@Modified
public void modified(ComponentContext context) {
    String[] values;
    if (context == null) {
        log.debug("No component configuration, using default OFDPA driver list");
        values = DEFAULT_OFDPA_BASED_DRIVERS.split(",");
    } else {
        Dictionary<?, ?> properties = context.getProperties();
        values = ((String) properties.get("ofdpaBasedDrivers")).split(",");
    }
    ofdpaBasedDrivers.clear();
    for (String val : values) {
        val = val.trim();
        if (val.length() > 0) {
            ofdpaBasedDrivers.add(val);
        }
    }
    log.debug("OFDPA based driver list update ({}) to {}", ofdpaBasedDrivers.size(), ofdpaBasedDrivers);
}
#end_block

#method_before
public String uuid() {
    return get(UUID, "");
}
#method_after
public String uuid() {
    return uuid;
}
#end_block

#method_before
public ConnectPoint leftCp() {
    String cp = get(LEFT, "");
    if (cp.equals("")) {
        return null;
    }
    return ConnectPoint.deviceConnectPoint(cp);
}
#method_after
public ConnectPoint leftCp() {
    return left;
}
#end_block

#method_before
public ConnectPoint rightCp() {
    String cp = get(RIGHT, "");
    if (cp.equals("")) {
        return null;
    }
    return ConnectPoint.deviceConnectPoint(cp);
}
#method_after
public ConnectPoint rightCp() {
    return right;
}
#end_block

#method_before
@Activate
protected void activate() {
    log.info("Started");
    appId = coreService.registerApplication(APP_ID);
    dynConfigService.addListener(dynamicConfigServiceListener);
    deviceService.addListener(deviceListener);
    linkService.addListener(linkListener);
    netcfgService.addListener(netcfgListener);
    netcfgRegistry.registerConfigFactory(factory);
    netcfgRegistry.registerConfigFactory(tccFactory);
    rpcRegistry.registerRpcService(rpcTapiConnectivity);
    rpcRegistry.registerRpcService(rpcTapiCommon);
    rpcTapiConnectivity.init();
    rpcTapiCommon.init();
}
#method_after
@Activate
protected void activate() {
    log.info("Started");
    appId = coreService.registerApplication(APP_ID);
    dynConfigService.addListener(dynamicConfigServiceListener);
    deviceService.addListener(deviceListener);
    linkService.addListener(linkListener);
    netcfgService.addListener(netcfgListener);
    netcfgRegistry.registerConfigFactory(factory);
    rpcRegistry.registerRpcService(rpcTapiConnectivity);
    rpcRegistry.registerRpcService(rpcTapiCommon);
    rpcTapiConnectivity.init();
    rpcTapiCommon.init();
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    log.info("Stopped");
    rpcRegistry.unregisterRpcService(rpcTapiCommon);
    rpcRegistry.unregisterRpcService(rpcTapiConnectivity);
    netcfgRegistry.unregisterConfigFactory(factory);
    netcfgRegistry.unregisterConfigFactory(tccFactory);
    netcfgService.removeListener(netcfgListener);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    dynConfigService.removeListener(dynamicConfigServiceListener);
}
#method_after
@Deactivate
protected void deactivate() {
    log.info("Stopped");
    rpcRegistry.unregisterRpcService(rpcTapiCommon);
    rpcRegistry.unregisterRpcService(rpcTapiConnectivity);
    netcfgRegistry.unregisterConfigFactory(factory);
    netcfgService.removeListener(netcfgListener);
    linkService.removeListener(linkListener);
    deviceService.removeListener(deviceListener);
    dynConfigService.removeListener(dynamicConfigServiceListener);
}
#end_block

#method_before
protected void processTapiEvent(TapiConnectivityConfig config) {
    // Setup or release the intent
    if (config.isEnabled()) {
        log.debug("TAPI config: {} to setup intent", config);
        Intent intent = createOpticalIntent(config.leftCp(), config.rightCp(), null, appId);
        IntentService service = getService(IntentService.class);
        service.submit(intent);
        // Store it in the map
        intentMap.put(config.uuid(), intent);
    } else {
        IntentService service = getService(IntentService.class);
        Intent intent = intentMap.get(config.uuid());
        if (intent == null) {
            log.error("ENOEXIST intent");
            return;
        }
        log.debug("TAPI config: {} to purge intent {}", config, intent);
        Key k = intent.key();
        CountDownLatch latch = new CountDownLatch(1);
        IntentListener listener = new DeleteListener(k, latch);
        service.addListener(listener);
        try {
            /*
                 * RCAS: Note, withdraw is asynchronous. We cannot call purge
                 * directly, because at this point it remains in the "INSTALLED"
                 * state.
                 */
            service.withdraw(intent);
            /*
                 * org.onosproject.onos-core-net - 2.1.0.SNAPSHOT |
                 * Purge for intent 0x0 is rejected because intent state is INSTALLED
                 * service.purge(intent);
                 */
            try {
                latch.await(WITHDRAW_EVENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            // double check the state
            IntentState state = service.getIntentState(k);
            if (state == WITHDRAWN || state == FAILED) {
                service.purge(intent);
            }
        } finally {
            service.removeListener(listener);
        }
    }
}
#method_after
public void processTapiEvent(TapiConnectivityConfig config) {
    checkNotNull(config, "Config can't be null");
    Key key = Key.of(config.uuid(), appId);
    // Setup the Intent
    if (config.isSetup()) {
        log.debug("TAPI config: {} to setup intent", config);
        Intent intent = createOpticalIntent(config.leftCp(), config.rightCp(), key, appId);
        intentService.submit(intent);
    } else {
        // Release the intent
        Intent intent = intentService.getIntent(key);
        if (intent == null) {
            log.error("Intent for uuid {} does not exist", config.uuid());
            return;
        }
        log.debug("TAPI config: {} to purge intent {}", config, intent);
        CountDownLatch latch = new CountDownLatch(1);
        IntentListener listener = new DeleteListener(key, latch);
        intentService.addListener(listener);
        try {
            /*
                 * RCAS: Note, withdraw is asynchronous. We cannot call purge
                 * directly, because at this point it remains in the "INSTALLED"
                 * state.
                 */
            intentService.withdraw(intent);
            /*
                 * org.onosproject.onos-core-net - 2.1.0.SNAPSHOT |
                 * Purge for intent 0x0 is rejected because intent state is INSTALLED
                 * intentService.purge(intent);
                 */
            try {
                latch.await(WITHDRAW_EVENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            // double check the state
            IntentState state = intentService.getIntentState(key);
            if (state == WITHDRAWN || state == FAILED) {
                intentService.purge(intent);
            }
        } finally {
            intentService.removeListener(listener);
        }
    }
}
#end_block

#method_before
protected Intent createOpticalIntent(ConnectPoint ingress, ConnectPoint egress, Key key, ApplicationId appId) {
    Intent intent = null;
    if (ingress == null || egress == null) {
        log.debug("Invalid endpoint(s); could not create optical intent");
        return intent;
    }
    DeviceService deviceService = getService(DeviceService.class);
    DeviceService ds = opticalView(deviceService);
    Port srcPort = ds.getPort(ingress.deviceId(), ingress.port());
    Port dstPort = ds.getPort(egress.deviceId(), egress.port());
    if (srcPort == null || dstPort == null) {
        log.debug("Invalid endpoint(s); could not create optical intent");
        return intent;
    }
    Device srcDevice = ds.getDevice(ingress.deviceId());
    Device dstDevice = ds.getDevice(egress.deviceId());
    // OchSignal signal = new OchSignal(GridType.FLEX, ChannelSpacing.CHL_6P25GHZ, 1, 1);
    OchSignal signal = OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, 1);
    OduSignalType signalType = ((OchPort) srcPort).signalType();
    intent = OpticalConnectivityIntent.builder().appId(appId).key(key).src(ingress).dst(egress).signalType(signalType).bidirectional(true).ochSignal(signal).build();
    return intent;
}
#method_after
protected Intent createOpticalIntent(ConnectPoint ingress, ConnectPoint egress, Key key, ApplicationId appId) {
    Intent intent = null;
    if (ingress == null || egress == null) {
        log.error("Invalid endpoint(s) for optical intent: ingress {}, egress {}", ingress, egress);
        return null;
    }
    DeviceService ds = opticalView(deviceService);
    Port srcPort = ds.getPort(ingress.deviceId(), ingress.port());
    Port dstPort = ds.getPort(egress.deviceId(), egress.port());
    if (srcPort == null || dstPort == null) {
        log.error("Invalid port(s) for optical intent: src {}, dst {}", srcPort, dstPort);
        return null;
    }
    // OchSignal signal = new OchSignal(GridType.FLEX, ChannelSpacing.CHL_6P25GHZ, 1, 1);
    OchSignal signal = OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, 1);
    OduSignalType signalType = ((OchPort) srcPort).signalType();
    intent = OpticalConnectivityIntent.builder().appId(appId).key(key).src(ingress).dst(egress).signalType(signalType).bidirectional(true).ochSignal(signal).build();
    return intent;
}
#end_block

#method_before
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.type() == CONFIG_ADDED || event.type() == CONFIG_UPDATED) {
        if (event.config().orElse(null) instanceof TerminalDeviceConfig) {
            return true;
        }
        if (event.config().orElse(null) instanceof TapiConnectivityConfig) {
            return true;
        }
    }
    if (event.type() == CONFIG_REMOVED) {
        if (event.prevConfig().orElse(null) instanceof TerminalDeviceConfig) {
            return true;
        }
        if (event.prevConfig().orElse(null) instanceof TapiConnectivityConfig) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    if (event.type() == CONFIG_ADDED || event.type() == CONFIG_UPDATED) {
        if (event.config().orElse(null) instanceof TerminalDeviceConfig) {
            return true;
        }
    }
    if (event.type() == CONFIG_REMOVED) {
        if (event.prevConfig().orElse(null) instanceof TerminalDeviceConfig) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    log.debug("Event type: {}, subject: {}", event.type(), event.subject());
    DeviceId did = ((ConnectPoint) event.subject()).deviceId();
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
            if (event.config().get() instanceof TerminalDeviceConfig) {
                TerminalDeviceConfig config = (TerminalDeviceConfig) event.config().get();
                log.debug("config: {}", config);
                DefaultOdtnTerminalDeviceDriver driver = DefaultOdtnTerminalDeviceDriver.create();
                driver.apply(did, config.clientCp().port(), config.subject().port(), config.isEnabled());
            }
            if (event.config().get() instanceof TapiConnectivityConfig) {
                TapiConnectivityConfig config = (TapiConnectivityConfig) event.config().get();
                processTapiEvent(config);
            }
            break;
        case CONFIG_REMOVED:
            if (event.config().get() instanceof TerminalDeviceConfig) {
                TerminalDeviceConfig config = (TerminalDeviceConfig) event.prevConfig().get();
                log.debug("config: {}", config);
                DefaultOdtnTerminalDeviceDriver driver = DefaultOdtnTerminalDeviceDriver.create();
                driver.apply(did, config.clientCp().port(), config.subject().port(), false);
            }
            break;
        default:
            log.error("Unsupported event type.");
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    log.debug("Event type: {}, subject: {}", event.type(), event.subject());
    DeviceId did = ((ConnectPoint) event.subject()).deviceId();
    TerminalDeviceConfig config = (TerminalDeviceConfig) event.config().get();
    DefaultOdtnTerminalDeviceDriver driver = DefaultOdtnTerminalDeviceDriver.create();
    log.debug("config: {}", config);
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
            driver.apply(did, config.clientCp().port(), config.subject().port(), config.isEnabled());
            break;
        case CONFIG_REMOVED:
            driver.apply(did, config.clientCp().port(), config.subject().port(), false);
            break;
        default:
            log.error("Unsupported event type.");
    }
}
#end_block

#method_before
public static DcsBasedTapiConnectionManager create() {
    DcsBasedTapiConnectionManager self = new DcsBasedTapiConnectionManager();
    return self;
}
#method_after
public static DcsBasedTapiConnectionManager create() {
    return new DcsBasedTapiConnectionManager();
}
#end_block

#method_before
private void notifyTapiConnectivityChange(String uuid, ConnectPoint left, ConnectPoint right, boolean enable) {
    NetworkConfigEventEmitter eventEmitter = NetworkConfigEventEmitter.create();
    eventEmitter.emit(uuid, left, right, enable);
}
#method_after
private void notifyTapiConnectivityChange(String uuid, ConnectPoint left, ConnectPoint right, boolean enable) {
    TapiConnectivityConfig cfg = new TapiConnectivityConfig(uuid, left, right, enable);
    processor.processTapiEvent(cfg);
}
#end_block

#method_before
@Override
public void filter(ContainerRequestContext requestContext) throws IOException {
    if (auditService() != null) {
        String requestBody = (requestContext.hasEntity() ? (readTreeFromStream(mapper, requestContext.getEntityStream()).toString()) : "");
        requestContext.setProperty("requestBody", requestBody);
        // FIXME: audit message should be better structured
        requestContext.setProperty("auditMessage", "Path: " + requestContext.getUriInfo().getPath() + separator + "Method: " + requestContext.getMethod() + separator + (requestContext.getMethod().equals("PUT") ? // FIXME: is there really a need to differentiate based on method?
        ("Path_Parameters: " + requestContext.getUriInfo().getPathParameters().toString() + separator + "Query_Parameters: " + requestContext.getUriInfo().getQueryParameters().toString() + separator + "Request_Body: " + requestBody) : ""));
        requestContext.setEntityStream(IOUtils.toInputStream(requestBody));
    }
}
#method_after
@Override
public void filter(ContainerRequestContext requestContext) throws IOException {
    if (auditService() != null) {
        String requestBody = (requestContext.hasEntity() ? (readTreeFromStream(mapper, requestContext.getEntityStream()).toString()) : "");
        requestContext.setProperty("requestBody", requestBody);
        // FIXME: audit message should be better structured
        requestContext.setProperty("auditMessage", "{\"Path" + logCompSeperator + requestContext.getUriInfo().getPath() + separator + "Method" + logCompSeperator + requestContext.getMethod() + separator + (requestContext.getMethod().equals("PUT") ? // FIXME: is there really a need to differentiate based on method?
        ("Path_Parameters" + logCompSeperator + requestContext.getUriInfo().getPathParameters().toString() + separator + "Query_Parameters" + logCompSeperator + requestContext.getUriInfo().getQueryParameters().toString() + separator + "Request_Body" + logCompSeperator + requestBody) : ""));
        requestContext.setEntityStream(IOUtils.toInputStream(requestBody));
    }
}
#end_block

#method_before
@Override
public void filter(ContainerRequestContext containerRequestContext, ContainerResponseContext containerResponseContext) throws IOException {
    AuditService auditService = auditService();
    if (auditService != null) {
        containerRequestContext.setProperty("auditMessage", containerRequestContext.getProperty("auditMessage") + separator + "Status: " + containerResponseContext.getStatusInfo().toString());
        // FIXME: Audit record should indicate who did it, not just what was done and when
        String user = containerRequestContext.getSecurityContext().getUserPrincipal().getName();
        String action = containerRequestContext.getProperty("auditMessage").toString();
        auditService.logUserAction(user, action);
    }
}
#method_after
@Override
public void filter(ContainerRequestContext containerRequestContext, ContainerResponseContext containerResponseContext) throws IOException {
    AuditService auditService = auditService();
    if (auditService != null) {
        containerRequestContext.setProperty("auditMessage", containerRequestContext.getProperty("auditMessage") + separator + "Status" + logCompSeperator + containerResponseContext.getStatusInfo().toString() + "\"}");
        // FIXME: Audit record should indicate who did it, not just what was done and when
        String user = containerRequestContext.getSecurityContext().getUserPrincipal().getName();
        String action = containerRequestContext.getProperty("auditMessage").toString();
        auditService.logUserAction(user, action);
    }
}
#end_block

#method_before
private void auditCommand() {
    AuditService auditService = get(AuditService.class);
    if (auditService != null && auditService.isAuditing()) {
        // FIXME: Compose and log audit message here; this is a hack
        // FIXME
        String user = "foo";
        // FIXME
        String action = Thread.currentThread().getName().substring(5);
        auditService.logUserAction(user, action);
    }
}
#method_after
private void auditCommand() {
    AuditService auditService = get(AuditService.class);
    if (auditService != null && auditService.isAuditing()) {
        // FIXME: Compose and log audit message here; this is a hack
        // FIXME
        String user = "foo";
        String action = "{\"command\" : \"" + Thread.currentThread().getName().substring(5) + "\"}";
        auditService.logUserAction(user, action);
    }
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(getClass()).add("portLoadBalancerId", portLoadBalancerId).add("ports", ports).add("mode", mode).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(getClass()).add("id", portLoadBalancerId).add("ports", ports).add("mode", mode).toString();
}
#end_block

#method_before
protected List<PortDescription> parseTapiPorts(JsonNode tapiContext) {
    List<PortDescription> ports = Lists.newArrayList();
    int counter = 0;
    /**
     *         This annotations are used to store persistent mapping information between TAPI SIP's uuid
     *         and ONOS device portNumbers. This is needed to be publicly available at least within ODTN app
     *         when connectivity services will be sent to OLS Controller.
     */
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
    JsonNode sips = tapiContext.get(SERVICE_INTERFACE_POINT);
    Iterator<JsonNode> iter = sips.iterator();
    while (iter.hasNext()) {
        JsonNode sipAttributes = iter.next();
        if (checkValidEndpoint(sipAttributes)) {
            String uuid = sipAttributes.get(UUID).textValue();
            JsonNode mcPool = sipAttributes.get(MEDIA_CHANNEL_SERVICE_INTERFACE_POINT_SPEC).get(MC_POOL);
            // We create a sample OChSignal in the first position of the 50GHz DWDM Grid,
            // this should be replace for a OChSignal construct which has undefined spectrum.
            /*OchSignal ochSignal = new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ,
                        0, 1);*/
            OchSignal ochSignal = getOchSignal(mcPool);
            synchronized (N_PORT_LOCK) {
                // annotations(portNumber-uuid)
                annotations.set(nPort.toString(), uuid);
                // add och port
                ports.add(ochPortDescription(nPort, true, OduSignalType.ODU4, false, ochSignal, annotations.build()));
                nPort = PortNumber.portNumber(counter++);
            }
        } else {
            log.error("SIP {} is not valid", sipAttributes);
        }
    }
    log.debug("PortList: {}", ports);
    return ImmutableList.copyOf(ports);
}
#method_after
protected List<PortDescription> parseTapiPorts(JsonNode tapiContext) {
    List<PortDescription> ports = Lists.newArrayList();
    int counter = 0;
    /**
     *         This annotations are used to store persistent mapping information between TAPI SIP's uuid
     *         and ONOS device portNumbers. This is needed to be publicly available at least within ODTN app
     *         when connectivity services will be sent to OLS Controller.
     */
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
    JsonNode sips = tapiContext.get(SERVICE_INTERFACE_POINT);
    Iterator<JsonNode> iter = sips.iterator();
    while (iter.hasNext()) {
        JsonNode sipAttributes = iter.next();
        if (checkValidEndpoint(sipAttributes)) {
            String uuid = sipAttributes.get(UUID).textValue();
            JsonNode mcPool = sipAttributes.get(MEDIA_CHANNEL_SERVICE_INTERFACE_POINT_SPEC).get(MC_POOL);
            /*We create a sample OChSignal in the first position of the 50GHz DWDM Grid,
                this should be replace for a OChSignal construct which has undefined spectrum.
                OchSignal ochSignal = new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ,
                        0, 1);*/
            OchSignal ochSignal = getOchSignal(mcPool);
            synchronized (N_PORT_LOCK) {
                // annotations(portNumber-uuid)
                annotations.set(nPort.toString(), uuid);
                // add och port
                ports.add(ochPortDescription(nPort, true, OduSignalType.ODU4, false, ochSignal, annotations.build()));
                nPort = PortNumber.portNumber(counter++);
            }
        } else {
            log.error("SIP {} is not valid", sipAttributes);
        }
    }
    log.debug("PortList: {}", ports);
    return ImmutableList.copyOf(ports);
}
#end_block

#method_before
private OchSignal getOchSignal(JsonNode mcPool) {
    long availableUpperFrec = 0, availableLowerFrec = 0;
    String availableAdjustmentGranularity = "", availableGridType = "";
    JsonNode availableSpectrum = mcPool.get(AVAILABLE_SPECTRUM);
    /**
     * At this time only the latest availableSpectrum is used*
     */
    Iterator<JsonNode> iterAvailable = availableSpectrum.iterator();
    while (iterAvailable.hasNext()) {
        JsonNode availableSpec = iterAvailable.next();
        availableUpperFrec = availableSpec.get(UPPER_FREQUENCY).asLong();
        availableLowerFrec = availableSpec.get(LOWER_FREQUENCY).asLong();
        availableAdjustmentGranularity = availableSpec.get(FREQUENCY_CONSTRAINT).get(ADJUSTMENT_GRANULARITY).textValue();
        availableGridType = availableSpec.get(FREQUENCY_CONSTRAINT).get(GRID_TYPE).textValue();
    }
    int spacingMult = 0, slotGranularity = 1;
    ChannelSpacing chSpacing = getChannelSpacing(availableAdjustmentGranularity);
    long spacingFrequency = chSpacing.frequency().asHz();
    long centralFrequency = (availableUpperFrec - (availableUpperFrec - availableLowerFrec) / 2);
    GridType gridType = getGridType(availableGridType);
    if (gridType == GridType.DWDM) {
        spacingMult = (int) ((centralFrequency - BASE_FREQUENCY) / toMbpsFromHz(spacingFrequency));
    } else if (gridType == GridType.CWDM) {
        log.warn("GridType CWDM. Not implemented");
    } else if (gridType == GridType.FLEX) {
        log.warn("GridType FLEX. Not implemented");
        slotGranularity = getSlotGranularity(chSpacing);
    } else {
        log.warn("Unknown GridType");
    }
    return new OchSignal(gridType, chSpacing, spacingMult, slotGranularity);
}
#method_after
private OchSignal getOchSignal(JsonNode mcPool) {
    long availableUpperFrec = 0;
    long availableLowerFrec = 0;
    String availableAdjustmentGranularity = "";
    String availableGridType = "";
    JsonNode availableSpectrum = mcPool.get(AVAILABLE_SPECTRUM);
    /**
     * At this time only the latest availableSpectrum is used*
     */
    Iterator<JsonNode> iterAvailable = availableSpectrum.iterator();
    while (iterAvailable.hasNext()) {
        JsonNode availableSpec = iterAvailable.next();
        availableUpperFrec = availableSpec.get(UPPER_FREQUENCY).asLong();
        availableLowerFrec = availableSpec.get(LOWER_FREQUENCY).asLong();
        availableAdjustmentGranularity = availableSpec.get(FREQUENCY_CONSTRAINT).get(ADJUSTMENT_GRANULARITY).textValue();
        availableGridType = availableSpec.get(FREQUENCY_CONSTRAINT).get(GRID_TYPE).textValue();
    }
    int spacingMult = 0;
    int slotGranularity = 1;
    ChannelSpacing chSpacing = getChannelSpacing(availableAdjustmentGranularity);
    long spacingFrequency = chSpacing.frequency().asHz();
    long centralFrequency = (availableUpperFrec - (availableUpperFrec - availableLowerFrec) / 2);
    GridType gridType = GridType.valueOf(availableGridType);
    if (gridType == GridType.DWDM) {
        spacingMult = (int) ((centralFrequency - BASE_FREQUENCY) / toMbpsFromHz(spacingFrequency));
    } else if (gridType == GridType.CWDM) {
        log.warn("GridType CWDM. Not implemented");
    } else if (gridType == GridType.FLEX) {
        log.warn("GridType FLEX. Not implemented");
        slotGranularity = getSlotGranularity(chSpacing);
    } else {
        log.warn("Unknown GridType");
    }
    return new OchSignal(gridType, chSpacing, spacingMult, slotGranularity);
}
#end_block

#method_before
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    RestSBController controller = checkNotNull(handler().get(RestSBController.class));
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = handler().data().deviceId();
    Device dev = deviceService.getDevice(deviceId);
    if (dev == null) {
        log.error(" %s", "Device does not exist");
    }
    Port p = deviceService.getPort(dev.id(), port);
    if (p == null) {
        log.error(" %s", "Port does not exist");
    }
    String uuid = p.annotations().value(port.toString());
    try {
        InputStream inputStream = controller.get(deviceId, SIP_REQUEST_DATA_API + uuid, MediaType.APPLICATION_JSON_TYPE);
        log.debug(SIP_REQUEST_DATA_API + uuid);
        JsonNode sipAttributes = new ObjectMapper().readTree(inputStream);
        JsonNode mcPool = sipAttributes.get(MEDIA_CHANNEL_SERVICE_INTERFACE_POINT_SPEC).get(MC_POOL);
        // This creates a hashset of OChSignals representing the spectrum availability at the target port.
        Set<OchSignal> lambdas = getOchSignal(mcPool);
        log.debug(lambdas.toString());
        return lambdas;
    } catch (IOException e) {
        log.error("Exception discoverPortDetails() {}", did(), e);
        return ImmutableSet.of();
    }
}
#method_after
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    RestSBController controller = checkNotNull(handler().get(RestSBController.class));
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = did();
    Device dev = deviceService.getDevice(deviceId);
    if (dev == null) {
        log.error("Device {} does not exist", deviceId);
    }
    Port p = deviceService.getPort(dev.id(), port);
    if (p == null) {
        log.error("Port {} does not exist", port);
    }
    String uuid = p.annotations().value(port.toString());
    try {
        InputStream inputStream = controller.get(deviceId, SIP_REQUEST_DATA_API + uuid, MediaType.APPLICATION_JSON_TYPE);
        log.debug("Service interface point UUID: {}", uuid);
        JsonNode sipAttributes = new ObjectMapper().readTree(inputStream);
        JsonNode mcPool = sipAttributes.get(MEDIA_CHANNEL_SERVICE_INTERFACE_POINT_SPEC).get(MC_POOL);
        // This creates a hashset of OChSignals representing the spectrum availability at the target port.
        Set<OchSignal> lambdas = getOchSignal(mcPool);
        log.debug("Lambdas: {}", lambdas.toString());
        return lambdas;
    } catch (IOException e) {
        log.error("Exception discoverPortDetails() {}", did(), e);
        return ImmutableSet.of();
    }
}
#end_block

#method_before
private Set<OchSignal> getOchSignal(JsonNode mcPool) {
    Set<OchSignal> lambdas = new LinkedHashSet<>();
    long availableUpperFrec = 0, availableLowerFrec = 0;
    String availableAdjustmentGranularity = "", availableGridType = "";
    JsonNode availableSpectrum = mcPool.get(AVAILABLE_SPECTRUM);
    /**
     * At this time only the latest availableSpectrum is used*
     */
    Iterator<JsonNode> iterAvailable = availableSpectrum.iterator();
    while (iterAvailable.hasNext()) {
        JsonNode availableSpec = iterAvailable.next();
        availableUpperFrec = availableSpec.get(UPPER_FREQUENCY).asLong();
        availableLowerFrec = availableSpec.get(LOWER_FREQUENCY).asLong();
        availableAdjustmentGranularity = availableSpec.get(FREQUENCY_CONSTRAINT).get(ADJUSTMENT_GRANULARITY).textValue();
        availableGridType = availableSpec.get(FREQUENCY_CONSTRAINT).get(GRID_TYPE).textValue();
        int spacingMult = 0, slotGranularity = 1;
        ChannelSpacing chSpacing = getChannelSpacing(availableAdjustmentGranularity);
        long spacingFrequency = chSpacing.frequency().asHz();
        long centralFrequency = (availableUpperFrec - (availableUpperFrec - availableLowerFrec) / 2);
        GridType gridType = getGridType(availableGridType);
        if (gridType == GridType.DWDM) {
            spacingMult = (int) ((centralFrequency - BASE_FREQUENCY) / toMbpsFromHz(spacingFrequency));
            OchSignal ochSignal = new OchSignal(gridType, chSpacing, spacingMult, slotGranularity);
            lambdas.add(ochSignal);
        } else if (gridType == GridType.CWDM) {
            log.warn("GridType CWDM. Not implemented");
        } else if (gridType == GridType.FLEX) {
            log.warn("GridType FLEX. Not implemented");
            slotGranularity = getSlotGranularity(chSpacing);
        } else {
            log.warn("Unknown GridType");
        }
    }
    return lambdas;
}
#method_after
private Set<OchSignal> getOchSignal(JsonNode mcPool) {
    Set<OchSignal> lambdas = new LinkedHashSet<>();
    long availableUpperFrec = 0;
    long availableLowerFrec = 0;
    String availableAdjustmentGranularity = "";
    String availableGridType = "";
    JsonNode availableSpectrum = mcPool.get(AVAILABLE_SPECTRUM);
    /**
     * At this time only the latest availableSpectrum is used*
     */
    Iterator<JsonNode> iterAvailable = availableSpectrum.iterator();
    while (iterAvailable.hasNext()) {
        JsonNode availableSpec = iterAvailable.next();
        availableUpperFrec = availableSpec.get(UPPER_FREQUENCY).asLong();
        availableLowerFrec = availableSpec.get(LOWER_FREQUENCY).asLong();
        availableAdjustmentGranularity = availableSpec.get(FREQUENCY_CONSTRAINT).get(ADJUSTMENT_GRANULARITY).textValue();
        availableGridType = availableSpec.get(FREQUENCY_CONSTRAINT).get(GRID_TYPE).textValue();
        int spacingMult = 0;
        int slotGranularity = 1;
        ChannelSpacing chSpacing = getChannelSpacing(availableAdjustmentGranularity);
        long spacingFrequency = chSpacing.frequency().asHz();
        long centralFrequency = (availableUpperFrec - (availableUpperFrec - availableLowerFrec) / 2);
        GridType gridType = GridType.valueOf(availableGridType);
        if (gridType == GridType.DWDM) {
            spacingMult = (int) ((centralFrequency - BASE_FREQUENCY) / toMbpsFromHz(spacingFrequency));
            OchSignal ochSignal = new OchSignal(gridType, chSpacing, spacingMult, slotGranularity);
            lambdas.add(ochSignal);
        } else if (gridType == GridType.CWDM) {
            log.warn("GridType CWDM. Not implemented");
        } else if (gridType == GridType.FLEX) {
            log.warn("GridType FLEX. Not implemented");
            slotGranularity = getSlotGranularity(chSpacing);
        } else {
            log.warn("Unknown GridType");
        }
    }
    return lambdas;
}
#end_block

#method_before
static String postClis(DriverHandler handler, List<String> cmds) {
    RestSBController controller = checkNotNull(handler.get(RestSBController.class));
    DeviceId deviceId = handler.data().deviceId();
    String request = generate(cmds, CommandType.CLI);
    InputStream stream = new ByteArrayInputStream(request.getBytes(StandardCharsets.UTF_8));
    return controller.post(deviceId, API_URI, stream, MediaType.valueOf(APP_JSON_RPC), String.class);
}
#method_after
public static String postClis(DriverHandler handler, List<String> cmds) {
    RestSBController controller = checkNotNull(handler.get(RestSBController.class));
    DeviceId deviceId = handler.data().deviceId();
    String request = generate(cmds, CommandType.CLI);
    InputStream stream = new ByteArrayInputStream(request.getBytes(StandardCharsets.UTF_8));
    return controller.post(deviceId, API_URI, stream, MediaType.valueOf(APP_JSON_RPC), String.class);
}
#end_block

#method_before
static String postCli(DriverHandler handler, String command) {
    return post(handler, command, CommandType.CLI);
}
#method_after
public static String postCli(DriverHandler handler, String command) {
    return post(handler, command, CommandType.CLI);
}
#end_block

#method_before
@Deprecated
public List<PortDescription> getPorts() {
    return new DeviceDescriptionDiscoveryCiscoImpl().discoverPortDetails();
}
#method_after
@Deprecated
public List<PortDescription> getPorts() {
    return new DeviceDescriptionDiscoveryCisco9kImpl().discoverPortDetails();
}
#end_block

#method_before
@DELETE
@Path("fpm-delete/{prefix}")
public Response dhcpFpmDelete(@PathParam("prefix") String prefix) {
    DhcpRelayService dhcpRelayService = get(DhcpRelayService.class);
    RouteStore routeStore = get(RouteStore.class);
    try {
        // removes fpm route from fpm record
        Optional<FpmRecord> fpmRecord = dhcpRelayService.removeFpmRecord(IpPrefix.valueOf(prefix));
        if (fpmRecord.isPresent()) {
            IpAddress nextHop = fpmRecord.get().nextHop();
            Route route = new Route(Route.Source.DHCP, IpPrefix.valueOf(prefix), nextHop);
            // removes DHCP route from route store
            routeStore.removeRoute(route);
        } else {
            LOG.warn("fpmRecord is not present");
        }
    } catch (IllegalArgumentException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.noContent().build();
}
#method_after
@DELETE
@Path("fpm/{prefix}")
public Response dhcpFpmDelete(@PathParam("prefix") String prefix) {
    DhcpRelayService dhcpRelayService = get(DhcpRelayService.class);
    RouteStore routeStore = get(RouteStore.class);
    try {
        // removes fpm route from fpm record
        Optional<FpmRecord> fpmRecord = dhcpRelayService.removeFpmRecord(IpPrefix.valueOf(prefix));
        if (fpmRecord.isPresent()) {
            IpAddress nextHop = fpmRecord.get().nextHop();
            Route route = new Route(Route.Source.DHCP, IpPrefix.valueOf(prefix), nextHop);
            // removes DHCP route from route store
            routeStore.removeRoute(route);
        } else {
            LOG.warn("fpmRecord is not present");
        }
    } catch (IllegalArgumentException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.noContent().build();
}
#end_block

#method_before
private ArrayNode dhcpRelayRecords(Collection<DhcpRecord> records) {
    DhcpRelayCommand dhcpRelayCommand = new DhcpRelayCommand();
    ArrayNode dhcpRelayRecords = mapper.createArrayNode();
    records.forEach(record -> {
        ObjectNode dhcpRecord = mapper.createObjectNode();
        dhcpRecord.put("id", record.macAddress() + "/" + record.vlanId());
        dhcpRecord.put("locations", record.locations().toString());
        dhcpRecord.put("last-seen", Tools.timeAgo(record.lastSeen()));
        dhcpRecord.put("IPv4", dhcpRelayCommand.ip4State(record));
        dhcpRecord.put("IPv6", dhcpRelayCommand.ip6State(record));
        dhcpRelayRecords.add(dhcpRecord);
    });
    return dhcpRelayRecords;
}
#method_after
private ArrayNode dhcpRelayRecords() {
    DhcpRelayCommand dhcpRelayCommand = new DhcpRelayCommand();
    ObjectNode node = mapper.createObjectNode();
    ArrayNode dhcpRelayRecords = mapper.createArrayNode();
    records.forEach(record -> {
        ObjectNode dhcpRecord = mapper.createObjectNode();
        dhcpRecord.put("id", record.macAddress() + "/" + record.vlanId());
        dhcpRecord.put("locations", record.locations().toString().concat(record.directlyConnected() ? DIRECTLY : EMPTY));
        dhcpRecord.put("last-seen", Tools.timeAgo(record.lastSeen()));
        dhcpRecord.put("IPv4", dhcpRelayCommand.ip4State(record));
        dhcpRecord.put("IPv6", dhcpRelayCommand.ip6State(record));
        dhcpRelayRecords.add(dhcpRecord);
    });
    return dhcpRelayRecords;
}
#end_block

#method_before
public static ConnectPoint deviceConnectPoint(String string) {
    /*
         * As device IDs may have a path component, we are expecting one
         * of:
         * - scheme:ip:port/cp
         * - scheme:ip:port/path/cp
         *
         * The assumption is the last `/` will separate the device ID
         * from the connection point number.
         */
    checkNotNull(string);
    int idx = string.lastIndexOf("/");
    checkArgument(idx != -1, "Connect point must be in \"deviceUri/portNumber\" format");
    String id = string.substring(0, idx);
    String cp = string.substring(idx + 1);
    checkArgument(!cp.isEmpty(), "Connect point must be in \"deviceUri/portNumber\" format");
    return new ConnectPoint(DeviceId.deviceId(id), PortNumber.portNumber(cp));
}
#method_after
public static ConnectPoint deviceConnectPoint(String string) {
    /*
         * As device IDs may have a path component, we are expecting one
         * of:
         * - scheme:ip:port/cp
         * - scheme:ip:port/path/cp
         *
         * The assumption is the last `/` will separate the device ID
         * from the connection point number.
         */
    checkNotNull(string);
    int idx = string.lastIndexOf("/");
    checkArgument(idx != -1, NO_SEP_SPECIFIED);
    String id = string.substring(0, idx);
    String cp = string.substring(idx + 1);
    checkArgument(!cp.isEmpty(), SEP_NO_VALUE);
    return new ConnectPoint(DeviceId.deviceId(id), PortNumber.portNumber(cp));
}
#end_block

#method_before
public static ConnectPoint fromString(String string) {
    /*
         * As device IDs may have a path component, we are expecting one
         * of:
         * - scheme:ip:port/cp
         * - scheme:ip:port/path/cp
         *
         * The assumption is the last `/` will separate the device ID
         * from the connection point number.
         */
    checkNotNull(string);
    int idx = string.lastIndexOf("/");
    checkArgument(idx != -1, "Connect point must be in \"deviceUri/portNumber\" format");
    String id = string.substring(0, idx);
    String cp = string.substring(idx + 1);
    checkArgument(!cp.isEmpty(), "Connect point must be in \"deviceUri/portNumber\" format");
    return new ConnectPoint(DeviceId.deviceId(id), PortNumber.fromString(cp));
}
#method_after
public static ConnectPoint fromString(String string) {
    /*
         * As device IDs may have a path component, we are expecting one
         * of:
         * - scheme:ip:port/cp
         * - scheme:ip:port/path/cp
         *
         * The assumption is the last `/` will separate the device ID
         * from the connection point number.
         */
    checkNotNull(string);
    int idx = string.lastIndexOf("/");
    checkArgument(idx != -1, NO_SEP_SPECIFIED);
    String id = string.substring(0, idx);
    String cp = string.substring(idx + 1);
    checkArgument(!cp.isEmpty(), SEP_NO_VALUE);
    return new ConnectPoint(DeviceId.deviceId(id), PortNumber.fromString(cp));
}
#end_block

#method_before
@Test
public void testGetNetconfDeviceWithIPPort() {
    NetconfDevice fetchedDevice1 = ctrl.getNetconfDevice(IpAddress.valueOf(DEVICE_1_IP), DEVICE_1_PORT);
    assertNotNull(String.format("Fetching '%s':'%d'", IpAddress.valueOf(DEVICE_1_IP), DEVICE_1_PORT), fetchedDevice1);
    assertEquals("Incorrect device fetched", fetchedDevice1.getDeviceInfo().ip(), device1.getDeviceInfo().ip());
    NetconfDevice fetchedDevice2 = ctrl.getNetconfDevice(IpAddress.valueOf(DEVICE_2_IP), DEVICE_2_PORT);
    assertEquals("Incorrect device fetched", fetchedDevice2.getDeviceInfo().ip(), device2.getDeviceInfo().ip());
}
#method_after
@Test
public void testGetNetconfDeviceWithIPPort() {
    NetconfDevice fetchedDevice1 = ctrl.getNetconfDevice(IpAddress.valueOf(DEVICE_1_IP), DEVICE_1_PORT);
    assertEquals("Incorrect device fetched", fetchedDevice1.getDeviceInfo().ip(), device1.getDeviceInfo().ip());
    NetconfDevice fetchedDevice2 = ctrl.getNetconfDevice(IpAddress.valueOf(DEVICE_2_IP), DEVICE_2_PORT);
    assertEquals("Incorrect device fetched", fetchedDevice2.getDeviceInfo().ip(), device2.getDeviceInfo().ip());
}
#end_block

#method_before
@Override
public NetconfDevice connectDevice(DeviceId deviceId) throws NetconfException {
    NetconfDeviceConfig netCfg = netCfgService.getConfig(deviceId, NetconfDeviceConfig.class);
    NetconfDeviceInfo deviceInfo = null;
    if (netconfDeviceMap.containsKey(deviceId)) {
        log.debug("Device {} is already present", deviceId);
        return netconfDeviceMap.get(deviceId);
    } else if (netCfg != null) {
        log.debug("Device {} is present in NetworkConfig", deviceId);
        deviceInfo = new NetconfDeviceInfo(netCfg);
    } else {
        log.debug("Creating NETCONF device {}", deviceId);
        Device device = deviceService.getDevice(deviceId);
        String ip, path = null;
        int port;
        if (device != null) {
            ip = device.annotations().value("ipaddress");
            port = Integer.parseInt(device.annotations().value("port"));
        } else {
            Triple<String, Integer, Optional<String>> info = extractIpPortPath(deviceId);
            ip = info.getLeft();
            port = info.getMiddle();
            path = (info.getRight().isPresent() ? info.getRight().get() : null);
        }
        try {
            DeviceKey deviceKey = deviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceId.toString()));
            if (deviceKey.type() == DeviceKey.Type.USERNAME_PASSWORD) {
                UsernamePassword usernamepasswd = deviceKey.asUsernamePassword();
                deviceInfo = new NetconfDeviceInfo(usernamepasswd.username(), usernamepasswd.password(), IpAddress.valueOf(CharMatcher.anyOf("][").trimFrom(ip)), port, path);
            } else if (deviceKey.type() == DeviceKey.Type.SSL_KEY) {
                String username = deviceKey.annotations().value(AnnotationKeys.USERNAME);
                String password = deviceKey.annotations().value(AnnotationKeys.PASSWORD);
                String sshkey = deviceKey.annotations().value(AnnotationKeys.SSHKEY);
                deviceInfo = new NetconfDeviceInfo(username, password, IpAddress.valueOf(ip), port, path, sshkey);
            } else {
                log.error("Unknown device key for device {}", deviceId);
            }
        } catch (NullPointerException e) {
            throw new NetconfException("No Device Key for device " + deviceId, e);
        }
    }
    NetconfDevice netconfDevicedevice = createDevice(deviceInfo);
    netconfDevicedevice.getSession().addDeviceOutputListener(downListener);
    return netconfDevicedevice;
}
#method_after
@Override
public NetconfDevice connectDevice(DeviceId deviceId) throws NetconfException {
    NetconfDeviceConfig netCfg = netCfgService.getConfig(deviceId, NetconfDeviceConfig.class);
    NetconfDeviceInfo deviceInfo = null;
    if (netconfDeviceMap.containsKey(deviceId)) {
        log.debug("Device {} is already present", deviceId);
        return netconfDeviceMap.get(deviceId);
    } else if (netCfg != null) {
        log.debug("Device {} is present in NetworkConfig", deviceId);
        deviceInfo = new NetconfDeviceInfo(netCfg);
    } else {
        log.debug("Creating NETCONF device {}", deviceId);
        Device device = deviceService.getDevice(deviceId);
        String ip, path = null;
        int port;
        if (device != null) {
            ip = device.annotations().value("ipaddress");
            port = Integer.parseInt(device.annotations().value("port"));
        } else {
            Triple<String, Integer, Optional<String>> info = extractIpPortPath(deviceId);
            ip = info.getLeft();
            port = info.getMiddle();
            path = (info.getRight().isPresent() ? info.getRight().get() : null);
        }
        try {
            DeviceKey deviceKey = deviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceId.toString()));
            if (deviceKey.type() == DeviceKey.Type.USERNAME_PASSWORD) {
                UsernamePassword usernamepasswd = deviceKey.asUsernamePassword();
                deviceInfo = new NetconfDeviceInfo(usernamepasswd.username(), usernamepasswd.password(), IpAddress.valueOf(ip), port, path);
            } else if (deviceKey.type() == DeviceKey.Type.SSL_KEY) {
                String username = deviceKey.annotations().value(AnnotationKeys.USERNAME);
                String password = deviceKey.annotations().value(AnnotationKeys.PASSWORD);
                String sshkey = deviceKey.annotations().value(AnnotationKeys.SSHKEY);
                deviceInfo = new NetconfDeviceInfo(username, password, IpAddress.valueOf(ip), port, path, sshkey);
            } else {
                log.error("Unknown device key for device {}", deviceId);
            }
        } catch (NullPointerException e) {
            throw new NetconfException("No Device Key for device " + deviceId, e);
        }
    }
    NetconfDevice netconfDevicedevice = createDevice(deviceInfo);
    netconfDevicedevice.getSession().addDeviceOutputListener(downListener);
    return netconfDevicedevice;
}
#end_block

#method_before
@Override
protected void execute() {
    MetricsService service = get(MetricsService.class);
    Map<String, Counter> counters = service.getCounters(filter);
    Counter arpCounter = counters.get("packetStatisticsComponent.arpFeature.arpPC");
    Counter lldpCounter = counters.get("packetStatisticsComponent.lldpFeature.lldpPC");
    Counter nsCounter = counters.get("packetStatisticsComponent.nbrSolicitFeature.nbrSolicitPC");
    Counter naCounter = counters.get("packetStatisticsComponent.nbrAdvertFeature.nbrAdvertPC");
    print(FORMAT, "ARP ", arpCounter.getCount());
    print(FORMAT, "LLDP ", lldpCounter.getCount());
    print(FORMAT, "Neighbor Solicitation ", nsCounter.getCount());
    print(FORMAT, "Neighbor Advertisement ", naCounter.getCount());
/*
            PacketStatistics pktService = get(PacketSltatistics.class);
            Map<String, Counter> lldpCounters = pktService.getLldpCounters();
            for (Map.Entry<String, Counter> entry : lldpCounters.entrySet()) {
                 print(FORMAT_LLDP, entry.getKey(), entry.getValue());
            } */
}
#method_after
@Override
protected void execute() {
    MetricsService service = get(MetricsService.class);
    Map<String, Counter> counters = service.getCounters(filter);
    Counter arpCounter = counters.get("packetStatisticsComponent.arpFeature.arpPC");
    Counter lldpCounter = counters.get("packetStatisticsComponent.lldpFeature.lldpPC");
    Counter nsCounter = counters.get("packetStatisticsComponent.nbrSolicitFeature.nbrSolicitPC");
    Counter naCounter = counters.get("packetStatisticsComponent.nbrAdvertFeature.nbrAdvertPC");
    print(FORMAT, "ARP ", arpCounter.getCount());
    print(FORMAT, "LLDP ", lldpCounter.getCount());
    print(FORMAT, "Neighbor Solicitation ", nsCounter.getCount());
    print(FORMAT, "Neighbor Advertisement ", naCounter.getCount());
}
#end_block

#method_before
@Activate
protected void activate() {
    super.activate();
    filtCacheEventExecutor = newSingleThreadExecutor(groupedThreads("onos/flowobj", "cache-event-filt", log));
    fwdCacheEventExecutor = newSingleThreadExecutor(groupedThreads("onos/flowobj", "cache-event-fwd", log));
    nextCacheEventExecutor = newSingleThreadExecutor(groupedThreads("onos/flowobj", "cache-event-next", log));
    // TODO Clean up duplicated code
    filtObjQueueHead = CacheBuilder.newBuilder().expireAfterWrite(OBJ_TIMEOUT_MS, TimeUnit.MILLISECONDS).removalListener((RemovalNotification<FilteringObjQueueKey, Objective> notification) -> {
        Objective obj = notification.getValue();
        switch(notification.getCause()) {
            case EXPIRED:
            case COLLECTED:
            case SIZE:
                filtCacheEventExecutor.execute(() -> obj.context().ifPresent(c -> c.onError(obj, ObjectiveError.INSTALLATIONTIMEOUT)));
                break;
            // No action when the objective completes correctly
            case EXPLICIT:
            // No action when a pending forward or next objective gets executed
            case REPLACED:
            default:
                break;
        }
    }).build();
    fwdObjQueueHead = CacheBuilder.newBuilder().expireAfterWrite(OBJ_TIMEOUT_MS, TimeUnit.MILLISECONDS).removalListener((RemovalNotification<ForwardingObjQueueKey, Objective> notification) -> {
        Objective obj = notification.getValue();
        switch(notification.getCause()) {
            case EXPIRED:
            case COLLECTED:
            case SIZE:
                fwdCacheEventExecutor.execute(() -> obj.context().ifPresent(c -> c.onError(obj, ObjectiveError.INSTALLATIONTIMEOUT)));
                break;
            // No action when the objective completes correctly
            case EXPLICIT:
            // No action when a pending forward or next objective gets executed
            case REPLACED:
            default:
                break;
        }
    }).build();
    nextObjQueueHead = CacheBuilder.newBuilder().expireAfterWrite(OBJ_TIMEOUT_MS, TimeUnit.MILLISECONDS).removalListener((RemovalNotification<NextObjQueueKey, Objective> notification) -> {
        Objective obj = notification.getValue();
        switch(notification.getCause()) {
            case EXPIRED:
            case COLLECTED:
            case SIZE:
                nextCacheEventExecutor.execute(() -> obj.context().ifPresent(c -> c.onError(obj, ObjectiveError.INSTALLATIONTIMEOUT)));
                break;
            // No action when the objective completes correctly
            case EXPLICIT:
            // No action when a pending forward or next objective gets executed
            case REPLACED:
            default:
                break;
        }
    }).build();
    cacheCleaner = newSingleThreadScheduledExecutor(groupedThreads("onos/flowobj", "cache-cleaner", log));
    cacheCleaner.scheduleAtFixedRate(() -> {
        filtObjQueueHead.cleanUp();
        fwdObjQueueHead.cleanUp();
        nextObjQueueHead.cleanUp();
    }, 0, OBJ_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    // Replace store delegate to make sure pendingForward and pendingNext are resubmitted to
    // execute()
    flowObjectiveStore.unsetDelegate(super.delegate);
    flowObjectiveStore.setDelegate(delegate);
}
#method_after
@Activate
protected void activate() {
    super.activate();
    filtCacheEventExecutor = newSingleThreadExecutor(groupedThreads("onos/flowobj", "cache-event-filt", log));
    fwdCacheEventExecutor = newSingleThreadExecutor(groupedThreads("onos/flowobj", "cache-event-fwd", log));
    nextCacheEventExecutor = newSingleThreadExecutor(groupedThreads("onos/flowobj", "cache-event-next", log));
    RemovalListener<ObjectiveQueueKey, Objective> removalListener = notification -> {
        Objective obj = notification.getValue();
        switch(notification.getCause()) {
            case EXPIRED:
            case COLLECTED:
            case SIZE:
                obj.context().ifPresent(c -> c.onError(obj, ObjectiveError.INSTALLATIONTIMEOUT));
                break;
            // No action when the objective completes correctly
            case EXPLICIT:
            // No action when a pending forward or next objective gets executed
            case REPLACED:
            default:
                break;
        }
    };
    filtObjQueueHead = CacheBuilder.newBuilder().expireAfterWrite(OBJ_TIMEOUT_MS, TimeUnit.MILLISECONDS).removalListener(RemovalListeners.asynchronous(removalListener, filtCacheEventExecutor)).build();
    fwdObjQueueHead = CacheBuilder.newBuilder().expireAfterWrite(OBJ_TIMEOUT_MS, TimeUnit.MILLISECONDS).removalListener(RemovalListeners.asynchronous(removalListener, fwdCacheEventExecutor)).build();
    nextObjQueueHead = CacheBuilder.newBuilder().expireAfterWrite(OBJ_TIMEOUT_MS, TimeUnit.MILLISECONDS).removalListener(RemovalListeners.asynchronous(removalListener, nextCacheEventExecutor)).build();
    cacheCleaner = newSingleThreadScheduledExecutor(groupedThreads("onos/flowobj", "cache-cleaner", log));
    cacheCleaner.scheduleAtFixedRate(() -> {
        filtObjQueueHead.cleanUp();
        fwdObjQueueHead.cleanUp();
        nextObjQueueHead.cleanUp();
    }, 0, OBJ_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    // Replace store delegate to make sure pendingForward and pendingNext are resubmitted to
    // execute()
    flowObjectiveStore.unsetDelegate(super.delegate);
    flowObjectiveStore.setDelegate(delegate);
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cacheCleaner.shutdown();
    clearQueue();
    super.deactivate();
}
#method_after
@Deactivate
protected void deactivate() {
    cacheCleaner.shutdown();
    clearQueue();
    filtCacheEventExecutor.shutdown();
    fwdCacheEventExecutor.shutdown();
    nextCacheEventExecutor.shutdown();
    super.deactivate();
}
#end_block

#method_before
private synchronized void dequeue(DeviceId deviceId, Objective obj, ObjectiveError error) {
    List<Objective> remaining;
    int priority = obj.priority();
    LogLevel logLevel = (obj.op() == Objective.Operation.VERIFY) ? LogLevel.TRACE : LogLevel.DEBUG;
    Tools.log(log, logLevel, "Dequeue {}", obj);
    if (obj instanceof FilteringObjective) {
        FilteringObjQueueKey k = new FilteringObjQueueKey(deviceId, priority, ((FilteringObjective) obj).key());
        if (!ObjectiveError.INSTALLATIONTIMEOUT.equals(error)) {
            filtObjQueueHead.invalidate(k);
        }
        filtObjQueue.remove(k, obj);
        remaining = filtObjQueue.get(k);
    } else if (obj instanceof ForwardingObjective) {
        ForwardingObjQueueKey k = new ForwardingObjQueueKey(deviceId, priority, ((ForwardingObjective) obj).selector());
        if (!ObjectiveError.INSTALLATIONTIMEOUT.equals(error)) {
            fwdObjQueueHead.invalidate(k);
        }
        fwdObjQueue.remove(k, obj);
        remaining = fwdObjQueue.get(k);
    } else if (obj instanceof NextObjective) {
        if (error != null) {
            // Remove pendingForwards and pendingNexts if next objective failed
            Set<PendingFlowObjective> removedForwards = pendingForwards.remove(obj.id());
            List<PendingFlowObjective> removedNexts = pendingNexts.remove(obj.id());
            if (removedForwards != null) {
                removedForwards.stream().map(PendingFlowObjective::flowObjective).forEach(pendingObj -> pendingObj.context().ifPresent(c -> c.onError(pendingObj, error)));
            }
            if (removedNexts != null) {
                removedNexts.stream().map(PendingFlowObjective::flowObjective).forEach(pendingObj -> pendingObj.context().ifPresent(c -> c.onError(pendingObj, error)));
            }
        }
        NextObjQueueKey k = new NextObjQueueKey(deviceId, obj.id());
        if (!ObjectiveError.INSTALLATIONTIMEOUT.equals(error)) {
            nextObjQueueHead.invalidate(k);
        }
        nextObjQueue.remove(k, obj);
        remaining = nextObjQueue.get(k);
    } else {
        log.error("Unknown flow objective instance: {}", obj.getClass().getName());
        return;
    }
    log.trace("{} queue size {}", obj.getClass().getSimpleName(), remaining.size());
    // Submit the next one in the queue, if any
    if (remaining.size() > 0) {
        execute(deviceId, remaining.get(0));
    }
}
#method_after
private synchronized void dequeue(DeviceId deviceId, Objective obj, ObjectiveError error) {
    List<Objective> remaining;
    int priority = obj.priority();
    LogLevel logLevel = (obj.op() == Objective.Operation.VERIFY) ? LogLevel.TRACE : LogLevel.DEBUG;
    Tools.log(log, logLevel, "Dequeue {}", obj);
    if (obj instanceof FilteringObjective) {
        FilteringObjQueueKey k = new FilteringObjQueueKey(deviceId, priority, ((FilteringObjective) obj).key());
        if (!Objects.equals(ObjectiveError.INSTALLATIONTIMEOUT, error)) {
            filtObjQueueHead.invalidate(k);
        }
        filtObjQueue.remove(k, obj);
        remaining = filtObjQueue.get(k);
    } else if (obj instanceof ForwardingObjective) {
        ForwardingObjQueueKey k = new ForwardingObjQueueKey(deviceId, priority, ((ForwardingObjective) obj).selector());
        if (!Objects.equals(ObjectiveError.INSTALLATIONTIMEOUT, error)) {
            fwdObjQueueHead.invalidate(k);
        }
        fwdObjQueue.remove(k, obj);
        remaining = fwdObjQueue.get(k);
    } else if (obj instanceof NextObjective) {
        if (error != null) {
            // Remove pendingForwards and pendingNexts if next objective failed
            Set<PendingFlowObjective> removedForwards = pendingForwards.remove(obj.id());
            List<PendingFlowObjective> removedNexts = pendingNexts.remove(obj.id());
            if (removedForwards != null) {
                removedForwards.stream().map(PendingFlowObjective::flowObjective).forEach(pendingObj -> pendingObj.context().ifPresent(c -> c.onError(pendingObj, error)));
            }
            if (removedNexts != null) {
                removedNexts.stream().map(PendingFlowObjective::flowObjective).forEach(pendingObj -> pendingObj.context().ifPresent(c -> c.onError(pendingObj, error)));
            }
        }
        NextObjQueueKey k = new NextObjQueueKey(deviceId, obj.id());
        if (!Objects.equals(ObjectiveError.INSTALLATIONTIMEOUT, error)) {
            nextObjQueueHead.invalidate(k);
        }
        nextObjQueue.remove(k, obj);
        remaining = nextObjQueue.get(k);
    } else {
        log.error("Unknown flow objective instance: {}", obj.getClass().getName());
        return;
    }
    log.trace("{} queue size {}", obj.getClass().getSimpleName(), remaining.size());
    // Submit the next one in the queue, if any
    if (remaining.size() > 0) {
        execute(deviceId, remaining.get(0));
    }
}
#end_block

#method_before
@Override
public boolean subscribe(SubscribeRequest request) {
    return streamChannelManager.subscribeOnChange(request);
}
#method_after
@Override
public boolean subscribe(SubscribeRequest request) {
    return gnmiSubscriptionManager.subscribe(request);
}
#end_block

#method_before
@Override
public void terminateSubscriptionChannel() {
    streamChannelManager.complete();
}
#method_after
@Override
public void terminateSubscriptionChannel() {
    gnmiSubscriptionManager.complete();
}
#end_block

#method_before
@Override
protected Void doShutdown() {
    streamChannelManager.complete();
    return super.doShutdown();
}
#method_after
@Override
protected Void doShutdown() {
    gnmiSubscriptionManager.shutdown();
    return super.doShutdown();
}
#end_block

#method_before
@Override
public List<CharSequence> enable(PortNumber client, PortNumber line, boolean enable) {
    log.debug("enable() cassini route");
    DeviceId did = this.data().deviceId();
    Port clientPort = handler().get(DeviceService.class).getPort(did, client);
    if (clientPort == null) {
        log.warn("{} does not exist on {}", client, did);
        return Collections.emptyList();
    }
    String clientName = clientPort.annotations().value(OC_NAME);
    if (Strings.isNullOrEmpty(clientName)) {
        log.warn("{} annotations not exist on {}@{}", OC_NAME, client, did);
        return Collections.emptyList();
    }
    Port linePort = handler().get(DeviceService.class).getPort(did, line);
    if (linePort == null) {
        log.warn("{} does not exist on {}", line, did);
        return Collections.emptyList();
    }
    String lineName = linePort.annotations().value(OC_NAME);
    if (Strings.isNullOrEmpty(lineName)) {
        log.warn("{} annotations not exist on {}@{}", OC_NAME, line, did);
        return Collections.emptyList();
    }
    // create <terminal-device xmlns="http://openconfig.net/yang/terminal-device">
    // </terminal-device>
    OpenConfigTerminalDeviceHandler terminalDevice = new OpenConfigTerminalDeviceHandler();
    // add <logical-channels></logical-channels>
    OpenConfigLogicalChannelsHandler logicalChannels = new OpenConfigLogicalChannelsHandler(terminalDevice);
    // add <channel><index>"clientName"</index></channel>
    OpenConfigChannelHandler channel = new OpenConfigChannelHandler(Integer.parseInt(clientName), logicalChannels);
    // add <config><index>"clientName"</index></config>
    OpenConfigConfigOfChannelHandler configOfChannel = new OpenConfigConfigOfChannelHandler(channel);
    configOfChannel.addIndex(Integer.parseInt(clientName));
    // add <logical-channel-assignments xc:operation="merge/delete">
    OpenConfigLogicalChannelAssignmentsHandler logicalChannelAssignments = new OpenConfigLogicalChannelAssignmentsHandler(channel);
    // add <assignment><index>"clientName"</index></assignment>
    OpenConfigAssignmentHandler assignment = new OpenConfigAssignmentHandler(Integer.parseInt(clientName), logicalChannelAssignments);
    if (!enable) {
        assignment.addAnnotation(ANOTATION_NAME, Operation.DELETE.value());
    }
    // add <config><assignment-type>LOGICAL_CHANNEL</assignment-type>
    // <logical-channel>"lineName"</logical-channel>
    // <allocation>100</allocation>
    // </config>
    OpenConfigConfigOfAssignmentHandler configOfAssignment = new OpenConfigConfigOfAssignmentHandler(assignment);
    configOfAssignment.addIndex(Long.parseLong(clientName));
    configOfAssignment.addAssignmentType(AssignmentTypeEnum.LOGICAL_CHANNEL);
    configOfAssignment.addLogicalChannel(lineName);
    configOfAssignment.addAllocation(BigDecimal.valueOf(100));
    return terminalDevice.getListCharSequence();
}
#method_after
@Override
public List<CharSequence> enable(PortNumber client, PortNumber line, boolean enable) {
    log.debug("enable() cassini route");
    DeviceId did = this.data().deviceId();
    Port clientPort = handler().get(DeviceService.class).getPort(did, client);
    if (clientPort == null) {
        log.warn("{} does not exist on {}", client, did);
        return Collections.emptyList();
    }
    String clientName = clientPort.annotations().value(OC_NAME);
    if (Strings.isNullOrEmpty(clientName)) {
        log.warn("{} annotations not exist on {}@{}", OC_NAME, client, did);
        return Collections.emptyList();
    }
    Port linePort = handler().get(DeviceService.class).getPort(did, line);
    if (linePort == null) {
        log.warn("{} does not exist on {}", line, did);
        return Collections.emptyList();
    }
    String lineName = linePort.annotations().value(OC_NAME);
    if (Strings.isNullOrEmpty(lineName)) {
        log.warn("{} annotations not exist on {}@{}", OC_NAME, line, did);
        return Collections.emptyList();
    }
    // create <terminal-device xmlns="http://openconfig.net/yang/terminal-device">
    // </terminal-device>
    OpenConfigTerminalDeviceHandler terminalDevice = new OpenConfigTerminalDeviceHandler();
    // add <logical-channels></logical-channels>
    OpenConfigLogicalChannelsHandler logicalChannels = new OpenConfigLogicalChannelsHandler(terminalDevice);
    // add <channel><index>"clientName"</index></channel>
    OpenConfigChannelHandler channel = new OpenConfigChannelHandler(Integer.parseInt(clientName), logicalChannels);
    // add <config><index>"clientName"</index></config>
    OpenConfigConfigOfChannelHandler configOfChannel = new OpenConfigConfigOfChannelHandler(channel);
    configOfChannel.addIndex(Integer.parseInt(clientName));
    // add <logical-channel-assignments></logical-channel-assignments>
    OpenConfigLogicalChannelAssignmentsHandler logicalChannelAssignments = new OpenConfigLogicalChannelAssignmentsHandler(channel);
    // add <assignment (none)/xc:operation="delete"><index>"clientName"</index></assignment>
    OpenConfigAssignmentHandler assignment = new OpenConfigAssignmentHandler(Integer.parseInt(clientName), logicalChannelAssignments);
    if (!enable) {
        assignment.addAnnotation(ANOTATION_NAME, Operation.DELETE.value());
    }
    // add <config><index>"clientName"</index>
    // <assignment-type>LOGICAL_CHANNEL</assignment-type>
    // <logical-channel>"lineName"</logical-channel>
    // <allocation>100</allocation>
    // </config>
    OpenConfigConfigOfAssignmentHandler configOfAssignment = new OpenConfigConfigOfAssignmentHandler(assignment);
    configOfAssignment.addIndex(Long.parseLong(clientName));
    configOfAssignment.addAssignmentType(AssignmentTypeEnum.LOGICAL_CHANNEL);
    configOfAssignment.addLogicalChannel(lineName);
    configOfAssignment.addAllocation(BigDecimal.valueOf(100));
    return terminalDevice.getListCharSequence();
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    // Not really used right now
    return new DefaultDeviceDescription(handler().data().deviceId().uri(), Device.Type.OTN, "EDGECORE", "Cassini1", "OcNOS", "", new ChassisId("1"));
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    return new DefaultDeviceDescription(handler().data().deviceId().uri(), Device.Type.OTN, "EDGECORE", "Cassini", "OcNOS", "", new ChassisId("1"));
}
#end_block

#method_before
private PortDescription parseLogicalChannel(HierarchicalConfiguration channel) {
    HierarchicalConfiguration config = channel.configurationAt("config");
    String name = config.getString("index");
    String portName = config.getString("description");
    log.info("Parsing Component {} type {}", name, portName);
    Map<String, String> annotations = new HashMap<>();
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_NAME, name);
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_TYPE, portName);
    // Store all properties as port properties
    // e.g. ce1/1
    Pattern clientPattern = Pattern.compile("ce(\\d*)/1");
    // e.g. oe1
    Pattern linePattern = Pattern.compile("oe(\\d*)");
    Matcher clientMatch = clientPattern.matcher(portName);
    Matcher lineMatch = linePattern.matcher(portName);
    Builder builder = DefaultPortDescription.builder();
    if (clientMatch.find()) {
        Long num = Long.parseLong(clientMatch.group(1));
        Long portNum = 100 + num;
        String connectionId = "connection:" + num.toString();
        annotations.putIfAbsent(PORT_TYPE, OdtnPortType.CLIENT.value());
        annotations.putIfAbsent(ONOS_PORT_INDEX, portNum.toString());
        annotations.putIfAbsent(CONNECTION_ID, connectionId);
        builder.withPortNumber(PortNumber.portNumber(portNum, name));
        builder.type(Type.PACKET);
    } else if (lineMatch.find()) {
        Long num = Long.parseLong(lineMatch.group(1));
        Long portNum = 200 + num;
        String connectionId = "connection:" + num.toString();
        annotations.putIfAbsent(PORT_TYPE, OdtnPortType.LINE.value());
        annotations.putIfAbsent(ONOS_PORT_INDEX, portNum.toString());
        annotations.putIfAbsent(CONNECTION_ID, connectionId);
        builder.withPortNumber(PortNumber.portNumber(portNum, name));
        builder.type(Type.OCH);
    }
    builder.annotations(DefaultAnnotations.builder().putAll(annotations).build());
    return builder.build();
}
#method_after
private PortDescription parseLogicalChannel(HierarchicalConfiguration channel) {
    HierarchicalConfiguration config = channel.configurationAt("config");
    String name = config.getString("index");
    String portName = config.getString("description");
    String rateClass = config.getString("rate-class");
    log.info("Parsing Component {} type {} rate {}", name, portName, rateClass);
    Map<String, String> annotations = new HashMap<>();
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_NAME, name);
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_TYPE, portName);
    // Store all properties as port properties
    // e.g. ce1/1
    Pattern clientPattern = Pattern.compile("ce(\\d*)/1");
    // e.g. oe1
    Pattern linePattern = Pattern.compile("oe(\\d*)");
    Matcher clientMatch = clientPattern.matcher(portName);
    Matcher lineMatch = linePattern.matcher(portName);
    Pattern portSpeedPattern = Pattern.compile("TRIB_RATE_([0-9.]*)G");
    Matcher portSpeedMatch = portSpeedPattern.matcher(rateClass);
    Builder builder = DefaultPortDescription.builder();
    if (clientMatch.find()) {
        Long num = Long.parseLong(clientMatch.group(1));
        Long portNum = 100 + num;
        String connectionId = "connection:" + num.toString();
        annotations.putIfAbsent(PORT_TYPE, OdtnPortType.CLIENT.value());
        annotations.putIfAbsent(ONOS_PORT_INDEX, portNum.toString());
        annotations.putIfAbsent(CONNECTION_ID, connectionId);
        builder.withPortNumber(PortNumber.portNumber(portNum, name));
        builder.type(Type.PACKET);
    } else if (lineMatch.find()) {
        Long num = Long.parseLong(lineMatch.group(1));
        Long portNum = 200 + num;
        String connectionId = "connection:" + num.toString();
        annotations.putIfAbsent(PORT_TYPE, OdtnPortType.LINE.value());
        annotations.putIfAbsent(ONOS_PORT_INDEX, portNum.toString());
        annotations.putIfAbsent(CONNECTION_ID, connectionId);
        builder.withPortNumber(PortNumber.portNumber(portNum, name));
        builder.type(Type.OCH);
    }
    if (portSpeedMatch.find()) {
        Long speed = Long.parseLong(portSpeedMatch.group(1));
        builder.portSpeed(speed * 1000);
    }
    builder.annotations(DefaultAnnotations.builder().putAll(annotations).build());
    return builder.build();
}
#end_block

#method_before
@Override
public RpcOutput createConnectivityService(RpcInput inputVar) {
    try {
        TapiCreateConnectivityInputHandler input = new TapiCreateConnectivityInputHandler();
        input.setRpcInput(inputVar);
        log.info("input SIPs: {}", input.getSips());
        // check SIP validation
        if (!checkSipValidation(input.getSips())) {
            log.error("check SIP validation : NG");
            return new RpcOutput(RpcOutput.Status.RPC_FAILURE, null);
        }
        log.info("check SIP validation : OK");
        List<TapiNepRef> nepRefs = input.getSips().stream().map(sipId -> resolver.getNepRef(sipId)).collect(Collectors.toList());
        // for test
        // Map<String, String> filter = new HashMap<>();
        // filter.put(ODTN_PORT_TYPE, OdtnDeviceDescriptionDiscovery.OdtnPortType.CLIENT.value());
        // List<TapiNepRef> nepRefs = resolver.getNepRefs(filter);
        // setup connections
        TapiNepPair neps = TapiNepPair.create(nepRefs.get(0), nepRefs.get(1));
        DcsBasedTapiConnectionManager connectionManager = DcsBasedTapiConnectionManager.create();
        connectionManager.createConnection(neps);
        // setup connectivity service
        TapiConnectivityServiceHandler connectivityServiceHandler = TapiConnectivityServiceHandler.create();
        connectivityServiceHandler.addConnection(connectionManager.getConnectionHandler().getModelObject().uuid());
        neps.stream().map(nepRef -> TapiSepHandler.create().setSip(nepRef.getSipId())).forEach(sepBuilder -> {
            connectivityServiceHandler.addSep(sepBuilder.getModelObject());
        });
        // build
        connectionManager.apply();
        connectivityServiceHandler.add();
        // output
        TapiCreateConnectivityOutputHandler output = TapiCreateConnectivityOutputHandler.create().addService(connectivityServiceHandler.getModelObject());
        return new RpcOutput(RpcOutput.Status.RPC_SUCCESS, output.getDataNode());
    } catch (Throwable e) {
        log.error("Error:", e);
        return new RpcOutput(RpcOutput.Status.RPC_FAILURE, null);
    }
}
#method_after
@Override
public RpcOutput createConnectivityService(RpcInput inputVar) {
    try {
        TapiCreateConnectivityInputHandler input = new TapiCreateConnectivityInputHandler();
        input.setRpcInput(inputVar);
        log.info("input SIPs: {}", input.getSips());
        // check SIP validation
        if (!disjoint(getUsedSips(), input.getSips())) {
            log.error("check SIP validation : NG");
            return new RpcOutput(RpcOutput.Status.RPC_FAILURE, null);
        }
        log.debug("check SIP validation : OK");
        List<TapiNepRef> nepRefs = input.getSips().stream().map(sipId -> resolver.getNepRef(sipId)).collect(Collectors.toList());
        // for test
        // Map<String, String> filter = new HashMap<>();
        // filter.put(ODTN_PORT_TYPE, OdtnDeviceDescriptionDiscovery.OdtnPortType.CLIENT.value());
        // List<TapiNepRef> nepRefs = resolver.getNepRefs(filter);
        // setup connections
        TapiNepPair neps = TapiNepPair.create(nepRefs.get(0), nepRefs.get(1));
        DcsBasedTapiConnectionManager connectionManager = DcsBasedTapiConnectionManager.create();
        connectionManager.createConnection(neps);
        // setup connectivity service
        TapiConnectivityServiceHandler connectivityServiceHandler = TapiConnectivityServiceHandler.create();
        connectivityServiceHandler.addConnection(connectionManager.getConnectionHandler().getModelObject().uuid());
        neps.stream().map(nepRef -> TapiSepHandler.create().setSip(nepRef.getSipId())).forEach(sepBuilder -> {
            connectivityServiceHandler.addSep(sepBuilder.getModelObject());
        });
        // build
        connectionManager.apply();
        connectivityServiceHandler.add();
        // output
        TapiCreateConnectivityOutputHandler output = TapiCreateConnectivityOutputHandler.create().addService(connectivityServiceHandler.getModelObject());
        return new RpcOutput(RpcOutput.Status.RPC_SUCCESS, output.getDataNode());
    } catch (Throwable e) {
        log.error("Error:", e);
        return new RpcOutput(RpcOutput.Status.RPC_FAILURE, null);
    }
}
#end_block

#method_before
private List<String> getUsedSips() {
    TapiContextHandler handler = TapiContextHandler.create();
    handler.read();
    List<String> usedSips = new ArrayList();
    handler.getConnectivityServices().stream().forEach(connectivityService -> connectivityService.getEndPoint().stream().forEach(endPoint -> usedSips.add(endPoint.serviceInterfacePoint().serviceInterfacePointUuid().toString())));
    log.info("usedSips: {}", usedSips);
    return usedSips;
}
#method_after
private List<String> getUsedSips() {
    TapiContextHandler handler = TapiContextHandler.create();
    handler.read();
    List<String> usedSips = new ArrayList();
    handler.getConnectivityServices().stream().forEach(connectivityService -> connectivityService.getEndPoint().stream().forEach(endPoint -> usedSips.add(endPoint.serviceInterfacePoint().serviceInterfacePointUuid().toString())));
    log.debug("usedSips: {}", usedSips);
    return usedSips;
}
#end_block

#method_before
@Override
public void filter(ContainerRequestContext requestContext) throws IOException {
    if (disableForTests) {
        return;
    }
    auditService = services.get(AuditService.class);
    requestContext.setProperty("auditStatus", auditService.getAuditServiceStatus());
    requestContext.setProperty("auditService", auditService);
    if ((Boolean) requestContext.getProperty("auditStatus")) {
        String requestBody = (requestContext.hasEntity() ? (readTreeFromStream(mapper(), requestContext.getEntityStream()).toString()) : "");
        requestContext.setProperty("requestBody", requestBody);
        requestContext.setProperty("auditLog", "Path: " + getUrlPath(requestContext) + separator + "Method: " + getUrlMethod(requestContext) + separator + (isUrlMethod(requestContext, "PUT") ? ("Path_Parameters: " + getPathParameters(requestContext) + separator + "Query_Parameters: " + getQueryParameters(requestContext) + separator + "Request_Body: " + requestBody) : ""));
        requestContext.setEntityStream(IOUtils.toInputStream(requestBody));
    }
}
#method_after
@Override
public void filter(ContainerRequestContext requestContext) throws IOException {
    if (disableForTests) {
        return;
    }
    if (isEnabled()) {
        String requestBody = (requestContext.hasEntity() ? (readTreeFromStream(mapper, requestContext.getEntityStream()).toString()) : "");
        requestContext.setProperty("requestBody", requestBody);
        requestContext.setProperty("auditLog", "Path: " + requestContext.getUriInfo().getPath() + separator + "Method: " + requestContext.getMethod() + separator + (requestContext.getMethod().equals("PUT") ? ("Path_Parameters: " + requestContext.getUriInfo().getPathParameters().toString() + separator + "Query_Parameters: " + requestContext.getUriInfo().getQueryParameters().toString() + separator + "Request_Body: " + requestBody) : ""));
        requestContext.setEntityStream(IOUtils.toInputStream(requestBody));
    }
}
#end_block

#method_before
@Override
public void filter(ContainerRequestContext containerRequestContext, ContainerResponseContext containerResponseContext) throws IOException {
    if (disableForTests) {
        return;
    }
    if (containerRequestContext.getProperty("auditStatus") != null && (Boolean) containerRequestContext.getProperty("auditStatus")) {
        containerRequestContext.setProperty("auditLog", containerRequestContext.getProperty("auditLog") + separator + "Status: " + getResponseStatus(containerResponseContext));
        saveCliLog(containerRequestContext.getProperty("auditLog").toString(), containerRequestContext);
    }
}
#method_after
@Override
public void filter(ContainerRequestContext containerRequestContext, ContainerResponseContext containerResponseContext) throws IOException {
    if (disableForTests) {
        return;
    }
    if (isEnabled()) {
        containerRequestContext.setProperty("auditLog", containerRequestContext.getProperty("auditLog") + separator + "Status: " + containerResponseContext.getStatusInfo().toString());
        saveAuditLog(containerRequestContext.getProperty("auditLog").toString());
    }
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getIntents() {
    DeviceService deviceService = get(DeviceService.class);
    IntentService intentService = get(IntentService.class);
    Iterator intentItr = intentService.getIntents().iterator();
    ArrayNode arrayFlows = mapper().createArrayNode();
    while (intentItr.hasNext()) {
        Intent intent = (Intent) intentItr.next();
        if (intent instanceof OpticalConnectivityIntent) {
            OpticalConnectivityIntent opticalConnectivityIntent = (OpticalConnectivityIntent) intent;
            Device srcDevice = deviceService.getDevice(opticalConnectivityIntent.getSrc().deviceId());
            Device dstDevice = deviceService.getDevice(opticalConnectivityIntent.getDst().deviceId());
            String srcDeviceName = srcDevice.annotations().value(AnnotationKeys.NAME);
            String dstDeviceName = dstDevice.annotations().value(AnnotationKeys.NAME);
            ObjectNode objectNode = mapper().createObjectNode();
            objectNode.put("intent id", opticalConnectivityIntent.id().toString());
            objectNode.put("app id", opticalConnectivityIntent.appId().name());
            objectNode.put("state", intentService.getIntentState(opticalConnectivityIntent.key()).toString());
            objectNode.put("src", opticalConnectivityIntent.getSrc().toString());
            objectNode.put("dst", opticalConnectivityIntent.getDst().toString());
            objectNode.put("srcName", srcDeviceName);
            objectNode.put("dstName", dstDeviceName);
            // Only for INSTALLED intents
            if (intentService.getIntentState(intent.key()) == IntentState.INSTALLED) {
                objectNode.put("ochSignal", opticalConnectivityIntent.ochSignal().toString());
                objectNode.put("centralFreq", opticalConnectivityIntent.ochSignal().get().centralFrequency().asTHz() + " THz");
                // Retrieve associated FlowRuleIntent
                FlowRuleIntent installableIntent = (FlowRuleIntent) intentService.getInstallableIntents(opticalConnectivityIntent.key()).stream().filter(FlowRuleIntent.class::isInstance).findFirst().orElse(null);
                // TODO store utilized ochSignal in the intent resources
                if (installableIntent != null) {
                    OchSignal signal = installableIntent.flowRules().stream().map(r -> ((OchSignalCriterion) r.selector().getCriterion(Criterion.Type.OCH_SIGID)).lambda()).findFirst().orElse(null);
                    objectNode.put("ochSignal", signal.toString());
                    objectNode.put("centralFreq", signal.centralFrequency().asTHz() + " THz");
                }
                // Retrieve path and print it to REST
                if (installableIntent != null) {
                    String path = installableIntent.resources().stream().filter(Link.class::isInstance).map(Link.class::cast).map(r -> deviceService.getDevice(r.src().deviceId())).map(r -> r.annotations().value(AnnotationKeys.NAME)).collect(Collectors.joining(" -> "));
                    List<Link> pathLinks = installableIntent.resources().stream().filter(Link.class::isInstance).map(Link.class::cast).collect(Collectors.toList());
                    DefaultPath defaultPath = new DefaultPath(PROVIDER_ID, pathLinks, new ScalarWeight(1));
                    objectNode.put("path", defaultPath.toString());
                    objectNode.put("pathName", path + " -> " + dstDeviceName);
                }
            }
            arrayFlows.add(objectNode);
        }
    }
    ObjectNode root = this.mapper().createObjectNode().putPOJO("Intents", arrayFlows);
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getIntents() {
    DeviceService deviceService = get(DeviceService.class);
    IntentService intentService = get(IntentService.class);
    Iterator intentItr = intentService.getIntents().iterator();
    ArrayNode arrayFlows = mapper().createArrayNode();
    while (intentItr.hasNext()) {
        Intent intent = (Intent) intentItr.next();
        if (intent instanceof OpticalConnectivityIntent) {
            OpticalConnectivityIntent opticalConnectivityIntent = (OpticalConnectivityIntent) intent;
            Device srcDevice = deviceService.getDevice(opticalConnectivityIntent.getSrc().deviceId());
            Device dstDevice = deviceService.getDevice(opticalConnectivityIntent.getDst().deviceId());
            String srcDeviceName = srcDevice.annotations().value(AnnotationKeys.NAME);
            String dstDeviceName = dstDevice.annotations().value(AnnotationKeys.NAME);
            ObjectNode objectNode = mapper().createObjectNode();
            objectNode.put("intent id", opticalConnectivityIntent.id().toString());
            objectNode.put("app id", opticalConnectivityIntent.appId().name());
            objectNode.put("state", intentService.getIntentState(opticalConnectivityIntent.key()).toString());
            objectNode.put("src", opticalConnectivityIntent.getSrc().toString());
            objectNode.put("dst", opticalConnectivityIntent.getDst().toString());
            objectNode.put("srcName", srcDeviceName);
            objectNode.put("dstName", dstDeviceName);
            // Only for INSTALLED intents
            if (intentService.getIntentState(intent.key()) == IntentState.INSTALLED) {
                // Retrieve associated FlowRuleIntent
                FlowRuleIntent installableIntent = (FlowRuleIntent) intentService.getInstallableIntents(opticalConnectivityIntent.key()).stream().filter(FlowRuleIntent.class::isInstance).findFirst().orElse(null);
                // TODO store utilized ochSignal in the intent resources
                if (installableIntent != null) {
                    OchSignal signal = installableIntent.flowRules().stream().map(r -> ((OchSignalCriterion) r.selector().getCriterion(Criterion.Type.OCH_SIGID)).lambda()).findFirst().orElse(null);
                    objectNode.put("ochSignal", signal.toString());
                    objectNode.put("centralFreq", signal.centralFrequency().asTHz() + " THz");
                }
                // Retrieve path and print it to REST
                if (installableIntent != null) {
                    String path = installableIntent.resources().stream().filter(Link.class::isInstance).map(Link.class::cast).map(r -> deviceService.getDevice(r.src().deviceId())).map(r -> r.annotations().value(AnnotationKeys.NAME)).collect(Collectors.joining(" -> "));
                    List<Link> pathLinks = installableIntent.resources().stream().filter(Link.class::isInstance).map(Link.class::cast).collect(Collectors.toList());
                    DefaultPath defaultPath = new DefaultPath(PROVIDER_ID, pathLinks, new ScalarWeight(1));
                    objectNode.put("path", defaultPath.toString());
                    objectNode.put("pathName", path + " -> " + dstDeviceName);
                }
            }
            arrayFlows.add(objectNode);
        }
    }
    ObjectNode root = this.mapper().createObjectNode().putPOJO("Intents", arrayFlows);
    return ok(root).build();
}
#end_block

#method_before
public static Intent createExplicitOpticalIntent(ConnectPoint ingress, ConnectPoint egress, DeviceService deviceService, Key key, ApplicationId appId, boolean bidirectional, OchSignal signal, Path path) {
    Intent intent = null;
    if (ingress == null || egress == null) {
        log.debug("Invalid endpoint(s); could not create optical intent");
        return intent;
    }
    DeviceService ds = opticalView(deviceService);
    Port srcPort = ds.getPort(ingress.deviceId(), ingress.port());
    Port dstPort = ds.getPort(egress.deviceId(), egress.port());
    if (srcPort instanceof OduCltPort && dstPort instanceof OduCltPort) {
        Device srcDevice = ds.getDevice(ingress.deviceId());
        Device dstDevice = ds.getDevice(egress.deviceId());
        // continue only if both OduClt port's Devices are of the same type
        if (!(srcDevice.type().equals(dstDevice.type()))) {
            log.debug("Devices without same deviceType: SRC={} and DST={}", srcDevice.type(), dstDevice.type());
            return intent;
        }
        CltSignalType signalType = ((OduCltPort) srcPort).signalType();
        if (Device.Type.ROADM.equals(srcDevice.type()) || Device.Type.ROADM_OTN.equals(srcDevice.type())) {
            intent = OpticalCircuitIntent.builder().appId(appId).key(key).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).build();
        } else if (Device.Type.OTN.equals(srcDevice.type())) {
            intent = OpticalOduIntent.builder().appId(appId).key(key).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).build();
        } else {
            log.debug("Wrong Device Type for connect points {} and {}", ingress, egress);
        }
    } else if (srcPort instanceof OchPort && dstPort instanceof OchPort) {
        OduSignalType signalType = ((OchPort) srcPort).signalType();
        intent = OpticalConnectivityIntent.builder().appId(appId).key(key).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).ochSignal(signal).suggestedPath(path).build();
    } else {
        log.debug("Unable to create explicit optical intent between connect points {} and {}", ingress, egress);
    }
    return intent;
}
#method_after
public static Intent createExplicitOpticalIntent(ConnectPoint ingress, ConnectPoint egress, DeviceService deviceService, Key key, ApplicationId appId, boolean bidirectional, OchSignal signal, Path path) {
    Intent intent = null;
    if (ingress == null || egress == null) {
        log.error("Invalid endpoint(s); could not create optical intent");
        return intent;
    }
    DeviceService ds = opticalView(deviceService);
    Port srcPort = ds.getPort(ingress.deviceId(), ingress.port());
    Port dstPort = ds.getPort(egress.deviceId(), egress.port());
    if (srcPort instanceof OduCltPort && dstPort instanceof OduCltPort) {
        Device srcDevice = ds.getDevice(ingress.deviceId());
        Device dstDevice = ds.getDevice(egress.deviceId());
        // continue only if both OduClt port's Devices are of the same type
        if (!(srcDevice.type().equals(dstDevice.type()))) {
            log.debug("Devices without same deviceType: SRC={} and DST={}", srcDevice.type(), dstDevice.type());
            return intent;
        }
        CltSignalType signalType = ((OduCltPort) srcPort).signalType();
        if (Device.Type.ROADM.equals(srcDevice.type()) || Device.Type.ROADM_OTN.equals(srcDevice.type())) {
            intent = OpticalCircuitIntent.builder().appId(appId).key(key).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).build();
        } else if (Device.Type.OTN.equals(srcDevice.type())) {
            intent = OpticalOduIntent.builder().appId(appId).key(key).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).build();
        } else {
            log.error("Wrong Device Type for connect points: " + "ingress {} of type {}; egress {} of type {}", ingress, srcDevice.type(), egress, dstDevice.type());
        }
    } else if (srcPort instanceof OchPort && dstPort instanceof OchPort) {
        OduSignalType signalType = ((OchPort) srcPort).signalType();
        intent = OpticalConnectivityIntent.builder().appId(appId).key(key).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).ochSignal(signal).suggestedPath(path).build();
    } else {
        log.error("Unable to create explicit optical intent between connect points {} and {}", ingress, egress);
    }
    return intent;
}
#end_block

#method_before
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    checkArgument(deviceService.getPort(src.deviceId(), src.port()) instanceof OchPort);
    checkArgument(deviceService.getPort(dst.deviceId(), dst.port()) instanceof OchPort);
    List<Resource> resources = new LinkedList<>();
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // Release of intent resources here is only a temporary solution for handling the
    // case of recompiling due to intent restoration (when intent state is FAILED).
    // TODO: try to release intent resources in IntentManager.
    resourceService.release(intent.key());
    // Check OCh port availability
    // If ports are not available, compilation fails
    // Else add port to resource reservation list
    Resource srcPortResource = Resources.discrete(src.deviceId(), src.port()).resource();
    Resource dstPortResource = Resources.discrete(dst.deviceId(), dst.port()).resource();
    if (!Stream.of(srcPortResource, dstPortResource).allMatch(resourceService::isAvailable)) {
        log.error("Ports for the intent are not available. Intent: {}", intent);
        throw new OpticalIntentCompilationException("Ports for the intent are not available. Intent: " + intent);
    }
    resources.add(srcPortResource);
    resources.add(dstPortResource);
    // If there is a suggestedPath, use this path without further checking, otherwise trigger path computation
    Stream<Path> paths;
    if (intent.suggestedPath().isPresent()) {
        Set<Path> pathsSet = new HashSet<>();
        pathsSet.add(intent.suggestedPath().get());
        paths = pathsSet.stream();
    } else {
        paths = getOpticalPaths(intent);
    }
    // Find first path that has the required resources
    Optional<Map.Entry<Path, List<OchSignal>>> found = paths.map(path -> Maps.immutableEntry(path, findFirstAvailableLambda(intent, path))).filter(entry -> !entry.getValue().isEmpty()).filter(entry -> convertToResources(entry.getKey(), entry.getValue()).stream().allMatch(resourceService::isAvailable)).findFirst();
    // Allocate resources and create optical path intent
    if (found.isPresent()) {
        resources.addAll(convertToResources(found.get().getKey(), found.get().getValue()));
        allocateResources(intent, resources);
        OchSignal ochSignal = OchSignal.toFixedGrid(found.get().getValue(), ChannelSpacing.CHL_50GHZ);
        // intent.ochSignal = Optional.ofNullable(ochSignal);
        return ImmutableList.of(createIntent(intent, found.get().getKey(), ochSignal));
    } else {
        log.error("Unable to find suitable lightpath for intent {}", intent);
        throw new OpticalIntentCompilationException("Unable to find suitable lightpath for intent " + intent);
    }
}
#method_after
@Override
public List<Intent> compile(OpticalConnectivityIntent intent, List<Intent> installable) {
    // Check if source and destination are optical OCh ports
    ConnectPoint src = intent.getSrc();
    ConnectPoint dst = intent.getDst();
    checkArgument(deviceService.getPort(src.deviceId(), src.port()) instanceof OchPort);
    checkArgument(deviceService.getPort(dst.deviceId(), dst.port()) instanceof OchPort);
    List<Resource> resources = new LinkedList<>();
    log.debug("Compiling optical connectivity intent between {} and {}", src, dst);
    // Release of intent resources here is only a temporary solution for handling the
    // case of recompiling due to intent restoration (when intent state is FAILED).
    // TODO: try to release intent resources in IntentManager.
    resourceService.release(intent.key());
    // Check OCh port availability
    // If ports are not available, compilation fails
    // Else add port to resource reservation list
    Resource srcPortResource = Resources.discrete(src.deviceId(), src.port()).resource();
    Resource dstPortResource = Resources.discrete(dst.deviceId(), dst.port()).resource();
    if (!Stream.of(srcPortResource, dstPortResource).allMatch(resourceService::isAvailable)) {
        log.error("Ports for the intent are not available. Intent: {}", intent);
        throw new OpticalIntentCompilationException("Ports for the intent are not available. Intent: " + intent);
    }
    resources.add(srcPortResource);
    resources.add(dstPortResource);
    // If there is a suggestedPath, use this path without further checking, otherwise trigger path computation
    Stream<Path> paths;
    if (intent.suggestedPath().isPresent()) {
        paths = Stream.of(intent.suggestedPath().get());
    } else {
        paths = getOpticalPaths(intent);
    }
    // Find first path that has the required resources
    Optional<Map.Entry<Path, List<OchSignal>>> found = paths.map(path -> Maps.immutableEntry(path, findFirstAvailableLambda(intent, path))).filter(entry -> !entry.getValue().isEmpty()).filter(entry -> convertToResources(entry.getKey(), entry.getValue()).stream().allMatch(resourceService::isAvailable)).findFirst();
    // Allocate resources and create optical path intent
    if (found.isPresent()) {
        resources.addAll(convertToResources(found.get().getKey(), found.get().getValue()));
        allocateResources(intent, resources);
        OchSignal ochSignal = OchSignal.toFixedGrid(found.get().getValue(), ChannelSpacing.CHL_50GHZ);
        return ImmutableList.of(createIntent(intent, found.get().getKey(), ochSignal));
    } else {
        log.error("Unable to find suitable lightpath for intent {}", intent);
        throw new OpticalIntentCompilationException("Unable to find suitable lightpath for intent " + intent);
    }
}
#end_block

#method_before
private Stream<Path> getOpticalPaths(OpticalConnectivityIntent intent) {
    // Route in WDM topology
    Topology topology = topologyService.currentTopology();
    // TODO: refactor with LinkWeigher class Implementation
    LinkWeigher weight = new LinkWeigher() {

        @Override
        public Weight getInitialWeight() {
            return ScalarWeight.toWeight(0.0);
        }

        @Override
        public Weight getNonViableWeight() {
            return ScalarWeight.NON_VIABLE_WEIGHT;
        }

        /**
         * @param edge edge to be weighed
         * @return the metric retrieved from the annotations otherwise 1
         */
        @Override
        public Weight weight(TopologyEdge edge) {
            log.info("Link {} metric {}", edge.link(), edge.link().annotations().value("metric"));
            // Disregard inactive or non-optical links
            if (edge.link().state() == Link.State.INACTIVE) {
                return ScalarWeight.toWeight(-1);
            }
            if (edge.link().type() != Link.Type.OPTICAL) {
                return ScalarWeight.toWeight(-1);
            }
            // Adhere to static port mappings
            DeviceId srcDeviceId = edge.link().src().deviceId();
            if (srcDeviceId.equals(intent.getSrc().deviceId())) {
                ConnectPoint srcStaticPort = staticPort(intent.getSrc());
                if (srcStaticPort != null) {
                    return ScalarWeight.toWeight(srcStaticPort.equals(edge.link().src()) ? 1 : -1);
                }
            }
            DeviceId dstDeviceId = edge.link().dst().deviceId();
            if (dstDeviceId.equals(intent.getDst().deviceId())) {
                ConnectPoint dstStaticPort = staticPort(intent.getDst());
                if (dstStaticPort != null) {
                    return ScalarWeight.toWeight(dstStaticPort.equals(edge.link().dst()) ? 1 : -1);
                }
            }
            String metricString = edge.link().annotations().value("metric");
            if (!metricString.isEmpty()) {
                double metric = Double.parseDouble(metricString);
                return ScalarWeight.toWeight(metric);
            } else {
                return ScalarWeight.toWeight(1);
            }
        }
    };
    ConnectPoint start = intent.getSrc();
    ConnectPoint end = intent.getDst();
    // 0 hop case
    if (start.deviceId().equals(end.deviceId())) {
        log.debug("install optical intent for 0 hop i.e srcDeviceId=dstDeviceId");
        DefaultLink defaultLink = DefaultLink.builder().providerId(PROVIDER_ID).src(start).dst(end).state(Link.State.ACTIVE).type(Link.Type.DIRECT).isExpected(true).build();
        List<Link> links = ImmutableList.<Link>builder().add(defaultLink).build();
        Annotations annotations = DefaultAnnotations.builder().build();
        DefaultPath defaultPath = new DefaultPath(PROVIDER_ID, links, null, annotations);
        return ImmutableList.<Path>builder().add(defaultPath).build().stream();
    }
    // head link's src port should be same as intent src port and tail link dst port
    // should be same as intent dst port in the path.
    Stream<Path> paths = topologyService.getKShortestPaths(topology, start.deviceId(), end.deviceId(), weight).filter(p -> p.links().get(0).src().port().equals(start.port()) && p.links().get(p.links().size() - 1).dst().port().equals(end.port()));
    if (log.isDebugEnabled()) {
        return paths.map(path -> {
            // no-op map stage to add debug logging
            log.debug("Candidate path: {}", path.links().stream().map(lk -> lk.src() + "-" + lk.dst()).collect(Collectors.toList()));
            return path;
        });
    }
    return paths;
}
#method_after
private Stream<Path> getOpticalPaths(OpticalConnectivityIntent intent) {
    // Route in WDM topology
    Topology topology = topologyService.currentTopology();
    // TODO: refactor with LinkWeigher class Implementation
    LinkWeigher weight = new LinkWeigher() {

        @Override
        public Weight getInitialWeight() {
            return ScalarWeight.toWeight(0.0);
        }

        @Override
        public Weight getNonViableWeight() {
            return ScalarWeight.NON_VIABLE_WEIGHT;
        }

        /**
         * @param edge edge to be weighed
         * @return the metric retrieved from the annotations otherwise 1
         */
        @Override
        public Weight weight(TopologyEdge edge) {
            log.debug("Link {} metric {}", edge.link(), edge.link().annotations().value("metric"));
            // Disregard inactive or non-optical links
            if (edge.link().state() == Link.State.INACTIVE) {
                return ScalarWeight.toWeight(-1);
            }
            if (edge.link().type() != Link.Type.OPTICAL) {
                return ScalarWeight.toWeight(-1);
            }
            // Adhere to static port mappings
            DeviceId srcDeviceId = edge.link().src().deviceId();
            if (srcDeviceId.equals(intent.getSrc().deviceId())) {
                ConnectPoint srcStaticPort = staticPort(intent.getSrc());
                if (srcStaticPort != null) {
                    return ScalarWeight.toWeight(srcStaticPort.equals(edge.link().src()) ? 1 : -1);
                }
            }
            DeviceId dstDeviceId = edge.link().dst().deviceId();
            if (dstDeviceId.equals(intent.getDst().deviceId())) {
                ConnectPoint dstStaticPort = staticPort(intent.getDst());
                if (dstStaticPort != null) {
                    return ScalarWeight.toWeight(dstStaticPort.equals(edge.link().dst()) ? 1 : -1);
                }
            }
            String metricString = edge.link().annotations().value("metric");
            if (!metricString.isEmpty()) {
                double metric = Double.parseDouble(metricString);
                return ScalarWeight.toWeight(metric);
            } else {
                return ScalarWeight.toWeight(1);
            }
        }
    };
    ConnectPoint start = intent.getSrc();
    ConnectPoint end = intent.getDst();
    // 0 hop case
    if (start.deviceId().equals(end.deviceId())) {
        log.debug("install optical intent for 0 hop i.e srcDeviceId=dstDeviceId");
        DefaultLink defaultLink = DefaultLink.builder().providerId(PROVIDER_ID).src(start).dst(end).state(Link.State.ACTIVE).type(Link.Type.DIRECT).isExpected(true).build();
        List<Link> links = ImmutableList.<Link>builder().add(defaultLink).build();
        Annotations annotations = DefaultAnnotations.builder().build();
        DefaultPath defaultPath = new DefaultPath(PROVIDER_ID, links, null, annotations);
        return ImmutableList.<Path>builder().add(defaultPath).build().stream();
    }
    // head link's src port should be same as intent src port and tail link dst port
    // should be same as intent dst port in the path.
    Stream<Path> paths = topologyService.getKShortestPaths(topology, start.deviceId(), end.deviceId(), weight).filter(p -> p.links().get(0).src().port().equals(start.port()) && p.links().get(p.links().size() - 1).dst().port().equals(end.port()));
    if (log.isDebugEnabled()) {
        return paths.map(path -> {
            // no-op map stage to add debug logging
            log.debug("Candidate path: {}", path.links().stream().map(lk -> lk.src() + "-" + lk.dst()).collect(Collectors.toList()));
            return path;
        });
    }
    return paths;
}
#end_block

#method_before
private void installPath(IpAddress mcastIp, ConnectPoint source, Path mcastPath) {
    List<Link> links = mcastPath.links();
    if (links == null || links.isEmpty()) {
        log.warn("There is no one link can be proceed.");
        return;
    }
    // Setup new ingress mcast role
    mcastRoleStore.put(new McastRoleStoreKey(mcastIp, links.get(0).src().deviceId(), source), INGRESS);
    // For each link, modify the next on the source device adding the src port
    // and a new filter objective on the destination port
    links.forEach(link -> {
        addPortToDevice(link.src().deviceId(), link.src().port(), mcastIp, mcastUtils.assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
        mcastUtils.addFilterToDevice(link.dst().deviceId(), link.dst().port(), mcastUtils.assignedVlan(null), mcastIp, null);
    });
    // Setup mcast role for the transit
    links.stream().filter(link -> !link.src().deviceId().equals(source.deviceId())).forEach(link -> mcastRoleStore.put(new McastRoleStoreKey(mcastIp, link.src().deviceId(), source), TRANSIT));
}
#method_after
private void installPath(IpAddress mcastIp, ConnectPoint source, Path mcastPath) {
    List<Link> links = mcastPath.links();
    if (links.isEmpty()) {
        log.warn("There is no link that can be used. Stopping installation.");
        return;
    }
    // Setup new ingress mcast role
    mcastRoleStore.put(new McastRoleStoreKey(mcastIp, links.get(0).src().deviceId(), source), INGRESS);
    // For each link, modify the next on the source device adding the src port
    // and a new filter objective on the destination port
    links.forEach(link -> {
        addPortToDevice(link.src().deviceId(), link.src().port(), mcastIp, mcastUtils.assignedVlan(link.src().deviceId().equals(source.deviceId()) ? source : null));
        mcastUtils.addFilterToDevice(link.dst().deviceId(), link.dst().port(), mcastUtils.assignedVlan(null), mcastIp, null);
    });
    // Setup mcast role for the transit
    links.stream().filter(link -> !link.src().deviceId().equals(source.deviceId())).forEach(link -> mcastRoleStore.put(new McastRoleStoreKey(mcastIp, link.src().deviceId(), source), TRANSIT));
}
#end_block

#method_before
@Override
public void hostDetected(HostId hostId, HostDescription hostDescription, boolean replaceIps) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    hostDescription = validateHost(hostDescription, hostId);
    if (!allowDuplicateIps) {
        removeDuplicates(hostId, hostDescription);
    }
    store.createOrUpdateHost(provider().id(), hostId, hostDescription, replaceIps);
    if (monitorHosts) {
        hostDescription.ipAddress().forEach(ip -> {
            monitor.addMonitoringFor(ip);
        });
    }
    // overwrite the learnt information with the configured information.
    if (greedyLearningIpv6) {
        // Auto-generation of the IPv6 link local address
        // using the mac address
        Ip6Address targetIp6Address = Ip6Address.valueOf(getLinkLocalAddress(hostId.mac().toBytes()));
        // If we already know this guy we don't need to do other
        if (!hostDescription.ipAddress().contains(targetIp6Address)) {
            Host host = store.getHost(hostId);
            // Configured host, skip it.
            if (host != null && host.configured()) {
                return;
            }
            // Host does not exist in the store or the target is not known
            if ((host == null || !host.ipAddresses().contains(targetIp6Address))) {
                // Use DAD to probe if interface MAC is not specified
                MacAddress probeMac = interfaceService.getInterfacesByPort(hostDescription.location()).stream().map(Interface::mac).findFirst().orElse(MacAddress.ONOS);
                Ip6Address probeIp = !probeMac.equals(MacAddress.ONOS) ? Ip6Address.valueOf(getLinkLocalAddress(probeMac.toBytes())) : Ip6Address.ZERO;
                // We send a probe using the monitoring service
                monitor.sendProbe(hostDescription.location(), targetIp6Address, probeIp, probeMac, hostId.vlanId());
            }
        }
    }
}
#method_after
@Override
public void hostDetected(HostId hostId, HostDescription hostDescription, boolean replaceIps) {
    checkNotNull(hostId, HOST_ID_NULL);
    checkValidity();
    hostDescription = validateHost(hostDescription, hostId);
    if (!allowDuplicateIps) {
        removeDuplicates(hostId, hostDescription);
    }
    BasicHostConfig cfg = networkConfigService.getConfig(hostId, BasicHostConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Host {} is not allowed to be added into the contol domain", hostId);
        return;
    }
    hostDescription = BasicHostOperator.combine(cfg, hostDescription);
    HostAnnotationConfig annoConfig = networkConfigService.getConfig(hostId, HostAnnotationConfig.class);
    if (annoConfig != null) {
        hostDescription = hostAnnotationOperator.combine(hostId, hostDescription, Optional.of(annoConfig));
    }
    store.createOrUpdateHost(provider().id(), hostId, hostDescription, replaceIps);
    if (monitorHosts) {
        hostDescription.ipAddress().forEach(ip -> {
            monitor.addMonitoringFor(ip);
        });
    }
    // overwrite the learnt information with the configured information.
    if (greedyLearningIpv6) {
        // Auto-generation of the IPv6 link local address
        // using the mac address
        Ip6Address targetIp6Address = Ip6Address.valueOf(getLinkLocalAddress(hostId.mac().toBytes()));
        // If we already know this guy we don't need to do other
        if (!hostDescription.ipAddress().contains(targetIp6Address)) {
            Host host = store.getHost(hostId);
            // Configured host, skip it.
            if (host != null && host.configured()) {
                return;
            }
            // Host does not exist in the store or the target is not known
            if ((host == null || !host.ipAddresses().contains(targetIp6Address))) {
                // Use DAD to probe if interface MAC is not specified
                MacAddress probeMac = interfaceService.getInterfacesByPort(hostDescription.location()).stream().map(Interface::mac).findFirst().orElse(MacAddress.ONOS);
                Ip6Address probeIp = !probeMac.equals(MacAddress.ONOS) ? Ip6Address.valueOf(getLinkLocalAddress(probeMac.toBytes())) : Ip6Address.ZERO;
                // We send a probe using the monitoring service
                monitor.sendProbe(hostDescription.location(), targetIp6Address, probeIp, probeMac, hostId.vlanId());
            }
        }
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    log.debug("Detected host network config event {}", event.type());
    HostEvent he = null;
    HostId hostId = (HostId) event.subject();
    BasicHostConfig cfg = networkConfigService.getConfig(hostId, BasicHostConfig.class);
    if (!isAllowed(cfg)) {
        kickOutBadHost(hostId);
    } else if (event.configClass().equals(BasicHostConfig.class)) {
        Host host = getHost(hostId);
        HostDescription desc = (host == null) ? null : BasicHostOperator.descriptionOf(host);
        desc = BasicHostOperator.combine(cfg, desc);
        if (desc != null) {
            he = store.createOrUpdateHost(host.providerId(), hostId, desc, false);
        }
    } else if (event.configClass().equals(HostAnnotationConfig.class)) {
        Host host = getHost(hostId);
        HostProvider hp = getProvider(host.providerId());
        HostDescription desc = (host == null) ? null : BasicHostOperator.descriptionOf(host);
        Optional<Config> prevConfig = event.prevConfig();
        log.info("Host annotations: {} prevconfig {} desc {}", hostId, prevConfig, desc);
        desc = hostAnnotationOperator.combine(hostId, desc, prevConfig);
        if (desc != null && hp != null) {
            log.info("Host annotations update - updated host description :{}", desc.toString());
            he = store.createOrUpdateHost(hp.id(), hostId, desc, false);
            if (he != null && he.subject() != null) {
                log.info("Host annotations update - Host Event : {}", he.subject().annotations());
            }
        }
    }
    if (he != null) {
        post(he);
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    log.debug("Detected host network config event {}", event.type());
    HostEvent he = null;
    HostId hostId = (HostId) event.subject();
    BasicHostConfig cfg = networkConfigService.getConfig(hostId, BasicHostConfig.class);
    if (!isAllowed(cfg)) {
        kickOutBadHost(hostId);
    } else if (event.configClass().equals(BasicHostConfig.class)) {
        Host host = getHost(hostId);
        HostDescription desc = (host == null) ? null : BasicHostOperator.descriptionOf(host);
        desc = BasicHostOperator.combine(cfg, desc);
        if (desc != null) {
            he = store.createOrUpdateHost(host.providerId(), hostId, desc, false);
        }
    } else if (event.configClass().equals(HostAnnotationConfig.class)) {
        Host host = getHost(hostId);
        HostProvider hp = getProvider(host.providerId());
        HostDescription desc = (host == null) ? null : BasicHostOperator.descriptionOf(host);
        Optional<Config> prevConfig = event.prevConfig();
        log.debug("Host annotations: {} prevconfig {} desc {}", hostId, prevConfig, desc);
        desc = hostAnnotationOperator.combine(hostId, desc, prevConfig);
        if (desc != null && hp != null) {
            log.debug("Host annotations update - updated host description :{}", desc.toString());
            he = store.createOrUpdateHost(hp.id(), hostId, desc, false);
            if (he != null && he.subject() != null) {
                log.debug("Host annotations update - Host Event : {}", he.subject().annotations());
            }
        }
    }
    if (he != null) {
        post(he);
    }
}
#end_block

#method_before
@Override
protected void doExecute() {
    NetworkConfigService netcfgService = get(NetworkConfigService.class);
    HostId hostId = HostId.hostId(uri);
    if (key == null) {
        print("[ERROR] Annotation key not specified.");
        return;
    }
    HostAnnotationConfig cfg = netcfgService.getConfig(hostId, HostAnnotationConfig.class);
    if (cfg == null) {
        cfg = new HostAnnotationConfig(hostId);
    }
    if (removeCfg) {
        // remove config about entry
        cfg.annotation(key);
    } else {
        // add remove request config
        cfg.annotation(key, value);
    }
    netcfgService.applyConfig(hostId, HostAnnotationConfig.class, cfg.node());
}
#method_after
@Override
protected void doExecute() {
    NetworkConfigService netcfgService = get(NetworkConfigService.class);
    HostId hostId = HostId.hostId(uri);
    if (key == null) {
        print("[ERROR] Annotation key not specified.");
        return;
    }
    HostAnnotationConfig cfg = netcfgService.getConfig(hostId, HostAnnotationConfig.class);
    if (cfg == null) {
        cfg = new HostAnnotationConfig(hostId);
    }
    if (removeCfg) {
        // remove config about entry
        cfg.annotation(key);
    } else {
        // add request config
        cfg.annotation(key, value);
    }
    netcfgService.applyConfig(hostId, HostAnnotationConfig.class, cfg.node());
}
#end_block

#method_before
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    Map<String, DefaultPortStatistics.Builder> portStatistics = Maps.newHashMap();
    Map<String, PortNumber> ifacePortNumberMapping = Maps.newHashMap();
    List<Port> ports = deviceService.getPorts(deviceId);
    GetRequest.Builder getRequest = GetRequest.newBuilder();
    getRequest.setEncoding(Gnmi.Encoding.PROTO);
    // Use this path to get all counters from specific interface(port)
    // /interfaces/interface[port-name]/state/counters/[counter name]
    ports.forEach(port -> {
        String portName = port.number().name();
        Path path = interfaceCounterPath(portName);
        getRequest.addPath(path);
        ifacePortNumberMapping.put(portName, port.number());
    });
    GetResponse getResponse = getFutureWithDeadline(client.get(getRequest.build()), "getting port counters", GetResponse.getDefaultInstance());
    getResponse.getNotificationList().forEach(notification -> {
        AtomicLong inPkts = new AtomicLong(0);
        AtomicLong outPkts = new AtomicLong(0);
        notification.getUpdateList().forEach(update -> {
            Path path = update.getPath();
            String interfaceName = interfaceNameFromPath(path);
            // Last element is the counter name
            String counterName = path.getElem(path.getElemCount() - 1).getName();
            long counterValue = update.getVal().getUintVal();
            portStatistics.putIfAbsent(interfaceName, DefaultPortStatistics.builder());
            DefaultPortStatistics.Builder portStatsBuilder = portStatistics.get(interfaceName);
            portStatsBuilder.setDeviceId(deviceId);
            PortNumber portNumber = ifacePortNumberMapping.get(interfaceName);
            portStatsBuilder.setPort(portNumber);
            portStatsBuilder.setDurationSec(getDuration(portNumber));
            switch(counterName) {
                case "in-octets":
                    portStatsBuilder.setBytesReceived(counterValue);
                    break;
                case "out-octets":
                    portStatsBuilder.setBytesSent(counterValue);
                    break;
                case "in-discards":
                    portStatsBuilder.setPacketsRxDropped(counterValue);
                    break;
                case "out-discards":
                    portStatsBuilder.setPacketsTxDropped(counterValue);
                    break;
                case "in-errors":
                    portStatsBuilder.setPacketsRxErrors(counterValue);
                    break;
                case "out-errors":
                    portStatsBuilder.setPacketsTxErrors(counterValue);
                    break;
                case "in-unicast-pkts":
                case "in-broadcast-pkts":
                case "in-multicast-pkts":
                    portStatsBuilder.setPacketsReceived(inPkts.addAndGet(counterValue));
                    break;
                case "out-unicast-pkts":
                case "out-broadcast-pkts":
                case "out-multicast-pkts":
                    portStatsBuilder.setPacketsSent(outPkts.addAndGet(counterValue));
                    break;
                default:
                    log.debug("Unsupported counter name {}, ignored", counterName);
                    break;
            }
        });
    });
    return portStatistics.values().stream().map(DefaultPortStatistics.Builder::build).collect(Collectors.toList());
}
#method_after
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    Map<String, DefaultPortStatistics.Builder> portStatistics = Maps.newHashMap();
    Map<String, PortNumber> ifacePortNumberMapping = Maps.newHashMap();
    List<Port> ports = deviceService.getPorts(deviceId);
    GetRequest.Builder getRequest = GetRequest.newBuilder();
    getRequest.setEncoding(Gnmi.Encoding.PROTO);
    // Use this path to get all counters from specific interface(port)
    // /interfaces/interface[port-name]/state/counters/[counter name]
    ports.forEach(port -> {
        String portName = port.number().name();
        Path path = interfaceCounterPath(portName);
        getRequest.addPath(path);
        ifacePortNumberMapping.put(portName, port.number());
    });
    GetResponse getResponse = getFutureWithDeadline(client.get(getRequest.build()), "getting port counters", GetResponse.getDefaultInstance());
    Map<String, Long> inPkts = Maps.newHashMap();
    Map<String, Long> outPkts = Maps.newHashMap();
    Map<String, Long> inBytes = Maps.newHashMap();
    Map<String, Long> outBytes = Maps.newHashMap();
    Map<String, Long> inDropped = Maps.newHashMap();
    Map<String, Long> outDropped = Maps.newHashMap();
    Map<String, Long> inErrors = Maps.newHashMap();
    Map<String, Long> outErrors = Maps.newHashMap();
    Map<String, Duration> timestamps = Maps.newHashMap();
    // Collect responses and sum {in,out,dropped} packets
    getResponse.getNotificationList().forEach(notification -> {
        notification.getUpdateList().forEach(update -> {
            Path path = update.getPath();
            String ifName = interfaceNameFromPath(path);
            timestamps.putIfAbsent(ifName, Duration.ofNanos(notification.getTimestamp()));
            // Last element is the counter name
            String counterName = path.getElem(path.getElemCount() - 1).getName();
            long counterValue = update.getVal().getUintVal();
            switch(counterName) {
                case "in-octets":
                    inBytes.put(ifName, counterValue);
                    break;
                case "out-octets":
                    outBytes.put(ifName, counterValue);
                    break;
                case "in-discards":
                case "in-fcs-errors":
                    inDropped.compute(ifName, (k, v) -> v == null ? counterValue : v + counterValue);
                    break;
                case "out-discards":
                    outDropped.put(ifName, counterValue);
                    break;
                case "in-errors":
                    inErrors.put(ifName, counterValue);
                    break;
                case "out-errors":
                    outErrors.put(ifName, counterValue);
                    break;
                case "in-unicast-pkts":
                case "in-broadcast-pkts":
                case "in-multicast-pkts":
                case "in-unknown-protos":
                    inPkts.compute(ifName, (k, v) -> v == null ? counterValue : v + counterValue);
                    break;
                case "out-unicast-pkts":
                case "out-broadcast-pkts":
                case "out-multicast-pkts":
                    outPkts.compute(ifName, (k, v) -> v == null ? counterValue : v + counterValue);
                    break;
                default:
                    log.warn("Unsupported counter name {}, ignored", counterName);
                    break;
            }
        });
    });
    // Build ONOS port stats map
    return ifacePortNumberMapping.entrySet().stream().map(e -> {
        String ifName = e.getKey();
        PortNumber portNumber = e.getValue();
        Duration portActive = getDurationActive(portNumber, timestamps.get(ifName));
        return DefaultPortStatistics.builder().setDeviceId(deviceId).setPort(portNumber).setDurationSec(portActive.getSeconds()).setDurationNano(portActive.getNano()).setPacketsSent(outPkts.getOrDefault(ifName, 0L)).setPacketsReceived(inPkts.getOrDefault(ifName, 0L)).setPacketsTxDropped(outDropped.getOrDefault(ifName, 0L)).setPacketsRxDropped(inDropped.getOrDefault(ifName, 0L)).setBytesSent(outBytes.getOrDefault(ifName, 0L)).setBytesReceived(inBytes.getOrDefault(ifName, 0L)).setPacketsTxErrors(outErrors.getOrDefault(ifName, 0L)).setPacketsRxErrors(inErrors.getOrDefault(ifName, 0L)).build();
    }).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> subscribe(SubscribeRequest request) {
    return supplyInContext(() -> streamChannelManager.send(request), "subscribe");
}
#method_after
@Override
public boolean subscribe(SubscribeRequest request) {
    return streamChannelManager.send(request);
}
#end_block

#method_before
public boolean send(SubscribeRequest value) {
    synchronized (this) {
        initIfRequired();
        try {
            requestObserver.onNext(value);
            // signalOpen();
            return true;
        } catch (Throwable ex) {
            if (ex instanceof StatusRuntimeException) {
                log.warn("Unable to send {} to {}: {}", value.toString(), deviceId, ex.getMessage());
            } else {
                log.warn(format("Exception while sending %s to %s", value.toString(), deviceId), ex);
            }
            complete();
            return false;
        }
    }
}
#method_after
public boolean send(SubscribeRequest value) {
    synchronized (this) {
        initIfRequired();
        try {
            requestObserver.onNext(value);
            // signalOpen();
            return true;
        } catch (Throwable ex) {
            if (ex instanceof StatusRuntimeException) {
                log.warn("Unable to send subscribe request to {}: {}", deviceId, ex.getMessage());
            } else {
                log.warn(format("Exception while sending subscribe request to %s", deviceId), ex);
            }
            complete();
            return false;
        }
    }
}
#end_block

#method_before
public void complete() {
    synchronized (this) {
        signalClosed();
        if (requestObserver != null) {
            requestObserver.onCompleted();
            requestObserver.cancel("Terminated", null);
            requestObserver = null;
        }
    }
}
#method_after
public void complete() {
    synchronized (this) {
        if (requestObserver != null) {
            requestObserver.onCompleted();
            requestObserver.cancel("Terminated", null);
            requestObserver = null;
        }
    }
}
#end_block

#method_before
@Override
public void onNext(SubscribeResponse message) {
    streamChannelManager.signalOpen();
    executorService.submit(() -> doNext(message));
}
#method_after
@Override
public void onNext(SubscribeResponse message) {
    executorService.submit(() -> doNext(message));
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    connectionExecutor = newFixedThreadPool(CORE_POOL_SIZE, groupedThreads("onos/gdp-connect", "%d", log));
    statsExecutor = newScheduledThreadPool(CORE_POOL_SIZE, groupedThreads("onos/gdp-stats", "%d", log));
    probeExecutor = newSingleThreadScheduledExecutor(groupedThreads("onos/gdp-probe", "%d", log));
    providerService = providerRegistry.register(this);
    componentConfigService.registerProperties(getClass());
    coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgListener);
    deviceService.addListener(deviceListener);
    pipeconfWatchdogService.addListener(pipeconfWatchdogListener);
    rescheduleProbeTask(false);
    modified(context);
    gnmiDeviceStateSubscriber = new GnmiDeviceStateSubscriber(gnmiController, deviceService, providerService);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    connectionExecutor = newFixedThreadPool(CORE_POOL_SIZE, groupedThreads("onos/gdp-connect", "%d", log));
    statsExecutor = newScheduledThreadPool(CORE_POOL_SIZE, groupedThreads("onos/gdp-stats", "%d", log));
    probeExecutor = newSingleThreadScheduledExecutor(groupedThreads("onos/gdp-probe", "%d", log));
    providerService = providerRegistry.register(this);
    componentConfigService.registerProperties(getClass());
    coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgListener);
    deviceService.addListener(deviceListener);
    pipeconfWatchdogService.addListener(pipeconfWatchdogListener);
    rescheduleProbeTask(false);
    modified(context);
    gnmiDeviceStateSubscriber = new GnmiDeviceStateSubscriber(gnmiController, deviceService, mastershipService, providerService);
    log.info("Started");
}
#end_block

#method_before
private void doAdvertiseDevice(DeviceId deviceId) {
    // Retrieve config
    if (configIsMissing(deviceId)) {
        return;
    }
    // Obtain device and port description.
    final boolean isPipelineReady = isPipelineReady(deviceId);
    final DeviceDescription description = getDeviceDescription(deviceId, isPipelineReady);
    final List<PortDescription> ports = getPortDetails(deviceId);
    // Advertise to core.
    if (deviceService.getDevice(deviceId) == null || (description.isDefaultAvailable() && !deviceService.isAvailable(deviceId))) {
        if (!isPipelineReady) {
            log.info("Advertising device to core with available={} as " + "device pipeline is not ready yet", description.isDefaultAvailable());
        }
        providerService.deviceConnected(deviceId, description);
    }
    providerService.updatePorts(deviceId, ports);
    gnmiDeviceStateSubscriber.addDevice(deviceId);
    // If pipeline is not ready, encourage watchdog to perform probe ASAP.
    if (!isPipelineReady) {
        pipeconfWatchdogService.triggerProbe(deviceId);
    }
}
#method_after
private void doAdvertiseDevice(DeviceId deviceId) {
    // Retrieve config
    if (configIsMissing(deviceId)) {
        return;
    }
    // Obtain device and port description.
    final boolean isPipelineReady = isPipelineReady(deviceId);
    final DeviceDescription description = getDeviceDescription(deviceId, isPipelineReady);
    final List<PortDescription> ports = getPortDetails(deviceId);
    // Advertise to core.
    if (deviceService.getDevice(deviceId) == null || (description.isDefaultAvailable() && !deviceService.isAvailable(deviceId))) {
        if (!isPipelineReady) {
            log.info("Advertising device to core with available={} as " + "device pipeline is not ready yet", description.isDefaultAvailable());
        }
        providerService.deviceConnected(deviceId, description);
    }
    providerService.updatePorts(deviceId, ports);
    // If pipeline is not ready, encourage watchdog to perform probe ASAP.
    if (!isPipelineReady) {
        pipeconfWatchdogService.triggerProbe(deviceId);
    }
}
#end_block

#method_before
public void deactivate() {
    deviceScribed.clear();
    gnmiController.removeListener(gnmiEventListener);
}
#method_after
public void deactivate() {
    deviceSubscribed.clear();
    deviceService.removeListener(deviceEventListener);
    mastershipService.removeListener(mastershopListener);
    gnmiController.removeListener(gnmiEventListener);
}
#end_block

#method_before
private void handleGnmiUpdate(GnmiUpdate eventSubject) {
    Notification notification = eventSubject.update();
    if (notification == null) {
        log.warn("Cannot handle gNMI event without update data, abort");
        log.debug("gNMI update:\n{}", eventSubject);
        return;
    }
    List<Update> updateList = notification.getUpdateList();
    updateList.forEach(update -> {
        Path path = update.getPath();
        PathElem lastElem = path.getElem(path.getElemCount() - 1);
        // Use last element to identify which state updated
        if (lastElem.getName().equals("oper-status")) {
            handleOperStatusUpdate(eventSubject.deviceId(), update);
        }
    });
}
#method_after
private void handleGnmiUpdate(GnmiUpdate eventSubject) {
    Notification notification = eventSubject.update();
    if (notification == null) {
        log.warn("Cannot handle gNMI event without update data, abort");
        log.debug("gNMI update:\n{}", eventSubject);
        return;
    }
    List<Update> updateList = notification.getUpdateList();
    updateList.forEach(update -> {
        Path path = update.getPath();
        PathElem lastElem = path.getElem(path.getElemCount() - 1);
        // Use last element to identify which state updated
        switch(lastElem.getName()) {
            case "oper-status":
                handleOperStatusUpdate(eventSubject.deviceId(), update);
                break;
            default:
                log.debug("Unrecognized update {}", GnmiUtils.pathToString(path));
        }
    });
}
#end_block

#method_before
private void handleOperStatusUpdate(DeviceId deviceId, Update update) {
    Path path = update.getPath();
    // first element should be "interface"
    String interfaceName = path.getElem(1).getKeyOrDefault("name", null);
    if (interfaceName == null) {
        log.error("No interface present in gNMI update, abort");
        log.debug("gNMI update:\n{}", update);
        return;
    }
    List<Port> portsFromDevice = deviceService.getPorts(deviceId);
    portsFromDevice.forEach(port -> {
        if (!port.number().name().equals(interfaceName)) {
            return;
        }
        // Port/Interface name is identical in OpenConfig model, but not in ONOS
        // This might cause some problem if we use one name to different port
        PortDescription portDescription = DefaultPortDescription.builder().portSpeed(port.portSpeed()).withPortNumber(port.number()).isEnabled(update.getVal().getStringVal().equals("UP")).type(port.type()).annotations((SparseAnnotations) port.annotations()).build();
        deviceProviderService.portStatusChanged(deviceId, portDescription);
    });
}
#method_after
private void handleOperStatusUpdate(DeviceId deviceId, Update update) {
    Path path = update.getPath();
    // first element should be "interface"
    String interfaceName = path.getElem(1).getKeyOrDefault("name", null);
    if (interfaceName == null) {
        log.error("No interface present in gNMI update, abort");
        log.debug("gNMI update:\n{}", update);
        return;
    }
    List<Port> portsFromDevice = deviceService.getPorts(deviceId);
    portsFromDevice.forEach(port -> {
        if (!port.number().name().equals(interfaceName)) {
            return;
        }
        // Port/Interface name is identical in OpenConfig model, but not in ONOS
        // This might cause some problem if we use one name to different port
        PortDescription portDescription = DefaultPortDescription.builder().portSpeed(port.portSpeed()).withPortNumber(port.number()).isEnabled(update.getVal().getStringVal().equals("UP")).type(port.type()).annotations((SparseAnnotations) port.annotations()).build();
        providerService.portStatusChanged(deviceId, portDescription);
    });
}
#end_block

#method_before
@Override
public boolean isRelevant(GnmiEvent event) {
    return deviceScribed.contains(event.subject().deviceId());
}
#method_after
@Override
public boolean isRelevant(GnmiEvent event) {
    return deviceSubscribed.contains(event.subject().deviceId());
}
#end_block

#method_before
public boolean handleLldp(PacketContext packetContext) {
    Ethernet eth = packetContext.inPacket().parsed();
    if (eth == null) {
        return false;
    }
    ONOSLLDP onoslldp = ONOSLLDP.parseONOSLLDP(eth);
    if (onoslldp != null) {
        Type lt;
        if (notMy(eth.getSourceMAC().toString())) {
            lt = Type.EDGE;
        } else {
            lt = eth.getEtherType() == Ethernet.TYPE_LLDP ? Type.DIRECT : Type.INDIRECT;
            /* Verify MAC in LLDP packets */
            if (!ONOSLLDP.verify(onoslldp, context.lldpSecret(), context.maxDiscoveryDelay())) {
                log.warn("LLDP Packet failed to validate!");
                return true;
            }
        }
        PortNumber srcPort = portNumber(onoslldp.getPort());
        PortNumber dstPort = packetContext.inPacket().receivedFrom().port();
        String idString = onoslldp.getDeviceString();
        if (!isNullOrEmpty(idString)) {
            DeviceId srcDeviceId = DeviceId.deviceId(idString);
            DeviceId dstDeviceId = packetContext.inPacket().receivedFrom().deviceId();
            ConnectPoint src = new ConnectPoint(srcDeviceId, srcPort);
            ConnectPoint dst = new ConnectPoint(dstDeviceId, dstPort);
            LinkDescription ld = new DefaultLinkDescription(src, dst, lt);
            try {
                context.providerService().linkDetected(ld);
                context.touchLink(LinkKey.linkKey(src, dst));
            } catch (IllegalStateException e) {
                return true;
            }
            return true;
        }
    }
    return false;
}
#method_after
public boolean handleLldp(PacketContext packetContext) {
    Ethernet eth = packetContext.inPacket().parsed();
    if (eth == null) {
        return false;
    }
    if (processOnosLldp(packetContext, eth)) {
        return true;
    }
    if (processLldp(packetContext, eth)) {
        return true;
    }
    ONOSLLDP lldp = ONOSLLDP.parseLLDP(eth);
    if (lldp == null) {
        log.debug("Cannot parse the packet. It seems that it is not the lldp or bsn packet.");
    } else {
        log.debug("LLDP packet is dropped due to there are no handlers that properly handle this packet: {}", lldp.toString());
    }
    return false;
}
#end_block

#method_before
private OutboundPacket createOutBoundLldp(Long portNumber, String portDesc) {
    if (portNumber == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(portNumber, portDesc);
    if (lldp == null) {
        return null;
    }
    ethPacket.setSourceMACAddress(context.fingerprint()).setPayload(lldp);
    return new DefaultOutboundPacket(deviceId, builder().setOutput(portNumber(portNumber)).build(), ByteBuffer.wrap(ethPacket.serialize()));
}
#method_after
private OutboundPacket createOutBoundLldp(Long portNumber, String portDesc) {
    if (portNumber == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(portNumber, portDesc);
    if (lldp == null) {
        log.warn("Cannot get link probe with portNumber {} and portDesc {} for {} at LLDP packet creation.", portNumber, portDesc, deviceId);
        return null;
    }
    ethPacket.setSourceMACAddress(context.fingerprint()).setPayload(lldp);
    return new DefaultOutboundPacket(deviceId, builder().setOutput(portNumber(portNumber)).build(), ByteBuffer.wrap(ethPacket.serialize()));
}
#end_block

#method_before
private OutboundPacket createOutBoundBddp(Long portNumber, String portDesc) {
    if (portNumber == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(portNumber, portDesc);
    if (lldp == null) {
        return null;
    }
    bddpEth.setSourceMACAddress(context.fingerprint()).setPayload(lldp);
    return new DefaultOutboundPacket(deviceId, builder().setOutput(portNumber(portNumber)).build(), ByteBuffer.wrap(bddpEth.serialize()));
}
#method_after
private OutboundPacket createOutBoundBddp(Long portNumber, String portDesc) {
    if (portNumber == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(portNumber, portDesc);
    if (lldp == null) {
        log.warn("Cannot get link probe with portNumber {} and portDesc {} for {} at BDDP packet creation.", portNumber, portDesc, deviceId);
        return null;
    }
    bddpEth.setSourceMACAddress(context.fingerprint()).setPayload(lldp);
    return new DefaultOutboundPacket(deviceId, builder().setOutput(portNumber(portNumber)).build(), ByteBuffer.wrap(bddpEth.serialize()));
}
#end_block

#method_before
private ONOSLLDP getLinkProbe(Long portNumber, String portDesc) {
    Device device = context.deviceService().getDevice(deviceId);
    if (device == null) {
        return null;
    }
    return ONOSLLDP.onosSecureLLDP(deviceId.toString(), device.chassisId(), portNumber.intValue(), portDesc, context.lldpSecret());
}
#method_after
private ONOSLLDP getLinkProbe(Long portNumber, String portDesc) {
    Device device = context.deviceService().getDevice(deviceId);
    if (device == null) {
        log.warn("Cannot find the device {}", deviceId);
        return null;
    }
    return ONOSLLDP.onosSecureLLDP(deviceId.toString(), device.chassisId(), portNumber.intValue(), portDesc, context.lldpSecret());
}
#end_block

#method_before
public static boolean isSip(Port port) {
    try {
        String portType = port.annotations().value(PORT_TYPE);
        OdtnDeviceDescriptionDiscovery.OdtnPortType odtnPortType = OdtnDeviceDescriptionDiscovery.OdtnPortType.fromValue(portType);
        return odtnPortType.value().equals(OdtnDeviceDescriptionDiscovery.OdtnPortType.CLIENT.value());
    } catch (Exception e) {
        // This can be the case where there is no annotation
        return false;
    }
}
#method_after
public static boolean isSip(Port port) {
    if (!port.annotations().keys().contains(PORT_TYPE)) {
        log.warn("No annotation of {} on port {}", PORT_TYPE, port);
        return false;
    }
    String portType = port.annotations().value(PORT_TYPE);
    OdtnDeviceDescriptionDiscovery.OdtnPortType odtnPortType = OdtnDeviceDescriptionDiscovery.OdtnPortType.fromValue(portType);
    return odtnPortType.value().equals(OdtnDeviceDescriptionDiscovery.OdtnPortType.CLIENT.value());
}
#end_block

#method_before
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    log.debug("OPENCONFIG: queried lambdas for port {}", port);
    if (false) {
        // Profile 1
        channelSpacing = ChannelSpacing.CHL_50GHZ;
        lambdaCount = 96;
        slotGranularity = 4;
        return super.queryLambdas(port);
    }
    if (true) {
        // Profile 2
        short lambdaCount = 96;
        // fixed grid lambdas of 50GHz width
        return IntStream.rangeClosed(1, lambdaCount).mapToObj(x -> OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, x)).collect(Collectors.toSet());
    }
    return ImmutableSet.of();
}
#method_after
@Override
public Set<OchSignal> queryLambdas(PortNumber port) {
    log.debug("OPENCONFIG: queried lambdas for port {}", port);
    // Profile 1
    channelSpacing = ChannelSpacing.CHL_50GHZ;
    lambdaCount = 96;
    slotGranularity = 4;
    return super.queryLambdas(port);
// Another option, commented until best option for transceiver tunability deduction is chosen Profile 2
// short lambdaCount = 96;
// // fixed grid lambdas of 50GHz width
// return IntStream.rangeClosed(1, lambdaCount)
// .mapToObj(x -> OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, x))
// .collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public Collection<FlowRule> applyFlowRules(Collection<FlowRule> rules) {
    NetconfSession session = getNetconfSession();
    if (session == null) {
        openConfigError("null session");
        return ImmutableList.of();
    }
    List<FlowRule> added = new ArrayList<>();
    for (FlowRule r : rules) {
        try {
            applyFlowRule(session, r);
        } catch (Exception e) {
            openConfigError("Error {}", e);
            continue;
        }
        connectionCache.add(did(), r);
        added.add(r);
    }
    openConfigLog("applyFlowRules added {}", added.size());
    return added;
}
#method_after
@Override
public Collection<FlowRule> applyFlowRules(Collection<FlowRule> rules) {
    NetconfSession session = getNetconfSession();
    if (session == null) {
        openConfigError("null session");
        return ImmutableList.of();
    }
    List<FlowRule> added = new ArrayList<>();
    for (FlowRule r : rules) {
        try {
            applyFlowRule(session, r);
        } catch (Exception e) {
            openConfigError("Error {}", e);
            continue;
        }
        getConnectionCache().add(did(), r);
        added.add(r);
    }
    openConfigLog("applyFlowRules added {}", added.size());
    return added;
}
#end_block

#method_before
@Override
public Collection<FlowEntry> getFlowEntries() {
    if (connectionCache.get(did()) == null) {
        return ImmutableList.of();
    }
    List<FlowEntry> entries = new ArrayList<>();
    for (FlowRule r : connectionCache.get(did())) {
        entries.add(new DefaultFlowEntry(r, FlowEntry.FlowEntryState.ADDED, 0, 0, 0));
    }
    return entries;
}
#method_after
@Override
public Collection<FlowEntry> getFlowEntries() {
    OpenConfigConnectionCache cache = getConnectionCache();
    if (cache.get(did()) == null) {
        return ImmutableList.of();
    }
    List<FlowEntry> entries = new ArrayList<>();
    for (FlowRule r : cache.get(did())) {
        entries.add(new DefaultFlowEntry(r, FlowEntry.FlowEntryState.ADDED, 0, 0, 0));
    }
    return entries;
}
#end_block

#method_before
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rules) {
    NetconfSession session = getNetconfSession();
    if (session == null) {
        openConfigError("null session");
        return ImmutableList.of();
    }
    List<FlowRule> removed = new ArrayList<>();
    for (FlowRule r : rules) {
        try {
            removeFlowRule(session, r);
        } catch (Exception e) {
            openConfigError("Error {}", e);
            continue;
        }
        connectionCache.add(did(), r);
        removed.add(r);
    }
    openConfigLog("removedFlowRules removed {}", removed.size());
    return removed;
}
#method_after
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rules) {
    NetconfSession session = getNetconfSession();
    if (session == null) {
        openConfigError("null session");
        return ImmutableList.of();
    }
    List<FlowRule> removed = new ArrayList<>();
    for (FlowRule r : rules) {
        try {
            removeFlowRule(session, r);
        } catch (Exception e) {
            openConfigError("Error {}", e);
            continue;
        }
        getConnectionCache().add(did(), r);
        removed.add(r);
    }
    openConfigLog("removedFlowRules removed {}", removed.size());
    return removed;
}
#end_block

#method_before
private PortDescription parsePortComponent(HierarchicalConfiguration component, HierarchicalConfiguration components) {
    Map<String, String> annotations = new HashMap<>();
    String name = component.getString("name");
    String type = component.getString("state/type");
    log.info("Parsing Component {} type {}", name, type);
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_NAME, name);
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_TYPE, type);
    // Store all properties as port properties
    component.configurationsAt("properties/property").forEach(property -> {
        String pn = property.getString("name");
        String pv = property.getString("state/value");
        annotations.put(pn, pv);
    });
    // Assing an ONOS port number
    PortNumber portNum;
    if (annotations.containsKey(ONOS_PORT_INDEX)) {
        portNum = PortNumber.portNumber(Long.parseLong(annotations.get(ONOS_PORT_INDEX)));
    } else {
        log.warn("PORT {} does not include onos-index, hashing...", name);
        portNum = PortNumber.portNumber(name.hashCode());
    }
    log.debug("PORT {} number {}", name, portNum);
    // The heuristic to know if it is client or line side
    if (!annotations.containsKey(PORT_TYPE)) {
        if (hasTransceiverSubComponent(component, components)) {
            annotations.put(PORT_TYPE, OdtnPortType.CLIENT.value());
        } else if (hasOpticalChannelSubComponent(component, components)) {
            annotations.put(PORT_TYPE, OdtnPortType.LINE.value());
        }
    }
    // to be an issue with resource mapping
    if (annotations.get(PORT_TYPE).equals(OdtnPortType.CLIENT.value())) {
        log.debug("Adding CLIENT port");
        Builder builder = DefaultPortDescription.builder();
        builder.type(Type.PACKET);
        builder.withPortNumber(portNum);
        builder.annotations(DefaultAnnotations.builder().putAll(annotations).build());
        return builder.build();
    }
    if (annotations.get(PORT_TYPE).equals(OdtnPortType.LINE.value())) {
        log.debug("Adding LINE port");
        // NOTE: To be configured
        OchSignal signalId = OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, 1);
        return OchPortHelper.ochPortDescription(portNum, true, // Client signal to be discovered
        OduSignalType.ODU4, true, signalId, DefaultAnnotations.builder().putAll(annotations).build());
    }
    log.error("Unknown port type");
    return null;
}
#method_after
private PortDescription parsePortComponent(HierarchicalConfiguration component, HierarchicalConfiguration components) {
    Map<String, String> annotations = new HashMap<>();
    String name = component.getString("name");
    String type = component.getString("state/type");
    log.info("Parsing Component {} type {}", name, type);
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_NAME, name);
    annotations.put(OdtnDeviceDescriptionDiscovery.OC_TYPE, type);
    // Store all properties as port properties
    component.configurationsAt("properties/property").forEach(property -> {
        String pn = property.getString("name");
        String pv = property.getString("state/value");
        annotations.put(pn, pv);
    });
    // Assing an ONOS port number
    PortNumber portNum;
    if (annotations.containsKey(ONOS_PORT_INDEX)) {
        portNum = PortNumber.portNumber(Long.parseLong(annotations.get(ONOS_PORT_INDEX)));
    } else {
        log.warn("PORT {} does not include onos-index, hashing...", name);
        portNum = PortNumber.portNumber(name.hashCode());
    }
    log.debug("PORT {} number {}", name, portNum);
    // The heuristic to know if it is client or line side
    if (!annotations.containsKey(PORT_TYPE)) {
        if (hasTransceiverSubComponent(component, components)) {
            annotations.put(PORT_TYPE, OdtnPortType.CLIENT.value());
        } else if (hasOpticalChannelSubComponent(component, components)) {
            annotations.put(PORT_TYPE, OdtnPortType.LINE.value());
        }
    }
    // to be an issue with resource mapping
    if (annotations.get(PORT_TYPE).equals(OdtnPortType.CLIENT.value())) {
        log.debug("Adding CLIENT port");
        Builder builder = DefaultPortDescription.builder();
        builder.type(Type.PACKET);
        builder.withPortNumber(portNum);
        builder.annotations(DefaultAnnotations.builder().putAll(annotations).build());
        return builder.build();
    }
    if (annotations.get(PORT_TYPE).equals(OdtnPortType.LINE.value())) {
        log.debug("Adding LINE port");
        // TODO: To be configured
        OchSignal signalId = OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, 1);
        return OchPortHelper.ochPortDescription(portNum, true, // TODO Client signal to be discovered
        OduSignalType.ODU4, true, signalId, DefaultAnnotations.builder().putAll(annotations).build());
    }
    log.error("Unknown port type");
    return null;
}
#end_block

#method_before
@Override
public void setData(DriverData data) {
    super.setData(data);
    p4RuntimeHandshaker.setData(data);
    gnmiHandshaker.setData(data);
}
#method_after
@Override
public void setData(DriverData data) {
    super.setData(data);
    p4RuntimeHandshaker.setData(data);
    gnmiHandshaker.setData(data);
    deviceId = data.deviceId();
}
#end_block

#method_before
@Override
public void roleChanged(MastershipRole newRole) {
    p4RuntimeHandshaker.roleChanged(newRole);
// FIXME: gNMI doesn't support mastership handling now.
}
#method_after
@Override
public void roleChanged(MastershipRole newRole) {
    p4RuntimeHandshaker.roleChanged(newRole);
// gNMI doesn't support mastership handling now.
}
#end_block

#method_before
@Override
public MastershipRole getRole() {
    return p4RuntimeHandshaker.getRole();
// FIXME: gNMI doesn't support mastership handling now.
}
#method_after
@Override
public MastershipRole getRole() {
    return p4RuntimeHandshaker.getRole();
// gNMI doesn't support mastership handling now.
}
#end_block

#method_before
@Override
public void addDeviceAgentListener(ProviderId providerId, DeviceAgentListener listener) {
    p4RuntimeHandshaker.addDeviceAgentListener(providerId, listener);
// FIXME: gNMI doesn't support device events
}
#method_after
@Override
public void addDeviceAgentListener(ProviderId providerId, DeviceAgentListener listener) {
    p4RuntimeHandshaker.addDeviceAgentListener(providerId, listener);
// TODO: Support gNMI device events
}
#end_block

#method_before
@Override
public void removeDeviceAgentListener(ProviderId providerId) {
    p4RuntimeHandshaker.removeDeviceAgentListener(providerId);
// FIXME: gNMI doesn't support device events
}
#method_after
@Override
public void removeDeviceAgentListener(ProviderId providerId) {
    p4RuntimeHandshaker.removeDeviceAgentListener(providerId);
// TODO: Support gNMI device events
}
#end_block

#method_before
@Override
public boolean isConnected() {
    return p4RuntimeHandshaker.isConnected() && gnmiHandshaker.isConnected();
}
#method_after
@Override
public boolean isConnected() {
    CompletableFuture<Boolean> p4runtimeConnected = CompletableFuture.supplyAsync(p4RuntimeHandshaker::isConnected);
    CompletableFuture<Boolean> gnmiConnected = CompletableFuture.supplyAsync(gnmiHandshaker::isConnected);
    try {
        return p4runtimeConnected.thenCombine(gnmiConnected, Boolean::logicalAnd).get(DEFAULT_DEVICE_REQ_TIMEOUT, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        log.error("Exception while checking connectivity on {}", deviceId);
    } catch (ExecutionException e) {
        final Throwable cause = e.getCause();
        if (cause instanceof StatusRuntimeException) {
            final StatusRuntimeException grpcError = (StatusRuntimeException) cause;
            log.warn("Error while checking connectivity on {}: {}", deviceId, grpcError.getMessage());
        } else {
            log.error("Exception while checking connectivity on {}", deviceId, e.getCause());
        }
    } catch (TimeoutException e) {
        log.error("Operation TIMEOUT while checking connectivity on {}", deviceId);
    }
    return false;
}
#end_block

#method_before
private void setFakeGatewayArpRule(Subnet osSubnet, boolean install, OpenstackNode osNode) {
    if (ARP_BROADCAST_MODE.equals(getArpMode())) {
        // different networks
        if (!install) {
            long numOfDupGws = osNetworkService.subnets().stream().filter(s -> !s.getId().equals(osSubnet.getId())).filter(s -> s.getGateway() != null).filter(s -> s.getGateway().equals(osSubnet.getGateway())).count();
            if (numOfDupGws > 0) {
                return;
            }
        }
        String gateway = osSubnet.getGateway();
        if (gateway == null) {
            return;
        }
        TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        NetworkType type = NetworkType.valueOf(osNetworkService.networkType(osSubnet.getNetworkId()));
        if (type.equals(NetworkType.VLAN)) {
            sBuilder.matchVlanId(VlanId.vlanId(osNetworkService.segmentId(osSubnet.getNetworkId())));
            tBuilder.popVlan();
        }
        sBuilder.matchEthType(EthType.EtherType.ARP.ethType().toShort()).matchArpOp(ARP.OP_REQUEST).matchArpTpa(Ip4Address.valueOf(gateway)).build();
        tBuilder.setArpOp(ARP.OP_REPLY).setArpSha(MacAddress.valueOf(gatewayMac)).setArpSpa(Ip4Address.valueOf(gateway)).setOutput(PortNumber.IN_PORT);
        if (osNode == null) {
            osNodeService.completeNodes(COMPUTE).forEach(n -> osFlowRuleService.setRule(appId, n.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_ARP_GATEWAY_RULE, ARP_TABLE, install));
        } else {
            osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_ARP_GATEWAY_RULE, ARP_TABLE, install);
        }
    }
}
#method_after
private void setFakeGatewayArpRule(Subnet osSubnet, boolean install, OpenstackNode osNode) {
    if (ARP_BROADCAST_MODE.equals(getArpMode())) {
        // different networks
        if (!install) {
            long numOfDupGws = osNetworkService.subnets().stream().filter(s -> !s.getId().equals(osSubnet.getId())).filter(s -> s.getGateway() != null).filter(s -> s.getGateway().equals(osSubnet.getGateway())).count();
            if (numOfDupGws > 0) {
                return;
            }
        }
        String gateway = osSubnet.getGateway();
        if (gateway == null) {
            return;
        }
        TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        NetworkType type = NetworkType.valueOf(osNetworkService.networkType(osSubnet.getNetworkId()));
        if (type.equals(NetworkType.VLAN)) {
            sBuilder.matchVlanId(VlanId.vlanId(osNetworkService.segmentId(osSubnet.getNetworkId())));
            tBuilder.popVlan();
        }
        sBuilder.matchEthType(EthType.EtherType.ARP.ethType().toShort()).matchArpOp(ARP.OP_REQUEST).matchArpTpa(Ip4Address.valueOf(gateway));
        tBuilder.setArpOp(ARP.OP_REPLY).setArpSha(MacAddress.valueOf(gatewayMac)).setArpSpa(Ip4Address.valueOf(gateway)).setOutput(PortNumber.IN_PORT);
        if (osNode == null) {
            osNodeService.completeNodes(COMPUTE).forEach(n -> osFlowRuleService.setRule(appId, n.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_ARP_GATEWAY_RULE, ARP_TABLE, install));
        } else {
            osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_ARP_GATEWAY_RULE, ARP_TABLE, install);
        }
    }
}
#end_block

#method_before
protected void installObjective(FlowRule.Builder ruleBuilder, Objective objective) {
    FlowRuleOperations.Builder flowBuilder = FlowRuleOperations.builder();
    switch(objective.op()) {
        case ADD:
            log.info("HP Driver - Requested ADD of objective to device " + deviceId);
            flowBuilder.add(ruleBuilder.build());
            break;
        case REMOVE:
            log.info("HP Driver - Requested REMOVE of objective to device " + deviceId);
            flowBuilder.remove(ruleBuilder.build());
            break;
        default:
            log.debug("HP Driver - Unknown operation {}", objective.op());
    }
    flowRuleService.apply(flowBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            objective.context().ifPresent(context -> context.onSuccess(objective));
            log.trace("HP Driver - Installed objective " + objective.toString());
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            objective.context().ifPresent(context -> context.onError(objective, ObjectiveError.FLOWINSTALLATIONFAILED));
            log.trace("HP Driver - Objective installation failed" + objective.toString());
        }
    }));
}
#method_after
protected void installObjective(FlowRule.Builder ruleBuilder, Objective objective) {
    FlowRuleOperations.Builder flowBuilder = FlowRuleOperations.builder();
    switch(objective.op()) {
        case ADD:
            log.trace("HP Driver - Requested ADD of objective to device " + deviceId);
            flowBuilder.add(ruleBuilder.build());
            break;
        case REMOVE:
            log.trace("HP Driver - Requested REMOVE of objective to device " + deviceId);
            flowBuilder.remove(ruleBuilder.build());
            break;
        default:
            log.debug("HP Driver - Unknown operation {}", objective.op());
    }
    flowRuleService.apply(flowBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            objective.context().ifPresent(context -> context.onSuccess(objective));
            log.trace("HP Driver - Installed objective " + objective.toString());
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            objective.context().ifPresent(context -> context.onError(objective, ObjectiveError.FLOWINSTALLATIONFAILED));
            log.trace("HP Driver - Objective installation failed" + objective.toString());
        }
    }));
}
#end_block

#method_before
private void setFakeGatewayArpRuleByRouter(Router router, boolean install) {
    setFakeGatewayArpRuleByGateway(router, install);
}
#method_after
private void setFakeGatewayArpRuleByRouter(Router router, boolean install) {
    if (ARP_BROADCAST_MODE.equals(getArpMode())) {
        setFakeGatewayArpRuleByExternalIp(getExternalIp(router, osNetworkService), install);
    }
}
#end_block

#method_before
@Override
public void event(OpenstackRouterEvent event) {
    Set<OpenstackNode> completedGws = osNodeService.completeNodes(GATEWAY);
    switch(event.type()) {
        case OPENSTACK_ROUTER_CREATED:
            eventExecutor.execute(() -> setFakeGatewayArpRuleByRouter(event.subject(), true));
            break;
        case OPENSTACK_ROUTER_REMOVED:
            eventExecutor.execute(() -> setFakeGatewayArpRuleByRouter(event.subject(), false));
            break;
        case OPENSTACK_ROUTER_GATEWAY_ADDED:
            eventExecutor.execute(() -> setFakeGatewayArpRuleByGateway(event.subject(), true));
            break;
        case OPENSTACK_ROUTER_GATEWAY_REMOVED:
            eventExecutor.execute(() -> setFakeGatewayArpRuleByGateway(event.subject(), false));
            break;
        case OPENSTACK_FLOATING_IP_ASSOCIATED:
            eventExecutor.execute(() -> {
                if (getValidPortId(event) == null) {
                    return;
                }
                // associate a floating IP with an existing VM
                setFloatingIpArpRule(event.floatingIp(), getValidPortId(event), completedGws, true);
            });
            break;
        case OPENSTACK_FLOATING_IP_DISASSOCIATED:
            eventExecutor.execute(() -> {
                if (getValidPortId(event) == null) {
                    return;
                }
                // disassociate a floating IP with an existing VM
                setFloatingIpArpRule(event.floatingIp(), getValidPortId(event), completedGws, false);
            });
            break;
        case OPENSTACK_FLOATING_IP_CREATED:
            // during floating IP creation, if the floating IP is
            // associated with any port of VM, then we will set
            // floating IP related ARP rules to gateway node
            eventExecutor.execute(() -> {
                if (getValidPortId(event) == null) {
                    return;
                }
                // associate a floating IP with an existing VM
                setFloatingIpArpRule(event.floatingIp(), getValidPortId(event), completedGws, true);
            });
            break;
        case OPENSTACK_FLOATING_IP_REMOVED:
            // during floating IP deletion, if the floating IP is
            // still associated with any port of VM, then we will
            // remove floating IP related ARP rules from gateway node
            eventExecutor.execute(() -> {
                if (getValidPortId(event) == null) {
                    return;
                }
                // associate a floating IP with an existing VM
                setFloatingIpArpRule(event.floatingIp(), getValidPortId(event), completedGws, false);
            });
            break;
        default:
            // do nothing for the other events
            break;
    }
}
#method_after
@Override
public void event(OpenstackRouterEvent event) {
    Set<OpenstackNode> completedGws = osNodeService.completeNodes(GATEWAY);
    switch(event.type()) {
        case OPENSTACK_ROUTER_CREATED:
        // add a router with external gateway
        case OPENSTACK_ROUTER_GATEWAY_ADDED:
            // add a gateway manually after adding a router
            eventExecutor.execute(() -> setFakeGatewayArpRuleByRouter(event.subject(), true));
            break;
        case OPENSTACK_ROUTER_REMOVED:
        // remove a router with external gateway
        case OPENSTACK_ROUTER_GATEWAY_REMOVED:
            // remove a gateway from an existing router
            eventExecutor.execute(() -> setFakeGatewayArpRuleByRouter(event.subject(), false));
            break;
        case OPENSTACK_FLOATING_IP_ASSOCIATED:
            eventExecutor.execute(() -> {
                if (getValidPortId(event) == null) {
                    return;
                }
                // associate a floating IP with an existing VM
                setFloatingIpArpRule(event.floatingIp(), getValidPortId(event), completedGws, true);
            });
            break;
        case OPENSTACK_FLOATING_IP_DISASSOCIATED:
            eventExecutor.execute(() -> {
                if (getValidPortId(event) == null) {
                    return;
                }
                // disassociate a floating IP with an existing VM
                setFloatingIpArpRule(event.floatingIp(), getValidPortId(event), completedGws, false);
            });
            break;
        case OPENSTACK_FLOATING_IP_CREATED:
            // during floating IP creation, if the floating IP is
            // associated with any port of VM, then we will set
            // floating IP related ARP rules to gateway node
            eventExecutor.execute(() -> {
                if (getValidPortId(event) == null) {
                    return;
                }
                // associate a floating IP with an existing VM
                setFloatingIpArpRule(event.floatingIp(), getValidPortId(event), completedGws, true);
            });
            break;
        case OPENSTACK_FLOATING_IP_REMOVED:
            // during floating IP deletion, if the floating IP is
            // still associated with any port of VM, then we will
            // remove floating IP related ARP rules from gateway node
            eventExecutor.execute(() -> {
                if (getValidPortId(event) == null) {
                    return;
                }
                // associate a floating IP with an existing VM
                setFloatingIpArpRule(event.floatingIp(), getValidPortId(event), completedGws, false);
            });
            break;
        default:
            // do nothing for the other events
            break;
    }
}
#end_block

#method_before
@Override
protected void execute() {
    List<RouterInterface> routerInterfaces = Lists.newArrayList(routerService.routerInterfaces());
    if (outputJson()) {
        print("%s", json(routerInterfaces));
    } else {
        print(FORMAT, "ID", "SubnetID", "PortID", "TenantID");
        for (RouterInterface routerInterface : routerInterfaces) {
            print(FORMAT, routerInterface.getId(), routerInterface.getSubnetId(), routerInterface.getPortId(), routerInterface.getTenantId());
        }
    }
}
#method_after
@Override
protected void execute() {
    List<RouterInterface> routerInterfaces = Lists.newArrayList(routerService.routerInterfaces());
    if (outputJson()) {
        print("%s", json(routerInterfaces));
    } else {
        print(FORMAT, "ID", "RouterName", "SubnetID", "PortID", "TenantID");
        for (RouterInterface routerInterface : routerInterfaces) {
            print(FORMAT, routerInterface.getId(), routerService.router(routerInterface.getId()), routerInterface.getSubnetId(), routerInterface.getPortId(), routerInterface.getTenantId());
        }
    }
}
#end_block

#method_before
public static ExternalPeerRouter externalPeerRouterFromSubnet(Subnet subnet, OpenstackRouterService osRouterService, OpenstackNetworkService osNetworkService) {
    RouterInterface osRouterIface = osRouterService.routerInterfaces().stream().filter(i -> Objects.equals(i.getSubnetId(), subnet.getId())).findAny().orElse(null);
    if (osRouterIface == null) {
        return null;
    }
    Router osRouter = osRouterService.router(osRouterIface.getId());
    if (osRouter == null) {
        return null;
    }
    if (osRouter.getExternalGatewayInfo() == null) {
        return null;
    }
    ExternalGateway exGatewayInfo = osRouter.getExternalGatewayInfo();
    return osNetworkService.externalPeerRouter(exGatewayInfo);
}
#method_after
public static ExternalPeerRouter externalPeerRouterFromSubnet(Subnet subnet, OpenstackRouterService osRouterService, OpenstackNetworkService osNetworkService) {
    Router osRouter = getRouterFromSubnet(subnet, osRouterService);
    if (osRouter == null) {
        return null;
    }
    if (osRouter.getExternalGatewayInfo() == null) {
        // this router does not have external connectivity
        log.trace("router({}) has no external gateway", osRouter.getName());
        return null;
    }
    return osNetworkService.externalPeerRouter(osRouter.getExternalGatewayInfo());
}
#end_block

#method_before
public static IpAddress getExternalIpFromSubnet(Subnet srcSubnet, OpenstackRouterService osRouterService, OpenstackNetworkService osNetworkService) {
    RouterInterface osRouterIface = osRouterService.routerInterfaces().stream().filter(i -> Objects.equals(i.getSubnetId(), srcSubnet.getId())).findAny().orElse(null);
    if (osRouterIface == null) {
        // this subnet is not connected to the router
        log.trace("source subnet(ID:{}, CIDR:{}) has no router", srcSubnet.getId(), srcSubnet.getCidr());
        return null;
    }
    Router osRouter = osRouterService.router(osRouterIface.getId());
    if (osRouter.getExternalGatewayInfo() == null) {
        // this router does not have external connectivity
        log.trace("router({}) has no external gateway", osRouter.getName());
        return null;
    }
    return getExternalIp(osRouter, osNetworkService);
}
#method_after
public static IpAddress getExternalIpFromSubnet(Subnet srcSubnet, OpenstackRouterService osRouterService, OpenstackNetworkService osNetworkService) {
    Router osRouter = getRouterFromSubnet(srcSubnet, osRouterService);
    if (osRouter.getExternalGatewayInfo() == null) {
        // this router does not have external connectivity
        log.trace("router({}) has no external gateway", osRouter.getName());
        return null;
    }
    return getExternalIp(osRouter, osNetworkService);
}
#end_block

#method_before
@Override
protected void execute() {
    OpenstackSecurityGroupAdminService osSgAdminService = get(OpenstackSecurityGroupAdminService.class);
    OpenstackNetworkAdminService osNetAdminService = get(OpenstackNetworkAdminService.class);
    OpenstackRouterAdminService osRouterAdminService = get(OpenstackRouterAdminService.class);
    OpenstackNodeService osNodeService = get(OpenstackNodeService.class);
    HashMap<String, String> headerMap = new HashMap();
    headerMap.put(HTTP_HEADER_ACCEPT, HTTP_HEADER_VALUE_JSON);
    Optional<OpenstackNode> node = osNodeService.nodes(CONTROLLER).stream().findFirst();
    if (!node.isPresent()) {
        error("Keystone auth info has not been configured. " + "Please specify auth info via network-cfg.json.");
        return;
    }
    OSClient osClient = OpenstackNetworkingUtil.getConnectedClient(node.get());
    if (osClient == null) {
        return;
    }
    print("Synchronizing OpenStack security groups");
    print(SECURITY_GROUP_FORMAT, "ID", "Name");
    osClient.headers(headerMap).networking().securitygroup().list().forEach(osSg -> {
        if (osSgAdminService.securityGroup(osSg.getId()) != null) {
            osSgAdminService.updateSecurityGroup(osSg);
        } else {
            osSgAdminService.createSecurityGroup(osSg);
        }
        print(SECURITY_GROUP_FORMAT, osSg.getId(), osSg.getName());
    });
    print("\nSynchronizing OpenStack networks");
    print(NETWORK_FORMAT, "ID", "Name", "VNI", "Subnets");
    osClient.headers(headerMap).networking().network().list().forEach(osNet -> {
        if (osNetAdminService.network(osNet.getId()) != null) {
            osNetAdminService.updateNetwork(osNet);
        } else {
            osNetAdminService.createNetwork(osNet);
        }
        printNetwork(osNet);
    });
    print("\nSynchronizing OpenStack subnets");
    print(SUBNET_FORMAT, "ID", "Network", "CIDR");
    osClient.headers(headerMap).networking().subnet().list().forEach(osSubnet -> {
        if (osNetAdminService.subnet(osSubnet.getId()) != null) {
            osNetAdminService.updateSubnet(osSubnet);
        } else {
            osNetAdminService.createSubnet(osSubnet);
        }
        printSubnet(osSubnet, osNetAdminService);
    });
    print("\nSynchronizing OpenStack ports");
    print(PORT_FORMAT, "ID", "Network", "MAC", "Fixed IPs");
    osClient.headers(headerMap).networking().port().list().forEach(osPort -> {
        if (osNetAdminService.port(osPort.getId()) != null) {
            osNetAdminService.updatePort(osPort);
        } else {
            osNetAdminService.createPort(osPort);
        }
        printPort(osPort, osNetAdminService);
    });
    print("\nSynchronizing OpenStack routers");
    print(ROUTER_FORMAT, "ID", "Name", "External", "Internal");
    osClient.headers(headerMap).networking().router().list().forEach(osRouter -> {
        if (osRouterAdminService.router(osRouter.getId()) != null) {
            osRouterAdminService.updateRouter(osRouter);
        } else {
            osRouterAdminService.createRouter(osRouter);
        }
        // FIXME do we need to manage router interfaces separately?
        osNetAdminService.ports().stream().filter(osPort -> Objects.equals(osPort.getDeviceId(), osRouter.getId()) && Objects.equals(osPort.getDeviceOwner(), DEVICE_OWNER_IFACE)).forEach(osPort -> addRouterIface(osPort, osRouterAdminService));
        printRouter(osRouter, osNetAdminService);
    });
    print("\nSynchronizing OpenStack floating IPs");
    print(FLOATING_IP_FORMAT, "ID", "Floating IP", "Fixed IP");
    osClient.headers(headerMap).networking().floatingip().list().forEach(osFloating -> {
        if (osRouterAdminService.floatingIp(osFloating.getId()) != null) {
            osRouterAdminService.updateFloatingIp(osFloating);
        } else {
            osRouterAdminService.createFloatingIp(osFloating);
        }
        printFloatingIp(osFloating);
    });
}
#method_after
@Override
protected void execute() {
    OpenstackSecurityGroupAdminService osSgAdminService = get(OpenstackSecurityGroupAdminService.class);
    OpenstackNetworkAdminService osNetAdminService = get(OpenstackNetworkAdminService.class);
    OpenstackRouterAdminService osRouterAdminService = get(OpenstackRouterAdminService.class);
    OpenstackNodeService osNodeService = get(OpenstackNodeService.class);
    Map<String, String> headerMap = new HashMap();
    headerMap.put(HTTP_HEADER_ACCEPT, HTTP_HEADER_VALUE_JSON);
    Optional<OpenstackNode> node = osNodeService.nodes(CONTROLLER).stream().findFirst();
    if (!node.isPresent()) {
        error("Keystone auth info has not been configured. " + "Please specify auth info via network-cfg.json.");
        return;
    }
    OSClient osClient = OpenstackNetworkingUtil.getConnectedClient(node.get());
    if (osClient == null) {
        return;
    }
    print("Synchronizing OpenStack security groups");
    print(SECURITY_GROUP_FORMAT, "ID", "Name");
    osClient.headers(headerMap).networking().securitygroup().list().forEach(osSg -> {
        if (osSgAdminService.securityGroup(osSg.getId()) != null) {
            osSgAdminService.updateSecurityGroup(osSg);
        } else {
            osSgAdminService.createSecurityGroup(osSg);
        }
        print(SECURITY_GROUP_FORMAT, osSg.getId(), osSg.getName());
    });
    print("\nSynchronizing OpenStack networks");
    print(NETWORK_FORMAT, "ID", "Name", "VNI", "Subnets");
    osClient.headers(headerMap).networking().network().list().forEach(osNet -> {
        if (osNetAdminService.network(osNet.getId()) != null) {
            osNetAdminService.updateNetwork(osNet);
        } else {
            osNetAdminService.createNetwork(osNet);
        }
        printNetwork(osNet);
    });
    print("\nSynchronizing OpenStack subnets");
    print(SUBNET_FORMAT, "ID", "Network", "CIDR");
    osClient.headers(headerMap).networking().subnet().list().forEach(osSubnet -> {
        if (osNetAdminService.subnet(osSubnet.getId()) != null) {
            osNetAdminService.updateSubnet(osSubnet);
        } else {
            osNetAdminService.createSubnet(osSubnet);
        }
        printSubnet(osSubnet, osNetAdminService);
    });
    print("\nSynchronizing OpenStack ports");
    print(PORT_FORMAT, "ID", "Network", "MAC", "Fixed IPs");
    osClient.headers(headerMap).networking().port().list().forEach(osPort -> {
        if (osNetAdminService.port(osPort.getId()) != null) {
            osNetAdminService.updatePort(osPort);
        } else {
            osNetAdminService.createPort(osPort);
        }
        printPort(osPort, osNetAdminService);
    });
    print("\nSynchronizing OpenStack routers");
    print(ROUTER_FORMAT, "ID", "Name", "External", "Internal");
    osClient.headers(headerMap).networking().router().list().forEach(osRouter -> {
        if (osRouterAdminService.router(osRouter.getId()) != null) {
            osRouterAdminService.updateRouter(osRouter);
        } else {
            osRouterAdminService.createRouter(osRouter);
        }
        // FIXME do we need to manage router interfaces separately?
        osNetAdminService.ports().stream().filter(osPort -> Objects.equals(osPort.getDeviceId(), osRouter.getId()) && Objects.equals(osPort.getDeviceOwner(), DEVICE_OWNER_IFACE)).forEach(osPort -> addRouterIface(osPort, osRouterAdminService));
        printRouter(osRouter, osNetAdminService);
    });
    print("\nSynchronizing OpenStack floating IPs");
    print(FLOATING_IP_FORMAT, "ID", "Floating IP", "Fixed IP");
    osClient.headers(headerMap).networking().floatingip().list().forEach(osFloating -> {
        if (osRouterAdminService.floatingIp(osFloating.getId()) != null) {
            osRouterAdminService.updateFloatingIp(osFloating);
        } else {
            osRouterAdminService.createFloatingIp(osFloating);
        }
        printFloatingIp(osFloating);
    });
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("sync/states")
public Response syncStates() {
    HashMap<String, String> headerMap = new HashMap();
    headerMap.put(HTTP_HEADER_ACCEPT, HTTP_HEADER_VALUE_JSON);
    Optional<OpenstackNode> node = osNodeAdminService.nodes(CONTROLLER).stream().findFirst();
    if (!node.isPresent()) {
        throw new ItemNotFoundException("Auth info is not found");
    }
    OSClient osClient = OpenstackNetworkingUtil.getConnectedClient(node.get());
    if (osClient == null) {
        throw new ItemNotFoundException("Auth info is not correct");
    }
    osClient.headers(headerMap).networking().securitygroup().list().forEach(osSg -> {
        if (osSgAdminService.securityGroup(osSg.getId()) != null) {
            osSgAdminService.updateSecurityGroup(osSg);
        } else {
            osSgAdminService.createSecurityGroup(osSg);
        }
    });
    osClient.headers(headerMap).networking().network().list().forEach(osNet -> {
        if (osNetAdminService.network(osNet.getId()) != null) {
            osNetAdminService.updateNetwork(osNet);
        } else {
            osNetAdminService.createNetwork(osNet);
        }
    });
    osClient.headers(headerMap).networking().subnet().list().forEach(osSubnet -> {
        if (osNetAdminService.subnet(osSubnet.getId()) != null) {
            osNetAdminService.updateSubnet(osSubnet);
        } else {
            osNetAdminService.createSubnet(osSubnet);
        }
    });
    osClient.headers(headerMap).networking().port().list().forEach(osPort -> {
        if (osNetAdminService.port(osPort.getId()) != null) {
            osNetAdminService.updatePort(osPort);
        } else {
            osNetAdminService.createPort(osPort);
        }
    });
    osClient.headers(headerMap).networking().router().list().forEach(osRouter -> {
        if (osRouterAdminService.router(osRouter.getId()) != null) {
            osRouterAdminService.updateRouter(osRouter);
        } else {
            osRouterAdminService.createRouter(osRouter);
        }
        osNetAdminService.ports().stream().filter(osPort -> Objects.equals(osPort.getDeviceId(), osRouter.getId()) && Objects.equals(osPort.getDeviceOwner(), DEVICE_OWNER_IFACE)).forEach(osPort -> addRouterIface(osPort, osRouterAdminService));
    });
    osClient.headers(headerMap).networking().floatingip().list().forEach(osFloating -> {
        if (osRouterAdminService.floatingIp(osFloating.getId()) != null) {
            osRouterAdminService.updateFloatingIp(osFloating);
        } else {
            osRouterAdminService.createFloatingIp(osFloating);
        }
    });
    return ok(mapper().createObjectNode()).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("sync/states")
public Response syncStates() {
    Map<String, String> headerMap = new HashMap();
    headerMap.put(HTTP_HEADER_ACCEPT, HTTP_HEADER_VALUE_JSON);
    Optional<OpenstackNode> node = osNodeAdminService.nodes(CONTROLLER).stream().findFirst();
    if (!node.isPresent()) {
        throw new ItemNotFoundException("Auth info is not found");
    }
    OSClient osClient = OpenstackNetworkingUtil.getConnectedClient(node.get());
    if (osClient == null) {
        throw new ItemNotFoundException("Auth info is not correct");
    }
    osClient.headers(headerMap).networking().securitygroup().list().forEach(osSg -> {
        if (osSgAdminService.securityGroup(osSg.getId()) != null) {
            osSgAdminService.updateSecurityGroup(osSg);
        } else {
            osSgAdminService.createSecurityGroup(osSg);
        }
    });
    osClient.headers(headerMap).networking().network().list().forEach(osNet -> {
        if (osNetAdminService.network(osNet.getId()) != null) {
            osNetAdminService.updateNetwork(osNet);
        } else {
            osNetAdminService.createNetwork(osNet);
        }
    });
    osClient.headers(headerMap).networking().subnet().list().forEach(osSubnet -> {
        if (osNetAdminService.subnet(osSubnet.getId()) != null) {
            osNetAdminService.updateSubnet(osSubnet);
        } else {
            osNetAdminService.createSubnet(osSubnet);
        }
    });
    osClient.headers(headerMap).networking().port().list().forEach(osPort -> {
        if (osNetAdminService.port(osPort.getId()) != null) {
            osNetAdminService.updatePort(osPort);
        } else {
            osNetAdminService.createPort(osPort);
        }
    });
    osClient.headers(headerMap).networking().router().list().forEach(osRouter -> {
        if (osRouterAdminService.router(osRouter.getId()) != null) {
            osRouterAdminService.updateRouter(osRouter);
        } else {
            osRouterAdminService.createRouter(osRouter);
        }
        osNetAdminService.ports().stream().filter(osPort -> Objects.equals(osPort.getDeviceId(), osRouter.getId()) && Objects.equals(osPort.getDeviceOwner(), DEVICE_OWNER_IFACE)).forEach(osPort -> addRouterIface(osPort, osRouterAdminService));
    });
    osClient.headers(headerMap).networking().floatingip().list().forEach(osFloating -> {
        if (osRouterAdminService.floatingIp(osFloating.getId()) != null) {
            osRouterAdminService.updateFloatingIp(osFloating);
        } else {
            osRouterAdminService.createFloatingIp(osFloating);
        }
    });
    return ok(mapper().createObjectNode()).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("dhcp-relay")
public Response getDhcpServers() {
    ObjectNode node;
    try {
        node = getdhcpRelayJsonOutput(null, null);
    } catch (IllegalAccessError e) {
        throw new IllegalAccessError();
    }
    return Response.status(200).entity(node).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("dhcp-relay")
public Response getDhcpServers() {
    ObjectNode node = getdhcpRelayJsonOutput(null, null);
    return Response.status(200).entity(node).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("dhcp-relay/{counter}")
public Response getDhcpRelayCounter(@PathParam("counter") String counter) {
    ObjectNode node;
    try {
        node = getdhcpRelayJsonOutput(counter, null);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(e);
    }
    return Response.status(200).entity(node).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("dhcp-relay/{counter}")
public Response getDhcpRelayCounter(@PathParam("counter") String counter) {
    ObjectNode node = getdhcpRelayJsonOutput(counter, null);
    return Response.status(200).entity(node).build();
}
#end_block

#method_before
@PUT
@Produces(MediaType.APPLICATION_JSON)
@Path("dhcp-relay/{counter}/{reset}")
public Response resetDhcpRelayCounter(@PathParam("counter") String counter, @PathParam("reset") String reset) {
    ObjectNode node;
    try {
        node = getdhcpRelayJsonOutput(counter, reset);
    } catch (IllegalAccessError e) {
        throw new IllegalAccessError();
    }
    return Response.status(200).entity(node).build();
}
#method_after
@PUT
@Produces(MediaType.APPLICATION_JSON)
@Path("dhcp-relay/{counter}/{reset}")
public Response resetDhcpRelayCounter(@PathParam("counter") String counter, @PathParam("reset") String reset) {
    ObjectNode node = getdhcpRelayJsonOutput(counter, reset);
    return Response.status(200).entity(node).build();
}
#end_block

#method_before
private ObjectNode getdhcpRelayJsonOutput(String counter, String reset) {
    ObjectNode node = mapper.createObjectNode();
    ObjectNode dhcpRelayServerNode = mapper.createObjectNode();
    try {
        if (!defaultDhcpServerInfoList.isEmpty()) {
            ArrayNode defaultDhcpServers = listServers(defaultDhcpServerInfoList);
            dhcpRelayServerNode.put("Default DHCP server", defaultDhcpServers);
        }
        if (!indirectDhcpServerInfoList.isEmpty()) {
            ArrayNode indirectDhcpServers = listServers(indirectDhcpServerInfoList);
            dhcpRelayServerNode.put("Indirect DHCP server", indirectDhcpServers);
        }
        ArrayNode dhcpRecords = dhcpRelayRecords(records);
        dhcpRelayServerNode.put("DHCP relay records ([D]: Directly connected)", dhcpRecords);
        if (counter != null && !counter.equals("counter")) {
            ArrayNode counterArray = dhcpRelayCounters(reset);
            dhcpRelayServerNode.put("DHCP Relay Counter", counterArray);
        }
        node.put("Default DHCP servers", dhcpRelayServerNode);
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException(e);
    }
    return node;
}
#method_after
private ObjectNode getdhcpRelayJsonOutput(String counter, String reset) {
    ObjectNode node = mapper.createObjectNode();
    ObjectNode dhcpRelayServerNode = mapper.createObjectNode();
    if (!defaultDhcpServerInfoList.isEmpty()) {
        ArrayNode defaultDhcpServers = listServers(defaultDhcpServerInfoList);
        dhcpRelayServerNode.put("Default-DHCP-Server", defaultDhcpServers);
    }
    if (!indirectDhcpServerInfoList.isEmpty()) {
        ArrayNode indirectDhcpServers = listServers(indirectDhcpServerInfoList);
        dhcpRelayServerNode.put("Indirect-DHCP-Server", indirectDhcpServers);
    }
    ArrayNode dhcpRecords = dhcpRelayRecords(records);
    dhcpRelayServerNode.put("DHCP-Relay-Records([D]:Directly-Connected)", dhcpRecords);
    if (counter != null && !counter.equals("counter")) {
        ArrayNode counterArray = dhcpRelayCounters(reset);
        dhcpRelayServerNode.put("DHCP-Relay-Counter", counterArray);
    }
    node.put("Default-DHCP-Servers", dhcpRelayServerNode);
    return node;
}
#end_block

#method_before
public String ip6State(DhcpRecord record) {
    String nextHopIp = findNextHopIp6(IpAddress::isIp6, record.nextHop().orElse(null), record.vlanId());
    if (record.directlyConnected()) {
        return String.format(STATUS_FMT_V6, record.ip6Address().map(Object::toString).orElse(NA), record.addrPrefTime(), record.getLastIp6Update(), record.pdPrefix().map(Object::toString).orElse(NA), record.pdPrefTime(), record.getLastPdUpdate(), record.ip6Status().map(Object::toString).orElse(NA));
    } else {
        return String.format(STATUS_FMT_V6_NH, record.ip6Address().map(Object::toString).orElse(NA), record.addrPrefTime(), record.getLastIp6Update(), record.pdPrefix().map(Object::toString).orElse(NA), record.pdPrefTime(), record.getLastPdUpdate(), nextHopIp, record.ip6Status().map(Object::toString).orElse(NA));
    }
}
#method_after
/**
 * To return ipv6state.
 *
 * @param record DhcpRecord object
 * @return ipState type String
 */
public String ip6State(DhcpRecord record) {
    String nextHopIp = findNextHopIp6(IpAddress::isIp6, record.nextHop().orElse(null), record.vlanId());
    if (record.directlyConnected()) {
        return String.format(STATUS_FMT_V6, record.ip6Address().map(Object::toString).orElse(NA), record.addrPrefTime(), record.getLastIp6Update(), record.pdPrefix().map(Object::toString).orElse(NA), record.pdPrefTime(), record.getLastPdUpdate(), record.ip6Status().map(Object::toString).orElse(NA));
    } else {
        return String.format(STATUS_FMT_V6_NH, record.ip6Address().map(Object::toString).orElse(NA), record.addrPrefTime(), record.getLastIp6Update(), record.pdPrefix().map(Object::toString).orElse(NA), record.pdPrefTime(), record.getLastPdUpdate(), nextHopIp, record.ip6Status().map(Object::toString).orElse(NA));
    }
}
#end_block

#method_before
private void routerIfaceAdded(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkAdminService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format("Failed to set flows for router %s: subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    if (!osRouter.isAdminStateUp()) {
        Network network = osNetworkAdminService.network(osSubnet.getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), true);
    }
    setInternalRoutes(osRouter, osSubnet, true);
    setGatewayIcmp(osSubnet, true);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, true);
    }
    log.info("Connected subnet({}) to {}", osSubnet.getCidr(), osRouter.getName());
}
#method_after
private void routerIfaceAdded(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkAdminService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format("Failed to set flows for router %s: subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    if (!osRouter.isAdminStateUp()) {
        Network network = osNetworkAdminService.network(osSubnet.getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), true);
    }
    setInternalRoutes(osRouter, osSubnet, true);
    setGatewayIcmp(osSubnet, osRouter, true);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, true);
    }
    log.info("Connected subnet({}) to {}", osSubnet.getCidr(), osRouter.getName());
}
#end_block

#method_before
private void routerIfaceRemoved(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkAdminService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format("Failed to set flows for router %s: subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    if (!osRouter.isAdminStateUp()) {
        Network network = osNetworkAdminService.network(osSubnet.getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), false);
    }
    setInternalRoutes(osRouter, osSubnet, false);
    setGatewayIcmp(osSubnet, false);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, false);
    }
    log.info("Disconnected subnet({}) from {}", osSubnet.getCidr(), osRouter.getName());
}
#method_after
private void routerIfaceRemoved(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkAdminService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format("Failed to set flows for router %s: subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    if (!osRouter.isAdminStateUp()) {
        Network network = osNetworkAdminService.network(osSubnet.getNetworkId());
        setRouterAdminRules(network.getProviderSegID(), network.getNetworkType(), false);
    }
    setInternalRoutes(osRouter, osSubnet, false);
    setGatewayIcmp(osSubnet, osRouter, false);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, false);
    }
    log.info("Disconnected subnet({}) from {}", osSubnet.getCidr(), osRouter.getName());
}
#end_block

#method_before
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    OpenstackNode sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkAdminService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.dataIp() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.vlanPortNum() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, sourceNatGateway, network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format("%s %s", ERR_UNSUPPORTED_NET_TYPE, network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> setGatewayIcmpRule(gatewayIp, gNode.intgBridge(), install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#method_after
private void setGatewayIcmp(Subnet osSubnet, Router osRouter, boolean install) {
    OpenstackNode sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkAdminService.network(osSubnet.getNetworkId());
    Set<Subnet> routableSubnets = routableSubnets(osRouter, osSubnet.getId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.dataIp() != null).forEach(cNode -> setRulesToGatewayWithRoutableSubnets(cNode, sourceNatGateway, network.getProviderSegID(), osSubnet, routableSubnets, NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.vlanPortNum() != null).forEach(cNode -> setRulesToGatewayWithRoutableSubnets(cNode, sourceNatGateway, network.getProviderSegID(), osSubnet, routableSubnets, NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format("%s %s", ERR_UNSUPPORTED_NET_TYPE, network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> setGatewayIcmpRule(gatewayIp, gNode.intgBridge(), install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#end_block

#method_before
private void setInternalRoutes(Router osRouter, Subnet updatedSubnet, boolean install) {
    Network updatedNetwork = osNetworkAdminService.network(updatedSubnet.getNetworkId());
    Set<Subnet> routableSubnets = routableSubnets(osRouter, updatedSubnet.getId());
    String updatedSegmendId = getSegmentId(updatedSubnet);
    // installs rule from/to my subnet intentionally to fix ICMP failure
    // to my subnet gateway if no external gateway added to the router
    osNodeService.completeNodes(COMPUTE).forEach(cNode -> {
        setInternalRouterRules(cNode.intgBridge(), updatedSegmendId, updatedSegmendId, IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        routableSubnets.forEach(subnet -> {
            setInternalRouterRules(cNode.intgBridge(), updatedSegmendId, getSegmentId(subnet), IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(subnet.getCidr()), updatedNetwork.getNetworkType(), install);
            setInternalRouterRules(cNode.intgBridge(), getSegmentId(subnet), updatedSegmendId, IpPrefix.valueOf(subnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        });
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    routableSubnets.forEach(subnet -> log.debug(updateStr + "route between subnet:{} and subnet:{}", subnet.getCidr(), updatedSubnet.getCidr()));
}
#method_after
private void setInternalRoutes(Router osRouter, Subnet updatedSubnet, boolean install) {
    Network updatedNetwork = osNetworkAdminService.network(updatedSubnet.getNetworkId());
    Set<Subnet> routableSubnets = routableSubnets(osRouter, updatedSubnet.getId());
    String updatedSegmentId = getSegmentId(updatedSubnet);
    // installs rule from/to my subnet intentionally to fix ICMP failure
    // to my subnet gateway if no external gateway added to the router
    osNodeService.completeNodes(COMPUTE).forEach(cNode -> {
        setInternalRouterRules(cNode.intgBridge(), updatedSegmentId, updatedSegmentId, IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        routableSubnets.forEach(subnet -> {
            setInternalRouterRules(cNode.intgBridge(), updatedSegmentId, getSegmentId(subnet), IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(subnet.getCidr()), updatedNetwork.getNetworkType(), install);
            setInternalRouterRules(cNode.intgBridge(), getSegmentId(subnet), updatedSegmentId, IpPrefix.valueOf(subnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        });
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    routableSubnets.forEach(subnet -> log.debug(updateStr + "route between subnet:{} and subnet:{}", subnet.getCidr(), updatedSubnet.getCidr()));
}
#end_block

#method_before
private void setRulesToGateway(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    OpenstackNode sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet.getIp4Prefix()).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            break;
        default:
            final String error = String.format("%s %s", ERR_UNSUPPORTED_NET_TYPE, networkType.toString());
            throw new IllegalStateException(error);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(networkType) {
        case VXLAN:
            tBuilder.extension(buildExtension(deviceService, osNode.intgBridge(), sourceNatGateway.dataIp().getIp4Address()), osNode.intgBridge()).setOutput(osNode.tunnelPortNum());
            break;
        case VLAN:
            tBuilder.setOutput(osNode.vlanPortNum());
            break;
        default:
            break;
    }
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#method_after
private void setRulesToGateway(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    OpenstackNode sourceNatGateway = osNodeService.completeNodes(GATEWAY).stream().findFirst().orElse(null);
    if (sourceNatGateway == null) {
        return;
    }
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet.getIp4Prefix()).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            break;
        default:
            final String error = String.format("%s %s", ERR_UNSUPPORTED_NET_TYPE, networkType.toString());
            throw new IllegalStateException(error);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(networkType) {
        case VXLAN:
            tBuilder.extension(buildExtension(deviceService, osNode.intgBridge(), sourceNatGateway.dataIp().getIp4Address()), osNode.intgBridge()).setOutput(osNode.tunnelPortNum());
            break;
        case VLAN:
            tBuilder.setOutput(osNode.vlanPortNum());
            break;
        default:
            break;
    }
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setRulesToGatewayWithDstIp(OpenstackNode osNode, OpenstackNode sourceNatGateway, String segmentId, IpAddress dstIp, NetworkMode networkMode, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(segmentId)).matchIPDst(dstIp.getIp4Address().toIpPrefix());
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(networkMode) {
        case VXLAN:
            tBuilder.extension(buildExtension(deviceService, osNode.intgBridge(), sourceNatGateway.dataIp().getIp4Address()), osNode.intgBridge()).setOutput(osNode.tunnelPortNum());
            break;
        case VLAN:
            tBuilder.setOutput(osNode.vlanPortNum());
            break;
        default:
            break;
    }
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_SWITCHING_RULE, ROUTING_TABLE, install);
}
#method_after
private void setRulesToGatewayWithDstIp(OpenstackNode osNode, OpenstackNode sourceNatGateway, String segmentId, IpAddress dstIp, NetworkMode networkMode, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(dstIp.getIp4Address().toIpPrefix());
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(networkMode) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            tBuilder.extension(buildExtension(deviceService, osNode.intgBridge(), sourceNatGateway.dataIp().getIp4Address()), osNode.intgBridge()).setOutput(osNode.tunnelPortNum());
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            tBuilder.setOutput(osNode.vlanPortNum());
            break;
        default:
            break;
    }
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_SWITCHING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setRulesToController(DeviceId deviceId, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            break;
        default:
            final String error = String.format("%s %s", ERR_UNSUPPORTED_NET_TYPE, networkType.toString());
            throw new IllegalStateException(error);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    if (networkType.equals(NetworkType.VLAN)) {
        tBuilder.popVlan();
    }
    tBuilder.punt();
    osFlowRuleService.setRule(appId, deviceId, sBuilder.build(), tBuilder.build(), PRIORITY_EXTERNAL_ROUTING_RULE, GW_COMMON_TABLE, install);
    // Sends ICMP response to controller for SNATing ingress traffic
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIcmpType(ICMP.TYPE_ECHO_REPLY).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().punt().build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, GW_COMMON_TABLE, install);
}
#method_after
private void setRulesToController(DeviceId deviceId, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            break;
        default:
            final String error = String.format("%s %s", ERR_UNSUPPORTED_NET_TYPE, networkType.toString());
            throw new IllegalStateException(error);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    if (networkType.equals(NetworkType.VLAN)) {
        tBuilder.popVlan();
    }
    tBuilder.punt();
    osFlowRuleService.setRule(appId, deviceId, sBuilder.build(), tBuilder.build(), PRIORITY_EXTERNAL_ROUTING_RULE, GW_COMMON_TABLE, install);
}
#end_block

#method_before
@Override
public boolean isConnected() {
    final GnmiController controller = handler().get(GnmiController.class);
    final DeviceId deviceId = handler().data().deviceId();
    final GnmiClient client = controller.getClient(deviceId);
    if (client == null) {
        return false;
    }
    // TODO: Using subscription stream channel to test the connectivity
    try {
        // Returns null when service is unavailable
        return client.get(CONNECTIVITY_TEST_REQ).get() != null;
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Got error while trying to check connectivity for device {}: {}", deviceId, e.getMessage());
        return false;
    }
}
#method_after
@Override
public boolean isConnected() {
    final GnmiController controller = handler().get(GnmiController.class);
    final DeviceId deviceId = handler().data().deviceId();
    final GnmiClient client = controller.getClient(deviceId);
    if (client == null) {
        return false;
    }
    return getFutureWithDeadline(client.isServiceAvailable(), "getting availability", false);
}
#end_block

#method_before
@Before
public void setUp() {
    icmpHandler = new OpenstackRoutingIcmpHandler();
    icmpHandler.coreService = new TestCoreService();
    icmpHandler.packetService = new TestPacketService();
    icmpHandler.storageService = new TestStorageService();
    icmpHandler.osNodeService = new TestOpenstackNodeService();
    icmpHandler.instancePortService = new TestInstancePortService();
    icmpHandler.osNetworkService = new TestOpenstackNetworkService();
    icmpHandler.osRouterService = new TestOpenstackRouterService();
    icmpHandler.leadershipService = new TestLeadershipService();
    icmpHandler.osFlowRuleService = new TestOpenstackFlowRuleService();
    TestUtils.setField(icmpHandler, "eventExecutor", MoreExecutors.newDirectExecutorService());
    icmpHandler.activate();
    createPort();
    createSubnet();
    createInstancePortMap();
    createRouterInterfaceMap();
    createRouterMap();
}
#method_after
@Before
public void setUp() {
    icmpHandler = new OpenstackRoutingIcmpHandler();
    icmpHandler.coreService = new TestCoreService();
    icmpHandler.packetService = new TestPacketService();
    icmpHandler.storageService = new TestStorageService();
    icmpHandler.osNodeService = new TestOpenstackNodeService();
    icmpHandler.instancePortService = new TestInstancePortService();
    icmpHandler.osNetworkService = new TestOpenstackNetworkService();
    icmpHandler.osRouterService = new TestOpenstackRouterService();
    icmpHandler.leadershipService = new TestLeadershipService();
    icmpHandler.osFlowRuleService = new TestOpenstackFlowRuleService();
    icmpHandler.clusterService = new TestClusterService();
    TestUtils.setField(icmpHandler, "eventExecutor", MoreExecutors.newDirectExecutorService());
    icmpHandler.activate();
    createPort();
    createSubnet();
    createInstancePortMap();
    createRouterInterfaceMap();
    createRouterMap();
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(OPENSTACK_NETWORKING_APP_ID);
    packetService.addProcessor(packetProcessor, PacketProcessor.director(1));
    leadershipService.runForLeadership(appId.name());
    osNodeService.addListener(osNodeListener);
    icmpInfoMap = storageService.<String, InstancePort>consistentMapBuilder().withSerializer(Serializer.using(SERIALIZER_ICMP_MAP)).withName("openstack-icmpmap").withApplicationId(appId).build();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(OPENSTACK_NETWORKING_APP_ID);
    packetService.addProcessor(packetProcessor, PacketProcessor.director(1));
    localNodeId = clusterService.getLocalNode().id();
    leadershipService.runForLeadership(appId.name());
    osNodeService.addListener(osNodeListener);
    icmpInfoMap = storageService.<String, InstancePort>consistentMapBuilder().withSerializer(Serializer.using(SERIALIZER_ICMP_MAP)).withName("openstack-icmpmap").withApplicationId(appId).build();
    log.info("Started");
}
#end_block

#method_before
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case OPENSTACK_NODE_COMPLETE:
            setIcmpReplyRules(osNode.intgBridge(), true);
            break;
        case OPENSTACK_NODE_INCOMPLETE:
            setIcmpReplyRules(osNode.intgBridge(), false);
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case OPENSTACK_NODE_COMPLETE:
            eventExecutor.execute(() -> setIcmpReplyRules(osNode.intgBridge(), true));
            break;
        case OPENSTACK_NODE_INCOMPLETE:
            eventExecutor.execute(() -> setIcmpReplyRules(osNode.intgBridge(), false));
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    log.debug("Discovering port details on device {}", handler().data().deviceId());
    GetResponse response;
    try {
        response = client.getDeviceData(buildPortStateRequest()).get(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        log.warn("Unable to discover ports from {}: {}", deviceId, e.getMessage());
        log.debug("{}", e);
        return null;
    }
    Map<String, DefaultPortDescription.Builder> ports = Maps.newHashMap();
    Map<String, DefaultAnnotations.Builder> annotations = Maps.newHashMap();
    // Creates port descriptions with port name and port number
    response.getNotificationList().stream().flatMap(notification -> notification.getUpdateList().stream()).forEach(update -> {
        String ifName = update.getPath().getElem(1).getKeyMap().get("name");
        if (!ports.containsKey(ifName)) {
            ports.put(ifName, DefaultPortDescription.builder());
            annotations.put(ifName, DefaultAnnotations.builder());
        }
        DefaultPortDescription.Builder builder = ports.get(ifName);
        DefaultAnnotations.Builder annotationsBuilder = annotations.get(ifName);
        parseInterfaceInfo(update, ifName, builder, annotationsBuilder);
    });
    List<PortDescription> portDescriptionList = Lists.newArrayList();
    ports.forEach((key, value) -> {
        DefaultAnnotations annotation = annotations.get(key).build();
        portDescriptionList.add(value.annotations(annotation).build());
    });
    return portDescriptionList;
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    log.debug("Discovering port details on device {}", handler().data().deviceId());
    GetResponse response;
    try {
        response = client.get(buildPortStateRequest()).get(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        log.warn("Unable to discover ports from {}: {}", deviceId, e.getMessage());
        log.debug("{}", e);
        return Collections.emptyList();
    }
    Map<String, DefaultPortDescription.Builder> ports = Maps.newHashMap();
    Map<String, DefaultAnnotations.Builder> annotations = Maps.newHashMap();
    // Creates port descriptions with port name and port number
    response.getNotificationList().stream().flatMap(notification -> notification.getUpdateList().stream()).forEach(update -> {
        // /interfaces/interface[name=ifName]/state/...
        String ifName = update.getPath().getElem(1).getKeyMap().get("name");
        if (!ports.containsKey(ifName)) {
            ports.put(ifName, DefaultPortDescription.builder());
            annotations.put(ifName, DefaultAnnotations.builder());
        }
        DefaultPortDescription.Builder builder = ports.get(ifName);
        DefaultAnnotations.Builder annotationsBuilder = annotations.get(ifName);
        parseInterfaceInfo(update, ifName, builder, annotationsBuilder);
    });
    List<PortDescription> portDescriptionList = Lists.newArrayList();
    ports.forEach((key, value) -> {
        DefaultAnnotations annotation = annotations.get(key).build();
        portDescriptionList.add(value.annotations(annotation).build());
    });
    return portDescriptionList;
}
#end_block

#method_before
protected boolean setupBehaviour() {
    deviceId = handler().data().deviceId();
    controller = handler().get(GnmiController.class);
    client = controller.getClient(deviceId);
    if (client == null) {
        client = createClient();
    }
    if (client == null) {
        log.warn("Can not create client for {} (see log above)");
        return false;
    }
    return true;
}
#method_after
protected boolean setupBehaviour() {
    // FIXME: Should create GnmiHandshaker which initialize the client
    // instead of create client here.
    deviceId = handler().data().deviceId();
    controller = handler().get(GnmiController.class);
    client = controller.getClient(deviceId);
    if (client == null) {
        client = createClient();
    }
    if (client == null) {
        log.warn("Can not create client for {} (see log above)", deviceId);
        return false;
    }
    return true;
}
#end_block

#method_before
protected GnmiClient createClient() {
    deviceId = handler().data().deviceId();
    controller = handler().get(GnmiController.class);
    final String serverAddr = this.data().value(GNMI_SERVER_ADDR_KEY);
    final String serverPortString = this.data().value(GNMI_SERVER_PORT_KEY);
    if (serverAddr == null || serverPortString == null) {
        log.warn("Unable to create client for {}, missing driver data key (required is {}, {}, and {})", deviceId, GNMI_SERVER_ADDR_KEY, GNMI_SERVER_PORT_KEY);
        return null;
    }
    final int serverPort;
    try {
        serverPort = Integer.parseUnsignedInt(serverPortString);
    } catch (NumberFormatException e) {
        log.error("{} is not a valid gNMI port number", serverPortString);
        return null;
    }
    if (!controller.createClient(deviceId, serverAddr, serverPort)) {
        log.warn("Unable to create client for {}, aborting operation", deviceId);
        return null;
    }
    return controller.getClient(deviceId);
}
#method_after
protected GnmiClient createClient() {
    deviceId = handler().data().deviceId();
    controller = handler().get(GnmiController.class);
    final String serverAddr = this.data().value(GNMI_SERVER_ADDR_KEY);
    final String serverPortString = this.data().value(GNMI_SERVER_PORT_KEY);
    if (serverAddr == null || serverPortString == null) {
        log.warn("Unable to create client for {}, missing driver data key (required is {}, {}, and {})", deviceId, GNMI_SERVER_ADDR_KEY, GNMI_SERVER_PORT_KEY);
        return null;
    }
    final int serverPort;
    try {
        serverPort = Integer.parseUnsignedInt(serverPortString);
    } catch (NumberFormatException e) {
        log.error("{} is not a valid gNMI port number", serverPortString);
        return null;
    }
    GnmiClientKey clientKey = new GnmiClientKey(GNMI_SERVICE_NAME, deviceId, serverAddr, serverPort);
    if (!controller.createClient(clientKey)) {
        log.warn("Unable to create client for {}, aborting operation", deviceId);
        return null;
    }
    return controller.getClient(deviceId);
}
#end_block

#method_before
@Activate
public void activate() {
}
#method_after
@Activate
public void activate() {
    super.activate();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    clientKeys.keySet().forEach(this::removeClient);
    clientKeys.clear();
    clients.clear();
    channelIds.clear();
}
#method_after
@Deactivate
public void deactivate() {
    super.deactivate();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    GrpcClientKey that = (GrpcClientKey) o;
    return serverPort == that.serverPort && Objects.equal(deviceId, that.deviceId) && Objects.equal(serverAddr, that.serverAddr);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    GrpcClientKey that = (GrpcClientKey) o;
    return serverPort == that.serverPort && Objects.equal(serviceName, that.serviceName) && Objects.equal(deviceId, that.deviceId) && Objects.equal(serverAddr, that.serverAddr);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(deviceId, serverAddr, serverPort);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(serviceName, deviceId, serverAddr, serverPort);
}
#end_block

#method_before
protected MoreObjects.ToStringHelper toStringHelper() {
    return MoreObjects.toStringHelper(this).add("deviceId", deviceId).add("serverAddr", serverAddr).add("serverPort", serverPort);
}
#method_after
protected MoreObjects.ToStringHelper toStringHelper() {
    return MoreObjects.toStringHelper(this).add("serviceName", serviceName).add("deviceId", deviceId).add("serverAddr", serverAddr).add("serverPort", serverPort);
}
#end_block

#method_before
protected Void doShutdown() {
    log.debug("Shutting down client for {}...", deviceId);
    streamChannelManager.complete();
    cancellableContext.cancel(new InterruptedException("Requested client shutdown"));
    this.executorService.shutdownNow();
    try {
        executorService.awaitTermination(5, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        log.warn("Executor service didn't shutdown in time.");
        Thread.currentThread().interrupt();
    }
    return null;
}
#method_after
protected Void doShutdown() {
    streamChannelManager.complete();
    return super.doShutdown();
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    clientKeys.keySet().forEach(this::removeClient);
    clientKeys.clear();
    clients.clear();
    channelIds.clear();
}
#method_after
@Deactivate
public void deactivate() {
    clientKeys.keySet().forEach(this::removeClient);
    clientKeys.clear();
    clients.clear();
    channelIds.clear();
    log.info("Stopped");
}
#end_block

#method_before
private boolean doCreateClient(K clientKey) {
    DeviceId deviceId = clientKey.deviceId();
    String serverAddr = clientKey.serverAddr();
    int serverPort = clientKey.serverPort();
    if (clientKeys.containsKey(deviceId)) {
        final GrpcClientKey existingKey = clientKeys.get(deviceId);
        if (clientKey.equals(existingKey)) {
            log.debug("Not creating client for {} as it already exists (server={}:{})...", deviceId, serverAddr, serverPort);
            return true;
        } else {
            log.info("Requested client for {} with new " + "endpoint, removing old client (server={}:{})...", deviceId, existingKey.serverAddr(), existingKey.serverPort());
            doRemoveClient(deviceId);
        }
    }
    log.info("Creating client for {} (server={}:{})...", deviceId, serverAddr, serverPort);
    GrpcChannelId channelId = GrpcChannelId.of(clientKey.deviceId(), clientKey.serviceName() + "-" + clientKey);
    ManagedChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(serverAddr, serverPort).maxInboundMessageSize(DEFAULT_MAX_INBOUND_MSG_SIZE * MEGABYTES).usePlaintext();
    ManagedChannel channel;
    try {
        channel = grpcChannelController.connectChannel(channelId, channelBuilder);
    } catch (IOException e) {
        log.warn("Unable to connect to gRPC server of {}: {}", clientKey.deviceId(), e.getMessage());
        return false;
    }
    clientKeys.put(deviceId, clientKey);
    clients.put(clientKey, createClientInstance(clientKey, channel));
    channelIds.put(deviceId, channelId);
    return true;
}
#method_after
private boolean doCreateClient(K clientKey) {
    DeviceId deviceId = clientKey.deviceId();
    String serverAddr = clientKey.serverAddr();
    int serverPort = clientKey.serverPort();
    if (clientKeys.containsKey(deviceId)) {
        final GrpcClientKey existingKey = clientKeys.get(deviceId);
        if (clientKey.equals(existingKey)) {
            log.debug("Not creating client for {} as it already exists (key={})...", deviceId, clientKey);
            return true;
        } else {
            log.info("Requested client for {} with new " + "endpoint, removing old client (key={})...", deviceId, clientKey);
            doRemoveClient(deviceId);
        }
    }
    log.info("Creating client for {} (server={}:{})...", deviceId, serverAddr, serverPort);
    GrpcChannelId channelId = GrpcChannelId.of(clientKey.deviceId(), clientKey.toString());
    ManagedChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(serverAddr, serverPort).maxInboundMessageSize(DEFAULT_MAX_INBOUND_MSG_SIZE * MEGABYTES).usePlaintext();
    ManagedChannel channel;
    try {
        channel = grpcChannelController.connectChannel(channelId, channelBuilder);
    } catch (IOException e) {
        log.warn("Unable to connect to gRPC server of {}: {}", clientKey.deviceId(), e.getMessage());
        return false;
    }
    C client = createClientInstance(clientKey, channel);
    if (client == null) {
        log.warn("Cannot create client for {} (key={})", deviceId, clientKey);
        return false;
    }
    clientKeys.put(deviceId, clientKey);
    clients.put(clientKey, client);
    channelIds.put(deviceId, channelId);
    return true;
}
#end_block

#method_before
@Activate
public void activate() {
    eventDispatcher.addSink(P4RuntimeEvent.class, listenerRegistry);
    electionIdGenerator = new DistributedElectionIdGenerator(storageService);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    super.activate();
    eventDispatcher.addSink(P4RuntimeEvent.class, listenerRegistry);
    electionIdGenerator = new DistributedElectionIdGenerator(storageService);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    deviceAgentListeners.clear();
    grpcChannelController = null;
    electionIdGenerator.destroy();
    electionIdGenerator = null;
    eventDispatcher.removeSink(P4RuntimeEvent.class);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    super.deactivate();
    deviceAgentListeners.clear();
    electionIdGenerator.destroy();
    electionIdGenerator = null;
    log.info("Stopped");
}
#end_block

#method_before
@Override
public List<CharSequence> enable(PortNumber client, PortNumber line, boolean enable) {
    log.info("enable() infinera route");
    DeviceId did = this.data().deviceId();
    Port clientPort = handler().get(DeviceService.class).getPort(did, client);
    if (clientPort == null) {
        log.warn("{} does not exist on {}", client, did);
        return Collections.emptyList();
    }
    String clientName = clientPort.annotations().value(OC_NAME);
    if (Strings.isNullOrEmpty(clientName)) {
        log.warn("{} annotations not exist on {}@{}", OC_NAME, client, did);
        return Collections.emptyList();
    }
    Port linePort = handler().get(DeviceService.class).getPort(did, line);
    if (linePort == null) {
        log.warn("{} does not exist on {}", line, did);
        return Collections.emptyList();
    }
    String lineName = linePort.annotations().value(OC_NAME);
    if (Strings.isNullOrEmpty(lineName)) {
        log.warn("{} annotations not exist on {}@{}", OC_NAME, line, did);
        return Collections.emptyList();
    }
    DataNodeWithAnnotations nodes = Infinera.enable(clientName, lineName, enable);
    for (AnnotatedNodeInfo annote : nodes.annodatedNodeInfos()) {
        log.info("AnnotatedNodeInfo.resourceId={}", annote.resourceId());
        log.info("AnnotatedNodeInfo.annotations={}", annote.annotations());
    }
    ResourceId empty = ResourceId.builder().build();
    return nodes.nodes().stream().map(node -> toCharSequence(toXmlCompositeStream(toCompositeDataWithAnnotationData(toResourceData(empty, node), nodes.annodatedNodeInfos())))).collect(Collectors.toList());
}
#method_after
@Override
public List<CharSequence> enable(PortNumber client, PortNumber line, boolean enable) {
    log.debug("enable() infinera route");
    DeviceId did = this.data().deviceId();
    Port clientPort = handler().get(DeviceService.class).getPort(did, client);
    if (clientPort == null) {
        log.warn("{} does not exist on {}", client, did);
        return Collections.emptyList();
    }
    String clientName = clientPort.annotations().value(OC_NAME);
    if (Strings.isNullOrEmpty(clientName)) {
        log.warn("{} annotations not exist on {}@{}", OC_NAME, client, did);
        return Collections.emptyList();
    }
    Port linePort = handler().get(DeviceService.class).getPort(did, line);
    if (linePort == null) {
        log.warn("{} does not exist on {}", line, did);
        return Collections.emptyList();
    }
    String lineName = linePort.annotations().value(OC_NAME);
    if (Strings.isNullOrEmpty(lineName)) {
        log.warn("{} annotations not exist on {}@{}", OC_NAME, line, did);
        return Collections.emptyList();
    }
    // create <terminal-device xmlns="http://openconfig.net/yang/terminal-device">
    // </terminal-device>
    OpenConfigTerminalDeviceHandler terminalDevice = new OpenConfigTerminalDeviceHandler();
    // add <logical-channels></logical-channels>
    OpenConfigLogicalChannelsHandler logicalChannels = new OpenConfigLogicalChannelsHandler(terminalDevice);
    // add <channel><index>"clientName"</index></channel>
    OpenConfigChannelHandler channel = new OpenConfigChannelHandler(clientName, logicalChannels);
    // add <config><index>"clientName"</index></config>
    OpenConfigConfigOfChannelHandler configOfChannel = new OpenConfigConfigOfChannelHandler(channel);
    configOfChannel.addIndex(clientName);
    // add <logical-channel-assignments xc:operation="merge/delete">
    OpenConfigLogicalChannelAssignmentsHandler logicalChannelAssignments = new OpenConfigLogicalChannelAssignmentsHandler(channel);
    if (enable) {
        logicalChannelAssignments.addAnnotation(ANOTATION_NAME, Operation.MERGE.value());
    } else {
        logicalChannelAssignments.addAnnotation(ANOTATION_NAME, Operation.DELETE.value());
    }
    // add <assignment><index>"clientName"</index></assignment>
    OpenConfigAssignmentHandler assignment = new OpenConfigAssignmentHandler(clientName, logicalChannelAssignments);
    // add <config><assignment-type>LOGICAL_CHANNEL</assignment-type>
    // <logical-channel>"lineName"</logical-channel>
    // <allocation>100</allocation>
    // </config>
    OpenConfigConfigOfAssignmentHandler configOfAssignment = new OpenConfigConfigOfAssignmentHandler(assignment);
    configOfAssignment.addAssignmentType(AssignmentTypeEnum.LOGICAL_CHANNEL);
    configOfAssignment.addLogicalChannel(lineName);
    configOfAssignment.addAllocation(BigDecimal.valueOf(100));
    return terminalDevice.getListCharSequence();
}
#end_block

#method_before
public static CompositeData toCompositeData(ResourceData input) {
    CompositeData.Builder builder = DefaultCompositeData.builder();
    builder.resourceData(input);
    return builder.build();
}
#method_after
public static CompositeData toCompositeData(ResourceData input, List<AnnotatedNodeInfo> annotatedNodeInfos) {
    CompositeData.Builder builder = DefaultCompositeData.builder();
    builder.resourceData(input);
    // Set AnnotationNodeInfo
    annotatedNodeInfos.stream().forEach(a -> builder.addAnnotatedNodeInfo(a));
    return builder.build();
}
#end_block

#method_before
@Override
public List<CharSequence> enable(String component, boolean enable) {
    DataNodeWithAnnotations nodes = Transceiver.enable(component, enable);
    for (AnnotatedNodeInfo annote : nodes.annodatedNodeInfos()) {
        log.debug("resourceId={}", annote.resourceId());
        log.debug("annotations={}", annote.annotations());
    }
    ResourceId empty = ResourceId.builder().build();
    return nodes.nodes().stream().map(node -> toCharSequence(toXmlCompositeStream(toCompositeDataWithAnnotationData(toResourceData(empty, node), nodes.annodatedNodeInfos())))).collect(Collectors.toList());
}
#method_after
@Override
public List<CharSequence> enable(String componentName, boolean enable) {
    // create <components xmlns="http://openconfig.net/yang/platform"
    // xc:operation="merge/delete">
    // </components>
    OpenConfigComponentsHandler components = new OpenConfigComponentsHandler();
    if (enable) {
        components.addAnnotation(ANOTATION_NAME, Operation.MERGE.value());
    } else {
        components.addAnnotation(ANOTATION_NAME, Operation.DELETE.value());
    }
    // add <component><name>"componentName"</name></component>
    OpenConfigComponentHandler component = new OpenConfigComponentHandler(componentName, components);
    // add <config><name>"componentName"</name></config>
    OpenConfigConfigOfComponentHandler configOfComponent = new OpenConfigConfigOfComponentHandler(component);
    configOfComponent.addName(componentName);
    // add <transceiver xmlns="http://openconfig.net/yang/platform/transceiver"></transceiver>
    OpenConfigTransceiverHandler transceiver = new OpenConfigTransceiverHandler(component);
    // add <config><enabled>true/false</enabled></config>
    OpenConfigConfigOfTransceiverHandler configOfTransceiver = new OpenConfigConfigOfTransceiverHandler(transceiver);
    configOfTransceiver.addEnabled(enable);
    return components.getListCharSequence();
}
#end_block

#method_before
@Override
public ByteBuffer createDeviceDataBuffer(PiPipeconf pipeconf) {
    checkArgument(pipeconf.id().equals(MLNX_FABRIC_PIPECONF_ID), format("Cannot program Spectrum device with a pipeconf " + "other than '%s' (found '%s')", MLNX_FABRIC_PIPECONF_ID, pipeconf.id()));
    List<ByteBuffer> buffers = Lists.newLinkedList();
    try {
        buffers.add(extensionBuffer(pipeconf, SPECTRUM_BIN));
    } catch (ExtensionException e) {
        return null;
    }
    // Concatenate buffers (flip so they can be read).
    int len = buffers.stream().mapToInt(Buffer::limit).sum();
    ByteBuffer deviceData = ByteBuffer.allocate(len);
    buffers.forEach(b -> deviceData.put((ByteBuffer) b.flip()));
    deviceData.flip();
    return deviceData.asReadOnlyBuffer();
}
#method_after
@Override
public ByteBuffer createDeviceDataBuffer(PiPipeconf pipeconf) {
    log.debug("Creating device data buffer for {} in pipeconf {}", SPECTRUM_BIN, pipeconf.id());
    ByteBuffer deviceData;
    try {
        deviceData = extensionBuffer(pipeconf, SPECTRUM_BIN);
    } catch (ExtensionException e) {
        log.error("Failed to create device data buffer for {} in pipeconf {}", SPECTRUM_BIN, pipeconf.id());
        return null;
    }
    // flip buffer data so they can be read
    deviceData.flip();
    return deviceData.asReadOnlyBuffer();
}
#end_block

#method_before
private ByteBuffer extensionBuffer(PiPipeconf pipeconf, ExtensionType extType) {
    if (!pipeconf.extension(extType).isPresent()) {
        log.warn("Missing *SPECTRUM* extension {} in pipeconf {}", extType, pipeconf.id());
        throw new ExtensionException();
    }
    try {
        byte[] bytes = IOUtils.toByteArray(pipeconf.extension(extType).get());
        // Length of the extension + bytes.
        return ByteBuffer.allocate(bytes.length).order(ByteOrder.LITTLE_ENDIAN).put(bytes);
    } catch (IOException ex) {
        log.warn("Unable to read extension {} from pipeconf {}: {}", extType, pipeconf.id(), ex.getMessage());
        throw new ExtensionException();
    }
}
#method_after
private ByteBuffer extensionBuffer(PiPipeconf pipeconf, ExtensionType extType) {
    if (!pipeconf.extension(extType).isPresent()) {
        log.warn("Missing extension {} in pipeconf {}", extType, pipeconf.id());
        throw new ExtensionException();
    }
    try {
        byte[] bytes = IOUtils.toByteArray(pipeconf.extension(extType).get());
        // Length of the extension + bytes.
        return ByteBuffer.allocate(bytes.length).order(ByteOrder.LITTLE_ENDIAN).put(bytes);
    } catch (IOException ex) {
        log.warn("Unable to read extension {} from pipeconf {}: {}", extType, pipeconf.id(), ex.getMessage());
        throw new ExtensionException();
    }
}
#end_block

#method_before
@Override
protected void execute() {
    RouteAdminService service = AbstractShellCommand.get(RouteAdminService.class);
    IpPrefix prefix = IpPrefix.valueOf(prefixString);
    IpAddress nextHop = IpAddress.valueOf(nextHopString);
    service.withdraw(Collections.singleton(new Route(Route.Source.valueOf(source), prefix, nextHop)));
}
#method_after
@Override
protected void execute() {
    RouteAdminService service = AbstractShellCommand.get(RouteAdminService.class);
    IpPrefix prefix = IpPrefix.valueOf(prefixString);
    IpAddress nextHop = IpAddress.valueOf(nextHopString);
    // Routes through cli without mentioning source then it is created as STATIC,
    // otherwise routes are created with corresponding source.
    Route route = source == null ? new Route(Route.Source.STATIC, prefix, nextHop) : new Route(Route.Source.valueOf(source), prefix, nextHop);
    service.withdraw(Collections.singleton(route));
}
#end_block

#method_before
private void processHostRemoved(Host host) {
    MacAddress hostMac = host.mac();
    VlanId hostVlanId = host.vlan();
    Set<HostLocation> locations = host.locations();
    Set<IpAddress> ips = host.ipAddresses();
    log.info("Host {}/{} is removed from {}", hostMac, hostVlanId, locations);
    // Check if the host still exists in the host store
    if (hostService.getHost(host.id()) == null) {
        log.debug("Host entry for host {} no more present. Aborting hostprobe for this host");
        return;
    }
    locations.forEach(location -> {
        if (isDoubleTaggedHost(host)) {
            ips.forEach(ip -> processDoubleTaggedRoutingRule(location.deviceId(), location.port(), hostMac, host.innerVlan(), hostVlanId, host.tpid(), ip, true));
        } else {
            processBridgingRule(location.deviceId(), location.port(), hostMac, hostVlanId, true);
            ips.forEach(ip -> processRoutingRule(location.deviceId(), location.port(), hostMac, hostVlanId, ip, true));
        }
        // Also remove redirection flows on the pair device if exists.
        Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(location.deviceId());
        Optional<PortNumber> pairLocalPort = srManager.getPairLocalPort(location.deviceId());
        if (pairDeviceId.isPresent() && pairLocalPort.isPresent()) {
            // NOTE: Since the pairLocalPort is trunk port, use assigned vlan of original port
            // when the host is untagged
            VlanId vlanId = vlanForPairPort(hostVlanId, location);
            if (vlanId == null) {
                return;
            }
            processBridgingRule(pairDeviceId.get(), pairLocalPort.get(), hostMac, vlanId, true);
            ips.forEach(ip -> processRoutingRule(pairDeviceId.get(), pairLocalPort.get(), hostMac, vlanId, ip, true));
        }
        // Delete prefix from sr-device-subnet when the next hop host is removed
        srManager.routeService.getRouteTables().forEach(tableId -> {
            srManager.routeService.getRoutes(tableId).forEach(routeInfo -> {
                if (routeInfo.allRoutes().stream().anyMatch(rr -> ips.contains(rr.nextHop()))) {
                    log.debug("HostRemoved. removeSubnet {}, {}", location, routeInfo.prefix());
                    srManager.deviceConfiguration.removeSubnet(location, routeInfo.prefix());
                }
            });
        });
    });
}
#method_after
private void processHostRemoved(Host host) {
    MacAddress hostMac = host.mac();
    VlanId hostVlanId = host.vlan();
    Set<HostLocation> locations = host.locations();
    Set<IpAddress> ips = host.ipAddresses();
    log.info("Host {}/{} is removed from {}", hostMac, hostVlanId, locations);
    locations.forEach(location -> {
        if (isDoubleTaggedHost(host)) {
            ips.forEach(ip -> processDoubleTaggedRoutingRule(location.deviceId(), location.port(), hostMac, host.innerVlan(), hostVlanId, host.tpid(), ip, true));
        } else {
            processBridgingRule(location.deviceId(), location.port(), hostMac, hostVlanId, true);
            ips.forEach(ip -> processRoutingRule(location.deviceId(), location.port(), hostMac, hostVlanId, ip, true));
        }
        // Also remove redirection flows on the pair device if exists.
        Optional<DeviceId> pairDeviceId = srManager.getPairDeviceId(location.deviceId());
        Optional<PortNumber> pairLocalPort = srManager.getPairLocalPort(location.deviceId());
        if (pairDeviceId.isPresent() && pairLocalPort.isPresent()) {
            // NOTE: Since the pairLocalPort is trunk port, use assigned vlan of original port
            // when the host is untagged
            VlanId vlanId = vlanForPairPort(hostVlanId, location);
            if (vlanId == null) {
                return;
            }
            processBridgingRule(pairDeviceId.get(), pairLocalPort.get(), hostMac, vlanId, true);
            ips.forEach(ip -> processRoutingRule(pairDeviceId.get(), pairLocalPort.get(), hostMac, vlanId, ip, true));
        }
        // Delete prefix from sr-device-subnet when the next hop host is removed
        srManager.routeService.getRouteTables().forEach(tableId -> {
            srManager.routeService.getRoutes(tableId).forEach(routeInfo -> {
                if (routeInfo.allRoutes().stream().anyMatch(rr -> ips.contains(rr.nextHop()))) {
                    log.debug("HostRemoved. removeSubnet {}, {}", location, routeInfo.prefix());
                    srManager.deviceConfiguration.removeSubnet(location, routeInfo.prefix());
                }
            });
        });
    });
}
#end_block

#method_before
private void probe(Host host, ConnectPoint location, DeviceId pairDeviceId, PortNumber pairRemotePort) {
    VlanId vlanToProbe = host.vlan().equals(VlanId.NONE) ? srManager.getInternalVlanId(location) : host.vlan();
    if (srManager.symmetricProbing) {
        srManager.interfaceService.getInterfaces().stream().filter(i -> i.vlanTagged().contains(vlanToProbe) || i.vlanUntagged().equals(vlanToProbe) || i.vlanNative().equals(vlanToProbe)).filter(i -> i.connectPoint().deviceId().equals(pairDeviceId)).filter(i -> i.connectPoint().port().equals(location.port())).forEach(i -> {
            log.debug("Probing host {} on pair device {}", host.id(), i.connectPoint());
            srManager.probingService.probeHost(host, i.connectPoint(), ProbeMode.DISCOVER);
        });
    } else {
        srManager.interfaceService.getInterfaces().stream().filter(i -> i.vlanTagged().contains(vlanToProbe) || i.vlanUntagged().equals(vlanToProbe) || i.vlanNative().equals(vlanToProbe)).filter(i -> i.connectPoint().deviceId().equals(pairDeviceId)).filter(i -> !i.connectPoint().port().equals(pairRemotePort)).forEach(i -> {
            log.debug("Probing host {} on pair device {}", host.id(), i.connectPoint());
            srManager.probingService.probeHost(host, i.connectPoint(), ProbeMode.DISCOVER);
        });
    }
}
#method_after
private void probe(Host host, ConnectPoint location, DeviceId pairDeviceId, PortNumber pairRemotePort) {
    // Check if the host still exists in the host store
    if (hostService.getHost(host.id()) == null) {
        log.debug("Host entry for host {} no more present. Aborting hostprobe discover for this host", host.id());
        return;
    }
    VlanId vlanToProbe = host.vlan().equals(VlanId.NONE) ? srManager.getInternalVlanId(location) : host.vlan();
    if (srManager.symmetricProbing) {
        srManager.interfaceService.getInterfaces().stream().filter(i -> i.vlanTagged().contains(vlanToProbe) || i.vlanUntagged().equals(vlanToProbe) || i.vlanNative().equals(vlanToProbe)).filter(i -> i.connectPoint().deviceId().equals(pairDeviceId)).filter(i -> i.connectPoint().port().equals(location.port())).forEach(i -> {
            log.debug("Probing host {} on pair device {}", host.id(), i.connectPoint());
            srManager.probingService.probeHost(host, i.connectPoint(), ProbeMode.DISCOVER);
        });
    } else {
        srManager.interfaceService.getInterfaces().stream().filter(i -> i.vlanTagged().contains(vlanToProbe) || i.vlanUntagged().equals(vlanToProbe) || i.vlanNative().equals(vlanToProbe)).filter(i -> i.connectPoint().deviceId().equals(pairDeviceId)).filter(i -> !i.connectPoint().port().equals(pairRemotePort)).forEach(i -> {
            log.debug("Probing host {} on pair device {}", host.id(), i.connectPoint());
            srManager.probingService.probeHost(host, i.connectPoint(), ProbeMode.DISCOVER);
        });
    }
}
#end_block

#method_before
static PiActionGroup translate(Group group, PiPipeconf pipeconf, Device device) throws PiTranslationException {
    if (!SUPPORTED_GROUP_TYPES.contains(group.type())) {
        throw new PiTranslationException(format("group type %s not supported", group.type()));
    }
    final PiPipelineInterpreter interpreter = getInterpreterOrNull(device, pipeconf);
    final PiActionGroup.Builder piActionGroupBuilder = PiActionGroup.builder().withId(PiActionGroupId.of(group.id().id()));
    if (!(group.appCookie() instanceof PiGroupKey)) {
        throw new PiTranslationException("group app cookie is not PI (class should be PiGroupKey)");
    }
    final PiGroupKey groupKey = (PiGroupKey) group.appCookie();
    piActionGroupBuilder.withActionProfileId(groupKey.actionProfileId());
    // Translate group buckets to PI group members
    short bucketIdx = 0;
    for (GroupBucket bucket : group.buckets().buckets()) {
        /*
            FIXME: the way member IDs are computed can cause collisions!
            Problem:
            In P4Runtime action group members, i.e. action buckets, are associated to a numeric ID chosen
            at member insertion time. This ID must be unique for the whole action profile (i.e. the group table in
            OpenFlow). In ONOS, GroupBucket doesn't specify any ID.

            Solutions:
            - Change GroupBucket API to force application wanting to perform group operations to specify a member id.
            - Maintain state to dynamically allocate/deallocate member IDs, e.g. in a dedicated service, or in a
            P4Runtime Group Provider.

            Hack:
            Statically derive member ID by combining groupId and position of the bucket in the list.
             */
        ByteBuffer bb = ByteBuffer.allocate(4).putShort((short) (group.id().id() & 0xffff)).putShort(bucketIdx);
        bb.rewind();
        int memberId = bb.getInt();
        bucketIdx++;
        final PiTableAction tableAction = translateTreatment(bucket.treatment(), interpreter, groupKey.tableId(), pipeconf.pipelineModel());
        if (tableAction == null) {
            return null;
        }
        if (tableAction.type() != ACTION) {
            throw new PiTranslationException(format("PI table action of type %s is not supported in groups", tableAction.type()));
        }
        piActionGroupBuilder.addMember(PiActionGroupMember.builder().forActionProfile(groupKey.actionProfileId()).withId(PiActionGroupMemberId.of(memberId)).withAction((PiAction) tableAction).withWeight(bucket.weight()).build());
    }
    return piActionGroupBuilder.build();
}
#method_after
static PiActionGroup translate(Group group, PiPipeconf pipeconf, Device device) throws PiTranslationException {
    if (!SUPPORTED_GROUP_TYPES.contains(group.type())) {
        throw new PiTranslationException(format("group type %s not supported", group.type()));
    }
    final PiPipelineInterpreter interpreter = getInterpreterOrNull(device, pipeconf);
    final PiActionGroup.Builder piActionGroupBuilder = PiActionGroup.builder().withId(PiActionGroupId.of(group.id().id()));
    if (!(group.appCookie() instanceof PiGroupKey)) {
        throw new PiTranslationException("group app cookie is not PI (class should be PiGroupKey)");
    }
    final PiGroupKey groupKey = (PiGroupKey) group.appCookie();
    piActionGroupBuilder.withActionProfileId(groupKey.actionProfileId());
    // Translate group buckets to PI group members
    short bucketIdx = 0;
    for (GroupBucket bucket : group.buckets().buckets()) {
        /*
            FIXME: the way member IDs are computed can cause collisions!
            Problem:
            In P4Runtime action group members, i.e. action buckets, are associated to a numeric ID chosen
            at member insertion time. This ID must be unique for the whole action profile (i.e. the group table in
            OpenFlow). In ONOS, GroupBucket doesn't specify any ID.

            Solutions:
            - Change GroupBucket API to force application wanting to perform group operations to specify a member id.
            - Maintain state to dynamically allocate/deallocate member IDs, e.g. in a dedicated service, or in a
            P4Runtime Group Provider.

            Hack:
            Statically derive member ID by combining groupId and position of the bucket in the list.
             */
        ByteBuffer bb = ByteBuffer.allocate(4).putShort((short) (group.id().id() & 0xffff)).putShort(bucketIdx);
        bb.rewind();
        int memberId = bb.getInt();
        bucketIdx++;
        final PiTableAction tableAction = translateTreatment(bucket.treatment(), interpreter, groupKey.tableId(), pipeconf.pipelineModel());
        if (tableAction == null) {
            throw new PiTranslationException("The PI table action returned by the interpreter is null");
        }
        if (tableAction.type() != ACTION) {
            throw new PiTranslationException(format("PI table action of type %s is not supported in groups", tableAction.type()));
        }
        piActionGroupBuilder.addMember(PiActionGroupMember.builder().forActionProfile(groupKey.actionProfileId()).withId(PiActionGroupMemberId.of(memberId)).withAction((PiAction) tableAction).withWeight(bucket.weight()).build());
    }
    return piActionGroupBuilder.build();
}
#end_block

#method_before
public Set<FabricNetwork> fabricNetworks() {
    Set<FabricNetwork> fabricNetworks = Sets.newHashSet();
    JsonNode fabricNetworkNodes = object.get(FABRIC_NETWORKS);
    if (fabricNetworkNodes == null) {
        return fabricNetworks;
    }
    fabricNetworkNodes.forEach(jsonNode -> {
        Set<String> ifaces = Sets.newHashSet();
        JsonNode fabricNetworkIfaces = jsonNode.path(INTERFACES);
        if (fabricNetworkIfaces == null) {
            log.warn("Fabric network interfaces cannot find {}; skip: jsonNode={}", INTERFACES, jsonNode);
        } else if (!fabricNetworkIfaces.toString().isEmpty()) {
            fabricNetworkIfaces.forEach(ifacesNode -> ifaces.add(ifacesNode.asText()));
        }
        // NONE or VLAN
        String encapsulation = NONE_ENCAPSULATION;
        if (jsonNode.hasNonNull(ENCAPSULATION)) {
            encapsulation = jsonNode.get(ENCAPSULATION).asText();
        }
        boolean isForward = true;
        if (jsonNode.hasNonNull(IS_FORWARD)) {
            isForward = jsonNode.get(IS_FORWARD).asBoolean();
        }
        boolean isBroadcast = true;
        if (jsonNode.hasNonNull(IS_BROADCAST)) {
            isBroadcast = jsonNode.get(IS_BROADCAST).asBoolean();
        }
        try {
            fabricNetworks.add(DefaultFabricNetwork.builder().name(jsonNode.get(NAME).asText()).interfaceNames(ifaces).encapsulation(EncapsulationType.enumFromString(encapsulation)).forward(isForward).broadcast(isBroadcast).build());
        } catch (Exception e) {
            log.warn("Fabric Network parse failed; skip: jsonNode={}", jsonNode);
        }
    });
    return fabricNetworks;
}
#method_after
public Set<FabricNetwork> fabricNetworks() {
    Set<FabricNetwork> fabricNetworks = Sets.newHashSet();
    JsonNode fabricNetworkNodes = object.get(FABRIC_NETWORKS);
    if (fabricNetworkNodes == null) {
        return fabricNetworks;
    }
    fabricNetworkNodes.forEach(jsonNode -> {
        Set<String> ifaces = Sets.newHashSet();
        JsonNode fabricNetworkIfaces = jsonNode.path(INTERFACES);
        if (fabricNetworkIfaces == null) {
            log.warn("Fabric network interfaces cannot find {}; skip: jsonNode={}", INTERFACES, jsonNode);
        } else if (!fabricNetworkIfaces.toString().isEmpty()) {
            fabricNetworkIfaces.forEach(ifacesNode -> ifaces.add(ifacesNode.asText()));
        }
        // NONE or VLAN
        String encapsulation = NONE_ENCAPSULATION;
        if (jsonNode.hasNonNull(ENCAPSULATION)) {
            encapsulation = jsonNode.get(ENCAPSULATION).asText();
        }
        boolean isForward = true;
        if (jsonNode.hasNonNull(IS_FORWARD)) {
            isForward = jsonNode.get(IS_FORWARD).asBoolean();
        }
        boolean isBroadcast = true;
        if (jsonNode.hasNonNull(IS_BROADCAST)) {
            isBroadcast = jsonNode.get(IS_BROADCAST).asBoolean();
        }
        try {
            fabricNetworks.add(DefaultFabricNetwork.builder().name(jsonNode.get(NAME).asText()).interfaceNames(ifaces).encapsulation(EncapsulationType.enumFromString(encapsulation)).forward(isForward).broadcast(isBroadcast).build());
        } catch (Exception e) {
            log.warn("Fabric network parse failed; skip: jsonNode={}", jsonNode);
        }
    });
    return fabricNetworks;
}
#end_block

#method_before
public Set<FabricRoute> fabricRoutes() {
    Set<FabricRoute> routes = Sets.newHashSet();
    JsonNode routesNode = object.get(FABRIC_ROUTES);
    if (routesNode == null) {
        // log.warn("simple fabric network config fabricRoutes is null!");
        return routes;
    }
    routesNode.forEach(jsonNode -> {
        try {
            routes.add(DefaultFabricRoute.builder().source(FabricRoute.Source.STATIC).prefix(IpPrefix.valueOf(jsonNode.path(IP_PREFIX).asText())).nextHop(IpAddress.valueOf(jsonNode.path(NEXT_HOP).asText())).build());
        } catch (IllegalArgumentException e) {
            log.warn("Fabric Router parse error; skip: jsonNode={}", jsonNode);
        }
    });
    return routes;
}
#method_after
public Set<FabricRoute> fabricRoutes() {
    Set<FabricRoute> routes = Sets.newHashSet();
    JsonNode routesNode = object.get(FABRIC_ROUTES);
    if (routesNode == null) {
        return routes;
    }
    routesNode.forEach(jsonNode -> {
        try {
            routes.add(DefaultFabricRoute.builder().source(FabricRoute.Source.STATIC).prefix(IpPrefix.valueOf(jsonNode.path(PREFIX).asText())).nextHop(IpAddress.valueOf(jsonNode.path(NEXT_HOP).asText())).build());
        } catch (IllegalArgumentException e) {
            log.warn("Fabric router parse error; skip: jsonNode={}", jsonNode);
        }
    });
    return routes;
}
#end_block

#method_before
// Set up from configuration
private boolean refresh() {
    log.debug("simple fabric refresh");
    boolean dirty = false;
    SimpleFabricConfig config = configService.getConfig(coreService.registerApplication(APP_ID), SimpleFabricConfig.class);
    if (config == null) {
        log.debug("No simple fabric config available!");
        return false;
    }
    // fabricNetworks
    Set<FabricNetwork> newFabricNetworks = new HashSet<>();
    Set<Interface> newNetworkInterfaces = new HashSet<>();
    for (FabricNetwork newFabricNetworkConfig : config.fabricNetworks()) {
        FabricNetwork newFabricNetwork = DefaultFabricNetwork.of(newFabricNetworkConfig);
        // fill up interfaces and Hosts with active port only
        for (String ifaceName : newFabricNetworkConfig.interfaceNames()) {
            Interface iface = getInterfaceByName(ifaceName);
            if (iface != null && deviceService.isAvailable(iface.connectPoint().deviceId())) {
                newFabricNetwork.addInterface(iface);
                newNetworkInterfaces.add(iface);
            }
        }
        for (Host host : hostService.getHosts()) {
            // consider host with ip only
            if (!host.ipAddresses().isEmpty()) {
                Interface iface = findAvailableDeviceHostInterface(host);
                if (iface != null && newFabricNetwork.contains(iface)) {
                    newFabricNetwork.addHost(host);
                }
            }
        }
        newFabricNetwork.setDirty(true);
        // update newFabricNetwork's isDirty flags if same entry already exists
        for (FabricNetwork prevFabricNetwork : fabricNetworks) {
            if (prevFabricNetwork.equals(newFabricNetwork)) {
                newFabricNetwork.setDirty(prevFabricNetwork.isDirty());
                break;
            }
        }
        newFabricNetworks.add(newFabricNetwork);
    }
    if (!fabricNetworks.equals(newFabricNetworks)) {
        fabricNetworks = newFabricNetworks;
        dirty = true;
    }
    if (!networkInterfaces.equals(newNetworkInterfaces)) {
        networkInterfaces = newNetworkInterfaces;
        dirty = true;
    }
    // defaultFabricIpSubnets
    Set<FabricIpSubnet> newFabricIpSubnets = config.fabricIpSubnets();
    InvertedRadixTree<FabricIpSubnet> newIp4SubnetTable = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
    InvertedRadixTree<FabricIpSubnet> newIp6SubnetTable = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
    Map<IpAddress, MacAddress> newVirtualGatewayIpMacMap = Maps.newConcurrentMap();
    for (FabricIpSubnet subnet : newFabricIpSubnets) {
        if (subnet.ipPrefix().isIp4()) {
            newIp4SubnetTable.put(createBinaryString(subnet.ipPrefix()), subnet);
        } else {
            newIp6SubnetTable.put(createBinaryString(subnet.ipPrefix()), subnet);
        }
        newVirtualGatewayIpMacMap.put(subnet.gatewayIp(), subnet.gatewayMac());
    }
    if (!fabricIpSubnets.equals(newFabricIpSubnets)) {
        fabricIpSubnets = newFabricIpSubnets;
        ip4SubnetTable = newIp4SubnetTable;
        ip6SubnetTable = newIp6SubnetTable;
        dirty = true;
    }
    if (!virtualGatewayIpMacMap.equals(newVirtualGatewayIpMacMap)) {
        virtualGatewayIpMacMap = newVirtualGatewayIpMacMap;
        dirty = true;
    }
    // fabricRoutes config handling
    Set<FabricRoute> newFabricRoutes = config.fabricRoutes();
    if (!fabricRoutes.equals(newFabricRoutes)) {
        InvertedRadixTree<FabricRoute> newIp4BorderRouteTable = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
        InvertedRadixTree<FabricRoute> newIp6BorderRouteTable = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
        for (FabricRoute route : newFabricRoutes) {
            if (route.prefix().isIp4()) {
                newIp4BorderRouteTable.put(createBinaryString(route.prefix()), route);
            } else {
                newIp6BorderRouteTable.put(createBinaryString(route.prefix()), route);
            }
        }
        fabricRoutes = newFabricRoutes;
        ip4BorderRouteTable = newIp4BorderRouteTable;
        ip6BorderRouteTable = newIp6BorderRouteTable;
        dirty = true;
    }
    // notify to SimpleFabric listeners
    if (dirty) {
        log.info("simple fabric refresh; notify events");
        process(new SimpleFabricEvent(SimpleFabricEvent.Type.SIMPLE_FABRIC_UPDATED, "updated"));
    }
    return dirty;
}
#method_after
// Set up from configuration
private boolean refresh() {
    log.debug("simple fabric refresh");
    boolean dirty = false;
    SimpleFabricConfig config = configService.getConfig(coreService.registerApplication(APP_ID), SimpleFabricConfig.class);
    if (config == null) {
        log.debug("No simple fabric config available!");
        return false;
    }
    // fabricNetworks
    Set<FabricNetwork> newFabricNetworks = new HashSet<>();
    Set<Interface> newInterfaces = new HashSet<>();
    for (FabricNetwork newFabricNetworkConfig : config.fabricNetworks()) {
        FabricNetwork newFabricNetwork = DefaultFabricNetwork.of(newFabricNetworkConfig);
        // fill up interfaces and Hosts with active port only
        for (String ifaceName : newFabricNetworkConfig.interfaceNames()) {
            Interface iface = getInterfaceByName(ifaceName);
            if (iface != null && deviceService.isAvailable(iface.connectPoint().deviceId())) {
                newFabricNetwork.addInterface(iface);
                newInterfaces.add(iface);
            }
        }
        for (Host host : hostService.getHosts()) {
            // consider host with ip only
            if (!host.ipAddresses().isEmpty()) {
                Interface iface = findAvailableDeviceHostInterface(host);
                if (iface != null && newFabricNetwork.contains(iface)) {
                    newFabricNetwork.addHost(host);
                }
            }
        }
        newFabricNetwork.setDirty(true);
        // update newFabricNetwork's isDirty flags if same entry already exists
        for (FabricNetwork prevFabricNetwork : fabricNetworks) {
            if (prevFabricNetwork.equals(newFabricNetwork)) {
                newFabricNetwork.setDirty(prevFabricNetwork.isDirty());
                break;
            }
        }
        newFabricNetworks.add(newFabricNetwork);
    }
    if (!fabricNetworks.equals(newFabricNetworks)) {
        fabricNetworks = newFabricNetworks;
        dirty = true;
    }
    if (!networkInterfaces.equals(newInterfaces)) {
        networkInterfaces = newInterfaces;
        dirty = true;
    }
    // default Fabric Subnets
    Set<FabricSubnet> newFabricSubnets = config.fabricSubnets();
    InvertedRadixTree<FabricSubnet> newIp4SubnetTable = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
    InvertedRadixTree<FabricSubnet> newIp6SubnetTable = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
    Map<IpAddress, MacAddress> newVirtualGatewayIpMacMap = Maps.newConcurrentMap();
    for (FabricSubnet subnet : newFabricSubnets) {
        if (subnet.prefix().isIp4()) {
            newIp4SubnetTable.put(createBinaryString(subnet.prefix()), subnet);
        } else {
            newIp6SubnetTable.put(createBinaryString(subnet.prefix()), subnet);
        }
        newVirtualGatewayIpMacMap.put(subnet.gatewayIp(), subnet.gatewayMac());
    }
    if (!fabricSubnets.equals(newFabricSubnets)) {
        fabricSubnets = newFabricSubnets;
        ip4SubnetTable = newIp4SubnetTable;
        ip6SubnetTable = newIp6SubnetTable;
        dirty = true;
    }
    if (!virtualGatewayIpMacMap.equals(newVirtualGatewayIpMacMap)) {
        virtualGatewayIpMacMap = newVirtualGatewayIpMacMap;
        dirty = true;
    }
    // fabricRoutes config handling
    Set<FabricRoute> newFabricRoutes = config.fabricRoutes();
    if (!fabricRoutes.equals(newFabricRoutes)) {
        InvertedRadixTree<FabricRoute> newIp4BorderRouteTable = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
        InvertedRadixTree<FabricRoute> newIp6BorderRouteTable = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
        for (FabricRoute route : newFabricRoutes) {
            if (route.prefix().isIp4()) {
                newIp4BorderRouteTable.put(createBinaryString(route.prefix()), route);
            } else {
                newIp6BorderRouteTable.put(createBinaryString(route.prefix()), route);
            }
        }
        fabricRoutes = newFabricRoutes;
        ip4BorderRouteTable = newIp4BorderRouteTable;
        ip6BorderRouteTable = newIp6BorderRouteTable;
        dirty = true;
    }
    // notify to SimpleFabric listeners
    if (dirty) {
        log.info("simple fabric refresh; notify events");
        process(new SimpleFabricEvent(SimpleFabricEvent.Type.SIMPLE_FABRIC_UPDATED, "updated"));
    }
    return dirty;
}
#end_block

#method_before
@Override
public FabricRoute fabricRoute(IpAddress ip) {
    // ASSUME: ipAddress is out of fabricIpSubnet
    if (ip.isIp4()) {
        return ip4BorderRouteTable.getValueForLongestKeyPrefixing(createBinaryString(IpPrefix.valueOf(ip, Ip4Address.BIT_LENGTH)));
    } else {
        return ip6BorderRouteTable.getValueForLongestKeyPrefixing(createBinaryString(IpPrefix.valueOf(ip, Ip6Address.BIT_LENGTH)));
    }
}
#method_after
@Override
public FabricRoute fabricRoute(IpAddress ip) {
    // ASSUME: ipAddress is out of fabricSubnet
    if (ip.isIp4()) {
        return ip4BorderRouteTable.getValueForLongestKeyPrefixing(createBinaryString(IpPrefix.valueOf(ip, Ip4Address.BIT_LENGTH)));
    } else {
        return ip6BorderRouteTable.getValueForLongestKeyPrefixing(createBinaryString(IpPrefix.valueOf(ip, Ip6Address.BIT_LENGTH)));
    }
}
#end_block

#method_before
@Override
public boolean requestMac(IpAddress ip) {
    FabricIpSubnet fabricIpSubnet = fabricIpSubnet(ip);
    if (fabricIpSubnet == null) {
        log.warn("simple fabric request mac failed for unknown DefaultFabricIpSubnet: {}", ip);
        return false;
    }
    FabricNetwork fabricNetwork = fabricNetwork(fabricIpSubnet.networkName());
    if (fabricNetwork == null) {
        log.warn("simple fabric request mac failed for unknown fabricNetwork name {}: {}", fabricIpSubnet.networkName(), ip);
        return false;
    }
    log.debug("simple fabric send request mac DefaultFabricNetwork {}: {}", fabricNetwork.name(), ip);
    for (Interface iface : fabricNetwork.interfaces()) {
        Ethernet neighbourReq;
        if (ip.isIp4()) {
            neighbourReq = ARP.buildArpRequest(fabricIpSubnet.gatewayMac().toBytes(), fabricIpSubnet.gatewayIp().toOctets(), ip.toOctets(), iface.vlan().toShort());
        } else {
            byte[] soliciteIp = IPv6.getSolicitNodeAddress(ip.toOctets());
            neighbourReq = NeighborSolicitation.buildNdpSolicit(ip.toOctets(), fabricIpSubnet.gatewayIp().toOctets(), soliciteIp, fabricIpSubnet.gatewayMac().toBytes(), IPv6.getMCastMacAddress(soliciteIp), iface.vlan());
        }
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(iface.connectPoint().port()).build();
        OutboundPacket packet = new DefaultOutboundPacket(iface.connectPoint().deviceId(), treatment, ByteBuffer.wrap(neighbourReq.serialize()));
        packetService.emit(packet);
    }
    return true;
}
#method_after
@Override
public boolean requestMac(IpAddress ip) {
    FabricSubnet fabricSubnet = fabricSubnet(ip);
    if (fabricSubnet == null) {
        log.warn("simple fabric request mac failed for unknown fabricSubnet: {}", ip);
        return false;
    }
    FabricNetwork fabricNetwork = fabricNetwork(fabricSubnet.name());
    if (fabricNetwork == null) {
        log.warn("simple fabric request mac failed for unknown fabricNetwork name {}: {}", fabricSubnet.name(), ip);
        return false;
    }
    log.debug("simple fabric send request mac fabricNetwork {}: {}", fabricNetwork.name(), ip);
    for (Interface iface : fabricNetwork.interfaces()) {
        Ethernet neighbourReq;
        if (ip.isIp4()) {
            neighbourReq = ARP.buildArpRequest(fabricSubnet.gatewayMac().toBytes(), fabricSubnet.gatewayIp().toOctets(), ip.toOctets(), iface.vlan().toShort());
        } else {
            byte[] soliciteIp = IPv6.getSolicitNodeAddress(ip.toOctets());
            neighbourReq = NeighborSolicitation.buildNdpSolicit(ip.toOctets(), fabricSubnet.gatewayIp().toOctets(), soliciteIp, fabricSubnet.gatewayMac().toBytes(), IPv6.getMCastMacAddress(soliciteIp), iface.vlan());
        }
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(iface.connectPoint().port()).build();
        OutboundPacket packet = new DefaultOutboundPacket(iface.connectPoint().deviceId(), treatment, ByteBuffer.wrap(neighbourReq.serialize()));
        packetService.emit(packet);
    }
    return true;
}
#end_block

#method_before
protected void dump(String subject, PrintStream out) {
    if ("show".equals(subject)) {
        out.println("Static Configuration Flag:");
        out.println("    ALLOW_IPV6=" + ALLOW_IPV6);
        out.println("    ALLOW_ETH_ADDRESS_SELECTOR=" + ALLOW_ETH_ADDRESS_SELECTOR);
        out.println("    REACTIVE_SINGLE_TO_SINGLE=" + REACTIVE_SINGLE_TO_SINGLE);
        out.println("    REACTIVE_ALLOW_LINK_CP=" + REACTIVE_ALLOW_LINK_CP);
        out.println("    REACTIVE_HASHED_PATH_SELECTION=" + REACTIVE_HASHED_PATH_SELECTION);
        out.println("    REACTIVE_MATCH_IP_PROTO=" + REACTIVE_MATCH_IP_PROTO);
        out.println("");
        out.println("SimpleFabricAppId:");
        out.println("    " + appId());
        out.println("");
        out.println("fabricNetworks:");
        for (FabricNetwork fabricNetwork : fabricNetworks()) {
            out.println("    " + fabricNetwork);
        }
        out.println("");
        out.println("defaultFabricIpSubnets:");
        for (FabricIpSubnet fabricIpSubnet : defaultFabricIpSubnets()) {
            out.println("    " + fabricIpSubnet);
        }
        out.println("");
        out.println("fabricRoutes:");
        for (FabricRoute route : fabricRoutes()) {
            out.println("    " + route);
        }
    }
}
#method_after
protected void dump(String subject, PrintStream out) {
    if ("show".equals(subject)) {
        out.println("Static Configuration Flag:");
        out.println("    ALLOW_IPV6=" + ALLOW_IPV6);
        out.println("    ALLOW_ETH_ADDRESS_SELECTOR=" + ALLOW_ETH_ADDRESS_SELECTOR);
        out.println("    REACTIVE_SINGLE_TO_SINGLE=" + REACTIVE_SINGLE_TO_SINGLE);
        out.println("    REACTIVE_ALLOW_LINK_CP=" + REACTIVE_ALLOW_LINK_CP);
        out.println("    REACTIVE_HASHED_PATH_SELECTION=" + REACTIVE_HASHED_PATH_SELECTION);
        out.println("    REACTIVE_MATCH_IP_PROTO=" + REACTIVE_MATCH_IP_PROTO);
        out.println("");
        out.println("SimpleFabricAppId:");
        out.println("    " + appId());
        out.println("");
        out.println("fabricNetworks:");
        for (FabricNetwork fabricNetwork : fabricNetworks()) {
            out.println("    " + fabricNetwork);
        }
        out.println("");
        out.println("fabricSubnets:");
        for (FabricSubnet fabricIpSubnet : defaultFabricSubnets()) {
            out.println("    " + fabricIpSubnet);
        }
        out.println("");
        out.println("fabricRoutes:");
        for (FabricRoute route : fabricRoutes()) {
            out.println("    " + route);
        }
    }
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(REACTIVE_APP_ID);
    log.info("simple fabric routing starting with app id {}", appId.toString());
    if (REACTIVE_HASHED_PATH_SELECTION) {
        reactiveConstraints = ImmutableList.of(new PartialFailureConstraint(), new HashedPathSelectionConstraint());
    } else {
        reactiveConstraints = ImmutableList.of(new PartialFailureConstraint());
    }
    processor = new InternalRoutingProcessor();
    packetService.addProcessor(processor, PacketProcessor.director(2));
    simpleFabric.addListener(simpleFabricListener);
    registerIntercepts();
    refreshIntercepts();
    log.info("simple fabric routing started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(ROUTING_APP_ID);
    log.info("simple fabric routing starting with app id {}", appId.toString());
    if (REACTIVE_HASHED_PATH_SELECTION) {
        reactiveConstraints = ImmutableList.of(new PartialFailureConstraint(), new HashedPathSelectionConstraint());
    } else {
        reactiveConstraints = ImmutableList.of(new PartialFailureConstraint());
    }
    processor = new InternalRoutingProcessor();
    packetService.addProcessor(processor, PacketProcessor.director(2));
    simpleFabric.addListener(simpleFabricListener);
    registerIntercepts();
    refreshIntercepts();
    log.info("simple fabric routing started");
}
#end_block

#method_before
private void refreshIntercepts() {
    Set<FlowRule> newInterceptFlowRules = new HashSet<>();
    for (Device device : deviceService.getAvailableDevices()) {
        for (FabricIpSubnet subnet : simpleFabric.defaultFabricIpSubnets()) {
            newInterceptFlowRules.add(generateInterceptFlowRule(true, device.id(), subnet.ipPrefix()));
            // check if this devices has the fabricIpSubnet, then add ip broadcast flue rule
            FabricNetwork fabricNetwork = simpleFabric.fabricNetwork(subnet.networkName());
            if (fabricNetwork != null && fabricNetwork.contains(device.id())) {
                newInterceptFlowRules.add(generateLocalSubnetIpBctFlowRule(device.id(), subnet.ipPrefix(), fabricNetwork));
            }
        // JUST FOR FLOW RULE TEST ONLY
        // newInterceptFlowRules.add(generateTestFlowRule(device.id(), subnet.ipPrefix()));
        }
        for (FabricRoute route : simpleFabric.fabricRoutes()) {
            newInterceptFlowRules.add(generateInterceptFlowRule(false, device.id(), route.prefix()));
        }
    }
    if (!newInterceptFlowRules.equals(interceptFlowRules)) {
        // NOTE: DO NOT REMOVE INTERCEPT FLOW RULES FOR FAILED DEVICE FLOW UPDATE MIGHT BE BLOCKED
        /*
            interceptFlowRules.stream()
                .filter(rule -> !newInterceptFlowRules.contains(rule))
                .forEach(rule -> {
                    flowRuleService.removeFlowRules(rule);
                    log.info("simple fabric reactive routing remove intercept flow rule: {}", rule);
                });
            */
        newInterceptFlowRules.stream().filter(rule -> !interceptFlowRules.contains(rule)).forEach(rule -> {
            flowRuleService.applyFlowRules(rule);
            log.info("simple fabric routing apply intercept flow rule: {}", rule);
        });
        interceptFlowRules = newInterceptFlowRules;
    }
}
#method_after
private void refreshIntercepts() {
    Set<FlowRule> newInterceptFlowRules = new HashSet<>();
    for (Device device : deviceService.getAvailableDevices()) {
        for (FabricSubnet subnet : simpleFabric.defaultFabricSubnets()) {
            newInterceptFlowRules.add(generateInterceptFlowRule(true, device.id(), subnet.prefix()));
            // check if this devices has the fabricSubnet, then add ip broadcast flue rule
            FabricNetwork fabricNetwork = simpleFabric.fabricNetwork(subnet.name());
            if (fabricNetwork != null && fabricNetwork.contains(device.id())) {
                newInterceptFlowRules.add(generateLocalSubnetIpBctFlowRule(device.id(), subnet.prefix(), fabricNetwork));
            }
        // JUST FOR FLOW RULE TEST ONLY
        // newInterceptFlowRules.add(generateTestFlowRule(device.id(), subnet.ipPrefix()));
        }
        for (FabricRoute route : simpleFabric.fabricRoutes()) {
            newInterceptFlowRules.add(generateInterceptFlowRule(false, device.id(), route.prefix()));
        }
    }
    if (!newInterceptFlowRules.equals(interceptFlowRules)) {
        // NOTE: DO NOT REMOVE INTERCEPT FLOW RULES FOR FAILED DEVICE FLOW UPDATE MIGHT BE BLOCKED
        /*
            interceptFlowRules.stream()
                .filter(rule -> !newInterceptFlowRules.contains(rule))
                .forEach(rule -> {
                    flowRuleService.removeFlowRules(rule);
                    log.info("simple fabric reactive routing remove intercept flow rule: {}", rule);
                });
            */
        newInterceptFlowRules.stream().filter(rule -> !interceptFlowRules.contains(rule)).forEach(rule -> {
            flowRuleService.applyFlowRules(rule);
            log.info("simple fabric routing apply intercept flow rule: {}", rule);
        });
        interceptFlowRules = newInterceptFlowRules;
    }
}
#end_block

#method_before
private boolean checkVirtualGatewayIpPacket(InboundPacket pkt, IpAddress srcIp, IpAddress dstIp) {
    // assume valid
    Ethernet ethPkt = pkt.parsed();
    MacAddress mac = simpleFabric.vMacForIp(dstIp);
    if (mac == null || !simpleFabric.isVMac(ethPkt.getDestinationMAC())) {
        /* Destination MAC should be any of virtual gateway macs */
        return false;
    } else if (dstIp.isIp4()) {
        IPv4 ipv4Packet = (IPv4) ethPkt.getPayload();
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_ICMP) {
            ICMP icmpPacket = (ICMP) ipv4Packet.getPayload();
            if (icmpPacket.getIcmpType() == ICMP.TYPE_ECHO_REQUEST) {
                log.info("IPV4 ICMP ECHO request to virtual gateway: " + "srcIp={} dstIp={} proto={}", srcIp, dstIp, ipv4Packet.getProtocol());
                TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(pkt.receivedFrom().port()).build();
                OutboundPacket packet = new DefaultOutboundPacket(pkt.receivedFrom().deviceId(), treatment, ByteBuffer.wrap(icmpPacket.buildIcmpReply(pkt.parsed()).serialize()));
                packetService.emit(packet);
                return true;
            }
        }
        log.warn("IPV4 packet to virtual gateway dropped: " + "srcIp={} dstIp={} proto={}", srcIp, dstIp, ipv4Packet.getProtocol());
        return true;
    } else if (dstIp.isIp6()) {
        // TODO: not tested yet (2017-07-20)
        IPv6 ipv6Packet = (IPv6) ethPkt.getPayload();
        if (ipv6Packet.getNextHeader() == IPv6.PROTOCOL_ICMP6) {
            ICMP6 icmp6Packet = (ICMP6) ipv6Packet.getPayload();
            if (icmp6Packet.getIcmpType() == ICMP6.ECHO_REQUEST) {
                log.info("IPV6 ICMP6 ECHO request to virtual gateway: srcIp={} dstIp={} nextHeader={}", srcIp, dstIp, ipv6Packet.getNextHeader());
                TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(pkt.receivedFrom().port()).build();
                OutboundPacket packet = new DefaultOutboundPacket(pkt.receivedFrom().deviceId(), treatment, ByteBuffer.wrap(icmp6Packet.buildIcmp6Reply(pkt.parsed()).serialize()));
                packetService.emit(packet);
                return true;
            }
        }
        log.warn("IPV6 packet to virtual gateway dropped: srcIp={} dstIp={} nextHeader={}", srcIp, dstIp, ipv6Packet.getNextHeader());
        return true;
    }
    // unknown traffic
    return false;
}
#method_after
private boolean checkVirtualGatewayIpPacket(InboundPacket pkt, IpAddress srcIp, IpAddress dstIp) {
    // assume valid
    Ethernet ethPkt = pkt.parsed();
    MacAddress mac = simpleFabric.vMacForIp(dstIp);
    if (mac == null || !simpleFabric.isVirtualGatewayMac(ethPkt.getDestinationMAC())) {
        /* Destination MAC should be any of virtual gateway macs */
        return false;
    } else if (dstIp.isIp4()) {
        IPv4 ipv4Packet = (IPv4) ethPkt.getPayload();
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_ICMP) {
            ICMP icmpPacket = (ICMP) ipv4Packet.getPayload();
            if (icmpPacket.getIcmpType() == ICMP.TYPE_ECHO_REQUEST) {
                log.info("IPV4 ICMP ECHO request to virtual gateway: " + "srcIp={} dstIp={} proto={}", srcIp, dstIp, ipv4Packet.getProtocol());
                TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(pkt.receivedFrom().port()).build();
                OutboundPacket packet = new DefaultOutboundPacket(pkt.receivedFrom().deviceId(), treatment, ByteBuffer.wrap(icmpPacket.buildIcmpReply(pkt.parsed()).serialize()));
                packetService.emit(packet);
                return true;
            }
        }
        log.warn("IPV4 packet to virtual gateway dropped: " + "srcIp={} dstIp={} proto={}", srcIp, dstIp, ipv4Packet.getProtocol());
        return true;
    } else if (dstIp.isIp6()) {
        // TODO: not tested yet (2017-07-20)
        IPv6 ipv6Packet = (IPv6) ethPkt.getPayload();
        if (ipv6Packet.getNextHeader() == IPv6.PROTOCOL_ICMP6) {
            ICMP6 icmp6Packet = (ICMP6) ipv6Packet.getPayload();
            if (icmp6Packet.getIcmpType() == ICMP6.ECHO_REQUEST) {
                log.info("IPV6 ICMP6 ECHO request to virtual gateway: srcIp={} dstIp={} nextHeader={}", srcIp, dstIp, ipv6Packet.getNextHeader());
                TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(pkt.receivedFrom().port()).build();
                OutboundPacket packet = new DefaultOutboundPacket(pkt.receivedFrom().deviceId(), treatment, ByteBuffer.wrap(icmp6Packet.buildIcmp6Reply(pkt.parsed()).serialize()));
                packetService.emit(packet);
                return true;
            }
        }
        log.warn("IPV6 packet to virtual gateway dropped: srcIp={} dstIp={} nextHeader={}", srcIp, dstIp, ipv6Packet.getNextHeader());
        return true;
    }
    // unknown traffic
    return false;
}
#end_block

#method_before
private void ipPacketReactiveProcessor(PacketContext context, Ethernet ethPkt, ConnectPoint srcCp, IpAddress srcIp, IpAddress dstIp, byte ipProto) {
    /* check reactive handling and forward packet */
    log.trace("ip packet: srcCp={} srcIp={} dstIp={} ipProto={}", srcCp, srcIp, dstIp, ipProto);
    EncapsulationType encap = EncapsulationType.NONE;
    // prefix and nextHop for local Subnet
    IpPrefix srcPrefix = srcIp.toIpPrefix();
    IpPrefix dstPrefix = dstIp.toIpPrefix();
    IpAddress srcNextHop = srcIp;
    IpAddress dstNextHop = dstIp;
    MacAddress treatmentSrcMac = ethPkt.getDestinationMAC();
    int borderRoutePrefixLength = 0;
    boolean updateMac = simpleFabric.isVMac(ethPkt.getDestinationMAC());
    // check subnet local or route
    FabricIpSubnet srcSubnet = simpleFabric.fabricIpSubnet(srcIp);
    if (srcSubnet == null) {
        FabricRoute route = simpleFabric.fabricRoute(srcIp);
        if (route == null) {
            log.warn("unknown srcIp; drop: srcCp={} srcIp={} dstIp={} ipProto={}", srcCp, srcIp, dstIp, ipProto);
            return;
        }
        srcPrefix = route.prefix();
        srcNextHop = route.nextHop();
        borderRoutePrefixLength = route.prefix().prefixLength();
    }
    FabricIpSubnet dstSubnet = simpleFabric.fabricIpSubnet(dstIp);
    if (dstSubnet == null) {
        FabricRoute route = simpleFabric.fabricRoute(dstIp);
        if (route == null) {
            log.warn("unknown dstIp; drop: srcCp={} srcIp={} dstIp={} ipProto={}", srcCp, srcIp, dstIp, ipProto);
            return;
        }
        dstPrefix = route.prefix();
        dstNextHop = route.nextHop();
        borderRoutePrefixLength = route.prefix().prefixLength();
    }
    if (dstSubnet != null) {
        // destination is local subnet ip
        if (ALLOW_ETH_ADDRESS_SELECTOR && dstSubnet.equals(srcSubnet)) {
            // NOTE: if ALLOW_ETH_ADDRESS_SELECTOR=false; isForward is always false
            FabricNetwork fabricNetwork = simpleFabric.fabricNetwork(dstSubnet.networkName());
            treatmentSrcMac = ethPkt.getSourceMAC();
            if (fabricNetwork != null && fabricNetwork.isForward()) {
                // NOTE: no reactive route action but do forward packet for L2Forward do not handle packet
                // update mac only if dstMac is virtualGatewayMac, else assume valid mac already for the l2 network
                log.info("LOCAL FORWARD ONLY: " + "srcCp={} srcIp={} dstIp={} srcMac={} dstMac={} vlanId={} ipProto={} updateMac={}", context.inPacket().receivedFrom(), srcIp, dstIp, ethPkt.getSourceMAC(), ethPkt.getDestinationMAC(), ethPkt.getVlanID(), ipProto, updateMac);
                forwardPacketToDstIp(context, dstIp, treatmentSrcMac, updateMac);
                return;
            }
        }
        encap = dstSubnet.encapsulation();
        if (encap == EncapsulationType.NONE && srcSubnet != null) {
            encap = srcSubnet.encapsulation();
        }
    } else {
        // destination is external network
        if (srcSubnet == null) {
            // both are externel network
            log.warn("INVALID PACKET: srcIp and dstIp are both NON-LOCAL: " + "srcCP={} srcIp={} dstIp={} srcMac={} dstMac={} vlanId={} ipProto={} updateMac={}", context.inPacket().receivedFrom(), srcIp, dstIp, ethPkt.getSourceMAC(), ethPkt.getDestinationMAC(), ethPkt.getVlanID(), ipProto, updateMac);
            return;
        }
        encap = srcSubnet.encapsulation();
    }
    log.info("REGI AND FORWARD: " + "srcCP={} srcIp={} dstIp={} srcMac={} dstMac={} vlanId={} ipProto={} updateMac={}", context.inPacket().receivedFrom(), srcIp, dstIp, ethPkt.getSourceMAC(), ethPkt.getDestinationMAC(), ethPkt.getVlanID(), ipProto, updateMac);
    setUpConnectivity(srcCp, ipProto, srcPrefix, dstPrefix, dstNextHop, treatmentSrcMac, encap, updateMac, dstSubnet != null, borderRoutePrefixLength);
    forwardPacketToDstIp(context, dstNextHop, treatmentSrcMac, updateMac);
}
#method_after
private void ipPacketReactiveProcessor(PacketContext context, Ethernet ethPkt, ConnectPoint srcCp, IpAddress srcIp, IpAddress dstIp, byte ipProto) {
    /* check reactive handling and forward packet */
    log.trace("ip packet: srcCp={} srcIp={} dstIp={} ipProto={}", srcCp, srcIp, dstIp, ipProto);
    EncapsulationType encap = EncapsulationType.NONE;
    // prefix and nextHop for local Subnet
    IpPrefix srcPrefix = srcIp.toIpPrefix();
    IpPrefix dstPrefix = dstIp.toIpPrefix();
    IpAddress srcNextHop = srcIp;
    IpAddress dstNextHop = dstIp;
    MacAddress treatmentSrcMac = ethPkt.getDestinationMAC();
    int borderRoutePrefixLength = 0;
    boolean updateMac = simpleFabric.isVirtualGatewayMac(ethPkt.getDestinationMAC());
    // check subnet local or route
    FabricSubnet srcSubnet = simpleFabric.fabricSubnet(srcIp);
    if (srcSubnet == null) {
        FabricRoute route = simpleFabric.fabricRoute(srcIp);
        if (route == null) {
            log.warn("unknown srcIp; drop: srcCp={} srcIp={} dstIp={} ipProto={}", srcCp, srcIp, dstIp, ipProto);
            return;
        }
        srcPrefix = route.prefix();
        srcNextHop = route.nextHop();
        borderRoutePrefixLength = route.prefix().prefixLength();
    }
    FabricSubnet dstSubnet = simpleFabric.fabricSubnet(dstIp);
    if (dstSubnet == null) {
        FabricRoute route = simpleFabric.fabricRoute(dstIp);
        if (route == null) {
            log.warn("unknown dstIp; drop: srcCp={} srcIp={} dstIp={} ipProto={}", srcCp, srcIp, dstIp, ipProto);
            return;
        }
        dstPrefix = route.prefix();
        dstNextHop = route.nextHop();
        borderRoutePrefixLength = route.prefix().prefixLength();
    }
    if (dstSubnet != null) {
        // destination is local subnet ip
        if (ALLOW_ETH_ADDRESS_SELECTOR && dstSubnet.equals(srcSubnet)) {
            // NOTE: if ALLOW_ETH_ADDRESS_SELECTOR=false; isForward is always false
            FabricNetwork fabricNetwork = simpleFabric.fabricNetwork(dstSubnet.name());
            treatmentSrcMac = ethPkt.getSourceMAC();
            if (fabricNetwork != null && fabricNetwork.isForward()) {
                // NOTE: no reactive route action but do forward packet for L2Forward do not handle packet
                // update mac only if dstMac is virtualGatewayMac, else assume valid mac already for the l2 network
                log.info("LOCAL FORWARD ONLY: " + "srcCp={} srcIp={} dstIp={} srcMac={} dstMac={} vlanId={} ipProto={} updateMac={}", context.inPacket().receivedFrom(), srcIp, dstIp, ethPkt.getSourceMAC(), ethPkt.getDestinationMAC(), ethPkt.getVlanID(), ipProto, updateMac);
                forwardPacketToDstIp(context, dstIp, treatmentSrcMac, updateMac);
                return;
            }
        }
        encap = dstSubnet.encapsulation();
        if (encap == EncapsulationType.NONE && srcSubnet != null) {
            encap = srcSubnet.encapsulation();
        }
    } else {
        // destination is external network
        if (srcSubnet == null) {
            // both are externel network
            log.warn("INVALID PACKET: srcIp and dstIp are both NON-LOCAL: " + "srcCP={} srcIp={} dstIp={} srcMac={} dstMac={} vlanId={} ipProto={} updateMac={}", context.inPacket().receivedFrom(), srcIp, dstIp, ethPkt.getSourceMAC(), ethPkt.getDestinationMAC(), ethPkt.getVlanID(), ipProto, updateMac);
            return;
        }
        encap = srcSubnet.encapsulation();
    }
    log.info("REGI AND FORWARD: " + "srcCP={} srcIp={} dstIp={} srcMac={} dstMac={} vlanId={} ipProto={} updateMac={}", context.inPacket().receivedFrom(), srcIp, dstIp, ethPkt.getSourceMAC(), ethPkt.getDestinationMAC(), ethPkt.getVlanID(), ipProto, updateMac);
    setUpConnectivity(srcCp, ipProto, srcPrefix, dstPrefix, dstNextHop, treatmentSrcMac, encap, updateMac, dstSubnet != null, borderRoutePrefixLength);
    forwardPacketToDstIp(context, dstNextHop, treatmentSrcMac, updateMac);
}
#end_block

#method_before
@Activate
public void activate() {
    l2ForwardAppId = coreService.registerApplication(L2FORWARD_APP_ID);
    log.info("simple fabric forwarding starting with l2net app id {}", l2ForwardAppId.toString());
    simpleFabric.addListener(simpleFabricListener);
    refresh();
    checkIntentsPurge();
    log.info("simple fabric forwarding started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(FORWARDING_APP_ID);
    log.info("simple fabric forwarding starting with l2net app id {}", appId.toString());
    simpleFabric.addListener(simpleFabricListener);
    refresh();
    checkIntentsPurge();
    log.info("simple fabric forwarding started");
}
#end_block

#method_before
private Set<SinglePointToMultiPointIntent> buildBrcIntents(FabricNetwork fabricNetwork) {
    Set<Interface> interfaces = fabricNetwork.interfaces();
    if (interfaces.size() < 2 || !fabricNetwork.isForward() || !fabricNetwork.isBroadcast()) {
        return ImmutableSet.of();
    }
    Set<SinglePointToMultiPointIntent> brcIntents = Sets.newHashSet();
    ResourceGroup resourceGroup = ResourceGroup.of(fabricNetwork.name());
    // Generates broadcast Intents from any network interface to other
    // network interface from the L2 Network.
    interfaces.forEach(src -> {
        FilteredConnectPoint srcFcp = buildFilteredConnectedPoint(src);
        Set<FilteredConnectPoint> dstFcps = interfaces.stream().filter(iface -> !iface.equals(src)).map(this::buildFilteredConnectedPoint).collect(Collectors.toSet());
        Key key = buildKey(fabricNetwork.name(), "BCAST", srcFcp.connectPoint(), MacAddress.BROADCAST);
        TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
        SinglePointToMultiPointIntent.Builder intentBuilder = SinglePointToMultiPointIntent.builder().appId(l2ForwardAppId).key(key).selector(selector).filteredIngressPoint(srcFcp).filteredEgressPoints(dstFcps).constraints(buildConstraints(L2NETWORK_CONSTRAINTS, fabricNetwork.encapsulation())).priority(PRI_L2NETWORK_BROADCAST).resourceGroup(resourceGroup);
        brcIntents.add(intentBuilder.build());
    });
    return brcIntents;
}
#method_after
private Set<SinglePointToMultiPointIntent> buildBrcIntents(FabricNetwork fabricNetwork) {
    Set<Interface> interfaces = fabricNetwork.interfaces();
    if (interfaces.size() < 2 || !fabricNetwork.isForward() || !fabricNetwork.isBroadcast()) {
        return ImmutableSet.of();
    }
    Set<SinglePointToMultiPointIntent> brcIntents = Sets.newHashSet();
    ResourceGroup resourceGroup = ResourceGroup.of(fabricNetwork.name());
    // Generates broadcast Intents from any network interface to other
    // network interface from the L2 Network.
    interfaces.forEach(src -> {
        FilteredConnectPoint srcFcp = buildFilteredConnectedPoint(src);
        Set<FilteredConnectPoint> dstFcps = interfaces.stream().filter(iface -> !iface.equals(src)).map(this::buildFilteredConnectedPoint).collect(Collectors.toSet());
        Key key = buildKey(fabricNetwork.name(), "BCAST", srcFcp.connectPoint(), MacAddress.BROADCAST);
        TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
        SinglePointToMultiPointIntent.Builder intentBuilder = SinglePointToMultiPointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoint(srcFcp).filteredEgressPoints(dstFcps).constraints(buildConstraints(L2NETWORK_CONSTRAINTS, fabricNetwork.encapsulation())).priority(PRI_L2NETWORK_BROADCAST).resourceGroup(resourceGroup);
        brcIntents.add(intentBuilder.build());
    });
    return brcIntents;
}
#end_block

#method_before
private Set<MultiPointToSinglePointIntent> buildUniIntents(FabricNetwork fabricNetwork, Set<Host> hosts) {
    Set<Interface> interfaces = fabricNetwork.interfaces();
    if (!fabricNetwork.isForward() || interfaces.size() < 2) {
        return ImmutableSet.of();
    }
    Set<MultiPointToSinglePointIntent> uniIntents = Sets.newHashSet();
    ResourceGroup resourceGroup = ResourceGroup.of(fabricNetwork.name());
    hosts.forEach(host -> {
        FilteredConnectPoint hostFcp = buildFilteredConnectedPoint(host);
        Set<FilteredConnectPoint> srcFcps = interfaces.stream().map(this::buildFilteredConnectedPoint).filter(fcp -> !fcp.equals(hostFcp)).collect(Collectors.toSet());
        Key key = buildKey(fabricNetwork.name(), "UNI", hostFcp.connectPoint(), host.mac());
        TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
        MultiPointToSinglePointIntent.Builder intentBuilder = MultiPointToSinglePointIntent.builder().appId(l2ForwardAppId).key(key).selector(selector).filteredIngressPoints(srcFcps).filteredEgressPoint(hostFcp).constraints(buildConstraints(L2NETWORK_CONSTRAINTS, fabricNetwork.encapsulation())).priority(PRI_L2NETWORK_UNICAST).resourceGroup(resourceGroup);
        uniIntents.add(intentBuilder.build());
    });
    return uniIntents;
}
#method_after
private Set<MultiPointToSinglePointIntent> buildUniIntents(FabricNetwork fabricNetwork, Set<Host> hosts) {
    Set<Interface> interfaces = fabricNetwork.interfaces();
    if (!fabricNetwork.isForward() || interfaces.size() < 2) {
        return ImmutableSet.of();
    }
    Set<MultiPointToSinglePointIntent> uniIntents = Sets.newHashSet();
    ResourceGroup resourceGroup = ResourceGroup.of(fabricNetwork.name());
    hosts.forEach(host -> {
        FilteredConnectPoint hostFcp = buildFilteredConnectedPoint(host);
        Set<FilteredConnectPoint> srcFcps = interfaces.stream().map(this::buildFilteredConnectedPoint).filter(fcp -> !fcp.equals(hostFcp)).collect(Collectors.toSet());
        Key key = buildKey(fabricNetwork.name(), "UNI", hostFcp.connectPoint(), host.mac());
        TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
        MultiPointToSinglePointIntent.Builder intentBuilder = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoints(srcFcps).filteredEgressPoint(hostFcp).constraints(buildConstraints(L2NETWORK_CONSTRAINTS, fabricNetwork.encapsulation())).priority(PRI_L2NETWORK_UNICAST).resourceGroup(resourceGroup);
        uniIntents.add(intentBuilder.build());
    });
    return uniIntents;
}
#end_block

#method_before
private Key buildKey(String l2NetworkName, String type, ConnectPoint cPoint, MacAddress dstMac) {
    return Key.of(l2NetworkName + "-" + type + "-" + cPoint.toString() + "-" + dstMac, l2ForwardAppId);
}
#method_after
private Key buildKey(String l2NetworkName, String type, ConnectPoint cPoint, MacAddress dstMac) {
    return Key.of(l2NetworkName + "-" + type + "-" + cPoint.toString() + "-" + dstMac, appId);
}
#end_block

#method_before
@Activate
public void activate() {
    initDcsTapiContext();
    initDcsTapiTopology();
    initDcsTapiConnectivityContect();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    initDcsTapiContext();
    initDcsTapiTopology();
    initDcsTapiConnectivityContext();
    log.info("Started");
}
#end_block

#method_before
@Override
protected Uuid getIdDetail() {
    return null;
}
#method_after
@Override
protected Uuid getIdDetail() {
    // The target yang object of this class is container, so no need to handle Id.
    return null;
}
#end_block

#method_before
@Override
protected void setIdDetail(Uuid uuid) {
}
#method_after
@Override
protected void setIdDetail(Uuid uuid) {
// The target yang object of this class is container, so no need to handle Id.
}
#end_block

#method_before
@Override
public ModelObjectId getParentModelObjectId() {
    DefaultConnectivityContext connectivityContext = new DefaultConnectivityContext();
    DefaultAugmentedTapiCommonContext context = new DefaultAugmentedTapiCommonContext();
    context.connectivityContext(connectivityContext);
    return ModelObjectId.builder().addChild(DefaultContext.class).build();
}
#method_after
@Override
public ModelObjectId getParentModelObjectId() {
    DefaultAugmentedTapiCommonContext context = new DefaultAugmentedTapiCommonContext();
    context.connectivityContext(obj);
    return ModelObjectId.builder().addChild(DefaultContext.class).build();
}
#end_block

#method_before
@Override
protected Uuid getIdDetail() {
    return null;
}
#method_after
@Override
protected Uuid getIdDetail() {
    // The target yang object of this class is container, so no need to handle Id.
    return null;
}
#end_block

#method_before
@Override
protected void setIdDetail(Uuid uuid) {
}
#method_after
@Override
protected void setIdDetail(Uuid uuid) {
// The target yang object of this class is container, so no need to handle Id.
}
#end_block

#method_before
@Override
public ModelObjectId getParentModelObjectId() {
    DefaultTopologyContext topologyContext = new DefaultTopologyContext();
    DefaultAugmentedTapiCommonContext context = new DefaultAugmentedTapiCommonContext();
    context.topologyContext(topologyContext);
    return ModelObjectId.builder().addChild(DefaultContext.class).build();
}
#method_after
@Override
public ModelObjectId getParentModelObjectId() {
    DefaultAugmentedTapiCommonContext context = new DefaultAugmentedTapiCommonContext();
    context.topologyContext(obj);
    return ModelObjectId.builder().addChild(DefaultContext.class).build();
}
#end_block

#method_before
@Override
protected Uuid getIdDetail() {
    return null;
}
#method_after
@Override
protected Uuid getIdDetail() {
    // The target yang object of this class is container, so no need to handle Id.
    return null;
}
#end_block

#method_before
@Override
protected void setIdDetail(Uuid uuid) {
}
#method_after
@Override
protected void setIdDetail(Uuid uuid) {
// The target yang object of this class is container, so no need to handle Id.
}
#end_block

#method_before
@DELETE
@Path("{prefix}")
public Response dhcpFpmDelete(@PathParam("prefix") String prefix) {
    DhcpRelayService dhcpRelayService = get(DhcpRelayService.class);
    RouteStore routeStore = get(RouteStore.class);
    // removes fpm route from fpm record
    Optional<FpmRecord> fpmRecord = dhcpRelayService.removeFpmRecord(IpPrefix.valueOf(prefix));
    IpAddress nextHop = fpmRecord.get().nextHop();
    Route route = new Route(Route.Source.DHCP, IpPrefix.valueOf(prefix), nextHop);
    // removes DHCP route from route store
    routeStore.removeRoute(route);
    return Response.noContent().build();
}
#method_after
@DELETE
@Path("{prefix}")
public Response dhcpFpmDelete(@PathParam("prefix") String prefix) {
    DhcpRelayService dhcpRelayService = get(DhcpRelayService.class);
    RouteStore routeStore = get(RouteStore.class);
    try {
        // removes fpm route from fpm record
        Optional<FpmRecord> fpmRecord = dhcpRelayService.removeFpmRecord(IpPrefix.valueOf(prefix));
        if (fpmRecord.isPresent()) {
            IpAddress nextHop = fpmRecord.get().nextHop();
            Route route = new Route(Route.Source.DHCP, IpPrefix.valueOf(prefix), nextHop);
            // removes DHCP route from route store
            routeStore.removeRoute(route);
        } else {
            LOG.warn("fpmRecord is not present");
        }
    } catch (IllegalArgumentException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.noContent().build();
}
#end_block

#method_before
static ActionProfileGroup encode(PiActionGroup piActionGroup, PiPipeconf pipeconf, int maxMemberSize) throws P4InfoBrowser.NotFoundException, EncodeException {
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    if (browser == null) {
        throw new EncodeException(format("Can't get P4 info browser from pipeconf %s", pipeconf));
    }
    PiActionProfileId piActionProfileId = piActionGroup.actionProfileId();
    P4InfoOuterClass.ActionProfile actionProfile = browser.actionProfiles().getByName(piActionProfileId.id());
    int actionProfileId = actionProfile.getPreamble().getId();
    ActionProfileGroup.Builder actionProfileGroupBuilder = ActionProfileGroup.newBuilder().setGroupId(piActionGroup.id().id()).setActionProfileId(actionProfileId);
    piActionGroup.members().forEach(m -> {
        // TODO: currently we don't set "watch" field of member
        Member member = Member.newBuilder().setMemberId(m.id().id()).setWeight(m.weight()).build();
        actionProfileGroupBuilder.addMembers(member);
    });
    // FIXME: ONOS-7797 Make this configurable, or find a different way of
    // supporting group modify. In P4Runtime, group size cannot be modified
    // once the group is created. To allow adding members to an existing
    // group we set max_size to support an additional number of members
    // other than the one already defined in the PI group. Clearly, this
    // will break if we try to add more than GROUP_SIZE_ADDITIONAL_MEMBERS
    // to the same group.
    actionProfileGroupBuilder.setMaxSize(maxMemberSize);
    return actionProfileGroupBuilder.build();
}
#method_after
static ActionProfileGroup encode(PiActionGroup piActionGroup, PiPipeconf pipeconf, int maxMemberSize) throws P4InfoBrowser.NotFoundException, EncodeException {
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    if (browser == null) {
        throw new EncodeException(format("Can't get P4 info browser from pipeconf %s", pipeconf));
    }
    PiActionProfileId piActionProfileId = piActionGroup.actionProfileId();
    P4InfoOuterClass.ActionProfile actionProfile = browser.actionProfiles().getByName(piActionProfileId.id());
    int actionProfileId = actionProfile.getPreamble().getId();
    ActionProfileGroup.Builder actionProfileGroupBuilder = ActionProfileGroup.newBuilder().setGroupId(piActionGroup.id().id()).setActionProfileId(actionProfileId);
    piActionGroup.members().forEach(m -> {
        // TODO: currently we don't set "watch" field of member
        Member member = Member.newBuilder().setMemberId(m.id().id()).setWeight(m.weight()).build();
        actionProfileGroupBuilder.addMembers(member);
    });
    if (maxMemberSize > 0) {
        actionProfileGroupBuilder.setMaxSize(maxMemberSize);
    }
    return actionProfileGroupBuilder.build();
}
#end_block

#method_before
private boolean doWriteActionGroup(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf, int maxMemberSize) {
    final ActionProfileGroup actionProfileGroup;
    try {
        actionProfileGroup = ActionProfileGroupEncoder.encode(group, pipeconf, maxMemberSize);
    } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to encode group, aborting {} operation: {}", e.getMessage(), opType.name());
        return false;
    }
    final Update updateMsg = Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileGroup(actionProfileGroup).build()).setType(UPDATE_TYPES.get(opType)).build();
    return write(singletonList(updateMsg), singletonList(group), opType, "group");
}
#method_after
private boolean doWriteActionGroup(PiActionGroup group, WriteOperationType opType, PiPipeconf pipeconf, int maxMemberSize) {
    final ActionProfileGroup actionProfileGroup;
    if (opType == P4RuntimeClient.WriteOperationType.INSERT && maxMemberSize < group.members().size()) {
        log.warn("Unable to encode group, since group member larger than maximum member size");
        return false;
    }
    try {
        actionProfileGroup = ActionProfileGroupEncoder.encode(group, pipeconf, maxMemberSize);
    } catch (EncodeException | P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to encode group, aborting {} operation: {}", e.getMessage(), opType.name());
        return false;
    }
    final Update updateMsg = Update.newBuilder().setEntity(Entity.newBuilder().setActionProfileGroup(actionProfileGroup).build()).setType(UPDATE_TYPES.get(opType)).build();
    return write(singletonList(updateMsg), singletonList(group), opType, "group");
}
#end_block

#method_before
private boolean applyGroup(PiActionGroup group, PiActionGroupHandle handle) {
    int groupBuffer = 3;
    int currentMemberSize = group.members().size();
    int previousMemberSize;
    if (groupMirror.get(handle) != null) {
        previousMemberSize = Integer.parseInt(groupMirror.annotations(handle).value("maxMemSize"));
        if (currentMemberSize > previousMemberSize + groupBuffer) {
            deleteGroup(group, handle);
        } else {
            currentMemberSize = previousMemberSize;
        }
    }
    P4RuntimeClient.WriteOperationType opType = groupMirror.get(handle) == null ? INSERT : MODIFY;
    final boolean success = getFutureWithDeadline(client.writeActionGroup(group, opType, pipeconf, currentMemberSize), "performing action profile group " + opType, false);
    if (success) {
        groupMirror.put(handle, group);
        if (opType == INSERT) {
            groupMirror.putAnnotations(handle, DefaultAnnotations.builder().set("maxMemSize", Integer.toString(currentMemberSize)).build());
        }
    }
    return success;
}
#method_after
private boolean applyGroup(PiActionGroup group, PiActionGroupHandle handle) {
    final int currentMemberSize = group.members().size();
    if (groupMirror.get(handle) != null) {
        String maxMemSize = "";
        if (groupMirror.annotations(handle) != null && groupMirror.annotations(handle).value(MAX_MEM_SIZE) != null) {
            maxMemSize = groupMirror.annotations(handle).value(MAX_MEM_SIZE);
        }
        if (maxMemSize == "" || currentMemberSize > Integer.parseInt(maxMemSize)) {
            deleteGroup(group, handle);
        }
    }
    P4RuntimeClient.WriteOperationType opType = groupMirror.get(handle) == null ? INSERT : MODIFY;
    int currentMaxMemberSize = opType == INSERT ? (currentMemberSize + GROUP_MEMBERS_BUFFER_SIZE) : 0;
    final boolean success = getFutureWithDeadline(client.writeActionGroup(group, opType, pipeconf, currentMaxMemberSize), "performing action profile group " + opType, false);
    if (success) {
        groupMirror.put(handle, group);
        if (opType == INSERT) {
            groupMirror.putAnnotations(handle, DefaultAnnotations.builder().set(MAX_MEM_SIZE, Integer.toString(currentMaxMemberSize)).build());
        }
    }
    return success;
}
#end_block

#method_before
@Activate
public void activate() {
    mirrorMap = storageService.<H, TimedEntry<E>>eventuallyConsistentMapBuilder().withName(mapName()).withSerializer(storeSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    annotationsMap = storageService.<H, Annotations>eventuallyConsistentMapBuilder().withName(mapName() + "Annotations").withSerializer(storeSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    pipeconfWatchdogService.addListener(pipeconfListener);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    mirrorMap = storageService.<H, TimedEntry<E>>eventuallyConsistentMapBuilder().withName(mapName()).withSerializer(storeSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    annotationsMap = storageService.<H, Annotations>eventuallyConsistentMapBuilder().withName(mapName() + "-annotations").withSerializer(storeSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    pipeconfWatchdogService.addListener(pipeconfListener);
    log.info("Started");
}
#end_block

#method_before
@Override
public void remove(H handle) {
    checkNotNull(handle);
    mirrorMap.remove(handle);
}
#method_after
@Override
public void remove(H handle) {
    checkNotNull(handle);
    mirrorMap.remove(handle);
    annotationsMap.remove(handle);
}
#end_block

#method_before
private void removeAll(DeviceId deviceId) {
    checkNotNull(deviceId);
    Collection<H> handles = getHandlesForDevice(deviceId);
    handles.forEach(mirrorMap::remove);
}
#method_after
private void removeAll(DeviceId deviceId) {
    checkNotNull(deviceId);
    Collection<H> handles = getHandlesForDevice(deviceId);
    handles.forEach(this::remove);
}
#end_block

#method_before
private void pollTableStatistics(Device device) {
    try {
        providerService.pushTableStatistics(device.id(), device.as(TableStatisticsDiscovery.class).getTableStatisticsEntry());
    } catch (Exception e) {
        log.warn("Exception thrown while polling {}", device.id(), e);
    }
}
#method_after
private void pollTableStatistics(Device device) {
    try {
        List<TableStatisticsEntry> tableStatsList = newArrayList(device.as(TableStatisticsDiscovery.class).getTableStatistics());
        providerService.pushTableStatistics(device.id(), tableStatsList);
    } catch (Exception e) {
        log.warn("Exception thrown while polling table statistics for {}", device.id(), e);
    }
}
#end_block

#method_before
private Map<PiTableId, Integer> piFlowRuleCounting(PiPipelineModel model, PiPipelineInterpreter interpreter, List<FlowEntry> rules) {
    Map<PiTableId, Integer> piTableFlowCount = new HashMap<>();
    for (PiTableModel tableModel : model.tables()) {
        piTableFlowCount.put(tableModel.id(), 0);
    }
    for (FlowEntry f : rules) {
        if (f.state() == FlowEntry.FlowEntryState.ADDED) {
            PiTableId piTableId = f.table().type() == TableId.Type.PIPELINE_INDEPENDENT ? (PiTableId) f.table() : interpreter.mapFlowRuleTableId(((IndexTableId) f.table()).id()).get();
            piTableFlowCount.put(piTableId, piTableFlowCount.get(piTableId) + 1);
        }
    }
    return piTableFlowCount;
}
#method_after
private Map<PiTableId, Integer> piFlowRuleCounting(PiPipelineModel model, PiPipelineInterpreter interpreter, List<FlowEntry> rules) {
    Map<PiTableId, Integer> piTableFlowCount = new HashMap<>();
    for (PiTableModel tableModel : model.tables()) {
        piTableFlowCount.put(tableModel.id(), 0);
    }
    for (FlowEntry f : rules) {
        if (f.state() == FlowEntry.FlowEntryState.ADDED) {
            PiTableId piTableId = getPiTableId(f, interpreter);
            if (piTableId != null) {
                piTableFlowCount.put(piTableId, piTableFlowCount.get(piTableId) + 1);
            }
        }
    }
    return piTableFlowCount;
}
#end_block

#method_before
private Map<PiTableId, Long> piMatchedCounting(PiPipelineModel model, PiPipelineInterpreter interpreter, List<FlowEntry> rules) {
    Map<PiTableId, Long> piTableMatchCount = new HashMap<>();
    for (PiTableModel tableModel : model.tables()) {
        piTableMatchCount.put(tableModel.id(), (long) 0);
    }
    for (FlowEntry f : rules) {
        if (f.state() == FlowEntry.FlowEntryState.ADDED) {
            PiTableId piTableId = f.table().type() == TableId.Type.PIPELINE_INDEPENDENT ? (PiTableId) f.table() : interpreter.mapFlowRuleTableId(((IndexTableId) f.table()).id()).get();
            piTableMatchCount.put(piTableId, piTableMatchCount.get(piTableId) + f.packets());
        }
    }
    return piTableMatchCount;
}
#method_after
private Map<PiTableId, Long> piMatchedCounting(PiPipelineModel model, PiPipelineInterpreter interpreter, List<FlowEntry> rules) {
    Map<PiTableId, Long> piTableMatchCount = new HashMap<>();
    for (PiTableModel tableModel : model.tables()) {
        piTableMatchCount.put(tableModel.id(), (long) 0);
    }
    for (FlowEntry f : rules) {
        if (f.state() == FlowEntry.FlowEntryState.ADDED) {
            PiTableId piTableId = getPiTableId(f, interpreter);
            if (piTableId != null) {
                piTableMatchCount.put(piTableId, piTableMatchCount.get(piTableId) + f.packets());
            }
        }
    }
    return piTableMatchCount;
}
#end_block

#method_before
private TableStatisticsEntry buildTableStatistics(DeviceId deviceId, OFTableStatsEntry ofEntry) {
    TableStatisticsEntry entry = null;
    if (ofEntry != null) {
        IndexTableId tid = IndexTableId.of(ofEntry.getTableId().getValue());
        long maxSize;
        try {
            maxSize = ofEntry.getMaxEntries();
        } catch (UnsupportedOperationException e) {
            maxSize = -1;
        }
        entry = new DefaultTableStatisticsEntry(deviceId, tid, ofEntry.getActiveCount(), ofEntry.getLookupCount().getValue(), ofEntry.getMatchedCount().getValue(), maxSize);
    }
    return entry;
}
#method_after
private TableStatisticsEntry buildTableStatistics(DeviceId deviceId, OFTableStatsEntry ofEntry) {
    TableStatisticsEntry entry = null;
    if (ofEntry != null) {
        IndexTableId tid = IndexTableId.of(ofEntry.getTableId().getValue());
        try {
            entry = DefaultTableStatisticsEntry.builder().withDeviceId(deviceId).withTableId(tid).withActiveFlowEntries(ofEntry.getActiveCount()).withPacketsLookedUpCount(ofEntry.getLookupCount().getValue()).withPacketsMatchedCount(ofEntry.getMatchedCount().getValue()).withMaxSize(ofEntry.getMaxEntries()).build();
        } catch (UnsupportedOperationException e) {
            // The exception "UnsupportedOperationException" is thrown by "getMaxEntries()".
            entry = DefaultTableStatisticsEntry.builder().withDeviceId(deviceId).withTableId(tid).withActiveFlowEntries(ofEntry.getActiveCount()).withPacketsLookedUpCount(ofEntry.getLookupCount().getValue()).withPacketsMatchedCount(ofEntry.getMatchedCount().getValue()).build();
        }
    }
    return entry;
}
#end_block

#method_before
@Override
protected void execute() {
    FlowRuleService flowService = get(FlowRuleService.class);
    DeviceService deviceService = get(DeviceService.class);
    PiPipeconfService pipeconfService = get(PiPipeconfService.class);
    SortedMap<Device, List<TableStatisticsEntry>> deviceTableStats = getSortedTableStats(deviceService, flowService, pipeconfService);
    if (outputJson()) {
        print("%s", json(deviceTableStats.keySet(), deviceTableStats));
    } else {
        deviceTableStats.forEach((device, tableStats) -> printTableStats(device, tableStats));
    }
}
#method_after
@Override
protected void execute() {
    FlowRuleService flowService = get(FlowRuleService.class);
    DeviceService deviceService = get(DeviceService.class);
    SortedMap<Device, List<TableStatisticsEntry>> deviceTableStats = getSortedTableStats(deviceService, flowService);
    if (outputJson()) {
        print("%s", json(deviceTableStats.keySet(), deviceTableStats));
    } else {
        deviceTableStats.forEach((device, tableStats) -> printTableStats(device, tableStats));
    }
}
#end_block

#method_before
protected void printTableStats(Device d, List<TableStatisticsEntry> tableStats) {
    boolean empty = tableStats == null || tableStats.isEmpty();
    print("deviceId=%s, tableCount=%d", d.id(), empty ? 0 : tableStats.size());
    if (!empty) {
        for (TableStatisticsEntry t : tableStats) {
            print(FORMAT, t.tableId(), t.activeFlowEntries(), t.packetsLookedup() == -1 ? "N/A" : t.packetsLookedup(), t.packetsMatched(), t.maxSize() == -1 ? "N/A" : t.maxSize());
        }
    }
}
#method_after
protected void printTableStats(Device d, List<TableStatisticsEntry> tableStats) {
    boolean empty = tableStats == null || tableStats.isEmpty();
    print("deviceId=%s, tableCount=%d", d.id(), empty ? 0 : tableStats.size());
    if (!empty) {
        for (TableStatisticsEntry t : tableStats) {
            print(FORMAT, t.table(), t.activeFlowEntries(), t.hasPacketsLookedup() ? t.packetsLookedup() : NA, t.packetsMatched(), t.hasMaxSize() ? t.maxSize() : NA);
        }
    }
}
#end_block

#method_before
protected SortedMap<Device, List<TableStatisticsEntry>> getSortedTableStats(DeviceService deviceService, FlowRuleService flowService, PiPipeconfService pipeconfService) {
    SortedMap<Device, List<TableStatisticsEntry>> deviceTableStats = new TreeMap<>(Comparators.ELEMENT_COMPARATOR);
    List<TableStatisticsEntry> tableStatsList;
    Iterable<Device> devices = uri == null ? deviceService.getDevices() : Collections.singletonList(deviceService.getDevice(DeviceId.deviceId(uri)));
    for (Device d : devices) {
        if (pipeconfService.ofDevice(d.id()).isPresent() && pipeconfService.getPipeconf(pipeconfService.ofDevice(d.id()).get()).isPresent()) {
            PiPipeconf pipeconf = pipeconfService.getPipeconf(pipeconfService.ofDevice(d.id()).get()).get();
            PiPipelineModel model = pipeconf.pipelineModel();
            PiPipelineInterpreter interpreter = d.as(PiPipelineInterpreter.class);
            List<FlowEntry> rules = newArrayList(flowService.getFlowEntries(d.id()));
            Map<PiTableId, Integer> piTableFlowCount = piFlowRuleCounting(flowService, model, interpreter, d.id());
            Map<PiTableId, Long> piTableMatchCount = piMatchedCounting(flowService, model, interpreter, d.id());
            tableStatsList = generatePiFlowTableStatistics(piTableFlowCount, piTableMatchCount, model, d.id());
            deviceTableStats.put(d, tableStatsList);
        } else {
            tableStatsList = newArrayList(flowService.getFlowTableStatistics(d.id()));
            tableStatsList.sort((p1, p2) -> Integer.valueOf(((IndexTableId) (p1.tableId())).id()).compareTo(Integer.valueOf((((IndexTableId) (p2.tableId())).id()))));
            deviceTableStats.put(d, tableStatsList);
        }
    }
    return deviceTableStats;
}
#method_after
protected SortedMap<Device, List<TableStatisticsEntry>> getSortedTableStats(DeviceService deviceService, FlowRuleService flowService) {
    SortedMap<Device, List<TableStatisticsEntry>> deviceTableStats = new TreeMap<>(Comparators.ELEMENT_COMPARATOR);
    List<TableStatisticsEntry> tableStatsList;
    Iterable<Device> devices = uri == null ? deviceService.getDevices() : Collections.singletonList(deviceService.getDevice(DeviceId.deviceId(uri)));
    for (Device d : devices) {
        tableStatsList = newArrayList(flowService.getFlowTableStatistics(d.id()));
        tableStatsList.sort((p1, p2) -> Integer.valueOf(p1.tableId()).compareTo(Integer.valueOf(p2.tableId())));
        deviceTableStats.put(d, tableStatsList);
    }
    return deviceTableStats;
}
#end_block

#method_before
@Override
public TableId tableId() {
    return tableId;
}
#method_after
@Override
public int tableId() {
    return tableId.type() == TableId.Type.INDEX ? ((IndexTableId) tableId).id() : tableId.hashCode();
}
#end_block

#method_before
@Override
public ObjectNode encode(TableStatisticsEntry entry, CodecContext context) {
    checkNotNull(entry, "Table Statistics entry cannot be null");
    final ObjectNode result = context.mapper().createObjectNode().put("tableId", entry.tableId().type() == TableId.Type.INDEX ? ((IndexTableId) (entry.tableId())).id().toString() : ((PiTableId) (entry.tableId())).id()).put("deviceId", entry.deviceId().toString()).put("activeEntries", entry.activeFlowEntries()).put("packetsLookedUp", entry.packetsLookedup()).put("packetsMatched", entry.packetsMatched());
    return result;
}
#method_after
@Override
public ObjectNode encode(TableStatisticsEntry entry, CodecContext context) {
    checkNotNull(entry, "Table Statistics entry cannot be null");
    final ObjectNode result = context.mapper().createObjectNode().put("tableId", entry.table().toString()).put("deviceId", entry.deviceId().toString()).put("activeEntries", entry.activeFlowEntries()).put("packetsLookedUp", entry.packetsLookedup()).put("packetsMatched", entry.packetsMatched());
    return result;
}
#end_block

#method_before
public PiCounterData data() {
    return counterData;
}
#method_after
public PiCounterCellData data() {
    return counterData;
}
#end_block

#method_before
@Override
public Collection<FlowEntry> getFlowEntries() {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    if (driverBoolProperty(READ_FROM_MIRROR, DEFAULT_READ_FROM_MIRROR)) {
        return getFlowEntriesFromMirror();
    }
    final ImmutableList.Builder<FlowEntry> result = ImmutableList.builder();
    final List<PiTableEntry> inconsistentEntries = Lists.newArrayList();
    // Read table entries, including default ones.
    final Collection<PiTableEntry> deviceEntries = Stream.concat(streamEntries(), streamDefaultEntries()).filter(e -> !tableIsConstant(e.table())).distinct().collect(Collectors.toList());
    if (deviceEntries.isEmpty()) {
        return Collections.emptyList();
    }
    // Synchronize mirror with the device state.
    syncMirror(deviceEntries);
    // Forge flow entries with counter values.
    for (PiTableEntry entry : deviceEntries) {
        final FlowEntry flowEntry = forgeFlowEntry(entry);
        if (flowEntry == null) {
            // that were not installed by us, e.g. original default entry.
            if (!isOriginalDefaultEntry(entry)) {
                inconsistentEntries.add(entry);
            }
        } else {
            result.add(flowEntry);
        }
    }
    if (inconsistentEntries.size() > 0) {
        // Trigger clean up of inconsistent entries.
        SharedExecutors.getSingleThreadExecutor().execute(() -> cleanUpInconsistentEntries(inconsistentEntries));
    }
    return result.build();
}
#method_after
@Override
public Collection<FlowEntry> getFlowEntries() {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    if (driverBoolProperty(READ_FROM_MIRROR, DEFAULT_READ_FROM_MIRROR)) {
        return getFlowEntriesFromMirror();
    }
    final ImmutableList.Builder<FlowEntry> result = ImmutableList.builder();
    final List<PiTableEntry> inconsistentEntries = Lists.newArrayList();
    // Read table entries, including default ones.
    final Collection<PiTableEntry> deviceEntries = Stream.concat(streamEntries(), streamDefaultEntries()).filter(e -> !tableIsConstant(e.table())).distinct().collect(Collectors.toList());
    if (deviceEntries.isEmpty()) {
        return Collections.emptyList();
    }
    // Synchronize mirror with the device state.
    syncMirror(deviceEntries);
    final Map<PiTableEntry, PiCounterCellData> counterCellMap = readEntryCounters(deviceEntries);
    // Forge flow entries with counter values.
    for (PiTableEntry entry : deviceEntries) {
        final FlowEntry flowEntry = forgeFlowEntry(entry, counterCellMap.get(entry));
        if (flowEntry == null) {
            // that were not installed by us, e.g. original default entry.
            if (!isOriginalDefaultEntry(entry)) {
                inconsistentEntries.add(entry);
            }
        } else {
            result.add(flowEntry);
        }
    }
    if (inconsistentEntries.size() > 0) {
        // Trigger clean up of inconsistent entries.
        SharedExecutors.getSingleThreadExecutor().execute(() -> cleanUpInconsistentEntries(inconsistentEntries));
    }
    return result.build();
}
#end_block

#method_before
private FlowEntry forgeFlowEntry(PiTableEntry entry) {
    final PiTableEntryHandle handle = PiTableEntryHandle.of(deviceId, entry);
    final Optional<PiTranslatedEntity<FlowRule, PiTableEntry>> translatedEntity = translator.lookup(handle);
    final TimedEntry<PiTableEntry> timedEntry = tableMirror.get(handle);
    final PiCounterData counterData = entry.counter();
    if (!translatedEntity.isPresent()) {
        log.warn("Table entry handle not found in translation store: {}", handle);
        return null;
    }
    if (!translatedEntity.get().translated().equals(entry)) {
        log.warn("Table entry obtained from device {} is different from " + "one in in translation store: device={}, store={}", deviceId, entry, translatedEntity.get().translated());
        return null;
    }
    if (timedEntry == null) {
        log.warn("Table entry handle not found in device mirror: {}", handle);
        return null;
    }
    if (counterData != null) {
        return new DefaultFlowEntry(translatedEntity.get().original(), ADDED, timedEntry.lifeSec(), counterData.packets(), counterData.bytes());
    } else {
        return new DefaultFlowEntry(translatedEntity.get().original(), ADDED, timedEntry.lifeSec(), 0, 0);
    }
}
#method_after
private FlowEntry forgeFlowEntry(PiTableEntry entry, PiCounterCellData cellData) {
    final PiTableEntryHandle handle = PiTableEntryHandle.of(deviceId, entry);
    final Optional<PiTranslatedEntity<FlowRule, PiTableEntry>> translatedEntity = translator.lookup(handle);
    final TimedEntry<PiTableEntry> timedEntry = tableMirror.get(handle);
    if (!translatedEntity.isPresent()) {
        log.warn("Table entry handle not found in translation store: {}", handle);
        return null;
    }
    if (!translatedEntity.get().translated().equals(entry)) {
        log.warn("Table entry obtained from device {} is different from " + "one in in translation store: device={}, store={}", deviceId, entry, translatedEntity.get().translated());
        return null;
    }
    if (timedEntry == null) {
        log.warn("Table entry handle not found in device mirror: {}", handle);
        return null;
    }
    if (cellData != null) {
        return new DefaultFlowEntry(translatedEntity.get().original(), ADDED, timedEntry.lifeSec(), cellData.packets(), cellData.bytes());
    } else {
        return new DefaultFlowEntry(translatedEntity.get().original(), ADDED, timedEntry.lifeSec(), 0, 0);
    }
}
#end_block

#method_before
private Collection<FlowEntry> getFlowEntriesFromMirror() {
    return tableMirror.getAll(deviceId).stream().map(timedEntry -> forgeFlowEntry(timedEntry.entry())).filter(Objects::nonNull).collect(Collectors.toList());
}
#method_after
private Collection<FlowEntry> getFlowEntriesFromMirror() {
    return tableMirror.getAll(deviceId).stream().map(timedEntry -> forgeFlowEntry(timedEntry.entry(), null)).filter(Objects::nonNull).collect(Collectors.toList());
}
#end_block

#method_before
private Map<PiTableEntry, PiCounterCell> readEntryCounters(Collection<PiTableEntry> tableEntries) {
    if (!driverBoolProperty(SUPPORT_TABLE_COUNTERS, DEFAULT_SUPPORT_TABLE_COUNTERS) || tableEntries.isEmpty()) {
        return Collections.emptyMap();
    }
    Collection<PiCounterCell> cellDatas;
    if (driverBoolProperty(READ_ALL_DIRECT_COUNTERS, DEFAULT_READ_ALL_DIRECT_COUNTERS)) {
        // FIXME: read counters when dumping table entries ONOS-7596
        cellDatas = Collections.emptyList();
    } else {
        Set<PiCounterCellId> cellIds = tableEntries.stream().filter(e -> !e.isDefaultAction()).filter(e -> tableHasCounter(e.table())).map(PiCounterCellId::ofDirect).collect(Collectors.toSet());
        cellDatas = getFutureWithDeadline(client.readCounterCells(cellIds, pipeconf), "reading table counters", Collections.emptyList());
    }
    return cellDatas.stream().collect(Collectors.toMap(c -> c.cellId().tableEntry(), c -> c));
}
#method_after
private Map<PiTableEntry, PiCounterCellData> readEntryCounters(Collection<PiTableEntry> tableEntries) {
    if (!driverBoolProperty(SUPPORT_TABLE_COUNTERS, DEFAULT_SUPPORT_TABLE_COUNTERS) || tableEntries.isEmpty()) {
        return Collections.emptyMap();
    }
    if (driverBoolProperty(READ_COUNTERS_WITH_TABLE_ENTRIES, DEFAULT_READ_COUNTERS_WITH_TABLE_ENTRIES)) {
        return tableEntries.stream().collect(Collectors.toMap(c -> c, PiTableEntry::counter));
    } else {
        Collection<PiCounterCell> cells;
        Set<PiCounterCellId> cellIds = tableEntries.stream().filter(e -> !e.isDefaultAction()).filter(e -> tableHasCounter(e.table())).map(PiCounterCellId::ofDirect).collect(Collectors.toSet());
        cells = getFutureWithDeadline(client.readCounterCells(cellIds, pipeconf), "reading table counters", Collections.emptyList());
        return cells.stream().collect(Collectors.toMap(c -> c.cellId().tableEntry(), PiCounterCell::data));
    }
}
#end_block

#method_before
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    DeviceId deviceId = this.data().deviceId();
    PiPipeconfService piPipeconfService = handler().get(PiPipeconfService.class);
    if (!piPipeconfService.ofDevice(deviceId).isPresent() || !piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).isPresent()) {
        log.warn("Unable to get the pipeconf of {}, aborting operation", deviceId);
        return Collections.emptyList();
    }
    PiPipeconf pipeconf = piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).get();
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    P4RuntimeClient client = controller.getClient(deviceId);
    if (client == null) {
        log.warn("Unable to find client for {}, aborting operation", deviceId);
        return Collections.emptyList();
    }
    Map<Long, DefaultPortStatistics.Builder> portStatBuilders = Maps.newHashMap();
    deviceService.getPorts(deviceId).forEach(p -> portStatBuilders.put(p.number().toLong(), DefaultPortStatistics.builder().setPort(p.number()).setDeviceId(deviceId).setDurationSec(getDuration(p.number()))));
    Set<PiCounterCellId> counterCellIds = Sets.newHashSet();
    portStatBuilders.keySet().forEach(p -> {
        // Counter cell/index = port number.
        counterCellIds.add(PiCounterCellId.ofIndirect(ingressCounterId(), p));
        counterCellIds.add(PiCounterCellId.ofIndirect(egressCounterId(), p));
    });
    Collection<PiCounterCell> counterEntryResponse;
    try {
        counterEntryResponse = client.readCounterCells(counterCellIds, pipeconf).get();
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Exception while reading port counters from {}: {}", deviceId, e.toString());
        log.debug("", e);
        return Collections.emptyList();
    }
    counterEntryResponse.forEach(counterData -> {
        if (counterData.cellId().counterType() != INDIRECT) {
            log.warn("Invalid counter data type {}, skipping", counterData.cellId().counterType());
            return;
        }
        PiCounterCellId indCellId = counterData.cellId();
        if (!portStatBuilders.containsKey(indCellId.index())) {
            log.warn("Unrecognized counter index {}, skipping", counterData);
            return;
        }
        DefaultPortStatistics.Builder statsBuilder = portStatBuilders.get(indCellId.index());
        if (counterData.cellId().counterId().equals(ingressCounterId())) {
            statsBuilder.setPacketsReceived(counterData.packets());
            statsBuilder.setBytesReceived(counterData.bytes());
        } else if (counterData.cellId().counterId().equals(egressCounterId())) {
            statsBuilder.setPacketsSent(counterData.packets());
            statsBuilder.setBytesSent(counterData.bytes());
        } else {
            log.warn("Unrecognized counter ID {}, skipping", counterData);
        }
    });
    return portStatBuilders.values().stream().map(DefaultPortStatistics.Builder::build).collect(Collectors.toList());
}
#method_after
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    DeviceId deviceId = this.data().deviceId();
    PiPipeconfService piPipeconfService = handler().get(PiPipeconfService.class);
    if (!piPipeconfService.ofDevice(deviceId).isPresent() || !piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).isPresent()) {
        log.warn("Unable to get the pipeconf of {}, aborting operation", deviceId);
        return Collections.emptyList();
    }
    PiPipeconf pipeconf = piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).get();
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    P4RuntimeClient client = controller.getClient(deviceId);
    if (client == null) {
        log.warn("Unable to find client for {}, aborting operation", deviceId);
        return Collections.emptyList();
    }
    Map<Long, DefaultPortStatistics.Builder> portStatBuilders = Maps.newHashMap();
    deviceService.getPorts(deviceId).forEach(p -> portStatBuilders.put(p.number().toLong(), DefaultPortStatistics.builder().setPort(p.number()).setDeviceId(deviceId).setDurationSec(getDuration(p.number()))));
    Set<PiCounterCellId> counterCellIds = Sets.newHashSet();
    portStatBuilders.keySet().forEach(p -> {
        // Counter cell/index = port number.
        counterCellIds.add(PiCounterCellId.ofIndirect(ingressCounterId(), p));
        counterCellIds.add(PiCounterCellId.ofIndirect(egressCounterId(), p));
    });
    Collection<PiCounterCell> counterEntryResponse;
    try {
        counterEntryResponse = client.readCounterCells(counterCellIds, pipeconf).get();
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Exception while reading port counters from {}: {}", deviceId, e.toString());
        log.debug("", e);
        return Collections.emptyList();
    }
    counterEntryResponse.forEach(counterCell -> {
        if (counterCell.cellId().counterType() != INDIRECT) {
            log.warn("Invalid counter data type {}, skipping", counterCell.cellId().counterType());
            return;
        }
        PiCounterCellId indCellId = counterCell.cellId();
        if (!portStatBuilders.containsKey(indCellId.index())) {
            log.warn("Unrecognized counter index {}, skipping", counterCell);
            return;
        }
        DefaultPortStatistics.Builder statsBuilder = portStatBuilders.get(indCellId.index());
        if (counterCell.cellId().counterId().equals(ingressCounterId())) {
            statsBuilder.setPacketsReceived(counterCell.data().packets());
            statsBuilder.setBytesReceived(counterCell.data().bytes());
        } else if (counterCell.cellId().counterId().equals(egressCounterId())) {
            statsBuilder.setPacketsSent(counterCell.data().packets());
            statsBuilder.setBytesSent(counterCell.data().bytes());
        } else {
            log.warn("Unrecognized counter ID {}, skipping", counterCell);
        }
    });
    return portStatBuilders.values().stream().map(DefaultPortStatistics.Builder::build).collect(Collectors.toList());
}
#end_block

#method_before
@Test
public void testTableEntryEncoder() throws Exception {
    Collection<TableEntry> result = encode(Lists.newArrayList(piTableEntry), defaultPipeconf);
    assertThat(result, hasSize(1));
    TableEntry tableEntryMsg = result.iterator().next();
    Collection<PiTableEntry> decodedResults = decode(Lists.newArrayList(tableEntryMsg), defaultPipeconf);
    PiTableEntry decodedPiTableEntry = decodedResults.iterator().next();
    // Test equality for decoded entry.
    new EqualsTester().addEqualityGroup(piTableEntry, decodedPiTableEntry).testEquals();
    // Table ID.
    int p4InfoTableId = browser.tables().getByName(tableId.id()).getPreamble().getId();
    int encodedTableId = tableEntryMsg.getTableId();
    assertThat(encodedTableId, is(p4InfoTableId));
    // Ternary match.
    byte[] encodedTernaryMatchValue = tableEntryMsg.getMatch(0).getTernary().getValue().toByteArray();
    assertThat(encodedTernaryMatchValue, is(ethAddr.asArray()));
    Action actionMsg = tableEntryMsg.getAction().getAction();
    // Action ID.
    int p4InfoActionId = browser.actions().getByName(outActionId.toString()).getPreamble().getId();
    int encodedActionId = actionMsg.getActionId();
    assertThat(encodedActionId, is(p4InfoActionId));
    // Action param ID.
    int p4InfoActionParamId = browser.actionParams(p4InfoActionId).getByName(portParamId.toString()).getId();
    int encodedActionParamId = actionMsg.getParams(0).getParamId();
    assertThat(encodedActionParamId, is(p4InfoActionParamId));
    // Action param value.
    byte[] encodedActionParam = actionMsg.getParams(0).getValue().toByteArray();
    assertThat(encodedActionParam, is(portValue.asArray()));
    // Counter
    CounterData counterData = tableEntryMsg.getCounterData();
    PiCounterData encodedCounterData = new PiCounterData(counterData.getPacketCount(), counterData.getByteCount());
    assertThat(encodedCounterData, is(piCounterData));
// TODO: improve, assert other field match types (ternary, LPM)
}
#method_after
@Test
public void testTableEntryEncoder() throws Exception {
    Collection<TableEntry> result = encode(Lists.newArrayList(piTableEntry), defaultPipeconf);
    assertThat(result, hasSize(1));
    TableEntry tableEntryMsg = result.iterator().next();
    Collection<PiTableEntry> decodedResults = decode(Lists.newArrayList(tableEntryMsg), defaultPipeconf);
    PiTableEntry decodedPiTableEntry = decodedResults.iterator().next();
    // Test equality for decoded entry.
    new EqualsTester().addEqualityGroup(piTableEntry, decodedPiTableEntry).testEquals();
    // Table ID.
    int p4InfoTableId = browser.tables().getByName(tableId.id()).getPreamble().getId();
    int encodedTableId = tableEntryMsg.getTableId();
    assertThat(encodedTableId, is(p4InfoTableId));
    // Ternary match.
    byte[] encodedTernaryMatchValue = tableEntryMsg.getMatch(0).getTernary().getValue().toByteArray();
    assertThat(encodedTernaryMatchValue, is(ethAddr.asArray()));
    Action actionMsg = tableEntryMsg.getAction().getAction();
    // Action ID.
    int p4InfoActionId = browser.actions().getByName(outActionId.toString()).getPreamble().getId();
    int encodedActionId = actionMsg.getActionId();
    assertThat(encodedActionId, is(p4InfoActionId));
    // Action param ID.
    int p4InfoActionParamId = browser.actionParams(p4InfoActionId).getByName(portParamId.toString()).getId();
    int encodedActionParamId = actionMsg.getParams(0).getParamId();
    assertThat(encodedActionParamId, is(p4InfoActionParamId));
    // Action param value.
    byte[] encodedActionParam = actionMsg.getParams(0).getValue().toByteArray();
    assertThat(encodedActionParam, is(portValue.asArray()));
    // Counter
    CounterData counterData = tableEntryMsg.getCounterData();
    PiCounterCellData encodedCounterData = new PiCounterCellData(counterData.getPacketCount(), counterData.getByteCount());
    assertThat(encodedCounterData, is(counterCellData));
// TODO: improve, assert other field match types (ternary, LPM)
}
#end_block

#method_before
@Test
public void testEncodeWithNoAction() throws Exception {
    Collection<TableEntry> result = encode(Lists.newArrayList(piTableEntryWithoutAction), defaultPipeconf);
    assertThat(result, hasSize(1));
    TableEntry tableEntryMsg = result.iterator().next();
    Collection<PiTableEntry> decodedResults = decode(Lists.newArrayList(tableEntryMsg), defaultPipeconf);
    PiTableEntry decodedPiTableEntry = decodedResults.iterator().next();
    // Test equality for decoded entry.
    new EqualsTester().addEqualityGroup(piTableEntryWithoutAction, decodedPiTableEntry).testEquals();
    // Table ID.
    int p4InfoTableId = browser.tables().getByName(tableId.id()).getPreamble().getId();
    int encodedTableId = tableEntryMsg.getTableId();
    assertThat(encodedTableId, is(p4InfoTableId));
    // Ternary match.
    byte[] encodedTernaryMatchValue = tableEntryMsg.getMatch(0).getTernary().getValue().toByteArray();
    assertThat(encodedTernaryMatchValue, is(ethAddr.asArray()));
    // no action
    assertThat(tableEntryMsg.hasAction(), is(false));
    // Counter
    CounterData counterData = tableEntryMsg.getCounterData();
    PiCounterData encodedCounterData = new PiCounterData(counterData.getPacketCount(), counterData.getByteCount());
    assertThat(encodedCounterData, is(piCounterData));
// TODO: improve, assert other field match types (ternary, LPM)
}
#method_after
@Test
public void testEncodeWithNoAction() throws Exception {
    Collection<TableEntry> result = encode(Lists.newArrayList(piTableEntryWithoutAction), defaultPipeconf);
    assertThat(result, hasSize(1));
    TableEntry tableEntryMsg = result.iterator().next();
    Collection<PiTableEntry> decodedResults = decode(Lists.newArrayList(tableEntryMsg), defaultPipeconf);
    PiTableEntry decodedPiTableEntry = decodedResults.iterator().next();
    // Test equality for decoded entry.
    new EqualsTester().addEqualityGroup(piTableEntryWithoutAction, decodedPiTableEntry).testEquals();
    // Table ID.
    int p4InfoTableId = browser.tables().getByName(tableId.id()).getPreamble().getId();
    int encodedTableId = tableEntryMsg.getTableId();
    assertThat(encodedTableId, is(p4InfoTableId));
    // Ternary match.
    byte[] encodedTernaryMatchValue = tableEntryMsg.getMatch(0).getTernary().getValue().toByteArray();
    assertThat(encodedTernaryMatchValue, is(ethAddr.asArray()));
    // no action
    assertThat(tableEntryMsg.hasAction(), is(false));
    // Counter
    CounterData counterData = tableEntryMsg.getCounterData();
    PiCounterCellData encodedCounterData = new PiCounterCellData(counterData.getPacketCount(), counterData.getByteCount());
    assertThat(encodedCounterData, is(counterCellData));
// TODO: improve, assert other field match types (ternary, LPM)
}
#end_block

#method_before
public PiCounterData counter() {
    return counterData;
}
#method_after
public PiCounterCellData counter() {
    return counterData;
}
#end_block

#method_before
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    DeviceId deviceId = this.data().deviceId();
    // Get a client for this device.
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    P4RuntimeClient client = controller.getClient(deviceId);
    if (client == null) {
        log.warn("Unable to find client for {}, aborting operation", deviceId);
        return Collections.emptyList();
    }
    // Get the pipeconf of this device.
    PiPipeconfService piPipeconfService = handler().get(PiPipeconfService.class);
    if (!piPipeconfService.ofDevice(deviceId).isPresent() || !piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).isPresent()) {
        log.warn("Unable to get the pipeconf of {}, aborting operation", deviceId);
        return Collections.emptyList();
    }
    PiPipeconf pipeconf = piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).get();
    // Prepare PortStatistics objects to return, one per port of this device.
    Map<Long, DefaultPortStatistics.Builder> portStatBuilders = Maps.newHashMap();
    deviceService.getPorts(deviceId).forEach(p -> portStatBuilders.put(p.number().toLong(), DefaultPortStatistics.builder().setPort(p.number()).setDeviceId(deviceId)));
    // Generate the counter cell IDs.
    Set<PiCounterCellId> counterCellIds = Sets.newHashSet();
    portStatBuilders.keySet().forEach(p -> {
        // Counter cell/index = port number.
        counterCellIds.add(PiCounterCellId.ofIndirect(INGRESS_COUNTER_ID, p));
        counterCellIds.add(PiCounterCellId.ofIndirect(EGRESS_COUNTER_ID, p));
    });
    // Query the device.
    Collection<PiCounterCell> counterEntryResponse;
    try {
        counterEntryResponse = client.readCounterCells(counterCellIds, pipeconf).get();
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Exception while reading port counters from {}: {}", deviceId, e.toString());
        log.debug("", e);
        return Collections.emptyList();
    }
    // Process response.
    counterEntryResponse.forEach(counterData -> {
        if (counterData.cellId().counterType() != INDIRECT) {
            log.warn("Invalid counter data type {}, skipping", counterData.cellId().counterType());
            return;
        }
        if (!portStatBuilders.containsKey(counterData.cellId().index())) {
            log.warn("Unrecognized counter index {}, skipping", counterData);
            return;
        }
        DefaultPortStatistics.Builder statsBuilder = portStatBuilders.get(counterData.cellId().index());
        if (counterData.cellId().counterId().equals(INGRESS_COUNTER_ID)) {
            statsBuilder.setPacketsReceived(counterData.packets());
            statsBuilder.setBytesReceived(counterData.bytes());
        } else if (counterData.cellId().counterId().equals(EGRESS_COUNTER_ID)) {
            statsBuilder.setPacketsSent(counterData.packets());
            statsBuilder.setBytesSent(counterData.bytes());
        } else {
            log.warn("Unrecognized counter ID {}, skipping", counterData);
        }
    });
    return portStatBuilders.values().stream().map(DefaultPortStatistics.Builder::build).collect(Collectors.toList());
}
#method_after
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    DeviceId deviceId = this.data().deviceId();
    // Get a client for this device.
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    P4RuntimeClient client = controller.getClient(deviceId);
    if (client == null) {
        log.warn("Unable to find client for {}, aborting operation", deviceId);
        return Collections.emptyList();
    }
    // Get the pipeconf of this device.
    PiPipeconfService piPipeconfService = handler().get(PiPipeconfService.class);
    if (!piPipeconfService.ofDevice(deviceId).isPresent() || !piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).isPresent()) {
        log.warn("Unable to get the pipeconf of {}, aborting operation", deviceId);
        return Collections.emptyList();
    }
    PiPipeconf pipeconf = piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).get();
    // Prepare PortStatistics objects to return, one per port of this device.
    Map<Long, DefaultPortStatistics.Builder> portStatBuilders = Maps.newHashMap();
    deviceService.getPorts(deviceId).forEach(p -> portStatBuilders.put(p.number().toLong(), DefaultPortStatistics.builder().setPort(p.number()).setDeviceId(deviceId)));
    // Generate the counter cell IDs.
    Set<PiCounterCellId> counterCellIds = Sets.newHashSet();
    portStatBuilders.keySet().forEach(p -> {
        // Counter cell/index = port number.
        counterCellIds.add(PiCounterCellId.ofIndirect(INGRESS_COUNTER_ID, p));
        counterCellIds.add(PiCounterCellId.ofIndirect(EGRESS_COUNTER_ID, p));
    });
    // Query the device.
    Collection<PiCounterCell> counterEntryResponse;
    try {
        counterEntryResponse = client.readCounterCells(counterCellIds, pipeconf).get();
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Exception while reading port counters from {}: {}", deviceId, e.toString());
        log.debug("", e);
        return Collections.emptyList();
    }
    // Process response.
    counterEntryResponse.forEach(counterCell -> {
        if (counterCell.cellId().counterType() != INDIRECT) {
            log.warn("Invalid counter data type {}, skipping", counterCell.cellId().counterType());
            return;
        }
        if (!portStatBuilders.containsKey(counterCell.cellId().index())) {
            log.warn("Unrecognized counter index {}, skipping", counterCell);
            return;
        }
        DefaultPortStatistics.Builder statsBuilder = portStatBuilders.get(counterCell.cellId().index());
        if (counterCell.cellId().counterId().equals(INGRESS_COUNTER_ID)) {
            statsBuilder.setPacketsReceived(counterCell.data().packets());
            statsBuilder.setBytesReceived(counterCell.data().bytes());
        } else if (counterCell.cellId().counterId().equals(EGRESS_COUNTER_ID)) {
            statsBuilder.setPacketsSent(counterCell.data().packets());
            statsBuilder.setBytesSent(counterCell.data().bytes());
        } else {
            log.warn("Unrecognized counter ID {}, skipping", counterCell);
        }
    });
    return portStatBuilders.values().stream().map(DefaultPortStatistics.Builder::build).collect(Collectors.toList());
}
#end_block

#method_before
private static PiTableEntry decodeTableEntryMsg(TableEntry tableEntryMsg, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    PiTableEntry.Builder piTableEntryBuilder = PiTableEntry.builder();
    P4InfoOuterClass.Table tableInfo = browser.tables().getById(tableEntryMsg.getTableId());
    // Table id.
    piTableEntryBuilder.forTable(PiTableId.of(tableInfo.getPreamble().getName()));
    // Priority.
    if (tableEntryMsg.getPriority() > 0) {
        piTableEntryBuilder.withPriority(tableEntryMsg.getPriority());
    }
    // Controller metadata (cookie)
    piTableEntryBuilder.withCookie(tableEntryMsg.getControllerMetadata());
    // Table action.
    if (tableEntryMsg.hasAction()) {
        piTableEntryBuilder.withAction(decodeTableActionMsg(tableEntryMsg.getAction(), browser));
    }
    // Timeout.
    // FIXME: how to decode table entry messages with timeout, given that the timeout value is lost after encoding?
    // Match key for field matches.
    piTableEntryBuilder.withMatchKey(decodeFieldMatchMsgs(tableEntryMsg.getMatchList(), tableInfo, browser));
    // Counter.
    piTableEntryBuilder.withCounter(decodeCounter(tableEntryMsg.getCounterData()));
    return piTableEntryBuilder.build();
}
#method_after
private static PiTableEntry decodeTableEntryMsg(TableEntry tableEntryMsg, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    PiTableEntry.Builder piTableEntryBuilder = PiTableEntry.builder();
    P4InfoOuterClass.Table tableInfo = browser.tables().getById(tableEntryMsg.getTableId());
    // Table id.
    piTableEntryBuilder.forTable(PiTableId.of(tableInfo.getPreamble().getName()));
    // Priority.
    if (tableEntryMsg.getPriority() > 0) {
        piTableEntryBuilder.withPriority(tableEntryMsg.getPriority());
    }
    // Controller metadata (cookie)
    piTableEntryBuilder.withCookie(tableEntryMsg.getControllerMetadata());
    // Table action.
    if (tableEntryMsg.hasAction()) {
        piTableEntryBuilder.withAction(decodeTableActionMsg(tableEntryMsg.getAction(), browser));
    }
    // Timeout.
    // FIXME: how to decode table entry messages with timeout, given that the timeout value is lost after encoding?
    // Match key for field matches.
    piTableEntryBuilder.withMatchKey(decodeFieldMatchMsgs(tableEntryMsg.getMatchList(), tableInfo, browser));
    // Counter.
    piTableEntryBuilder.withCounterCellData(decodeCounter(tableEntryMsg.getCounterData()));
    return piTableEntryBuilder.build();
}
#end_block

#method_before
static CounterData encodeCounter(PiCounterData piCounterData) {
    return CounterData.newBuilder().setPacketCount(piCounterData.packets()).setByteCount(piCounterData.bytes()).build();
}
#method_after
static CounterData encodeCounter(PiCounterCellData piCounterCellData) {
    return CounterData.newBuilder().setPacketCount(piCounterCellData.packets()).setByteCount(piCounterCellData.bytes()).build();
}
#end_block

#method_before
static PiCounterData decodeCounter(CounterData counterData) {
    return new PiCounterData(counterData.getPacketCount(), counterData.getByteCount());
}
#method_after
static PiCounterCellData decodeCounter(CounterData counterData) {
    return new PiCounterCellData(counterData.getPacketCount(), counterData.getByteCount());
}
#end_block

#method_before
private ForwardingPipelineConfig getPipelineConfig(PiPipeconf pipeconf, ByteBuffer deviceData) {
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return null;
    }
    // FIXME: This is specific to PI P4Runtime implementation.
    P4Config.P4DeviceConfig p4DeviceConfigMsg = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.copyFrom(deviceData)).build();
    return ForwardingPipelineConfig.newBuilder().setP4Info(p4Info).setP4DeviceConfig(p4DeviceConfigMsg.toByteString()).build();
}
#method_after
private ForwardingPipelineConfig getPipelineConfig(PiPipeconf pipeconf, ByteBuffer deviceData) {
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return null;
    }
    ForwardingPipelineConfig.Cookie pipeconfCookie = ForwardingPipelineConfig.Cookie.newBuilder().setCookie(pipeconf.fingerprint()).build();
    // FIXME: This is specific to PI P4Runtime implementation.
    P4Config.P4DeviceConfig p4DeviceConfigMsg = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.copyFrom(deviceData)).build();
    return ForwardingPipelineConfig.newBuilder().setP4Info(p4Info).setP4DeviceConfig(p4DeviceConfigMsg.toByteString()).setCookie(pipeconfCookie).build();
}
#end_block

#method_before
private boolean doIsPipelineConfigSet(PiPipeconf pipeconf, ByteBuffer deviceData) {
    GetForwardingPipelineConfigRequest request = GetForwardingPipelineConfigRequest.newBuilder().setDeviceId(p4DeviceId).build();
    GetForwardingPipelineConfigResponse resp;
    try {
        resp = this.blockingStub.getForwardingPipelineConfig(request);
    } catch (StatusRuntimeException ex) {
        checkGrpcException(ex);
        // the first place. Don't bother logging.
        if (!ex.getStatus().getCode().equals(Status.FAILED_PRECONDITION.getCode())) {
            log.warn("Unable to get pipeline config from {}: {}", deviceId, ex.getMessage());
        }
        return false;
    }
    ForwardingPipelineConfig expectedConfig = getPipelineConfig(pipeconf, deviceData);
    if (expectedConfig == null) {
        return false;
    }
    if (!resp.hasConfig()) {
        log.warn("{} returned GetForwardingPipelineConfigResponse " + "with 'config' field unset", deviceId);
        return false;
    }
    if (resp.getConfig().getP4DeviceConfig().isEmpty() && !expectedConfig.getP4DeviceConfig().isEmpty()) {
        // Don't bother with a warn or error since we don't really allow
        // updating the pipeline to a different one. So the P4Info should be
        // enough for us.
        log.debug("{} returned GetForwardingPipelineConfigResponse " + "with empty 'p4_device_config' field, " + "equality will be based only on P4Info", deviceId);
        return resp.getConfig().getP4Info().equals(expectedConfig.getP4Info());
    } else {
        return resp.getConfig().equals(expectedConfig);
    }
}
#method_after
private boolean doIsPipelineConfigSet(PiPipeconf pipeconf, ByteBuffer deviceData) {
    GetForwardingPipelineConfigRequest request = GetForwardingPipelineConfigRequest.newBuilder().setDeviceId(p4DeviceId).setResponseType(GetForwardingPipelineConfigRequest.ResponseType.COOKIE_ONLY).build();
    GetForwardingPipelineConfigResponse resp;
    try {
        resp = this.blockingStub.getForwardingPipelineConfig(request);
    } catch (StatusRuntimeException ex) {
        checkGrpcException(ex);
        // the first place. Don't bother logging.
        if (!ex.getStatus().getCode().equals(Status.FAILED_PRECONDITION.getCode())) {
            log.warn("Unable to get pipeline config from {}: {}", deviceId, ex.getMessage());
        }
        return false;
    }
    if (!resp.getConfig().hasCookie()) {
        log.warn("{} returned GetForwardingPipelineConfigResponse " + "with 'cookie' field unset", deviceId);
        return false;
    }
    return resp.getConfig().getCookie().getCookie() == pipeconf.fingerprint();
}
#end_block

#method_before
private List<PiTableEntry> doDumpTables(Set<PiTableId> piTableIds, boolean defaultEntries, PiPipeconf pipeconf) {
    log.debug("Dumping tables {} from {} (pipeconf {})...", piTableIds, deviceId, pipeconf.id());
    Set<Integer> tableIds = Sets.newHashSet();
    if (piTableIds == null) {
        // Dump all tables.
        tableIds.add(0);
    } else {
        P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
        if (browser == null) {
            log.warn("Unable to get a P4Info browser for pipeconf {}", pipeconf);
            return Collections.emptyList();
        }
        piTableIds.forEach(piTableId -> {
            try {
                tableIds.add(browser.tables().getByName(piTableId.id()).getPreamble().getId());
            } catch (P4InfoBrowser.NotFoundException e) {
                log.warn("Unable to dump table {}: {}", piTableId, e.getMessage());
            }
        });
    }
    if (tableIds.isEmpty()) {
        return Collections.emptyList();
    }
    ReadRequest.Builder requestMsgBuilder = ReadRequest.newBuilder().setDeviceId(p4DeviceId);
    tableIds.forEach(tableId -> requestMsgBuilder.addEntities(Entity.newBuilder().setTableEntry(TableEntry.newBuilder().setTableId(tableId).setIsDefaultAction(defaultEntries).build()).build()).build());
    Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestMsgBuilder.build());
    } catch (StatusRuntimeException e) {
        checkGrpcException(e);
        log.warn("Unable to dump tables from {}: {}", deviceId, e.getMessage());
        return Collections.emptyList();
    }
    Iterable<ReadResponse> responseIterable = () -> responses;
    List<TableEntry> tableEntryMsgs = StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == TABLE_ENTRY).map(Entity::getTableEntry).collect(Collectors.toList());
    log.debug("Retrieved {} entries from {} tables on {}...", tableEntryMsgs.size(), tableIds.size(), deviceId);
    return TableEntryEncoder.decode(tableEntryMsgs, pipeconf);
}
#method_after
private List<PiTableEntry> doDumpTables(Set<PiTableId> piTableIds, boolean defaultEntries, PiPipeconf pipeconf) {
    log.debug("Dumping tables {} from {} (pipeconf {})...", piTableIds, deviceId, pipeconf.id());
    Set<Integer> tableIds = Sets.newHashSet();
    if (piTableIds == null) {
        // Dump all tables.
        tableIds.add(0);
    } else {
        P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
        if (browser == null) {
            log.warn("Unable to get a P4Info browser for pipeconf {}", pipeconf);
            return Collections.emptyList();
        }
        piTableIds.forEach(piTableId -> {
            try {
                tableIds.add(browser.tables().getByName(piTableId.id()).getPreamble().getId());
            } catch (P4InfoBrowser.NotFoundException e) {
                log.warn("Unable to dump table {}: {}", piTableId, e.getMessage());
            }
        });
    }
    if (tableIds.isEmpty()) {
        return Collections.emptyList();
    }
    ReadRequest.Builder requestMsgBuilder = ReadRequest.newBuilder().setDeviceId(p4DeviceId);
    tableIds.forEach(tableId -> requestMsgBuilder.addEntities(Entity.newBuilder().setTableEntry(TableEntry.newBuilder().setTableId(tableId).setIsDefaultAction(defaultEntries).setCounterData(P4RuntimeOuterClass.CounterData.getDefaultInstance()).build()).build()).build());
    Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestMsgBuilder.build());
    } catch (StatusRuntimeException e) {
        checkGrpcException(e);
        log.warn("Unable to dump tables from {}: {}", deviceId, e.getMessage());
        return Collections.emptyList();
    }
    Iterable<ReadResponse> responseIterable = () -> responses;
    List<TableEntry> tableEntryMsgs = StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == TABLE_ENTRY).map(Entity::getTableEntry).collect(Collectors.toList());
    log.debug("Retrieved {} entries from {} tables on {}...", tableEntryMsgs.size(), tableIds.size(), deviceId);
    return TableEntryEncoder.decode(tableEntryMsgs, pipeconf);
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    providerService = providerRegistry.register(this);
    factories.forEach(cfgService::registerConfigFactory);
    executor = Executors.newFixedThreadPool(EXECUTOR_THREAD_POOL_SIZE, groupedThreads("onos/restsbprovider", "device-installer-%d", log));
    cfgService.addListener(configListener);
    executor.execute(RestDeviceProvider.this::createAndConnectDevices);
    scheduledTask = schedulePolling();
    devicePollTask = scheduleDevicePolling();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    compCfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    factories.forEach(netCfgService::registerConfigFactory);
    executor = Executors.newFixedThreadPool(EXECUTOR_THREAD_POOL_SIZE, groupedThreads("onos/restsbprovider", "device-installer-%d", log));
    netCfgService.addListener(configListener);
    executor.execute(RestDeviceProvider.this::createAndConnectDevices);
    scheduledTask = schedulePolling();
    devicePollTask = scheduleDevicePolling();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    cfgService.removeListener(configListener);
    providerRegistry.unregister(this);
    providerService = null;
    factories.forEach(cfgService::unregisterConfigFactory);
    scheduledTask.cancel(true);
    executor.shutdown();
    devicePollTask.cancel(true);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    compCfgService.unregisterProperties(getClass(), false);
    netCfgService.removeListener(configListener);
    providerRegistry.unregister(this);
    providerService = null;
    factories.forEach(netCfgService::unregisterConfigFactory);
    scheduledTask.cancel(true);
    executor.shutdown();
    devicePollTask.cancel(true);
    log.info("Stopped");
}
#end_block

#method_before
private ScheduledFuture scheduleDevicePolling() {
    return deviceConnectionExecutor.scheduleWithFixedDelay(() -> {
        try {
            controller.getDevices().values().stream().forEach(restSBDevice -> {
                DeviceId deviceId = restSBDevice.deviceId();
                if (deviceService.getDevice(deviceId) != null) {
                    boolean connected = testDeviceConnection(restSBDevice);
                    restSBDevice.setActive(connected);
                    if (deviceService.isAvailable(deviceId) && (!connected)) {
                        providerService.deviceDisconnected(deviceId);
                    } else if ((!deviceService.isAvailable(deviceId)) && (connected)) {
                        DeviceDescription devDesc = getDesc(restSBDevice);
                        checkNotNull(devDesc, "deviceDescription cannot be null");
                        providerService.deviceConnected(deviceId, mergeAnn(deviceId, devDesc));
                    }
                }
            });
        } catch (Exception e) {
            log.error("Exception at schedule Device polling", e);
        }
    }, 1, DEVICE_POLL_SEC, TimeUnit.SECONDS);
}
#method_after
private ScheduledFuture scheduleDevicePolling() {
    return deviceConnectionExecutor.scheduleWithFixedDelay(() -> {
        try {
            controller.getDevices().values().stream().forEach(restSBDevice -> {
                DeviceId deviceId = restSBDevice.deviceId();
                if (deviceService.getDevice(deviceId) != null) {
                    boolean connected = testDeviceConnection(restSBDevice);
                    restSBDevice.setActive(connected);
                    if (deviceService.isAvailable(deviceId) && (!connected)) {
                        providerService.deviceDisconnected(deviceId);
                    } else if (!deviceService.isAvailable(deviceId) && connected) {
                        DeviceDescription devDesc = getDesc(restSBDevice);
                        checkNotNull(devDesc, "deviceDescription cannot be null");
                        providerService.deviceConnected(deviceId, mergeAnn(deviceId, devDesc));
                    }
                }
            });
        } catch (Exception e) {
            log.error("Exception at schedule Device polling", e);
        }
    }, 1, DEVICE_POLL_SEC, TimeUnit.SECONDS);
}
#end_block

#method_before
private void deviceAdded(RestSBDevice restSBDev) {
    checkNotNull(restSBDev, ISNOTNULL);
    // check if the server is controlling a single or multiple devices
    if (restSBDev.isProxy()) {
        Driver driver = driverService.getDriver(restSBDev.manufacturer().get(), restSBDev.hwVersion().get(), restSBDev.swVersion().get());
        if (driver != null && driver.hasBehaviour(DevicesDiscovery.class)) {
            // Creates the driver to communicate with the server
            DevicesDiscovery devicesDiscovery = devicesDiscovery(restSBDev, driver);
            Set<DeviceId> deviceIds = devicesDiscovery.deviceIds();
            restSBDev.setActive(true);
            deviceIds.forEach(deviceId -> {
                controller.addProxiedDevice(deviceId, restSBDev);
                DeviceDescription devDesc = devicesDiscovery.deviceDetails(deviceId);
                checkNotNull(devDesc, "deviceDescription cannot be null");
                providerService.deviceConnected(deviceId, mergeAnn(restSBDev.deviceId(), devDesc));
                if (driver.hasBehaviour(DeviceDescriptionDiscovery.class)) {
                    DriverHandler h = driverService.createHandler(deviceId);
                    DeviceDescriptionDiscovery devDisc = h.behaviour(DeviceDescriptionDiscovery.class);
                    providerService.updatePorts(deviceId, devDisc.discoverPortDetails());
                }
                checkAndUpdateDevice(deviceId);
            });
        } else {
            log.warn("Driver not found for {}", restSBDev);
        }
    } else {
        DeviceId deviceId = restSBDev.deviceId();
        DeviceDescription deviceDescription = getDesc(restSBDev);
        restSBDev.setActive(true);
        providerService.deviceConnected(deviceId, deviceDescription);
        checkAndUpdateDevice(deviceId);
    }
}
#method_after
private void deviceAdded(RestSBDevice restSBDev) {
    checkNotNull(restSBDev, ISNOTNULL);
    Driver driver = driverService.getDriver(restSBDev.manufacturer().get(), restSBDev.hwVersion().get(), restSBDev.swVersion().get());
    // Check if the server is controlling a single or multiple devices
    if (restSBDev.isProxy()) {
        if (driver != null && driver.hasBehaviour(DevicesDiscovery.class)) {
            DevicesDiscovery devicesDiscovery = devicesDiscovery(restSBDev, driver);
            Set<DeviceId> deviceIds = devicesDiscovery.deviceIds();
            restSBDev.setActive(true);
            deviceIds.forEach(deviceId -> {
                controller.addProxiedDevice(deviceId, restSBDev);
                DeviceDescription devDesc = devicesDiscovery.deviceDetails(deviceId);
                checkNotNull(devDesc, "DeviceDescription cannot be null");
                providerService.deviceConnected(deviceId, mergeAnn(restSBDev.deviceId(), devDesc));
                if (driver.hasBehaviour(DeviceDescriptionDiscovery.class)) {
                    DriverHandler h = driverService.createHandler(deviceId);
                    DeviceDescriptionDiscovery devDisc = h.behaviour(DeviceDescriptionDiscovery.class);
                    providerService.updatePorts(deviceId, devDisc.discoverPortDetails());
                }
                checkAndUpdateDevice(deviceId);
            });
        } else {
            log.warn("Driver not found for {}", restSBDev);
        }
    } else {
        DeviceId deviceId = restSBDev.deviceId();
        if (driver != null && driver.hasBehaviour(DevicesDiscovery.class)) {
            restSBDev.setActive(true);
            DevicesDiscovery devicesDiscovery = devicesDiscovery(restSBDev, driver);
            DeviceDescription deviceDescription = devicesDiscovery.deviceDetails(deviceId);
            checkNotNull(deviceDescription, "DeviceDescription cannot be null");
            providerService.deviceConnected(deviceId, deviceDescription);
            if (driver.hasBehaviour(DeviceDescriptionDiscovery.class)) {
                DriverHandler h = driverService.createHandler(deviceId);
                DeviceDescriptionDiscovery deviceDiscovery = h.behaviour(DeviceDescriptionDiscovery.class);
                providerService.updatePorts(deviceId, deviceDiscovery.discoverPortDetails());
            }
        } else {
            DeviceDescription deviceDescription = getDesc(restSBDev);
            restSBDev.setActive(true);
            providerService.deviceConnected(deviceId, deviceDescription);
        }
        checkAndUpdateDevice(deviceId);
    }
}
#end_block

#method_before
private void checkAndUpdateDevice(DeviceId deviceId) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, " + "maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            if (device.is(DeviceDescriptionDiscovery.class)) {
                DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                    providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    // if ports are not discovered, retry the discovery
                    if (deviceService.getPorts(deviceId).isEmpty()) {
                        discoverPorts(deviceId);
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {}", deviceId);
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#method_after
private void checkAndUpdateDevice(DeviceId deviceId) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            if (device.is(DeviceDescriptionDiscovery.class)) {
                DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                    providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    // if ports are not discovered, retry the discovery
                    if (deviceService.getPorts(deviceId).isEmpty()) {
                        discoverPorts(deviceId);
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {}", deviceId);
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#end_block

#method_before
private void createAndConnectDevices() {
    Set<DeviceId> deviceSubjects = cfgService.getSubjects(DeviceId.class, RestDeviceConfig.class);
    log.debug("Connecting and configuring devices with received configuration:{}", deviceSubjects);
    connectDevices(deviceSubjects.stream().filter(deviceId -> deviceService.getDevice(deviceId) == null).map(deviceId -> {
        RestDeviceConfig config = cfgService.getConfig(deviceId, RestDeviceConfig.class);
        return toInactiveRestSBDevice(config);
    }).collect(Collectors.toSet()));
}
#method_after
private void createAndConnectDevices() {
    Set<DeviceId> deviceSubjects = netCfgService.getSubjects(DeviceId.class, RestDeviceConfig.class);
    log.debug("Connecting and configuring devices with received configuration:{}", deviceSubjects);
    connectDevices(deviceSubjects.stream().filter(deviceId -> deviceService.getDevice(deviceId) == null).map(deviceId -> {
        RestDeviceConfig config = netCfgService.getConfig(deviceId, RestDeviceConfig.class);
        return toInactiveRestSBDevice(config);
    }).collect(Collectors.toSet()));
}
#end_block

#method_before
private RestSBDevice toInactiveRestSBDevice(RestDeviceConfig config) {
    return new DefaultRestSBDevice(config.ip(), config.port(), config.username(), config.password(), config.protocol(), config.url(), false, config.testUrl(), config.manufacturer(), config.hwVersion(), config.swVersion(), config.authenticationScheme(), config.token());
}
#method_after
private RestSBDevice toInactiveRestSBDevice(RestDeviceConfig config) {
    return new DefaultRestSBDevice(config.ip(), config.port(), config.username(), config.password(), config.protocol(), config.url(), false, config.testUrl(), config.manufacturer(), config.hwVersion(), config.swVersion(), config.isProxy(), config.authenticationScheme(), config.token());
}
#end_block

#method_before
private ScheduledFuture schedulePolling() {
    return portStatisticsExecutor.scheduleAtFixedRate(this::executePortStatisticsUpdate, DEFAULT_POLL_FREQUENCY_SECONDS / 2, DEFAULT_POLL_FREQUENCY_SECONDS, TimeUnit.SECONDS);
}
#method_after
private ScheduledFuture schedulePolling() {
    return portStatisticsExecutor.scheduleAtFixedRate(this::executePortStatisticsUpdate, pollFrequency / 2, pollFrequency, TimeUnit.SECONDS);
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    ExecutorService bg = SharedExecutors.getSingleThreadExecutor();
    if (event.type() == CONFIG_REMOVED) {
        log.debug("Config {} event for rest device provider for {}", event.type(), event.prevConfig().get().subject());
        DeviceId did = (DeviceId) event.subject();
        bg.execute(() -> deviceRemoved(did));
    } else {
        // CONFIG_ADDED or CONFIG_UPDATED
        log.debug("Config {} event for rest device provider for {}", event.type(), event.config().get().subject());
        RestDeviceConfig cfg = (RestDeviceConfig) event.config().get();
        RestSBDevice restSBDevice = toInactiveRestSBDevice(cfg);
        bg.execute(() -> connectDevice(restSBDevice));
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (!isRelevant(event)) {
        log.warn("Irrelevant network configuration event: {}", event);
        return;
    }
    ExecutorService bg = SharedExecutors.getSingleThreadExecutor();
    if (event.type() == CONFIG_REMOVED) {
        log.debug("Config {} event for rest device provider for {}", event.type(), event.prevConfig().get().subject());
        DeviceId did = (DeviceId) event.subject();
        bg.execute(() -> deviceRemoved(did));
    } else {
        // CONFIG_ADDED or CONFIG_UPDATED
        log.debug("Config {} event for rest device provider for {}", event.type(), event.config().get().subject());
        RestDeviceConfig cfg = (RestDeviceConfig) event.config().get();
        RestSBDevice restSBDevice = toInactiveRestSBDevice(cfg);
        bg.execute(() -> connectDevice(restSBDevice));
    }
}
#end_block

#method_before
public PiPipeconf build() {
    checkNotNull(id);
    checkNotNull(pipelineModel);
    Map<ExtensionType, URL> extensions = extensionMapBuilder.build();
    return new DefaultPiPipeconf(id, pipelineModel, hashExtension(extensions), behaviourMapBuilder.build(), extensions);
}
#method_after
public PiPipeconf build() {
    checkNotNull(id);
    checkNotNull(pipelineModel);
    Map<ExtensionType, URL> extensions = extensionMapBuilder.build();
    return new DefaultPiPipeconf(id, pipelineModel, generateFingerprint(extensions), behaviourMapBuilder.build(), extensions);
}
#end_block

#method_before
private ForwardingPipelineConfig getPipelineConfig(PiPipeconf pipeconf, ByteBuffer deviceData) {
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return null;
    }
    ForwardingPipelineConfig.Cookie pipeconfCookie = ForwardingPipelineConfig.Cookie.newBuilder().setCookie(pipeconf.getCookie()).build();
    // FIXME: This is specific to PI P4Runtime implementation.
    P4Config.P4DeviceConfig p4DeviceConfigMsg = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.copyFrom(deviceData)).build();
    return ForwardingPipelineConfig.newBuilder().setP4Info(p4Info).setP4DeviceConfig(p4DeviceConfigMsg.toByteString()).setCookie(pipeconfCookie).build();
}
#method_after
private ForwardingPipelineConfig getPipelineConfig(PiPipeconf pipeconf, ByteBuffer deviceData) {
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return null;
    }
    ForwardingPipelineConfig.Cookie pipeconfCookie = ForwardingPipelineConfig.Cookie.newBuilder().setCookie(pipeconf.fingerprint()).build();
    // FIXME: This is specific to PI P4Runtime implementation.
    P4Config.P4DeviceConfig p4DeviceConfigMsg = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.copyFrom(deviceData)).build();
    return ForwardingPipelineConfig.newBuilder().setP4Info(p4Info).setP4DeviceConfig(p4DeviceConfigMsg.toByteString()).setCookie(pipeconfCookie).build();
}
#end_block

#method_before
private boolean doIsPipelineConfigSet(PiPipeconf pipeconf, ByteBuffer deviceData) {
    GetForwardingPipelineConfigRequest request = GetForwardingPipelineConfigRequest.newBuilder().setDeviceId(p4DeviceId).setResponseType(GetForwardingPipelineConfigRequest.ResponseType.COOKIE_ONLY).build();
    GetForwardingPipelineConfigResponse resp;
    try {
        resp = this.blockingStub.getForwardingPipelineConfig(request);
    } catch (StatusRuntimeException ex) {
        checkGrpcException(ex);
        // the first place. Don't bother logging.
        if (!ex.getStatus().getCode().equals(Status.FAILED_PRECONDITION.getCode())) {
            log.warn("Unable to get pipeline config from {}: {}", deviceId, ex.getMessage());
        }
        return false;
    }
    if (!resp.getConfig().hasCookie()) {
        log.warn("{} returned GetForwardingPipelineConfigResponse " + "with 'cookie' field unset", deviceId);
        return false;
    }
    return resp.getConfig().getCookie().getCookie() == pipeconf.getCookie();
}
#method_after
private boolean doIsPipelineConfigSet(PiPipeconf pipeconf, ByteBuffer deviceData) {
    GetForwardingPipelineConfigRequest request = GetForwardingPipelineConfigRequest.newBuilder().setDeviceId(p4DeviceId).setResponseType(GetForwardingPipelineConfigRequest.ResponseType.COOKIE_ONLY).build();
    GetForwardingPipelineConfigResponse resp;
    try {
        resp = this.blockingStub.getForwardingPipelineConfig(request);
    } catch (StatusRuntimeException ex) {
        checkGrpcException(ex);
        // the first place. Don't bother logging.
        if (!ex.getStatus().getCode().equals(Status.FAILED_PRECONDITION.getCode())) {
            log.warn("Unable to get pipeline config from {}: {}", deviceId, ex.getMessage());
        }
        return false;
    }
    if (!resp.getConfig().hasCookie()) {
        log.warn("{} returned GetForwardingPipelineConfigResponse " + "with 'cookie' field unset", deviceId);
        return false;
    }
    return resp.getConfig().getCookie().getCookie() == pipeconf.fingerprint();
}
#end_block

#method_before
@DELETE
@Path("{deviceId}/{meterId}")
public Response deleteMeterByDeviceIdAndMeterId(@PathParam("deviceId") String deviceId, @PathParam("meterId") String meterId) {
    DeviceId did = DeviceId.deviceId(deviceId);
    MeterId mid = MeterId.meterId(Long.valueOf(meterId));
    final Meter tmpMeter = meterService.getMeter(did, mid);
    if (tmpMeter != null) {
        final MeterRequest meterRequest = meterToMeterRequest(tmpMeter, "REMOVE");
        if (meterRequest != null) {
            meterService.withdraw(meterRequest, tmpMeter.id());
        }
    }
    return Response.noContent().build();
}
#method_after
@DELETE
@Path("{deviceId}/{meterId}")
public Response deleteMeterByDeviceIdAndMeterId(@PathParam("deviceId") String deviceId, @PathParam("meterId") String meterId) {
    DeviceId did = DeviceId.deviceId(deviceId);
    MeterId mid = MeterId.meterId(Long.valueOf(meterId));
    final Meter tmpMeter = meterService.getMeter(did, mid);
    if (tmpMeter != null) {
        final MeterRequest meterRequest = meterToMeterRequest(tmpMeter, "REMOVE");
        if (meterRequest != null) {
            meterService.withdraw(meterRequest, tmpMeter.id());
        }
    } else {
        log.warn("Meter {}, is not present", tmpMeter);
    }
    return Response.noContent().build();
}
#end_block

#method_before
private void setFloatingIpRules(NetFloatingIP floatingIp, InstancePort instPort, OpenstackNode gateway, boolean install) {
    if (instPort == null) {
        log.debug("No instance port found");
        return;
    }
    Network osNet = osNetworkService.network(instPort.networkId());
    ExternalPeerRouter externalPeerRouter = externalPeerRouter(osNet, osNetworkService, osRouterAdminService);
    if (externalPeerRouter == null) {
        final String errorFormat = ERR_FLOW + "no external peer router found";
        throw new IllegalStateException(errorFormat);
    }
    if (install) {
        preCommitPortService.subscribePreCommit(instPort.portId(), OPENSTACK_PORT_PRE_REMOVE, this.getClass().getName());
        log.info("Subscribed the port {} on listening pre-remove event", instPort.portId());
    } else {
        preCommitPortService.unsubscribePreCommit(instPort.portId(), OPENSTACK_PORT_PRE_REMOVE, instancePortService, this.getClass().getName());
        log.info("Unsubscribed the port {} on listening pre-remove event", instPort.portId());
    }
    updateComputeNodeRules(instPort, osNet, gateway, install);
    updateGatewayNodeRules(floatingIp, instPort, osNet, externalPeerRouter, gateway, install);
    // TODO: need to refactor setUpstreamRules if possible
    setUpstreamRules(floatingIp, osNet, instPort, externalPeerRouter, install);
    log.trace("Succeeded to set flow rules for floating ip {}:{} and install: {}", floatingIp.getFloatingIpAddress(), floatingIp.getFixedIpAddress(), install);
}
#method_after
private void setFloatingIpRules(NetFloatingIP floatingIp, InstancePort instPort, OpenstackNode gateway, boolean install) {
    if (instPort == null) {
        log.debug("No instance port found");
        return;
    }
    Network osNet = osNetworkService.network(instPort.networkId());
    ExternalPeerRouter externalPeerRouter = externalPeerRouterForNetwork(osNet, osNetworkService, osRouterAdminService);
    if (externalPeerRouter == null) {
        final String errorFormat = ERR_FLOW + "no external peer router found";
        throw new IllegalStateException(errorFormat);
    }
    if (install) {
        preCommitPortService.subscribePreCommit(instPort.portId(), OPENSTACK_PORT_PRE_REMOVE, this.getClass().getName());
        log.info("Subscribed the port {} on listening pre-remove event", instPort.portId());
    } else {
        preCommitPortService.unsubscribePreCommit(instPort.portId(), OPENSTACK_PORT_PRE_REMOVE, instancePortService, this.getClass().getName());
        log.info("Unsubscribed the port {} on listening pre-remove event", instPort.portId());
    }
    updateComputeNodeRules(instPort, osNet, gateway, install);
    updateGatewayNodeRules(floatingIp, instPort, osNet, externalPeerRouter, gateway, install);
    // TODO: need to refactor setUpstreamRules if possible
    setUpstreamRules(floatingIp, osNet, instPort, externalPeerRouter, install);
    log.trace("Succeeded to set flow rules for floating ip {}:{} and install: {}", floatingIp.getFloatingIpAddress(), floatingIp.getFixedIpAddress(), install);
}
#end_block

#method_before
private void processGratuitousArpPacket(NetFloatingIP floatingIP, InstancePort instancePort) {
    Set<OpenstackNode> gws = ImmutableSet.copyOf(osNodeService.completeNodes(GATEWAY));
    Network osNet = osNetworkService.network(instancePort.networkId());
    OpenstackNode selectedGw = getGwByInstancePort(gws, instancePort);
    ExternalPeerRouter externalPeerRouter = externalPeerRouter(osNet, osNetworkService, osRouterAdminService);
    if (externalPeerRouter == null) {
        final String errorFormat = ERR_FLOW + "no external peer router found";
        throw new IllegalStateException(errorFormat);
    }
    processGratuitousArpPacketForFloatingIp(floatingIP, instancePort, externalPeerRouter.vlanId(), selectedGw, packetService);
}
#method_after
private void processGratuitousArpPacket(NetFloatingIP floatingIP, InstancePort instancePort) {
    Set<OpenstackNode> gws = ImmutableSet.copyOf(osNodeService.completeNodes(GATEWAY));
    Network osNet = osNetworkService.network(instancePort.networkId());
    OpenstackNode selectedGw = getGwByInstancePort(gws, instancePort);
    ExternalPeerRouter externalPeerRouter = externalPeerRouterForNetwork(osNet, osNetworkService, osRouterAdminService);
    if (externalPeerRouter == null) {
        log.error("Failed to process GARP packet for floating ip {} because no external peer router found");
        return;
    }
    processGratuitousArpPacketForFloatingIp(floatingIP, instancePort, externalPeerRouter.vlanId(), selectedGw, packetService);
}
#end_block

#method_before
@Override
public void event(OpenstackNodeEvent event) {
    switch(event.type()) {
        case OPENSTACK_NODE_COMPLETE:
            eventExecutor.execute(() -> {
                for (NetFloatingIP fip : osRouterAdminService.floatingIps()) {
                    if (Strings.isNullOrEmpty(fip.getPortId())) {
                        continue;
                    }
                    Port osPort = osNetworkService.port(fip.getPortId());
                    InstancePort instPort = instancePortService.instancePort(fip.getPortId());
                    // we check both Openstack Port and Instance Port
                    if (osPort == null || instPort == null) {
                        continue;
                    }
                    setFloatingIpRules(fip, instPort, event.subject(), true);
                }
            });
            break;
        case OPENSTACK_NODE_INCOMPLETE:
            eventExecutor.execute(() -> {
                for (NetFloatingIP fip : osRouterAdminService.floatingIps()) {
                    if (Strings.isNullOrEmpty(fip.getPortId())) {
                        continue;
                    }
                    Port osPort = osNetworkService.port(fip.getPortId());
                    if (osPort == null) {
                        log.warn("Failed to set floating IP {}", fip.getId());
                        continue;
                    }
                    Network osNet = osNetworkService.network(osPort.getNetworkId());
                    if (osNet == null) {
                        final String errorFormat = ERR_FLOW + "no network(%s) exists";
                        final String error = String.format(errorFormat, fip.getFloatingIpAddress(), osPort.getNetworkId());
                        throw new IllegalStateException(error);
                    }
                    MacAddress srcMac = MacAddress.valueOf(osPort.getMacAddress());
                    log.trace("Mac address of openstack port: {}", srcMac);
                    InstancePort instPort = instancePortService.instancePort(srcMac);
                    if (instPort == null) {
                        final String errorFormat = ERR_FLOW + "no host(MAC:%s) found";
                        final String error = String.format(errorFormat, fip.getFloatingIpAddress(), srcMac);
                        throw new IllegalStateException(error);
                    }
                    ExternalPeerRouter externalPeerRouter = externalPeerRouter(osNet, osNetworkService, osRouterAdminService);
                    if (externalPeerRouter == null) {
                        final String errorFormat = ERR_FLOW + "no external peer router found";
                        throw new IllegalStateException(errorFormat);
                    }
                    updateComputeNodeRules(instPort, osNet, event.subject(), false);
                    updateGatewayNodeRules(fip, instPort, osNet, externalPeerRouter, event.subject(), false);
                }
            });
            break;
        default:
            // do nothing
            break;
    }
}
#method_after
@Override
public void event(OpenstackNodeEvent event) {
    switch(event.type()) {
        case OPENSTACK_NODE_COMPLETE:
            eventExecutor.execute(() -> {
                for (NetFloatingIP fip : osRouterAdminService.floatingIps()) {
                    if (Strings.isNullOrEmpty(fip.getPortId())) {
                        continue;
                    }
                    Port osPort = osNetworkService.port(fip.getPortId());
                    InstancePort instPort = instancePortService.instancePort(fip.getPortId());
                    // we check both Openstack Port and Instance Port
                    if (osPort == null || instPort == null) {
                        continue;
                    }
                    setFloatingIpRules(fip, instPort, event.subject(), true);
                }
            });
            break;
        case OPENSTACK_NODE_INCOMPLETE:
            eventExecutor.execute(() -> {
                for (NetFloatingIP fip : osRouterAdminService.floatingIps()) {
                    if (Strings.isNullOrEmpty(fip.getPortId())) {
                        continue;
                    }
                    Port osPort = osNetworkService.port(fip.getPortId());
                    if (osPort == null) {
                        log.warn("Failed to set floating IP {}", fip.getId());
                        continue;
                    }
                    Network osNet = osNetworkService.network(osPort.getNetworkId());
                    if (osNet == null) {
                        final String errorFormat = ERR_FLOW + "no network(%s) exists";
                        final String error = String.format(errorFormat, fip.getFloatingIpAddress(), osPort.getNetworkId());
                        throw new IllegalStateException(error);
                    }
                    MacAddress srcMac = MacAddress.valueOf(osPort.getMacAddress());
                    log.trace("Mac address of openstack port: {}", srcMac);
                    InstancePort instPort = instancePortService.instancePort(srcMac);
                    if (instPort == null) {
                        final String errorFormat = ERR_FLOW + "no host(MAC:%s) found";
                        final String error = String.format(errorFormat, fip.getFloatingIpAddress(), srcMac);
                        throw new IllegalStateException(error);
                    }
                    ExternalPeerRouter externalPeerRouter = externalPeerRouterForNetwork(osNet, osNetworkService, osRouterAdminService);
                    if (externalPeerRouter == null) {
                        final String errorFormat = ERR_FLOW + "no external peer router found";
                        throw new IllegalStateException(errorFormat);
                    }
                    updateComputeNodeRules(instPort, osNet, event.subject(), false);
                    updateGatewayNodeRules(fip, instPort, osNet, externalPeerRouter, event.subject(), false);
                }
            });
            break;
        default:
            // do nothing
            break;
    }
}
#end_block

#method_before
@Override
public void event(InstancePortEvent event) {
    InstancePort instPort = event.subject();
    Set<OpenstackNode> gateways = osNodeService.completeNodes(GATEWAY);
    Set<NetFloatingIP> ips = osRouterAdminService.floatingIps();
    NetFloatingIP fip;
    Port osPort;
    Network osNet;
    ExternalPeerRouter externalPeerRouter;
    switch(event.type()) {
        case OPENSTACK_INSTANCE_PORT_DETECTED:
            if (instPort != null && instPort.portId() != null) {
                osRouterAdminService.floatingIps().stream().filter(f -> f.getPortId() != null).filter(f -> f.getPortId().equals(instPort.portId())).forEach(f -> setFloatingIpRules(f, instPort, null, true));
            }
            break;
        case OPENSTACK_INSTANCE_MIGRATION_STARTED:
            fip = associatedFloatingIp(event.subject(), ips);
            if (fip == null) {
                return;
            }
            osPort = osNetworkService.port(fip.getPortId());
            osNet = osNetworkService.network(osPort.getNetworkId());
            externalPeerRouter = externalPeerRouter(osNet, osNetworkService, osRouterAdminService);
            if (externalPeerRouter == null) {
                final String errorFormat = ERR_FLOW + "no external peer router found";
                throw new IllegalStateException(errorFormat);
            }
            eventExecutor.execute(() -> {
                // since DownstreamExternal rules should only be placed in
                // corresponding gateway node, we need to install new rule to
                // the corresponding gateway node
                setDownstreamExternalRulesHelper(fip, osNet, event.subject(), externalPeerRouter, gateways, true);
                // since ComputeNodeToGateway rules should only be placed in
                // corresponding compute node, we need to install new rule to
                // the target compute node, and remove rules from original node
                setComputeNodeToGatewayHelper(event.subject(), osNet, gateways, true);
            });
            break;
        case OPENSTACK_INSTANCE_MIGRATION_ENDED:
            InstancePort revisedInstPort = swapStaleLocation(event.subject());
            fip = associatedFloatingIp(revisedInstPort, ips);
            if (fip == null) {
                return;
            }
            osPort = osNetworkService.port(fip.getPortId());
            osNet = osNetworkService.network(osPort.getNetworkId());
            externalPeerRouter = externalPeerRouter(osNet, osNetworkService, osRouterAdminService);
            if (externalPeerRouter == null) {
                final String errorFormat = ERR_FLOW + "no external peer router found";
                throw new IllegalStateException(errorFormat);
            }
            // flow rules from either gateway or compute node
            if (gateways.size() == 1) {
                return;
            }
            // Checks whether the destination compute node's device id
            // has identical gateway hash or not
            // if it is true, we simply do not remove the rules, as
            // it has been overwritten at port detention event
            // if it is false, we will remove the rules
            DeviceId newDeviceId = event.subject().deviceId();
            DeviceId oldDeviceId = revisedInstPort.deviceId();
            OpenstackNode oldGateway = getGwByComputeDevId(gateways, oldDeviceId);
            OpenstackNode newGateway = getGwByComputeDevId(gateways, newDeviceId);
            if (oldGateway != null && oldGateway.equals(newGateway)) {
                return;
            }
            eventExecutor.execute(() -> {
                // We need to remove the old ComputeNodeToGateway rules from
                // original compute node
                setComputeNodeToGatewayHelper(revisedInstPort, osNet, gateways, false);
                // Since DownstreamExternal rules should only be placed in
                // corresponding gateway node, we need to remove old rule from
                // the corresponding gateway node
                setDownstreamExternalRulesHelper(fip, osNet, revisedInstPort, externalPeerRouter, gateways, false);
            });
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(InstancePortEvent event) {
    InstancePort instPort = event.subject();
    Set<OpenstackNode> gateways = osNodeService.completeNodes(GATEWAY);
    Set<NetFloatingIP> ips = osRouterAdminService.floatingIps();
    NetFloatingIP fip;
    Port osPort;
    Network osNet;
    ExternalPeerRouter externalPeerRouter;
    switch(event.type()) {
        case OPENSTACK_INSTANCE_PORT_DETECTED:
            if (instPort != null && instPort.portId() != null) {
                osRouterAdminService.floatingIps().stream().filter(f -> f.getPortId() != null).filter(f -> f.getPortId().equals(instPort.portId())).forEach(f -> setFloatingIpRules(f, instPort, null, true));
            }
            break;
        case OPENSTACK_INSTANCE_MIGRATION_STARTED:
            fip = associatedFloatingIp(event.subject(), ips);
            if (fip == null) {
                return;
            }
            osPort = osNetworkService.port(fip.getPortId());
            osNet = osNetworkService.network(osPort.getNetworkId());
            externalPeerRouter = externalPeerRouterForNetwork(osNet, osNetworkService, osRouterAdminService);
            if (externalPeerRouter == null) {
                final String errorFormat = ERR_FLOW + "no external peer router found";
                throw new IllegalStateException(errorFormat);
            }
            eventExecutor.execute(() -> {
                // since DownstreamExternal rules should only be placed in
                // corresponding gateway node, we need to install new rule to
                // the corresponding gateway node
                setDownstreamExternalRulesHelper(fip, osNet, event.subject(), externalPeerRouter, gateways, true);
                // since ComputeNodeToGateway rules should only be placed in
                // corresponding compute node, we need to install new rule to
                // the target compute node, and remove rules from original node
                setComputeNodeToGatewayHelper(event.subject(), osNet, gateways, true);
            });
            break;
        case OPENSTACK_INSTANCE_MIGRATION_ENDED:
            InstancePort revisedInstPort = swapStaleLocation(event.subject());
            fip = associatedFloatingIp(revisedInstPort, ips);
            if (fip == null) {
                return;
            }
            osPort = osNetworkService.port(fip.getPortId());
            osNet = osNetworkService.network(osPort.getNetworkId());
            externalPeerRouter = externalPeerRouterForNetwork(osNet, osNetworkService, osRouterAdminService);
            if (externalPeerRouter == null) {
                final String errorFormat = ERR_FLOW + "no external peer router found";
                throw new IllegalStateException(errorFormat);
            }
            // flow rules from either gateway or compute node
            if (gateways.size() == 1) {
                return;
            }
            // Checks whether the destination compute node's device id
            // has identical gateway hash or not
            // if it is true, we simply do not remove the rules, as
            // it has been overwritten at port detention event
            // if it is false, we will remove the rules
            DeviceId newDeviceId = event.subject().deviceId();
            DeviceId oldDeviceId = revisedInstPort.deviceId();
            OpenstackNode oldGateway = getGwByComputeDevId(gateways, oldDeviceId);
            OpenstackNode newGateway = getGwByComputeDevId(gateways, newDeviceId);
            if (oldGateway != null && oldGateway.equals(newGateway)) {
                return;
            }
            eventExecutor.execute(() -> {
                // We need to remove the old ComputeNodeToGateway rules from
                // original compute node
                setComputeNodeToGatewayHelper(revisedInstPort, osNet, gateways, false);
                // Since DownstreamExternal rules should only be placed in
                // corresponding gateway node, we need to remove old rule from
                // the corresponding gateway node
                setDownstreamExternalRulesHelper(fip, osNet, revisedInstPort, externalPeerRouter, gateways, false);
            });
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void event(OpenstackNetworkEvent event) {
    switch(event.type()) {
        case OPENSTACK_PORT_PRE_REMOVE:
            InstancePort instPort = instancePortService.instancePort(event.port().getId());
            if (instPort == null) {
                break;
            }
            NetFloatingIP fip = associatedFloatingIp(instPort, osRouterAdminService.floatingIps());
            boolean sgFlag = getPropertyValueAsBoolean(componentConfigService.getProperties(OpenstackSecurityGroupHandler.class.getName()), USE_SECURITY_GROUP);
            if (fip != null) {
                instancePortService.updateInstancePort(instPort.updateState(REMOVE_PENDING));
                eventExecutor.execute(() -> updateFipStore(instancePortService.instancePort(event.port().getId())));
            } else {
                // find a better way to remove this dependency
                if (!sgFlag) {
                    instancePortService.removeInstancePort(instPort.portId());
                }
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(OpenstackNetworkEvent event) {
    switch(event.type()) {
        case OPENSTACK_PORT_PRE_REMOVE:
            InstancePort instPort = instancePortService.instancePort(event.port().getId());
            if (instPort == null) {
                break;
            }
            NetFloatingIP fip = associatedFloatingIp(instPort, osRouterAdminService.floatingIps());
            if (fip != null) {
                instancePortService.updateInstancePort(instPort.updateState(REMOVE_PENDING));
                eventExecutor.execute(() -> updateFipStore(event.port().getId()));
            } else {
                instancePortService.removeInstancePort(instPort.portId());
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void updateFipStore(InstancePort port) {
    if (port == null) {
        return;
    }
    Set<NetFloatingIP> ips = osRouterAdminService.floatingIps();
    for (NetFloatingIP fip : ips) {
        if (Strings.isNullOrEmpty(fip.getFixedIpAddress())) {
            continue;
        }
        if (Strings.isNullOrEmpty(fip.getFloatingIpAddress())) {
            continue;
        }
        if (fip.getFixedIpAddress().equals(port.ipAddress().toString())) {
            NeutronFloatingIP neutronFip = (NeutronFloatingIP) fip;
            // invalidate bound fixed IP and port
            neutronFip.setFixedIpAddress(null);
            neutronFip.setPortId(null);
            // Following update will in turn trigger
            // OPENSTACK_FLOATING_IP_DISASSOCIATED event
            osRouterAdminService.updateFloatingIp(neutronFip);
            log.info("Updated floating IP {}, due to host removal", neutronFip.getFloatingIpAddress());
        }
    }
}
#method_after
private void updateFipStore(String portId) {
    if (portId == null) {
        return;
    }
    Set<NetFloatingIP> ips = osRouterAdminService.floatingIps();
    for (NetFloatingIP fip : ips) {
        if (Strings.isNullOrEmpty(fip.getFixedIpAddress())) {
            continue;
        }
        if (Strings.isNullOrEmpty(fip.getFloatingIpAddress())) {
            continue;
        }
        if (fip.getPortId().equals(portId)) {
            NeutronFloatingIP neutronFip = (NeutronFloatingIP) fip;
            // invalidate bound fixed IP and port
            neutronFip.setFixedIpAddress(null);
            neutronFip.setPortId(null);
            // Following update will in turn trigger
            // OPENSTACK_FLOATING_IP_DISASSOCIATED event
            osRouterAdminService.updateFloatingIp(neutronFip);
            log.info("Updated floating IP {}, due to host removal", neutronFip.getFloatingIpAddress());
        }
    }
}
#end_block

#method_before
private void setArpRule(NetFloatingIP fip, MacAddress targetMac, OpenstackNode gateway, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(EthType.EtherType.ARP.ethType().toShort()).matchArpOp(ARP.OP_REQUEST).matchArpTpa(Ip4Address.valueOf(fip.getFloatingIpAddress())).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setArpOp(ARP.OP_REPLY).setArpSha(targetMac).setArpSpa(Ip4Address.valueOf(fip.getFloatingIpAddress())).setOutput(PortNumber.IN_PORT).build();
    osFlowRuleService.setRule(appId, gateway.intgBridge(), selector, treatment, PRIORITY_ARP_GATEWAY_RULE, GW_COMMON_TABLE, install);
    if (install) {
        log.info("Install ARP Rule for Floating IP {}", fip.getFloatingIpAddress());
    } else {
        log.info("Uninstall ARP Rule for Floating IP {}", fip.getFloatingIpAddress());
    }
}
#method_after
private void setArpRule(NetFloatingIP fip, MacAddress targetMac, OpenstackNode gateway, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(gateway.uplinkPortNum()).matchEthType(EthType.EtherType.ARP.ethType().toShort()).matchArpOp(ARP.OP_REQUEST).matchArpTpa(Ip4Address.valueOf(fip.getFloatingIpAddress())).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setArpOp(ARP.OP_REPLY).setArpSha(targetMac).setArpSpa(Ip4Address.valueOf(fip.getFloatingIpAddress())).setOutput(PortNumber.IN_PORT).build();
    osFlowRuleService.setRule(appId, gateway.intgBridge(), selector, treatment, PRIORITY_ARP_GATEWAY_RULE, GW_COMMON_TABLE, install);
    if (install) {
        log.info("Install ARP Rule for Floating IP {}", fip.getFloatingIpAddress());
    } else {
        log.info("Uninstall ARP Rule for Floating IP {}", fip.getFloatingIpAddress());
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(OpenstackNetworkEvent event) {
    Port osPort = event.port();
    if (osPort == null || osPort.getFixedIps() == null) {
        return false;
    }
    // do not allow to proceed without leadership
    NodeId leader = leadershipService.getLeader(appId.name());
    return Objects.equals(localNodeId, leader) && DEVICE_OWNER_ROUTER_GW.equals(osPort.getDeviceOwner());
}
#method_after
@Override
public boolean isRelevant(OpenstackNetworkEvent event) {
    Port osPort = event.port();
    if (osPort == null || osPort.getFixedIps() == null) {
        return false;
    }
    // do not allow to proceed without leadership
    NodeId leader = leadershipService.getLeader(appId.name());
    return Objects.equals(localNodeId, leader) && DEVICE_OWNER_ROUTER_GW.equals(osPort.getDeviceOwner()) && ARP_BROADCAST_MODE.equals(getArpMode());
}
#end_block

#method_before
private void sendGratuitousArpToSwitch(OpenstackNode gatewayNode, boolean isCompleteCase) {
    if (!gatewayNode.type().equals(GATEWAY)) {
        return;
    }
    Set<OpenstackNode> completeGws = ImmutableSet.copyOf(osNodeService.completeNodes(GATEWAY));
    if (isCompleteCase) {
        osNodeService.completeNodes(COMPUTE).stream().filter(node -> isGwSelectedByComputeNode(completeGws, node, gatewayNode)).forEach(node -> processGratuitousArpPacketForComputeNode(node, gatewayNode));
    } else {
        Set<OpenstackNode> oldCompleteGws = Sets.newConcurrentHashSet();
        oldCompleteGws.addAll(ImmutableSet.copyOf(osNodeService.completeNodes(GATEWAY)));
        oldCompleteGws.add(gatewayNode);
        osNodeService.completeNodes(COMPUTE).stream().filter(node -> isGwSelectedByComputeNode(oldCompleteGws, node, gatewayNode)).forEach(node -> {
            OpenstackNode newSelectedGatewayNode = getGwByComputeDevId(completeGws, node.intgBridge());
            processGratuitousArpPacketForComputeNode(node, newSelectedGatewayNode);
        });
    }
}
#method_after
private void sendGratuitousArpToSwitch(OpenstackNode gatewayNode, boolean isCompleteCase) {
    Set<OpenstackNode> completeGws = ImmutableSet.copyOf(osNodeService.completeNodes(GATEWAY));
    if (isCompleteCase) {
        osNodeService.completeNodes(COMPUTE).stream().filter(node -> isGwSelectedByComputeNode(completeGws, node, gatewayNode)).forEach(node -> processGratuitousArpPacketForComputeNode(node, gatewayNode));
    } else {
        Set<OpenstackNode> oldCompleteGws = Sets.newConcurrentHashSet();
        oldCompleteGws.addAll(ImmutableSet.copyOf(osNodeService.completeNodes(GATEWAY)));
        oldCompleteGws.add(gatewayNode);
        osNodeService.completeNodes(COMPUTE).stream().filter(node -> isGwSelectedByComputeNode(oldCompleteGws, node, gatewayNode)).forEach(node -> {
            OpenstackNode newSelectedGatewayNode = getGwByComputeDevId(completeGws, node.intgBridge());
            processGratuitousArpPacketForComputeNode(node, newSelectedGatewayNode);
        });
    }
}
#end_block

#method_before
private void processGratuitousArpPacketForComputeNode(OpenstackNode computeNode, OpenstackNode gatewayNode) {
    instancePortService.instancePort(computeNode.intgBridge()).forEach(instancePort -> {
        NetFloatingIP floatingIP = floatingIpByInstancePort(instancePort);
        Network network = osNetworkService.network(instancePort.networkId());
        ExternalPeerRouter externalPeerRouter = OpenstackNetworkingUtil.externalPeerRouter(network, osNetworkService, osRouterAdminService);
        if (floatingIP != null && externalPeerRouter != null) {
            processGratuitousArpPacketForFloatingIp(floatingIP, instancePort, externalPeerRouter.vlanId(), gatewayNode, packetService);
        }
    });
}
#method_after
private void processGratuitousArpPacketForComputeNode(OpenstackNode computeNode, OpenstackNode gatewayNode) {
    instancePortService.instancePort(computeNode.intgBridge()).forEach(instancePort -> {
        NetFloatingIP floatingIP = OpenstackNetworkingUtil.floatingIpByInstancePort(instancePort, osRouterAdminService);
        Network network = osNetworkService.network(instancePort.networkId());
        ExternalPeerRouter externalPeerRouter = OpenstackNetworkingUtil.externalPeerRouterForNetwork(network, osNetworkService, osRouterAdminService);
        if (floatingIP != null && externalPeerRouter != null) {
            processGratuitousArpPacketForFloatingIp(floatingIP, instancePort, externalPeerRouter.vlanId(), gatewayNode, packetService);
        }
    });
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_ID);
    localNodeId = clusterService.getLocalNode().id();
    leadershipService.runForLeadership(appId.name());
    eventExecutor = newSingleThreadScheduledExecutor(groupedThreads(this.getClass().getSimpleName(), "event-handler", log));
    store.setDelegate(delegate);
    eventDispatcher.addSink(OpenstackVtapEvent.class, listenerRegistry);
    deviceService.addListener(deviceListener);
    osNodeService.addListener(osNodeListener);
    hostService.addListener(hostListener);
    initVtap();
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_ID);
    localNodeId = clusterService.getLocalNode().id();
    leadershipService.runForLeadership(appId.name());
    componentConfigService.registerProperties(getClass());
    eventExecutor = newSingleThreadScheduledExecutor(groupedThreads(this.getClass().getSimpleName(), "event-handler", log));
    store.setDelegate(delegate);
    eventDispatcher.addSink(OpenstackVtapEvent.class, listenerRegistry);
    deviceService.addListener(deviceListener);
    osNodeService.addListener(osNodeListener);
    hostService.addListener(hostListener);
    initVtap();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    clearVtap();
    hostService.removeListener(hostListener);
    osNodeService.removeListener(osNodeListener);
    deviceService.removeListener(deviceListener);
    eventDispatcher.removeSink(OpenstackVtapEvent.class);
    store.unsetDelegate(delegate);
    eventExecutor.shutdown();
    leadershipService.withdraw(appId.name());
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    clearVtap();
    hostService.removeListener(hostListener);
    osNodeService.removeListener(osNodeListener);
    deviceService.removeListener(deviceListener);
    eventDispatcher.removeSink(OpenstackVtapEvent.class);
    store.unsetDelegate(delegate);
    eventExecutor.shutdown();
    componentConfigService.unregisterProperties(getClass(), false);
    leadershipService.withdraw(appId.name());
    log.info("Stopped");
}
#end_block

#method_before
private void setOutputTableForTunnel(DeviceId deviceId, int tableId, PortNumber outPort, IpAddress serverIp, boolean install) {
    log.debug("setOutputTableForTunnel[{}]: deviceId={}, tableId={}, outPort={}, serverIp={}", install ? "add" : "remove", deviceId, tableId, outPort, serverIp);
    ExtensionTreatment extensionTreatment = buildTunnelExtension(deviceId, serverIp);
    if (extensionTreatment == null) {
        log.warn("Vtap tunnel extension cannot be null");
        return;
    }
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().extension(extensionTreatment, deviceId).setOutput(outPort);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(PRIORITY_VTAP_OUTPUT_RULE).makePermanent().forTable(tableId).fromApp(appId).build();
    log.debug("setOutputTableForTunnel flowRule={}, install={}", flowRule, install);
    applyFlowRule(flowRule, install);
}
#method_after
private void setOutputTableForTunnel(DeviceId deviceId, int tableId, PortNumber outPort, IpAddress serverIp, boolean install) {
    log.debug("setOutputTableForTunnel[{}]: deviceId={}, tableId={}, outPort={}, serverIp={}", install ? "add" : "remove", deviceId, tableId, outPort, serverIp);
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setOutput(outPort);
    if (tunnelNicira) {
        ExtensionTreatment extensionTreatment = buildTunnelExtension(deviceId, serverIp);
        if (extensionTreatment == null) {
            return;
        }
        treatment.extension(extensionTreatment, deviceId);
    }
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(PRIORITY_VTAP_OUTPUT_RULE).makePermanent().forTable(tableId).fromApp(appId).build();
    log.debug("setOutputTableForTunnel flowRule={}, install={}", flowRule, install);
    applyFlowRule(flowRule, install);
}
#end_block

#method_before
private OpenstackVtap createOrUpdateVtap(boolean update, OpenstackVtap description, boolean replaceDevices) {
    DefaultOpenstackVtap result = vtapMap.compute(description.id(), (id, existing) -> {
        // Check create or update validity
        if (update && existing == null) {
            return null;
        } else if (!update && existing != null) {
            return existing;
        }
        if (shouldUpdateVtap(existing, description, replaceDevices)) {
            // Replace or add devices
            final Set<DeviceId> txDeviceIds;
            if (existing == null || replaceDevices) {
                txDeviceIds = ImmutableSet.copyOf(description.txDeviceIds());
            } else {
                txDeviceIds = Sets.newHashSet(existing.txDeviceIds());
                txDeviceIds.addAll(description.txDeviceIds());
            }
            final Set<DeviceId> rxDeviceIds;
            if (existing == null || replaceDevices) {
                rxDeviceIds = ImmutableSet.copyOf(description.rxDeviceIds());
            } else {
                rxDeviceIds = Sets.newHashSet(existing.rxDeviceIds());
                rxDeviceIds.addAll(description.rxDeviceIds());
            }
            // Replace or add annotations
            final SparseAnnotations annotations;
            if (existing != null) {
                annotations = merge((DefaultAnnotations) existing.annotations(), (SparseAnnotations) description.annotations());
            } else {
                annotations = (SparseAnnotations) description.annotations();
            }
            return DefaultOpenstackVtap.builder(description).txDeviceIds(txDeviceIds).rxDeviceIds(rxDeviceIds).annotations(annotations).build();
        }
        return existing;
    });
    return result;
}
#method_after
private OpenstackVtap createOrUpdateVtap(boolean update, OpenstackVtap description, boolean replaceDevices) {
    DefaultOpenstackVtap result = vtapMap.compute(description.id(), (id, existing) -> {
        // Check create or update validity
        if (update && existing == null) {
            return null;
        } else if (!update && existing != null) {
            return existing;
        }
        if (shouldUpdateVtap(existing, description, replaceDevices)) {
            // Replace or add devices
            final Set<DeviceId> txDeviceIds;
            if (existing == null || replaceDevices) {
                txDeviceIds = description.txDeviceIds();
            } else {
                txDeviceIds = Sets.newHashSet(existing.txDeviceIds());
                txDeviceIds.addAll(description.txDeviceIds());
            }
            final Set<DeviceId> rxDeviceIds;
            if (existing == null || replaceDevices) {
                rxDeviceIds = description.rxDeviceIds();
            } else {
                rxDeviceIds = Sets.newHashSet(existing.rxDeviceIds());
                rxDeviceIds.addAll(description.rxDeviceIds());
            }
            // Replace or add annotations
            final SparseAnnotations annotations;
            if (existing != null) {
                annotations = merge((DefaultAnnotations) existing.annotations(), (SparseAnnotations) description.annotations());
            } else {
                annotations = (SparseAnnotations) description.annotations();
            }
            return DefaultOpenstackVtap.builder(description).txDeviceIds(txDeviceIds).rxDeviceIds(rxDeviceIds).annotations(annotations).build();
        }
        return existing;
    });
    return result;
}
#end_block

#method_before
@Override
public boolean addDeviceToVtap(OpenstackVtapId vtapId, Type type, DeviceId deviceId) {
    OpenstackVtap result = vtapMap.compute(vtapId, (id, existing) -> {
        if (existing == null) {
            return null;
        }
        // Check type validate
        if (!existing.type().isValid(type)) {
            log.error("Not valid OpenstackVtap type {} for requested type {}", existing.type(), type);
            return existing;
        }
        // Add deviceId to txDeviceIds
        Set<DeviceId> txDeviceIds = null;
        if (existing.type().isValid(Type.VTAP_TX) && (type.isValid(Type.VTAP_TX) || type == Type.VTAP_ANY) && !existing.txDeviceIds().contains(deviceId)) {
            txDeviceIds = Sets.newHashSet(existing.txDeviceIds());
            txDeviceIds.add(deviceId);
        }
        // Add deviceId to rxDeviceIds
        Set<DeviceId> rxDeviceIds = null;
        if (existing.type().isValid(Type.VTAP_RX) && (type.isValid(Type.VTAP_RX) || type == Type.VTAP_ANY) && !existing.rxDeviceIds().contains(deviceId)) {
            rxDeviceIds = Sets.newHashSet(existing.rxDeviceIds());
            rxDeviceIds.add(deviceId);
        }
        if (txDeviceIds != null || rxDeviceIds != null) {
            return DefaultOpenstackVtap.builder().id(id).type(existing.type()).vtapCriterion(existing.vtapCriterion()).txDeviceIds(txDeviceIds != null ? txDeviceIds : existing.txDeviceIds()).rxDeviceIds(rxDeviceIds != null ? rxDeviceIds : existing.rxDeviceIds()).annotations(existing.annotations()).build();
        } else {
            return existing;
        }
    });
    return Objects.nonNull(result);
}
#method_after
@Override
public boolean addDeviceToVtap(OpenstackVtapId vtapId, Type type, DeviceId deviceId) {
    OpenstackVtap result = vtapMap.compute(vtapId, (id, existing) -> {
        if (existing == null) {
            return null;
        }
        // Check type validate
        if (!existing.type().isValid(type)) {
            log.error("Not valid OpenstackVtap type {} for requested type {}", existing.type(), type);
            return existing;
        }
        // Add deviceId to txDeviceIds
        final Set<DeviceId> txDeviceIds;
        if (existing.type().isValid(Type.VTAP_TX) && (type.isValid(Type.VTAP_TX) || type == Type.VTAP_ANY) && !existing.txDeviceIds().contains(deviceId)) {
            txDeviceIds = Sets.newHashSet(existing.txDeviceIds());
            txDeviceIds.add(deviceId);
        } else {
            txDeviceIds = null;
        }
        // Add deviceId to rxDeviceIds
        final Set<DeviceId> rxDeviceIds;
        if (existing.type().isValid(Type.VTAP_RX) && (type.isValid(Type.VTAP_RX) || type == Type.VTAP_ANY) && !existing.rxDeviceIds().contains(deviceId)) {
            rxDeviceIds = Sets.newHashSet(existing.rxDeviceIds());
            rxDeviceIds.add(deviceId);
        } else {
            rxDeviceIds = null;
        }
        if (txDeviceIds != null || rxDeviceIds != null) {
            return DefaultOpenstackVtap.builder().id(id).type(existing.type()).vtapCriterion(existing.vtapCriterion()).txDeviceIds(txDeviceIds != null ? txDeviceIds : existing.txDeviceIds()).rxDeviceIds(rxDeviceIds != null ? rxDeviceIds : existing.rxDeviceIds()).annotations(existing.annotations()).build();
        } else {
            return existing;
        }
    });
    return Objects.nonNull(result);
}
#end_block

#method_before
@Override
public boolean removeDeviceFromVtap(OpenstackVtapId vtapId, OpenstackVtap.Type type, DeviceId deviceId) {
    OpenstackVtap result = vtapMap.compute(vtapId, (id, existing) -> {
        if (existing == null) {
            return null;
        }
        // Check type validate
        if (!existing.type().isValid(type)) {
            log.error("Not valid OpenstackVtap type {} for requested type {}", existing.type(), type);
            return existing;
        }
        // Remove deviceId from txDeviceIds
        Set<DeviceId> txDeviceIds = null;
        if (existing.type().isValid(Type.VTAP_TX) && (type.isValid(Type.VTAP_TX) || type == Type.VTAP_ANY) && existing.txDeviceIds().contains(deviceId)) {
            txDeviceIds = Sets.newHashSet(existing.txDeviceIds());
            txDeviceIds.remove(deviceId);
        }
        // Remove deviceId from rxDeviceIds
        Set<DeviceId> rxDeviceIds = null;
        if (existing.type().isValid(Type.VTAP_RX) && (type.isValid(Type.VTAP_RX) || type == Type.VTAP_ANY) && existing.rxDeviceIds().contains(deviceId)) {
            rxDeviceIds = Sets.newHashSet(existing.rxDeviceIds());
            rxDeviceIds.remove(deviceId);
        }
        if (txDeviceIds != null || rxDeviceIds != null) {
            return DefaultOpenstackVtap.builder().id(id).type(existing.type()).vtapCriterion(existing.vtapCriterion()).txDeviceIds(txDeviceIds != null ? txDeviceIds : existing.txDeviceIds()).rxDeviceIds(rxDeviceIds != null ? rxDeviceIds : existing.rxDeviceIds()).annotations(existing.annotations()).build();
        } else {
            return existing;
        }
    });
    return Objects.nonNull(result);
}
#method_after
@Override
public boolean removeDeviceFromVtap(OpenstackVtapId vtapId, OpenstackVtap.Type type, DeviceId deviceId) {
    OpenstackVtap result = vtapMap.compute(vtapId, (id, existing) -> {
        if (existing == null) {
            return null;
        }
        // Check type validate
        if (!existing.type().isValid(type)) {
            log.error("Not valid OpenstackVtap type {} for requested type {}", existing.type(), type);
            return existing;
        }
        // Remove deviceId from txDeviceIds
        final Set<DeviceId> txDeviceIds;
        if (existing.type().isValid(Type.VTAP_TX) && (type.isValid(Type.VTAP_TX) || type == Type.VTAP_ANY) && existing.txDeviceIds().contains(deviceId)) {
            txDeviceIds = Sets.newHashSet(existing.txDeviceIds());
            txDeviceIds.remove(deviceId);
        } else {
            txDeviceIds = null;
        }
        // Remove deviceId from rxDeviceIds
        final Set<DeviceId> rxDeviceIds;
        if (existing.type().isValid(Type.VTAP_RX) && (type.isValid(Type.VTAP_RX) || type == Type.VTAP_ANY) && existing.rxDeviceIds().contains(deviceId)) {
            rxDeviceIds = Sets.newHashSet(existing.rxDeviceIds());
            rxDeviceIds.remove(deviceId);
        } else {
            rxDeviceIds = null;
        }
        if (txDeviceIds != null || rxDeviceIds != null) {
            return DefaultOpenstackVtap.builder().id(id).type(existing.type()).vtapCriterion(existing.vtapCriterion()).txDeviceIds(txDeviceIds != null ? txDeviceIds : existing.txDeviceIds()).rxDeviceIds(rxDeviceIds != null ? rxDeviceIds : existing.rxDeviceIds()).annotations(existing.annotations()).build();
        } else {
            return existing;
        }
    });
    return Objects.nonNull(result);
}
#end_block

#method_before
@Override
public Set<DeviceId> txDeviceIds() {
    return Collections.unmodifiableSet(txDeviceIds);
}
#method_after
@Override
public Set<DeviceId> txDeviceIds() {
    return txDeviceIds;
}
#end_block

#method_before
@Override
public Set<DeviceId> rxDeviceIds() {
    return Collections.unmodifiableSet(rxDeviceIds);
}
#method_after
@Override
public Set<DeviceId> rxDeviceIds() {
    return rxDeviceIds;
}
#end_block

#method_before
@Override
public Builder id(OpenstackVtapId id) {
    this.id = checkNotNull(id);
    return this;
}
#method_after
@Override
public Builder id(OpenstackVtapId id) {
    this.id = id;
    return this;
}
#end_block

#method_before
@Override
public Builder type(Type type) {
    this.type = checkNotNull(type);
    return this;
}
#method_after
@Override
public Builder type(Type type) {
    this.type = type;
    return this;
}
#end_block

#method_before
@Override
public Builder vtapCriterion(OpenstackVtapCriterion vtapCriterion) {
    this.vtapCriterion = checkNotNull(vtapCriterion);
    return this;
}
#method_after
@Override
public Builder vtapCriterion(OpenstackVtapCriterion vtapCriterion) {
    this.vtapCriterion = vtapCriterion;
    return this;
}
#end_block

#method_before
@Override
public Builder annotations(SparseAnnotations annotations) {
    this.annotations = checkNotNull(annotations);
    return this;
}
#method_after
@Override
public Builder annotations(SparseAnnotations annotations) {
    this.annotations = annotations;
    return this;
}
#end_block

#method_before
@Override
public DefaultOpenstackVtap build() {
    return new DefaultOpenstackVtap(id, type, vtapCriterion, txDeviceIds, rxDeviceIds, annotations);
}
#method_after
@Override
public DefaultOpenstackVtap build() {
    return new DefaultOpenstackVtap(checkNotNull(id), checkNotNull(type), checkNotNull(vtapCriterion), txDeviceIds, rxDeviceIds, checkNotNull(annotations));
}
#end_block

#method_before
@Override
public Builder mode(Mode mode) {
    this.mode = checkNotNull(mode);
    return this;
}
#method_after
@Override
public Builder mode(Mode mode) {
    this.mode = mode;
    return this;
}
#end_block

#method_before
@Override
public Builder serverIp(IpAddress serverIp) {
    this.serverIp = checkNotNull(serverIp);
    return this;
}
#method_after
@Override
public Builder serverIp(IpAddress serverIp) {
    this.serverIp = serverIp;
    return this;
}
#end_block

#method_before
@Override
public Builder annotations(SparseAnnotations annotations) {
    this.annotations = checkNotNull(annotations);
    return this;
}
#method_after
@Override
public Builder annotations(SparseAnnotations annotations) {
    this.annotations = annotations;
    return this;
}
#end_block

#method_before
@Override
public DefaultOpenstackVtapNetwork build() {
    return new DefaultOpenstackVtapNetwork(mode, networkId, serverIp, annotations);
}
#method_after
@Override
public DefaultOpenstackVtapNetwork build() {
    return new DefaultOpenstackVtapNetwork(checkNotNull(mode), networkId, checkNotNull(serverIp), checkNotNull(annotations));
}
#end_block

#method_before
void doTheMagic(List<CharSequence> nodes) {
    Document doc;
    try {
        doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
    } catch (ParserConfigurationException e) {
        printlog("Unexpected error", e);
        throw new IllegalStateException(e);
    }
    // netconf rpc boilerplate part without message-id
    Element rpc = doc.createElementNS("urn:ietf:params:xml:ns:netconf:base:1.0", "rpc");
    doc.appendChild(rpc);
    Element editConfig = doc.createElement("edit-config");
    rpc.appendChild(editConfig);
    Element target = doc.createElement("target");
    editConfig.appendChild(target);
    target.appendChild(doc.createElement("running"));
    Element config = doc.createElement("config");
    config.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xc", "urn:ietf:params:xml:ns:netconf:base:1.0");
    editConfig.appendChild(config);
    for (CharSequence node : nodes) {
        Document ldoc = toDocument(CharSource.wrap(node));
        if (null == ldoc) {
            continue;
        }
        Element cfgRoot = ldoc.getDocumentElement();
        // is everything as merge, ok?
        cfgRoot.setAttribute("xc:operation", "merge");
        // move (or copy) node to another Document
        config.appendChild(Optional.ofNullable(doc.adoptNode(cfgRoot)).orElseGet(() -> doc.importNode(cfgRoot, true)));
    // don't have good use for JSON for now
    // JsonNode json = toJsonNode(toJsonCompositeStream(toCompositeData(toResourceData(resourceId, node))));
    // printlog("JSON:\n{}", toCharSequence(json));
    }
    printlog("XML:\n{}", XmlString.prettifyXml(toCharSequence(doc)));
    // TODO if deviceId is given send it out to the device
    if (uri != null) {
        DeviceId deviceId = DeviceId.deviceId(uri);
        NetconfController ctr = get(NetconfController.class);
        Optional.ofNullable(ctr.getNetconfDevice(deviceId)).map(NetconfDevice::getSession).ifPresent(session -> {
            try {
                session.rpc(toCharSequence(doc, false).toString()).join();
            } catch (NetconfException e) {
                log.error("Exception thrown", e);
            }
        });
    }
}
#method_after
void doTheMagic(List<CharSequence> nodes) {
    Document doc;
    try {
        doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
    } catch (ParserConfigurationException e) {
        printlog("Unexpected error", e);
        throw new IllegalStateException(e);
    }
    // netconf rpc boilerplate part without message-id
    Element rpc = doc.createElementNS("urn:ietf:params:xml:ns:netconf:base:1.0", "rpc");
    doc.appendChild(rpc);
    Element editConfig = doc.createElement("edit-config");
    rpc.appendChild(editConfig);
    Element target = doc.createElement("target");
    editConfig.appendChild(target);
    target.appendChild(doc.createElement("running"));
    Element config = doc.createElement("config");
    config.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xc", "urn:ietf:params:xml:ns:netconf:base:1.0");
    editConfig.appendChild(config);
    for (CharSequence node : nodes) {
        Document ldoc = toDocument(CharSource.wrap(node));
        if (ldoc != null) {
            Element cfgRoot = ldoc.getDocumentElement();
            // is everything as merge, ok?
            cfgRoot.setAttribute("xc:operation", "merge");
            // move (or copy) node to another Document
            config.appendChild(Optional.ofNullable(doc.adoptNode(cfgRoot)).orElseGet(() -> doc.importNode(cfgRoot, true)));
        // don't have good use for JSON for now
        // JsonNode json = toJsonNode(toJsonCompositeStream(toCompositeData(toResourceData(resourceId, node))));
        // printlog("JSON:\n{}", toCharSequence(json));
        }
    }
    printlog("XML:\n{}", XmlString.prettifyXml(toCharSequence(doc)));
    // TODO if deviceId is given send it out to the device
    if (uri != null) {
        DeviceId deviceId = DeviceId.deviceId(uri);
        NetconfController ctr = get(NetconfController.class);
        Optional.ofNullable(ctr.getNetconfDevice(deviceId)).map(NetconfDevice::getSession).ifPresent(session -> {
            try {
                session.rpc(toCharSequence(doc, false).toString()).join();
            } catch (NetconfException e) {
                log.error("Exception thrown", e);
            }
        });
    }
}
#end_block

#method_before
@Override
public void runPostOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rl.uriForYangRuntime(), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (null == dataNodeList || dataNodeList.isEmpty()) {
        log.warn("There is no one Data Node can be proceed.");
        return;
    }
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.createNode(rl.ridForDynConfig(), dataNode);
    } catch (Exception e) {
        if (e.getMessage().startsWith("Requested node already present")) {
            throw new RestconfException("Already exists", e, RestconfError.ErrorTag.DATA_EXISTS, CONFLICT, Optional.of(uri.getPath()));
        } else {
            log.error("ERROR: DynamicConfigService: creating {} with {}", ResourceIds.toInstanceIdentifier(rl.ridForDynConfig()), dataNode, e);
            throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
        }
    }
}
#method_after
@Override
public void runPostOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rl.uriForYangRuntime(), rootNode);
    ResourceId rid = receivedData.resourceId();
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList == null || dataNodeList.isEmpty()) {
        log.warn("There is no one Data Node can be proceed.");
        return;
    }
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    if (rid == null) {
        rid = ResourceId.builder().addBranchPointSchema("/", null).build();
        dataNode = removeTopNode(dataNode);
    }
    try {
        dynamicConfigService.createNode(rl.ridForDynConfig(), dataNode);
    } catch (Exception e) {
        if (e.getMessage().startsWith("Requested node already present")) {
            throw new RestconfException("Already exists", e, RestconfError.ErrorTag.DATA_EXISTS, CONFLICT, Optional.of(uri.getPath()));
        } else {
            log.error("ERROR: DynamicConfigService: creating {} with {}", ResourceIds.toInstanceIdentifier(rl.ridForDynConfig()), dataNode, e);
            throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
        }
    }
}
#end_block

#method_before
@Override
public void runPutOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (null == dataNodeList || dataNodeList.isEmpty()) {
        log.warn("There is no one Data Node can be proceed.");
        return;
    }
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    try {
        /*
             * If the data node already exists, then replace it.
             * Otherwise, create it.
             */
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.replaceNode(parentOf(rl.ridForDynConfig()), dataNode);
        } else {
            dynamicConfigService.createNode(parentOf(rl.ridForDynConfig()), dataNode);
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
    }
}
#method_after
@Override
public void runPutOperationOnDataResource(URI uri, ObjectNode rootNode) throws RestconfException {
    DataResourceLocator rl = DataResourceLocator.newInstance(uri);
    ResourceData receivedData = convertJsonToDataNode(rmLastPathSegment(rl.uriForYangRuntime()), rootNode);
    List<DataNode> dataNodeList = receivedData.dataNodes();
    if (dataNodeList == null || dataNodeList.isEmpty()) {
        log.warn("There is no one Data Node can be proceed.");
        return;
    }
    if (dataNodeList.size() > 1) {
        log.warn("There are more than one Data Node can be proceed: {}", dataNodeList.size());
    }
    DataNode dataNode = dataNodeList.get(0);
    try {
        /*
             * If the data node already exists, then replace it.
             * Otherwise, create it.
             */
        if (dynamicConfigService.nodeExist(rl.ridForDynConfig())) {
            dynamicConfigService.replaceNode(parentOf(rl.ridForDynConfig()), dataNode);
        } else {
            dynamicConfigService.createNode(parentOf(rl.ridForDynConfig()), dataNode);
        }
    } catch (FailedException e) {
        log.error("ERROR: DynamicConfigService: ", e);
        throw new RestconfException("ERROR: DynamicConfigService", e, RestconfError.ErrorTag.OPERATION_FAILED, INTERNAL_SERVER_ERROR, Optional.of(uri.getPath()));
    }
}
#end_block

#method_before
public static ONOSLLDP onosLLDP(String deviceId, ChassisId chassisId, int portNum, String portDesc, String secret) {
    ONOSLLDP probe = onosLLDP(deviceId, chassisId, portNum, secret);
    if (portDesc != null && !portDesc.isEmpty()) {
        byte[] bPortDesc = portDesc.getBytes(StandardCharsets.UTF_8);
        if (bPortDesc.length > LLDPTLV.MAX_LENGTH) {
            bPortDesc = Arrays.copyOf(bPortDesc, LLDPTLV.MAX_LENGTH);
        }
        LLDPTLV portDescTlv = new LLDPTLV().setType(PORT_DESC_TLV_TYPE).setLength((short) bPortDesc.length).setValue(bPortDesc);
        probe.addOptionalTLV(portDescTlv);
    }
    return probe;
}
#method_after
@Deprecated
public static ONOSLLDP onosLLDP(String deviceId, ChassisId chassisId, int portNum) {
    ONOSLLDP probe = new ONOSLLDP(NAME_SUBTYPE, DEVICE_SUBTYPE);
    probe.setPortId(portNum);
    probe.setDevice(deviceId);
    probe.setChassisId(chassisId);
    return probe;
}
#end_block

#method_before
public static ONOSLLDP onosLLDP(String deviceId, ChassisId chassisId, int portNum, String secret) {
    ONOSLLDP probe = null;
    if (secret == null) {
        probe = new ONOSLLDP(NAME_SUBTYPE, DEVICE_SUBTYPE);
    } else {
        probe = new ONOSLLDP(NAME_SUBTYPE, DEVICE_SUBTYPE, TIMESTAMP_SUBTYPE, SIG_SUBTYPE);
    }
    probe.setPortId(portNum);
    probe.setDevice(deviceId);
    probe.setChassisId(chassisId);
    if (secret != null) {
        /* Secure Mode */
        long ts = System.currentTimeMillis();
        probe.setTimestamp(ts);
        byte[] sig = createSig(deviceId, portNum, ts, secret);
        if (sig == null) {
            return null;
        }
        probe.setSig(sig);
        sig = null;
    }
    return probe;
}
#method_after
@Deprecated
public static ONOSLLDP onosLLDP(String deviceId, ChassisId chassisId, int portNum, String portDesc) {
    ONOSLLDP probe = onosLLDP(deviceId, chassisId, portNum);
    addPortDesc(probe, portDesc);
    return probe;
}
#end_block

#method_before
private ONOSLLDP getLinkProbe(Long portNumber, String portDesc) {
    return ONOSLLDP.onosLLDP(device.id().toString(), device.chassisId(), portNumber.intValue(), portDesc, context.lldpSecret());
}
#method_after
private ONOSLLDP getLinkProbe(Long portNumber, String portDesc) {
    return ONOSLLDP.onosSecureLLDP(device.id().toString(), device.chassisId(), portNumber.intValue(), portDesc, context.lldpSecret());
}
#end_block

#method_before
@Override
public String lldpSecret() {
    if (clusterMetadataService == null) {
        return null;
    }
    return clusterMetadataService.getClusterMetadata().getLldpSecret();
}
#method_after
@Override
public String lldpSecret() {
    return clusterMetadataService.getClusterMetadata().getClusterSecret();
}
#end_block

#method_before
private ClusterMetadataPrototype toPrototype(ClusterMetadata metadata) {
    ClusterMetadataPrototype prototype = new ClusterMetadataPrototype();
    prototype.setName(metadata.getName());
    prototype.setController(metadata.getNodes().stream().map(this::toPrototype).collect(Collectors.toSet()));
    prototype.setStorage(metadata.getStorageNodes().stream().map(this::toPrototype).collect(Collectors.toSet()));
    prototype.setLldpSecret(metadata.getLldpSecret());
    return prototype;
}
#method_after
private ClusterMetadataPrototype toPrototype(ClusterMetadata metadata) {
    ClusterMetadataPrototype prototype = new ClusterMetadataPrototype();
    prototype.setName(metadata.getName());
    prototype.setController(metadata.getNodes().stream().map(this::toPrototype).collect(Collectors.toSet()));
    prototype.setStorage(metadata.getStorageNodes().stream().map(this::toPrototype).collect(Collectors.toSet()));
    prototype.setClusterSecret(metadata.getClusterSecret());
    return prototype;
}
#end_block

#method_before
private Versioned<ClusterMetadata> fetchMetadata(String metadataUrl) {
    try {
        URL url = new URL(metadataUrl);
        ClusterMetadataPrototype metadata = null;
        long version = 0;
        if ("file".equals(url.getProtocol())) {
            File file = new File(metadataUrl.replaceFirst("file://", ""));
            version = file.lastModified();
            metadata = mapper.readValue(new FileInputStream(file), ClusterMetadataPrototype.class);
        } else if ("http".equals(url.getProtocol())) {
            try {
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                if (conn.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {
                    log.warn("Could not reach metadata URL {}. Retrying...", url);
                    return null;
                }
                if (conn.getResponseCode() == HttpURLConnection.HTTP_NO_CONTENT) {
                    return null;
                }
                version = conn.getLastModified();
                metadata = mapper.readValue(conn.getInputStream(), ClusterMetadataPrototype.class);
            } catch (IOException e) {
                log.warn("Could not reach metadata URL {}. Retrying...", url);
                return null;
            }
        }
        if (null == metadata) {
            log.warn("Metadata is null in the function fetchMetadata");
            throw new NullPointerException();
        }
        return new Versioned<>(new ClusterMetadata(PROVIDER_ID, metadata.getName(), metadata.getNode() != null ? new DefaultControllerNode(getNodeId(metadata.getNode()), getNodeHost(metadata.getNode()), getNodePort(metadata.getNode())) : null, metadata.getController().stream().map(node -> new DefaultControllerNode(getNodeId(node), getNodeHost(node), getNodePort(node))).collect(Collectors.toSet()), metadata.getStorage().stream().map(node -> new DefaultControllerNode(getNodeId(node), getNodeHost(node), getNodePort(node))).collect(Collectors.toSet()), metadata.getLldpSecret()), version);
    } catch (IOException e) {
        throw new IllegalArgumentException(e);
    }
}
#method_after
private Versioned<ClusterMetadata> fetchMetadata(String metadataUrl) {
    try {
        URL url = new URL(metadataUrl);
        ClusterMetadataPrototype metadata = null;
        long version = 0;
        if ("file".equals(url.getProtocol())) {
            File file = new File(metadataUrl.replaceFirst("file://", ""));
            version = file.lastModified();
            metadata = mapper.readValue(new FileInputStream(file), ClusterMetadataPrototype.class);
        } else if ("http".equals(url.getProtocol())) {
            try {
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                if (conn.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {
                    log.warn("Could not reach metadata URL {}. Retrying...", url);
                    return null;
                }
                if (conn.getResponseCode() == HttpURLConnection.HTTP_NO_CONTENT) {
                    return null;
                }
                version = conn.getLastModified();
                metadata = mapper.readValue(conn.getInputStream(), ClusterMetadataPrototype.class);
            } catch (IOException e) {
                log.warn("Could not reach metadata URL {}. Retrying...", url);
                return null;
            }
        }
        if (null == metadata) {
            log.warn("Metadata is null in the function fetchMetadata");
            throw new NullPointerException();
        }
        return new Versioned<>(new ClusterMetadata(PROVIDER_ID, metadata.getName(), metadata.getNode() != null ? new DefaultControllerNode(getNodeId(metadata.getNode()), getNodeHost(metadata.getNode()), getNodePort(metadata.getNode())) : null, metadata.getController().stream().map(node -> new DefaultControllerNode(getNodeId(node), getNodeHost(node), getNodePort(node))).collect(Collectors.toSet()), metadata.getStorage().stream().map(node -> new DefaultControllerNode(getNodeId(node), getNodeHost(node), getNodePort(node))).collect(Collectors.toSet()), metadata.getClusterSecret()), version);
    } catch (IOException e) {
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@Override
public String lldpSecret() {
    return metadataService.getClusterMetadata().getLldpSecret();
}
#method_after
@Override
public String lldpSecret() {
    return metadataService.getClusterMetadata().getClusterSecret();
}
#end_block

#method_before
private boolean verify(PacketContext packetContext) {
    Ethernet eth = packetContext.inPacket().parsed();
    if (eth == null) {
        return false;
    }
    ONOSLLDP onoslldp = ONOSLLDP.parseONOSLLDP(eth);
    if (onoslldp != null) {
        if (!notMy(eth.getSourceMAC().toString())) {
            return false;
        }
        if (!ONOSLLDP.verify(onoslldp, context.lldpSecret(), context.maxDiscoveryDelay())) {
            log.warn("LLDP Packet failed to validate!");
            return false;
        }
        return true;
    }
    return false;
}
#method_after
private boolean verify(PacketContext packetContext) {
    Ethernet eth = packetContext.inPacket().parsed();
    if (eth == null) {
        return false;
    }
    ONOSLLDP onoslldp = ONOSLLDP.parseONOSLLDP(eth);
    if (onoslldp != null) {
        if (!isOthercluster(eth.getSourceMAC().toString())) {
            return false;
        }
        if (!ONOSLLDP.verify(onoslldp, context.lldpSecret(), context.maxDiscoveryDelay())) {
            log.warn("LLDP Packet failed to validate!");
            return false;
        }
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public InboundPacket inPacket() {
    ONOSLLDP lldp = ONOSLLDP.onosLLDP(deviceService.getDevice(DID1).id().toString(), device.chassisId(), (int) pd1.number().toLong(), "", "test");
    Ethernet ethPacket = new Ethernet();
    ethPacket.setEtherType(Ethernet.TYPE_LLDP);
    ethPacket.setDestinationMACAddress(MacAddress.ONOS_LLDP);
    ethPacket.setPayload(lldp);
    ethPacket.setPad(true);
    ethPacket.setSourceMACAddress("DE:AD:BE:EF:BA:11");
    ConnectPoint cp = new ConnectPoint(device.id(), pd3.number());
    return new DefaultInboundPacket(cp, ethPacket, ByteBuffer.wrap(ethPacket.serialize()));
}
#method_after
@Override
public InboundPacket inPacket() {
    ONOSLLDP lldp = ONOSLLDP.onosSecureLLDP(deviceService.getDevice(DID1).id().toString(), device.chassisId(), (int) pd1.number().toLong(), "", "test");
    Ethernet ethPacket = new Ethernet();
    ethPacket.setEtherType(Ethernet.TYPE_LLDP);
    ethPacket.setDestinationMACAddress(MacAddress.ONOS_LLDP);
    ethPacket.setPayload(lldp);
    ethPacket.setPad(true);
    ethPacket.setSourceMACAddress("DE:AD:BE:EF:BA:11");
    ConnectPoint cp = new ConnectPoint(device.id(), pd3.number());
    return new DefaultInboundPacket(cp, ethPacket, ByteBuffer.wrap(ethPacket.serialize()));
}
#end_block

#method_before
@Override
public InboundPacket inPacket() {
    ONOSLLDP lldp = ONOSLLDP.onosLLDP(deviceService.getDevice(DID1).id().toString(), device.chassisId(), (int) pd1.number().toLong(), "", "test");
    Ethernet ethPacket = new Ethernet();
    ethPacket.setEtherType(Ethernet.TYPE_LLDP);
    ethPacket.setDestinationMACAddress(MacAddress.ONOS_LLDP);
    ethPacket.setPayload(lldp);
    ethPacket.setPad(true);
    ethPacket.setSourceMACAddress("DE:AD:BE:EF:BA:11");
    ConnectPoint cp = new ConnectPoint(device.id(), pd3.number());
    return new DefaultInboundPacket(cp, ethPacket, ByteBuffer.wrap(ethPacket.serialize()));
}
#method_after
@Override
public InboundPacket inPacket() {
    ONOSLLDP lldp = ONOSLLDP.onosSecureLLDP(deviceService.getDevice(DID1).id().toString(), device.chassisId(), (int) pd1.number().toLong(), "", "test");
    Ethernet ethPacket = new Ethernet();
    ethPacket.setEtherType(Ethernet.TYPE_LLDP);
    ethPacket.setDestinationMACAddress(MacAddress.ONOS_LLDP);
    ethPacket.setPayload(lldp);
    ethPacket.setPad(true);
    ethPacket.setSourceMACAddress("DE:AD:BE:EF:BA:11");
    ConnectPoint cp = new ConnectPoint(device.id(), pd3.number());
    return new DefaultInboundPacket(cp, ethPacket, ByteBuffer.wrap(ethPacket.serialize()));
}
#end_block

#method_before
@Override
public InboundPacket inPacket() {
    ONOSLLDP lldp = ONOSLLDP.onosLLDP(src.deviceId().toString(), new ChassisId(), (int) src.port().toLong(), "", "test-secret");
    Ethernet ethPacket = new Ethernet();
    ethPacket.setEtherType(Ethernet.TYPE_LLDP);
    ethPacket.setDestinationMACAddress(MacAddress.ONOS_LLDP);
    ethPacket.setPayload(lldp);
    ethPacket.setPad(true);
    ethPacket.setSourceMACAddress("DE:AD:BE:EF:BA:11");
    return new DefaultInboundPacket(dst, ethPacket, ByteBuffer.wrap(ethPacket.serialize()));
}
#method_after
@Override
public InboundPacket inPacket() {
    ONOSLLDP lldp = ONOSLLDP.onosSecureLLDP(src.deviceId().toString(), new ChassisId(), (int) src.port().toLong(), "", "test-secret");
    Ethernet ethPacket = new Ethernet();
    ethPacket.setEtherType(Ethernet.TYPE_LLDP);
    ethPacket.setDestinationMACAddress(MacAddress.ONOS_LLDP);
    ethPacket.setPayload(lldp);
    ethPacket.setPad(true);
    ethPacket.setSourceMACAddress("DE:AD:BE:EF:BA:11");
    return new DefaultInboundPacket(dst, ethPacket, ByteBuffer.wrap(ethPacket.serialize()));
}
#end_block

#method_before
@Override
public Set<Class<?>> getClasses() {
    return getClasses(ApiDocResource.class, ApplicationsWebResource.class, ComponentConfigWebResource.class, NetworkConfigWebResource.class, ClusterWebResource.class, DevicesWebResource.class, LinksWebResource.class, HostsWebResource.class, IntentsWebResource.class, FlowsWebResource.class, GroupsWebResource.class, MetersWebResource.class, TopologyWebResource.class, PathsWebResource.class, StatisticsWebResource.class, MetricsWebResource.class, FlowObjectiveWebResource.class, MulticastRouteWebResource.class, DeviceKeyWebResource.class, RegionsWebResource.class, TenantWebResource.class, VirtualNetworkWebResource.class, MastershipWebResource.class, InvalidConfigExceptionMapper.class, DpisWebResource.class, DiagnosticsWebResource.class, UiPreferencesWebResource.class, SystemInfoWebResource.class, PktProcessorsWebResource.class);
}
#method_after
@Override
public Set<Class<?>> getClasses() {
    return getClasses(ApiDocResource.class, ApplicationsWebResource.class, ComponentConfigWebResource.class, NetworkConfigWebResource.class, ClusterWebResource.class, DevicesWebResource.class, LinksWebResource.class, HostsWebResource.class, IntentsWebResource.class, FlowsWebResource.class, GroupsWebResource.class, MetersWebResource.class, TopologyWebResource.class, PathsWebResource.class, StatisticsWebResource.class, MetricsWebResource.class, FlowObjectiveWebResource.class, MulticastRouteWebResource.class, DeviceKeyWebResource.class, RegionsWebResource.class, TenantWebResource.class, VirtualNetworkWebResource.class, MastershipWebResource.class, InvalidConfigExceptionMapper.class, DpisWebResource.class, DiagnosticsWebResource.class, UiPreferencesWebResource.class, SystemInfoWebResource.class, PacketProcessorsWebResource.class);
}
#end_block

